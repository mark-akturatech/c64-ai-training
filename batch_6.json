[{"id": "map-B08B", "address_start": 45195, "address_end": 45195, "hex_start": "$B08B", "hex_end": "$B08B", "label": "PTRGET", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45195         $B08B          PTRGET\nSearch for a Variable and Set It Up If It Is Not Found\n\nThis routine attempts to locate a variable by searching for its name\nin the variable area.  If an existing variable of that name cannot be\nfound, one is created with the NOTFNS routine below."}, {"id": "map-B113", "address_start": 45331, "address_end": 45331, "hex_start": "$B113", "hex_end": "$B113", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45331         $B113\nCheck If .A Register Holds Alphabetic ASCII Character\n\nThis is part of the check for a valid variable name (it must start\nwith an alphabetic character)."}, {"id": "map-B11D", "address_start": 45341, "address_end": 45341, "hex_start": "$B11D", "hex_end": "$B11D", "label": "NOTFNS", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45341         $B11D          NOTFNS\nCreate a New BASIC Variable\n\nThis routine makes space for a seven-byte descriptor by moving the\nvariable storage area seven bytes higher in memory, and then creates\nthe descriptor."}, {"id": "map-B185", "address_start": 45445, "address_end": 45445, "hex_start": "$B185", "hex_end": "$B185", "label": "FINPTR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45445         $B185          FINPTR\nReturn the Address of the Variable That Was Found or Created\n\nThis routine stores the address of the variable that was found or\ncreated by the preceding routines in a pointer at 71-72 ($47-$48)."}, {"id": "map-B194", "address_start": 45460, "address_end": 45460, "hex_start": "$B194", "hex_end": "$B194", "label": "ARYGET", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45460         $B194          ARYGET\nAllocate Space for Array Descriptors\n\nThis routine allocates five bytes plus two bytes for every dimension\nspecified for the array descriptor."}, {"id": "map-B1A5", "address_start": 45477, "address_end": 45477, "hex_start": "$B1A5", "hex_end": "$B1A5", "label": "N32768", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45477         $B1A5          N32768\nThe Constant -32768 in Five-Byte Floating Point Format\n\nThis constant is used for range checking in the conversion of a\nfloating point number to a signed integer (the minimum inter value is\n-32768)."}, {"id": "map-B1AA", "address_start": 45482, "address_end": 45482, "hex_start": "$B1AA", "hex_end": "$B1AA", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45482         $B1AA\nConvert a Floating Point Number to a Signed Integer in .A and .Y Registers\n\nThis subroutine calls AYINT, below, which checks to make sure that the\nnumber in the Floating Point Accumulator is between 32767 and -32768,\nand converts it to a 16-bit signed integer in 100-101 ($64-$65), high\nbyte first.  It leaves the high byte of the integer in the\nAccumulator, and the low byte in the .Y register.\n\nAlthough this routine does not appear to be referenced anywhere in\nBASIC, the vector at locations 3-4 points to its address.  Presumably,\nit is provided for the benefit of the user who wishes to pass\nparameters in a USR call, or the like."}, {"id": "map-B1B2", "address_start": 45490, "address_end": 45490, "hex_start": "$B1B2", "hex_end": "$B1B2", "label": "INTIDX", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45490         $B1B2          INTIDX\nInput and Convert a Floating Point Subscript to a Positive Integer\n\nThis routine converts a floating point subscript value to an integer,\nmaking sure first that it is positive."}, {"id": "map-B1BF", "address_start": 45503, "address_end": 45503, "hex_start": "$B1BF", "hex_end": "$B1BF", "label": "AYINT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45503         $B1BF          AYINT\nConvert a Floating Point Number to a Signed Integer\n\nThis subroutine first checks to make sure that the number in the\nFloating Point Accumulator is between 32767 and -32768.  If it is not,\nan ILLEGAL QUANTITY error results.  If it is, the routine converts it\nto a 16-bit signed integer with the high byte in location 100 ($64),\nand the low byte in location 101 ($65)."}, {"id": "map-B1D1", "address_start": 45521, "address_end": 45521, "hex_start": "$B1D1", "hex_end": "$B1D1", "label": "ISARY", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45521         $B1D1          ISARY\nFind Array Element or Create New Array in RAM\n\nThis routine searches for an array.  If it is found, the subscript\nvalue is checked to see if it is valid, and pointers to the array and\nelement of the array are set.  If it is not found, the array is\ncreated, and the pointers set."}, {"id": "map-B245", "address_start": 45637, "address_end": 45637, "hex_start": "$B245", "hex_end": "$B245", "label": "BSERR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45637         $B245          BSERR\nPrint BAD SUBSCRIPT Error Message"}, {"id": "map-B248", "address_start": 45640, "address_end": 45640, "hex_start": "$B248", "hex_end": "$B248", "label": "FCERR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45640         $B248          FCERR\nPrint ILLEGAL QUANTITY Error Message"}, {"id": "map-B34C", "address_start": 45900, "address_end": 45900, "hex_start": "$B34C", "hex_end": "$B34C", "label": "UMULT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45900         $B34C          UMULT\nCompute the Size of a Multidimensional Array\n\nThis routine calculates the size of a multidimensional array by\nmultiplying the dimensions."}, {"id": "map-B37D", "address_start": 45949, "address_end": 45949, "hex_start": "$B37D", "hex_end": "$B37D", "label": "FRE", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45949         $B37D          FRE\nPerform FRE\n\nThe FRE function calls the garbage collection routine at 46374 ($B526)\nto get rid of unused string text, and calculates the difference\nbetween the bottom of string text and the top of array storage.  It\nthen drops through to the follow routine, which assumes that the free\nmemory value is a 16-bit signed integer, and converts it to floating\npoint accordingly.\n\nOf course, while the free memory space on the PET might have always\nbeen 32767 or less (the maximum value of a signed integer), sich is\ndefinitely not the case on the 64.  Because conversion is from a\nsigned integer, any memory value over 32767 will be regarded as\nnegative (the high bit is treated as a sign bit).  Therefore, for\nthese higher values you must add twice the bit value of the high bit\n(65536) in order to come up with the correct value.  The expression\nFRE(0)-6556*(FRE(0)<0) will always return the correct amount of free\nmemory."}, {"id": "map-B391", "address_start": 45969, "address_end": 45969, "hex_start": "$B391", "hex_end": "$B391", "label": "GIVAYF", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45969         $B391          GIVAYF\nConvert 16-Bit Signed Integer to Floating Point\n\nThis routine treats the value in the Accumulator as the high byte of a\n16-bit signed integer, and the value in the .Y register as the low\nbyte, and converts the signed integer into a floating point number in\nthe Floating Point Accumulator.\n\nThe address of this routine is pointed to by the RAM vector at 5-6,\nand the routine can be used to return an argument from the USR call in\nthe Floating Point Accumulator."}, {"id": "map-B39E", "address_start": 45982, "address_end": 45982, "hex_start": "$B39E", "hex_end": "$B39E", "label": "POS", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45982         $B39E          POS\nPerform POS\n\nThe POS command calls the Kernal PLOT routine (58634, $E50A) to get\nthe position of the cursor on the logical line.  What it really does\nis an equivalent of PEEK(211).  Remember, since we are dealing with a\nlogical line, this number can be over 39.  The statement \"THIS\nSENTENCE IS LONGER THAN ONE PHYSICAL LINE\";POS(X) will return a value\nof 48 for the POS(X)."}, {"id": "map-B3A6", "address_start": 45990, "address_end": 45990, "hex_start": "$B3A6", "hex_end": "$B3A6", "label": "ERRDIR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45990         $B3A6          ERRDIR\nCheck If the Program is Running in Direct Mode, and If So Issue an Error\n\nThis routine is called by statements that prohibit execution in direct\nmode.  It checks a flag that is set when a line without a linenumber\nis entered, and causes an ILLEGAL DIRECT error if the flag is set."}, {"id": "map-B3B3", "address_start": 46003, "address_end": 46003, "hex_start": "$B3B3", "hex_end": "$B3B3", "label": "DEF", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46003         $B3B3          DEF\nPerform DEF\n\nDEF performs some syntax checking, and pushes five bytes onto the\nstack:  the first byte of the function statement, a two-byte pointer\nto the dependent variable (the X in FN(X)), and the address of the\nfirst character of the definition itself, where it resides in the\nprogram text.\n\nThe DEF statement must fit on one line, but functions can be extended\nby nesting them (having one function call another)."}, {"id": "map-B3E1", "address_start": 46049, "address_end": 46049, "hex_start": "$B3E1", "hex_end": "$B3E1", "label": "GETFNM", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46049         $B3E1          GETFNM\nCheck DEF and FN Syntax\n\nThis routine checks to make sure that FN follow SEG, and that the\ndependent variable has a valid floating point variable name.  It calls\nthe routine to find or create a variable to get the pointer to its\naddress."}, {"id": "map-B3F4", "address_start": 46068, "address_end": 46068, "hex_start": "$B3F4", "hex_end": "$B3F4", "label": "FNDOER", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46068         $B3F4          FNDOER\nPerform FN\n\nThe FN evaluation is done by evaluating the FN argument (for example,\nFN(A+B*C/D)) and then getting the rest of the expression from the text\nof the function definition statement.  The function variable\ndescriptor area is used as a work area, and the dependent variable is\nnot disturbed (so that if the definition used FN(X), the value of X\nwill not be changed by the function call)."}, {"id": "map-B465", "address_start": 46181, "address_end": 46181, "hex_start": "$B465", "hex_end": "$B465", "label": "STRD", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46181         $B465          STRD\nPerform STR$\n\nSTR$ first checks to make sure that the parameter is a number, and\nthen calls the routines that convert floating point to ASCII and crate\nthe pointers to a string constant."}, {"id": "map-B487", "address_start": 46215, "address_end": 46215, "hex_start": "$B487", "hex_end": "$B487", "label": "STRLIT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46215         $B487          STRLIT\nScan and Set Up Pointers to a String in Memory\n\nThis routine calculates the length of the string, and calls the\nroutine that allocates space in memory.  It then saves the string, or\ncreates a pointer to its location in the BASIC text input buffer at\n512 ($200)."}, {"id": "map-B4F4", "address_start": 46324, "address_end": 46324, "hex_start": "$B4F4", "hex_end": "$B4F4", "label": "GETSPA", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46324         $B4F4          GETSPA\nAllocate Space in Memory for String\n\nThe amount of space needed for a string is passed to this routine, and\nthe routine checks if there is that amount of space available in free\nmemory.  If not, it does a garbage collection and tries again."}, {"id": "map-B526", "address_start": 46374, "address_end": 46374, "hex_start": "$B526", "hex_end": "$B526", "label": "GARBAG", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46374         $B526          GARBAG\nString Garbage Collection\n\nWhenever a string is changed in any way, the revised version of the\ntext is added to the bottom of the string text area, leaving the old\nversion higher up in memory, wasting space.\n\nIn order to reclaim that space, the descriptor for every string whose\ntext is in the string text area (rather than in the program text area)\nmust be searched to find the valid text that is highest in memory.  If\nthat string is not as high as it could be, it is moved up to replace\nany string that is no longer valid.  Then all of the string\ndescriptors must be searched again to find the next highest string and\nmove it up.  This continues until every string that is un use has been\ncovered.  After all have been moved up, the pointer to the bottom of\nstring text at 51-52 ($33-$34) is changed to show the new bottom\nlocation.\n\nIf there are more than a few strings whose text is in the string text\nstorage area, rather than in the body of the program, scanning every\nstring as many times as there are strings can take an awful lot of\ntime.  The computer may seem as if it had died (the STOP key is not\neven checked during the procedure).\n\nThe collection will take about as long whether there is any spare\nspace or not; the full collection will be done even if it is done\nimmediately after the last collection.  Although the increased memory\ncapacity of the 64 helps to forestall the need for garbage collection,\na large program with many string arrays may still experience lengthy\ncollection delays."}, {"id": "map-B5BD", "address_start": 46525, "address_end": 46525, "hex_start": "$B5BD", "hex_end": "$B5BD", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46525         $B5BD\nCheck for Most Eligible String to Collect\n\nThis part of the garbage collection routine checks to see if the\ncurrent string is the highest in memory."}, {"id": "map-B606", "address_start": 46598, "address_end": 46598, "hex_start": "$B606", "hex_end": "$B606", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46598         $B606\nCollect a String\n\nThis part of the garbage collection routine moves the string to high\nmemory and updates the descriptor to point to its new location."}, {"id": "map-B63D", "address_start": 46653, "address_end": 46653, "hex_start": "$B63D", "hex_end": "$B63D", "label": "CAT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46653         $B63D          CAT\nConcatenate Two Strings\n\nThis routine is used to add the text of one string onto the end of\nanother (A$+B$).  Error checking is done to see if the length of the\ncombined string is within range, the allocation routine is called to\nallocate space, and the new string is built at the bottom of the\nstring text area."}, {"id": "map-B67A", "address_start": 46714, "address_end": 46714, "hex_start": "$B67A", "hex_end": "$B67A", "label": "MOVINS", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46714         $B67A          MOVINS\nMove a String in Memory\n\nThis is the routine which is used to move a string to the bottom of\nthe string text area for the above routine.  It is generally used as a\nutility routine to move strings."}, {"id": "map-B6A3", "address_start": 46755, "address_end": 46755, "hex_start": "$B6A3", "hex_end": "$B6A3", "label": "FRESTR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46755         $B6A3          FRESTR\nDiscard a Temporary String\n\nThis routine calls the following routine which clears an entry from\nthe temporary descriptor stack.  If the descriptor was on the stack,\nit exits after setting pointers to the string and its length.  If it\nwasn't on the temporary stack and is at the bottom of string text\nstorage, the pointer to the bottom is moved up to deallocate the\nstring."}, {"id": "map-B6DB", "address_start": 46811, "address_end": 46811, "hex_start": "$B6DB", "hex_end": "$B6DB", "label": "FRETMS", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46811         $B6DB          FRETMS\nRemove an Entry from the String Descriptor Stack\n\nIf the descriptor of a currently valid string is the same as one of\nthe entries on the temporary string descriptor stack, the stack entry\nis removed."}, {"id": "map-B6EC", "address_start": 46828, "address_end": 46828, "hex_start": "$B6EC", "hex_end": "$B6EC", "label": "CHRD", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46828         $B6EC          CHRD\nPerform CHR$\n\nThe CHR$ routine creates a descriptor on the temporary string stack\nfor the one-byte string whose value is specified in the command, and\nsets a pointer to that string."}, {"id": "map-B700", "address_start": 46848, "address_end": 46848, "hex_start": "$B700", "hex_end": "$B700", "label": "LEFTD", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46848         $B700          LEFTD\nPerform LEFT$\n\nLEFT$ creates a temporary string descriptor for a new string which\ncontains the number of characters from the left side of the string\nthat is specified in the command."}, {"id": "map-B72C", "address_start": 46892, "address_end": 46892, "hex_start": "$B72C", "hex_end": "$B72C", "label": "RIGHTD", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46892         $B72C          RIGHTD\nPerform RIGHT$\n\nRIGHT$ manipulates its parameters so that the tail end of LEFT$ can be\nused to create a temporary string descriptor for a new string.  This\nnew string contains the number of characters from the right side of\nthe string that is specified in the command."}, {"id": "map-B737", "address_start": 46903, "address_end": 46903, "hex_start": "$B737", "hex_end": "$B737", "label": "MIDD", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46903         $B737          MIDD\nPerform MID$\n\nMID$ manipulates its parameters so that the tail end of LEFT$ can be\nused to create a temporary string descriptor for a new string.  This\nnew string contains the number of characters from the position in the\nmiddle of the string that is specified in the command."}, {"id": "map-B761", "address_start": 46945, "address_end": 46945, "hex_start": "$B761", "hex_end": "$B761", "label": "PREAM", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46945         $B761          PREAM\nPull String Function Parameters from Stack for LEFT$, RIGHT$, and MID$\n\nThis routine is used to obtain the first two parameters for all three\nof these commands."}, {"id": "map-B77C", "address_start": 46972, "address_end": 46972, "hex_start": "$B77C", "hex_end": "$B77C", "label": "LEN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46972         $B77C          LEN\nPerform LEN\n\nThe LEN function is performed by obtaining the string length from the\ndescriptor and converting it to a floating point number."}, {"id": "map-B78B", "address_start": 46987, "address_end": 46987, "hex_start": "$B78B", "hex_end": "$B78B", "label": "ASC", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "46987         $B78B          ASC\nPerform ASC\n\nThis routine gets the first character of the string in the .Y register\n(if it's not a null string).  Then it calls the part of POS that\nconverts a one- byte integer in .Y to a floating point number."}, {"id": "map-B79B", "address_start": 47003, "address_end": 47003, "hex_start": "$B79B", "hex_end": "$B79B", "label": "GETBYTC", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47003         $B79B          GETBYTC\nInput a Parameter Whose Value Is Between 0 and 255\n\nThis routine reads numeric ASCII program text, converts it to an\ninteger, checks that it is in the range 0-255, and stores it in the .X\nregister.  This routine can be useful for reading parameters from a\nUSR statement or new commands."}, {"id": "map-B7AD", "address_start": 47021, "address_end": 47021, "hex_start": "$B7AD", "hex_end": "$B7AD", "label": "VAL", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47021         $B7AD          VAL\nPerform VAL\n\nThe VAL routine obtains the string pointer, and reads the string one\ncharacter at a time until an invalid character is found (ASCII\nnumbers, sign character, a single decimal point, exponent, and spaces\nare all valid).  Then the string is changed to floating point.  If no\nvalid characters are found, a 0 is returned."}, {"id": "map-B7EB", "address_start": 47083, "address_end": 47083, "hex_start": "$B7EB", "hex_end": "$B7EB", "label": "GETNUM", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47083         $B7EB          GETNUM\nGet a 16-Bit Address Parameter and an 8-Bit Parameter (for POKE and WAIT)\n\nThis routine gets the next numeric parameter from the current place in\nprogram text.  The routine evaluates it, checks that it is a positive\ninteger within the range 0-65535, and changes it from floating point\nto a two-byte integer in 20-21 ($14-$15).  It checks for and skips a\ncomma, then gets a one-byte integer parameter in the .X register.  The\nroutine is used to get the parameters for POKE an WAIT."}, {"id": "map-B7F7", "address_start": 47095, "address_end": 47095, "hex_start": "$B7F7", "hex_end": "$B7F7", "label": "GETADR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47095         $B7F7          GETADR\nConvert a Floating Point Number to an Unsigned Two-Byte Integer\n\nThis routine checks the number in the Floating Point Accumulator to\nmake sure that it is a positive number less than 65536, and then calls\nthe subroutine which conerts floatin point to integer.  It is used to\nget address parameters, for commands such as PEEK."}, {"id": "map-B80D", "address_start": 47117, "address_end": 47117, "hex_start": "$B80D", "hex_end": "$B80D", "label": "PEEK", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47117         $B80D          PEEK\nPerform PEEK\n\nPEEK reads the address parameter and converts it to a pointer.  Then\nit gets the byte pointed to into the .Y register, and calls the part\nof POS that converts a single integer in .Y to a floating point\nnumber."}, {"id": "map-B824", "address_start": 47140, "address_end": 47140, "hex_start": "$B824", "hex_end": "$B824", "label": "POKE", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47140         $B824          POKE\nPerform POKE\n\nPOKE gets a pointer to the address parameter, and stores the next\nparameter there."}, {"id": "map-B82D", "address_start": 47149, "address_end": 47149, "hex_start": "$B82D", "hex_end": "$B82D", "label": "FUWAIT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47149         $B82D          FUWAIT\nPerform WAIT\n\nWAIT gets an address parameter and an integer parameter to use as a\nmask.  WAIT then looks for an optional parameter to use as a pattern\nfor the exclusive OR.  Then, the address location is read, its value\nis exclusive ORed with the optional pattern value (or 0 if there is\nnone).  This value is ANDed with the mask value.  The command loops\ncontinuously until the result is not- zero.\n\nThe purpose of this command is to allow the program to watch a\nlocation which can be changed by the system or by outside hardware\n(such as the software clock or keycode value locations).\n\nThe AND function lets you check if a bit changes from 0 to 1, while\nthe EOR function allows you to check if a bit changes from 1 to 0.\nFor more information, see the article \"All About the Wait\nInstruction,\" by Louis Sander and Doug Ferguson, in COMPUTE!'s First\nBook of Commodore 64."}, {"id": "map-B849", "address_start": 47177, "address_end": 47177, "hex_start": "$B849", "hex_end": "$B849", "label": "FADDH", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47177         $B849          FADDH\nAdd .5 to Contents of Floating Point Accumulator #1"}, {"id": "map-B850", "address_start": 47184, "address_end": 47184, "hex_start": "$B850", "hex_end": "$B850", "label": "FSUB", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47184         $B850          FSUB\nSubtract FAC1 from a Number in Memory\n\nThis routine is used to subtract the Floating Point Accumulator from a\nnumber in memory.  It moves the number in memory into FAC2, and falls\nthrough to the next routine."}, {"id": "map-B853", "address_start": 47187, "address_end": 47187, "hex_start": "$B853", "hex_end": "$B853", "label": "FSUBT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47187         $B853          FSUBT\nBASIC's Subtraction Operation\n\nThis routine subtracts the contents of FAC2 from FAC1 by complementing\nits sign and adding."}, {"id": "map-B867", "address_start": 47207, "address_end": 47207, "hex_start": "$B867", "hex_end": "$B867", "label": "FADD", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47207         $B867          FADD\nAdd FAC1 to a Number in Memory\n\nThis routine is used to add the contents of the Floating Point\nAccumulator (FAC1) to a number in memory, by moving that number into\nFAC2, and falling through to the next routine."}, {"id": "map-B86A", "address_start": 47210, "address_end": 47210, "hex_start": "$B86A", "hex_end": "$B86A", "label": "FADDT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47210         $B86A          FADDT\nPerform BASIC's Addition Operation\n\nThis routine adds the contents of FAC1 and FAC2 and stores the results\nin FAC1."}, {"id": "map-B8A7", "address_start": 47271, "address_end": 47271, "hex_start": "$B8A7", "hex_end": "$B8A7", "label": "FADD4", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47271         $B8A7          FADD4\nMake the Result Negative If a Borrow Was Done"}]