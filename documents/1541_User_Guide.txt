*********

Welcome to Project 64!

The goal of Project 64 is to preserve Commodore 64 related documents
in electronic text format that might otherwise cease to exist with the
rapid advancement of computer technology and declining interest in 8-
bit computers on the part of the general population.

Extensive efforts were made to preserve the contents of the original
document.  However, certain portions, such as diagrams, program
listings, and indexes may have been either altered or sacrificed due
to the limitations of plain vanilla text.  Diagrams may have been
eliminated where ASCII-art was not feasible.  Program listings may be
missing display codes where substitutions were not possible.  Tables
of contents and indexes may have been changed from page number
references to section number references. Please accept our apologies
for these limitations, alterations, and possible omissions.

The author(s) of the original document and members of Project 64 make
no representations about the accuracy or suitability of this material
for any purpose.  This etext is provided "as-is".  Please refer to the
warantee of the original document, if any, that may included in this
etext.  No other warantees, express or implied, are made to you as to
the etext or any medium it may be on.  Neither the author(s) nor the
members of Project 64 will assume liability for damages either from
the direct or indirect use of this etext or from the distribution of
or modification to this etext.

*********

The Project 64 etext of the Commodore 1541 Disk Drive User's Guide,
first edition.  Converted to etext by the Basic Bombardier.  Some
errors in the original document were corrected in this etext.

1541D10A.TXT, January 1996, etext #7

*********

Note: To extract the ascii text basic programs all at once from this
etext use "tok64" by Cris Berneburg <74171.2136@compuserve.com>. Or to
extract the uuencoded basic programs all at once use "uud" by Edwin
Kremer <edwin@zlotty>.

*********

COMMODORE 1541 DISK DRIVE USER'S GUIDE

A Friendly Introduction to Your 1541 Disk Drive
   _____
  /  ___|___
 |  /   |__/  c o m m o d o r e
 |  \___|__\  C O M P U T E R
  \_____|

INFORMATION TO USER

"WARNING: THIS EQUIPMENT HAS BEEN CERTIFIED TO COMPLY WITH THE LIMITS
FOR A CLASS B COMPUTING DEVICE, PURSUANT TO SUBPART J OF PART 15 OF
FCC RULES.  ONLY PERIPHERALS (COMPUTER INPUT/OUTPUT DEVICES, TERMINALS,
PRINTERS, ETC.) CERTIFIED TO COMPLY WITH THE CLASS B LIMITS MAY BE
ATTACHED TO THIS COMPUTER.  OPERATION WITH NON-CERTIFIED PERIPHERALS
IS LIKELY TO RESULT IN INTERFERENCE TO RADIO AND TV RECEPTION."

"THIS EQUIPMENT GENERATES AND USES RADIO FREQUENCY ENERGY AND IF NOT
INSTALLED PROPERLY, THAT IS, IN STRICT ACCORDANCE WITH THE
MANUFACTURER'S INSTRUCTIONS, MAY CAUSE INTERFERENCE TO RADIO AND
TELEVISION RECEPTION.  IT HAS BEEN TYPE TESTED AND FOUND TO COMPLY
WITH THE LIMITS FOR A CLASS B COMPUTING DEVICE IN ACCORDANCE WITH THE
SPECIFICATIONS IN SUBPART J OF PART 15 OF FCC RULES, WHICH ARE
DESIGNED TO PROVIDE REASONABLE PROTECTION AGAINST SUCH INTERFERENCE IN
A RESIDENTIAL INSTALLATION.  HOWEVER, THERE IS NO GUARANTEE THAT
INTERFERENCE WILL NOT OCCUR IN A PARTICULAR INSTALLATION.  IF THIS
EQUIPMENT DOES CAUSE INTERFERENCE TO RADIO OR TELEVISION RECEPTION,
WHICH CAN BE DETERMINED BY TURNING THE EQUIPMENT OFF AND ON, THE USER
IS ENCOURAGED TO TRY TO CORRECT THE INTERFERENCE BY ONE OR MORE OF THE
FOLLOWING MEASURES:

* REORIENT THE RECEIVING ANTENNA

* RELOCATE THE COMPUTER WITH RESPECT TO THE RECEIVER

* MOVE THE COMPUTER AWAY FROM THE RECEIVER

* PLUG THE COMPUTER INTO A DIFFERENT OUTLET SO THAT COMPUTER AND
RECEIVER ARE ON DIFFERENT BRANCH CIRCUITS

"IF NECESSARY, THE USER SHOULD CONSULT THE DEALER OR AN EXPERIENCED
RADIO/TELEVISION TECHNICIAN FOR ADDITIONAL SUGGESTIONS.  THE USER MAY
FIND THE FOLLOWING BOOKLET PREPARED BY THE FEDERAL COMMUNICATIONS
COMMISSION HELPFUL: 'HOW TO IDENTIFY AND RESOLVE RADIO-TV INTERFERENCE
PROBLEMS.' THIS BOOKLET IS AVAILABLE FROM THE U.S. GVERNMENT PRINTING
OFFIC, WASHINGTON, D.C. 2402, STOCK NO. 004-000-00345-4."

PART NO: 320970

The information in this manual has been reviewed and is believed to be
entirely reliable.  No responsibility, however, is assumed for
inaccuracies.  The material in this manual is for information purposes
only, and is subject to change without notice.

(C) Commodore Business Machines Electronics Ltd., September 1982

"All rights reserved."



Table of Contents                                  [ Section ]

1. GENERAL DESCRIPTION
    [ Introduction........................................ 1 ]
    [ Specifications...................................... 2 ]

2. UNPACKING AND CONNECTING
      Contents of Box..................................... 1
      Connection of Cables................................ 2
      Powering On......................................... 3
      Insertion of Diskette............................... 4
      Using with VIC 20 or Commodore 64................... 5

3. USING PROGRAMS
      Loading Pre-packaged Software....................... 1
      LOAD................................................ 2
      Directory of Disk................................... 3
      Pattern Matching & Wild Cards....................... 4
      SAVE................................................ 5
      SAVE and replace.................................... 6
      VERIFY.............................................. 7
      DOS Support Program................................. 8

4. DISK COMMANDS
      OPEN AND PRINT #.................................... 1
      NEW................................................. 2
      COPY................................................ 3
      RENAME.............................................. 4
      SCRATCH............................................. 5
      INITIALIZE.......................................... 6
      VALIDATE............................................ 7
      DUPLICATE........................................... 8
      Reading the Error Channel........................... 9
      CLOSE...............................................10

5. SEQUENTIAL FILES
      OPEN................................................ 1
      PRINT# and INPUT#................................... 2
      GET#................................................ 3
      Reading the Directory............................... 4

6. RANDOM FILES
    [ Explanation......................................... 1 ]
      Opening a channel for random access data............ 2
      BLOCK-READ.......................................... 3
      BLOCK-WRITE......................................... 4
      BLOCK-ALLOCATE...................................... 5
      BLOCK-FREE.......................................... 6
    [ Using Random Files.................................. 7 ]
      BUFFER-POINTER...................................... 8
      USER1 and USER2..................................... 9

7. RELATIVE FILES
    [ Introduction........................................ 1 ]
      Creating a relative file............................ 2
      Using relative files................................ 3
      Create a relative file.............................. 4
      Summary............................................. 5
      Modifying the program............................... 6

8. PROGRAMNUNG THE DISK CONTROLLER
      BLOCK-EXECUTE....................................... 1
      MEMORY-READ......................................... 2
      MEMORY-WRITE........................................ 3
      MEMORY-EXECUTE...................................... 4
      USER Commands....................................... 5

9. CHANGING THE DISK DEVICE NUMEBER
      Software Method..................................... 1
      Hardware Method..................................... 2

10. ASSEMBLY LANGUAGE AND THE 1541

Appendices
      A. Disk Command Summary
      B. Error Messages
      C. Demonstration Disk Programs
      D. Disk Formats Tables

[ Index ]

[ Commodore Sales Centers ]

[ Back Page ]



1. GENERAL DESCRIPTION

1.1 INTRODUCTION

Welcome to the fastest, easiest, and most efficient filing system
available for your Commodore 64 or VIC 20 computer, your 1541 DISK
DRIVE.  This manual has been designed to show you how to get the most
from your drive, whether you're a beginner or an advanced professional.


If you are a beginner, the first few chapters will help you through
the basics of disk drive installation and operation.  As your skill
and programming knowledge improves, you will find more uses for your
disk drive and the more advanced chapters of this manual will become
much more valuable.

If you're a professional, this reference guide will show you how to
put the 1541 through its paces to perform just about all the disk
drive jobs you can think of.

No matter what level of expertise you have, your 1541 disk drive will
dramatically improve the overall capabilities of your computer system.

Before you get to the details of 1541 operation, you should be aware
of a few important points.  This manual is a REFERENCE GUIDE, which
means that unless the information you seek directly pertains to the
disk or disk drive you will have to use your Commodore 64 or VIC 20
User's Guides and Programmer's Reference Guides to find programming
information.  In addition, even though we give you step-by-step
instructions for each operation, you should become familiar with BASIC
and the instructions (called commands) that help you operate your
disks and drives.  However, if you just want to use your disk drive
unit to load and save prepackaged software, we've included an easy and
brief section on doing just that.

Now ... let's get on with the general information.

The commands for the disk drive come in several levels of
sophistication.  Starting in chapter three, you can learn how the
command that allow you to SAVE and LOAD programs with the disk work.
Chapter four teaches you how commands are sent to the disk, and
introduces the disk maintenance commands.

Chapter five tells you how to work with SEQuential data files.  These
are very similar to their counterparts on tape (but much faster).
Chapter six introduces the commands that allow you to work with random
files, to access any piece of data on the disk, and how you organize
the diskette into tracks and blocks.  Chapter seven describes the
special relative files.  RELative files are the best method of storing
data bases, especially when they are used along with sequential files.

Chapter eight describes methods for programming the disk controller
circuits at the machine language level.  And the final chapter shows
you how to change the disk device number, by cutting a line inside the
drive unit or through software.

Remember, you don't really need to learn everything in this book all
at once.  The first four chapters are enough to get you going, and the
next couple are enough for most operations.  Getting to know your disk
drive will reward you in many ways -- speed of operation, reliability,
and much more flexibility in your data processing capabilities.



1.2 SPECIFICATIONS

This disk drive allows you to store up to 144 different programs
and/or data files on a single mini-floppy diskette, for a maximum of
over 174,000 bytes worth of information storage.

Included in the drive is circuitry for both the disk controller and a
complete disk operating system, a total of 16K of ROM and 2K of RAM
memory.  This circuitry makes your Commodore 1541 disk drive an
"intelligent" device.  This means it does its own processing without
taking any memory away from your Commodore 64 or VIC 20 computer.  The
disk uses a "pipeline" software system.  The "pipeline" makes the disk
able to process commands while the computer is performing other jobs.
This dramatically improves the overall throughput (input and output)
of the system.

Diskettes that you create in this disk drive are read and write
compatible with Commodore 4040 and 2031 disk drives.  Therefore,
diskettes can be used interchangeably on any of these systems.  In
addition, this drive can read programs created on the older Commodore
2040 drives.

The 1541 disk drive contains a dual "serial bus" interface.  This bus
was specially created by Commodore.  The signals of this bus resemble
the parallel IEEE-488 interface used on Commodore PET computers,
except that only one wire is used to communicate data instead of eight.
 The two ports at the rear of the drive allows more than one device to
share the serial bus at the same time.  This is accomplished by
"daisy-chaining" the devices together, each plugged into the next. Up
to five disk drives and one printer can share the bus simultaneously.

Figure 1.1 Specifications VIC 1540/1541 Single Drive Floppy Disk

STORAGE

    Total capacity       174848 bytes per diskette
    Sequential           168656 bytes per diskette
    Relative             167132 bytes per diskette
                         65535 records per file
    Directory entries    144 per diskette
    Sectors per track    17 to 21
    Bytes per sector     256
    Tracks               35
    Blocks               683 (664 blocks free)

IC's:

    6502                 microprocessor
    6522 (2)             I/O, internal timers

    Buffer
      2114 (4)           2K RAM

PHYSICAL:

    Dimensions
      Height              97 mm
      Width              200 mm
      Depth              374 mm

Electrical:

Power Requirements
      Voltage            100, 120, 220, or 240 VAC
      Frequency          50 or 60 Hertz
      Power              25 Watts

MEDIA:

Diskettes                Standard mini 5 1/4", single sided,
                         single density



2. UNPACKING AND CONNECTING

2.1 CONTENTS OF BOX

Included with the 1541 disk drive unit, you should find a gray power
cable, black serial bus cable, this manual, and a demonstration
diskette.  The power cable has a connection for the back of the disk
drive on one end, and for a grounded (three-prong) electrical outlet
on the other.  The serial bus cable is exactly the same on both ends.
It has a 6-pin DIN plug which attaches to the VIC 20, Commodore 64 or
another disk drive.

Please, don't hook up anything until you've completed the following
section!

                                      Fig 1.A
 +------------------------------------------+
 |                                          |
 |  +------------------------------------+  |
 |  | C= commodore ========       1541   |  |
 |  +------------------------------------+  |
 |      +----------------------------+      |
 |      |                            |      |
 +------| ========================== |------+
 |      |          |      |          |      |
 |  O   |     O    +------+          |      |
 |  |   +-----|----------------------+      |
 +--|---------|-----------------------------+
    |         |
    |         +-- DRIVE INDICATOR (RED LED)
    |                             LIGHT: ACTIVE
    |                             FLASH: ERROR
    +-- POWER INDICATOR
        (GREEN LED) LIGHT: POWER ON

 Fig 1. Front Panel

                                      Fig 1.B
 +------------------------------------------+
 |                                          |
 |  +------------------------------------+  |
 |  | C= commodore ========       1541   |  |
 |  +------------------------------------+  |
 |      +----------------------------+      |
 |      |     O----+------+          |      |
 +------| ====|===================== |------+
 |      |     |    |      |          |      |
 |  O   |   ==|    |      |          |      |
 |  |   +---|--\---+------+----------+      |
 +--|-------|---|---------------------------+
    |       |   |
    |       |   +-- DOOR LEVER
    |       |
    |       +---- DRIVE INDICATOR (RED LED)
    |                             LIGHT: ACTIVE
    |                             FLASH: ERROR
    +-- POWER INDICATOR
        (GREEN LED) LIGHT: POWER ON



                    +-- POWER SWITCH
 Fig 2. Back Panel  |
                    |       +------+-- SERIAL BUS
 +------------------|-------|------|--------+
 |                  |      _|_    _|_       |
 |                  |     / _ \  / _ \      |
 |      +-----------+    | |_| || |_| |     |
 |      |                 \___/  \___/      |
 |    __|__   ________     ___              |
 |    |+-+|  / ______ \   / _ \             |
 +----|| ||-|--|    |--|-|-|_|-|------------+
 |    |+-+| |  |____|  |  \___/             |
 |    +---+ +----|-----+    |               |
 |               |          |               |
 +---------------|----------|---------------+
                 |          |
      AC INPUT --+          +-- FUSE/HOLDER



2.2 CONNECTION OF CABLES

Your first step is to take the power cable and insert it into the back
of the disk drive (see figure 2).  It won't go in if you try to put it
in upside down.  Once it's in the drive, plug the other end into the
electrical outlet.  If the disk drive makes any sound at this time,
please turn it off using the switch on the back!  Don't plug any other
cables into the disk drive if the power is on.

Next, take the serial bus cable and attach it to either one of the
serial bus sockets in the rear of the drive.  Turn off the computer,
and plug the other end of the cable into the back of the computer.
That's all there is to it!

If you have a printer, or any additional disk drives, attach the
cables into the second serial bus port (see figure 3).  For directions
on using multiple drives at one time, read chapter 9. If you are a
first-time user with more than one drive, start working with only one
drive until you're comfortable with the unit.

                                   +--------+
 +---------------------------+     |  +-----|---+
 |  ============= O O        |     |  |     O O----+
 |                  | == === |     |  | #[]o    |  |
 +------------------|--------+     |  +---------+  |
  Commodore 64 or   |              |  VIC 1541     |
  VIC20 Personal    | Serial cable |  Single Drive |
     Computer       +--------------+  Floppy Disk  |
                                                   |
                                                   |
                                   Serial cable    |
                           +-----------------------+
                           |
                           |       +---------------+
 Fig 3. Floppy Disk        |       |               |
        Hookup             |       +-+-------------+
                           |         |  Printer
                           +---------+

2.3 POWERING ON

When you have all the devices hooked together, it's time to start
turning on the power.  It is important that you turn on the devices in
the correct order.  The computer should always be turned on last.  As
long as the computer is the last one to be turned on, everything will
be OK.

First, make sure that you've removed all diskettes from the disk
drives before powering on.

After all the other devices have been turned on, only then is it safe
to turn on the computer.  All the other devices will go through their
starting sequences.  The printer's motor goes on, with the print head
moving halfway across the line and back again.  The 1541 disk drive
will have its green light on, and then the red drive/error light will
blink, while your TV screen forms the starting picture.

Once the red drive/error light has stopped flashing on the drive, it
is safe to begin working with it.



                    +-------U-===-U-------+       /\
                    |         | |         |     /    \
                    |         |_|         |   /_      _\ INSERT
                    |         ___         |     |    |    INTO
                    |     O  /   \        |     |    |    DRIVE
        WRITE       |       |     |       |     |    |
        PROTECT     |        \___/        |     |    |
        NOTCH ------]                     |     |____|
                    |                     |
                    +---------------------+
 WHEN COVERED, DISKETTE
 CONTENTS CANNOT BE ALTERED

 Fig.4. Postition for Diskette Insertion



2.4 INSERTION OF DISKETTE

There is different way to open and close the drive door, and
insertion/removal the diskette.

TYPE 1: figure 1.A -- To open the door on the drive, simply press the
door catch lightly, and the door will pop open. If there is a diskette
in the drive, it is ejected by a small spring.  Take the diskette to
be inserted, and place it in the drive face-up with the large opening
going in first and write-protect notch to the left (covered with tape
in the demonstration disk) (see figure 4).

Press it in gently, and when the diskette is in all the way, you will
feel a click and the diskette will not spring out.  Close the drive
door by pulling downward until the latch clicks into place.  Now you
are ready to begin working with the diskette.

TYPE 2: figure 1.B -- To open the door on the drive, simply turn the
door lever counter-clockwise. Take the diskette to be inserted, and
place it in the drive face-up with the large opening going in first
and write-protect notch to the left (covered with tape in the
demonstration disk) (see figure 4).

Close the drive door by turning clockwise direction until the latch
clicks into place.  Now you are ready to begin working with the disk.

Remember to always remove the diskette before the drive is turned off
or on. Never remove the diskette when the red drive light in on!  Data
can be destroyed by the drive at this time!



2.5 USING WITH A VIC 20 OR COMMODORE 64

The 1541 Disk Drive can work with either the VIC 20 or Commodore 64
computers.  However, each computer has different requirements for
speed of incoming data.  Therefore, there is a software switch for
selecting which computer's speed to use. The drive starts out ready
for a Commodore 64.  To switch to VIC 20 speed, the following command
must be sent after the drive is started (power-on or through
software):

   OPEN 15, 8, 15, "UI-": CLOSE 15

To return the disk drive to Commodore 64 speed, use this command:

   OPEN 15, 8, 15, "UI+": CLOSE 15

More about using this type of command is in chapter 4, with a detailed
explanation of the U (user) commands in chapter 8.



3. USING PROGRAMS

3.1 LOADING PREPACKAGED PROGRAMS

For those of you interested in using only prepackaged programs
available on cartridges, cassette, or disk, here's all you have to do:

Using your disk drive, carefully insert the preprogrammed disk so that
the label on the disk is facing up and is closest to you.  Look for a
little notch on the disk (it might be covered with a little piece of
tape).  If you're inserting the disk properly, the notch will be on
the left side.  Once the disk is inside, close the protective gate by
pushing in on the level. Now type LOAD "PROGRAM NAME", 8 and hit the
RETURN key. The disk will make noise and your screen will say:

 SEARCHING FOR PROGRAM NAME
 LOADING

 READY

When the word READY appears, just type RUN, and your prepackaged
software is ready to use.



3.2 LOAD

The BASIC commands used with Programs on the disk drive are the same
as the commands used on the Commodore DATASSETTE-tm recorder.  There
are a few extra commands available for use with disks, however.

First of all, the program name must be given with each command.  On a
DATASSETTE-tm, you could omit the program name in order to just LOAD
the first program there.  On disk, since there are many different
programs that are equally accessible, the program name must be used to
tell the disk drive what to do.  In addition, the disk drive's device
number must be specified.  If no device number is listed, the computer
assumes the program is on tape.

FORMAT FOR THE LOAD COMMAND:

   LOAD name$, device#, command#

The program name is a string, that is, either a name in quotes or the
contents of a given string variable.  Some valid names are: "HELLO",
"PROGRAM #1", A$, NAME$.

The device# is preset on the circuit board to be #8.  If you have more
than one drive, see chapter 9 on how to change the device number. This
book assumes that you're using device number 8 for the disk drive.

The command# is optional.  If not given, or zero, the program is
LOADed normally, that is, beginning at the start of your available
memory for BASIC programs.  If the number is 1, the program will be
LOADed at exactly the same memory locations from which it came.  In
the case of computers with different memory configurations, like VICs
with 5K, 8K, or more memory, the start of BASIC memory is in different
places.  The command# 0 permits BASIC programs to LOAD normally.
Command# 1 is used mainly for machine language, character sets, and
other memory dependent functions.

EXAMPLES

   LOAD "TEST", 8
   LOAD "Program # 1", 8
   LOAD A$, J, K
   LOAD "Mach Lang", 8, 1

NOTE: You can use variables to represent device numbers, commands, and
strings, as long as you've previously defined them in your program.



3.3 DIRECTORY OF DISKETTE

The DATASSETTE-tm tape deck is a sequential device.  It can only read
from the beginning of the tape to the end, without skipping around the
tape and without the capability of going backward or recording over
old data.

Your disk drive is a random access device.  The read/write head of the
disk can go to any spot on the disk and access a single block of data
which holds up to 256 bytes of information.  There are a total of 683
blocks on a single diskette.

Fortunately, you don't really have to worry about individual blocks of
data. There is a progrmn in the disk drive called the Disk Operating
System, or the DOS. This program keeps track of the blocks for you. It
organizes them into a Block Availability Map, or BAM, and a directory.

The Block Availability Map is simply a checklist of all 683 blocks on
the disk.  It is stored in the middle of the diskette, halfway between
the center hub and the outer rim. Every time a program is SAVED or a
data file is CLOSED, the BAM is updated with the list of blocks used
up.

The directory is a list of all programs and other files stored on the
disk.  It is physically located right next to the BAM.  There are 144
entries available in the directory, consisting of information like
file name and type, a list of blocks used, and the starting block.
The directory is automatically updated every time a program is SAVEd
or a file is OPENed for writing.  BEWARE: the BAM isn't updated until
the file is CLOSED, even though the directory changes right away.  If
a file isn't CLOSED properly, all data in that file will probably be
lost.

The directory can be LOADed into your memory just like a BASIC program.
Place the diskette in the drive, and type the following command:

 LOAD "$", 8

The computer responds with:

 SEARCHING FOR $

 FOUND $

 LOADING

 READY.

Now the directory is in your computer's memory.  Type LIST, and you'll
see the directory displayed on the screen.  To print the directory on
your printer, type the following command line (in this example your
printer is plugged in as device# 4):

   OPEN 4, 4: CMD 4: LIST

NOTE: When using CMD, the file must be closed using the command
PRINT#4: CLOSE 4. See the VIC 1525/1515 printer manual for detailed
explanation.

To read the directory without LOADing it into your memory, see the
section later in this chapter on the DOS Support Program.  In addition,
to examine the directory from inside a BASIC program, see the section
in chapter 5 that deals with the GET# statement.



3.4 PATTERN MATCHING AND WILD CARDS

When using the tape deck, you can LOAD any program starting with
certain letters just by leaving off any following letters.  Thus, the
command LOAD "T" will find the first program on the tape beginning
with the letter T. And LOAD "HELLO" will find the first program
beginning with the letters HELLO, like "HELLO THERE."

When using the disk, this option is called pattern matching, and there
is a special character in the file name used to designate this.  The
asterisk (*) character following any program name tells the drive you
want to find any program starting with that name.

FORMAT FOR PATTERN MATCHING:
			      +-------------------+
 LOAD name$ + "*", 8          | Can Be a String   |
	 |                    | Variable Or The   |
	 +--------------------+ Name Inside Quotes|
			      +-------------------+

In other words, if you want to LOAD the first program on the disk
starting with the letter T, use the command LOAD "T*", 8.

If only the "*" is used for the name, the last program accessed on the
disk is the one LOADed.  If no program has yet been LOADed, the first
one listed in the directory is the one used.

You are probably familiar with the concept of wild cards in poker
where one card can replace any other card needed.  On your 1541, the
question mark (?) can be used as a wild card on the disk.  The program
name on the disk is compared to the name in the LOAD command, but any
characters where there is a question mark in the name aren't checked.

For instance, when the command LOAD "T?NT", 8 is given, programs that
match include TINT, TENT, etc.

When LOADing the directory of the disk, pattern matching and wild
cards can be used to check for a list of specific programs.  If you
gave the command LOAD "$0:TEST", only the program TEST would appear in
the directory (if present on the disk).  The command LOAD "$0:T*"
would give you a directory of all programs beginning with the letter T.
And LOAD "$0:T?ST" would give you all the programs with 4-letter names
having the first letter of T and the third and fourth letters ST. LOAD
"$0:T?ST*" would give names of any length with the correct first,
third, and fourth letters.



3.5 SAVE

To SAVE a program to the diskette, all that is needed is to add the
device number after the program name.  Just like the SAVE command for
the tape deck, the device number can be followed by a command number,
to prevent the automatic re-location on LOADing (see the section on
the LOAD command, above).

FORMAT FOR THE SAVE COMMAND:

   SAVE name$, device#, command#

See the LOAD command (section 3.3) for an explanation of the
parameters device# and command#.

When you tell the disk drive to SAVE a program, the DOS must take
several steps.  First, it looks at the directory to see if a program
with that name already exists. Next it checks to see that there is a
directory entry available for the name.  Then it checks the BAM to see
if there are enough blocks in which to store the program.  If
everything is OK up to this point, the program is stored.  If not, the
error light will flash.



3.6 SAVE AND REPLACE

If a program already exists on the disk, it is often necessary to make
a change and re-SAVE it onto the disk.  In this case, it would be
inconvenient to have to erase the old version of the program and then
SAVE it.

If the first characters of the program name are the "@" sign followed
by a 0 and a colon (:), the DOS knows to replace any old program that
has that name with the program that is now in the computer's memory.
The drive checks the directory to find the old program, then it marks
that entry as deleted, and it next creates a new entry with the same
name.  Finally, the program is stored normally.

FORMAT FOR SAVE WITH REPLACE:

   SAVE "@0:" + name$, device#, command#

For example, if a file was called TEST, the SAVE and replace command
would be SAVE "@0:TEST",8.  If the name is in A$, the command is SAVE
"@0:" + A$, 8.

The reason for the 0: is to keep compatibility with other Commodore
disk drive units which have more than one drive built in.  In that
case, the number 0 or 1 is used to specify which drive is being used.



3.7 VERIFY

The VERIFY command works to check the program currently in memory
against the program on disk.  You must include a device# with the
VERIFY command.  The computer does a byte-by-byte comparison of the
program, including line links -- which may be different for different
memory configurations.  For instance, if a program was SAVED to disk
from a 5K VIC 20, and re-LOADed on an 8K machine, it wouldn't VERIFY
properly because the links point to different memory locations.

FORMAT FOR VERIFY COMMAND:

   VERIFY name$, device#



3.8 DOS SUPPORT PROGRAM

On your demonstration disk, there may be a program called DOS SUPPORT.
This program, also called a wedge, allows you to use many disk
commands more easily (different wedges are used for the VIC 20 and the
Commodore 64).  Just LOAD the program and RUN it.  It automatically
sets itself up and erases itself when it's finished. You'll have a few
hundred less bytes to work with when this program is running, but
you'll also have a handy way to send the disk commands.

As a result of the DOS Support, the "/" key now takes the place of the
LOAD command.  Just hit the slash followed by the progrwn name, and
the program is LOADed.  When you use this method, you don't need to
use the LOAD command or the comma 8.

The "@" and ">" keys are used to send commands to the disk drive. If
you type @$ (or > $), the directory of the disk is displayed on the
screen, without LOADing into your memory!  These keys also take the
place of the PRINT# (see chapter 4) to send commands listed in the
next chapter.

To read the error channel of the disk (when the red error light is
blinking), just hit either the @ or the > and hit RETURN Key.  The
complete error message is displayed to you: message number, text, and
track and block numbers.



4. DISK COMMANDS

4.1 OPEN AND PRINT #

Up 'til now, you have explored the simple ways of dealing with the
disk drive.  In order to communicate with the disk drive more fully,
you have to touch on the OPEN and PRINT# statements in BASIC (more
details of these commands are available in your VIC 20 or Commodore 64
User's Guide or Programmer's Reference Guide).  You may be familiar
with their use with data files on cassette tape, where the OPEN
statement creates the file and the PRINT# statement fills the file
with data. They can be used the same way with the disk, as you will
see in the next chapter.  But they can also be used to set up a
command channel. The command channel lets you exchange information
between the computer and the disk drive.

FORMAT FOR THE OPEN STATEMENT:

   OPEN file#, device#, channel#, text$

The file# can be any number from 1 to 255.  This number is used
throughout the program to identify which file is being accessed.  But
numbers greater than 127 should be avoided, because they cause the
PRINT# statement to generate a linefeed after the return character.
These numbers are really meant to be used with non-standard printers.

The device# of the disk is usually 8.

The channel# can be any number from 2 to 15.  These refer to a channel
used to communicate with the disk, and channels numbered 0 and 1 are
reserved for the operating system to use for LOADing and SAVEing.
Channels 2 through 14 can be used for data to files, and 15 is the
command channel.

The text$ is a string that is PRINTed to the file, as if with a PRINT#
statement. This is handy for sending a single command to the channel.

EXAMPLES OF OPEN STATEMENTS:

   OPEN 15, 8, 15
   OPEN 2, 8, 2

	+-------------- FILE#
	|  +----------- DEVICE#
	|  |  +-------- COMMAND CHANNEL#
	|  |  |
   OPEN A, B, C, Z$
		 |
		 +----- COMMAND$(text$)

The PRINT# command works exactly like a PRINT statement, except that
the data goes to a device other than the screen, in this case to the
disk drive.  When used with a data channel, the PRINT# sends
information into a buffer in the disk drive, which LOADs it onto the
diskette.  When PRINT# is used with the command channel, it sends
commands to the disk drive.

FORMAT FOR SENDING DISK COMMANDS:

   OPEN 15, 8, 15, command$

or

   PRINT# 15, command$



4.2 NEW

This command is necessary when using a diskette for the first time.
The NEW command erases the entire diskette, it puts timing and block
markers on the diskette and creates the directory and BAM.  The NEW
command can also be used to clear out the directory of an already-
formatted diskette.  This is faster than re-formatting the whole disk.

FORMAT FOR THE NEW COMMAND TO FORMAT DISK:

   PRINT#15, "NEW:name,id"

or abbreviated as

   PRINT#15, "N:name,id"

FORMAT FOR THE NEW COMMAND TO CLEAR DIRECTORY:

   PRINT#15, "N:name"

The name goes in the directory as the name of the entire disk.  This
only appears when the directory is listed.  The ID code is any 2
characters, and they are placed not only on the directory but on every
block throughout the diskette.  That way, if you carelessly replace
diskettes while writing data, the drive will know by checking the ID
that something is wrong.



4.3 COPY

This command allows you to make a copy of any program or file on the
disk drive.  It won't copy from one drive to a different one (except
in the case of dual drives like the 4040), but it can duplicate a
program under another name on the drive.

FORMAT FOR THE COPY COMMAND:

   PRINT# 15, "COPY:newfile=oldfile"

or abbreviated as

   PRINT# 15, "C:newfile=oldfile"

The COPY command can also be used to combine two through four files on
the disk.

FORMAT FOR COPY TO COMBINE FILES:

 PRINT# 15, "C:newfile=oldfile1,oldfile2,oldfile3,oldfile4"

EXAMPLES OF COPY COMMAND:

   PRINT# 15, "C:BACKUP=ORIGINAL"
   PRINT# 15, "C:MASTERFILE=NAME,ADDRESS,PHONES"



4.4 RENAME

This command allows you to change the name of a file once it is in the
disk directory.  This is a fast operation, since only the name in the
directory must be changed.

FORMAT FOR RENAME COMMAND:

   PRINT# 15, "RENAME:newname=oldname"

or abbreviated as

   PRINT# 15, "R:newname=oldname"

EXAMPLE OF RENAME COMMAND:

   PRINT#15, "R:MYRA=MYRON"

The RENAME command will not work on any files that are currently OPEN.



4.5 SCRATCH

This command allows you to erase unwanted files and programs from the
disk, which then makes the blocks available for new information.  You
can erase programs one at a time or in groups by using pattem matching
and or wild cards.

FORMAT FOR SCRATCH COMMAND

   PRINT# 15, "SCRATCH:name"

or abbreviated as

   PRINT# 15, "S:name"

If you check the error channel after a scratch operation (see below),
the number usually reserved for the track number now tells you how
many files were scratched.  For example, if your directory contains
the programs KNOW and GNAW, and you use the command PRINT# 15,
"S:?N?W", you will scratch both programs.  If the directory contains
TEST, TRAIN, TRUCK, and TAIL, and you command the disk to PRINT# 15,
"S:T*", you will erase all four of these programs.



4.6 INITIALIZE

At times, an error condition on the disk will prevent you from
performing some operation you want to do.  The INITIALIZE command
returns the disk drive to the same state as when powered up.  You must
be careful to re-match the drive to the computer (see chapter 2).

FORMAT FOR INITIALIZE COMMAND:

   PRINT# 15, "INITIALIZE"

or abbreviated as

   PRINT# 15, "I"



4.7 VALIDATE

After a diskette has been in use for some time, the directory can
become disorganized.  When programs have been repeatedly SAVED and
SCRATCHed, they may leave numerous small gaps on the disk, a block
here and a few blocks there.  These blocks never get used because they
are too small to be useful.  The VALIDATE command will go in and re-
organize your diskette so that you can get the most from the available
space.

Also, there may be data files that were OPENed but never properly
CLOSED. This command will collect all blocks taken by such files and
make them available to the drive, since the files are unusable at that
point.

There is a danger in using this command.  When using random files (see
chapter 6), blocks allocated will be de-allocated by this command.
Therefore, this command should never be used with a diskette that uses
random files.

FORMAT FOR VALIDATE COMMAND:

   PRINT#15, "VALIDATE"

or abbreviated as

   PRINT#15, "V"



4.8 DUPLICATE

This command is a hangover from the operating systems that were
contained on the dual drives like the 4040. It was used to copy entire
diskettes from one drive to another, but has no function on a single
disk drive.



4.9 READING THE ERROR CHANNEL

Without the DOS Support Program, there is no way to read the disk
error channel without a program, since you need to use the INPUT#
command which won't work outside a program.  Here is a simple BASIC
routine to read the error channel:

 10 OPEN 15, 8, 15
 20 INPUT# 15, A$, B$, C$, D$
 30 PRINT A$, B$, C$, D$

Whenever you perform an INPUT# operation from the command channel, you
read up to 4 variables that describe the error condition.  The first,
third, and fourth variables come in as numbers, and can be INPUT into
numeric variables if you like. The first variable describes the
error#$, where 0 is no error.  The second variable is the error
description. The third variable is the track number on which the error
occurred, and the fourth and final is the block number inside that
track. (A block is also known as a sector)

Errors on track 18 have to do with the BAM and directory.  For example,
a READ ERROR on track 18 block 0 may indicate that the disk was never
formatted.



4.10 CLOSE

It is extremely important that you properly CLOSE files once you are
finished using them. Closing the file causes DOS to properly allocate
blocks in the BAM and to finish the entry in the directory. If you
don't CLOSE the file, all your data will be lost!

FORMAT FOR CLOSE STATEMENT:

 CLOSE file#

You should also be careful not to CLOSE the error channel (channel#
15) before CLOSEing your data channels.  The error channel should be
OPENed first and CLOSEd last of all your files! That will keep your
programs out of trouble.

If you close the error channel while other files are OPEN, the disk
drive will close them for you, but BASIC will still think they are
open (unless you CLOSE them properly), let you to try to write to them.


NOTE: If your BASIC program leads you into an effor condition, all
files are CLOSEd in BASIC, without CLOSEing them on your disk drive!
This is a very dangerous condition. You should immediately type the
statement OPEN 15, 8, 15, "I". This will re-initialize your drive and
make all your files safe.



5. SEQUENTIAL FILES

5.1 OPEN

SEQuential files are limited by their sequential nature, which means
they must be read from beginning to end.  Data is transferred byte by
byte, through a buffer, onto the magnetic media.  To the disk drive
all files are created equal.  That is, SEQuential files, program files,
and user files all work the same on the disk.  Only program files can
be LOADed, but that's really the only difference.  Even the directory
works like this, except that it is read-only.  The only difference is
with relative files.

FORMAT FOR OPENING A SEQUENTIAL FILE:

   OPEN file#, device#, channel#, "0:name,type,direction"

The file number is the same as in all your other applications of the
OPEN statement, and it is used throughout the program to refer to this
particular file.  The device# is usually 8. The channel# is a data
channel, number 2 through 14.  It is convenient to use the same number
for both the channel# and file#, to keep them straight.  The name is
the file name (no wild cards or pattern matching if you're creating a
write file).  The type can be any of the ones from the chart below, at
least the first letter of each type. The direction must be READ or
WRITE, or at least the first letter of each.


 FILE TYPE   MEANING

 PRG         Program
 SEQ         Sequential
 USR         User
 REL         Relative

EXAMPLES OF OPENING SEQUENTIAL FILES:

   OPEN 2, 8, 2, "0:DATA, S, W"
   OPEN 8, 8, 8, "0:Program, P, R"
   OPEN A, B, C, "0:" + A$ + "U,W"

If the file already exists, you can use the replace option in the OPEN
statement, similar to the SAVE-and-replace described in chapter 3.
Simply add the @0: before the file's name in the OPEN statement.

EXAMPLE OF SEQUENTIAL FILE WITH REPLACE OPTION:

   OPEN 2, 8, 2, "@0:DATA,S,W"

The 0: should always precede the name of the file or the drive will
only allow you to use 2 of the available buffers.



5.2 PRINT# and INPUT#

The PRINT# command works exactly like the PRINT statement, except that
output is re-directed to the disk drive.  The reason for the special
emphasis on the word exactly is that all the formatting capabilities
of the PRINT statement, as applies to punctuation and data types,
applies here too.  It just means that you have to be careful when
putting data into your files.

FORMAT FOR WRITING TO FILE WITH PRINT#:

   PRINT# file#, data list

The file# is the one from the OPEN statement when the file was created.


The data list is the same as the regular PRINT statement -- a list of
variables and/or text inside quote marks.  However, you must be
especially careful when writing data so that it is as easy as possible
to read the data back again.

When using the PRINT# statement, if you use commas (,) to separate
items on the fine, the items will be separated by some blank spaces,
as if it were being formatted for the screen.  Semicolons (;) don't
result in any extra spaces.

In order to more fully understand what's happening, here is a diagram
of a sequential file created by the statement OPEN 5, 8, 5,
"0:TEST,S,W":

      |eof|   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 -----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
 char | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| 14| 15|...

The eof stands for the end-of-file marker.  String data entering the
file goes in byte by byte, including spaces.

For instance, let's set up some variables with the statement A$=
"HELLO"; B$ = "ALL": C$ = "BYE". Here is a picture of a file after the
statement PRINT# 5, A$; B$; C$:

      | H | E | L | L | O | A | L | L | B | Y | E | CR|eof|
 -----+---+---+---+---+---+---+---+---+---+---+---+---+---+
 char | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13|

CR stands for the CHR$ code of 13, the carriage return, which is
PRINTed at the end of every PRINT or PRINT# statement unless there is
a comma or semicolon at the end of the line.

NOTE: Do not leave a space between PRINT and #, and do not try to
abbreviate the command as ?#.  See the appendixes in the user manual
for the correct abbreviation.

FORMAT FOR INPUT# STATEMENT:

   INPUT# file#, variable list

When using the INPUT# to read in data, the disk drive can't tell that
it's not supposed to be one long string.  You need something in the
file to act as a separator. Characters to use as separators include
the CR, a comma or a semicolon.  The CR can be added easily by just
using one variable per line on the PRINT# statement, and the system
puts one there automatically.  The statement PRINT# 5, A$: PRINT# 5,
B$: PRINT# 5, C$ puts a CR after every variable being written,
providing the proper separation for a statement like INPUT#5, A$, B$,
C$.  Or else a line like Z$ = ",":PRINT# 5, A$ Z$ B$ Z$ C$ will do the
job as well, and in less space.  The file after that line looks like
this:

      | H | E | L | L | O | , | A | L | L | , | B | Y | E | CR|eof|
 -----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 char | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| 14| 15|

Putting commas between variables results in lots of extra space on the
disk being used.  A statement like PRINT# 5, A$, B$ makes a file that
looks like:

      | H | E | L | L | O |   |   |   | A | L | L |   | CR|eof|
 -----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 char | 1 | 2 | 3 | 4 | 5 | 6 |...| 11| 12| 13| 14|...| 23| 24|

You can see that much of the space in the file is wasted.

The moral of all this is: take care when using PRINT# so your data
will be in order for reading back in.

Numeric data written in the file takes the form of a string, as if the
STR$ function had been performed on it before writing it out.  The
first character will be a blank space if the number is positive, and a
minus sign (-) if the number is negative.  Then comes the number, and
the last character is the cursor right character.  This format
provides enough information for the INPUT# statement to read them in
as separate numbers if several are written with no other special
separators.  It is somewhat wasteful of space, since there can be two
unused characters if the numbers are positive.

Here is a picture of the file after the statement PRINT# 5, 1; 3; 5; 7
is performed:

      |   | 1 |-->|   | 3 |-->|   | 5 |-->|   | 7 |-->| CR|eof|   |
 -----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 char | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| 14| 15|

Appendix B contains a program demonstrating the use of a sequential
disk file.



5.3 GET#

The GET# retrieves data from the disk, one character at a time.

FORMAT FOR THE GET# STATEMENT:

   GET# file#, variable list

Data comes in byte by byte, including the CR, comma, and other
separating characters.  It is much safer to use string variables when
using the GET# statement.  You will get a BASIC error message if
string data is received where a number was requested, but not vice-
versa.

EXAMPLES OF GET# STATEMENT:

   GET# 5, A$
   GET# A, B$, C$, D$
	   |   |   |
           +---+---+--- You can get more than 1 character at a time
   GET# 5, A

The GET# statement is extremely useful when examining files with
unknown contents, like a file that may have been damaged by an
experimental program.  It is safer than INPUT# because there is a
limit to the number of characters allowed between separators of INPUT
variables.  With GET#, you receive every character, and you can
examine separators as well as other data.

Here is a sample program that will allow you to examine any file on
the disk:

start tok64 examfile.prg
 10 input "file name";f$
 20 input "file type";t$
 30 t$ = left$ (t$,1)
 40 if t$<>"s" then if t$<>"p" then if t$<>"u" then 20
 45 open 15,8,15
 50 open 5,8,5,"0:" + f$ + "," + t$ + ",r"
 60 gosub 200
 70 get#5, a$
 80 if st=0 then 90
 85 if st=64 then close 5,15:end
 87 print st:stop
 90 print asc(a$ + chr$(0))
 100 goto 70
 200 input#15,a$,b$,c$,d$
 210 if val(a$)> 0 then printa$,b$,c$,d$:stop
 220 return
stop tok64

begin 644 EXAMFILE.PRG
M`0@6"`H`A2`B1DE,12!.04U%(CM&)``K"!0`A2`B1DE,12!465!%(CM4)``]
M"!X`5"0@LB#(("A4)"PQ*0!H""@`BR!4)+.Q(E,B(*<@BR!4)+.Q(E`B(*<@
MBR!4)+.Q(E4B(*<@,C``=@@M`)\@,34L."PQ-0">"#(`GR`U+#@L-2PB,#HB
M(*H@1B0@JB`B+"(@JB!4)""J("(L4B(`J`@\`(T@,C`P`+0(1@"A(S4L($$D
M`,0(4`"+(%-4LC`@IR`Y,`#;"%4`BR!35+(V-""G(*`@-2PQ-3J``.8(5P"9
M(%-4.I``^0A:`)D@QBA!)""J(,<H,"DI``()9`")(#<P`!8)R`"$,34L020L
M0B0L0R0L1"0`-@G2`(L@Q2A!)"FQ(#`@IR"9020L0B0L0R0L1"0ZD``\"=P`
$C@``````
`
end



5.4 READING THE DIRECTORY

The directory of the diskette may be read just fike a sequential file.
Just use $ for the file name, and OPEN 5, 8, 5, "$".  Now the GET#
statement works to examine the directory.  The format here is
identical to the format of a program file: the file sizes are the line
numbers, and names are stored as characters within quote marks.

Here's a program that lets you read the directory of the diskette:

start tok64 readdir.prg
 10 open 1,8,2,"$"
 20 for x=1 to 141:get#1,a$:next:rem skip over bam
 30 t$(0)="del":t$(1)="seq":t$(2)="prg":t$(3)="usr":t$(4)="rel"
 40 j=17:gosub 500:rem disk name
 50 n$=b$
 60 j=2:rem set length of id string
 70 gosub 500
 80 i$=b$
 85 get#1,a$
 90 j=2:rem set length of operating system string
 100 gosub 500
 110 o$=b$
 120 for l=1 to 88
 130 get#1,a$:rem get rest of block
 140 next
 160 print chr$(147) "disk name:"n$,"id:"i$,"os:"o$
 161 print "length","type","name"
 165 for p=1 to 8
 170 get#1,t$,a$,a$:rem file type
 180 if t$="" then t$ = chr$(128)
 190 j=15:rem set length of file name string
 200 gosub 500
 210 n$=b$
 220 get#1,a$,a$,a$,a$,a$,a$,a$,a$,a$,l$,h$:rem low & high bytes \
     of file length
 225 l=asc(l$+chr$(0))+256*asc(h$+chr$(0)):if l=0 then 260
 227 if st then close 1:end
 230 print l,t$(asc(t$)-128),n$
 250 if p < 8 then get#1,a$,a$
 260 next p:goto 165
 500 b$="":rem string building routine
 510 for l=0 to j
 520 get#1,a$
 530 if a$<>chr$(96) then if a$<>chr$(160) then b$=b$ + a$
 540 next
 550 return
stop tok64

begin 644 READDIR.PRG
M`0@1"`H`GR`Q+#@L,BPB)"(`.@@4`($@6+(Q(*0@,30Q.J$C,2Q!)#J".H\@
M4TM)4"!/5D52($)!30!Z"!X`5"0H,"FR(D1%3"(Z5"0H,2FR(E-%42(Z5"0H
M,BFR(E!21R(Z5"0H,RFR(E534B(Z5"0H-"FR(E)%3"(`E0@H`$JR,3<ZC2`U
M,#`ZCR!$25-+($Y!344`GP@R`$XDLD(D`,$(/`!*LC(ZCR!3150@3$5.1U1(
M($]&($E$(%-44DE.1P#+"$8`C2`U,#``U0A0`$DDLD(D`.`(50"A(S$L020`
M$`E:`$JR,CJ/(%-%5"!,14Y'5$@@3T8@3U!%4D%424Y'(%-94U1%32!35%))
M3D<`&@ED`(T@-3`P`"0);@!/)+)")``S"7@`@2!,LC$@I"`X.`!2"8(`H2,Q
M+$$D.H\@1T54(%)%4U0@3T8@0DQ/0TL`6`F,`((`A`F@`)D@QR@Q-#<I(")$
M25-+($Y!344Z(DXD+"))1#HB220L(D]3.B)/)`"A":$`F2`B3$5.1U1((BPB
M5%E012(L(DY!344B`*\)I0"!(%"R,2"D(#@`S`FJ`*$C,2Q4)"Q!)"Q!)#J/
M($9)3$4@5%E010#F";0`BR!4)+(B(B"G(%0D(+(@QR@Q,C@I`!`*O@!*LC$U
M.H\@4T54($Q%3D=42"!/1B!&24Q%($Y!344@4U1224Y'`!H*R`"-(#4P,``D
M"M(`3B2R0B0`;@K<`*$C,2Q!)"Q!)"Q!)"Q!)"Q!)"Q!)"Q!)"Q!)"Q!)"Q,
M)"Q()#J/($Q/5R`F($A)1T@@0EE415,@3T9&24Q%($Q%3D=42`":"N$`3++&
M*$PDJL<H,"DIJC(U-JS&*$@DJL<H,"DI.HL@3+(P(*<@,C8P`*L*XP"+(%-4
M(*<@H"`Q.H``Q`KF`)D@3"Q4)"C&*%0D*:LQ,C@I+$XD`-P*^@"+(%`@LR`X
M(*<@H2,Q+$$D+$$D`.H*!`&"(%`ZB2`Q-C4`#@OT`4(DLB(B.H\@4U1224Y'
M($)524Q$24Y'(%)/551)3D4`'`O^`8$@3+(P(*0@2@`G"P@"H2,Q+$$D`%,+
M$@*+($$DL[''*#DV*2"G((L@022SL<<H,38P*2"G($(DLD(D(*H@020`60L<
+`H(`7PLF`HX`````
`
end


                 Table 5.1: 1540/1541 BAM FORMAT
 +-----------------------------------------------------------------+
 | Track 18, Sector 0.                                             |
 +-------+----------+----------------------------------------------+
 | BYTE  | CONTENTS |                DEFINITION                    |
 +-------+----------+----------------------------------------------+
 | 0,1   | 18,01    | Track and sector of first directory block.   |
 +-------+----------+----------------------------------------------+
 | 2     | 65       | ASCII character A indicating 4040 format.    |
 +-------+----------+----------------------------------------------+
 | 3     | 0        | Null flag for future DOS use.                |
 +-------+----------+----------------------------------------------+
 | 4-143 |          | Bit map of available blocks for tracks 1-35. |
 +-------+----------+----------------------------------------------+
 | *1 = available block                                            |
 |  0 = block not available                                        |
 |      (each bit represents one block)                            |
 +-----------------------------------------------------------------+


                 Table 5.2: 1540/1541 DIRECTORY HEADER
 +-----------------------------------------------------------------+
 | Track 18, Sector 0.                                             |
 +---------+----------+--------------------------------------------+
 | BYTE    | CONTENTS |              DEFINITION                    |
 +---------+----------+--------------------------------------------+
 | 144-161 |          | Disk name padded with shifted spaces.      |
 +---------+----------+--------------------------------------------+
 | 162-163 |          | Disk ID.                                   |
 +---------+----------+--------------------------------------------+
 | 164     | 160      | Shifted space.                             |
 +---------+----------+--------------------------------------------+
 | 165,166 | 50,65    | ASCII representation for 2A which is DOS   |
 |         |          | version and format type.                   |
 +---------+----------+--------------------------------------------+
 | 166-167 | 160      | Shifted spaces.                            |
 +---------+----------+--------------------------------------------+
 | 171-255 | 0        | Nulls, not used.                           |
 +---------+----------+--------------------------------------------+
 | Note: ASCII characters may appear in locations 180 thru 191 on  |
 |       some diskettes.                                           |
 +-----------------------------------------------------------------+


                 Table 5.3: DIRECTORY FORMAT
 +---------------------------------------------------------+
 | Track 18, Sector 1 for 1540/1541                        |
 +---------+-----------------------------------------------+
 | BYTE    |               DEFINITION                      |
 +---------+-----------------------------------------------+
 | 0,1     | Track and sector of next directory block.     |
 +---------+-----------------------------------------------+
 | 2-31    | *File entry 1                                 |
 +---------+-----------------------------------------------+
 | 34-63   | *File entry 2                                 |
 +---------+-----------------------------------------------+
 | 66-95   | *File entry 3                                 |
 +---------+-----------------------------------------------+
 | 98-127  | *File entry 4                                 |
 +---------+-----------------------------------------------+
 | 130-159 | *File entry 5                                 |
 +---------+-----------------------------------------------+
 | 162-191 | *File entry 6                                 |
 +---------+-----------------------------------------------+
 | 194-223 | *File entry 7                                 |
 +---------+-----------------------------------------------+
 | 226-255 | *File entry 8                                 |
 +---------+-----------------------------------------------+

*STRUCTURE OF SINGLE DIRECTORY ENTRY

 +---------+----------+--------------------------------------------+
 | BYTE    | CONTENTS |              DEFINITION                    |
 +---------+----------+--------------------------------------------+
 | 0       | 128+type | File type OR'ed with $80 (hexadecimal) to  |
 |         |          | indicate properly closed file.             |
 |         |          | TYPES: 0 = DELeted                         |
 |         |          |        1 = SEQential                       |
 |         |          |        2 = PROGram                         |
 |         |          |        3 = USER                            |
 |         |          |        4 = RELative                        |
 +---------+----------+--------------------------------------------+
 | 1,2     |          | Track and sector of 1st data block.        |
 +---------+----------+--------------------------------------------+
 |         |          | File name padded with shifted spaces.      |
 +---------+----------+--------------------------------------------+
 |         |          | Relative file only: track and sector for   |
 |         |          | first side sector block.                   |
 +---------+----------+--------------------------------------------+
 |         |          | Relative file only: Record size.           |
 +---------+----------+--------------------------------------------+
 |         |          | Unused.                                    |
 +---------+----------+--------------------------------------------+
 |         |          | Track and sector of replacement file when  |
 |         |          | OPEN@ is in effect.                        |
 +---------+----------+--------------------------------------------+
 |         |          | Number of blocks in file: low byte, high   |
 |         |          | byte.                                      |
 +---------+----------+--------------------------------------------+


                 Table 5.4: SEQUENTIAL FORMAT
 +---------+-------------------------------------------------------+
 | BYTE    |              DEFINITION                               |
 +---------+-------------------------------------------------------+
 | 0,1     | Track and sector of next sequential data block.       |
 +---------+-------------------------------------------------------+
 | 2-256   | 254 bytes of data with carriage returns as record     |
 |         | terminators.                                          |
 +---------+-------------------------------------------------------+


                 Table 5.5: PROGRAM FILE FORMAT
 +---------+-------------------------------------------------------+
 | BYTE    |              DEFINITION                               |
 +---------+-------------------------------------------------------+
 | 0,1     | Track and sector of next block in program file.       |
 +---------+-------------------------------------------------------+
 | 2-256   | 254 bytes of program info stored in CBM memory format |
 |         | (with key words tokenized).  End of file is marked by |
 |         | three zero bytes.                                     |
 +---------+-------------------------------------------------------+



6. RANDOM FILES

[ 6.1 Explanation ]

Sequential files are fine when you're just working with a continuous
stream of data, but some jobs require more than that.  For example,
with a large mailing list, you would not want to have to scan through
the entire list to find a person's record.  For this you need some
kind of random access method, some way to get to any record inside a
file without having to read through the entire file first.

There are actually two different types of random access files on the
Commodore disk drive.  The relative files discussed in the next
chapter are more convenient for data handling operations, although the
random files in this chapter have uses of their own, especially when
working with machine language.

Random files on the Commodore disk drive reach the individual 256-byte
blocks of data stored on the disk.  As was mentioned in the first
chapter, there are a total of 683 blocks on the diskette, of which 664
are free on a blank diskette.

The diskette is divided into tracks, which are laid out as concentric
circles on the surface of the diskette.  There are 35 different tracks,
starting with track 1 at the outside of the diskette to track 35 at
the center.  Track 18 is used for the directory, and the DOS fills up
the diskette from the center outward.

Each track is subdivided into blocks.  Because there is more room on
the outer tracks, there are more blocks there.  The outer tracks
contain 21 blocks each, while the inner ones only have 17 blocks each.
The table below shows the number of blocks per track.


       Table 6.1: Track and Block Format
 +--------------+-------------+-------------+
 | TRACK NUMBER | BLOCK RANGE | TOTAL BLOCK |
 +--------------+-------------+-------------+
 |    1 to 17   |   0 to 20   |      21     |
 |   18 to 24   |   0 to 18   |      19     |
 |   25 to 30   |   0 to 17   |      18     |
 |   31 to 35   |   0 to 16   |      17     |
 +--------------+-------------+-------------+

The DOS contains commands for reading and writing directly to any
track and block on the diskette.  There are also commands for checking
to see which blocks are available, and for marking off used blocks.

These commands are transmitted through the command channel (channel
#15), and tell the disk what to do with the data.  The data must be
read later through one of the open data channels.



6.2 OPENING A DATA CHANNEL FOR RANDOM ACCESS

When working with random access files, you need to have 2 channels
open to the disk: one for the commands, and the other for the data.
The command channel is OPENed to channel 15, just like other disk
commands you've encountered so far.  The data channel for random
access files is OPENed by selecting the pound sign (#) as the file
name.

FORMAT FOR OPEN STATEMENT FOR RANDOM ACCESS DATA:

   OPEN file#, device#, channel#, "#"

or optionally

   OPEN file#, device#, channel#, "#buffer#"

EXAMPLES OF OPENING RANDOM ACCESS DATA CHANNEL:

                         +-------------------------+
   OPEN 5,8,5,"#" <------+ DON'T CARE WHICH BUFFER |
			 +----------------+--------+
   OPEN A,B,C,"#2" <-----+ PICK BUFFER #2 |
		 	 +----------------+

6.3 BLOCK-READ

FORMAT FOR BLOCK-READ COMMAND:

    PRINT#file#, "BLOCK-READ:" channel; drive; track; block

or abbreviated as

    PRINT#file#, "B-R:" channel; drive; track; block

This command will move one block of data from the diskette into the
selected channel.  Once this operation has been performed, the INPUT#
and GET# statements can read the information.

SAMPLE PROGRAM TO READ BLOCK 2 FROM TRACK 18: (stores contents in B$)

	  +---------+ +-------+  +-------+
	  | CHANNEL | | DRIVE |  | TRACK |
	  +---------+ +-------+  +-------+
		    | |          |
		    | |  +-------+
 10 OPEN 15,8,15    | |  |           +-------+
 20 OPEN 5,8,5,"#"  | |  |           | BLOCK |
 30 PRINT#15,"B-R:" 5;0;18;2 <-------+-------+
 40 B$=""
 50 FOR L=0 TO 255                  +----------------+
 60 GET#5,A$                        | COLLECT ENTIRE |
 70 IF ST = 0 THEN B$=B$+A$:NEXT L  | BLOCK: BYTE    |
 80 PRINT "FINISHED"     |          | BY BYTE        |
 90 CLOSE 5:CLOSE 15     +----------+----------------+



6.4 BLOCK-WRITE

The BLOCK-WRITE command is the exact opposite of the BLOCK-READ
command.  First you must fill up a data buffer with your information,
then you write that buffer to the correct location on the disk.

FORMAT FOR BLOCK-WRITE COMMAND:

   PRINT#file#, "BLOCK-WRITE:" channel; drive; track; block

or abbreviated as

   PRINT#file, "B-W:" channel; drive; track; block

When the data is being put into the buffer, a pointer in the DOS keeps
track of how many characters there are.  When you perform the BLOCK-
WRITE operation, that pointer is recorded on the disk.  That is the
reason for the ST check in line 70 of the program above: the ST will
become non-zero when you try to read past the end-of-file marker
within the record.

SAMPLE PROGRAM TO WRITE DATA ON TRACK 1, SECTOR 1:

 10 OPEN 15,8,15
 20 OPEN 5,8,5,"#":REM OPEN A RANDOM ACCESS CHANNEL
 30 FOR L=1 TO 50
 40 PRINT#5,"TEST"
 50 NEXT
 60 PRINT#15,"B-W:"5;0;1;1
 70 CLOSE 5:CLOSE 15



6.5 BLOCK-ALLOCATE

In order to safely use random files along with regular files, your
programs must check the BAM to find available blocks, and change the
BAM to reflect that you've used them.  Once you update the BAM, your
random files will be safe -- at least unless you perform the VALIDATE
command (see chapter 3).

FORMAT FOR THE BLOCK-ALLOCATE COMMAND:

   PRINT#file#, "BLOCK-ALLOCATE:" drive; track; block

How do you know which blocks are available to use?  If you try a block
that isn't available the DOS will set the error message to number 65,
NO BLOCK, and set the track and block numbers to the next available
track and block number.  Therefore, any time you attempt to write a
block to the disk, you must first try to allocate that block. If that
block isn't available, read the next block available from the error
channel and then allocate that block.

EXAMPLE OF PROCEDURE TO ALLOCATE BLOCK:

			    +-------+
			    | DRIVE |
 10 OPEN 15,8,15   +--------+-------+
 20 OPEN 5,8,5,"#" |        | TRACK |
 30 PRINT#5,"DATA" | +------+-------+
 40 T=1:B=1        | |      | BLOCK |
 50 PRINT#15,"B-A:"0;T;B <--+-------+
 60 INPUT#15,A,B$,C,D
 70 IF A=65 THEN T=C:B=D:GOTO 50
 80 PRINT#15,"B-W:"5;0;1;1
 90 CLOSE 5:CLOSE 15



6.6 BLOCK-FREE

The BLOCK-FREE command is the opposite of BLOCK-ALLOCATE, in that it
frees a block that you don't want to use anymore for use by the system.
It is vaguely similar to the SCRATCH command for files, since it
doesn't really erase any data from the disk -- just frees the entry,
in this case just in the BAM.

FORMAT FOR BLOCK-FREE COMMAND:

   PRINT#file#, "BLOCK-FREE:" drive; track; block

or abbreviated as

   PRINT#file#, "B-F:" drive; track; block



6.7 USING RANDOM FILES

The only problem with what you've learned about random files so far is
that you have no way of keeping track of which blocks on the disk you
used.  After all, you can't tell one used block on the BAM from
another.  You can't tell whether it contains your random file, just
part of a program, or even sequential or relative files.

To keep track, the most common method is to build up a sequential file
to go with each random file.  Use this file to keep just a list of
record, track, and block locations. This means that there are 3
channels open to the disk for each random file: one for the command
channel, one for the random data, and the other for the sequential
data. This also means that there are 2 buffers that you're filling up
at the same time!

SAMPLE PROGRAM WRITING 10 RANDOM-ACCESS BLOCKS WITH SEQUENTIAL FILE:

 10 OPEN 15,8,15
 20 OPEN 5,8,5,"#"
 30 OPEN 4,8,4,"@0:KEYS,S,W"
 40 A$="RECORD CONTENTS #"
 50 FOR R=1 TO 10
 70 PRINT#5,A$","R
 90 T=1:B=1  <-------------------------+---------------------+
 100 PRINT#15,"B-A:"0;T;B  <-----------+ FIND NEXT AVAILABLE |
 110 INPUT#15,A,B$,C,D  <--------------+ TRACK & BLOCK       |
 120 IF A=65 THEN T=C:B=D:GOTO 100  <--+---------------------+
 130 PRINT#15,"B-W:"5;0;T;B
 140 PRINT#4,T","B
 150 NEXT R
 160 CLOSE 4:CLOSE 5:CLOSE 15

SAMPLE PROGRAM READING BACK 10 RANDOM-ACCESS BLOCKS WITH SEQUENTIAL
FILE:

 10 OPEN 15,8,15                  +------------+
 20 OPEN 5,8,5,"#"                | CHECKS TO  |
 30 OPEN 4,8,4,"KEYS,S,R"         | MAKE SURE  |
 40 FOR R=1 TO 10                 | DATA IS OK |
 50 INPUT#4,T,B                   +------------+
 60 PRINT#15,"B-R:"5;0;T;B        |
 80 INPUT#5,A$,X                  |
 90 IF A$<>"RECORD CONTENTS #" OR X<>R THEN STOP
 100 PRINT A$;R
 110 PRINT#15,"B-F:"0;T;B  <---+---------------+
 120 NEXT R                    | FREES THIS    |
 130 CLOSE 4:CLOSE 5           | TRACK & BLOCK |
 140 PRINT#15,"S0:KEYS"        | FOR LATER USE |
 150 CLOSE 15                  +---------------+



6.8 BUFFER-POINTER

The buffer pointer keeps track of where the last piece of data was
written.  It also is the pointer for where the next piece of data is
to be read.  By changing the buffer pointer's location within the
buffer, you can get random access to the individual bytes within a
block.  This way, you can subdivide each block into records.

For example, let's take a hypothetical mailing list.  The information
such as name, address, etc., will take up a total of 64 characters
maximum.  We could divide each block of the random access file into 4
separate records, and by knowing the track, sector, and record numbers,
we can access that individual record.

FORMAT FOR BUFFER-POINTER COMMAND:

   PRINT#file#, "BUFFER-POINTER:" channel; location

or abbreviated as

   PRINT#file#, "B-P:" channel; location

EXAMPLE OF SETTING POINTER TO 64TH CHARACTER OF BUFFER:

   PRINT#15, "B-P:" 5; 64

Here are versions of the random access writing and reading programs
shown above, modified to work with records within blocks:

SAMPLE PROGRAM WRITING 10 RANDOM-ACCESS BLOCKS WITH 4 RECORDS EACH:

 10 OPEN 15,8,15
 20 OPEN 5,8,5,"#"
 30 OPEN 4,8,4,"@0:KEYS,S,W"
 40 A$="RECORD CONTENTS #"             +--------------------+
 50 FOR R=1 TO 10                      | SET POSITION       |
 60 FOR L=1 TO 4                       | TO 1, 65, 129, 193 |
 70 PRINT#15,"B-P:"5;(L-1)*64+1  <-----+--------------------+
 80 PRINT#5,A$","L
 90 NEXT L
 100 T=1:B=1                           +---------------------+
 110 PRINT#15,"B-A:"0;T;B  <-----------+ FIND NEXT AVAILABLE |
 120 INPUT#15,A,B$,C,D  <--------------+ TRACK & BLOCK       |
 130 IF A=65 THEN T=C:B=D:GOTO 110  <--+---------------------+
 140 PRINT#15,"B-W:"5;0;T;B
 150 PRINT#4,T","B
 160 NEXT R
 170 CLOSE 4:CLOSE 5:CLOSE 15

SAMPLE PROGRAM READING BACK 10 RANDOM-ACCESS BLOCKS WITH 4 RECORDS
EACH:

 10 OPEN 15,8,15
 20 OPEN 5,8,5,"#"
 30 OPEN 4,8,4,"KEYS,S,R"
 40 FOR R=1 TO 10
 50 INPUT#4,T,B
 60 PRINT#15,"B-R:"5;0;T;B
 70 FOR L=1 TO 4
 80 PRINT#15,"B-P:"5;(L-1)*64+1
 85 INPUT#5,A$,X
 90 IF A$<>"RECORD CONTENTS #" OR X<>L THEN STOP
 95 PRINT R;A$;L
 100 NEXT L
 110 PRINT#15,"B-F:"0;T;B
 120 NEXT R
 130 CLOSE 4:CLOSE 5
 140 PRINT#15,"S0:KEYS"
 150 CLOSE 15



6.9 USER1 and USER2

The USER commands are generally designed to work with machine language
(see chapter 8 for more on this).  The USER1 and USER2 commands are
special versions of the BLOCK-READ and BLOCK-WRITE commands, but...
with an important difference: the way USER1 and USER2 work with the
buffer-pointer.

The BLOCK-READ command reads up to 256 characters, but stops reading
when the buffer-pointer stored with the block says that block is
finished.  The USER1 command performs the BLOCK-READ operation, but
first forces the pointer to 255 in order to read the entire block of
data from the disk.

FORMAT FOR USER1 COMMAND

   PRINT#file#, "U1:" channel; drive; track; block

or

   PRINT#file#, "UA:" channel; drive; track; block

There is no difference between the U1 and UA designations for this
command.

The BLOCK-WRITE command writes the contents of the buffer to the block
on the disk along with the value of the buffer-pointer.  The USER2
command writes the buffer without disturbing the buffer-pointer value
already stored on that block of the diskette.  This is useful when a
block is to be read in with BLOCK-READ, updated through the BUFFER-
POINTER and PRINT# statements, and then written back to the diskette
with USER2.

FORMAT FOR USER2 COMMAND:

   PRINT#file#, "U2:" channel; drive; track; block

or

   PRINT#file#, "UB:" channel; drive; track; block

For a more complex sample program, see Appendix C.



7. RELATIVE FILES

[ 7.1 INTRODUCTION ]

RELative files allow you to easily zero in on exactly the piece of
data that you want from the file.  It is more convenient for data
handling because it allows you to structure your files into records,
and into fields within those records.

The DOS keeps track of the tracks and blocks used, and even allows
records to overlap from one block to the next.  It is able to do this
because it establishes side sectors, a series of pointers for the
beginning of each record.  Each side sector can point to up to 120
records, and there may be 6 side sectors in a file.  There can be up
to 720 records in a file, and each record can be up to 254 characters,
so the file could be as large as the entire diskette.



7.2 CREATING A RELATIVE FILE

When a RELative file is first to be used, the OPEN statement will
create that file; after that, that same file will be used.  The
replace option (with the @ sign) does not erase and re-create the file.
. The file can be expanded, read, and written into.

FORMAT FOR THE OPEN STATEMENT TO CREATE RELATIVE FILE:

    OPEN file#, device#, channel#, "name,L," + CHR$(record length)

EXAMPLES OF OPEN STATEMENT CREATING RELATIVE FILES:

    OPEN 2, 8, 2, "FILE,L," + CHR$(100)  <--+---------------+
    OPEN F, 8, F, A$+ ",L," + CHR$(Q)  <----+ Record Length |
    OPEN A, B, C, "TEST,L," + CHR$(33)  <---+---------------+

Table 7.1: RELATIVE FILE FORMAT

 +---------------------------------------------------------------+
 | DATA BLOCK                                                    |
 +---------------------------------------------------------------+
 | BYTE   | DEFINITION                                           |
 +--------+------------------------------------------------------+
 | 0,1    | Track and block of next data block.                  |
 +--------+------------------------------------------------------+
 | 2-256  | 254 bytes of data. Empty records contain FF (all     |
 |        | binary ones) in the first byte followed by 00        |
 |        | (binary all zeros) to the end of the record.         |
 |        | Partially filled records are padded with nulls (00). |
 +---------------------------------------------------------------+
 | SIDE SECTOR BLOCK                                             |
 +--------+------------------------------------------------------+
 | BYTE   | DEFINITION                                           |
 +--------+------------------------------------------------------+
 | 0,1    | Track and block of next side sector block.           |
 +--------+------------------------------------------------------+
 | 2      | Side sector number. (0-5)                            |
 +--------+------------------------------------------------------+
 | 3      | Record length.                                       |
 +--------+------------------------------------------------------+
 | 4,5    | Track and block of first side sector (number 0)      |
 +--------+------------------------------------------------------+
 | 6,7    | Track and block of second side sector (number 1)     |
 +--------+------------------------------------------------------+
 | 8,9    | Track and block of third side sector (number 2)      |
 +--------+------------------------------------------------------+
 | 10,11  | Track and block of fourth side sector (number 3)     |
 +--------+------------------------------------------------------+
 | 12,13  | Track and block of fifth side sector (number 4)      |
 +--------+------------------------------------------------------+
 | 14,15  | Track and block of sixth side sector (number 5)      |
 +--------+------------------------------------------------------+
 | 16-256 | Track and block pointers to 120 data blocks.         |
 +--------+------------------------------------------------------+

Upon execution, the DOS first checks to see if the file exists.  If it
does, then nothing happens.  The only way to erase an old relative
file is by using the SCRATCH command (see chapter 4), but not by using
the replace option.



7.3 USING RELATIVE FILES

In order to OPEN a relative file once it exists, the format is simpler.


FORMAT FOR OPENING AN EXISTING RELATIVE FILE:

    OPEN file#, device#, channel#, "name"

In this case, the DOS automatically knows that it is a relative file.
This syntax, and the one shown in the above section, both allow either
reading or writing to the file.

In order to read or write, you must, before any operation, position
the file pointer to the correct record position.

FORMAT FOR POSITION COMMAND:

    PRINT#file#, "P" CHR$(channel#+96) CHR$(rec#lo) CHR$(rec#hi)
    CHR$(position)

EXAMPLES OF POSITION COMMAND:

    PRINT#15, "P" CHR$(2+96) CHR$(1) CHR$(0)

    PRINT#15, "P" CHR$(CH+96) CHR$(R1) CHR$(R2)

    PRINT#15, "P" CHR$(4+96) CHR$(R1) CHR$(R2) CHR$(P)
                       |          |        |        |
	   +-----------+----------+--------+  +-----+---------+
	   | Channel # | Record #          |  | Position      |
	   +-----------+-------------------+  | within Record |
					      +---------------+

The 2-byte format for the record number is needed because one byte can
only hold 256 different numbers, and we can have over 700 records in
the file.  The rec# lo contains the least significant part of the
address, and the rec# hi is the most significant part.  This could be
translated to the actual record number by the formula REC# = REC HI *
256 + REC LO.

If the record number is known, the high and low bytes can be
determined as follows:

    REC# HI= INT(REC#/256)
    REC# LO= REC# - REC# HI*256

EXAMPLE:

    PRINT#15, "P" CHR$(4+96) CHR$(R1) CHR$(R2) CHR$(0)

    IF REC# = 540: R2 = INT(540/256) ... so R2 = 2
                   RI = 540 - R2*256 ... so RI = 28

Let's assume we have a mailing list.  The list consists of 8 pieces of
data, according to this chart:

    Field Name               Length

    first name               12
    last name                15
    address line 1           20
    address line 2           20
    city                     12
    state                     2
    zip code                  9
    phone number             10
    ----------------------------
    TOTAL                   100

This is how the record length is determined.  We would probably want
to allow an extra character in length for each field, to allow for
separations; otherwise the INPUT# command would pick up a much longer
piece of the file than needed, just like in sequential files.
Therefore, we'll set up a file with a length of 108 characters per
record. In the first record, we'll put the number 1, representing the
largest record# used so far. Here is the program as described so far:

 5 X=0
 10 OPEN 1,8,15
 20 OPEN 2,8,3,"0:MAILING LIST,L," + CHR$(108)
 30 GOSUB 900
 40 PRINT#1 "P" CHR$(3+96) CHR$(1) CHR$(0) CHR$(1)
 50 GOSUB 900
 60 IF E=50 THEN PRINT#2,1:GOTO 40
 70 INPUT#2,X
 75 PRINT X
 300 STOP:CLOSE 1:CLOSE 2:END
 900 INPUT#1,E,B$,C,D: REM ERROR SUBROUTINE
 910 IF (E=50) OR (E<20) THEN RETURN
 920 PRINT E;B$;C;D:STOP:RETURN

Error #50 which is checked in line 60 of the program is the RECORD NOT
PRESENT error, which means that the record hadn't been created yet.
Writing into the record will solve the problem.  This error condition
must be watched carefully within your programs.

So far, all it does is create the file and the first record, but
doesn't actually put any data in it.  Below is a greatly expanded
version of the program, to actually allow you to work with a mailing
list where the records are coded by numbers.

start tok64 maillist.prg
 5 a(1)=12: a(2)=15: a(3)=20: a(4)=20: a(5)=12: a(6)=2: a(7)=9: \
   a(8)=10
 9 rem open relative file called "mailing list"
 10 open 1,8,15:open 2,8,3,"0:mailing list,l,"+chr$(108):gosub 900
 20 print#1,"p" chr$(3+96) chr$(1) chr$(0) chr$(1):input#2,x$:\
    x=val(x$): if x=0 then x=2
 30 input "read,write,or end";j$:if j$="e" then close 2:close 1:end
 40 if j$="w" then 200
 50 print:input "record #";r:if r<0 or r>x then 50:rem read rout
 60 if r<2 then 30
 70 r1=r:r2=0:if r1>256 then r2=int(r1/256):r1=r1-256*r2
 80 restore:data 1,first name,14,last name,30,address1,51,address2
 90 data 72,city,85,state,88,zip,98,phone#
 100 for l=1 to 8:read a,a$:print#1,"p" chr$(3+96) chr$(r1) \
     chr$(r2) chr$(a):gosub 900
 110 on a/50 goto 50
 115 input#2,z$:print a$,z$:next:goto 50
 200 print:input "record #";r:if r<0 or r>500 then 200:rem write rout
 210 if r<2 then 30
 215 if r>x then r=x+1:print:print "record#"; r
 220 r1=r:r2=0:if r>255 then r2=int(r1/256):r1=r1-256*r2
 230 restore:for l=1 to 8:read a,a$:print#1,"p" chr$(3+96)chr$(r1) \
     chr$(r2) chr$(a)
 232 gosub 900
 235 print a$;:input z$:if len(z$)>a(l) then z$=left$(z$,a(l))
 240 print#2,z$:gosub 900:next:if r>x then x=r
 245 print#1,"p" chr$(3+96) chr$(1) chr$(0) chr$(1)
 250 print#2,x:gosub 900:goto 200
 900 input#1,a,b$,c,d:if a<20 then return:rem error check rout
 910 if a<>50 then print a;b$,c;d:stop:return
 920 if j$="r" then print b$
 930 return
stop tok64

begin 644 MAILLIST.PRG
M`0A)"`4`02@Q*;(Q,CH@02@R*;(Q-3H@02@S*;(R,#H@02@T*;(R,#H@02@U
M*;(Q,CH@02@V*;(R.B!!*#<ILCDZ02@X*;(Q,`!X"`D`CR!/4$5.(%)%3$%4
M259%($9)3$4@0T%,3$5$(")-04E,24Y'($Q)4U0B`*X("@"?(#$L."PQ-3J?
M(#(L."PS+"(P.DU!24Q)3D<@3$E35"Q,+"*JQR@Q,#@I.HT@.3`P`.L(%`"8
M,2PB4"(@QR@SJCDV*2#'*#$I(,<H,"D@QR@Q*3J$,BQ8)#I8LL4H6"0I.B"+
M(%BR,""G(%BR,@`="1X`A2`B4D5!1"Q74DE412Q/4B!%3D0B.THD.HL@2B2R
M(D4B(*<@H"`R.J`@,3J``#`)*`"+($HDLB)7(B"G(#(P,`!B"3(`F3J%(")2
M14-/4D0@(R([4CJ+(%*S,""P(%*Q6""G(#4P.H\@4D5!1"!23U54`'$)/`"+
M(%*S,B"G(#,P`*0)1@!2,;)2.E(RLC`ZBR!2,;$R-38@IR!2,K*U*%(QK3(U
M-BDZ4C&R4C&K,C4VK%(R`-X)4`",.H,@,2Q&25)35"!.04U%+#$T+$Q!4U0@
M3D%-12PS,"Q!1$1215-3,2PU,2Q!1$1215-3,@`&"EH`@R`W,BQ#2519+#@U
M+%-4051%+#@X+%I)4"PY."Q02$].12,`0`ID`($@3+(Q(*0@.#J'($$L020Z
MF#$L(E`B(,<H,ZHY-BD@QRA2,2D@QRA2,BG'*$$I.HT@.3`P`%`*;@"1($&M
M-3`@B2`U,`!I"G,`A#(L6B0ZF2!!)"Q:)#J".HD@-3``GPK(`)DZA2`B4D5#
M3U)$(",B.U(ZBR!2LS`@L"!2L34P,""G(#(P,#J/(%=2251%(%)/550`K@K2
M`(L@4K,R(*<@,S``T0K7`(L@4K%8(*<@4K)8JC$ZF3J9(")214-/4D0C(CL@
M4@`#"]P`4C&R4CI2,K(P.HL@4K$R-34@IR!2,K*U*%(QK3(U-BDZ4C&R4C&K
M,C4VK%(R`#D+Y@",.H$@3+(Q(*0@.#J'($$L020ZF#$L(E`B(,<H,ZHY-BG'
M*%(Q*2#'*%(R*2#'*$$I`$,+Z`"-(#DP,`!O"^L`F2!!)#LZA2!:)#J+(,,H
M6B0IL4$H3"D@IR!:)++(*%HD+$$H3"DI`(T+\`"8,BQ:)#J-(#DP,#J".HL@
M4K%8(*<@6+)2`*\+]0"8,2PB4"(@QR@SJCDV*2#'*#$I(,<H,"D@QR@Q*0#$
M"_H`F#(L6#J-(#DP,#J)(#(P,`#R"X0#A#$L02Q")"Q#+$0ZBR!!LS(P(*<@
MCCJ/($524D]2($-(14-+(%)/550`#PR.`XL@0;.Q-3`@IR"9($$[0B0L0SM$
A.I`ZC@`C#)@#BR!*)+(B4B(@IR"9($(D`"D,H@..````
`
end

This program asks for record numbers when retrieving records.  It
won't let you retrieve from beyond the end of the file, and if you try
to write beyond the end it forces you to write on the next higher
record.

A more advanced version than this would keep track of the items by
"keys", to index the records.  For example, you would probably want to
search for a record by name, or print out labels by zip code.  For
this you would need a separate list of keys and record numbers,
probably stored in sequential files.

When working with a new relative file that will soon be very large, it
will save much time to create a record at the projected end of the
file. In other words, if you expect the file to be 1000 records long,
create a record# 1000 as soon as the file is created. This will force
the DOS to create all intermediate records, making later use of those
records much faster.

EXAMPLE OF CREATING LARGE FILE:

    OPEN 1, 8, 15: OPEN 2, 8, 2, "0:REL,L," + CHR$(60)
    PRINT#1, "P" CHR$(2+96) CHR$(0) CHR$(4) CHR$(1)
    PRINT#2, "END"
    CLOSE 2: CLOSE 1

PROGRAM AND EXPLANATION

start tok64 relfile.prg
 1 rem relative file program
 2 dim a$(5):dim c$(5):print"{clear}"
 3 print "hit f1 to construct a relative file"
 4 print "hit f3 to read a relative file"
 5 print "hit f5 to read the error channel":gosub 5000
 6 input "enter relative file name";z$
 8 open 2,8,2,z$+",l,"+chr$(50):rem create the relative file
 9 open 1,8,15
 11 gosub 1000
 20 for i=1 to 5
 30 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(1):rem position the \
    record pointer
 40 print "enter a name"
 50 input a$(i)
 60 print#2,a$(i)
 63 input "enter additional info";c$(i)
 65 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(25):rem position \
    pointer to 25th character
 67 print#2,c$(i)
 70 next i
 75 print "do you wish to replace a record":input d$
 76 if d$="n" then 80
 77 gosub 8000
 78 go to 75
 80 print "the relative file is constructed"
 82 for de=1 to 2500: next de: gosub 6000
 85 close 2
 90 end:stop
 100 input "enter desired file to read";z$
 105 open 2,8,2,z$:open 1,8,15
 106 print "reading " z$
 110 for i=1 to 5
 115 rem for i=5 to 1 step -1
 130 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(1)
 160 input#2,a$(i)
 170 print "record#(" i ")=", a$(i)
 175 k=6-i
 177 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(25)
 179 input#2,c$(i):print "additional info:";c$(i)
 180 next i
 181 print "do you wish to replace a record":input d$
 182 if d$="n" then 185
 183 gosub 8000
 184 go to 181
 185 gosub 1000
 186 j=i+1
 190 print "end of read":for de=1 to 1500:next de:gosub 6000:\
     close 2:close 1:end
 1000 input#1,a,b$,c,d:if a<20 then return
 1001 if a<>50 then print a,b$,c,d :stop: return
 1999 end
 2000 open 15,8,15
 2001 input#15,a,b$,c,d
 2002 print a,b$,c,d
 2003 close 15:end
 5000 get s$:if s$="" then 5000: rem scan keyboard for function \
      key chr$ codes
 5001 if s$=chr$(133) then 6: rem assign f1 function key
 5002 if s$=chr$(134) then 100: rem assign f3 function key
 5003 if s$=chr$(135) then 2000: rem assign f5 function key
 5004 return
 6000 print "{clear}hit f7: for hard copy or c to continue"
 6001 get p$: if p$<>chr$(136) and p$="c" then return
 6002 for de=1 to 500: next de: if p$ ="" or p$<>chr$(136) then 6000
 6003 open 4,4:cmd 4
 6004 print#4,"the " z$ " file consists of:"
 6005 for i=1 to 5
 6010 print#4,"record #";i;"=";a$(i)
 6012 print#4,"additional info ";i;"=";c$(i)
 6015 next i
 6020 close 4:return
 7000 rem to read in records in reverse order remove the rem in \
      line #115 and
 7002 rem put a rem before line#110
 7005 rem to read the 1st field of the 1st record and the 2nd \
      field of the last
 7007 rem replace the chr$(i) in line 177 with chr$(k)
 8000 print "which record # do you want replaced":input i
 8001 input "enter new record";a$(i)
 8002 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(1):rem position \
      file pointer
 8003 print#2,a$(i)
 8004 input "enter new record (field 2)";c$(i)
 8005 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(25):rem position \
      file pointer
 8007 print#2,c$(i)
 8009 print "record#";i;" has been replaced"
 8010 return
stop tok64

begin 644 RELFILE.PRG
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
KF2`B4D5#3U)$(R([23LB($A!4R!"145.(%)%4$Q!0T5$(@`?$4H?C@``````
`
end



7.4 CREATE A RELATIVE FILE

The program below, creates a relative file with 2 fields.  The first
field starts in position 1 of the record and the second field starts
in position 25.

LINE 8: Create the file.  Make room for records of 50 characters with
the CHR$(50). Use the Z$ as a file, input variable in LINE 6, you can
then press the f1 function key to create a file.

LINE 30: Point to the first character position of a file.  P tells the
disk drive to point to the position in the record that corresponds to
the optional, CHR$(1).

NOTE: If the CHR$ is not specified, character position defaults to 1.

LINE 65: Point to the twenty-fifth character position of a file.  P
tells the disk drive to point to the position in the record that
corresponds to the CHR$(25).

NOTE: The POSITION command does NOT write anything to, or read
anything from the file.  It just points to the position specified in
the record.

WRITE TO A RELATIVE FILE

LINE 60: Use the PRINT# statement after the POSITION command to move
to character position 1, as specified in LINE 30 -- CHR$(1).

READ FROM A RELATIVE FILE

LINE 130: Specify the character position using the POSITION command.
Then follow it with LINE 160, the INPUT# statement.

7.5 SUMMARY

In this program, you press the f1 key and a RELative file is created
on disk.  You can type RUN and press the f3 key to READ the previous
RELative file.  If an error condition exists (flashing red light on
the disk drive) you can hit the RUN/STOP key, type RUN and press the
f5 key.  This reads the ERROR CHANNEL from the drive, shows the error
number and message, as well as the track and sector of the error.  It
then resets the drive for use.  Later on the program asks if the file
should be printed.  To Print the file, press the f7 key when prompted,
or press C to continue.

REMEMBER:

1) Before a file can be written to, or read from, a POSITION command
must be executed.

2) You must always use PRINT#1 with the POSITION command. This puts
your data under command channel control.

3) The FIRST character string code in the POSITION command must
correspond to the THIRD number (channel #) in the OPEN statement.
Except OPEN 1, 8, 15 (see lines 8 and 30 of above program).

4) For convenience, use the FOR ... NEXT loop variable in the SECOND
character string, CHR$(I), of the POSITION command where I equals the
record number (see lines 20 and 30 of above program).

7.6 MODIFYING THE PROGRAM

1) You can add more POSITION commands to make more fields within each
record. Remember to include the character position number as the last
CHR$, when adding fields.

2) To change the length of each record, change the value of CHR$(50)
in LINE 8.

3) The number of records in the file is determined by the POSITION
command. The current example can process 5 records; the FOR ... NEXT
loop variable is 1 to 5. The program can process 720 records, but in
order to use more than 512 records, the number 2 must be in the THIRD
CHR$() of the POSITION command.  For more than 256, use the number 1.
For up to 256 records, simply use the FOR ... NEXT loop variable.
EXAMPLE: FOR I=1 TO 256 may access 256 records.



8. PROGRAMMING THE DISK CONTROLLER

The expert programmer can actually design routines that reside and
operate on the disk controller.  DOS routines can be added that come
from the diskette.  Routines can be added much the same way as the DOS
Support Program is "wedged" into your memory.

8.1 BLOCK-EXECUTE

This command will load a block from the diskette containing a machine
language routine, and begin executing it at location 0 in the buffer
until a RTS (ReTurn from Subroutine) command is encountered.

FORMAT FOR BLOCK-EXECUTE:

    PRINT#file#, "B-E:" channel; drive; track; block



8.2 MEMORY-READ

There is 16K of ROM in the disk drive as well as 2K of RAM.  You can
get direct access to these, or to the buffers that the DOS has set up
in the RAM, by using the MEMORY commands.  MEMORY-READ allows you to
select which byte to read, through the error channel.

FORMAT FOR MEMORY-READ:

    PRINT#file#, "M-R" CHR$(low byte of address) CHR$(high byte)
    (no abbreviation!)

The next byte read using the GET# statement through channel# 15, the
error channel, will be from that address in the disk controller's
memory, and successive bytes will be from successive memory locations.

Any INPUT# to the error channel will give peculiar results when you're
using this command.  This can be cleared up by any other command to
the disk (aside from a memory command).

PROGRAM TO READ THE DISK CONTROLLER'S MEMORY:

start tok64 rdiskmem.prg
 10 open 15,8,15
 20 input "location please";a
 25 for l=1 to 50
 30 a1=int(a/256):a2=a-a1*256
 40 print#15,"m-r" chr$(a2)chr$(a1)
 50 get#15,a$: rem get chars from error channel
 60 print asc(a$+chr$(0))
 70 a=a+1
 80 next
 90 input "continue";a$
 100 if left$(a$,1)="y" then 25
 110 goto 20
stop tok64

begin 644 RDISKMEM.PRG
M`0@/"`H`GR`Q-2PX+#$U`"D(%`"%("),3T-!5$E/3B!03$5!4T4B.T$`.`@9
M`($@3+(Q(*0@-3``5`@>`$$QLK4H0:TR-38I.D$RLD&K03&L,C4V`&T(*`"8
M,34L(DTM4B(@QRA!,BG'*$$Q*0"9"#(`H2,Q-2Q!)#H@CR!'150@0TA!4E,@
M1E)/32!%4E)/4B!#2$%.3D5,`*H(/`"9(,8H022JQR@P*2D`M`A&`$&R0:HQ
M`+H(4`""`,X(6@"%(")#3TY424Y512([020`Y0AD`(L@R"A!)"PQ*;(B62(@
0IR`R-0#N"&X`B2`R,```````
`
end



8.3 MEMORY-WRITE

The MEMORY-WRITE command allows you to write up to 34 bytes at a time
into the disk controller's memory.  The MEMORY-EXECUTE and USER
commands can be used to run this code.

FORMAT FOR MEMORY-WRITE:

    PRINT#file#, "M-W" CHR$(low address byte) CHR$(high address byte)
    CHR$(#-of-characters) byte data

PROGRAM TO WRITE AN "RTS" TO DISK:

 10 OPEN 8,8,15,"I": REM INITIALIZE DISK FIRST
 20 PRINT#8,"M-W" CHR$(0) CHR$(3) CHR$(1) CHR$(96)
 30 PRINT#8,"M-E" CHR$(0) CHR$(3)
 40 CLOSE 8



8.4 MEMORY-EXECUTE

Any routine in the DOS memory, RAM or ROM, can be executed with the
MEMORY-EXECUTE command.

FORMAT FOR MEMORY-EXECUTE:

    PRINT#file#, "M-E" CHR$(low address byte) CHR$(high byte)

See line 30 above for an example.

8.5 USER COMMANDS

Aside from the USER1 and USER2 commands discussed in chapter 6, and
the UI+ and UI- commands in chapter 2, the USER commands are jumps to
a table of locations in the disk drive's RAM memory.

USER COMMAND                    FUNCTION

 U1 or UA      BLOCK-READ without changing buffer-pointer
 U2 or UB      BLOCK-WRITE without changing buffer-pointer
 U3 or UC      jump to $0500  --+
 U4 or UD      jump to $0503    |
 U5 or UE      jump to $0506    |
 U6 or UF      jump to $0509    + (HEXADECIMAL LOCATIONS)
 U7 or UG      jump to $050C    |
 U8 or UH      jump to $05OF    |
 U9 or UI      jump to $FFFA  --+
 U; or UJ      power-up vector
 UI+           set Commodore 64 speed
 UI-           set VIC 20 speed

By loading these locations with another jump command, like JMP $0520,
you can create longer routines that operate in the disk's memory along
with an easy-to-use jump table -- even from BASIC!

EXAMPLES OF USER COMMANDS:

     PRINT# 15, "U3"
     PRINT# 15, "U"+CHR$(50+Q)
     PRINT# 15, "UI"



9. CHANGING THE DISK DRIVE DEVICE NUM[BER

9.1 SOFTWARE METHOD

The device number is selected by the drive by looking at a hardware
jumper on the board and writing the number based on that jumper in a
section of its RAM.  Once operation is underway, it is easy to write
over the previous device number with a new one.

FORMAT FOR CHANGING DEVICE NUMBER:

    PRINT#file#,"M-W:" CHR$(119) CHR$(0) CHR$(2) CHR$(address+32)
    CHR$(address+64)

EXAMPLE OF CHANGING DEVICE NUMBER (FROM 8 TO 9):

 10 OPEN 15, 8, 15
 20 PRINT# 15, "M-W" CHR$(119) CHR$(0) CHR$(2) CHR$(9+32)
    CHR$(9+64)

If you have more than one drive, it's sensible to change the address
through hardware (see below). If you must, the procedure is easy. Just
plug in the drives one at a time, and change their number to the
desired new values.  That way you won't have any conflicts.



9.2 HARDWARE METHOD

It's an easy job to permanently change the device number of your drive
for use in multiple drive systems.  The tools needed are a phillips-
head screwdriver and a knife.

STEPS TO CHANGING DEVICE NUMBER ON HARDWARE:

  1. Disconnect all cables from drive, including power.
  2. Turn drive upside down on a flat, steady surface.
  3. Remove 4 screws holding drive box together.
  4. Carefully turn drive right side up, and remove case top.
  5. Remove 2 screws on side of metal housing.
  6. Remove housing.
  7. Locate device number jumpers. If facing the front of the
     drive, it's on the left edge in the middle of the board.
  8. Cut either or both of jumpers 1 and 2 for Model 1541.
     Cut either or both of jumpers A and B for Model 1541CR.
     (see chart below)
  9. Replace housing and 2 screws, and case top and 4 screws.
 10. Re-connect cables and power up.

      DEVICE#     |      JUMPER A/1    |     JUMPER B/2
 -----------------+--------------------+-------------------
           8      |      DON'T CUT     |     DON'T CUT
 -----------------+--------------------+-------------------
           9      |         CUT        |     DON'T CUT
 -----------------+--------------------+-------------------
          10      |      DON'T CUT     |       CUT
 -----------------+--------------------+-------------------
          11      |         CUT        |       CUT



10. ASSEMBLY LANGUAGE AND THE 1541

If you want to use your 1541 disk drive to manipulate data directly
from assembly language you can use the information presented below.

Here is a list of subroutines that provide the start of memory
locations in each of the Kernal routines. These routines are used in
conjunction with the assembly language command JSR to jump to that
subroutine location in memory:

 SUBROUTINE
 SETLFS = $FFBA       ; set logical, physical & secondary addresses
 SETNAM = $FFBD       ; save length & address of filename
 OPEN   = SFFC0       ; open a logical file
 CLOSE  = $FFC3       ; close a logical file
 CHKIN  = $FFC6       ; open a channel for input
 CLRCH  = $FFCC       ; clear all channels
 BASIN  = $FFCF       ; get a byte from a file
 BSOUT  = $FFD2       ; output a character to the screen

For a more complete description as to what each routine does and what
parameters are passed to and from each routine, see your Commodore 64
or VIC-20 Programmer's Reference Guide.

Now, for a practical application of the subroutines listed above, here
is a sample program using those routines to read a sequential file on
a disk. Assume that you have stored the filename "TEST" at $C000.

 INIT                 ; initialize:
 LDA #$04             ; filename length
 LDX #$00             ; low byte of filename address
 LDY #$C0             ; high byte of filename address
 JSR SETNAM           ; save length & address of filename
 LDA #$03             ; logical address
 LDX #$08             ; device number
 LDY #$00             ; secondary address (0 = read seq. file)
 JSR SETLFS           ; set logical, physical & secondary addresses
 JSR OPEN             ; open logical file
 LDX #$03             ; set x-register to logical address
 JSR CHKIN            ; open input channel
 your program info    ; get data and print it one byte at a time
 JSR BASIN            ; get one byte
 BEQ END              ; if 0 then end of file or error
 JSR BSOUT            ; output character to the screen
 JMP your prog. info  ; loop
 END
 LDA #$03             ; set accumulator to logical address
 JSR CLOSE            ; close file
 JSR CLRCH            ; clear channels and reset defaults
 RTS                  ; end of assembly language program



APPENDIX A: DISK COMMAND SUMMARY

General Format: PRINT#file#, command

 COMMAND

 NEW                "N
 COPY               "C:new file=:orginal file
 RENAME             "R:new name=old name
 SCRATCH            "S:file name
 INITIALIZE         "I
 VALIDATE           "V
 DUPLICATE          not for single drives
 BLOCK-READ         "B-R:" channel; drive; track; block
 BLOCK-WRITE        "B-W:" channel; drive; track; block
 BLOCK-ALLOCATE     "B-A:" drive; track; block
 BLOCK-FREE         "B-F:" drive; track; block
 BUFFER-POINTER     "B-P:" channel; position
 USER1 and USER2    "Un:" channel; drive; track; block
 POSITION           "P" CHR$(channel#) CHR$(rec#lo) CHR$(rec#hi)
                     CHR$(position)
 BLOCK-EXECUTE      "B-E:" channel; drive; track; block
 MEMORY-READ        "M-R" CHR$(address lo) CHR$(address hi)
 MEMORY-WRITE       "M-W" CHR$(address lo) CHR$(address hi)
                    CHR$(#chars) "data"
 MEMORY-EXECUTE     "M-E" CHR$(address lo) CHR$(address hi)
 USER Commands      "Un"



APPENDIX B: SUMMARY OF CBM FLOPPY ERROR MESSAGES

 0         OK, no error exists.
 1         Files scratched response. Not an error condition.
 2-19      Unused error messages: should be ignored.
 20        Block header not found on disk.
 21        Sync character not found.
 22        Data block not present.
 23        Checksum error in data.
 24        Byte decoding error.
 25        Write-verify error.
 26        Attempt to write with write protect on.
 27        Checksum error in header.
 28        Data extends into next block.
 29        Disk id mismatch.
 30        General syntax error
 31        Invalid command.
 32        Long line.
 33        Invalid filename.
 34        No file given.
 39        Command file not found.
 50        Record not present.
 51        Overflow in record.
 52        File too large.
 60        File open for write.
 61        File not open.
 62        File not found.
 63        File exists.
 64        File type mismatch.
 65        No block.
 66        Illegal track or sector.
 67        Illegal system track or sector.
 70        No channels available.
 71        Directory error.
 72        Disk full or directory full.
 73        Power up message, or write attempt with DOS Mismatch.
 74        Drive not ready.

DESCRIPTION OF DOS ERROR MESSAGES

NOTE: Error message numbers less than 20 should be ignored with the
exception of 01 which gives information about the number of files
scratched with the SCRATCH command.

20: READ ERROR (block header not found) -- The disk controller is
unable to locate the header of the requested data block. Caused by an
illegal block number, or the header has been destroyed.

21: READ ERROR (no sync character) -- The disk controller is unable to
detect a sync mark on the desired track. Caused by misalignment of the
read/writer head, no diskette is present, or unformatted or improperly
seated diskette. Can also indicate a hardware failure.

22: READ ERROR (data block not present) -- The disk controller has
been requested to read or verify a data block that was not properly
written. This error message occurs in conjunction with the BLOCK
commands and indicates an illegal track and/or block request.

23: READ ERROR (checksum error in data block) -- This error message
indicates that there is an error in one or more of the data bytes. The
data has been read into the DOS memory, but the checksum over the data
is in error. This message may also indicate grounding problems.

24: READ ERROR (byte decoding error) -- The data or header as been
read into the DOS memory, but a hardware error has been created due to
an invalid bit pattern in the data byte. This message may also
indicate grounding problems.

25: WRITE ERROR (write-verify error) -- This message is generated if
the controller detects a mismatch between the written data and the
data in the DOS memory.

26: WRITE PROTECT ON -- This message is generated when the controller
has been requested to write a data block while the write protect
switch is depressed. Typically, this is caused by using a diskette
with a write a protect tab over the notch.

27: READ ERROR (checksum error in header) -- The controller has
detected an error in the header of the requested data block. The block
has not been read into the DOS memory.  This message may also indicate
grounding problems.

28: WRITE ERROR (long data block) -- The controller attempts to detect
the sync mark of the next header after writing a data block. If the
sync mark does not appear within a predetermined time, the error
message is generated.  The error is caused by a bad diskette format
(the data extends into the next block), or by hardware failure.

29: DISK ID MISMATCH -- This message is generated when the controller
has been requested to access a diskette which has not been initialized.
The message can also occur if a diskette has a bad header.

30: SYNTAX ERROR (general syntax) -- The DOS cannot interpret the
command sent to the command channel.  Typically, this is caused by an
illegal number of file names, or pattems are illegally used. For
example, two file names may appear on the left side of the COPY
command.

31: SYNTAX ERROR (invalid command) -- The DOS does not recognize the
command.  The command must start in the first position.

32: SYNTAX ERROR (invalid command) -- The command sent is longer than
58 characters.

33: SYNTAX ERROR (invalid file name) -- Pattem matching is invalidly
used in the OPEN or SAVE command.

34: SYNTAX ERROR (no file given) -- the file name was left out of a
command or the DOS does not recognize it as such.  Typically, a colon
(:) has been left out of the command,

39: SYNTAX ERROR (invalid command) -- This error may result if the
command sent to command channel (secondary address 15) is unrecognized
by the DOS.

50: RECORD NOT PRESENT -- Result of disk reading past the last record
through INPUT#, or GET# commands.  This message will also occur after
positioning to a record beyond end of file in a relative file.  If the
intent is to expand the file by adding the new record (with a PRINT#
command), the error message may be ignored.  INPUT or GET should not
be attempted after this error is detected without first repositioning.

51: OVERFLOW IN RECORD -- PRINT# statement exceeds record boundary.
Information is cut off.  Since the carriage return is sent as a record
terminator is counted in the record size.  This message will occur if
the total characters in the record (including the final carriage
return) exceeds the defined size.

52: FILE TOO LARGE -- Record position within a relative file indicates
that disk overflow will result.

60: WRITE FILE OPEN -- This message is generated when a write file
that has not been closed is being opened for reading.

61: FILE NOT OPEN -- This message is generated when a file is being
accessed that has not been opened in the DOS.  Sometimes, in this case,
a message is not generated; the request is simply ignored.

62: FILE NOT FOUND -- The requested file does not exist on the
indicated drive.

63: FILE EXISTS -- The file name of the file being created already
exists on the diskette.

64: FILE TYPE MISMATCH -- The file type does not match the file type
in the directory entry for the requested file.

65: NO BLOCK -- This message occurs in conjunction with the B-A
command.  It indicates that the block to be allocated has been
previously allocated.  The parameters indicate the track and sector
available with the next highest number.  If the parameters are zero
(0), then all blocks higher in number are in use.

66: ILLEGAL TRACK AND SECTOR -- The DOS has attempted to access a
track or block which does not exist in the format being used.  This
may indicate a problem reading the pointer to the next block.

67: ILLEGAL SYSTEM T OR S -- This special error message indicates an
illegal system track or block.

70: NO CHANNEL (available) -- The requested channel is not available,
or all channels are in use.  A maximum of five sequential files may be
opened at one time to the DOS.  Direct access channels may have six
opened files.

71: DIRECTORY ERROR -- The BAM does not match the internal count.
There is a problem in the BAM allocation or the BAM has been
overwritten in DOS memory.  To correct this problem, reinitialize the
diskette to restore the BAM in memory.  Some active files may be
terminated by the corrective action.  NOTE: BAM = Block Availability
Map

72: DISK FULL -- Either the blocks on the diskette are used or the
directory is at its entry limit. DISK FULL is sent when two blocks are
available on the 1541 to allow the current file to be closed.

73: DOS MISMATCH (73, CBM DOS V2.6 1541) -- DOS 1 and 2 are read
compatible but not write compatible.  Disks may be interchangeably
read with either DOS, but a disk formatted on one version cannot be
written upon with the other version because the format is different.
This error is displayed whenever an attempt is made to write upon a
disk which has been formatted in a non-compatible format. (A utility
routine is available to assist in converting from one format to
another.) This message may also appear after power up.

74: DRIVE NOT READY -- An attempt has been made to access the 1541
Single Drive Floppy Disk without any diskettes present in either drive.



APPENDIX C: Demonstration Disk Programs

1. DIR

start tok64 dir.prg
 4 open 2,8,15
 5 print "{clear}":goto 10000
 10 open 1,8,0,"$0"
 20 get#1,a$,b$
 30 get#1,a$,b$
 40 get#1,a$,b$
 50 c=0
 60 if a$<>"" then c=asc(a$)
 70 if b$<>"" then c=c+asc(b$)*256
 80 print "{reverse on}" mid$(str$(c),2);tab(3);"{reverse off}";
 90 get#1,b$:if st<>0 then 1000
 100 if b$<>chr$(34) then 90
 110 get#1,b$:if b$<>chr$(34)then printb$;:goto110
 120 get#1,b$:if b$=chr$(32) then 120
 130 print tab(18);:c$=""
 140 c$=c$+b$:get#1,b$:if b$<>"" then 140
 150 print "{reverse on}" left$(c$,3)
 160 get t$:if t$<>"" then gosub 2000
 170 if st=0 then 30
 1000 print" blocks free"
 1010 close 1:goto 10000
 2000 if t$="q" then close 1:end
 2010 get t$:if t$="" then 2000
 2020 return
 4000 rem disk command
 4010 c$="":print">";
 4011 get b$:if b$="" then 4011
 4012 print b$;:if b$=chr$(13) then 4020
 4013 c$=c$+b$:goto 4011
 4020 print#2,c$
 5000 print "{reverse on}";
 5010 get#2,a$:print a$;:if a$<>chr$(13) goto 5010
 5020 print "{reverse off}"
 10000 print "d-directory"
 10010 print ">-disk command"
 10020 print "q-quit program"
 10030 print "s-disk status"
 10100 get a$:if a$="" then 10100
 10200 if a$="d" then 10
 10300 if a$="." or a$=">" then 4000
 10310 if a$="q" then end
 10320 if a$="s" then 5000
 10999 goto 10100
stop tok64

begin 644 DIR.PRG
M`0@."`0`GR`R+#@L,34`(`@%`)D@(I,B.HD@,3`P,#``,0@*`)\@,2PX+#`L
M(B0P(@`_"!0`H2,Q+$$D+$(D`$T('@"A(S$L020L0B0`6P@H`*$C,2Q!)"Q"
M)`!C"#(`0[(P`'H(/`"+($$DL[$B(B"G($.RQBA!)"D`EPA&`(L@0B2SL2(B
M(*<@0[)#JL8H0B0IK#(U-@"T"%``F2`B$B(@RBC$*$,I+#(I.Z,S*3LBDB([
M`,X(6@"A(S$L0B0ZBR!35+.Q,""G(#$P,#``XPAD`(L@0B2SL<<H,S0I(*<@
M.3``!0EN`*$C,2Q")#J+($(DL[''*#,T*:<@F4(D.SJ),3$P`"$)>`"A(S$L
M0B0ZBR!")++'*#,R*2"G(#$R,``S"8(`F2"C,3@I.SI#)+(B(@!6"8P`0R2R
M0R2J0B0ZH2,Q+$(D.HL@0B2SL2(B(*<@,30P`&@)E@"9("(2(B#(*$,D+#,I
M`(,)H`"A(%0D.HL@5"2SL2(B(*<@C2`R,#`P`),)J@"+(%-4LC`@IR`S,`"G
M">@#F2(@0DQ/0TM3($92144B`+<)\@.@(#$ZB2`Q,#`P,`#,"=`'BR!4)+(B
M42(@IR"@(#$Z@`#D"=H'H2!4)#J+(%0DLB(B(*<@,C`P,`#J">0'C@#]":`/
MCR!$25-+($-/34U!3D0`#0JJ#T,DLB(B.IDB/B([`"4*JP^A($(D.HL@0B2R
M(B(@IR`T,#$Q`$$*K`^9($(D.SJ+($(DLL<H,3,I(*<@-#`R,`!5"JT/0R2R
M0R2J0B0ZB2`T,#$Q`%\*M`^8,BQ#)`!J"H@3F2`B$B([`(X*DA.A(S(L020Z
MF2!!)#LZBR!!)+.QQR@Q,RD@B2`U,#$P`)@*G!.9("*2(@"L"A`GF2`B1"U$
M25)%0U1/4EDB`,,*&B>9("(^+41)4TL@0T]-34%.1"(`V@HD)YD@(E$M455)
M5"!04D]'4D%-(@#P"BXGF2`B4RU$25-+(%-405154R(`"0MT)Z$@020ZBR!!
M)+(B(B"G(#$P,3`P`!L+V">+($$DLB)$(B"G(#$P`#@+/"B+($$DLB(N(B"P
M($$DLB(^(B"G(#0P,#``20M&*(L@022R(E$B(*<@@`!="U`HBR!!)+(B4R(@
5IR`U,#`P`&D+]RJ)(#$P,3`P````
`
end


2. VIEW BAM

start tok64 viewbam.prg
 100 rem********************************
 101 rem*  view bam for vic & 64 disk  *
 102 rem********************************
 105 open 15,8,15
 110 print#15,"i0":nu$="n/a n/a n/a n/a n/a":z4=1
 120 open 2,8,2,"#"
 130 y$="{home}{down*24}"
 140 x$="{right*23}"
 150 def fn s(z)=2^(s-int(s/8)*8) and (sb(int(s/8)))
 160 print#15,"u1:";2;0;18;0
 170 print#15,"b-p";2;1
 180 print "{clear}";
 190 y=22:x=1:gosub 430
 200 for i=0 to 20:print:print "{up*2}" right$(str$(i)+" ",3);:next
 210 get#2,a$
 220 get#2,a$
 230 get#2,a$
 240 ts=0
 250 for t=1 to 17:gosub 450
 260 y=22:x=t+4:gosub 430:gosub 540:next
 270 for i=1 to 2000:next:print "{clear}"
 280 y=22:x=1:gosub 430
 290 for i=0 to 20:print:print "{up*2}" right$(str$(i)+" ",3);:next
 300 for t=18 to 35
 310 gosub 450
 320 y=22:x=t-13:gosub 430:gosub 540:next
 330 for i=1 to 1000:next
 340 print "{clear}{down*5}"
 350 print#15,"b-p";2;144
 360 n$="":for i=1 to 20:get#2,a$:n$=n$+a$:next
 370 print" "n$" "ts-17;"blocks free"
 380 for i=1 to 4000:next
 390 print "{clear}"
 400 input "{down*3}{right*2}another diskette {right*2}n{left*3}";a$
 410 if a$="y" then run
 420 if a$<>"y" then end
 430 print left$(y$,y)left$(x$,x)"{left}";
 440 return
 450 get#2,sc$:sc=asc(right$(chr$(0)+sc$,1))
 460 ts=ts+sc
 470 get#2,a$:if a$="" then a$=chr$(0)
 480 sb(0)=asc(a$)
 490 get#2,a$:if a$="" then a$=chr$(0)
 500 sb(1)=asc(a$)
 510 get#2,a$:if a$="" then a$=chr$(0)
 520 sb(2)=asc(a$)
 530 return
 540 print "{down}{left}" right$(str$(t),1);"{left}{up*2}";
 550 rem  print t"   "sc"  "sb(0)" "sb(1)" "sb(2)=chr$(0)
 560 if t>24 and s=18 then:print mid$(nu$,z4,1);:goto 660
 570 for s=0 to 20
 580 if t<18 then 620
 590 if t>30 and s=17 then:print mid$(nu$,z4,1);:goto 660
 600 if t>24 and s=18 then:print mid$(nu$,z4,1);:goto 660
 610 if t>24 and s=19 then:print mid$(nu$,z4,1);:goto 660
 620 if t>17 and s=20 then:print mid$(nu$,z4,1);:z4=z4+1:goto 660
 630 print "{reverse on}";
 640 if fns(s)=0 then print "{";:goto 660
 650 print "{reverse off}{";:rem right$(str$(s),1);z4,1);:goto 72
 660 print "{up}{left}{reverse off}";
 670 next
 680 return
stop tok64

begin 644 VIEWBAM.PRG
M`0@G"&0`CRHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ`$T(90"/
M*B`@5DE%5R!"04T@1D]2(%9)0R`F(#8T($1)4TL@("H`<PAF`(\J*BHJ*BHJ
M*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*@"!"&D`GR`Q-2PX+#$U`*T(;@"8
M,34L(DDP(CI.522R(DXO02!.+T$@3B]!($XO02!.+T$B.EHTLC$`O0AX`)\@
M,BPX+#(L(B,B`.`(@@!9)+(B$Q$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$2(`
M`0F,`%@DLB(='1T='1T='1T='1T='1T='1T='1T='2(`+`F6`)8@I2!3*%HI
MLC*N*%.KM2A3K3@IK#@I(*\@*%-"*+4H4ZTX*2DI`$,)H`"8,34L(E4Q.B([
M,CLP.S$X.S``50FJ`)@Q-2PB0BU0(CLR.S$`8`FT`)D@(I,B.P!S";X`6;(R
M,CI8LC$ZC2`T,S``G`G(`($@2;(P(*0@,C`ZF3J9("*1D2(@R2C$*$DIJB(@
M(BPS*3LZ@@"G"=(`H2,R+$$D`+()W`"A(S(L020`O0GF`*$C,BQ!)`#&"?``
M5%.R,`#;"?H`@2!4LC$@I"`Q-SJ-(#0U,`#X"00!6;(R,CI8LE2J-#J-(#0S
M,#J-(#4T,#J"`!$*#@&!($FR,2"D(#(P,#`Z@CJ9("*3(@`D"A@!6;(R,CI8
MLC$ZC2`T,S``30HB`8$@2;(P(*0@,C`ZF3J9("*1D2(@R2C$*$DIJB(@(BPS
M*3LZ@@!="BP!@2!4LC$X(*0@,S4`9PHV`8T@-#4P`(4*0`%9LC(R.EBR5*LQ
M,SJ-(#0S,#J-(#4T,#J"`)@*2@&!($FR,2"D(#$P,#`Z@@"G"E0!F2`BDQ$1
M$1$1(@"["EX!F#$U+")"+5`B.S([,30T`.(*:`%.)+(B(CJ!($FR,2"D(#(P
M.J$C,BQ!)#I.)+).)*I!)#J"``,+<@&9(B`B3B0B(")44ZLQ-SLB0DQ/0TM3
M($92144B`!8+?`&!($FR,2"D(#0P,#`Z@@`@"X8!F2`BDR(`2`N0`84@(A$1
M$1T=04Y/5$A%4B!$25-+151412`='4Z=G9TB.T$D`%D+F@&+($$DLB)9(B"G
M((H`:PND`8L@022SL2)9(B"G((``A`NN`9D@R"A9)"Q9*<@H6"0L6"DBG2([
M`(H+N`&.`*H+P@&A(S(L4T,D.E-#LL8HR2C'*#`IJE-#)"PQ*2D`MPO,`513
MLE13JE-#`-0+U@&A(S(L020ZBR!!)+(B(B"G($$DLL<H,"D`Y`O@`5-"*#`I
MLL8H020I``$,Z@&A(S(L020ZBR!!)+(B(B"G($$DLL<H,"D`$0ST`5-"*#$I
MLL8H020I`"X,_@&A(S(L020ZBR!!)+(B(B"G($$DLL<H,"D`/@P(`E-"*#(I
MLL8H020I`$0,$@*.`&`,'`*9("(1G2(@R2C$*%0I+#$I.R*=D9$B.P"7#"8"
MCR`@4%))3E0@5"(@("`B4T,B("`B4T(H,"DB(")30B@Q*2(@(E-"*#(I/4-(
M4B0H,"D`P`PP`HL@5+$R-""O(%.R,3@@ISJ9(,HH3E4D+%HT+#$I.SJ)(#8V
M,`#/##H"@2!3LC`@I"`R,`#@#$0"BR!4LS$X(*<@-C(P``D-3@*+(%2Q,S`@
MKR!3LC$W(*<ZF2#**$Y5)"Q:-"PQ*3LZB2`V-C``,@U8`HL@5+$R-""O(%.R
M,3@@ISJ9(,HH3E4D+%HT+#$I.SJ)(#8V,`!;#6("BR!4L3(T(*\@4[(Q.2"G
M.ID@RBA.520L6C0L,2D[.HD@-C8P`(P-;`*+(%2Q,3<@KR!3LC(P(*<ZF2#*
M*$Y5)"Q:-"PQ*3LZ6C2R6C2J,3J)(#8V,`"7#78"F2`B$B([`+0-@`*+(*53
M*%,ILC`@IR"9(")[(CLZB2`V-C``XPV*`ID@(I)[(CLZCR!224=(5"0H4U12
M)"A3*2PQ*3M:-"PQ*3LZ1T]43R`W,@#P#90"F2`BD9V2(CL`]@V>`H(`_`VH
%`HX`````
`
end


3. DISPLAY T & S

start tok64 dispts.prg
 100 rem******************************
 110 rem* display any track $ sector *
 120 rem* on the disk to the screen  *
 130 rem* or the printer             *
 140 rem******************************
 150 print "{clear}{down*2}{175*22}"
 160 print "display block contents"
 165 print "{183*22}"
 170 rem******************************
 180 rem* set program constant       *
 190 rem******************************
 200 sp$=" ":nl$=chr$(0):hx$="0123456789abcdef"
 210 fs$="":for i=64 to 95:fs$=fs$+"{reverse on}"+chr$(i)+\
     "{reverse off}":next i
 220 ss$="  ":for i=192 to 223:ss$=ss$+"{reverse on}"+chr$(i)+\
     "{reverse off}":next i
 240 dim a$(15),nb(2)
 251 d$="0"
 253 print "        {reverse on}s{reverse off}creen{down}{left*8}";\
     "or {down}{left}{reverse on}p{reverse off}rinter"
 254 get jj$:if jj$="" then 254
 255 if jj$="s" then print "        {down}{reverse on}screen";\
     "{reverse off}"
 256 if jj$="p" then print "        {down}{reverse on}printer";\
     "{reverse off}"
 260 open 15,8,15,"i"+d$:gosub 650
 265 open 4,4
 270 open 2,8,2,"#":gosub 650
 280 rem******************************
 290 rem* load track and sector      *
 300 rem* into disk buffer           *
 310 rem******************************
 320 input "{down}{right*2}track, sector";t,s
 330 if t=0 or t>35 then print#15,"i"d$:close 2:close 4:close 15:\
     print "end":end
 340 if jj$="s" then print "{down}{right*2}track" t " sector" s \
     "{down}"
 341 if jj$="p" then print#4:print#4,"track" t " sector" s:print#4
 350 print#15,"u1:2," d$;t;s:gosub 650
 360 rem******************************
 370 rem* read byte 0 of disk buffer *
 390 rem******************************
 400 print#15,"b-p:2,1"
 410 print#15,"m-r"chr$(0)chr$(5)
 420 get#15,a$(0):if a$(0)="" then a$(0)=nl$
 428 if jj$="s" then 430
 430 if jj$="p"then 460
 431 rem******************************
 432 rem* read & crt display         *
 433 rem* rest of the disk buffer    *
 434 rem******************************
 436 k=1:nb(1)=asc(a$(0))
 438 for j=0 to 63:if j=32 then gosub 710:if z$="n" then j=80:\
     goto 458
 440 for i=k to 3
 442 get#2,a$(i):if a$(i)="" then a$(i)=nl$
 444 if k=1 and i<2 then nb(2)=asc(a$(i))
 446 next i:k=0
 448 a$="":b$=":":n=j*4:gosub 790:a$=a$+":"
 450 for i=0 to 3:n=asc(a$(i)):gosub 790
 452 c$=a$(i):gosub 850:b$=b$+c$
 454 next i:if jj$="s" then print a$b$
 458 next j:goto 571
 460 rem******************************
 462 rem* read & printer display     *
 464 rem******************************
 466 k=1:nb(1)=asc(a$(0))
 468 for j=0 to 15
 470 for i=k to 15
 472 get#2,a$(i):if a$(i)="" then a$(i)=nl$
 474 if k=1 and i<2 then nb(2)=asc(a$(i))
 476 next i:k=0
 478 a$="":b$=":":n=j*16:gosub 790:a$=a$+":"
 480 for i=0 to 15:n=asc(a$(i)):gosub 790:if z$="n" then j=40:\
     goto 571
 482 c$=a$(i):gosub 850:b$=b$+c$
 484 next i
 486 if jj$="p" then print#4,a$b$
 488 next j:goto 571
 571 rem******************************
 572 rem* next track and sector      *
 573 rem******************************
 575 print "next track and sector" nb(1) nb(2) "{down}"
 580 print "do you want next track and sector"
 590 get z$:if z$="" then 590
 600 if z$="y" then t=nb(1):s=nb(2):goto 330
 610 if z$="n" then 320
 620 goto 590
 630 rem******************************
 640 rem* subroutines                *
 650 rem******************************
 660 rem* error routine              *
 670 rem******************************
 680 input#15,en,em$,et,es:if en=0 then return
 690 print "{reverse on}disk error{reverse off}" en,em$,et,es
 700 end
 710 rem******************************
 720 rem* screen continue message    *
 730 rem******************************
 740 print "{down}{right*4}continue(y/n)"
 750 get z$:if z$="" then 750
 760 if z$="n" then return
 770 if z$<>"y" then 750
 780 print "{clear}track" t " sector" s "{home}":return
 790 rem******************************
 800 rem* disk byte to hex print     *
 810 rem******************************
 820 a1=int(n/16):a$=a$+mid$(hx$,a1+1,1)
 830 a2=int(n-16*a1):a$=a$+mid$(hx$,a2+1,1)
 840 a$=a$+sp$:return
 850 rem******************************
 860 rem* disk byte to asc display   *
 870 rem* character                  *
 880 rem******************************
 890 if asc(c$)<32 then c$=" ":return
 910 if asc(c$)<128 or asc(c$)>159 then return
 920 c$=mid$(ss$,3*(asc(c$)-127),3):return
stop tok64

begin 644 DISPTS.PRG
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
H.2"G((X`5!68`T,DLLHH4U,D+#.L*,8H0R0IJS$R-RDL,RDZC@``````
`
end


4. CHECK DISK

start tok64 chekdisk.prg
 1 rem check disk -- ver 1.4
 2 dn=8:rem floppy device number
 5 dim t(100):dim s(100):rem bad track, sector array
 9 print "{clear}{down*3}{175*21}"
 10 print " check disk program"
 12 print "{183*21}"
 20 d$="0"
 30 open 15,dn,15
 35 print#15,"v"d$
 45 n%=rnd(ti)*255
 50 a$="":for i=1 to 255:a$=a$+chr$(255 and (i+n%)):next
 60 gosub 900
 70 open 2,dn,2,"#"
 80 print:print#2,a$;
 85 t=1:s=0
 90 print#15,"b-a:"d$;t;s
 100 input#15,en,em$,et,es
 110 if en=0 then 130
 115 if et=0 then 200:rem end
 120 print#15,"b-a:"d$;et;es:t=et:s=es
 130 print#15,"u2:2,"d$;t;s
 134 nb=nb+1:print" checked  blocks"nb
 135 print " track    {left*4}" t;" sector    {left*4}" s "{up*2}"
 140 input#15,en,em$,et,es
 150 if en=0 then 85
 160 t(j)=t:s(j)=s:j=j+1
 165 print "{down*2}bad block:{left*2}",t;s""
 170 goto 85
 200 print#15,"i" d$
 210 gosub 900
 212 close 2
 215 if j=0 then print "{down*3}{right*3}no bad blocks!":end
 217 open 2,dn,2,"#"
 218 print "{down*2}bad blocks","track","sector"
 220 for i=0 to j-1
 230 print#15,"b-a:";d$,t(i);s(i)
 240 print,,t(i),s(i)
 250 next
 260 print "{down}" j "bad blocks have been allocated"
 270 close 2:end
 900 input#15,en,em$,et,es
 910 if en=0 then return
 920 print "{down*2}error #"en,em$;et;es""
 930 print#15,"i" d$
stop tok64

begin 644 CHEKDISK.PRG
M`0@="`$`CR!#2$5#2R!$25-+("TM(%9%4B`Q+C0`/0@"`$1.LC@ZCR!&3$]0
M4%D@1$5624-%($Y534)%4@!M"`4`AB!4*#$P,"DZAB!3*#$P,"DZCR!"040@
M5%)!0TLL(%-%0U1/4B!!4E)!60"/"`D`F2`BDQ$1$:^OKZ^OKZ^OKZ^OKZ^O
MKZ^OKZ^OKR(`JP@*`)D@(B!#2$5#2R!$25-+(%!23T=204TB`,D(#`"9("*W
MM[>WM[>WM[>WM[>WM[>WM[>WM[<B`-0(%`!$)+(B,"(`XP@>`)\@,34L1$XL
M,34`\0@C`)@Q-2PB5B)$)``""2T`3B6RNRA422FL,C4U`#`),@!!)+(B(CJ!
M($FR,2"D(#(U-3I!)+)!)*K'*#(U-2"O("A)JDXE*2DZ@@`Z"3P`C2`Y,#``
M2PE&`)\@,BQ$3BPR+"(C(@!8"5``F3J8,BQ!)#L`9`E5`%2R,3I3LC``>0E:
M`)@Q-2PB0BU!.B)$)#M4.U,`C@ED`(0Q-2Q%3BQ%320L150L15,`GPEN`(L@
M14ZR,""G(#$S,`"V"7,`BR!%5+(P(*<@,C`P.H\@14Y$`-<)>`"8,34L(D(M
M03HB1"0[150[15,Z5+)%5#I3LD53`.T)@@"8,34L(E4R.C(L(D0D.U0[4P`/
M"H8`3D*R3D*J,3J9(B!#2$5#2T5$("!"3$]#2U,B3D(`00J'`)D@(B!44D%#
M2R`@(""=G9V=(B!4.R(@4T5#5$]2("`@()V=G9TB(%,@(I&1(@!6"HP`A#$U
M+$5.+$5-)"Q%5"Q%4P!F"I8`BR!%3K(P(*<@.#4`?@J@`%0H2BFR5#I3*$HI
MLE,Z2K)*JC$`FPJE`)D@(A$10D%$($),3T-+.IV=(BQ4.U,B(@"D"JH`B2`X
M-0"S"L@`F#$U+"))(B!$)`"]"M(`C2`Y,#``Q0K4`*`@,@#L"M<`BR!*LC`@
MIR"9("(1$1$='1U.3R!"040@0DQ/0TM3(2(Z@`#]"MD`GR`R+$1.+#(L(B,B
M`",+V@"9("(1$4)!1"!"3$]#2U,B+")44D%#2R(L(E-%0U1/4B(`,PO<`($@
M2;(P(*0@2JLQ`$\+Y@"8,34L(D(M03HB.T0D+%0H22D[4RA)*0!@"_``F2PL
M5"A)*2Q3*$DI`&8+^@""`),+!`&9("(1(B!*(")"040@0DQ/0TM3($A!5D4@
M0D5%3B!!3$Q/0T%4140B`)T+#@&@(#(Z@`"R"X0#A#$U+$5.+$5-)"Q%5"Q%
M4P#!"XX#BR!%3K(P(*<@C@#A"Y@#F2`B$1%%4E)/4B`C(D5.+$5-)#M%5#M%
54R(B`/`+H@.8,34L(DDB($0D````
`
end


5. PERFORMANCE TEST

start tok64 perftest.prg
 1000 rem  performance test  2.0
 1010 :
 1020 rem  vic-20 and commodore 64
 1030 rem  single floppy drive
 1040 :
 1050 open 1,8,15:open 15,8,15
 1060 lt=35
 1070 lt$=str$(lt)
 1080 nt=30
 1090 print "{clear}{down}{175*22}"
 1100 print "   performance test"
 1110 print "{183*22}"
 1120 print
 1130 print "  insert scratch"
 1140 print
 1150 print "    diskette in drive"
 1160 print
 1170 print "{down}   press {reverse on}return{reverse off}"
 1180 print
 1190 print "          when ready{down}"
 1200 for i=0 to 50:get a$:next
 1210 get a$:if a$<>chr$(13) then 1210
 1220 :
 1230 :
 1240 ti$="000000"
 1250 tt=18
 1260 print#1,"n0:test disk,00"
 1270 c1$="   disk new command   "+chr$(13)
 1280 c2$="{down} wait about 80 seconds"
 1290 cc$=c1$+c2$:gosub 1840
 1300 if ti<nt then 1370
 1310 print "{down}system is"
 1320 print "{down}        not responding"
 1330 print "correctly to commands"
 1340 gosub 1880
 1350 :
 1360 :
 1370 print "{down}drive pass"
 1380 print "       mechanical test{down}"
 1390 tt=21
 1400 open 2,8,2,"0:test file,s,w"
 1410 cc$="open write file":gosub 1840
 1420 ch=2:cc$="write data":gosub 1930
 1430 cc$="close "+cc$:gosub 1840
 1440 open 2,8,2,"0:test file,s,r"
 1450 cc$="open read file":gosub 1840
 1460 ch=2:gosub 1990
 1470 print#1,"s0:test file"
 1480 cc$="scratch file{down}":tt=1:gosub 1840
 1490 :
 1500 :
 1510 tt=21
 1520 open 4,8,4,"#"
 1530 nn%=(1+rnd(ti)*254+nn%)and 255:print#1,"b-p";4;nn%
 1540 nn$="":for i=1 to 255:nn$=nn$+chr$(i):next
 1550 print#4,nn$
 1560 print#1,"u2:";4;0;lt;0
 1570 cc$="write track"+lt$:gosub 1840
 1580 print#1,"u2:";4;0;1;0
 1590 cc$="write track 1":gosub 1840
 1600 print#1,"u1:";4;0;lt;0
 1610 cc$="read track"+lt$:gosub 1840
 1620 print#1,"u1:";4;0;1;0
 1630 cc$="read track 1":gosub 1840
 1640 close 4
 1650 :
 1660 :
 1670 print "{down} unit has passed"
 1680 print "     performance test!"
 1690 print "{down} pull diskette from"
 1700 print "{down}  drive before turning"
 1710 print "   power off."
 1720 end
 1730 :
 1740 :
 1750 print "   {down}continue (y/n)?";
 1760 for i=0 to 50:get a$:next
 1770 get a$:if a$="" then 1770
 1780 print a$ "{down}"
 1790 if a$="n" then end
 1800 if a$="y" then return
 1810 goto 1760
 1820 :
 1830 :
 1840 print cc$
 1850 input#1,en,em$,et,es
 1860 print tab(12)""en;em$;et;es;""
 1870 if en<2 then return
 1880 print "{down} unit is failing"
 1890 print "{down}   performance test"
 1900 tm$=ti$:gosub 1750:ti$=tm$:return
 1910 :
 1920 :
 1930 print "writing data"
 1940 for i=1000 to 2000:print# ch,i:next
 1950 gosub 1850
 1960 close ch:return
 1970 :
 1980 :
 1990 print "reading data"
 2000 get a$
 2010 for i=1000 to 2000
 2020 input# ch,j
 2030 if j<>i then print "{reverse on}read error:{reverse off}":\
      gosub 1850
 2040 next
 2050 gosub 1850
 2060 close ch:return
stop tok64

begin 644 PERFTEST.PRG
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
5"(T@,3@U,``H$`P(H"!#2#J.````
`
end



APPENDIX D: DISK FORMATS

           [ Outer Rim ]
 ------------------------------------
              Track 1
  ----------------------------------

   --------------------------------
         Track 18 (Directory)
    ------------------------------

     ----------------------------
              Track 35    O Index Hole
      --------------------------
           [ Center Hub ]


    1540/1541 Format: Expanded View of a Single Sector

 +------+----+------+------+----+----+-------+-------+------+-
 | SYNC | 08 | ID 1 | ID 2 | TK | BL | CHECK | GAP 1 | SYNC |
 |      |    |      |      |    |    |  SUM  |       |      | <-+
 +------+----+------+------+----+----+-------+-------+------+-  |
                                                                |
 +----------------------- (CONTINUED) --------------------------+
 |
 |  -+----+------+------+-----------+-------+-----+
 |   | 07 | BYTE | BYTE | 254 BYTES | CHECK | GAP |
 +-> |    |  0   |  1   |  OF DATA  |  SUM  |     |
    -+----+------+------+-----------+-------+-----+


         BLOCK DISTRIBUTION BY TRACK
 +--------------+-------------+-------------+
 | TRACK NUMBER | BLOCK RANGE | TOTAL BLOCK |
 +--------------+-------------+-------------+
 |    1 to 17   |   0 to 20   |      21     |
 |   18 to 24   |   0 to 18   |      19     |
 |   25 to 30   |   0 to 17   |      18     |
 |   31 to 35   |   0 to 16   |      17     |
 +--------------+-------------+-------------+


                        1540/1541 BAM FORMAT
 +-----------------------------------------------------------------+
 | Track 18, Sector 0.                                             |
 +-------+----------+----------------------------------------------+
 | BYTE  | CONTENTS |                DEFINITION                    |
 +-------+----------+----------------------------------------------+
 | 0,1   | 18,01    | Track and sector of first directory block.   |
 +-------+----------+----------------------------------------------+
 | 2     | 65       | ASCII character A indicating 4040 format.    |
 +-------+----------+----------------------------------------------+
 | 3     | 0        | Null flag for future DOS use.                |
 +-------+----------+----------------------------------------------+
 | 4-143 |          | Bit map of available blocks for tracks 1-35. |
 +-------+----------+----------------------------------------------+
 | *1 = available block                                            |
 |  0 = block not available                                        |
 |      (each bit represents one block)                            |
 +-----------------------------------------------------------------+


                      1540/1541 DIRECTORY HEADER
 +-----------------------------------------------------------------+
 | Track 18, Sector 0.                                             |
 +---------+----------+--------------------------------------------+
 | BYTE    | CONTENTS |              DEFINITION                    |
 +---------+----------+--------------------------------------------+
 | 144-161 |          | Disk name padded with shifted spaces.      |
 +---------+----------+--------------------------------------------+
 | 162-163 |          | Disk ID.                                   |
 +---------+----------+--------------------------------------------+
 | 164     | 160      | Shifted space.                             |
 +---------+----------+--------------------------------------------+
 | 165,166 | 50,65    | ASCII representation for 2A which is DOS   |
 |         |          | version and format type.                   |
 +---------+----------+--------------------------------------------+
 | 166-167 | 160      | Shifted spaces.                            |
 +---------+----------+--------------------------------------------+
 | 171-255 | 0        | Nulls, not used.                           |
 +---------+----------+--------------------------------------------+
 | Note: ASCII characters may appear in locations 180 thru 191 on  |
 |       some diskettes.                                           |
 +-----------------------------------------------------------------+


                        SEQUENTIAL FORMAT
 +---------+-------------------------------------------------------+
 | BYTE    |              DEFINITION                               |
 +---------+-------------------------------------------------------+
 | 0,1     | Track and sector of next sequential data block.       |
 +---------+-------------------------------------------------------+
 | 2-256   | 254 bytes of data with carriage returns as record     |
 |         | terminators.                                          |
 +---------+-------------------------------------------------------+


                       PROGRAM FILE FORMAT
 +---------+-------------------------------------------------------+
 | BYTE    |              DEFINITION                               |
 +---------+-------------------------------------------------------+
 | 0,1     | Track and sector of next block in program file.       |
 +---------+-------------------------------------------------------+
 | 2-256   | 254 bytes of program info stored in CBM memory format |
 |         | (with key words tokenized).  End of file is marked by |
 |         | three zero bytes.                                     |
 +---------+-------------------------------------------------------+


                       DIRECTORY FORMAT
 +---------------------------------------------------------+
 | Track 18, Sector 1 for 1540/1541                        |
 +---------+-----------------------------------------------+
 | BYTE    |               DEFINITION                      |
 +---------+-----------------------------------------------+
 | 0,1     | Track and sector of next directory block.     |
 +---------+-----------------------------------------------+
 | 2-31    | *File entry 1                                 |
 +---------+-----------------------------------------------+
 | 34-63   | *File entry 2                                 |
 +---------+-----------------------------------------------+
 | 66-95   | *File entry 3                                 |
 +---------+-----------------------------------------------+
 | 98-127  | *File entry 4                                 |
 +---------+-----------------------------------------------+
 | 130-159 | *File entry 5                                 |
 +---------+-----------------------------------------------+
 | 162-191 | *File entry 6                                 |
 +---------+-----------------------------------------------+
 | 194-223 | *File entry 7                                 |
 +---------+-----------------------------------------------+
 | 226-255 | *File entry 8                                 |
 +---------+-----------------------------------------------+

*STRUCTURE OF SINGLE DIRECTORY ENTRY

 +---------+----------+--------------------------------------------+
 | BYTE    | CONTENTS |              DEFINITION                    |
 +---------+----------+--------------------------------------------+
 | 0       | 128+type | File type OR'ed with $80 (hexadecimal) to  |
 |         |          | indicate properly closed file.             |
 |         |          | TYPES: 0 = DELeted                         |
 |         |          |        1 = SEQential                       |
 |         |          |        2 = PROGram                         |
 |         |          |        3 = USER                            |
 |         |          |        4 = RELative                        |
 +---------+----------+--------------------------------------------+
 | 1,2     |          | Track and sector of 1st data block.        |
 +---------+----------+--------------------------------------------+
 |         |          | File name padded with shifted spaces.      |
 +---------+----------+--------------------------------------------+
 |         |          | Relative file only: track and sector for   |
 |         |          | first side sector block.                   |
 +---------+----------+--------------------------------------------+
 |         |          | Relative file only: Record size.           |
 +---------+----------+--------------------------------------------+
 |         |          | Unused.                                    |
 +---------+----------+--------------------------------------------+
 |         |          | Track and sector of replacement file when  |
 |         |          | OPEN@ is in effect.                        |
 +---------+----------+--------------------------------------------+
 |         |          | Number of blocks in file: low byte, high   |
 |         |          | byte.                                      |
 +---------+----------+--------------------------------------------+


                    RELATIVE FILE FORMAT
 +---------------------------------------------------------------+
 | DATA BLOCK                                                    |
 +---------------------------------------------------------------+
 | BYTE   | DEFINITION                                           |
 +--------+------------------------------------------------------+
 | 0,1    | Track and block of next data block.                  |
 +--------+------------------------------------------------------+
 | 2-256  | 254 bytes of data. Empty records contain FF (all     |
 |        | binary ones) in the first byte followed by 00        |
 |        | (binary all zeros) to the end of the record.         |
 |        | Partially filled records are padded with nulls (00). |
 +---------------------------------------------------------------+
 | SIDE SECTOR BLOCK                                             |
 +--------+------------------------------------------------------+
 | BYTE   | DEFINITION                                           |
 +--------+------------------------------------------------------+
 | 0,1    | Track and block of next side sector block.           |
 +--------+------------------------------------------------------+
 | 2      | Side sector number. (0-5)                            |
 +--------+------------------------------------------------------+
 | 3      | Record length.                                       |
 +--------+------------------------------------------------------+
 | 4,5    | Track and block of first side sector (number 0)      |
 +--------+------------------------------------------------------+
 | 6,7    | Track and block of second side sector (number 1)     |
 +--------+------------------------------------------------------+
 | 8,9    | Track and block of third side sector (number 2)      |
 +--------+------------------------------------------------------+
 | 10,11  | Track and block of fourth side sector (number 3)     |
 +--------+------------------------------------------------------+
 | 12,13  | Track and block of fifth side sector (number 4)      |
 +--------+------------------------------------------------------+
 | 14,15  | Track and block of sixth side sector (number 5)      |
 +--------+------------------------------------------------------+
 | 16-256 | Track and block pointers to 120 data blocks.         |
 +--------+------------------------------------------------------+



INDEX [ by Section Number ]

A
 Assembly Language, 10

B
 BLOCK-ALLOCATE, 6.5, A
 Block Availability Map (BAM), 3.3, 5.4, 6.1, 6.5, D
 BLOCK-EXECUTE, 8.1, A
 BLOCK-FREE, 6.6, A
 BLOCK-READ, 6.1, 6.3, 6.7, 6.8, 6.9, A
 Blocks, 1.2, 6.9, D
 BLOCK-WRITE, 6.4, 6.7, 6.9, A
 Buffer, 1.2, 6.8
 BUFFER-POINTER, 6.8, A

C
 CLOSE, 4.10
 COPY, 4.3, A

D
 Data Channel, 6.2
 Demonstration Disk Programs, C
 Device Number, 5.1, 9.1-9.2
 Directory, 3.3, 5.4, D
 Disk Controller, 8.1-8.5
 Disk Operating System (DOS), 3.3-3.4, 3.8, 5.4, 6.1, 6.5, 6.8, B
 DOS Support Program, 3.8, 4.9
 Drive Speeds, 2.5
 DUPLICATE, 4.8, A

E
 End-of-file (EOF), 5.2
 Error Channel, 4.9, 7.5, 8.2
 Error Messages, B

F
 FORMAT (see NEW)

G
 GET#, 5.3

I
 INITIALIZE, 4.6, 8.3, A
 INPUT#, 4.9, 5.2, 7.4

L
 LOAD, 1.1 3.2-3.5, 3.7-3.8, 4.1, 4.10

M
 Mailing List Program, 7.3
 MEMORY-EXECUTE, 8.4, A
 MEMORY-READ, 8.2, A
 MEMORY-WRITE, 8.3, A

N
 NEW, 4.2, A

O
 Open, 4.1, 5.1

P
 Pattem Matching, 3.4
 POSITION, 7.3-7.4, A
 PRINT#, 4.1, 5.2
 Program Files (PRG), 5.1, 5.4, C

R
 Random Files, 1.2, 6.1-6.8
 Relative Files (REL), 1.1-1.2, 5.1, 6.8-6.9, 7.1-7.6, D
 RENAME, 4.4, A

S
 SAVE, 1.1, 3.5-3.6, 4.7
 SCRATCH, 4.5, 4.7, A
 Sectors, 1.2, D
 Sequential Files (SEQ), 1.1-1.2, 5.1-5.3, 5.4, 6.7, D
 Serial Bus Interface, 1.2, 2.3, 2.5
 Side Sector, 7.1-7.2
 Specifications, 1.2

T
 Tracks, 6.1, 6.8, D

U
 USER, 8.5, A
 User Files (USR), 5.1, 5.4, 6.9

V
 VALIDATE, 4.7, A
 VERIFY, 3.7, A

W
 Wedge, 3.8, 8
 Wild Cards, 3.4



COMMODORE SALES CENTERS

 Commodore Business Machines, Inc.
 1200 Wilson Drive
 Westchester, PA 19380, U.S.A.

 Commodore Business Machines Ltd.
 3370 Pharmacy Avenue, Agincourt,
 Ontario, M1W 2K4, Canada

 Commodore Business Machines (UK) Ltd.
 675 Ajax Avenue, Trading Estate,
 Slough Berks, SL1 4BG, England

 Commodore Bueromashinen GmbH
 Lyonerstrasse 38, PO BOX 710126
 Frankfult 6000, West Germany

 Commodore Italians S.R.L.
 Via Conservatoria 22
 Milano 20122, Italy

 Commodore Information Center
 5 Onion Road
 Lane Cove 2066 NSW, Australia

 Commodore Computer B.V.
 Marksingel 2e4811 N.V. Breda
 Postlrus 720, 480 3aS Breda, Netherlands

 Commodore AG (Schweiz)
 Aeschenvorstadt 57
 4010 Basel, Switzerland



[ BACK PAGE ]

DISK DRIVES

MODEL SFD 1001 -- 1 Megabyte double sided, floppy disk drive. Uses
double density, double sided diskettes. IEEE interface.

MODEL 2031LP -- Media compatible with 1541 and 4040 diskettes. 170 K
of memory per single side disk.  Rugged and stylish housing. IEEE
interface.


PRINTERS

MODEL MPS-801 -- High quality dot matrix printing.  80 column printing.
Prints 50 characters per second.  Serial port interface.

MODEL MSC-801 -- Seven color, dot matrix printing.  Up to 80 columns
printed per page.  Prints 38 characters per second.  Perfect for
everything from personal letters to important business reports. Serial
port interface.

MODEL 1526 -- 80 column, dot mtrix printing. Prints 80 characters per
second.  Durability at an affordable price. Serial Port interface.


PRINTER/PLOTTER

MODEL 1520 -- Four color, printer/plotter for all graphic needs. Print
bar graphs...create pie charts...plot time graphs.  High quality
printing in a variety of styles and sizes.  Great for graphic artists.


MODEMS

VICMODEM -- Timely financial information, news and reference libraries
are as near as your phone.  An affordable introduction to the growing
world of phone/computer services.  Communicate with a wide variety of
computer users who already own a modem.

AUTOMODEM -- The convenience of automatic answering and dialing. The
resource power of telecomputing services.  Turn your phone into a
telecomputing information network.


   _____
  /  ___|___
 |  /   |__/  c o m m o d o r e
 |  \___|__\  C O M P U T E R
  \_____|

P/N 1540031-02 (5)

Printed in Japan

*********

End of the Project 64 etext of the Commodore 1541 Disk Drive User's
Guide, first edition.

*********

