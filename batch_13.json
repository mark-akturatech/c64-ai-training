[{"id": "map-F250", "address_start": 62032, "address_end": 62032, "hex_start": "$F250", "hex_end": "$F250", "label": "CHKOUT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62032         $F250          CHKOUT\nDesignate a Logical File As the Current Output Channel\n\nThis is a documented Kernal routine which can be entered from the jump\ntable at 65481 ($FFC9).\n\nThe routine jumps through a RAM vector at 800 ($320).  If you wish to\noutput data to any device other than the screen, this routine must be\ncalled after OPENing the device, and before you output a data byte\nwith the CHROUT routine.  When called, the routine will designate the\nlogical file whose file number is in the .X register as the current\nfile, its device as the current device, and its secondary address as\nthe current secondary address.  If the device on the channel uses the\nserial bus, and therefore requires a LISTEN command and possibly a\nsecondary address, this information will be sent on the bus."}, {"id": "map-F291", "address_start": 62097, "address_end": 62097, "hex_start": "$F291", "hex_end": "$F291", "label": "CLOSE", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62097         $F291          CLOSE\nClose a Logical I/O File\n\nCLOSE is a documented Kernal routine which can be entered via the jump\ntable at 65475 ($FFC3).\n\nThe routine jumps through a RAM vector at 796 ($31C).  It is used to\nclose a logical file after all I/O operations involving that file have\nbeen completed.  This is accomplished by loading the Accumulator with\nthe logical file number of the file to be closed, and calling this\nroutine.\n\nClosing an RS-232 file will de-allocate space at the top of memory for\nthe receiving and trasmit buffers.  Closing a cassette file that was\nopened for writing will force the last block to be written to\ncassette, even if it is not a full 192 bytes.  Closing a serial bus\ndevice will send an UNLISTEN command on the bus.  Remember, it is\nnecessary to properly CLOSE a cassette or disk data file in order to\nretrieve the file later.\n\nFor all types of files, CLOSE removes the file's entry from the tables\nof logical files, device, and secondary address at 601, 611, and 621\n($259, $263, $26D), and moves all higher entries in the table down one\nspace."}, {"id": "map-F30F", "address_start": 62223, "address_end": 62223, "hex_start": "$F30F", "hex_end": "$F30F", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62223         $F30F\nFind the File in the Logical File Table\n\nThis subroutine is used by many Kernal routines to find the position\nof the logical file in the logical file table at 601 ($259)."}, {"id": "map-F31F", "address_start": 62239, "address_end": 62239, "hex_start": "$F31F", "hex_end": "$F31F", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62239         $F31F\nSet Current Logical File, Current Device, and Current Seconday Address\n\nThis subroutine is used to update the Kernal variables at 184-186\n($B8-$BA) which holds the current logical file number, current device\nnumber, and current secondary address number."}, {"id": "map-F32F", "address_start": 62255, "address_end": 62255, "hex_start": "$F32F", "hex_end": "$F32F", "label": "CLALL", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62255         $F32F          CLALL\nClose All Logical I/O Files\n\nCLALL is a documented Kernal routine whose entry point in the jump\ntable is 65511 ($FFE7).\n\nThe routine jumps through a RAM vector at 812 ($32C).  It closes all\nopen files, by resetting the index into open files at 152 ($98) to\nzero.  It then falls through to the next routine, which restores the\ndefault I/O devices."}, {"id": "map-F333", "address_start": 62259, "address_end": 62259, "hex_start": "$F333", "hex_end": "$F333", "label": "CLRCHN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62259         $F333          CLRCHN\nRestore Current Input and Output Devices to the Default Devices\n\nThis is a documented Kernal Routine which can be entered at location\n65484 ($FFCC) in the jump table.\n\nThe routine jumps through a RAM vector at 802 ($322).  It sets the\ncurrent input device to the keyboard, and the current output device to\nthe screen.  Also, if the current input device was formerly a serial\ndevice, the routine sends it an UNTALK command on the serial bus, and\nif a serial device was formerly the current output device, the routine\nsends it an UNLISTEN command."}, {"id": "map-F34A", "address_start": 62282, "address_end": 62282, "hex_start": "$F34A", "hex_end": "$F34A", "label": "OPEN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62282         $F34A          OPEN\nOpen a Logical I/O File\n\nOPEN is a documented Kernal I/O routine.  It can be entered from the\njump table at 65472 ($FFC0).\n\nThe routine jumps through a RAM vector at 794 ($31A).  This routine\nassigns a logical file to a device, so that it can be used for\nInput/Output operations.  In order to specify the logical file number,\nthe device number, and the secondary address if any, the SETLFS\nroutine must first be called.  Likewise, in order to designate the\nfilename, the SETNAM routine must be used first.  After these two\nroutines are called, OPEN is then called."}, {"id": "map-F49E", "address_start": 62622, "address_end": 62622, "hex_start": "$F49E", "hex_end": "$F49E", "label": "LOAD", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62622         $F49E          LOAD\nLoad RAM from a Device\n\nThis is a documented Kernal routine, whose entry in the jump table\nappears at 65493 ($FFD5).\n\nThe routine jumps through a RAM vector at 816 ($330).  LOAD is used to\ntransfer data froma device directly to RAM.  It can also be used to\nverify RAM, comparing its contents to those of a disk or tape file.\nTo choose between these operations you must set the Accumulator with a\n0 for LOAD, or a 1 for VERIFY.\n\nSince the LOAD routine performs an OPEN, it must be preceded by a call\nto the SETLFS routine to specify the logical file number, device\nnumber, and secondary address, and a call to the SETNAM routine to\nspecify the filename (a LOAD from tape can be performed without a\nfilename being specified).  Then the .X and .Y registers should be set\nwith the starting address for the load, and the LOAD routine called.\nIf the secondary address specified was a 1, this starting address will\nbe ignored, and the header information will be used to supply the load\naddress.  If the secondary address was a 0, the address supplied by\nthe call will be used.  In either case, upon return from the\nsubroutine, the .X and .Y registers will contain the address of the\nhighest RAM location that was loaded."}, {"id": "map-F5A5", "address_start": 62885, "address_end": 62885, "hex_start": "$F5A5", "hex_end": "$F5A5", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62885         $F5A5\nPrint SEARCHING Message if in Direct Mode"}, {"id": "map-F5DD", "address_start": 62941, "address_end": 62941, "hex_start": "$F5DD", "hex_end": "$F5DD", "label": "SAVE", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "62941         $F5DD          SAVE\nSave RAM to a Device\n\nThis is a documented Kernal routine, whose entry in the jump table\nappears at 65496 ($FFD8).\n\nThe routine jumps through a RAM vector at 818 ($332).  SAVE is used to\ntransfer data directly from RAM to an I/O device.  Since the SAVE\nroutine performs an OPEN, it must be preceded by a call to the SETLFS\nroutine to specify the logical file number, device number, and\nsecondary address, and a call to the SETNAM routine to specify the\nfilename (although a SAVE to the cassette can be performed without\ngiving a filename).  A Page 0 pointer to the starting address of the\narea to be saved should be set up, with the low byte of the address\nfirst.  The accumulator should be loaded with the Page 0 offset of\nthat pointer, then the .X and .Y registers should be set with the\nending address for the save, and the SAVE routine called."}, {"id": "map-F68F", "address_start": 63119, "address_end": 63119, "hex_start": "$F68F", "hex_end": "$F68F", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63119         $F68F\nIf in Direct Mode, Print SAVING and Filename"}, {"id": "map-F69B", "address_start": 63131, "address_end": 63131, "hex_start": "$F69B", "hex_end": "$F69B", "label": "UDTIM", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63131         $F69B          UDTIM\nUpdate the Software Clock and Check for the STOP Key\n\nUDTIM is a documented Kernal routine which can be entered through the\njump table at 65514 ($FFEA).\n\nIt is normally called by the IRQ interrupt handler once every sixtieth\nof a second.  It adds one to the value in the three-byte software\njiffy clock at 160-162 ($A0-$A2), and sets the clock back to zero when\nit reaches the 24 hour point.  In addition, it scans the keyboard row\nin which the STOP key is located, and stores the current value of that\nkey in location 145 ($91).  This variable is used by the STOP routine\nwhich checks for the STOP key."}, {"id": "map-F6DD", "address_start": 63197, "address_end": 63197, "hex_start": "$F6DD", "hex_end": "$F6DD", "label": "RDTIM", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63197         $F6DD          RDTIM\nRead the Time From the Software Clock into the .A, .X, and .Y\nRegisters\n\nThis is a documented Kernal routine whose entry point in the jump\ntable is 65502 ($FFDE).\n\nIt reads the software clock (which counts sixtieths of a second) into\nthe internal registers.  The .Y register contains the most significant\nbyte (from location 160 ($A0)), the .X register contains the middle\nbyte (from location 161 ($A1)), and the Accumulator contains the least\nsignificant byte (from location 162 ($A2))."}, {"id": "map-F6E4", "address_start": 63204, "address_end": 63204, "hex_start": "$F6E4", "hex_end": "$F6E4", "label": "SETTIM", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63204         $F6E4          SETTIM\nSet the Software Clock from the .A, .X, and .Y Registers\n\nThis documented Kernal routine can be entered from location 65499\n($FFDB).\n\nIt performs the reverse operation from RDTIM, storing the value in the\n.Y register into location 160 ($A0), the .X register into 161 ($A1),\nand the Accumulator into 162 ($A2).  Interrupts are first disabled, to\nmake sure that the clock will not be updated while being set."}, {"id": "map-F6ED", "address_start": 63213, "address_end": 63213, "hex_start": "$F6ED", "hex_end": "$F6ED", "label": "STOP", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63213         $F6ED          STOP\nTest STOP Key\n\nSTOP is a documented Kernal routine which can be entered from the jump\ntable at location 65505 ($FFE1).\n\nIt is vectored through RAM at 808 ($328).  The routine checks to see\nif the STOP key was pressed during the last UDTIM call.  If it was,\nthe Zero flag is set to 1, the CLRCHN routine is called to set the\ninput and output devices back to the keyboard and screen, and the\nkeyboard queue is emptied."}, {"id": "map-F6FB", "address_start": 63227, "address_end": 63227, "hex_start": "$F6FB", "hex_end": "$F6FB", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63227         $F6FB\nSet Kernal I/O Error Messages\n\nThis subroutine is used to handle I/O errors from Kernal I?O routines.\nIt calls CLRCHN to restore default I/O devices.  If Bit 6 of the flag\nat 157 ($9D) is set, it prints I/O ERROR followed by the error number,\nand then sets the Carry flag to indicate an error, with the error\nnumber in the Accumulator.  The Kernal error messages are not used by\nBASIC, but may be used by machine language monitors and other\napplications."}, {"id": "map-F72C", "address_start": 63276, "address_end": 63276, "hex_start": "$F72C", "hex_end": "$F72C", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63276         $F72C\nGet Next Tape File Header from Cassette\n\nThis routine reads in tape blocks until it finds a file header block.\nIt then prints out the FOUND message along with the first 16\ncharacters of the filename."}, {"id": "map-F7D0", "address_start": 63440, "address_end": 63440, "hex_start": "$F7D0", "hex_end": "$F7D0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63440         $F7D0\nPut Pointer to Tape Buffer in .X and .Y Registers"}, {"id": "map-F7D7", "address_start": 63447, "address_end": 63447, "hex_start": "$F7D7", "hex_end": "$F7D7", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63447         $F7D7\nSet I/O Area Start and End Pointers to Tape Buffer Start and End\nAddress"}, {"id": "map-F817", "address_start": 63511, "address_end": 63511, "hex_start": "$F817", "hex_end": "$F817", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63511         $F817\nTest Cassette Buttons and Handle Messages for Tape Read\n\nThis routine tests the sense switch, and if no buttons are depressed\nit prints the PRESS PLAY ON TAPE message, and loops until a cassette\nbutton is pressed, or until the STOP key is pressed.  If a button is\npressed, it prints the message OK.\n\nSince the message printing routine is entered after the test for\ndirect mode, these messages cannot be superseded by changing the flag\nat 157 ($9D).  You could have them harmlessly printed to ROM, however,\nby changing the value of HIBASE at 648 ($288) temporarily to 160, and\nthen back to 4."}, {"id": "map-F82E", "address_start": 63534, "address_end": 63534, "hex_start": "$F82E", "hex_end": "$F82E", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63534         $F82E\nCheck Cassette Switch\n\nThis subroutine is used to check if a button on the recorder has been\npressed."}, {"id": "map-F838", "address_start": 63544, "address_end": 63544, "hex_start": "$F838", "hex_end": "$F838", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63544         $F838\nTest Cassette Buttons and Handle Messages for Tape Write\n\nThis routine tests the sense switch, and if no buttons are depressed\nit prints the PRESS PLAY & RECORD message, and loops until a cassette\nbutton is pressed, or until the STOP key is pressed.  If a button is\npressed, it prints the message OK.  These messages cannot be supressed\nby changing the flag at 157 ($9D).  See the entry for 63511 ($F817)\nfor more information."}, {"id": "map-F841", "address_start": 63553, "address_end": 63553, "hex_start": "$F841", "hex_end": "$F841", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63553         $F841\nStart Reading a Block of Data from the Cassette\n\nThis subroutine tests the cassette switch and initializes various\nflags for reading a block of data from cassette."}, {"id": "map-F864", "address_start": 63588, "address_end": 63588, "hex_start": "$F864", "hex_end": "$F864", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63588         $F864\nStart Writing a Block of Data to the Cassette\n\nThis subroutine tests the cassette switch and initializes various\nflags for writing a block of data to cassette."}, {"id": "map-F875", "address_start": 63605, "address_end": 63605, "hex_start": "$F875", "hex_end": "$F875", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63605         $F875\nCommon Code for Reading a Data Block from Tape and Writing a Block to Tape\n\nThis routine sets the actual reading or writing of a block of data.\nIt sets CIA #1 Timer B to call the IRQ which drives the actual reading\nor writing routine, saves the old IRQ vector, and sets the new IRQ\nvector to the read or write routine.  It also blanks the screen so\nthat the video chip's memory addressing (which normally takes away\nsome of the 6510 microprocessor's addressing time) will not interfere\nwith the timing of the routines."}, {"id": "map-F8D0", "address_start": 63696, "address_end": 63696, "hex_start": "$F8D0", "hex_end": "$F8D0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63696         $F8D0\nTest the STOP Key during Cassette I/O Operations\n\nThis subroutine is used to test the STOP key during tape I/O\noeprations, and to stop I/O if it is pressed."}, {"id": "map-F8E2", "address_start": 63714, "address_end": 63714, "hex_start": "$F8E2", "hex_end": "$F8E2", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63714         $F8E2\nAdjust CIA #1 Timer A for Tape Bit Timing"}, {"id": "map-F92C", "address_start": 63788, "address_end": 63788, "hex_start": "$F92C", "hex_end": "$F92C", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "63788         $F92C\nRead Tape Data (IRQ)\n\nThis is the IRQ handler routine that is used for reading data from the\ncassette.  At the end of the read, the IRQ vector is restored to the\nnormal IRQ routine."}, {"id": "map-FA60", "address_start": 64096, "address_end": 64096, "hex_start": "$FA60", "hex_end": "$FA60", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64096         $FA60\nReceive and Store the Next Character from Cassette\n\nThis is the part of the cassette read IRQ routine that actually gets\nthe next byte of data from the cassette."}, {"id": "map-FB8E", "address_start": 64398, "address_end": 64398, "hex_start": "$FB8E", "hex_end": "$FB8E", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64398         $FB8E\nMove the Tape SAVE/LOAD Address into the Pointer at 172"}, {"id": "map-FB97", "address_start": 64407, "address_end": 64407, "hex_start": "$FB97", "hex_end": "$FB97", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64407         $FB97\nReset Counters for Reading or Writing a New Byte of Cassette Data"}, {"id": "map-FBA6", "address_start": 64422, "address_end": 64422, "hex_start": "$FBA6", "hex_end": "$FBA6", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64422         $FBA6\nToggle the Tape Data Output Line\n\nThis routine sets the CIA #1 Timer B, and toggles the Tape Data Output\nline on the 6510 on-chip I/O port (Bit 3 of location 1)."}, {"id": "map-FBC8", "address_start": 64456, "address_end": 64456, "hex_start": "$FBC8", "hex_end": "$FBC8", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64456         $FBC8\nWrite Data to Cassette--Part 2 (IRQ)\n\nThis IRQ handler routine is one part of the write data to cassette\nroutine"}, {"id": "map-FC6A", "address_start": 64618, "address_end": 64618, "hex_start": "$FC6A", "hex_end": "$FC6A", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64618         $FC6A\nWrite Data fo Cassette--Part 1 (IRQ)\n\nThis IRQ handler routine is the other part of the write data to\ncassette routine."}, {"id": "map-FC93", "address_start": 64659, "address_end": 64659, "hex_start": "$FC93", "hex_end": "$FC93", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64659         $FC93\nRestores the Default IRQ Routine\n\nAt the end of the tape I/O operations, this subroutine is used to turn\nthe screen back on and stop the cassette motor.  It then resets the\nCIA #1 Timer A to generate an interrupt every sixtieth of a second,\nand restores the IRQ vector to point to the normal interrupt routine\nthat updates the software clock and scans the keyboard."}, {"id": "map-FCB8", "address_start": 64696, "address_end": 64696, "hex_start": "$FCB8", "hex_end": "$FCB8", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64696         $FCB8\nTerminate Cassette I/O\n\nThis routine calls the subroutine above and returns from the\ninterrupt."}, {"id": "map-FCD1", "address_start": 64721, "address_end": 64721, "hex_start": "$FCD1", "hex_end": "$FCD1", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64721         $FCD1\nCheck the Tape Read/Write Pointer\n\nThis routine compares the current tape read/write address with the\nending read/write address."}, {"id": "map-FCDB", "address_start": 64731, "address_end": 64731, "hex_start": "$FCDB", "hex_end": "$FCDB", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64731         $FCDB\nAdvance the Tape Read/Write Pointer\n\nThis routine is used to move the pointer to the current read/write\naddress up a byte."}, {"id": "map-FCE2", "address_start": 64738, "address_end": 64738, "hex_start": "$FCE2", "hex_end": "$FCE2", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64738         $FCE2\nPower-On Reset Routine\n\nThis is the RESET routine which is pointed to by the 6510 hardware\nRESET vector at 65532 ($FFFC).\n\nThis routine is automatically executed when the computer is first\nturned on.  First, it sets the Interrupt disable flag, sets the stack\npointer, and clears the Decimal mode flag.  Next, it tests for an\nautostart cartridge.  If one is found, the routine immediately jumps\nthrough the cartridge cold start vector at 32768 ($8000).  If no\ncartridge is found, the Kernal initialization routines IOINIT, RAMTAS,\nRESTOR, and CINT are called, the Interrupt disable flag is cleared,\nand the BASIC program is entered through the cold start vector at\n40960 ($A000)."}, {"id": "map-FD02", "address_start": 64770, "address_end": 64770, "hex_start": "$FD02", "hex_end": "$FD02", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64770         $FD02\nCheck for an Autostart Cartridge\n\nThis routine tests for an autostart cartridge by comparing the\ncharacters at location 32772-6 ($8004-8) to the text below.  The Zero\nflag will be set if they match, and cleared if they don't."}, {"id": "map-FD10", "address_start": 64784, "address_end": 64784, "hex_start": "$FD10", "hex_end": "$FD10", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64784         $FD10\nText for Autostart Cartridge Check\n\nThe characters stored here must be the fifth through the ninth\ncharacters in the cartridge in order for it to be started on power-up.\nThese characters are the PETASCII values for CBM, each with the high\nbit set (+128), and the characters \"80\"."}, {"id": "map-FD15", "address_start": 64789, "address_end": 64789, "hex_start": "$FD15", "hex_end": "$FD15", "label": "RESTOR", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64789         $FD15          RESTOR\nRestore RAM Vectors for Default I/O Routines\n\nThis documented Kernal routine can be entered through the jump table\nat 65418 ($FF8A).\n\nIt sets the values for the 16 RAM vectors to the interrupt and\nimportant Kernal I/O routines in the table that starts at 788 ($314)\nto the standard values held in the ROM table at 64816 ($FD30)."}, {"id": "map-FD1A", "address_start": 64794, "address_end": 64794, "hex_start": "$FD1A", "hex_end": "$FD1A", "label": "VECTOR", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64794         $FD1A          VECTOR\nSet the RAM Vector Table from the Table Pointed to by .X and .Y\n\nThis documented Kernal routine can be entered through the jump table\nat 65421 ($FF8D).\n\nIt is used to read or change the values for the 16 RAM vectors to the\ninterrupt and important Kernal I/O routines in the table that starts\nat 788 ($314).  If the Carry flag is set when the routine is called,\nthe current value of the 16 vectors will be stored at a table whose\naddress is pointed to by the values in the .X and .Y registers.  If\nthe Carry flag is cleared, the RAM vectors will be loaded from the\ntable whose address is pointed to by the .X and .Y registers.  Since\nthis routine can change the vectors for the IRQ and NMI interrupts,\nyou might expect that the Interrupt disable flag would be set at its\nbeginning.  Such is not the case, however, and therefore it would be\nwise to execute an SEI before calling it and a CLI afterwards (as the\npower-on RESET routine does) just to be safe."}, {"id": "map-FD30", "address_start": 64816, "address_end": 64816, "hex_start": "$FD30", "hex_end": "$FD30", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64816         $FD30\nTable of RAM Vectors to the Default I/O Routines\n\nThis table contains the 16 RAM I/O vectors that are moved to 788-819\n($314-$333)."}, {"id": "map-FD50", "address_start": 64848, "address_end": 64848, "hex_start": "$FD50", "hex_end": "$FD50", "label": "RAMTAS", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64848         $FD50          RAMTAS\nPerform RAM Test and Set Pointers to the Top and Bottom of RAM\n\nThis documented Kernal routine, which can be entered through location\n65415 ($FF87) of the jump table, performs a number of initialization\ntasks.\n\nFirst, it clears Pages 0, 2, and 3 of memory to zeros.  Next, it sets\nthe tape buffer pointer to address 828 ($33C), and performs a\nnondestructive test of RAM from 1024 ($400) up.  When it reaches a\nnon-RAM address (presumably the BASIC ROM at 40960 ($A000)), that\naddress is placed in the top of memory pointer at 643-4 ($283-4).  The\nbottom of memory pointer at 641-2 ($281-2) is set to point to address\n2048 ($800), which is the beginning of BASIC program text.  Finally,\nthe pointer to screen memory at 648 ($288) is set to 4, which lets the\nOperating System know that screen memory starts at 1024 ($400)."}, {"id": "map-FD9B", "address_start": 64923, "address_end": 64923, "hex_start": "$FD9B", "hex_end": "$FD9B", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64923         $FD9B\nTable of IRQ Vectors\n\nThis table holds the vectors to the four IRQ routines which the system\nuses.  The first points to Part 1 of the cassette write routine at\n64618 ($FC6A), the second to Part 2 of the cassette write routine at\n64461 ($FBCD), the third to the standard scan keyboard IRQ at 59953\n($EA31), and the last to the cassette read routine at 63788 ($F92C)."}, {"id": "map-FDA3", "address_start": 64931, "address_end": 64931, "hex_start": "$FDA3", "hex_end": "$FDA3", "label": "IOINIT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "64931         $FDA3          IOINIT\nInitialize CIA I/O Devices\n\nThis documented Kernal routine, which can be entered through the jump\ntable at 65412 ($FF84), intializes the Complex Interface Adapter (CIA)\ndevices, and turns the volume of the SID chip off.  As part of this\ninitialization, it sets CIA #1 Timer A to cause an IRQ interrupt every\nsixtieth of a second."}, {"id": "map-FDF9", "address_start": 65017, "address_end": 65017, "hex_start": "$FDF9", "hex_end": "$FDF9", "label": "SETNAM", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65017         $FDF9          SETNAM\nSet Filename Parameters\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65469 ($FFBD).\n\nIt puts the value in the Accumulator into the location which stores\nthe number of characters in the filename, and sets the pointer to the\naddress of the ASCII text of the filename from the .X and .Y\nregisters.  This sets up the filename for the OPEN, LOAD, or SAVE\nroutine."}, {"id": "map-FE00", "address_start": 65024, "address_end": 65024, "hex_start": "$FE00", "hex_end": "$FE00", "label": "SETLFS", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65024         $FE00          SETLFS\nSet Logical File Number, Device Number, and Secondary Address\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65466 ($FFBA).\n\nIt stores the value in the Accumulator in the location which holds the\ncurrent logical file number, the value in the .X register is put in\nthe location that holds the current device number, and the value in\nthe .Y register is stored in the location that holds the current\nsecondary address.  If no secondary address is used, the .Y register\nshould be set to 255 ($FF).  It is necessary to set the values of the\ncurrent file number, device number, and secondary address before you\nOPEN a file, or LOAD or SAVE."}, {"id": "map-FE07", "address_start": 65031, "address_end": 65031, "hex_start": "$FE07", "hex_end": "$FE07", "label": "READST", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65031         $FE07          READST\nRead the I/O Status Word\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65463 ($FFB7).\n\nWhenever an I/O error occurs, a bit of the Status Word is set to\nindicate what the problem was.  The routine allows you to read the\nstatus word (it is returned in the Accumulator).  If the device was\nthe RS-232, its status register is read and cleared to zero.  For the\nmeanings of the various status codes, see the entry for location 144\n($90) or 663 ($297) for the RS-232 device."}]