[{"id": "map-DC0C", "address_start": 56332, "address_end": 56332, "hex_start": "$DC0C", "hex_end": "$DC0C", "label": "CIASDR", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56332         $DC0C          CIASDR\nSerial Data Port\n\nThe CIA chip has an on-chip serial port, which allows you to send or\nreceive a byte of data one bit at a time, with the most significant\nbit (Bit 7) being transferred first.  Control Register A at 56334\n($DC0E) allows you to choose input or output modes.  In input mode, a\nbit of data is read from the SP line (pin 5 of the User Port) whenever\na signal on the CNT line (pin 4) appears to let you know that it is\ntime for a read.  After eight bits are received this way, the data is\nplaced in the Serial Port Register, and an interrupt is generated to\nlet you know that the register should be read.\n\nIn output mode, you write data to the Serial Port Register, and it is\nsent out over the SP line (pin 5 of the User Port), using Timer A for\nthe baud rate generator.  Whenever a byte of data is written to this\nregister, transmission will start as long as Timer A is running and in\ncontinuous mode.  Data is sent at half the Timer A rage, and an output\nwill appear on the CNT line (pin 4 of the User Port) whenever a bit is\nsent.  After all eight bits have been sent, an interrupt is generated\nto indicate that it is time to load the next byte to send into the\nSerial Register.\n\nThe Serial Data Register is not used by the 64, which does all of its\nserial I/O through the regular data ports."}, {"id": "map-DC0D", "address_start": 56333, "address_end": 56333, "hex_start": "$DC0D", "hex_end": "$DC0D", "label": "CIAICR", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56333         $DC0D          CIAICR\nInterrupt Control Register\n\nBit 0:  Read / did Timer A count down to 0?  (1=yes)\n        Write/ enable or disable Timer A interrupt (1=enable, 0=disable)\nBit 1:  Read / did Timer B count down to 0?  (1=yes)\n        Write/ enable or disable Timer B interrupt (1=enable, 0=disable)\nBit 2:  Read / did Time of Day Clock reach the alarm time?  (1=yes)\n        Write/ enable or disable TOD clock alarm interrupt (1=enable,\n        0=disable)\nBit 3:  Read / did the serial shift register finish a byte? (1=yes)\n        Write/ enable or disable serial shift register interrupt (1=enable,\n        0=disable)\nBit 4:  Read / was a signal sent on the flag line?  (1=yes)\n        Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)\nBit 5:  Not used\nBit 6:  Not used\nBit 7:  Read / did any CIA #1 source cause an interrupt?  (1=yes)\n        Write/ set or clear bits of this register (1=bits written with 1 will\n        be set, 0=bits written with 1 will be cleared)\n\nThis register is used to control the five interrupt sources on the\n6526 CIA chip.  These sources are Timer A, Timer B, the Time of Day\nClock, the Serial Register, and the FLAG line.  Timers A and B cause\nan interrupt when they count down to 0.  The Time of Day Clock\ngenerates an interrupt when it reaches the ALARM time.  The Serial\nShift Register interrupts when it compiles eight bits of input or\noutput.  An external signal pulling the CIA hardware line called FLAG\nlow will also cause an interrupt (on CIA #1, this FLAG line is\nconnected to the Cassette Read line of the Cassette Port).\n\nEven if the condition for a particular interrupt is satisfied, the\ninterrupt must still be enabled for an IRQ actually to occur.  This is\ndone by writing to the Interrupt Control Register.  What happens when\nyou write to this register depends on the way that you set Bit 7.  If\nyou set it to 0, any other bit that was written to with a 1 will be\ncleared, and the corresponding interrupt will be disabled.  If you set\nBit 7 to 1, any bit written to with a 1 will be set, and the\ncorresponding interrupt will be enabled.  In either case, the\ninterrupt enable flags for those bits written to with a 0 will not be\naffected.\n\nFor example, in order to disable all interrupts from BASIC, you could\nPOKE 56333, 127.  This sets Bit 7 to 0, which clears all of the other\nbits, since they are all written with 1's.  Don't try this from BASIC\nimmediate mode, as it will turn off Timer A which causes the IRQ for\nreading the keyboard, so that it will in effect turn off the keyboard.\n\nTo turn on the Timer A interrupt, a program could POKE 56333,129.  Bit\n7 is set to 1 and so is Bit 0, so the interrupt which corresponds to\nBit 0 (Timer A) is enabled.\n\nWhen you read this register, you can tell if any of the conditions for\na CIA Interrupt were satisfied because the corresponding bit will be\nset to a 1.  For example, if Timer A counts down to 0, Bit 0 of this\nregister will be set to 1.  If, in addition, the mask bit that\ncorresponds to that interrupt source is set to 1, and an interrupt\noccurs, Bit 7 will also be set.  This allows a multi-interrupt system\nto read one bit and see if the source of a particular interrupt was\nCIA #1.  You should note, however, that reading this register clears\nit, so you should preserve its contents in RAM if you want to test\nmore than one bit."}, {"id": "map-DC0E", "address_start": 56334, "address_end": 56334, "hex_start": "$DC0E", "hex_end": "$DC0E", "label": "CIACRA", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56334         $DC0E          CIACRA\nControl Register A\n\nBit 0:  Start Timer A (1=start, 0=stop)\nBit 1:  Select Timer A output on Port B (1=Timer A output appears on Bit 6 of\n        Port B)\nBit 2:  Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one cycle)\nBit 3:  Timer A run mode (1=one-shot, 0=continuous)\nBit 4:  Force latched value to be loaded to Timer A counter (1=force load\n        strobe)\nBit 5:  Timer A input mode (1=count microprocessor cycles, 0=count signals on\n        CNT line at pin 4 of User Port)\nBit 6:  Serial Port (56332, $DC0C) mode (1=output, 0=input)\nBit 7:  Time of Day Clock frequency (1=50 Hz required on TOD pin, 0=60 Hz)\n\nBits 0-3.  This nybble controls Timer A.  Bit 0 is set to 1 to start\nthe timer counting down, and set to 0 to stop it.  Bit 3 sets the\ntimer for one-shot or continuous mode.\n\nIn one-shot mode, the timer counts down to 0, sets the counter value\nback to the latch value, and then sets Bit 0 back to 0 to stop the\ntimer.  In continuous mode, it reloads the latch value and starts all\nover again.\n\nBits 1 and 2 allow you to send a signal on Bit 6 of Data Port B when\nthe timer counts.  Setting Bit 1 to 1 forces this output (which\noverrides the Data Direction Register B Bit 6, and the normal Data\nPort B value).  Bit 2 allows you to choose the form this output to Bit\n6 of Data Port B will take.  Setting Bit 2 to a value of 1 will cause\nBit 6 to toggle to the opposite value when the timer runs down (a\nvalue of 1 will change to 0, and a value of 0 will change to 1).\nSetting Bit 2 to a value of 0 will cause a single pulse of a one\nmachine-cycle duration (about a millionth of a second) to occur.\n\nBit 4.  This bit is used to load the Timer A counter with the value\nthat was previously written to the Timer Low and High Byte Registers.\nWriting a 1 to this bit will force the load (although there is no data\nstored here, and the bit has no significance on a read).\n\nBit 5.  Bit 5 is used to control just what it is Timer A is counting.\nIf this bit is set to 1, it counts the microprocessor machine cycles\n(which occur at the rate of 1,022,730 cycles per second).  If the bit\nis set to 0, the timer counts pulses on the CNT line, which is\nconnected to pin 4 of the User Port.  This allows you to use the CIA\nas a frequency counter or an event counter, or to measure pulse width\nor delay times of external signals.\n\nBit 6.  Whether the Serial Port Register is currently inputting or\noutputting data (see the entry for that register at 56332 ($DC0C) for\nmore information) is controlled by this bit.\n\nBit 7.  This bit allows you to select from software whether the Time\nof Day Clock will use a 50 Hz or 60 Hz signal on the TOD pin in order\nto keep accurate time (the 64 uses a 60 Hz signal on that pin)."}, {"id": "map-DC0F", "address_start": 56335, "address_end": 56335, "hex_start": "$DC0F", "hex_end": "$DC0F", "label": "CIACRB", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56335         $DC0F          CIACRB\nControl Register B\n\nBit 0:  Start Timer B (1=start, 0=stop)\nBit 1:  Select Timer B output on Port B (1=Timer B output appears on\n        Bit 7 of Port B)\nBit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one\n        cycle)\nBit 3:  Timer B run mode (1=one-shot, 0=continuous)\nBit 4:  Force latched value to be loaded to Timer B counter (1=force\n        load strobe)\nBits 5-6:  Timer B input mode\n           00 = Timer B counts microprocessor cycles\n           01 = Count signals on CNT line at pin 4 of User Port\n           10 = Count each time that Timer A counts down to 0\n           11 = Count Timer A 0's when CNT pulses are also present\nBit 7:  Select Time of Day write (0=writing to TOD registers sets\n        alarm, 1=writing to TOD registers sets clock)\n\nBits 0-3.  This nybble performs the same functions for Timer B that\nBits 0-3 of Control Register A perform for Timer A, except that Timer\nB output on Data Port B appears at Bit 7, and not Bit 6.\n\nBits 5 and 6.  These two bits are used to select what Timer B counts.\nIf both bits are set to 0, Timer B counts the microprocessor machine\ncycles (which occur at the rate of 1,022,730 cycles per second).  If\nBit 6 is set to 0 and Bit 5 is set to 1, Timer B counts pulses on the\nCNT line, which is connected to pin 4 of the User Port.  If Bit 6 is\nset to 1 and Bit 5 is set to 0, Timer B counts Timer A underflow\npulses, which is to say that it counts the number of times that Timer\nA counts down to 0.  This is used to link the two numbers into one\n32-bit timer that can count up to 70 minutes with accuracy to within\n1/15 second.  Finally, if both bits are set to 1, Timer B counts the\nnumber of times that Timer A counts down to 0 and there is a signal on\nthe CNT line (pin 4 of the User Port).\n\nBit 7.  Bit 7 controls what happens when you write to the Time of Day\nregisters.  If this bit is set to 1, writing to the TOD registers sets\nthe ALARM time.  If this bit is cleared to 0, writing to the TOD\nregisters sets the TOD clock."}, {"id": "map-DC10-DCFF", "address_start": 56336, "address_end": 56575, "hex_start": "$DC10", "hex_end": "$DCFF", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56336-56575 ($DC10-$DCFF)\nCIA #1 Register Images\n\nSince the CIA chip requires only enough addressing lines to handle 16\nregisters, none of the higher bits are decoded when addressing the\n256-byte area that has been assigned to it.  The result is that every\n16-byte area in this 256-byte block is a mirror of every other.  Even\nso, for the sake of clarity in your programs it is advisable to use\nthe base address of the chip, and not use the higher addresses to\ncommunicate with the chip."}, {"id": "map-DD00-DD0F", "address_start": 56576, "address_end": 56591, "hex_start": "$DD00", "hex_end": "$DD0F", "label": "", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56576-56591    $DD00-$DD0F\nComplex Interface Adapter (CIA) #2 Registers\n\nLocations 56576-56591 ($DD00-$DD0F) are used to address the Complex\nInterface Adapter chip #2 (CIA #2).  Since the chip itself is\nidentical to CIA #1, which is addressed at 56320 ($DC00), the\ndiscussion here will be limited to the use which the 64 makes of this\nparticular chip.  For more general information on the chip registers,\nplease see the corresponding entries for CIA #1.\n\nOne of the significant differences between CIA chips #1 and #1 is the\nuse to which Data Ports A and B are put.  The peripheral input and\noutput devices that CIA #2 controls are those on the Serial Bus (such\nas the 1541 Disk Drive and 1525 printer), the RS-232 device (which is\nused for telecommunications), and the User Port, an eight-bit parallel\nport that can be turned to whatever purpose the user desires.  In\naddition, Data Port A has the important task of selecting the 16K bank\nofmemory that will be used by the VIC-II chip for graphics.\n\nAnother significant difference between CIA chips #1 and #2 is that the\ninterrupt line of CIA #1 is wired to the 6510 IRQ line, while that of\nCIA #2 is wired to the NMI line.  This means that interrupts from this\nchip cannot be masked by setting the Interrupt disable flag (SEI).\nThey can be disabled from CIA's Mask Register, though.  Be sure to use\nthe NMI vector when setting up routines to be driven by interrupts\ngenerated by this chip."}, {"id": "map-DD00-DD01", "address_start": 56576, "address_end": 56577, "hex_start": "$DD00", "hex_end": "$DD01", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56576-56577 ($DD00-$DD01)\nCIA #2 Data Ports A and B\n\nThese registers are where the communication with the Serial Bus,\nRS-232 device, and User Port take place.  The Serial Bus is like the\nIEEE bus which is used by the PET, in that it allows more than one\ndevice to be connected to the port at a time, in a daisychain\narrangement.  Since each byte of data is sent one bit at a time,\nhowever, the Serial Bus is at least eight times slower than the IEEE.\nIt is presently used to control the 1541 Disk Drive and 1525 printer,\nand other devices (such as printer interface for Centronics- type\nparallel pritners and stringy floppy wafer tape storage units) can be\nplaced on this bus.\n\nData Port A is used for communication with the Serial Bus.  Bits 5 and\n7 are used for Serial Bus Data Output and Input, respectively, and\nBits 4 and 6 are used for the Serial Bus Clock Pulse Output and Input.\nBit 3 of Data Port A is used to send the ATN signal on the Serial Bus.\n\nThe 64 has built-in software to handle RS-232 communications through a\nmodem or other device plugged in the RS-232/User Port.  The RS-232\ndevice uses Bit 2 of Data Port A for data output (it is the only line\nfrom Port A that is connected to the RS-232/User Port jack).  It also\nmakes heavy use of Port B, using Bit 7 for the Data Set Ready (DSR)\nsignal, Bit 6 for the Clear to Send (CTS), Bit 4 for the Carrier\nDetect (DCD), Bit 3 for the Ring Indicator (RI), Bit 2 for Data\nTerminal Ready (DTR), Bit 1 for Request to Send (RTS), and Bit 0 for\ndata input.  See locations 659-660 ($293-$294) for more details on the\nRS-232 device.\n\nAll of the data lines which the RS-232 device uses are also available\nto the user as part of the User Port.  All of the Port B data lines,\nand Bit 2 of Port A, are brought out to the User Port connector on the\nback of the 64.  These data bits are utilized in the normal way:  The\nport connections are made to TTL-level input or output devices, and\nthe direction of data is determined by the Data Direction Registers.\n\nIn addition, the User Port has pins connected to the two CIA Serial\nPorts (whose eight-bit shift registers are well-suited for\nserial-to-parallel and parallel-to-serial conversion),and the two CNT\nlines which aid in the operation of the Serial Ports.  The CNT lines\ncan also be used in conjunction with the CIA Timers, and allow them to\nbe used as frequency counters, event counters, interval timers, etc.\nThe advanced features of the CIA chip make almost any type of\ninterfacing application possible, and in the near future we will\nprobably see many interesting applications for the User Port on the\n64.  A pin description of tthe User Port connector is provided below:\n\nUser         RS-232\nPort  CIA    DB-25\nPin   Line   Pin     Description\n\n1                    Ground\n2                    +5 Volts (100 milliamps maximum)\n3                    RESET (grounding this pin causes a cold start)\n4     CNT1           CIA #1 Serial Port and Timer Counter\n5     SP1            CIA #1 Serial Data Port\n6     CNT2           CIA #2 Serial Port and Timer Counter\n7     SP2            CIA #2 Serial Data Port\n8     PC2            CIA #2 handshaking line\n9                    Connected to the ATN line of the Serial Bus\n10                   9 Volts AC (+ phase, 50 milliamps maximum)\n11                   9 volts AC (- phase, 50 milliamps maximum)\n12                   Ground\nA            1       Ground\nB     FLAG2          CIA #2 handshaking line\nC     PB0    3       Port B Bit 0--RS-232 Received Data (SIN)\nD     PB1    4       Port B Bit 1--RS-232 Request to Send (RTS)\nE     PB2    20      Port B Bit 2--RS-232 Data Terminal Ready (DTR)\nF     PB3    22      Port B Bit 3--RS-232 Ring Indicator (RI)\nH     PB4    8       Port B Bit 4--RS-232 Carrier Detect (DCD)\nJ     PB5            Port B Bit 5\nK     PB6    5       Port B Bit 6--RS-232 Clear to Send (CTS)\nL     PB7    6       Port B Bit 7--RS-232 Data Set Ready (DSR)\nM     PA2    2       Port A Bit 2--RS-232 Transmitted Data (Sout)\nN            7       Ground\n\nOne of the handshaking lines on the above chart, PC2, was not covered\nin the discussion of CIA #1, because that line of CIA #1 is not\nconnected to anything.  The CIA #2 PC line is accessible from the User\nPort, however.  This line will go low for one cycle following a read\nor write of Port B on CIA #2.  This signal lets external devices know\nwhen data has been read or written.\n\nBits 0 and 1 of CIA #2 Port A have an extremely important function.\nAs mentioned in the section on the VIC-II chip (53248, $D000), the\nvideo chip can address only 16K of memory at a time, and all graphics\ndata must be stored in that 16K block in order to be displayed.\nWithin this area, sprite graphics data may be placed in any of 256\ngroups of 64 bytes each.  Character data can be stored in any of eight\n2K blocks.  Text screen memory may be in any of 16 1K areas, and\nbitmap screen memory may be in either of two 8K sections.\n\nWhen you turn the power on, the VIC-II uses the bottom 16K of memory\nfor graphics.  Unfortunately, this block of memory is also used\nextensively for other important purposes.  Though some means of\neliminating these conflicts are discussed above, in many situations\nyou will want to change from the default 16K bank at the low end of\nmemory.\n\nBits 0 and 1 select the current 16K bank for video memory from the\nfour possible choices using the following bit patterns:\n\n00 (bit value of 0) Bank 3 (49152-65535, $C000-$FFFF)\n01 (bit value of 1) Bank 2 (32768-49151, $8000-$BFFF)\n10 (bit value of 2) Bank 1 (16384-32767, $4000-$7FFF)\n11 (bit value of 3) Bank 0 (0-16383, $0-$3FFF)\n\nThe technique for making this change from BASIC is discussed below.\nBut before we go ahead and start changing banks, let's briefly review\nthe contents of these areas, and the considerations for using them for\ngraphics.\n\nBlock 0.  This is normally used for system variables and BASIC program\ntext.  Locations 1024-2047 ($400-$7FF) are reserved for the default\nposition of screen memory.\n\nThere is an addition limitation on memory usage of this block, as the\nVIC-II sees the character generator ROM at 4096-8191 ($1000-$1FFF),\nmaking this portion of memory unavailable for other graphics data.\nGenerally, there is little free space here for graphics display data.\nLocations 679-767 ($2A7- $2FF) are unused, and could hold one sprite\nshape (number 11) or data for 11 characters.  The area from 820-1023\n($334-$3FF), which includes the cassette I/O buffer, is available for\ngraphics memory, and is large enough to hold three sprite shapes\n(numbers 13, 14, and 15), or data for 25 characters (numbers 103-127).\nBut getting enough memory for bitmap graphics requires that you either\nreserve memory after the end of BASIC text by lowering the end of\nBASIC pointer at 56 ($38), or raise the start of BASIC pointer at 44\n($2C).  See the entries for these pointers for more details.\n\nBlock 1.  Block 1 is normally used for BASIC program storage.  When\nusing this bank, the VIC-II does not have access to the character\ngenerator ROM.  Providing that you lower the top of memory so that\nBASIC programs do not interfere, this area is wide open for sprite\nshapes, character graphics, and bitmap graphics.\n\nThe drawbacks to useing this bank are the unavailability of the\ncharacter ROM and the limitation on BASIC program space (as little as\n14K).  The absence of the character ROM is a relatively minor\nnuisance, because you can always switch in the ROM and copy any or all\nof the characters to RAM (see the entries for location 1 and the\nalternate entry for 53248 ($D000), the Character ROM, for details).\nThis block may be a good alternate choice to avoid potential conflicts\nwith other applications that use higher memory.\n\nBlock 2.  The third block (Block 2) consists of 8K of RAM, half of\nwhich is seen by the VIC-II chip as character ROM, and the 8K BASIC\ninterpreter ROM.  The BASIC ROM area is available for graphics.  This\nis possible because of the 64's special addressing.  The VIC-II chip\nreads only from RAM, and thus sees the RAM underneath the BASIC ROM,\neven if the 6510 has ROM switched in.  The 6510, on the other hand,\nalways writes to RAM, even when dealing with memory it reads as ROM.\nWhatever is written to the RAM underlying the BASIC ROM is displayed\nnormally by the VIC-II chip.  This opens up an extra 8K are for\nsprites and character data under the BASIC ROM.\n\nYou should keep in mind that while you can write to this area, you\ncannot read it from BASIC.  This may not be a serious problem when it\ncomes to character sets and sprite data, but it's more of a drawback\nif you want to use this RAM for screen memory.\n\nFor example, the Operating System has to read the text screen to move\nthe cursor properly, and if it reads the ROM value instead of the RAM\nscreen data, it gets hopelessly confused, making it impossible to type\nin any commands.\n\nLikewise, you would not be able to read the high-resolution screen if\nit were placed here, without some machine language trickery.  With\nlocations 36863-40959 ousted by the character ROM, only 4K of true RAM\nremains for use as screen memory, not enough for a complete\nhigh-resolution screen.  Therefore, this block is not recommended for\nuse in bitmap mode if your program needs to check the screen.\nOtherwise, this is a good place for graphics memory, particularly if\nyou need to emulate the screen configuration of the PET.\n\nBlock 3.  Normally Block 3 contains 4K of RAM that is completely\nunused by the system, 4K if I/O registers, and the 8K Operating System\nKernal ROM.  It is very convenient to use when you need a lot of\nmemory space for both graphics and a BASIC program.  Although the\ncharacter ROM is not available, it can be copied to RAM.  The area\nunder the Kernal ROM can be used as explained above.  One possible\nconflict that you should be aware of is that the current version of\nthe DOS support program is written to reside at 52224 ($CC00).  It\nwould be safest to avoid using 52224-53247 for graphics if you plan to\nuse DOS support.\n\nChanging banks.  Once you have selected a bank of 16K to use, the\nprocedure for making the change from BASIC is as follows:\n\n1.  Set the Data Direction Register if necessary.  In order to use\nBits 0 and 1 of Port A to change banks, these bits must be set as\noutputs in Data Direction Register A.  Since this is the default\ncondition on powering-up, this step normally will not be needed.\n\n2.  Select a bank.  Banks 0-3 can be chosen by entering the following\nlines:\n\nPOKE 56578,PEEK(56578) OR 3: REM SET FOR OUTPUT IF NOT ALREADY\nPOKE 56576,(PEEK(56576) AND 252) OR (3-BANK): REM BANK IS BANK #, MUST\n  BE 0-3\n\n3.  Set the VIC-II register for character memory.  As explained at the\nentry for location 53272 ($D018), the formula for this is:\n\nPOKE 53272,(PEEK(53272) AND 240) OR TK: REM TK IS 2 KBYTE OFFSET FROM\n  BEGINNING OF BLOCK\n\n4.  Set the VIC-II register for display memory.  As explained at the\nentry for location 53272 ($D018), the formula for this is:\n\nPOKE 53272,(PEEK(53272) AND 15) OR K*16: REM K IS KBYTE OFFSET FROM\n  BEGINNING OF BLOCK\n\nSince steps 3 and 4 operate on the same register, you could combine\nthese steps and just POKE 53272,(16*K+TK).\n\n5.  Set the Operating System pointer for display memory at 648 ($288).\nEven though you have just told the VIC-II chip where to display memory\nfor the screen, the Operating System does not yet know where to write\nits text characters.  Let it know with this statement:\n\nPOKE 648,AD/256: REM AD IS THE ACTUAL ADDRESS OF SCREEN MEMORY\n\nAfter you make this change, you must watch out for the STOP/RESTORE\nkey combination.  The BRK initialization changes the screen display\ndefault to location 1024 in Bank 0, but not the Operating System\npointer at 648 ($288).  As a result, what you are typing will not be\ndisplayed on the screen.  The computer will lock up until you turn the\npower off and back on again.  The simplest way to avoid this problem\nis to disable the RESTORE key entirely (see the entries for 792 ($318)\nand 808 ($328) for more information).\n\nBelow is a sample program which switches to Bank 3.  It includes a\nmachine language transfer routine to move the ROM character set to\nRAM, and a short interrupt routine to correct the RESTORE key problem.\nAfter the switch is made, a loop isused to POKE characters into the\nnew screen memory area.  Next, the character data is slowly erased, to\nshow that the character set is now in RAM.  Then, a loop is used to\nread the locations of the character set, and write to the same\nlocations.  This demonstrates that the 6510 reads the Kernal ROM when\nyou PEEK those locations, but POKEs to the RAM which is being\ndisplayed.  Finally, the machine language move is used again to show\nhow quickly the set is restored.\n\n20 FOR I=1 TO 33:READ A:POKE 49152+I,A:NEXT: REM SET UP ML ROUTINE\n30 GOSUB 200: REM ML COPY OF ROM CHARACTER SET TO RAM\n40 POKE 56576,PEEK(56576) AND 252: REM STEP 1, ENABLE BANK 3\n50 POKE 53272,44: REM STEPS 2-3, POINT VIC-II TO SCREEN AND CHARACTER MEMORY\n60 REM SCREEN OFFSET IS 2*16, CHARACTER OFFSET IS 12\n70 POKE 648,200: REM STEP 4, POINT OS TO SCREEN AT 51200 (200*256)\n80 PRINT CHR$(147): REM CLEAR SCREEN\n90 FOR I=53236 TO 53245:READ A:POKE I,A:NEXT: REM NEW INTERRUPT ROUTINE\n100 POKE 53246,PEEK(792):POKE 53247,PEK(793): REM SAVE OLD NMI VECTOR\n110 POKE 792,244:POKE 793,207: REM ROUTE THE INTERRUPT THROUGH THE NEW ROUTINE\n120 FOR I=0 TO 255:POKE 51400+I,I:POKE 55496+I,1:NEXT\n125 REM POKE CHARACTERS TO SCREEN\n130 FOR J=1 TO 8:FOR I=61439+J TO I+2048 STEP 8\n140 POKE I,0:NEXT I,J: REM ERASE CHARACTER SET\n150 FOR I=61440 TO I+2048:POKE I,PEEK(I):NEXT: REM POKE ROM TO RAM\n160 GOSUB 200:END: REM RESTORE CHARACTER SET\n200 POKE 56334,PEEK(56334) AND 254: REM DISABLE INTERRUPTS\n210 POKE 1,PEEK(1) AND 251:REM SWITCH CHARACTER ROM INTO 6510 MEMORY\n220 SYS 49152: REM COPY ROM CHARACTER SET TO RAM AT 61440\n230 POKE 1,PEEK(1) OR 4: REM SWITCH CHARACTER ROM OUT OF 6510 MEMORY\n240 POKE 56334,PEEK(56334)OR 1: REM ENABLE INTERRUPTS\n250 RETURN\n300 REM DATA FOR ML PROGRAM TO COPY CHARACTER SET TO RAM\n310 DATA169,0,133,251,133,253,169,208,133,252,169,240,133,254,162,16\n320 DATA160,0,177,251,145,253,136,208,249,230,252,230,254,202,208,240,96\n330 REM NEXT IS ML PROGRAM TO MAKE THE RESTORE KEY RESET OS POINTER TO SCREEN\n340 DATA 72,169,4,141,136,02,104,108,254,207\n\nSee also the sample program showing how to configure your 64 like a\nPET at location 43 ($2B)."}, {"id": "map-DD00", "address_start": 56576, "address_end": 56576, "hex_start": "$DD00", "hex_end": "$DD00", "label": "CI2PRA", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56576         $DD00          CI2PRA\nData Port Register A\n\nBits 0-1:  Select the 16K VIC-II chip memory bank (11=bank 0, 00=bank 3)\nBit 2:  RS-232 data output (Sout)/Pin M of User Port\nBit 3:  Serial bus ATN signal output\nBit 4:  Serial bus clock pulse output\nBit 5:  Serial bus data output\nBit 6:  Serial bus clock pulse input\nBit 7:  Serial bus data input"}, {"id": "map-DD01", "address_start": 56577, "address_end": 56577, "hex_start": "$DD01", "hex_end": "$DD01", "label": "CI2PRB", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56577         $DD01          CI2PRB\nData Port B\n\nBit 0:  RS-232 data input (SIN)/ Pin C of User Port\nBit 1:  RS-232 request to send (RTS)/ Pin D of User Port\nBit 2:  RS-232 data terminal ready (DTR)/ Pin E of User Port\nBit 3:  RS-232 ring indicator (RI)/ Pin F of User Port\nBit 4:  RS-232 carrier detect (DCD)/ Pin H of User Port\nBit 5:  Pin J of User Port\nBit 6:  RS-232 clear to send (CTS)/ Pin K of User Port\n        Toggle or pulse data output for Timer A\nBit 7:  RS-232 data set ready (DSR)/ Pin L of User Port\n        Toggle or pulse data output for Timer B"}, {"id": "map-DD02-DD03", "address_start": 56578, "address_end": 56579, "hex_start": "$DD02", "hex_end": "$DD03", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56578-56579 ($DD02-$DD03)\nCIA #2 Data Direction Registers A and B\n\nThese Data Direction registers control the direction of data flow over\nData Ports A and B.  For more details on the operation of these\nregisters, see the entry for the CIA #1 Data Direction Registers at\n56322 ($DC02).\n\nThe default setting for Data Direction Register A is 63 (all bits\nexcept 6 and 7 are outputs), and for Data Direction Register B the\ndefault setting is 0 (all inputs).  Bits 1 and 2 of Port B are changed\nto output when the RS-232 device is opened."}, {"id": "map-DD02", "address_start": 56578, "address_end": 56578, "hex_start": "$DD02", "hex_end": "$DD02", "label": "C2DDRA", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56578         $DD02          C2DDRA\nData Direction Register A\n\nBit 0:  Select Bit 0 of data Port A for input or output (0=input, 1=output)\nBit 1:  Select Bit 1 of data Port A for input or output (0=input, 1=output)\nBit 2:  Select Bit 2 of data Port A for input or output (0=input, 1=output)\nBit 3:  Select Bit 3 of data Port A for input or output (0=input, 1=output)\nBit 4:  Select Bit 4 of data Port A for input or output (0=input, 1=output)\nBit 5:  Select Bit 5 of data Port A for input or output (0=input, 1=output)\nBit 6:  Select Bit 6 of data Port A for input or output (0=input, 1=output)\nBit 7:  Select Bit 7 of data Port A for input or output (0=input, 1=output)"}, {"id": "map-DD03", "address_start": 56579, "address_end": 56579, "hex_start": "$DD03", "hex_end": "$DD03", "label": "C2DDRB", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56579         $DD03          C2DDRB\nData Direction Register B\n\nBit 0:  Select Bit 0 of data Port B for input or output (0=input, 1=output)\nBit 1:  Select Bit 1 of data Port B for input or output (0=input, 1=output)\nBit 2:  Select Bit 2 of data Port B for input or output (0=input, 1=output)\nBit 3:  Select Bit 3 of data Port B for input or output (0=input, 1=output)\nBit 4:  Select Bit 4 of data Port B for input or output (0=input, 1=output)\nBit 5:  Select Bit 5 of data Port B for input or output (0=input, 1=output)\nBit 6:  Select Bit 6 of data Port B for input or output (0=input, 1=output)\nBit 7:  Select Bit 7 of data Port B for input or output (0=input, 1=output)"}, {"id": "map-DD04-DD07", "address_start": 56580, "address_end": 56583, "hex_start": "$DD04", "hex_end": "$DD07", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56580-56583 ($DD04-$DD07)\nTimer A and B Low and High Bytes\n\nThese four timer registers are used to control Timers A and B.  For\ndetails on the operation of these timers, see the entry for Location\nRange 56324-56327 ($DC04-$DC07).\n\nThe 64 Operating System uses the CIA #2 Timers A and B mostly for\ntiming RS-232 send and receive operations.  Serial Bus timing uses CIA\n#1 Timer B."}, {"id": "map-DD04", "address_start": 56580, "address_end": 56580, "hex_start": "$DD04", "hex_end": "$DD04", "label": "TI2ALO", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56580         $DD04          TI2ALO\nTimer A (low byte)"}, {"id": "map-DD05", "address_start": 56581, "address_end": 56581, "hex_start": "$DD05", "hex_end": "$DD05", "label": "TI2AHI", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56581         $DD05          TI2AHI\nTimer A (high byte)"}, {"id": "map-DD06", "address_start": 56582, "address_end": 56582, "hex_start": "$DD06", "hex_end": "$DD06", "label": "TI2BLO", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56582         $DD06          TI2BLO\nTimer B (low byte)"}, {"id": "map-DD07", "address_start": 56583, "address_end": 56583, "hex_start": "$DD07", "hex_end": "$DD07", "label": "TI2BHI", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56583         $DD07          TI2BHI\nTimer B (high byte)"}, {"id": "map-DD08-DD0B", "address_start": 56584, "address_end": 56587, "hex_start": "$DD08", "hex_end": "$DD0B", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56584-56587 ($DD08-$DD0B)\nTime of Day Clock\n\nIn addition to the two general purpose timers, the 6526 CIA chip has a\nspecial purpose Time of Day Clock, which keeps time in a format that\nhumans can understand a little more easily than microseconds.  For\nmore information about this clock, see the entry for Location Range\n56328-56331 ($DC08-$DC0B).  The 64's Operating system does not make\nuse of these registers."}, {"id": "map-DD08", "address_start": 56584, "address_end": 56584, "hex_start": "$DD08", "hex_end": "$DD08", "label": "TO2TEN", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56584         $DD08          TO2TEN\nTime of Day Clock Tenths of Seconds\n\nBits 0-3:  Time of Day tenths of second digit (BCD)\nBits 4-7:  Unused"}, {"id": "map-DD09", "address_start": 56585, "address_end": 56585, "hex_start": "$DD09", "hex_end": "$DD09", "label": "TO2SEC", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56585         $DD09          TO2SEC\nTime of Day Clock Seconds\n\nBits 0-3:  Second digit of Time of Day seconds (BCD)\nBits 4-6:  First digit of Time of Day seconds (BCD)\nBit 7:  Unused"}, {"id": "map-DD0A", "address_start": 56586, "address_end": 56586, "hex_start": "$DD0A", "hex_end": "$DD0A", "label": "TO2MIN", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56586         $DD0A          TO2MIN\nTime of Day Clock Minutes\n\nBits 0-3:  Second digit of Time of Day minutes (BCD)\nBits 4-6:  First digit of Time of Day minutes (BCD)\nBit 7:  Unused"}, {"id": "map-DD0B", "address_start": 56587, "address_end": 56587, "hex_start": "$DD0B", "hex_end": "$DD0B", "label": "TO2HRS", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56587         $DD0B          TO2HRS\nTime of Day Clock Hours\n\nBits 0-3:  Second digit of Time of Day hours (BCD)\nBit 4:  First digit of Time of Day hours (BCD)\nBits 5-6:  Unused\nBit 7:  AM/PM flag (1=PM, 0=AM)"}, {"id": "map-DD0C", "address_start": 56588, "address_end": 56588, "hex_start": "$DD0C", "hex_end": "$DD0C", "label": "CI2SDR", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56588         $DD0C          CI2SDR\nSerial Data Port\n\nThe CIA chip has an on-chip serial port, which allows you to send or\nreceive a byte of data one bit at a time, with the most significant\nbit (Bit 7) being transferred first.  For more information about its\nuse, see the entry for location 56332 ($DC0C).  The 64's Operating\nSystem does not use this facility."}, {"id": "map-DD0D", "address_start": 56589, "address_end": 56589, "hex_start": "$DD0D", "hex_end": "$DD0D", "label": "CI2ICR", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56589         $DD0D          CI2ICR\nInterrupt Control Register\n\nBit 0:  Read / did Timer A count down to 0?  (1=yes)\n        Write/ enable or disable Timer A interrupt (1=enable, 0=disable)\nBit 1:  Read / did Timer B count down to 0?  (1=yes)\n        Write/ enable or disable Timer B interrupt (1=enable, 0=disable)\nBit 2:  Read / did Time of Day Clock reach the alarm time?  (1=yes)\n        Write/ enable or disable TOD clock alarm interrupt (1=enable,\n        0=disable)\nBit 3:  Read / did the serial shift register finish a byte?  (1=yes)\n        Write/ enable or disable serial shift register interrupt (1=enable,\n        0=disable)\nBit 4:  Read / was a signal sent on the FLAG line?  (1=yes)\n        Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)\nBit 5:  Not used\nBit 6:  Not used\nBit 7:  Read / did any CIA #2 source cause an interrupt?  (1=yes)\n        Write/ set or clear bits of this register (1=bits written with 1 will\n        be set, 0=bits written with 1 will be cleared)\n\nThis register is used to control the five interrupt sources on the\n6526 CIA chip.  For details on its operation, see the entry for 56333\n($DC0D).  The main difference between these two chips pertaining to\nthis register is that on CIA #2, the FLAG line is connected to Pin B\nof the User Port, and thus is available to the user who wishes to take\nadvantage of its ability to cause interrupts for handshaking purposes.\n\nLocation Range: 56590-$56591 ($DD0E-$DD0F)\nSee locations 56334 and 56334 for details"}, {"id": "map-DD0E", "address_start": 56590, "address_end": 56590, "hex_start": "$DD0E", "hex_end": "$DD0E", "label": "CI2CRA", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56590         $DD0E          CI2CRA\nControl Register A\n\nBit 0:  Start Timer A (1=start, 0=stop)\nBit 1:  Select Timer A output on Port B (1=Timer A output appears on\n        Bit 6 of Port B)\nBit 2:  Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one\n        cycle)\nBit 3:  Timer A run mode (1=one-shot, 0=continuous)\nBit 4:  Force latched value to be loaded to Timer A counter (1=force\n        load strobe)\nBit 5:  Timer A input mode (1=count microprocessor cycles, 0=count\n        signals on CNT line at pin 4 of User Port)\nBit 6:  Serial Port (56588, $DD0C) mode (1=output, 0=input)\nBit 7:  Time of Day Clock frequency (1=50 Hz required on TOD pin,\n        0=60 Hz)"}, {"id": "map-DD0F", "address_start": 56591, "address_end": 56591, "hex_start": "$DD0F", "hex_end": "$DD0F", "label": "CI2CRB", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56591         $DD0F          CI2CRB\nControl Register B\n\nBit 0:  Start Timer B (1=start, 0=stop)\nBit 1:  Select Timer B output on Port B (1=Timer B output appears on\n        Bit 7 of Port B)\nBit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one\n        cycle)\nBit 3:  Timer B run mode (1=one shot, 0=continuous)\nBit 4:  Force latched value to be loaded to Timer B counter (1=force\n        load strobe)\nBits 5-6:  Timer B input mode\n           00 = Timer B counts microprocessor cycles\n           01 = Count signals on CNT line at pin 4 of User Port\n           10 = Count each time that Timer A counts down to 0\n           11 = Count Timer A 0's when CNT pulses are also present\nBit 7:  Select Time of Day write (0=writing to TOD registers sets\n           alarm, 1=writing to ROD registers sets clock)"}, {"id": "map-DD10-DDFF", "address_start": 56592, "address_end": 56831, "hex_start": "$DD10", "hex_end": "$DDFF", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56592-56831 ($DD10-$DDFF)\nCIA #2 Register Images\n\nSince the CIA chip requires only enough addressing lines to handle 16\nregisters, none of the higher bits are decoded when addressing the\n256-byte area that has been assigned to it.  The result is that every\n16-byte area in this 256-byte block is a mirror of every other.  For\nthe sake of clarity in your programs, it is advisable not to use these\naddresses."}, {"id": "map-DE00-DEFF", "address_start": 56832, "address_end": 57087, "hex_start": "$DE00", "hex_end": "$DEFF", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56832-57087 ($DE00-$DEFF)\nReserved for I/O Expansion\n\nThis range of locations is not used directly by the 64's internal\nhardware.  It is, however, accessible via pin 7 of the Expansion Port.\nIt can be used to control cartridges which are connected to this port.\nFor example, the CP/M module uses this space to control which\nmicroprocessor is in control of the system.  The Z-80 microprocessor\nis turned on and off by writing to 56832 ($DE00).\n\nAnother cartridge which uses this space is Simon's BASIC.  This 16K\ncartridge is addressed at memory locations 32768-49151 ($8000-$BFFF),\nwhich means that it overlaps the regular BASIC ROM at 40960-49151\n($A000-$BFFF).  But since it contains additions to BASIC, it must use\nthe BASIC ROM as well.  This problem is solved by copying the\ncartridge at 32768-40959 ($8000-$9FFF) to RAM, and turning the\ncartridge on and off by writing to or reading from location 56832\n($DE00)."}, {"id": "map-DF00-DFFF", "address_start": 57088, "address_end": 57343, "hex_start": "$DF00", "hex_end": "$DFFF", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 57088-57343 ($DF00-$DFFF)\nCIA #2 Register Images\n\nThis range of locations is not used directly by the 64's internal\nhardward, but is accessible via pin 10 of the Expansion Port.  One\npossible use for this I/O memory that Commodore has mentioned is an\ninexpensive parallel disk drive (which presumable would be much faster\nthan the current serial model).\n\nAlternate 53248-57343 ($D000-$DFFF)\nCharacter Generator ROM\n\nThe character generator ROM supplies the data which is to form the\nshapes of the text and graphics characters that are displayed on the\nscreen.  Each character requires eight bytes of shape data, and these\neight-byte sequences are arranged in order in which the characters\nappear in the screen code chart (see Appendix G).  For example, the\nfirst eight bytes of data in the ROM hold the shape information for\nthe commercial at sign (@), the next eight hold the shape of the\nletter A, etc.  In all, there are 4096 bytes, representing shape data\nfor two complete character sets of 256 characters each--1K each for\nuppercase/graphics, reverse uppercase/reverse graphics, lowercase/\nuppercase, and reverse lowercase/reverse uppercase.\n\nThe shape of each character is formed by an 8 by 8 matrix of screen\ndots.  Whether any of the 64 dots is lit up or not is determined by\nthe bit patterns of the character data.  Each byte of the Character\nROM holds a number from 0 to 255.  This number can be represented by\neight binary digits of 0 or 1.  The leftmost bit of these eight is\nknown as Bit 7, while the rightmost bit is called Bit 0.  Each of\nthese binary digits has a bit value that is two times greater than the\nlast.  The values of a bit set to 1 in each of the bit places are:\n\nBit    0    1     2    3    4    5    6    7\nValue  1    2     4    8   16   32   64  128\n\nA byte whose value is 255 has every bit set to 1\n(128+64+32+16+8+4+2+1=255), while a byte whose value is 0 is made up\nof all zero bits.  Numbers in between are made up of combinations of\nbits set to 1 and bits set to 0.  If you think of every bit that holds\n0 as a dot on the screen which is the color of the screen background,\nand every bit that holds a 1 as a dot whose color is that of the\nappropriate nybble in Color RAM, you can begin to get an idea of how\nthe byte values relate to the shape of the character.  For example, if\nyou PEEK at the first eight bytes of the character ROM (the technique\nis explained in the entry for location 1), you will see the numbers\n60, 102, 110, 110, 96, 98, 60, 0.  Breaking these data bytes down into\ntheir bit values gives us a picture that looks like the following:\n\n00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60\n01100110   0 +  64 +  32 +   0 +   0 +   4 +   2 +   0 = 101\n01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110\n01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110\n01100000   0 +  64 +  32 +   0 +   0 +   0 +   0 +   0 =  96\n01100010   0 +  64 +  32 +   0 +   0 +   0 +   2 +   0 =  98\n00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60\n00000000   0 +   0 +   0 +   0 +   0 +   0 +   0 +   0 =   0\n\nIf you look closely, you will recognize the shape of the commercial at\nsign (@) as it's displayed on your screen.  The first byte of data is\n60, and you can see that Bits 5, 4, 3, and 2 are set to 1.  The chart\nabove shows that the bit values for these bits are 32, 16, 8, and 4.\nAdding these together, you get 32+16+8+4=60.  This should give you an\nidea of how the byte value corresponds to the patterns of lit dots.\nFor an even more graphic display, type in the following program, which\nshows the shape of any of the 512 characters in the ROM, along with\nthe number value of each byte of the shape.\n\n10 DIM B%(7),T%(7):FOR I=0 TO 7:T%(I)=2^I:NEXT\n20 POKE 53281,2:PRINT CHR$(147):POKE 53281,1:POKE 53280,0:POKE 646,11\n30 POKE 214,20:PRINT:INPUT\" CHARACTER NUMBER (0-511)\";C$\n40 C=VAL(C$):GOSUB 80:FOR I=0 TO 7\n50 POKE 214,6+I:PRINT:PRINT TAB(23);B%(I);CHR$(20);\"   \"\n60 FOR J=7 TO 0 STEP-1:POKE 1319+(7-J)+I*40,32-128*((B%(I)ANDT%(J))=T%(J))\n70 NEXT J,I:POKE 214,20:PRINT:PRINT TAB(27)\"    \":GOTO 30\n80 POKE 56333,127:POKE 1,51:FOR I=0 TO 7\n90 B%(I)=PEEK(53248+C*8+I):NEXT:POKE 1,55:POKE 56333,129:RETURN\n\nIf you have read about the VIC-II video chip, you know that it can\naddress only 16K of memory at a time, and that all display data such\nas screen memory, character shape data, and sprite shape data must be\nstored within that 16K block.\n\nSince it would be very inconvenient for the VIC-II chip to be able to\naccess the character data only at the 16K block which includes\nadresses 53248-57343 ($D000-$DFFF), the 64 uses an addressing trick\nthat makes the VIC-II chip see an image of the Character ROM at\n4096-8191 ($1000-$1FFF) and at 36864-40959 ($9000-$9FFF).  It is not\navailable in the other two blocks.  To generate characters in these\nblocks, you must supply your own user-defined character set, or copy\nthe ROM data to RAM.  A machine language routine for doing this is\nincluded in a sample program at the entry for 56576 ($DD00).\n\nAs indicated above, you are by no means limited to useing the\ncharacter data furnished by the ROM.  The availability of user-defined\ncharacters greatly extends the graphics power of the 64.  It allows\nyou to create special text characters, like math or chemistry symbols\nand foreign language alphabets.  You can also develop special graphics\ncharacters as a substitute for plotting points in bitmap graphics.\nYou can achieve the same resolution using a custom character as in\nhigh-resolution bitmap mode, but with less memory. Once you have\ndefined the character, it is much faster to print it to the screen\nthan in would be to plot out all of the individual points.\n\nTo employ user-defined characters, you must first pick a spot to put\nthe shape data.  This requires choosing a bank of 16K for video chip\nmemory (see the entry under Bits 0-1 of 56576 ($DD00) for the\nconsiderations involved), and setting the pointer to the 2K area of\ncharacter memory in 53272 ($D018).  It is then up to you to supply the\nshape data for the characters.  You can use part of the ROM character\nset by reading the ROM and transferring the data to your character\nshape area (see the entry for location 1 for a method of reading the\nROM).\n\nYour original characters may be created by darkening squares on an 8\nby 8 grid, converting all darkened squares to their bit values, and\nthen adding the bit values for each of the eight bytes.  Or, you may\nuse one of the many character graphics editor programs that are\navailable commercially to generate the data interactively by drawing\non the screen.\n\nOne graphics mode, multicolor text mode, almost requires that you\ndefine your own character set in order to use it effectively.\nMulticolor mode is enabled by Bit 4 of location 53270 ($D016).\nInstead of using each bit to control whether an individual dot will be\nforeground color (1) or background color (0), that mode breaks down\neach byte of shape data in four bit-pairs.  These bit pairs control\nwhether a dot will be the color in Background Color Register #0 (00),\nthe color in Background Color Register #1 (01), the color in\nBackground Color Register #2 (10), or the color in the appropriate\nnybble of Color RAM (11).  Since each pair of bits controls one dot,\neach character is only four dots across.  To make up for this, each\ndot is twice as wide as a normal high-resolution dot.\n\n\n::::::::::::::::\n::            ::\n::8K Operating::\n::   System   ::\n:: Kernal ROM ::\n::::::::::::::::\n\nAs with the section on the BASIC ROM, this section is not meant to be\na complete explanation of the Kernal ROM, but rather a guidepost for\nfurther exploration.  Where the exact instructions the Kernal ROM\nroutines use are important to your programming, it will be necessary\nfor you to obtain a disassembly listing of those routines and look at\nthe code itself.\n\nKeep in mind that there is 8K of RAM underlying the Kernal ROM that\ncan be used by turning off interrupts and switching out the Kernal ROM\ntemporarily.  Even without switching out the Kernal ROM, this RAM may\nbe read by the VIC-II chip if it is banked to use the top 16K of\nmemory, and may be used for graphics data.  The Kernal and BASIC ROMs\nmay be copied to RAM, and the RAM versions modified to change existing\nfeatures or add new ones.\n\nThere are some differences between the version of the Kernal found on\nthe first few Commodore 64s and those found on the majority of newer\nmodels.  Those differences are discussed in the entries for the\nsections on later Kernal additions (patches) at 58541-58623\n($E4AD-$E4FF) an 65371-67407 ($FF5B-$FF7F).\n\nThe most obvious change causes the Color RAM at 55296 ($D800) to be\ninitialized to the background color when the screen is cleared on\nnewer models, instead of white as on the original models.  Other\nchanges allow the new Kernal software to be used by either U.S. or\nEuropean 64s.  Keep in mind that the Kernal is always subject to\nchange, and that the following discussion, while accurate at the time\nwritten (mid-1983), may not pertain to later models.  If future\nchanges are like past ones, however, they are likely to be minor ones.\nThe first place to look for these changes would be in the patch\nsections identified above."}, {"id": "map-E000", "address_start": 57344, "address_end": 57344, "hex_start": "$E000", "hex_end": "$E000", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57344         $E000\nContinuation of EXP Routine\n\nThis routine is split, with part on the BASIC ROM and the other part\nhere.  Since the two ROMs do not occupy contiguous memory as on most\nCommodore machines, the BASIC ROM ends with a JMP $E000 instruction.\nThus, while the BASIC interpreter on the 64 is for the most part the\nsame as on the VIC, the addresses for routines in this ROM are\ndisplaced by three bytes from their location on the VIC."}, {"id": "map-E043", "address_start": 57411, "address_end": 57411, "hex_start": "$E043", "hex_end": "$E043", "label": "POLY1", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57411         $E043          POLY1\nFunction Series Evaluation Subroutine 1\n\nThis routine is used to evaluate more comples expressions, and calls\nthe following routine to do the intermediate evaluation."}, {"id": "map-E059", "address_start": 57433, "address_end": 57433, "hex_start": "$E059", "hex_end": "$E059", "label": "POLY2", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57433         $E059          POLY2\nFunction Series Evaluation Subroutine 2\n\nThis is the main series evaluation routine, which evaluates\nexpressions by using a table of the various values that must be\noperated on in sequence to obtain the proper result."}, {"id": "map-E08D", "address_start": 57485, "address_end": 57485, "hex_start": "$E08D", "hex_end": "$E08D", "label": "RMULC", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57485         $E08D          RMULC\nMultiplicative Constant for RND\n\nA five-byte floating point number which is multiplied by the seed\nvalue as part of the process of obtaining the next value for RND>"}, {"id": "map-E092", "address_start": 57490, "address_end": 57490, "hex_start": "$E092", "hex_end": "$E092", "label": "RADDC", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57490         $E092          RADDC\nAdditive Constant for RND\n\nThe five-byte floating point number stored here is added to the seed\nas part of the process of obtaining the value for RND."}, {"id": "map-E097", "address_start": 57495, "address_end": 57495, "hex_start": "$E097", "hex_end": "$E097", "label": "RND", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57495         $E097          RND\nPerform RND\n\nThis routine comes up with a random number in one of three ways,\ndepending on the argument X of RND(X).  If the argument is positive,\nthe next RND value is obtained by multiplying the seed value in\nlocation 139 ($8B) by one of the constants above, adding the other\nconstant, and scrambling the resulting bytes.  This produces the next\nnumber in a sequence.  So many numbers can be produced in this way\nbefore the sequence begins to repear that it can be considered random.\n\nIf the argument is negative, the argument itself is scrambled, and\nmade the new seed.  This allows creation of a sequence that can be\nduplicated.\n\nIf the argument is 0, four bytes of the Floating Point Accumulator are\nloaded from the low and high byte of Timer A, and the tenths of second\nand second Time of Day Clock registers, all on CIA #1.  This provides\na somewhat random value determined by the setting of those timers at\nthe moment that the command is executed, which becomes the new seed\nvalue.  The RND(1) command should then be used to generate further\nrandom numbers.\n\nThe RND(0) implementation on the 64 has serious problems which make it\nunusable for generating a series of random numbers when used by\nitself.  First of all, the Time of Day Clock on CIA #1 (see\n56328-56331 ($DC08-$DC0B)) does not start running until you write to\nthe tenth of second register.  The Operating System never starts this\nclock, and therefore the two registers used as part of the floating\npoint RND(0) value always have a value of 0.  Even if the clock was\nstarted, however, these registers keep time in Binary Coded Decimal\n(BCD) format, which means that they do not produce a full range of\nnumbers from 0 to 255.  In addition, the Timer A high register output\nranges only from 0 to 66, which also imits the range of the final\nfloating point value so that certain numbers are never chosen."}, {"id": "map-E0F9", "address_start": 57593, "address_end": 57593, "hex_start": "$E0F9", "hex_end": "$E0F9", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57593         $E0F9\nCall Kernal I/O Routines\n\nThis section is used when BASIC wants to call the Kernal I/O routines\nCHROUT, CHRIN, CHKOUT, CHKIN, and GETIN.  It handles any errors that\nresult from the call, and creates a 512-byte buffer space at the top\nof BASIC and executes a CLR if the RS-232 device is opened."}, {"id": "map-E12A", "address_start": 57642, "address_end": 57642, "hex_start": "$E12A", "hex_end": "$E12A", "label": "SYS", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57642         $E12A          SYS\nPerform SYS\n\nBefore executing the machine language subroutine (JSR) at the address\nindicated, the .A, .X, .Y, and .P registers are loaded from the\nstorage area at 780-783 ($30C-$30F).  After the return from subroutine\n(RTS), the new values of those registers are stored back at 780-783\n($30C-$30F)."}, {"id": "map-E156", "address_start": 57686, "address_end": 57686, "hex_start": "$E156", "hex_end": "$E156", "label": "SAVE", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57686         $E156          SAVE\nPerform SAVE\n\nThis routine sets the range of addresses to be saved from the start of\nBASIC program text and end of BASIC program text pointers at 43 ($2B)\nand 45 ($2D), and calls the Kernal SAVE routine.  This means that any\narea of memory can be saved by altering these two pointers to point to\nthe starting and ending address of the desired area, and then changing\nthem back."}, {"id": "map-E165", "address_start": 57701, "address_end": 57701, "hex_start": "$E165", "hex_end": "$E165", "label": "VERIFY", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57701         $E165          VERIFY\nPerform VERIFY\n\nThis routine sets the load/verify flag at 10 ($A), and falls through\nto the LOAD routine."}, {"id": "map-E168", "address_start": 57704, "address_end": 57704, "hex_start": "$E168", "hex_end": "$E168", "label": "LOAD", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57704         $E168          LOAD\nPerform LOAD\n\nThis routine sets the load address to the start of BASIC (from pointer\nat 43 ($2B)), and calls the Kerneal LOAD routine.  If the load is\nsuccessful, it relinks the BASIC program so that the links agree with\nthe address to which it is loaded, and it resets the end of BASIC\npointer to reflect the new end of program text.  If the LOAD was done\nwhile a program was running, the pointers are reset so that the\nprogram starts executing all over again from the beginning.  A CLR is\nnot performed, so that the variables build so far are retained, and\ntheir values are still accessible.  The pointer to the variable area\nis not changed, but if the new program is longer than the one that\nloaded it, the variable table will be partially overwritten.  This\nwill cause errors when the overwritten variables are referenced.\nLikewise, strings whose text was referenced at its location within the\noriginal program listing will be incorrect.\n\nSince a LOAD from a program causes the program execution to continue\nat the first line, when loading a machine language routine or data\nfile with a nonrelocating load (for example, LOAD\"FILE\",8,1) from a\nprogram, you should read a flag and GOTO the line after the LOAD if\nyou don't want the program to keep rerunning indefinitely:\n\n10 IF FLAG=1 THEN GOTO 30\n20 FLAG=1:LOAD\"FILE\",8,1\n30 REM PROGRAM CONTINUES HERE"}, {"id": "map-E1BE", "address_start": 57790, "address_end": 57790, "hex_start": "$E1BE", "hex_end": "$E1BE", "label": "OPEN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57790         $E1BE          OPEN\nPerform OPEN\n\nThe BASIC OPEN statement calls the Kernal OPEN routine."}, {"id": "map-E1C7", "address_start": 57799, "address_end": 57799, "hex_start": "$E1C7", "hex_end": "$E1C7", "label": "CLOSE", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57799         $E1C7          CLOSE\nPerform CLOSE\n\nThe BASIC CLOSE statement calls the Kernal CLOSE routine."}, {"id": "map-E1D4", "address_start": 57812, "address_end": 57812, "hex_start": "$E1D4", "hex_end": "$E1D4", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57812         $E1D4\nSet Parameters for LOAD, VERIFY, and SAVE\n\nThis routine is used in common by LOAD, SAVE, and VERIFY for setting\nthe filename, the logical file, device number, and secondary address,\nall of which must be done prior to these operations."}, {"id": "map-E200", "address_start": 57856, "address_end": 57856, "hex_start": "$E200", "hex_end": "$E200", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57856         $E200\nSkip Comma and Get Integer in .X\n\nThis subroutine is used to skip the comma between parameters and get\nthe following integer value in the .X register."}, {"id": "map-E206", "address_start": 57862, "address_end": 57862, "hex_start": "$E206", "hex_end": "$E206", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57862         $E206\nFetch Current Character and Check for End of Line\n\nThis subroutine gets the current character, and if it is 0 (end of\nline), it pulls its own return address off the stack and returns.\nThis terminates both its own execution and that of the subroutine\nwhich called it."}, {"id": "map-E20E", "address_start": 57870, "address_end": 57870, "hex_start": "$E20E", "hex_end": "$E20E", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57870         $E20E\nCheck for Comma\n\nThis subroutine checks for a comma, moves the text pointer past it if\nfound, and returns an error if it is not found."}, {"id": "map-E219", "address_start": 57881, "address_end": 57881, "hex_start": "$E219", "hex_end": "$E219", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57881         $E219\nSet Parameters for OPEN and CLOSE\n\nThis routine is used in common by OPEN and CLOSE for setting the\nfilename, the logical file, device number, and secondary address, all\nof which must be done prior to these operations."}, {"id": "map-E264", "address_start": 57956, "address_end": 57956, "hex_start": "$E264", "hex_end": "$E264", "label": "COS", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57956         $E264          COS\nPerform COS\n\nCOS is executed by adding PI/2 to the contents of FAC1 and dropping\nthrough to SIN."}, {"id": "map-E268", "address_start": 57960, "address_end": 57960, "hex_start": "$E268", "hex_end": "$E268", "label": "SIN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "57960         $E268          SIN\nPerform SIN\n\nThis routine evaluates the SIN of the number in FAC1 (which represents\nthe angle in radians), and leaves the result there."}, {"id": "map-E2B4", "address_start": 58036, "address_end": 58036, "hex_start": "$E2B4", "hex_end": "$E2B4", "label": "TAN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58036         $E2B4          TAN\nPerform TAN\n\nThis routine evaluates the tangent of the number in FAC1 (which\nrepresents the angle in radians) by dividing its sine by its cosine."}]