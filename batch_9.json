[{"id": "map-D403", "address_start": 54275, "address_end": 54275, "hex_start": "$D403", "hex_end": "$D403", "label": "PWHI1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54275         $D403          PWHI1\nVoice 1 Pulse Waveform Width (high nybble)"}, {"id": "map-D404", "address_start": 54276, "address_end": 54276, "hex_start": "$D404", "hex_end": "$D404", "label": "VCREG1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54276         $D404          VCREG1\nVoice 1 Control Register\n\nBit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release\nBit 1:  Sync Bit:  1=Synchronize Oscillator with Oscillator 3 frequency\nBit 2:  Ring Modulation:  1=Ring modulate Oscillators 1 and 3\nBit 3:  Test Bit:  1=Disable Oscillator 1\nBit 4:  Select triangle waveform\nBit 5:  Select sawtooth waveform\nBit 6:  Select pulse waveform\nBit 7:  Select random noise waveform\n\n\nBit 0.  Bit 0 is used to gate the sound.  Setting this bit to a 1\nwhile selecting one of the four waveforms will start the\nattack/decay/sustain part of the cycle.  Setting this bit back to 0\n(while keeping the same waveform setting) anytime after a note has\nstarted playing will begin the release cycle of the note.  Of course,\nin order for the gate bit to have an effect, the frequency and\nattack/decay/sustain/release (ADSR) registers must be set, as well as\nthe pulse width, if necessary, and the volume control set to a nonzero\nvalue.\n\nBit 1.  This bit is used to synchronize the fundamental frequency of\nOscillator 1 with the fundamental frequency of Oscillator 3, allowing\nyou to create a wide range of complex harmonic structures from voice\n1.  Synchronization occurs when this bit is set to 1.  Oscillator 3\nmust be set to some frequency other than zero, but no other voice 3\nparameters will affect the output from voice 1.\n\nBit 2.  When Bit 2 is set to 1, the triangle waveform output of voice\n1 is replaced with a ring modulated combination of Oscillators 1 and\n3.  This ring modulation produces nonharmonic overtone structures that\nare useful for creating bell or gong effects.\n\nBit 3.  Bit 3 is the test bit.  When set to 1, it disables the output\nof the oscillator.  This can be useful in generating very complex\nwaveforms (even speech synthesis) under software control.\n\nBit 4.  When set to 1, Bit 4 selects the triangle waveform output of\nOscillator 1.  Bit 0 must also be set for the note to be sounded.\n\nBit 5.  This bit selects the sawtooth waveform when set to 1.  Bit 0\nmust also be set for the sound to begin.\n\nBit 6.  Bit 6 chooses the pulse waveform when set to 1.  The harmonic\ncontent of sound produced using this waveform may be varied using the\nPulse Width Registers.  Bit 0 must be set to begin the sound.\n\nBit 7.  When Bit 7 is set to 1, the noise output waveform for\nOscillator 1 is set.  This creates a random sound output whose\nwaveform varies with a frequency proportionate to that of Oscillator\n1.  It can be used to imitate the sound of explosions, drums, and\nother unpitched noises.\n\nOne of the four waveforms must be chosed in order to create a sound.\nSetting more than one of these bits will result in a logical ANDing of\nthe waveforms.  Particularly, the combination of the noise waveform\nand another is not recommended."}, {"id": "map-D405-D406", "address_start": 54277, "address_end": 54278, "hex_start": "$D405", "hex_end": "$D406", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 54277-54278 ($D405-$D406)\nVoice 1 Envelop (ADSR) Control\n\nWhen a note is played on a musical instrument, the volume does not\nsuddenly rise to a peak and then cut off to zero.  Rather, the volume\nbuilds to a peak, levels off to an intermediate value, and then fades\naway.  This creates what is known as a volume envelope.\n\nThe first phase of the envelope, in which the volume builds to a peak,\nis known as the attack phase.  The second, in which it declines to an\nintermediate level, is called the decay phase.  The third, in which\nthe intermediate leve of volume is held, is known as the sustain\nperiod.  The final interval, in which the sound fades away, is called\nthe release part of the cycle.\n\nThe SID chip allows the volume envelope of each voice to be\ncontrolled, so that specific instruments may be imitated, or new\nsounds created.  This is done via the attack/decay and sustain/release\nregisters.  Each register devotes four bits (which can store a number\nfrom 0 to 15) to each phase of the cycle.  When a note is gated by\nwriting a 1 to a waveform bit and to Bit 0 of the Control Register,\nthe attack cycle begins.\n\nThe volume of the sound builds to a peak over the period of time\nspecified by the high nybble of the attack/decay register.  Once it\nhas reached the peak volume, it falls to the intermediate level during\nthe period indicated by the low nybble of the attack/decay register\n(this is the decay phase).  The volume of this intermediate or sustain\nlevel is selected by placing a value in the high nybble of the\nsustain/release register.  This volume level is held until a 0 is\nwritten to the gate bit of the control register (while leaving the\nwaveform bit set).  When that happens, the release phase begins, and\nthe volume of the sound begins to taper off during the period\nindicated by the low nybble of the sustain/release register.\n\nYou may notice the volume of the sound does not quite get to 0 at the\nend of the release cycle, and you may need to turn off the sound to\nget rid of the residual noise.  You can do this either by setting the\nwaveform bit back to 0, changing the frequency to 0, or setting the\nvolume to 0."}, {"id": "map-D405", "address_start": 54277, "address_end": 54277, "hex_start": "$D405", "hex_end": "$D405", "label": "ATDCY1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54277         $D405          ATDCY1\nVoice 1 Attack/Decay Register\n\nBits 0-3:  Select decay cycle duration (0-15)\nBits 4-7:  Select attack cycle duration (0-15)\n\nBits 4-7 control the duration of the attack cycle.  This is the period\nof time over which the volume will rise from 0 to its peak amplitude.\nThere are 16 durations which may be selected.  The way in which the\nnumber placed here corresponds to the elapsed time of this cycle is as\nfollows:\n\n0 = 2 milliseconds           8 = 100 milliseconds\n1 = 8 milliseconds           9 = 250 milliseconds\n2 = 16 milliseconds         10 = 500 milliseconds\n3 = 24 milliseconds         11 = 800 milliseconds\n4 = 38 milliseconds         12 = 1 second\n5 = 56 milliseconds         13 = 3 seconds\n6 = 68 milliseconds         14 = 5 seconds\n7 = 80 milliseconds         15 = 8 seconds\n\nBits 0-3 control the length of the decay phase, in which the volume of\nthe note declines from the peak reached in the attack phase to the\nsustain level.  The number selected corresponds to the length of this\nphase as shown below:\n\n0 = 6 milliseconds           8 = 300 milliseconds\n1 = 24 milliseconds          9 = 750 milliseconds\n2 = 48 milliseconds         10 = 1.5 seconds\n3 = 72 milliseconds         11 = 2.4 seconds\n4 = 114 milliseconds        12 = 3 seconds\n5 = 168 milliseconds        13 = 9 seconds\n6 = 204 milliseconds        14 = 15 seconds\n7 = 240 milliseconds        15 = 24 seconds\n\nSince the two functions share one register, you must multiply the\nattack value by 16 and add it to the decay value in order to come up\nwith the number to be placed in the register:\n\nREGISTER VALUE=(ATTACK*16)+DECAY"}, {"id": "map-D406", "address_start": 54278, "address_end": 54278, "hex_start": "$D406", "hex_end": "$D406", "label": "SUREL1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54278         $D406          SUREL1\nVoice 1 Sustain/Release Control Register\n\nBits 0-3:  Select release cycle duration (0-15)\nBits 4-7:  Select sustain volume level (0-15)\n\nBits 4-7 select the volume level at which the note is sustained.\nFollowing the decay cycle, the volume of the output of voice 1 will\nremain at the selected sustain level as long as the gate bit of the\nControl Register is set to 1.  The sustain values range from 0, which\nchooses no volume, to 15, which sets the output of voice 1 equal to\nthe peak volume achieved during the attack cycle.\n\nBits 0-3 determine the length of the release cycle.  This phase, in\nwhich the volume fades from the sustain level to near zero volume,\nbegins when the gate bit of the Control Register is set to 0 (while\nleaving the waveform setting that was previously chosen).  The\nduration of this decline in volume corresponds to the number (0-15)\nselected in the same way as for the decay value:\n\n0 = 6 milliseconds           8 = 300 milliseconds\n1 = 24 milliseconds          9 = 750 milliseconds\n2 = 48 milliseconds         10 = 1.5 seconds\n3 = 72 milliseconds         11 = 2.4 seconds\n4 = 114 milliseconds        12 = 3 seconds\n5 = 168 milliseconds        13 = 9 seconds\n6 = 204 milliseconds        14 = 15 seconds\n7 = 240 milliseconds        15 = 24 seconds"}, {"id": "map-D407-D414", "address_start": 54279, "address_end": 54292, "hex_start": "$D407", "hex_end": "$D414", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 54279-54292 ($D407-$D414)\nVoice 2 and Voice 3 Controls\n\nThe various control registers for these two voices correspond almost\nexactly to those of voice 1.  The one exception is that the sync and\nring-modulation bits of voice 2 operate on Oscillators 1 and 2, while\nthe same bits of the Control Register for voice 3 uses Oscillators 2\nand 3."}, {"id": "map-D407", "address_start": 54279, "address_end": 54279, "hex_start": "$D407", "hex_end": "$D407", "label": "FRELO2", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54279         $D407          FRELO2\nVoice 2 Frequency Control (low byte)"}, {"id": "map-D408", "address_start": 54280, "address_end": 54280, "hex_start": "$D408", "hex_end": "$D408", "label": "FREHI2", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54280         $D408          FREHI2\nVoice 2 Frequency Control (high byte)"}, {"id": "map-D409", "address_start": 54281, "address_end": 54281, "hex_start": "$D409", "hex_end": "$D409", "label": "PWLO2", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54281         $D409          PWLO2\nVoice 2 Pulse Waveform Width (low byte)"}, {"id": "map-D40A", "address_start": 54282, "address_end": 54282, "hex_start": "$D40A", "hex_end": "$D40A", "label": "PWHI2", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54282         $D40A          PWHI2\nVoice 2 Pulse Waveform Width (high nybble)"}, {"id": "map-D40B", "address_start": 54283, "address_end": 54283, "hex_start": "$D40B", "hex_end": "$D40B", "label": "VCREG2", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54283         $D40B          VCREG2\nVoice 2 Control Register\n\nBit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release\nBit 1:  Sync Bit:  1=Synchronize oscillator with Oscillator 1 frequency\nBit 2:  Ring Modulation:  1=Ring modulate Oscillators 2 and 1\nBit 3:  Test Bit:  1=Disable Oscillator 2\nBit 4:  Select triangle waveform\nBit 5:  Select sawtooth waveform\nBit 6:  Select pulse waveform\nBit 7:  Select noise waveform"}, {"id": "map-D40C", "address_start": 54284, "address_end": 54284, "hex_start": "$D40C", "hex_end": "$D40C", "label": "ATDCY2", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54284         $D40C          ATDCY2\nVoice 2 Attack/Decay Register\n\nBits 0-3:  Select decay cycle duration (0-15)\nBits 4-7:  Select attack cycle duration (0-15)"}, {"id": "map-D40D", "address_start": 54285, "address_end": 54285, "hex_start": "$D40D", "hex_end": "$D40D", "label": "SUREL2", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54285         $D40D          SUREL2\nVoice 2 Sustain/Release Control Register\n\nBits 0-3:  Select release cycle duration (0-15)\nBits 4-7:  Select sustain volume level (0-15)"}, {"id": "map-D40E", "address_start": 54286, "address_end": 54286, "hex_start": "$D40E", "hex_end": "$D40E", "label": "FRELO3", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54286         $D40E          FRELO3\nVoice 3 Frequency Control (low byte)"}, {"id": "map-D40F", "address_start": 54287, "address_end": 54287, "hex_start": "$D40F", "hex_end": "$D40F", "label": "FREHI3", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54287         $D40F          FREHI3\nVoice 3 Frequency Control (high byte)"}, {"id": "map-D410", "address_start": 54288, "address_end": 54288, "hex_start": "$D410", "hex_end": "$D410", "label": "PWLO3", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54288         $D410          PWLO3\nVoice 3 Pulse Waveform Width (low byte)"}, {"id": "map-D411", "address_start": 54289, "address_end": 54289, "hex_start": "$D411", "hex_end": "$D411", "label": "PWHI3", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54289         $D411          PWHI3\nVoice 3 Pulse Waveform Width (high nybble)"}, {"id": "map-D412", "address_start": 54290, "address_end": 54290, "hex_start": "$D412", "hex_end": "$D412", "label": "VCREG3", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54290         $D412          VCREG3\nVoice 3 Control Register\n\nBit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release\nBit 1:  Sync Bit:  1=Synchronize oscillator with Oscillator 2 frequency\nBit 2:  Ring Modulation:  1=Ring modulate Oscillators 3 and 2\nBit 3:  Test Bit:  1=Disable Oscillator 3\nBit 4:  Select triangle waveform\nBit 5:  Select sawtooth waveform\nBit 6:  Select pulse waveform\nBit 7:  Select noise waveform"}, {"id": "map-D413", "address_start": 54291, "address_end": 54291, "hex_start": "$D413", "hex_end": "$D413", "label": "ATDCY3", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54291         $D413          ATDCY3\nVoice 3 Attack/Decay Register\n\nBits 0-3:  Select decay cycle duration (0-15)\nBits 4-7:  Select attack cycle duration (0-15)"}, {"id": "map-D414", "address_start": 54292, "address_end": 54292, "hex_start": "$D414", "hex_end": "$D414", "label": "SUREL3", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54292         $D414          SUREL3\nVoice 3 Sustain/Release Control Register\n\nBits 0-3:  Select release cycle duration (0-15)\nBits 4-7:  Select sustain volume level (0-15)"}, {"id": "map-D415-D418", "address_start": 54293, "address_end": 54296, "hex_start": "$D415", "hex_end": "$D418", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 54293-54296 ($D415-$D418)\nFilter Controls\n\nIn addition to the controls detailed above for each voice, the SID\nchip also provides a filtering capability which allows you to\nattenuate (make quieter) certain ranges of frequencies.  Any one or\nall three voices can be filtered, and there is even a provision for\nfiltering an external signal that is input through pin 5 of the\nmonitor jack.\n\nA low-pass filter is available, which suppresses the volume of those\nfrequency components that are above a designated cutoff level.  The\nhigh-pass filter reduces the volume of frequency components that are\nbelow a certain level.  The band-pass filter reduces the volume of\nfrequency components on both sides of the chosen frequency, thereby\nenhancing that frequency.  Finally, the high-pass and low-pass filters\ncan be combined to form a notch reject filter, which reduces the\nfolume of the frequency components nearest the selected frequency.\nThese various filters can dramatically change the quality of the sound\nproduced.\n\nThe first two registers are used to select the filter cutoff\nfrequency.  This is the frequency above or below which any sounds will\nbe made quieter.  The further away from this level any frequency\ncomponents are, the more their output volume will be suppresed (high-\nand low-pass filters reduce the volume of those components by 12 dB\nper octave away from the center frequency, while the band-pass filter\nattenuates them by 6 dB per octave).\n\nThe cutoff frequency has an 11-bit range (which corresponds to the\nnumbers 0 to 2047).  This is made up of a high-byte and three low\nbits.  Therefore, to compute the frequency represented by the value in\nthese registers, you must multiply the value in the high byte by 8,\nand add the value of the low three bits.  The range of cutoff\nfreqnencies represented by these 2048 values stretches from 30 Hz to\nabout 12,000 Hz.  The exact frequency may be calculated with the\nformula:\n\nFREQUENCY=(REGISTER VALUE*5.8)+30Hz\n\nAn additional element in filtering is the resonance control.  This\nallows you to peak the volume of the frequency elements nearest the\ncutoff frequency."}, {"id": "map-D415", "address_start": 54293, "address_end": 54293, "hex_start": "$D415", "hex_end": "$D415", "label": "CUTLO", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54293         $D415          CUTLO\n\nBits 0-2:  Low portion of filter cutoff frequency\nBits 5-7:  Unused"}, {"id": "map-D416", "address_start": 54294, "address_end": 54294, "hex_start": "$D416", "hex_end": "$D416", "label": "CUTHI", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54294         $D416          CUTHI\nFilter Cutoff Frequency (high byte)"}, {"id": "map-D417", "address_start": 54295, "address_end": 54295, "hex_start": "$D417", "hex_end": "$D417", "label": "RESON", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54295         $D417          RESON\nFilter Resonance Control Register\n\nBit 0:  Filter the output of voice 1?  1=yes\nBit 1:  Filter the output of voice 2?  1=yes\nBit 2:  Filter the output of voice 3?  1=yes\nBit 3:  Filter the output from the external input?  1=yes\nBits 4-7:  Select filter resonance 0-15\n\nBits 0-3 are used to control which of the voices will be altered by\nthe filters.  If one of these bits is set to 1, the corresponding\nvoice will be processed through the filter, and its harmonic content\nwill be changed accordingly.  If the bit is set to 0, the voice will\npass directly to the audio output.  Note that there is also a\nprovision for processing an external audio signal which is brought\nthrough pin 5 of the Audio/Video Port.\n\nBits 4-7 control the resonance of the filter.  By placing a number\nfrom 0 to 15 in these four bits, you may peak the volume of those\nfrequencies nearest the cutoff.  This creates an even sharper\nfiltering effect.  A setting of 0 causes no resonance, while a setting\nof 15 gives maximum resonance."}, {"id": "map-D418", "address_start": 54296, "address_end": 54296, "hex_start": "$D418", "hex_end": "$D418", "label": "SIGVOL", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54296         $D418          SIGVOL\nVolume and Filter Select Register\n\nBits 0-3:  Select output volume (0-15)\nBit 4:  Select low-pass filter, 1=low-pass on\nBit 5:  Select band-pass filter, 1=band-pass on\nBit 6:  Select high-pass filter, 1=high-pass on\nBit 7:  Disconnect output of voice 4, 1=voice 3 off\n\nBits 0-3 control the volume of all outputs.  The possible volume\nlevels range from 0 (no volume) to 15 (maximum volume).  Some level of\nvolume must be set here before any sound can be heard.\n\nBits 4-6 control the selection of the low-pass, band-pass, or\nhigh-pass filter.  A 1 in any of these bits turns the corresponding\nfilter on.  These filters can be combined, although only one cutoff\nfrequency can be chosen.  In order for the filter to have any effect,\nat least one of the voices must be routed through it using the Filter\nResonance Control Register at 54295 ($D417).\n\nWhen Bit 7 is set to 1,  it disconnects the output of voice 3.  This\nallows you to use the output of the oscillator for modulating the\nfrequency of the other voices, or for generating random number,\nwithout any undesired audio output."}, {"id": "map-D419-D41A", "address_start": 54297, "address_end": 54298, "hex_start": "$D419", "hex_end": "$D41A", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 54297-54298 ($D419-$D41A)\nGame Paddle Inputs\n\nThese registers allow you to read the game paddles that plug into\njoystick Controller Ports 1 and 2.  Each paddle uses a variable\nresistor (also known as a potentiometer or pot), whose resistance is\ncontrolled by turning a knob.  The varying resistance is used to vary\nthe voltage to two pins of the SID chip between 0 and +5 volts.\nAnalog-to-digital (A/D) converters in the chip interpret these voltage\nlevels as binary values and store the values in these registers.\nThese registers return a number from 0 (minumum resistance) to 255\n(maximum resistance) for each paddle in either of the ports, depending\non the position of the paddle knob.\n\nSince these registers will read the paddle values for only one\ncontroller port, there is a switching mechanism which allows you to\nselect which of the two ports to read.  By writing a bit-pair of 01\n(bit value of 64) to the last two bits of CIA #1 Data Port A (56320,\n$DC00), you select the paddles on joystick Controller Port 1.  By\nwriting a bit-pair of 10 (bit value of 128), you select the paddles on\nController Port 2.\n\nIf you look at the description of Data Port A (56320, $DC00), however,\nyou will notice that it is also used in the keyboard scanning process.\nBy writing to this port, you determine which keyboard column will be\nread.\n\nSince the IRQ interrupt keyboard scan routine and the routine that\nchecks for the STOP key are putting values into this location 60 times\nper second, you cannot reliable select the pair of paddles you wish to\nread from BASIC without first turning off the keyboard IRQ.  This can\nbe done with a POKE 56333,127.  You can then read the paddles with the\nstatements A=PEEK(54297) and B=PEEK(54298).  The IRQ can be restored\nafter a paddle read with a POKE 56333,129.  It may, however, be easier\nand more accurate in the long run to use a machine language paddle\nread subroutine such as that presented on page 347 of the Commodore 64\nProgrammer's Reference Guide.\n\nThe paddle fire buttons are read as Bits 2 and 3 of the Data Ports A\n(56320, $DC00) and B (56321, $DC01).  On Port A, if Bit 2 is set to 0,\nbutton 1 is pushed, and if Bit 3 is set to 0, button 2 is pushed.  On\nPort B, if Bit 2 is set to 0, button 3 is pushed, and if Bit 3 is set\nto 0, button 4 is pushed.\n\nThe BASIC statements to test these buttons, thereore, are:\n\nPB(1)=(PEEK(56321)AND4)/4\nPB(2)=(PEEK(56321)AND8)/8\nPB(3)=(PEEK(56320)AND4)/4\nPB(4)=(PEEK(56320)AND8)/8\n\nIf a 0 is returned by the PEEK statement, the button is pushed, and if\na 1 is returned, it is not."}, {"id": "map-D419", "address_start": 54297, "address_end": 54297, "hex_start": "$D419", "hex_end": "$D419", "label": "POTX", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54297         $D419          POTX\nRead Game Paddle 1 (or 3) Position"}, {"id": "map-D41A", "address_start": 54298, "address_end": 54298, "hex_start": "$D41A", "hex_end": "$D41A", "label": "POTY", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54298         $D41A          POTY\nRead Game Paddle 2 (or 4) Position"}, {"id": "map-D41B", "address_start": 54299, "address_end": 54299, "hex_start": "$D41B", "hex_end": "$D41B", "label": "RANDOM", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54299         $D41B          RANDOM\nRead Oscillator 3/Random Number Generator\n\nThis register lets you read the upper eight bits of the waveform\noutput of Oscillator 3.  The kinds of numbers generated by this output\ndepend on the type of waveform selected.\n\nIf the sawtooth waveform is chosen, the output read by this register\nwill be a series of numbers which start at 0 and increase by 1 to a\nmaximum of 255, at which time they start over at 0.\n\nWhen the triangle waveform is chosen, they increase from 0 to 255, at\nwhich time they decrease to 0 again.  The rate at which these numbers\nchange is determined by the frequency of Oscillator 3.\n\nIf the pulse waveform is selected, the output here will be either 255\nor 0.\n\nFinally, selecting the noise waveform will produce a random series of\nnumbers between 0 and 255.  This allows you to use the register as a\nrandom number generator for games.\n\nThere are many other uses for reading Oscillator 3, however,\nparticularly for modulation of the other voices through machine\nlanguage software.  For example, the output of this register could be\nadded to the frequency of another voice.  If the triangle waveform\nwere selected for this purpose, it would cause the frequency of the\nother voice to rise and fall, at the frequency of Oscillator 3\n(perhaps for vibrato effects).  This output can also be combined with\nthe Filter Frequency or Pulse Width Registers to vary the values in\nthese registers quickly over a short period of time.\n\nNormally, when using Oscillator 3 for modulation, the audio output of\nvoice 3 should be turned off by setting Bit 7 of the Volume and Filter\nSelect Register at 54296 ($d418) to 1.  It is not necessary to gate\nBit 0 of Control Register 3 to use the oscillator, however, as its\noutput is not affected by the ADSR envelope cycle."}, {"id": "map-D41C", "address_start": 54300, "address_end": 54300, "hex_start": "$D41C", "hex_end": "$D41C", "label": "ENV3", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54300         $D41C          ENV3\nEnvelope Generator 3 Output\n\nThis register allows you to read the output of the voice 3 Envelope\ngenerator, in much the same way that the preceding register lets you\nread the output of Oscillator 3.  This output can also be added to\nanother oscillator's Frequency Control Registers, Pulse Width\nRegisters, or the Filter Frequency Control Register.  In order to\nproduce any output from this register, however, the gate bit in\nControl Register 3 must be set to 1.  Just as in the production of\nsound, setting the gate bit to 1 starts the attack/decay/sustain\ncycle, and setting it back to 0 starts the release cycle."}, {"id": "map-D41D-D41F", "address_start": 54301, "address_end": 54303, "hex_start": "$D41D", "hex_end": "$D41F", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 54301-54303 ($D41D-$D41F)\nNot Connected\n\nThe SID chip has been provided with enough addresses for 32 different\nregisters, but as it has only 29, the remaining three addresses are\nnot used.  Reading them will always return a value of 255 ($FF), and\nwriting to them will have no effect."}, {"id": "map-D420-D7FF", "address_start": 54304, "address_end": 55295, "hex_start": "$D420", "hex_end": "$D7FF", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 54304-55295 ($D420-$D7FF)\nSID Register Images\n\nSince the SID chip requires enough addressing lines for only 32\nlocations (the minimum possible for its 29 registers), none of the\nhigher bits are decoded when addressing the 1K area that has been\nassigned to it.  The result is that every 32-byte area in this 1K\nblock is a mirror of every other.  For the sake of clarity in your\nprograms, it is advisable not to use these addresses at all."}, {"id": "map-D800-DBFF", "address_start": 55296, "address_end": 56319, "hex_start": "$D800", "hex_end": "$DBFF", "label": "", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "55296-56319   $D800-$DBFF\nColor RAM\n\nThe normal Commodore 64 text graphics system uses a screen RAM area to\nkeep track of the character shapes that are to be displayed.  But\nsince each character can be displayed in any of 16 foreground colors,\nthere must also be a parallel area which keeps track of the foreground\ncolor.  This 1024-byte area is used for that purpose (actually, since\nthere are only 1000 screen positions, only 1000 byte actually affect\nscreen color).\n\nThese 1000 bytes each control the foreground color of one character,\nwith the first byte controlling the foreground color of the character\nin the upper- left corner, and subsequent bytes controlling the\ncharacters to the right and below that character.\n\nBecause only four bits are needed to represent the 16 colors\navailable, only the low four bits of each Color RAM location are\nconnected (this is why they are sometimes referred to as Color RAM\nNybbles).  Writing to the high bits will not affect them, and these\nfour bits will usually return a random value when read (a small number\nof 64s return a constant value).\n\nTherefore, in order to read Color RAM correctly, you must mask out the\ntop bits by using the logical AND function.  In BASIC, you can read\nthe first byte of Color RAM with the statement CR=PEEK(55296)AND15.\nThis will always return a color value between 0 and 15.  These color\nvalues correspond to the following colors:\n\n 0 = BLACK\n 1 = WHITE\n 2 = RED\n 3 = CYAN (LIGHT BLUE-GREEN)\n 4 = PURPLE\n 5 = GREEN\n 6 = BLUE\n 7 = YELLOW\n 8 = ORANGE\n 9 = BROWN\n10 = LIGHT RED\n11 = DARK GRAY\n12 = MEDIUM GRAY\n13 = LIGHT GREEN\n14 = LIGHT BLUE\n15 = LIGHT GRAY\n\nColor mapping affords a convenient method of changing the color of the\ntext display without changing the letters.  By POKEing the appropriate\nsection of Color RAM, you can change the color of a whole section of\ntext on the screen without affecting the content of the text.  You can\neven use this method to make letters disappear by changing their\nforeground colors to match the background (or by changing the\nbackground to match the foreground), and later make them reappear by\nchanging them back, or by changing the background to a contrasting\ncolor.  An interesting example program which changes Color RAM quickly\nin BASIC can be found under the entry for 648 ($288).\n\nA change in the Operating System causes newer 64s to set all of the\nColor RAM locations to the same value as the current background color\nwhenever the screen is cleared.  Therefore, POKEing character codes to\nthe Screen RAM area will not appear to have any effect, because the\nletters will be the same color as the background.  This can easily be\nturned to your advantage, however, because it means that all you have\nto do to set all of Color RAM to a particular value is to set the\nbackground color to that value (using the register at 53281 ($D021)),\nclear the screen, and return the background color in the desired\nvalue.\n\nThe various garphics modes use this area differently than does the\nregular text mode.  In high-resolution bitmap mode, this area is not\nused at all, but in multicolor bitmap mode it is used to determine the\ncolor of the 11 bit-pair for a given 8 by 8 dot area.\n\nIn multicolor text mode, only the lowest three bits are used, so only\ncolors 0-7 may be selected.  The fourth bit is used to determine\nwhether a character will be displayed in regular text or multicolor\ntext.  Characters with a color value over 7 are displayed as\nmulticolor characters, with the color of the 11 bit-pair determined by\nthe color value minus 8.  Characters with a color value under 8 are\ndisplayed normally.\n\nIt should be noted that unlike the Screen RAM area, which can be moved\nto any RAM location, the Color RAM area is fixed, and will function\nnormally regardless of where screen memory is located."}, {"id": "map-DC00-DC0F", "address_start": 56320, "address_end": 56335, "hex_start": "$DC00", "hex_end": "$DC0F", "label": "", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56320-56335   $DC00-$DC0F\nComplex Interface Adapter (CIA) #1 Registers\n\nLocations 56320-56335 ($DC00-$DC0F) are used to communicate with the\nComplex Interface Adapter chip #1 (CIA #1).  This chip is a successor\nto the earlier VIA and PIA devices used on the VIC-20 and PET.  This\nchip functions the same way as the VIA and PIA:  It allows the 6510\nmicroprocessor to communicate with peripheral input and output\ndevices.  The specific devices that CIA #1 reads data from and sends\ndata to are the joystick controllers, the paddle fire buttons, and the\nkeyboard.\n\nIn addition to its two data ports, CIA #1 has two timers, each of\nwhich can count an interval from a millionth of a second to a\nfifteenth of a second.  Or the timers can be hooked together to count\nmuch longer intervals.  CIA #1 has an interrupt line which is\nconnected to the 6510 IRQ line.  These two timers can be used to\ngenerate interrupts at specified intervals (such as the 1/60 second\ninterrupt used for keyboard scanning, or the more complexly timed\ninterrupts that drive the tape read and write routines).  As you will\nsee below, the CIA chip has a host of other features to aid in\nInput/Output functions."}, {"id": "map-DC00-DC01", "address_start": 56320, "address_end": 56321, "hex_start": "$DC00", "hex_end": "$DC01", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56320-56321 ($DC00-$DC01)\nCIA #1 Data Ports A and B\n\nThese registers are where the actual communication with outside\ndevices takes place.  Bits of data written to these registers can be\nsent to external devices, while bits of data that those devices send\ncan be read here.\n\nThe keyboard is so necessary to the computer's operation that you may\nhave a hard time thinking of it as a peripheral device.  Nonetheless,\nit cannot be directly read by the 6510 microprocessor.  Instead, the\nkeys are connected in a matrix of eight rows by eight columns to CIA\n#1 Ports A and B.  The layout of this matrix is shown below.\n\nWRITE TO PORT A               READ PORT B (56321, $DC01)\n56320/$DC00\n         Bit 7   Bit 6   Bit 5   Bit 4   Bit 3   Bit 2   Bit 1   Bit 0\n\nBit 7    STOP    Q       C=      SPACE   2       CTRL    <-      1\n\nBit 6    /       ^       =       RSHIFT  HOME    ;       *       LIRA\n\nBit 5    ,       @       :       .       -       L       P       +\n\nBit 4    N       O       K       M       0       J       I       9\n\nBit 3    V       U       H       B       8       G       Y       7\n\nBit 2    X       T       F       C       6       D       R       5\n\nBit 1    LSHIFT  E       S       Z       4       A       W       3\n\nBit 0    CRSR DN F5      F3      F1      F7      CRSR RT RETURN  DELETE\n\nAs you can see, there are two keys which do not appear in the matrix.\nThe SHIFT LOCK key is not read as a separate key, but rather is a\nmechanical device which holds the left SHIFT key switch in a closed\nposition.  The RESTORE key is not read like the other keys either.  It\nis directly connected to the NMI interrupt line of the 6510\nmicroprocessor, and causes an NMI interrupt to occur whenever it is\npressed (not just when it is pressed with the STOP key).\n\nIn order to read the individual keys in the matrix, you must first set\nPort A for all outputs (255, $FF), and Port B for all inputs (0),\nusing the Data Direction Registers.  Note that this is the default\ncondition.  Next, you must write a 0 in the bit of Data Port A that\ncorresponds to the column that you wish to read, and a 1 to the bits\nthat correspond to columns you wish to ignore.  You will then be able\nto read Data Port B to see which keys in that column are being pushed.\n\nA 0 in any bit position signifies that the key in the corresponding\nrow of the selected column is being pressed, while a 1 indicates that\nthe key is not being pressed.  A value of 255 ($FF) means that no keys\nin that column are being pressed.\n\nFortunately for us all, an interrupt routine causes the keyboard to be\nread, and the results are made available to the Operating System\nautomatically every 1/60 second.  And even when the normal interrupt\nroutine cannot be used, you can use the Kernal SCNKEY routine at 65439\n($FF9F) to read the keyboard.\n\nThese same data ports are also used to read the joystick controllers.\nAlthough common sense might lead you to believe that you could read\nthe joystick that is plugged into the port marked Controller Port 1\nfrom Data Port A, and the second joystick from Data Port B, there is\nnothing common about the Commodore 64.  Controller Port 1 is read from\nData Port B, and Controller Port 2 is read from CIA #1 Data Port A.\n\nJoysticks consist of five switches, one each for up, down, right, and\nleft directions, and another for the fire button.  The switches are\nread like the key switches--if the switch is pressed, the\ncorresponding bit will read 0, and if it is not pressed, the bit will\nbe set to 1.  From BASIC, you can PEEK the ports and use the AND and\nNOT operators to mask the unused bits and inverse the logic for easier\ncomprehension.  For example, to read the joystick in Controller Port\n1, you could use the statement:\n\nS1=NOT PEEK(56321)AND15\n\nThe meaning of the possible numbers returned are:\n\n 0 = none pressed\n 1 = up\n 2 = down\n 4 = left\n 5 = up left\n 6 = down left\n 8 = right\n 9 = up right\n10 = down right\n\nThe same technique can be used for joystick 2, by substituting 56320\nas the number to PEEK.  By the way, the 3 and 7 aren't listed because\nthey represent impossible combinations like up-down.\n\nTo read the fire buttons, you can PEEK the appropriate port and use\nthe AND operator to mask all but bit 4:\n\nT1=(PEEK(56321)AND16)/16\n\nThe above will return a 0 if the button is pressed, and a 1 if it is\nnot.  Substitute location 56320 as the location to PEEK for Trigger\nButton 2.\n\nSince CIA #1 Data Port B is used for reading the keyboard as well as\njoystick 1, some confusion can result.  The routine that checks the\nkeyboard has no way of telling whether a particular bit was set to 0\nby a keypress or one of the joystick switches.  For example, if you\nplug the joystick into Controller Port 1 and push the stick to the\nright, the routine will interpret this as the 2 key being pressed,\nbecause both set the same bit to 0.  Likewise, when you read the\njoystick, it will register as being pushed to the right if the 2 key\nis being pressed.\n\nThe problem of mistaking the keyboard for the joystick can be solved\nby turning off the keyscan momentarily when reading the stick with a\nPOKE 56333, 127:POKE 56320,255, and restoring it after the read with a\nPOKE 56333,129.  Sometimes you can use the simpler solution of\nclearing the keyboard buffer after reading the joystick, with a POKE\n198,0.\n\nThe problem of mistaking the joystick for a keypress is much more\ndifficult--there is no real way to turn off the joystick.  Many\ncommercially available games just use Controller Port 2 to avoid the\nconflict.  So, if you can't beat them, sit back and press your\njoystick to the left in order to slow down a program listing (the\nkeyscan routine thinks that it is the CTRL key).\n\nAs if all of the above were not enough, Port A is also used to control\nwhich set of paddles is read by the SID chip, and to read the paddle\nfire buttons.  Since there are two paddles per joystick Controller\nPort, and only two SID registers for reading paddle positions, there\nhas to be a method for switching the paddle read from joystick Port 1\nto joystick Port 2.\n\nWhen Bit 7 of Port A is set to 1 and Bit 6 is cleared to 0, the SID\nregisters will read the paddles on Port 1.  When Bit 7 is set to 0 and\nBit 6 is set to 1, the paddles on Port 2 are read by the SID chip\nregisters.  Note that this also conflicts with the keyscan routine,\nwhich is constantly writing different values to CIA #1 Data Port A in\norder to select the keyboard column to read (most of the time, the\nvalue for the last column is written to this port, which coincides\nwith the selection of paddles on joystick Port 1).  Therefore, in\norder to get an accurate reading, you must turn off the keyscan IRQ\nand select which joystick port you want to read.  See POTX at 54297\n($D419), which is the SID register where the paddles are read, for the\nexact technique.\n\nAlthough the SID chip is used to read the paddle settings, the fire\nbuttons are read at CIA #1 Data Ports A and B.  The fire buttons for\nthe paddles plugged into Controller Port 1 are read at Data Port B\n(56321, $DC01), while those for the paddles plugged into Controller\nPort 2 are read from Data Port A (56320, $DC00).  The fire buttons are\nread at Bit 2 and Bit 3 of each port (the same as the joystick left\nand joystick right switches), and as usual, the bit will read 0 if the\ncorresponding button is pushed, and 1 if it is not.\n\nAlthough only two of the rout paddle values can be read at any one\ntime, you can always read all four paddle buttons.  See the game\npaddle input description at 54297 ($D419) for the BASIC statements\nused to read these buttons.\n\nFinally, Data Port B can also be used as an output by either Timer A\nor B.  It is possible to set a mode in which the timers do not cause\nan interrupt when they run down (see the descriptions of Control\nRegisters A and B at 56334-5 ($DC0E-F)).  Instead, they cause the\noutput on Bit 6 or 7 of Data Port B to change.  Timer A can be set\neither to pulse the output of Bit 6 for one machine cycle, or to\ntoggle that bit from 1 to 0 or 0 to 1.  Timer B can use Bit 7 of this\nregister for the same purpose."}, {"id": "map-DC00", "address_start": 56320, "address_end": 56320, "hex_start": "$DC00", "hex_end": "$DC00", "label": "CIAPRA", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56320         $DC00          CIAPRA\nData Port Register A\n\nBit 0:  Select to read keyboard column 0\n        Read joystick 2 up direction\nBit 1:  Select to read keyboard column 1\n        Read joystick 2 down direction\nBit 2:  Select to read keyboard column 2\n        Read joystick 2 left direction\n        Read paddle 1 fire button\nBit 3:  Select to read keyboard column 3\n        Read joystick 2 right direction\n        Read paddle 2 fire button\nBit 4:  Select to read keyboard column 4\n        Read joystick 2 fire button\nBit 5:  Select to read keyboard column 5\nBit 6:  Select to read keyboard column 6\n        Select to read paddles on Port A or B\nBit 7:  Select to read keyboard column 7\n        Select to read paddles on Port A or B"}, {"id": "map-DC01", "address_start": 56321, "address_end": 56321, "hex_start": "$DC01", "hex_end": "$DC01", "label": "CIAPRB", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56321         $DC01          CIAPRB\nData Port Register B\n\nBit 0:  Read keyboard row 0\n        Read joystick 1 up direction\nBit 1:  Read keyboard row 1\n        Read joystick 1 down direction\nBit 2:  Read keyboard row 2\n        Read joystick 1 left direction\n        Read paddle 1 fire button\nBit 3:  Read keyboard row 3\n        Read joystick 1 right direction\n        Read paddle 2 fire button\nBit 4:  Read keyboard row 4\n        Read joystick 1 fire button\nBit 5:  Read keyboard row 5\nBit 6:  Read keyboard row 6\n        Toggle or pulse data output for Timer A\nBit 7:  Read keyboard row 7\n        Toggle or pulse data output for Timer B"}, {"id": "map-DC02-DC03", "address_start": 56322, "address_end": 56323, "hex_start": "$DC02", "hex_end": "$DC03", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56322-56323 ($DC02-$DC03)\nCIA #1 Data Direction Registers A and B\n\nThese Data Direction Registers control the direction of data flow over\nData Ports A and B.  Each bit controls the direction of the data on\nthe corresponding bit of the port.  If teh bit of the Direction\nRegister is set to a 1, the corresponding Data Port bit will be used\nfor data output.  If the bit is set to a 0, the corresponding Data\nPort bit will be used for data input.  For example, Bit 7 of Data\nDirection Register A controls Bit 7 of Data Port A, and if that\ndirection bit is set to 0, Bit 7 of Data Port A will be used for data\ninput.  If the direction bit is set to 1, however, data Bit 7 on Port\nA will be used for data output.\n\nThe default setting for Data Direction Register A is 255 (all\noutputs), and for Data Direction Register B it is 0 (all inputs).\nThis corresponds to the setting used when reading the keyboard (the\nkeyboard column number is written to Data Port A, and the row number\nis then read in Data Port B)."}, {"id": "map-DC02", "address_start": 56322, "address_end": 56322, "hex_start": "$DC02", "hex_end": "$DC02", "label": "CIDDRA", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56322         $DC02          CIDDRA\nData Direction Register A\n\nBit 0:  Select Bit 0 of Data Port A for input or output (0=input, 1=output)\nBit 1:  Select Bit 1 of Data Port A for input or output (0=input, 1=output)\nBit 2:  Select Bit 2 of Data Port A for input or output (0=input, 1=output)\nBit 3:  Select Bit 3 of Data Port A for input or output (0=input, 1=output)\nBit 4:  Select Bit 4 of Data Port A for input or output (0=input, 1=output)\nBit 5:  Select Bit 5 of Data Port A for input or output (0=input, 1=output)\nBit 6:  Select Bit 6 of Data Port A for input or output (0=input, 1=output)\nBit 7:  Select Bit 7 of Data Port A for input or output (0=input, 1=output)"}, {"id": "map-DC03", "address_start": 56323, "address_end": 56323, "hex_start": "$DC03", "hex_end": "$DC03", "label": "CIDDRB", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56323         $DC03          CIDDRB\nData Direction Register B\n\nBit 0:  Select Bit 0 of Data Port B for input or output (0=input, 1=output)\nBit 1:  Select Bit 1 of Data Port B for input or output (0=input, 1=output)\nBit 2:  Select Bit 2 of Data Port B for input or output (0=input, 1=output)\nBit 3:  Select Bit 3 of Data Port B for input or output (0=input, 1=output)\nBit 4:  Select Bit 4 of Data Port B for input or output (0=input, 1=output)\nBit 5:  Select Bit 5 of Data Port B for input or output (0=input, 1=output)\nBit 6:  Select Bit 6 of Data Port B for input or output (0=input, 1=output)\nBit 7:  Select Bit 7 of Data Port B for input or output (0=input, 1=output)"}, {"id": "map-DC04-DC07", "address_start": 56324, "address_end": 56327, "hex_start": "$DC04", "hex_end": "$DC07", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56324-56327 ($DC04-$DC07)\nTimers A and B Low and High Bytes\n\nThese four timer registers (two for each timer) have different\nfunctions depending on whether you are reading from them or writing to\nthem.  When you read from these registers, you get the present value\nof the Timer Counter (which counts down from its initial value to 0).\nWhen you write data to these registers, it is stored in the Timer\nLatch, and from there it can be used to load the Timer Counter using\nthe Force Load bit of Control Register A or B (see 56334-5 ($DC0E-F)\nbelow).\n\nThese interval timers can hold a 16-bit number from 0 to 65535, in\nnormal 6510 low-byte, high-byte format (VALUE=LOW BYTE+256*HIGH BYTE).\nOnce the Timer Counter is set to an initial value, and the timer is\nstarted, the timer will count down one number every microprocessor\nclock cycle.  Since the clock speed of the 64 (using the American NTSC\ntelevision standard) is 1,022,730 cycles per second, every count takes\napproximately a millionth of a second.  The formula for calculating\nthe amount of time it will take for the timer to count down from its\nlatch value to 0 is:\n\nTIME=LATCH VALUE/CLOCK SPEED\n\nwhere LATCH VALUE is the value written to the low and high timer\nregisters (LATCH VALUE=TIMER LOW+256*TIMER HIGH), and CLOCK SPEED is\n1,022,370 cycles per second for American (NTSC) standard television\nmonitors, or 985,250 for European (PAL) monitors.\n\nWhen Timer Counter A or B gets to 0, it will set Bit 0 or 1 in the\nInterrupt Control Register at 56333 ($DC0D).  If the timer interrupt\nhas been enabled (see 56333 ($DC0D)), an IRQ will take place, and the\nhigh bit of the Interrupt Control Register will be set to 1.\nAlternately, if the Port B output bit is set, the timer will write\ndata to Bit 6 or 7 of Port B.  After the timer gets to 0, it will\nreload the Timer Latch Value, and either stop or count down again,\ndepending on whether it is in one-shot or continuous mode (determined\nby Bit 3 of the Control Register).\n\nAlthough usually a timer will be used to count the microprocessor\ncycles, Timer A can count either the microprocessor clock cycles or\nexternal pulses on the CTN line, which is connected to pin 4 of the\nUser Port.\n\nTimer B is even more versatile.  In addition to these two sources,\nTimer B can count the number of times that Timer A goes to 0.  By\nsetting Timer A to count the microprocessor clock, and setting Timer B\nto count the number of times that Timer A zeros, you effectively link\nthe two timers into one 32-bit timer that can count up to 70 minutes\nwith accuracy within 1/15 second.\n\nIn the 64, CIA #1 Timer A is used to generate the interrupt which\ndrives the routine for reading the keyboard and updating the software\nclock.  Both Timers A and B are also used for the timing of the\nroutines that read and write tape data.  Normally, Timer A is set for\ncontinuous operation, and latched with a value of 149 in the low byte\nand 66 in the high byte, for a total Latch Value of 17045.  This means\nthat it is set to count to 0 every 17045/1022730 seconds, or\napproximately 1/60 second.\n\nFor tape reads and writes, the tape routines take over the IRQ\nvectors.  Even though the tape write routines use the on-chip I/O port\nat location 1 for the actual data output to the cassette, reading and\nwriting to the cassette uses both CIA #1 Timer A and Timer B for\ntiming the I/O routines."}, {"id": "map-DC04", "address_start": 56324, "address_end": 56324, "hex_start": "$DC04", "hex_end": "$DC04", "label": "TIMALO", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56324         $DC04          TIMALO\nTimer A (low byte)"}, {"id": "map-DC05", "address_start": 56325, "address_end": 56325, "hex_start": "$DC05", "hex_end": "$DC05", "label": "TIMAHI", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56325         $DC05          TIMAHI\nTimer A (high byte)"}, {"id": "map-DC06", "address_start": 56326, "address_end": 56326, "hex_start": "$DC06", "hex_end": "$DC06", "label": "TIMBLO", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56326         $DC06          TIMBLO\nTimer B (low byte)"}, {"id": "map-DC07", "address_start": 56327, "address_end": 56327, "hex_start": "$DC07", "hex_end": "$DC07", "label": "TIMBHI", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56327         $DC07          TIMBHI\nTimer B (high byte)"}, {"id": "map-DC08-DC0B", "address_start": 56328, "address_end": 56331, "hex_start": "$DC08", "hex_end": "$DC0B", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 56328-56331 ($DC08-$DC0B)\nTime of Day Clock (TOD)\n\nIn addition to the two general-purpose timers, the 6526 CIA chip has a\nspecial-purpose Time of Day Clock, which keeps time in a format that\nhumans can understand a little more easily than microseconds.\n\nThis Time of Day Clock even has an alarm, which can cause an interrupt\nat a specific time.  It is organized in four registers, one each for\nhours, minutes, seconds, and tenths of seconds.  Each register reads\nout in Binary Coded Decimal (BCD) format, for easier conversion to\nASCII digits.  A BCD byte is divided into two nybbles, each of which\nrepresents a single digit in base 10.  Even though a four-bit nybble\ncan hold a number from 0 to 15, only the base 10 digits of 0-9 are\nused.  Therefore, 10 0'clock would be represented by a byte in the\nhours register with the nybbles 0001 and 0000, which stand for the\ndigits 1 and 0.  The binary value of this byte would be 16 (16 times\nthe high nybble plus the low nybble).  Each of the other registers\noperates in the same manner.  In addition, Bit 7 of the hours register\nis used as an AM/PM flag.  If that bit is set to 1, it indicates PM,\nand if it is set to 0, the time is AM.\n\nThe Time of Day Clock Registers can be used for two purposes,\ndepending on whether you are reading them or writing to them.  If you\nare reading them, you will always be reading the time.  There is a\nlatching feature associated with reading the hours register in order\nto solve the problem of the time changing while you are reading the\nregisters.  For example, if you were reading the hours register just\nas the time was changing from 10:59 to 11:00, it is possible that you\nwould read the 10 in the hours register, and by the time you read the\nminutes register it would have changed from 59 to 00.  Therefore, you\nwould read 10:00 instead of either 10:59 or 11:00.\n\nTo prevent this kind of mistake, the Time of Day Clock Registers stop\nupdating as soon as you read the hours register, and do not start\nagain until you read the tenths of seconds register.  Of course, the\nclock continues to keep time internally even though it does not update\nthe registers.  If you want to read only minutes, or seconds or tenths\nof seconds, there is no problem, and no latching will occur.  But\nanytime you read hours, you must follow it by reading tenths of\nseconds, even if you don't care about them, or else the registers will\nnot continue to update.\n\nWriting to these registers either sets the time or the alarm,\ndepending on the setting of Bit 7 of Control Register B (56335,\n$DC0F).  If that bit is set to 1, writing to the Time of Day registers\nsets the alarm.  If the bit is set to 0, writing to the Time of Day\nregisters sets the Time of Day clock.  In either case, as with reading\nthe registers, there is a latch function.  This function stops the\nclock from updating when you write to the hours register.  The clock\nwill not start again until you write to the tenths of seconds\nregisters.\n\nThe only apparent use of the Time of Day Clock by the 64's Operating\nSystem is in the BASIC RND statement.  There, the seconds and tenths\nof seconds registers are read and their values used as part of the\nseed value for the RND(0) command.\n\nNonetheless, this clock can be an invaluable resource for the 64 user.\nIt will keep time more accurately than the software clock maintained\nat locations 60-162 ($A0-$A2) by the Timer A interrupt routine.  And\nunlike that software clock, the Time of Day Clock will not be\ndisturbed when I/O operations disrupt the Timer A IRQ, or when the IRQ\nvector is diverted elsewhere.  Not even a cold start RESET will\ndisrupt the time.  For game timers, just set the time for 00:00:00:0\nand it will keep track of elapsed time in hours, minutes, seconds and\ntenths of seconds format.\n\nThe following digital clock program, written in BASIC, will\ndemonstrate the use of these timers:\n\n10 PRINT CHR$(147):GOSUB 200\n20 H=PEEK(56331):POKE 1238,(H AND 16)/16+48:POKE 1239,(H AND 15)+48\n30 M=PEEK(56330):POKE 1241,(M AND 240)/16+48:POKE 1242,(M AND 15)+48\n40 S=PEEK(56329):POKE 1244,(S AND 240)/16+48:POKE 1245,(S AND 15)+48\n50 T=PEEK(56328)AND15:POKE 1247,T+48:GOTO 20\n200 INPUT\"WHAT IS THE HOUR\";H$:IF H$=\"\" THEN 200\n210 H=0:IF LEN(H$)>1 THEN H=16\n220 HH=VAL(RIGHT$(H$,1)):H=H+HH:POKE56331,H\n230 INPUT \"WHAT IS THE MINUTE\";M$:IF M$=\"\"THEN 200\n240 M=0:IF LEN(M$)>1 THEN M=16*VAL(LEFT$(M$,1))\n250 MM=VAL(RIGHT$(M$,1)):M=M+MM:POKE56330,M\n260 INPUT \"WHAT IS THE SECOND\";S$:IF S$=\"\"THEN 200\n270 S=0:IF LEN(S$)>1 THEN S=16*VAL(LEFT$(S$,1))\n280 SS=VAL(RIGHT$(S$,1)):S=S+SS:POKE56329,S:POKE56328,0\n290 POKE 53281,1:PRINT CHR$(147):POKE 53281,6\n300 POKE 1240,58:POKE 1243,58:POKE 1246,58:GOTO 20"}, {"id": "map-DC08", "address_start": 56328, "address_end": 56328, "hex_start": "$DC08", "hex_end": "$DC08", "label": "TODTEN", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56328         $DC08          TODTEN\nTime of Day Clock Tenths of Seconds\n\nBits 0-3:  Time of Day tenths of second digit (BCD)\nBits 4-7:  Unused"}, {"id": "map-DC09", "address_start": 56329, "address_end": 56329, "hex_start": "$DC09", "hex_end": "$DC09", "label": "TODSEC", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56329         $DC09          TODSEC\nTime of Day Clock Seconds\n\nBits 0-3:  Second digit of Time of Day seconds (BCD)\nBits 4-6:  First digit of Time of Day seconds (BCD)\nBit 7:  Unused"}, {"id": "map-DC0A", "address_start": 56330, "address_end": 56330, "hex_start": "$DC0A", "hex_end": "$DC0A", "label": "TODMIN", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56330         $DC0A          TODMIN\nTime of Day Clock Minutes\n\nBits 0-3:  Second digit of Time of Day minutes (BCD)\nBits 4-6:  First digit of Time of Day minutes (BCD)\nBit 7:  Unused"}, {"id": "map-DC0B", "address_start": 56331, "address_end": 56331, "hex_start": "$DC0B", "hex_end": "$DC0B", "label": "TODHRS", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "56331         $DC0B          TODHRS\nTime of Day Clock Hours\n\nBits 0-3:  Second digit of Time of Day hours (BCD)\nBit 4:  First digit of Time of Day hours (BCD)\nBits 5-6:  Unused\nBit 7:  AM/PM Flag (1=PM, 0=AM)"}]