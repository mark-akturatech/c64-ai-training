{
  "source_file": "1541_User_Guide.txt",
  "context": "*********",
  "splits": [
    {
      "start": 1,
      "end": 107,
      "name": "front_matter_project64_notice_and_disclaimer_ignored",
      "description": "Project 64 preservation notice, conversion credits, distribution disclaimers, FCC warnings, copyright and part number for the Commodore 1541 Disk Drive User's Guide. (Non-technical front matter \u2014 marked ignored.)",
      "references": [
        {
          "chunk": "table_of_contents_ignored",
          "topic": "points to the Table of Contents that follows the front matter"
        }
      ],
      "ignore": true,
      "reason": "Project 64 preservation notice, conversion credits, distribution disclaimers, FCC warnings, copyright and part number for the Commodore 1541 Disk Drive User's Guide. (Non-technical front matter \u2014 marked ignored.)"
    },
    {
      "start": 108,
      "end": 191,
      "name": "table_of_contents_ignored",
      "description": "Table of Contents for the manual listing chapters, sections and appendices. (Non-technical \u2014 marked ignored.)",
      "references": [
        {
          "chunk": "general_description_introduction",
          "topic": "entry for Chapter 1: General Description"
        },
        {
          "chunk": "appendix_a_disk_command_summary",
          "topic": "entry for Appendix A: Disk Command Summary"
        }
      ],
      "ignore": true,
      "reason": "Table of Contents for the manual listing chapters, sections and appendices. (Non-technical \u2014 marked ignored.)"
    },
    {
      "start": 192,
      "end": 258,
      "name": "general_description_introduction",
      "description": "Chapter 1 introduction to the 1541 disk drive: high-level overview, intended audience (beginners to professionals), how the manual is organized and which chapters to read for basic vs advanced usage.",
      "references": [
        {
          "chunk": "specifications_and_hardware_summary",
          "topic": "hardware/capacity summary for the 1541"
        },
        {
          "chunk": "using_programs_loading_prepackaged_software",
          "topic": "practical starting point for loading prepackaged software (Chapter 3)"
        }
      ]
    },
    {
      "start": 259,
      "end": 332,
      "name": "specifications_and_hardware_summary",
      "description": "Section 1.2: Technical specifications of the 1541 disk drive \u2014 storage capacity, file counts, ROM/RAM details, pipeline DOS behavior, compatibility with other Commodore drives, serial bus description, ICs, buffer RAM, physical dimensions, power requirements, and media format.",
      "references": [
        {
          "chunk": "general_description_introduction",
          "topic": "context for why these specifications matter"
        },
        {
          "chunk": "random_files_overview_and_disk_structure",
          "topic": "relationship between disk geometry (tracks/blocks) and random file access"
        }
      ]
    },
    {
      "start": 333,
      "end": 413,
      "name": "unpacking_contents_and_drive_panels",
      "description": "Chapter 2.1: Contents of the box and descriptive front/back panel ASCII figures (front panel indicators, drive indicator LED behaviors, door lever, power indicator) and rear-panel depiction (power switch, serial bus ports, fuse holder). Instructions not to connect devices before reading safety notes.",
      "references": [
        {
          "chunk": "connection_of_cables_and_serial_chain",
          "topic": "next steps: how to attach the supplied cables and daisy-chain multiple devices"
        }
      ]
    },
    {
      "start": 414,
      "end": 452,
      "name": "connection_of_cables_and_serial_chain",
      "description": "Section 2.2: How to connect the power cable and serial bus cable; cable orientation cautions; daisy-chaining multiple disk drives and printer hookup diagram (Fig 3); recommendation to power up one drive at a time and to use one drive during initial familiarization.",
      "references": [
        {
          "chunk": "powering_on_and_diskette_insertion_figure",
          "topic": "next: correct power-up sequencing and initial LED behavior"
        },
        {
          "chunk": "changing_device_number_hardware_method_and_jumper_table",
          "topic": "how to change device number when using multiple drives"
        }
      ]
    },
    {
      "start": 453,
      "end": 489,
      "name": "powering_on_and_diskette_insertion_figure",
      "description": "Section 2.3: Powering-on sequence and important order (computer last), removing all diskettes before power-up, LED startup behavior. Includes an ASCII diagram illustrating diskette write-protect notch and the correct orientation for insertion.",
      "references": [
        {
          "chunk": "insertion_and_drive_door_procedures",
          "topic": "step-by-step disk insertion and door operation (2.4)"
        }
      ]
    },
    {
      "start": 490,
      "end": 522,
      "name": "insertion_and_drive_door_procedures",
      "description": "Section 2.4: Two types of drive doors (type 1 and type 2) and the correct method to insert and remove a diskette; orientation (label up, notch to left), write-protect notch information, warnings about removing a disk while red drive light is on.",
      "references": [
        {
          "chunk": "powering_on_and_diskette_insertion_figure",
          "topic": "diagram showing diskette orientation"
        }
      ]
    },
    {
      "start": 523,
      "end": 545,
      "name": "using_with_vic20_or_commodore64_switching_speeds",
      "description": "Section 2.5: Compatibility and speed differences when using the 1541 with VIC-20 vs Commodore 64; commands to switch drive speed (UI- for VIC 20, UI+ for C64); note that drive starts in C64 mode; reference to USER commands in Chapter 8.",
      "references": [
        {
          "chunk": "programming_the_disk_controller_block_execute",
          "topic": "USER and UI commands explained further in Chapter 8"
        }
      ]
    },
    {
      "start": 546,
      "end": 568,
      "name": "using_programs_loading_prepackaged_software",
      "description": "Chapter 3.1: How to load prepackaged software from disk \u2014 insert disk, use LOAD \"program name\",8, observe SEARCHING/LOADING/READY messages, then RUN.",
      "references": [
        {
          "chunk": "load_command_syntax_and_examples",
          "topic": "detailed LOAD command options and command numbers"
        }
      ]
    },
    {
      "start": 569,
      "end": 616,
      "name": "load_command_syntax_and_examples",
      "description": "Section 3.2: LOAD command format (LOAD name$, device#, command#), explanation of name string, device number (default 8), command number (0 vs 1) and examples demonstrating usage including machine language loads (command# 1) and variable usage.",
      "references": [
        {
          "chunk": "save_command_and_process",
          "topic": "related SAVE command syntax and the effect of the DOS during save"
        },
        {
          "chunk": "directory_bam_and_listing",
          "topic": "how the directory interacts with LOAD and the Disk Operating System (DOS)"
        }
      ]
    },
    {
      "start": 617,
      "end": 682,
      "name": "directory_bam_and_listing",
      "description": "Section 3.3: Explanation of the BAM (Block Availability Map) and directory layout on disk, how DOS manages blocks and directory entries, why files must be CLOSED to update the BAM, and instructions to LOAD \"$\",8 to read the directory into memory and print or LIST it (including printing via CMD on a printer).",
      "references": [
        {
          "chunk": "bAm_directory_and_file_format_tables",
          "topic": "low-level BAM and directory header/table formats in Appendix/Tables"
        },
        {
          "chunk": "dos_support_wedge_and_shortcuts",
          "topic": "alternative ways to view the directory without LOAD via DOS support program"
        }
      ]
    },
    {
      "start": 683,
      "end": 729,
      "name": "pattern_matching_and_wildcards",
      "description": "Section 3.4: Pattern matching on disk with '*' to match any trailing characters and '?' as a single-character wildcard; syntax examples for LOAD and directory filtering (e.g., LOAD \"$0:T*\", LOAD \"$0:T?ST*\"), and behavior of using just '*' to load the last-accessed program.",
      "references": [
        {
          "chunk": "scratch_command_erasing_files_and_pattern_matching",
          "topic": "pattern matching is also used with SCRATCH to remove groups of files"
        }
      ]
    },
    {
      "start": 730,
      "end": 756,
      "name": "save_command_and_process",
      "description": "Section 3.5: SAVE command format (SAVE name$, device#, command#), how DOS chooses directory entries and blocks when saving, checks performed (directory existence, BAM availability), and error light behavior when save fails.",
      "references": [
        {
          "chunk": "save_with_replace_@0_syntax",
          "topic": "how to replace an existing file using the @0: prefix"
        }
      ]
    },
    {
      "start": 757,
      "end": 783,
      "name": "save_with_replace_@0_syntax",
      "description": "Section 3.6: SAVE-and-replace mechanism using the @0: prefix (e.g., SAVE \"@0:TEST\",8) which instructs DOS to mark the old entry deleted and create a new entry with the same name; explanation of the 0: compatibility with multi-drive systems.",
      "references": [
        {
          "chunk": "open_and_print_command_channel",
          "topic": "OPEN/PRINT# command channel usage for similar @0: replace behavior when opening files for write"
        }
      ]
    },
    {
      "start": 784,
      "end": 800,
      "name": "verify_command_comparison_and_limits",
      "description": "Section 3.7: VERIFY command format (VERIFY name$, device#) \u2014 byte-by-byte comparison between memory and disk file including line links; limitations when verifying across different machine memory configurations (e.g., VIC 20 vs C64).",
      "references": [
        {
          "chunk": "load_command_syntax_and_examples",
          "topic": "VERIFY checks differences that can arise from different LOAD command behaviors"
        }
      ]
    },
    {
      "start": 801,
      "end": 827,
      "name": "dos_support_wedge_and_shortcuts",
      "description": "Section 3.8: DOS SUPPORT program (wedge) description: convenience keys (\"/\" for LOAD, \"@\" and \">\" for DOS commands), how it reads the error channel with @ or > and RETURN, and the runtime memory impact of the wedge.",
      "references": [
        {
          "chunk": "reading_error_channel_example_and_error_fields",
          "topic": "how DOS support displays the error channel versus a BASIC routine"
        }
      ]
    },
    {
      "start": 828,
      "end": 896,
      "name": "open_and_print_command_channel",
      "description": "Section 4.1: OPEN and PRINT# usage for files and for setting up a command channel; OPEN syntax (OPEN file#, device#, channel#, text$), meaning of file#, device#, channel#, and text$; examples of opening command (channel 15) and data channels; sending commands via PRINT# or via OPEN with a text string.",
      "references": [
        {
          "chunk": "reading_error_channel_example_and_error_fields",
          "topic": "command channel (15) is used to read error information (INPUT# usage)"
        },
        {
          "chunk": "disk_command_summary",
          "topic": "summary of common PRINT# command strings"
        }
      ]
    },
    {
      "start": 897,
      "end": 923,
      "name": "new_format_and_directory_initialization",
      "description": "Section 4.2: NEW command to format a disk (creates timing/block markers, directory and BAM) or to clear directory of an already formatted disk; command syntax (PRINT#15,\"NEW:name,id\" or abbreviations) and the meaning of disk name and ID characters.",
      "references": [
        {
          "chunk": "bAm_directory_and_file_format_tables",
          "topic": "how NEW initializes the BAM and directory structures on track 18"
        }
      ]
    },
    {
      "start": 924,
      "end": 953,
      "name": "copy_command_and_combining_files",
      "description": "Section 4.3: COPY command to duplicate a file under a new name or to combine multiple files into one (PRINT#15,\"C:newfile=oldfile1,oldfile2,...\"). Examples and notes that COPY won't copy between single-drive units.",
      "references": [
        {
          "chunk": "rename_command",
          "topic": "other directory modification commands (rename/scratch)"
        }
      ]
    },
    {
      "start": 954,
      "end": 974,
      "name": "rename_command",
      "description": "Section 4.4: RENAME command to change a file name in the directory (PRINT#15,\"R:newname=oldname\"); fast directory-only operation and limitation that the file cannot be OPEN while renamed.",
      "references": [
        {
          "chunk": "scratch_command_erasing_files_and_pattern_matching",
          "topic": "related directory operations such as SCRATCH to delete files"
        }
      ]
    },
    {
      "start": 975,
      "end": 1001,
      "name": "scratch_command_erasing_files_and_pattern_matching",
      "description": "Section 4.5: SCRATCH command to delete files (PRINT#15,\"S:name\") and support for pattern matching/wildcards to delete multiple files at once; note about checking the error channel for the number of files scratched.",
      "references": [
        {
          "chunk": "pattern_matching_and_wildcards",
          "topic": "pattern matching and wildcard rules used with SCRATCH"
        }
      ]
    },
    {
      "start": 1002,
      "end": 1016,
      "name": "initialize_command_reset_drive_state",
      "description": "Section 4.6: INITIALIZE command (PRINT#15,\"INITIALIZE\" or \"I\") to return the drive to power-up state; caution to re-match drive to computer and that this clears drive state.",
      "references": [
        {
          "chunk": "open_and_print_command_channel",
          "topic": "INITIALIZE is often invoked via the command channel (15)"
        }
      ]
    },
    {
      "start": 1017,
      "end": 1046,
      "name": "validate_command_defragment_and_caution_with_random_files",
      "description": "Section 4.7: VALIDATE command (PRINT#15,\"VALIDATE\" or \"V\") to re-organize a disk's directory and collect blocks from improperly closed files to free space; warning that VALIDATE deallocates blocks used by random files and thus should not be used on disks with random files.",
      "references": [
        {
          "chunk": "block_allocate_and_error_handling",
          "topic": "VALIDATE can affect blocks allocated for random files"
        }
      ]
    },
    {
      "start": 1047,
      "end": 1056,
      "name": "duplicate_command_note_for_single_drives",
      "description": "Section 4.8: DUPLICATE command description \u2014 legacy command for copying entire disks on dual-drive systems (4040); no function on single-drive 1541.",
      "references": [
        {
          "chunk": "new_format_and_directory_initialization",
          "topic": "formatting differences between single- and dual-drive systems"
        }
      ]
    },
    {
      "start": 1057,
      "end": 1081,
      "name": "reading_error_channel_example_and_error_fields",
      "description": "Section 4.9: How to read the disk error channel from BASIC (sample routine using OPEN 15, INPUT# 15 to read up to 4 variables: error number, message text, track, and block). Notes on meaning of variables and common error locations (e.g., track 18 for BAM/directory).",
      "references": [
        {
          "chunk": "dos_support_wedge_and_shortcuts",
          "topic": "DOS Support program automates reading the error channel"
        },
        {
          "chunk": "appendix_b_detailed_error_descriptions_part1",
          "topic": "lookup of error numbers and detailed explanations"
        }
      ]
    },
    {
      "start": 1082,
      "end": 1110,
      "name": "close_statement_and_safe_closing_practices",
      "description": "Section 4.10: CLOSE statement usage and importance (CLOSE file#). Emphasizes closing files to properly update BAM and directory; advice to open error channel first and close it last; warnings about BASIC errors auto-closing files at the BASIC level but not on the drive, and the remedy (OPEN 15,8,15,\"I\").",
      "references": [
        {
          "chunk": "directory_bam_and_listing",
          "topic": "why CLOSE is required to update the BAM and directory entries"
        }
      ]
    },
    {
      "start": 1111,
      "end": 1166,
      "name": "sequential_files_open_syntax_and_file_types",
      "description": "Chapter 5.1: Sequential files overview and OPEN syntax for sequential files (OPEN file#, device#, channel#, \"0:name,type,direction\"); file type codes (PRG, SEQ, USR, REL), replace option with @0:, and examples.",
      "references": [
        {
          "chunk": "print_input_to_disk_formatting_and_examples",
          "topic": "how data is written to sequential files with PRINT#/INPUT#"
        }
      ]
    },
    {
      "start": 1167,
      "end": 1262,
      "name": "print_input_to_disk_formatting_and_examples",
      "description": "Chapter 5.2: PRINT# and INPUT# for writing/reading sequential files \u2014 formatting behavior for commas/semicolons/newlines, CR (CHR$13) handling, how numeric data is stored, inefficiency of commas, and illustrative diagrams showing file byte layouts (examples with string and numeric writes).",
      "references": [
        {
          "chunk": "get_statement_and_file_examination_example",
          "topic": "GET# to read files byte-by-byte for inspection"
        },
        {
          "chunk": "reading_directory_program_and_description",
          "topic": "the directory can be read as a sequential file"
        }
      ]
    },
    {
      "start": 1263,
      "end": 1336,
      "name": "get_statement_and_file_examination_example",
      "description": "Section 5.3: GET# statement to retrieve raw bytes from a file (GET# file#, variable list), guidance to prefer string variables, examples, and a sample BASIC program to examine arbitrary files on disk (including encoded program listing).",
      "references": [
        {
          "chunk": "reading_directory_program_and_description",
          "topic": "using GET# to read the directory when opened as a sequential file"
        }
      ]
    },
    {
      "start": 1337,
      "end": 1412,
      "name": "reading_directory_program_and_description",
      "description": "Section 5.4: How the disk directory can be opened as a sequential file (OPEN ... \"$\") and read using GET#; includes a sample BASIC program (READDIR.PRG) and notes on directory format (line numbers as file sizes, names in quotes).",
      "references": [
        {
          "chunk": "bAm_directory_and_file_format_tables",
          "topic": "detailed BAM and directory header/table formats for track 18"
        }
      ]
    },
    {
      "start": 1413,
      "end": 1431,
      "name": "bam_format_track18_sector0_1541",
      "description": "Table 5.1 \u2014 BAM (Block Availability Map) layout for the 1540/1541 disk. Covers Track 18 Sector 0 bytes: bytes 0\u20131 pointing to first directory block, byte 2 (ASCII 'A' for 4040 format), byte 3 (DOS reserved/null flag), and bytes 4\u2013143 containing the bit map of available blocks for tracks 1\u201335 (each bit represents a block; 1 = available, 0 = not available).",
      "references": [
        {
          "chunk": "directory_header_track18_sector0_1541",
          "topic": "Disk name/ID and header fields stored in the same track/sector (Track 18, Sector 0)"
        },
        {
          "chunk": "directory_format_and_entry_structure_1541",
          "topic": "Directory blocks pointed to by the BAM's first-directory-block pointer"
        }
      ]
    },
    {
      "start": 1432,
      "end": 1455,
      "name": "directory_header_track18_sector0_1541",
      "description": "Table 5.2 \u2014 Directory header area found on Track 18, Sector 0. Describes bytes 144\u2013161 (disk name padded with shifted spaces), bytes 162\u2013163 (disk ID), byte 164 (shifted space), bytes 165\u2013166 (ASCII representation for DOS version/format type), bytes 166\u2013167 (shifted spaces), and bytes 171\u2013255 (unused nulls). Note: ASCII characters may appear in locations 180\u2013191 on some disks.",
      "references": [
        {
          "chunk": "bam_format_track18_sector0_1541",
          "topic": "BAM resides in the same sector and contains the pointer to the first directory block"
        },
        {
          "chunk": "directory_format_and_entry_structure_1541",
          "topic": "Directory header relates to the directory entries stored in Track 18 sectors"
        }
      ]
    },
    {
      "start": 1456,
      "end": 1513,
      "name": "directory_format_and_entry_structure_1541",
      "description": "Table 5.3 \u2014 Directory format for Track 18, Sector 1 and the structure of a single directory entry. Covers the sector layout: bytes 0\u20131 (pointer to next directory block), eight file-entry slots per sector (bytes 2\u201331, 34\u201363, 66\u201395, 98\u2013127, 130\u2013159, 162\u2013191, 194\u2013223, 226\u2013255). Describes the single-directory-entry fields: byte 0 = file type OR'ed with $80 for properly closed files (type codes: 0=DEL,1=SEQ,2=PRG,3=USR,4=REL), bytes 1\u20132 = track and sector of first data block, file name padded with shifted spaces, relative-file specific fields (first side-sector pointer and record size), unused bytes, replacement-file pointer for OPEN@, and number-of-blocks in file (low and high bytes).",
      "references": [
        {
          "chunk": "bam_format_track18_sector0_1541",
          "topic": "BAM indicates free blocks referenced by directory entries"
        },
        {
          "chunk": "sequential_file_format_1541",
          "topic": "SEQ file type described here uses the sequential data block format"
        },
        {
          "chunk": "program_file_format_1541",
          "topic": "PRG file type described here uses the program-block format"
        }
      ]
    },
    {
      "start": 1514,
      "end": 1524,
      "name": "sequential_file_format_1541",
      "description": "Table 5.4 \u2014 Sequential file data block format. Each sequential data block contains bytes 0\u20131 pointing to the next sequential data block, and bytes 2\u2013256 containing 254 bytes of file data where carriage returns (CR) act as record terminators.",
      "references": [
        {
          "chunk": "directory_format_and_entry_structure_1541",
          "topic": "Sequential (SEQ) file entries reference first data block and use this block chaining format"
        },
        {
          "chunk": "program_file_format_1541",
          "topic": "Contrast with PRG program-file format (tokenized CBM memory layout and EOF marker)"
        }
      ]
    },
    {
      "start": 1525,
      "end": 1536,
      "name": "program_file_format_1541",
      "description": "Table 5.5 \u2014 PRG (program) file block format. Bytes 0\u20131 point to the next block in the program file. Bytes 2\u2013256 store 254 bytes of program data in Commodore memory format (keywords tokenized). End-of-file is marked by three zero bytes.",
      "references": [
        {
          "chunk": "directory_format_and_entry_structure_1541",
          "topic": "Program (PRG) directory entries reference the first data block described here"
        },
        {
          "chunk": "sequential_file_format_1541",
          "topic": "Sequential vs. PRG block layouts and EOF signaling differences"
        }
      ]
    },
    {
      "start": 1537,
      "end": 1582,
      "name": "random_files_overview_and_disk_structure",
      "description": "Chapter 6.1: Overview of random access files, motivation (direct record access vs sequential scans), basic disk geometry (35 tracks, blocks per track vary by track number), total blocks and DOS commands for direct block access.",
      "references": [
        {
          "chunk": "track_and_block_format_table",
          "topic": "table 6.1 within this section details blocks per track"
        },
        {
          "chunk": "opening_random_access_channel_and_buffers",
          "topic": "how to prepare channels for random access (OPEN syntax)"
        }
      ]
    },
    {
      "start": 1583,
      "end": 1617,
      "name": "opening_random_access_channel_and_buffers",
      "description": "Section 6.2: How to open the two channels needed for random access \u2014 command channel (15) and data channel (use \"#\" or \"#buffer#\" as file name). Examples showing OPEN syntax for selecting buffer numbers.",
      "references": [
        {
          "chunk": "block_read_command_and_example",
          "topic": "use of the opened random access data channel together with BLOCK-READ"
        }
      ]
    },
    {
      "start": 1618,
      "end": 1648,
      "name": "block_read_command_and_example",
      "description": "Section 6.3: BLOCK-READ command format (PRINT#file#,\"B-R:\" channel; drive; track; block or \"B-R:\" abbreviation) to move one 256-byte block from disk into the selected data channel. Includes a sample BASIC program to read a block into B$ byte-by-byte.",
      "references": [
        {
          "chunk": "get_statement_and_file_examination_example",
          "topic": "GET# used to extract bytes from the random-access buffer after BLOCK-READ"
        }
      ]
    },
    {
      "start": 1649,
      "end": 1681,
      "name": "block_write_command_and_example",
      "description": "Section 6.4: BLOCK-WRITE command format (PRINT#file#,\"B-W:\" channel; drive; track; block) to write contents of a data buffer to a disk block. Explains buffer-pointer behavior and includes a sample program writing to track 1 sector 1.",
      "references": [
        {
          "chunk": "block_allocate_and_error_handling",
          "topic": "importance of allocating blocks before writing with BLOCK-WRITE"
        }
      ]
    },
    {
      "start": 1682,
      "end": 1717,
      "name": "block_allocate_and_error_handling",
      "description": "Section 6.5: BLOCK-ALLOCATE command (PRINT#file#,\"B-A:\" drive; track; block) to mark a block in the BAM as used; explains how to detect 'NO BLOCK' error (error 65) and procedure to handle allocation failures by reading suggested next available block from the error channel. Includes a sample allocation loop.",
      "references": [
        {
          "chunk": "block_free_command",
          "topic": "counterpart operation to free blocks no longer needed"
        },
        {
          "chunk": "using_random_files_with_sequential_indexing_examples",
          "topic": "example programs showing allocation and use of sequential index files"
        }
      ]
    },
    {
      "start": 1718,
      "end": 1735,
      "name": "block_free_command",
      "description": "Section 6.6: BLOCK-FREE command (PRINT#file#,\"B-F:\" drive; track; block) to mark a previously allocated block as available in the BAM; notes that it does not erase the data but frees the entry for reuse.",
      "references": [
        {
          "chunk": "block_allocate_and_error_handling",
          "topic": "BLOCK-FREE is the inverse operation for blocks allocated with BLOCK-ALLOCATE"
        }
      ]
    },
    {
      "start": 1736,
      "end": 1788,
      "name": "using_random_files_with_sequential_indexing_examples",
      "description": "Section 6.7: Strategies for tracking which disk blocks belong to random files (maintain a companion sequential file as an index of track/block locations). Two sample programs: writing 10 random-access blocks with a sequential index and reading them back, showing allocation, write/read, and freeing of blocks.",
      "references": [
        {
          "chunk": "buffer_pointer_and_record_subdivision_examples",
          "topic": "using BUFFER-POINTER to create records inside blocks and access them"
        }
      ]
    },
    {
      "start": 1789,
      "end": 1860,
      "name": "buffer_pointer_and_record_subdivision_examples",
      "description": "Section 6.8: BUFFER-POINTER (PRINT#file#,\"B-P:\" channel; location) to set the buffer pointer inside a 256-byte block so that blocks can be subdivided into records; examples showing four records per block (64 bytes each) and sample write/read programs that set pointer, write data, and read records back.",
      "references": [
        {
          "chunk": "user1_user2_behaviour_and_usage",
          "topic": "how USER1/USER2 commands interact with buffer pointers"
        }
      ]
    },
    {
      "start": 1861,
      "end": 1904,
      "name": "user1_user2_behaviour_and_usage",
      "description": "Section 6.9: USER1 (U1/UA) and USER2 (U2/UB) commands \u2014 U1 forces read of entire block by setting pointer to 255 (reads full 256 bytes), U2 writes a block without changing the stored buffer-pointer (useful when updating blocks read with BLOCK-READ then altering via BUFFER-POINTER). Lists formats and notes that USER commands are useful for machine language usage.",
      "references": [
        {
          "chunk": "memory_execute_and_user_command_table",
          "topic": "other USER commands and jump table entries for disk-resident routines"
        }
      ]
    },
    {
      "start": 1905,
      "end": 1924,
      "name": "relative_files_introduction_and_structure_overview",
      "description": "Chapter 7.1: Introduction to RELative files \u2014 design for record/field structured data, side sectors and pointers, capacity (up to 720 records * up to 254 chars), and how DOS organizes side sectors and data blocks for relative access.",
      "references": [
        {
          "chunk": "creating_relative_files_open_syntax_and_format_table",
          "topic": "how to create relative files using OPEN syntax and record length specification"
        }
      ]
    },
    {
      "start": 1925,
      "end": 1982,
      "name": "creating_relative_files_open_syntax_and_format_table",
      "description": "Section 7.2: OPEN syntax to create a relative file (OPEN file#, device#, channel#, \"name,L,\" + CHR$(record length)), examples, and Table 7.1 showing the on-disk relative file format: data blocks, side sector blocks, field for side sector pointers to data blocks, and record padding rules.",
      "references": [
        {
          "chunk": "using_relative_files_position_command_and_record_numbering",
          "topic": "how to open and position within existing relative files (POSITION command)"
        }
      ]
    },
    {
      "start": 1983,
      "end": 2066,
      "name": "using_relative_files_position_command_and_record_numbering",
      "description": "Section 7.3: Opening existing relative files (OPEN file#, device#, channel#, \"name\") and how to position the file pointer for reading/writing using the POSITION command (PRINT#file#, \"P\" CHR$(channel#+96) CHR$(rec#lo) CHR$(rec#hi) CHR$(position)). Explanation of two-byte record numbers (REC HI/REC LO), conversion formulas, and examples for constructing record numbers.",
      "references": [
        {
          "chunk": "mailing_list_record_layout_and_sample_setup_intro",
          "topic": "practical application of record numbering with a sample mailing list layout"
        }
      ]
    },
    {
      "start": 2067,
      "end": 2090,
      "name": "mailing_list_record_layout_and_sample_setup_intro",
      "description": "Practical example: determining record length for a mailing list with multiple fields (first name, last name, address lines, city/state/zip/phone) and rationale for adding separator bytes; describes starting the file with a record number tracker and shows beginning of a program to create/read mailing-list type relative files.",
      "references": [
        {
          "chunk": "mailing_list_sample_program_and_usage",
          "topic": "complete mailing-list sample program that demonstrates creation, reading, and writing"
        }
      ]
    },
    {
      "start": 2091,
      "end": 2178,
      "name": "mailing_list_sample_program_and_usage",
      "description": "Detailed MAILING LIST sample program (BASIC) to create and manage relative-file records keyed by record numbers: variable setup, OPEN statements to create relative file, POSITION commands, write/read loops, error handling subroutine (checks for RECORD NOT PRESENT error 50), and instructions for expanding/modifying the program. Includes advice on creating large files in advance.",
      "references": [
        {
          "chunk": "create_relative_file_instructions_and_notes",
          "topic": "concise notes about POSITION command usage, CHR$(position) semantics, and write/read steps"
        },
        {
          "chunk": "relfile_program_constructor_and_read_example",
          "topic": "another sample RELFILE.PRG demonstrating construction and reading of relative files"
        }
      ]
    },
    {
      "start": 2179,
      "end": 2272,
      "name": "relative_file_basic_program",
      "description": "Complete BASIC source listing and explanation for RELFILE.PRG. Includes the tok64 directive and full BASIC program that demonstrates creating a relative file, opening devices (OPEN statements), positioning record pointers using print#1,\"p\" with chr$ sequences, writing and reading records to/from channels 1 and 2, prompting for user input, handling replacement of records, use of the error channel (subroutine at line 2000), keyboard function-key scanning (subroutine at line 5000), hardcopy/continue handling (subroutine at line 6000), helper comments and alternate-read notes (7000+), and the record-replacement subroutine (8000+). The listing ends with the 'stop tok64' directive. This chunk is a standalone BASIC program and documents all in-BASIC behaviors and subroutines referenced by the encoded distribution below.",
      "references": [
        {
          "chunk": "relfile_prg_encoded_dump",
          "topic": "encoded/tokenized distribution of this RELFILE.PRG program (begin 644 ... end)"
        }
      ]
    },
    {
      "start": 2273,
      "end": 2330,
      "name": "relfile_prg_encoded_dump",
      "description": "Encoded/tokenized dump of RELFILE.PRG suitable for distribution and re-creation on disk. Starts with 'begin 644 RELFILE.PRG' and contains an ASCII-encoded block (uuencode-style) representing the tokenized program data produced by tok64. The block continues through multiple encoded lines and terminates with 'end'. This chunk is the machine-readable encoded copy of the BASIC program listed earlier (relative_file_basic_program) and is intended to be decoded/written back to produce the RELFILE.PRG binary/tok64 file on a Commodore-compatible system.",
      "references": [
        {
          "chunk": "relative_file_basic_program",
          "topic": "human-readable BASIC source and explanation corresponding to this encoded dump"
        }
      ]
    },
    {
      "start": 2331,
      "end": 2354,
      "name": "create_relative_file_instructions_and_notes",
      "description": "Section 7.4: Step-by-step notes describing the relative file creation program: which lines in the sample program perform file creation, how POSITION CHR$ values set pointer positions (CHR$(1) and CHR$(25)), and that POSITION does not itself read or write data but sets file pointer for subsequent PRINT#/INPUT# operations.",
      "references": [
        {
          "chunk": "relative_files_introduction_and_structure_overview",
          "topic": "background on relative-file structure and side sectors"
        }
      ]
    },
    {
      "start": 2355,
      "end": 2408,
      "name": "relative_file_summary_and_modifying_program",
      "description": "Sections 7.5\u20137.6: Summary of relative-file program behavior (function keys, error-channel handling, printing options) and guidance for modifying the sample program \u2014 adding fields via extra POSITION commands, changing record length via CHR$(n), and remarks about access limits and record indexing for large files (up to 720 records, special considerations for >256 or >512 records).",
      "references": [
        {
          "chunk": "mailing_list_sample_program_and_usage",
          "topic": "practical modification examples (changing CHR$ length and adding fields)"
        }
      ]
    },
    {
      "start": 2409,
      "end": 2428,
      "name": "programming_disk_controller_block_execute",
      "description": "Chapter 8 intro and Section 8.1: Overview of programming the disk controller (adding routines to disk controller memory), and BLOCK-EXECUTE command (PRINT#file#, \"B-E:\" channel; drive; track; block) which loads a block into the buffer and executes it starting at buffer address until RTS.",
      "references": [
        {
          "chunk": "memory_write_and_example",
          "topic": "how MEMORY-WRITE can deposit machine code to be executed with BLOCK-EXECUTE or MEMORY-EXECUTE"
        }
      ]
    },
    {
      "start": 2429,
      "end": 2466,
      "name": "memory_read_command_and_sample_program",
      "description": "Section 8.2: MEMORY-READ syntax (PRINT#file#,\"M-R\" CHR$(low byte) CHR$(high byte)) to read bytes from the disk controller's RAM/ROM/buffers via the error channel; the next GET#/INPUT# on channel 15 will return bytes from that address; includes a sample BASIC program (RDISKMEM.PRG) to read memory ranges.",
      "references": [
        {
          "chunk": "appendix_a_disk_command_summary",
          "topic": "summary entry for MEMORY-READ (M-R) and other memory commands"
        }
      ]
    },
    {
      "start": 2467,
      "end": 2496,
      "name": "memory_write_and_example",
      "description": "Section 8.3: MEMORY-WRITE command to write bytes into controller memory (PRINT#file#,\"M-W\" CHR$(low) CHR$(high) CHR$(#chars) byte data); explains up to 34 bytes at a time and gives a short program to write an RTS at a controller address then execute it.",
      "references": [
        {
          "chunk": "memory_execute_and_user_command_table",
          "topic": "MEMORY-EXECUTE example and USER command jump table to run code in controller memory"
        }
      ]
    },
    {
      "start": 2497,
      "end": 2540,
      "name": "memory_execute_and_user_command_table",
      "description": "Section 8.4\u20138.5: MEMORY-EXECUTE syntax (PRINT#file#,\"M-E\" CHR$(low) CHR$(high)) to run code in DOS memory; USER command table (U1..U9, U; etc.) mapping USERn to jump vectors/addresses in disk RAM and examples of sending USER commands (PRINT# 15,\"U3\" or concatenated USER strings), description of UI+/UI- for speed switching.",
      "references": [
        {
          "chunk": "using_with_vic20_or_commodore64_switching_speeds",
          "topic": "UI+/UI- to switch between C64 and VIC-20 modes described earlier (Chapter 2)"
        }
      ]
    },
    {
      "start": 2541,
      "end": 2568,
      "name": "changing_device_number_software_method",
      "description": "Section 9.1: Software method to change the disk drive device number by writing new number into controller RAM via a MEMORY-WRITE sequence; includes example to change device number from 8 to 9 and notes about avoiding address conflicts when multiple drives are attached.",
      "references": [
        {
          "chunk": "changing_device_number_hardware_method_and_jumper_table",
          "topic": "hardware method is recommended for permanent multi-drive setups"
        }
      ]
    },
    {
      "start": 2569,
      "end": 2602,
      "name": "changing_device_number_hardware_method_and_jumper_table",
      "description": "Section 9.2: Hardware method to permanently change the device number \u2014 disassembly steps (remove screws, housing), locate and cut jumper(s) on the board (instructions for Model 1541/1541CR), reassembly steps and the jumper-to-device# mapping table (device numbers 8\u201311).",
      "references": [
        {
          "chunk": "changing_device_number_software_method",
          "topic": "alternative software-based method for temporary device number changes"
        }
      ]
    },
    {
      "start": 2603,
      "end": 2655,
      "name": "assembly_language_kernal_routines_and_sample_code",
      "description": "Chapter 10: Using the 1541 from assembly language \u2014 list of Kernal subroutine entry points (SETLFS, SETNAM, OPEN, CLOSE, CHKIN, CLRCH, BASIN, BSOUT), notes to consult the Programmer's Reference Guide for details, and a sample assembly-language program showing how to open and read a sequential file one byte at a time using JSR calls to the Kernal routines.",
      "references": [
        {
          "chunk": "memory_read_command_and_sample_program",
          "topic": "reading controller memory and executing code are related low-level operations"
        }
      ]
    },
    {
      "start": 2656,
      "end": 2685,
      "name": "appendix_a_disk_command_summary",
      "description": "Appendix A: Quick reference summary of disk commands and their PRINT# forms (NEW, COPY, RENAME, SCRATCH, INITIALIZE, VALIDATE, BLOCK-READ/WRITE/ALLOCATE/FREE, BUFFER-POINTER, USER1/2, POSITION, BLOCK-EXECUTE, MEMORY-READ/WRITE/EXECUTE, USER commands).",
      "references": [
        {
          "chunk": "disk_command_summary",
          "topic": "this appendix is the succinct command summary for in-chapter examples"
        },
        {
          "chunk": "appendix_b_error_code_summary_list",
          "topic": "when a command fails, Appendix B lists the error codes referenced by commands"
        }
      ]
    },
    {
      "start": 2686,
      "end": 2724,
      "name": "appendix_b_error_code_summary_list",
      "description": "Appendix B (start): Summary list of CBM floppy error message numbers and short captions (0 OK, 1 Files scratched, 2\u201319 unused, 20 Block header not found, ... up to 74 Drive not ready). Serves as an index of error numbers and brief explanations (the detailed descriptions follow).",
      "references": [
        {
          "chunk": "appendix_b_detailed_error_descriptions_part1",
          "topic": "detailed explanations of the listed error numbers appear in the following section"
        },
        {
          "chunk": "reading_error_channel_example_and_error_fields",
          "topic": "how to read these error numbers from the error channel (INPUT# 15)"
        }
      ]
    },
    {
      "start": 2725,
      "end": 2800,
      "name": "appendix_b_detailed_error_descriptions_part1",
      "description": "Appendix B continued: Detailed descriptions of DOS error messages (note to ignore numbers <20 except 1), including READ/WRITE error explanations for codes 20\u201329 (headers, sync, data missing, checksum, decode errors, write-protect, ID mismatch), syntax and file-related errors 30\u201339, record/file size errors 50\u201366, and other DOS/drive errors up through 74. Guidance on causes and suggested diagnostics.",
      "references": [
        {
          "chunk": "reading_error_channel_example_and_error_fields",
          "topic": "use the BASIC error-channel reader to obtain the error code plus track and block for diagnosis"
        },
        {
          "chunk": "validate_command_defragment_and_caution_with_random_files",
          "topic": "some errors (like file open/write or directory errors) are connected to improper file states that VALIDATE can address in some cases"
        }
      ]
    },
    {
      "start": 2801,
      "end": 2875,
      "name": "dos_error_messages_50_to_74",
      "description": "Disk Operating System (DOS) error messages 50 through 74 with short explanations. Covers: RECORD NOT PRESENT (50), OVERFLOW IN RECORD (51), FILE TOO LARGE (52), WRITE FILE OPEN (60), FILE NOT OPEN (61), FILE NOT FOUND (62), FILE EXISTS (63), FILE TYPE MISMATCH (64), NO BLOCK (65) with B-A context and parameters, ILLEGAL TRACK AND SECTOR (66), ILLEGAL SYSTEM T OR S (67), NO CHANNEL (70) and channel limits, DIRECTORY ERROR (71) with BAM note, DISK FULL (72), DOS MISMATCH (73) with explanation of read/write incompatibility, and DRIVE NOT READY (74) when no diskette is present.",
      "references": [
        {
          "chunk": "index_section",
          "topic": "See Index for error message cross-references"
        },
        {
          "chunk": "bam_format_1541",
          "topic": "Directory error (71) references the BAM (Block Availability Map)"
        }
      ]
    },
    {
      "start": 2876,
      "end": 2879,
      "name": "appendix_c_demo_disk_programs_header",
      "description": "Appendix C heading introducing Demonstration Disk Programs. Serves as the container for the example programs that follow (DIR, VIEW BAM, DISPLAY T & S, CHECK DISK, PERFORMANCE TEST).",
      "references": [
        {
          "chunk": "dir_demo_program",
          "topic": "Example program: DIR"
        },
        {
          "chunk": "view_bam_demo_program",
          "topic": "Example program: VIEW BAM"
        }
      ],
      "ignore": true,
      "reason": "audit: Index/TOC-only appendix with no technical details or standalone C64 programming content."
    },
    {
      "start": 2880,
      "end": 2952,
      "name": "dir_demo_program",
      "description": "Demonstration program 'DIR' (BASIC source and accompanying PRG data). Includes opening channel commands, reading directory entries from track 18, sector 0, parsing file entries, interactive disk commands, and the tokenized binary (begin 644 DIR.PRG ... end) of the program as stored on disk.",
      "references": [
        {
          "chunk": "appendix_c_demo_disk_programs_header",
          "topic": "Appendix C container"
        },
        {
          "chunk": "view_bam_demo_program",
          "topic": "Related demonstration program for viewing BAM"
        }
      ]
    },
    {
      "start": 2953,
      "end": 3059,
      "name": "view_bam_demo_program",
      "description": "Demonstration program 'VIEW BAM' (BASIC source and binary). Shows how to open the disk device, read the BAM (Block Availability Map) using device commands (e.g. 'i0', 'b-p', 'u1:') and display availability in a formatted manner for the VIC/64 display. Includes BASIC routines for fetching BAM bytes and rendering them, plus the tokenized PRG block (begin 644 VIEWBAM.PRG ... end).",
      "references": [
        {
          "chunk": "dir_demo_program",
          "topic": "Uses directory/BAM data similar to DIR program"
        },
        {
          "chunk": "bam_format_1541",
          "topic": "BAM layout and interpretation"
        }
      ]
    },
    {
      "start": 3060,
      "end": 3079,
      "name": "display_ts_overview_and_constants",
      "description": "Program title and purpose plus program constants and initial string setup. Covers the DISPLAY T & S header (REM comments), screen text prints, and initialization of variables and lookup strings: sp$, nl$, hx$ (hex digits), fs$ (field of reversed characters), ss$ (special character mapping), array and dimension declarations (a$(15), nb(2)).",
      "references": [
        {
          "chunk": "device_selection_and_file_opening",
          "topic": "select output device and open channels"
        },
        {
          "chunk": "load_track_sector_into_disk_buffer",
          "topic": "input track/sector and load disk buffer"
        }
      ]
    },
    {
      "start": 3080,
      "end": 3090,
      "name": "device_selection_and_file_opening",
      "description": "Select output device (screen or printer), set default drive variable, and open I/O channels. Shows default d$ assignment, prompts to choose screen (s) or printer (p), handling of jj$ input, prints confirmation of chosen output, and OPEN statements (OPEN 15,8,15 for CBM device, OPEN 4,4, and OPEN 2,8,2 \"#\") with Gosub 650 for error handling.",
      "references": [
        {
          "chunk": "display_ts_overview_and_constants",
          "topic": "string constants used for prompts and output"
        },
        {
          "chunk": "load_track_sector_into_disk_buffer",
          "topic": "subsequent disk commands use opened channels"
        },
        {
          "chunk": "subroutines_header_and_error_routine",
          "topic": "error handling (GOSUB 650)"
        }
      ]
    },
    {
      "start": 3091,
      "end": 3101,
      "name": "load_track_sector_into_disk_buffer",
      "description": "Prompt for track and sector, validate input, and issue disk commands to load specified block into the disk buffer. Includes INPUT for t,s, validation of track range (0 or >35 aborts), optional echo to screen/printer, and the CBM commands sent to the drive via channel 15: the 'U1' (u1:2,d$,t,s) command to position and read the addressed sector into the drive buffer, followed by an error-checking Gosub 650.",
      "references": [
        {
          "chunk": "device_selection_and_file_opening",
          "topic": "requires opened channels and selected output device"
        },
        {
          "chunk": "read_byte0_and_m_r_commands",
          "topic": "subsequent read of disk buffer starts by reading byte 0"
        },
        {
          "chunk": "next_track_sector_prompt_and_loop",
          "topic": "uses nb() results to iterate to next sector"
        }
      ]
    },
    {
      "start": 3102,
      "end": 3110,
      "name": "read_byte0_and_m_r_commands",
      "description": "Commands to read the first byte of the drive buffer and set up memory read. Sends 'b-p:2,1' to position the file pointer and then 'm-r' followed by two characters (chr$(0)chr$(5)) to initiate a memory read; then uses GET#15 to read a$(0) (byte 0) from the drive. Handles blank reads by substituting nl$ and then branches to the screen or printer display routines depending on jj$.",
      "references": [
        {
          "chunk": "load_track_sector_into_disk_buffer",
          "topic": "must be called after u1: to have buffer contents"
        },
        {
          "chunk": "read_and_crt_display",
          "topic": "screen-mode reader (branch target 431)"
        },
        {
          "chunk": "printer_display_loop_reading_disk_buffer",
          "topic": "printer-mode reader (branch target 460)"
        }
      ]
    },
    {
      "start": 3111,
      "end": 3125,
      "name": "read_and_crt_display",
      "description": "Screen-mode loop to read the remainder of the disk buffer and display it on the CRT. Initializes k and nb(1) from a$(0), then iterates j=0..63 (64 lines of 4 bytes) with special handling at j=32 to call the screen-continue subroutine (gosub 710) and handle 'n' to abort. For each 4-byte group it GET#s from channel 2 into a$(i), constructs hex address/a$ and ASCII representation/b$ via gosubs (790, 850), and prints formatted hex/ASCII lines to the screen.",
      "references": [
        {
          "chunk": "read_byte0_and_m_r_commands",
          "topic": "uses a$(0) read from drive before entering this loop"
        },
        {
          "chunk": "screen_continue_subroutine",
          "topic": "calls Gosub 710 at mid-page to prompt user continue"
        },
        {
          "chunk": "byte_to_hex_subroutine",
          "topic": "Gosub 790 formats hex for printing"
        },
        {
          "chunk": "byte_to_ascii_subroutine",
          "topic": "Gosub 850 converts bytes to displayable characters"
        },
        {
          "chunk": "next_track_sector_prompt_and_loop",
          "topic": "after display, control flows to prompt for next track/sector"
        }
      ]
    },
    {
      "start": 3126,
      "end": 3141,
      "name": "printer_display_loop_reading_disk_buffer",
      "description": "Printer-mode loop to read the drive buffer and send formatted output to the printer. Initializes k and nb(1) from a$(0), then iterates j=0..15 with inner loop i=k..15 to read up to 16 bytes per printer line into a$(i). Builds hex address and ASCII text for each 16-byte line using Gosub 790 and Gosub 850, checks for 'n' from the continue subroutine to abort, and sends each formatted line to printer channel 4 (PRINT#4).",
      "references": [
        {
          "chunk": "read_byte0_and_m_r_commands",
          "topic": "uses a$(0) read from drive before entering this loop"
        },
        {
          "chunk": "screen_continue_subroutine",
          "topic": "printer loop also respects continue prompt (z$)"
        },
        {
          "chunk": "byte_to_hex_subroutine",
          "topic": "Gosub 790 used for hex formatting"
        },
        {
          "chunk": "byte_to_ascii_subroutine",
          "topic": "Gosub 850 used for ASCII conversion"
        },
        {
          "chunk": "next_track_sector_prompt_and_loop",
          "topic": "after printing, code prompts for next track/sector"
        }
      ]
    },
    {
      "start": 3142,
      "end": 3150,
      "name": "next_track_sector_prompt_and_loop",
      "description": "Logic to present the next track/sector values and ask whether the user wants to display the next block. Prints 'next track and sector' using nb(1) and nb(2), prompts 'do you want next track and sector', reads z$, and branches: 'y' loads t,s with nb() and returns to the input/ load sequence; 'n' returns to top-of-input; otherwise loops waiting for valid response.",
      "references": [
        {
          "chunk": "read_and_crt_display",
          "topic": "produces nb(1)/nb(2) used to suggest the next block"
        },
        {
          "chunk": "printer_display_loop_reading_disk_buffer",
          "topic": "produces nb(1)/nb(2) used to suggest the next block"
        },
        {
          "chunk": "load_track_sector_into_disk_buffer",
          "topic": "reuses track/sector input flow when user opts to continue"
        }
      ]
    },
    {
      "start": 3151,
      "end": 3158,
      "name": "subroutines_header_and_error_routine",
      "description": "Subroutines section header and the disk error routine. Marks the beginning of subroutines and contains the error handler invoked after drive commands. The error routine (GOSUB 650) performs INPUT#15 to get error codes (en, em$, et, es), returns immediately if en=0, otherwise prints a formatted 'disk error' message and ends.",
      "references": [
        {
          "chunk": "device_selection_and_file_opening",
          "topic": "GOSUB 650 used after OPEN calls"
        },
        {
          "chunk": "read_byte0_and_m_r_commands",
          "topic": "GOSUB 650 used after drive commands"
        },
        {
          "chunk": "screen_continue_subroutine",
          "topic": "other subroutines follow in this section"
        }
      ]
    },
    {
      "start": 3159,
      "end": 3166,
      "name": "screen_continue_subroutine",
      "description": "Screen 'continue' prompt subroutine (called at mid-page). Prints a formatted 'continue(y/n)' prompt, reads z$ and loops until valid input. If 'n' it returns to caller (causing display loops to abort); if 'y' it clears the screen and prints the current track and sector header and returns to continue printing.",
      "references": [
        {
          "chunk": "read_and_crt_display",
          "topic": "invoked at half-page during screen-mode display"
        },
        {
          "chunk": "printer_display_loop_reading_disk_buffer",
          "topic": "printer-mode logic also checks z$ to abort"
        }
      ]
    },
    {
      "start": 3167,
      "end": 3172,
      "name": "byte_to_hex_subroutine",
      "description": "Subroutine to convert a disk buffer byte address 'n' into two hex characters appended to a$ using the hx$ lookup. Computes the high nibble (a1=int(n/16)), appends corresponding hex char, computes the low nibble (a2), appends it, adds a space and returns. (GOSUB 790 in main loops.)",
      "references": [
        {
          "chunk": "read_and_crt_display",
          "topic": "used to format address/byte hex output"
        },
        {
          "chunk": "printer_display_loop_reading_disk_buffer",
          "topic": "used to format address/byte hex output"
        },
        {
          "chunk": "byte_to_ascii_subroutine",
          "topic": "paired with ASCII conversion for full hex/ASCII lines"
        }
      ]
    },
    {
      "start": 3173,
      "end": 3179,
      "name": "byte_to_ascii_subroutine",
      "description": "Subroutine to convert a single disk buffer byte c$ into a displayable ASCII character appended to b$. If asc(c$)<32, replaces with space; if asc(c$) between 128 and 159 inclusive, maps to a special 3-character string using ss$; otherwise leaves c$ unchanged. (GOSUB 850 in main loops.)",
      "references": [
        {
          "chunk": "read_and_crt_display",
          "topic": "used to build ASCII column for screen hex dumps"
        },
        {
          "chunk": "printer_display_loop_reading_disk_buffer",
          "topic": "used to build ASCII column for printer hex dumps"
        },
        {
          "chunk": "byte_to_hex_subroutine",
          "topic": "paired with hex formatting to produce full dump lines"
        }
      ]
    },
    {
      "start": 3180,
      "end": 3261,
      "name": "tokenized_prg_binary_data",
      "description": "Tokenized PRG data for DISPTS.PRG: the tokenized BASIC program file contents produced by TOK64/STOP markers. Contains the binary/tokenized representation beginning with 'begin 644 DISPTS.PRG' followed by the encoded lines (M`... etc.) and ending with 'end'. This is the raw PRG payload corresponding to the displayed BASIC source above.",
      "references": [
        {
          "chunk": "display_ts_overview_and_constants",
          "topic": "binary form of the displayed BASIC source"
        },
        {
          "chunk": "device_selection_and_file_opening",
          "topic": "the compiled program includes OPEN/drive commands"
        }
      ]
    },
    {
      "start": 3262,
      "end": 3339,
      "name": "check_disk_program",
      "description": "Program 'CHECK DISK' (ver 1.4). BASIC source for scanning disk blocks, writing randomized test patterns, attempting block allocation (B-A), noting bad track/sector combinations, and reporting results. Includes error handling and a small routine to read drive responses. Also includes its tokenized PRG representation (begin 644 CHEKDISK.PRG ... end).",
      "references": [
        {
          "chunk": "performance_test_program",
          "topic": "Both are disk diagnostic programs"
        },
        {
          "chunk": "bam_format_1541",
          "topic": "Bad-block allocation and BAM interactions"
        }
      ]
    },
    {
      "start": 3340,
      "end": 3377,
      "name": "perftest_intro_and_disk_format",
      "description": "Program header and startup: 'PERFORMANCE TEST' title and tok64 start; BASIC comments identifying target systems; initial device opens and variable initialization (lt, lt$, nt); user prompts to insert a scratch disk and wait for Return; waiting loop for keystroke; initialization of ti$ and tt; issue of the disk-new command (PRINT#1 \"n0:test disk,00\"); construction of user messages (c1$, c2$, cc$) and calling the I/O response routine (GOSUB 1840); test of response timing and early failure handling (IF ti<nt ... and GOSUB 1880).",
      "references": [
        {
          "chunk": "perftest_io_response_handler",
          "topic": "handles device reply to commands sent here (GOSUB 1840/1880)"
        },
        {
          "chunk": "perftest_mechanical_file_test",
          "topic": "next test stage when disk-new succeeds (mechanical/file tests)"
        }
      ]
    },
    {
      "start": 3378,
      "end": 3391,
      "name": "perftest_mechanical_file_test",
      "description": "Mechanical/file-level drive test: prints 'drive pass' and starts 'mechanical test'; sets tt, opens a sequential file for writing on the drive (OPEN 2,8,2,\"0:test file,s,w\"), calls the I/O status routine for open (GOSUB 1840), invokes the write-data routine (ch=2; GOSUB 1930), closes via status messages (GOSUB 1840), reopens for reading (OPEN ... \"s,r\"), calls the read-data routine (GOSUB 1990), then issues a scratch file command (PRINT#1,\"s0:test file\") and reports the scratch with GOSUB 1840.",
      "references": [
        {
          "chunk": "perftest_io_response_handler",
          "topic": "used to display and evaluate device responses during file open/close"
        },
        {
          "chunk": "perftest_write_data_routine",
          "topic": "actual loop that writes numbered data lines to the file (GOSUB 1930)"
        },
        {
          "chunk": "perftest_read_data_routine",
          "topic": "actual loop that reads back and checks data (GOSUB 1990)"
        },
        {
          "chunk": "perftest_track_write_read_test",
          "topic": "the later track-level performance test that follows file tests"
        }
      ]
    },
    {
      "start": 3392,
      "end": 3415,
      "name": "perftest_track_write_read_test",
      "description": "Track-level performance test and program completion: sets tt, opens a logical file handle (#4) and sends a block-protect (b-p) command to the drive with a pseudo-random target buffer index; constructs a 255-byte buffer (nn$) and writes it to the drive file handle; issues U2 (write track) commands for 'lt' and track 1 (PRINT#1,\"u2:\" ...), using GOSUB 1840 to display device responses; issues U1 (read track) commands for 'lt' and track 1 (PRINT#1,\"u1:\" ...), again using GOSUB 1840 for status; closes the handle and prints success messages telling the user to remove the disk and power down; END of the main program.",
      "references": [
        {
          "chunk": "perftest_io_response_handler",
          "topic": "displays and checks responses for the b-p/u2/u1 track commands"
        },
        {
          "chunk": "perftest_tokenized_prg_blob",
          "topic": "tokenized PRG (PERFTEST.PRG) binary follows the BASIC listing"
        }
      ]
    },
    {
      "start": 3416,
      "end": 3424,
      "name": "perftest_continue_prompt",
      "description": "User 'continue (y/n)?' prompt routine: prints the prompt, flushes keyboard buffer (FOR loop), waits for a non-empty keypress, echoes the key and branches: 'n' ends the program, 'y' returns to caller, otherwise loops back to prompt (GOTO). This routine is called by other parts of the program to ask the operator whether to continue.",
      "references": [
        {
          "chunk": "perftest_io_response_handler",
          "topic": "used by the failure handler to ask whether to continue"
        }
      ]
    },
    {
      "start": 3425,
      "end": 3434,
      "name": "perftest_io_response_handler",
      "description": "I/O response display and failure handler (label at 1840): prints the prepared command/status text (cc$), performs INPUT#1,en,em$,et,es to read the drive's status bytes and error messages, prints a compact status line showing error code and messages, returns immediately if en<2 (success/OK range); on error prints 'unit is failing' and 'performance test', then saves ti$, calls the 'continue?' prompt routine (GOSUB 1750) to let the operator choose, restores ti$ and returns. Centralized handling for device replies used by format/open/write/read/track commands.",
      "references": [
        {
          "chunk": "perftest_continue_prompt",
          "topic": "prompts operator whether to continue when a failure is detected"
        },
        {
          "chunk": "perftest_mechanical_file_test",
          "topic": "invoked after file open/write/read operations to check status (GOSUB 1840)"
        },
        {
          "chunk": "perftest_track_write_read_test",
          "topic": "invoked after track-level commands to check status (GOSUB 1840)"
        }
      ]
    },
    {
      "start": 3435,
      "end": 3440,
      "name": "perftest_write_data_routine",
      "description": "Write-data subroutine (label at 1930): prints 'writing data', loops from 1000 to 2000 printing each loop index to the open file channel (PRINT# ch,i), calls the I/O status-display routine (GOSUB 1850) to show results, closes the channel (CLOSE ch) and returns. Used to populate a test file with sequential numeric records for later verification.",
      "references": [
        {
          "chunk": "perftest_io_response_handler",
          "topic": "called after writes to display the drive's response (GOSUB 1850)"
        },
        {
          "chunk": "perftest_mechanical_file_test",
          "topic": "invoked from the file write step (ch=2; GOSUB 1930)"
        }
      ]
    },
    {
      "start": 3441,
      "end": 3450,
      "name": "perftest_read_data_routine",
      "description": "Read-data subroutine (label at 1990): prints 'reading data', waits for a keypress to start, loops from 1000 to 2000 reading each record from the file (INPUT# ch,j), compares the read value to the expected index and prints a 'read error' message and calls the I/O status routine (GOSUB 1850) if any mismatch occurs; after the loop calls the I/O status routine and closes the channel before returning. Used to verify file integrity after writing.",
      "references": [
        {
          "chunk": "perftest_io_response_handler",
          "topic": "called to display the drive's response on errors (GOSUB 1850)"
        },
        {
          "chunk": "perftest_mechanical_file_test",
          "topic": "invoked from the file read step (GOSUB 1990)"
        }
      ]
    },
    {
      "start": 3451,
      "end": 3505,
      "name": "perftest_tokenized_prg_blob",
      "description": "Tokenized PRG blob and packaging markers: 'STOP TOK64' and the embedded tokenized program archive (BEGIN 644 PERFTEST.PRG ... multiple encoded lines starting with 'M' indicating uuencoded/tokenized PRG content) and the 'END' marker. This is the binary/tokenized form of PERFTEST.PRG included after the BASIC listing for distribution; includes the termination and trailing blank lines.",
      "references": [
        {
          "chunk": "perftest_intro_and_disk_format",
          "topic": "binary/tok64 packaging corresponds to the BASIC program beginning (start tok64 perftest.prg)"
        },
        {
          "chunk": "perftest_track_write_read_test",
          "topic": "compiled/tokenized form of the same program used for direct loading on target systems"
        }
      ]
    },
    {
      "start": 3506,
      "end": 3522,
      "name": "appendix_d_disk_formats_header",
      "description": "Appendix D header and diagram showing physical layout of a Commodore 1540/1541 disk (outer rim, tracks 1, 18 (directory), 35, index hole and center hub). Introduces the disk formats section that follows.",
      "references": [
        {
          "chunk": "sector_format_single_sector_1541",
          "topic": "Expanded view of a single sector"
        },
        {
          "chunk": "block_distribution_by_track",
          "topic": "How sectors/blocks are distributed by track"
        }
      ]
    },
    {
      "start": 3523,
      "end": 3537,
      "name": "sector_format_single_sector_1541",
      "description": "Expanded view of a single 1540/1541 sector layout. Shows sequence and components within a sector: SYNC, ID bytes, track (TK), block (BL), CHECKSUM, GAP 1, followed by an extended continuation showing data area: header byte (07), two BYTE fields (BYTE 0, BYTE 1), 254 bytes of data, CHECK SUM and GAP. This is the on-disk sector format for 1540/1541 single-density sectors.",
      "references": [
        {
          "chunk": "block_distribution_by_track",
          "topic": "Sector size combined with per-track block counts gives disk capacity"
        },
        {
          "chunk": "sequential_file_format",
          "topic": "Data area (254 bytes) format used by sequential files"
        }
      ]
    },
    {
      "start": 3538,
      "end": 3548,
      "name": "block_distribution_by_track",
      "description": "Table listing BLOCK DISTRIBUTION BY TRACK for 1540/1541: Tracks 1-17 have blocks 0-20 (21 blocks each), tracks 18-24 have blocks 0-18 (19 blocks), tracks 25-30 have blocks 0-17 (18 blocks), and tracks 31-35 have blocks 0-16 (17 blocks).",
      "references": [
        {
          "chunk": "bam_format_1541",
          "topic": "BAM stores availability for tracks 1-35"
        },
        {
          "chunk": "relative_file_format",
          "topic": "Relative side-sector allocation references per-track block ranges"
        }
      ]
    },
    {
      "start": 3549,
      "end": 3568,
      "name": "bam_format_1541",
      "description": "Block Availability Map (BAM) format for 1540/1541 stored on Track 18, Sector 0. Byte map: bytes 0-1 = track/sector of first directory block (18,01), byte 2 = ASCII 'A' (65) indicating 4040 format, byte 3 = reserved (null), bytes 4-143 = bitmap of available blocks for tracks 1-35 (each bit = block availability; 1 = available, 0 = not available).",
      "references": [
        {
          "chunk": "directory_header_1541",
          "topic": "BAM located on track 18 sector 0 alongside directory header"
        },
        {
          "chunk": "dos_error_messages_50_to_74",
          "topic": "Directory error (71) references BAM integrity"
        }
      ]
    },
    {
      "start": 3569,
      "end": 3592,
      "ignore": true,
      "reason": "Redundant with directory_header_track18_sector0_1541"
    },
    {
      "start": 3593,
      "end": 3603,
      "name": "sequential_file_format",
      "description": "Sequential file block format for 1540/1541. Byte layout: bytes 0-1 = track and sector of next sequential data block; bytes 2-256 = 254 bytes of data (records are terminated with carriage returns as record terminators).",
      "references": [
        {
          "chunk": "sector_format_single_sector_1541",
          "topic": "Uses the sector data area of 254 bytes"
        },
        {
          "chunk": "program_file_format",
          "topic": "Difference: sequential uses CR record terminators; program files use tokenized CBM format"
        }
      ]
    },
    {
      "start": 3604,
      "end": 3615,
      "name": "program_file_format",
      "description": "Program file (PRG) format for 1540/1541. Byte layout: bytes 0-1 = track and sector of next block in the program file; bytes 2-256 = 254 bytes of program data stored in Commodore memory format (keywords tokenized). End of file is indicated by three zero bytes.",
      "references": [
        {
          "chunk": "sequential_file_format",
          "topic": "Comparison of data region usage and EOF markers"
        },
        {
          "chunk": "directory_format_structure",
          "topic": "Directory entries point to first data block for a program file"
        }
      ]
    },
    {
      "start": 3616,
      "end": 3640,
      "ignore": true,
      "reason": "Redundant with directory_format_and_entry_structure_1541"
    },
    {
      "start": 3641,
      "end": 3671,
      "name": "single_directory_entry_structure",
      "description": "Structure of a single directory entry on Commodore disks. Byte 0 = 128 + file type (OR'ed with $80 indicates properly closed file). File types: 0 = DELeted, 1 = SEQential, 2 = PROGram, 3 = USER, 4 = RELative. Bytes 1-2 = track and sector of first data block. Remaining bytes include filename (padded with shifted spaces), relative-file fields (side-sector pointer and record size) where applicable, placeholders for replacement-file track/sector (OPEN@), and number-of-blocks (low byte, high byte).",
      "references": [
        {
          "chunk": "directory_format_structure",
          "topic": "Directory entries are stored in the directory sectors"
        },
        {
          "chunk": "relative_file_format",
          "topic": "Relative-file-specific fields inside directory entry"
        }
      ]
    },
    {
      "start": 3672,
      "end": 3672,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3673,
      "end": 3712,
      "name": "relative_file_format",
      "description": "Relative file (REL) format for 1540/1541. DATA BLOCK: bytes 0-1 = track and block of next data block; bytes 2-256 = 254 bytes of data. Empty records are encoded with $FF in first byte followed by $00 to end of record; partially filled records are padded with $00. SIDE SECTOR BLOCK: bytes 0-1 = track and block of next side sector block; byte 2 = side sector number (0-5); byte 3 = record length; bytes 4-15 = track/blocks of side sectors 0-5; bytes 16-256 = track/block pointers to up to 120 data blocks.",
      "references": [
        {
          "chunk": "single_directory_entry_structure",
          "topic": "Directory entries contain relative-file pointers and record size"
        },
        {
          "chunk": "block_distribution_by_track",
          "topic": "Relative file block allocation respects per-track block counts"
        }
      ]
    },
    {
      "start": 3713,
      "end": 3809,
      "ignore": true,
      "reason": "Index (alphabetical section references) \u2014 non-technical/index material intended for navigation rather than technical explanation."
    },
    {
      "start": 3810,
      "end": 3846,
      "ignore": true,
      "reason": "Commodore Sales Centers listing \u2014 non-technical contact/address information."
    },
    {
      "start": 3847,
      "end": 3908,
      "ignore": true,
      "reason": "Back page marketing/product listings, model summaries, logo, and publication credits (printed location, part number, etext note) \u2014 non-technical and credits."
    }
  ],
  "source_md5": "e7d14280dd0b1a69dbb913d8e7cf1b64"
}
