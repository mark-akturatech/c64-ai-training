{
  "source_file": "c64_rom_disassembly.txt",
  "context": "- Fully Commented Commodore 64 ROM Disassembly (English)",
  "splits": [
    {
      "start": 1,
      "end": 29,
      "ignore": true,
      "reason": "Title, file metadata, and parsing/format instructions (non-technical header)."
    },
    {
      "start": 30,
      "end": 2800,
      "name": "basic_rom_broad_overview",
      "description": "Comprehensive BASIC ROM content from the C64 ROM disassembly. Includes: BASIC cold/warm start vectors ($A000,$A002), ROM name string; action address tables for primary BASIC commands, functions and operators (vectors used by the interpreter); BASIC keyword table; GO keyword; BASIC error message strings and error-message pointer table; BASIC UI messages (OK, READY., ERROR, BREAK, etc.); many BASIC runtime routines and utilities including: stack search for FOR/GOSUB activity; memory management routines (open space in memory, copy blocks, check available memory, stack room checks); out-of-memory and error printing/warm-start sequences; BASIC input handling (buffering, get/line input, prompt handling); tokeniser (crunch) and de-tokeniser (uncrunch) routines; BASIC line insert/delete and line-chain rebuild routines; interpreter inner loop (fetch/dispatch of tokenized BASIC statements), command handlers for most BASIC statements and functions covered in the ROM portion: END, FOR/NEXT, DATA, INPUT/INPUT#, GET, READ, RESTORE, GOTO, GOSUB, RETURN, STOP/CONT/RUN, LIST/PRINT/PRINT#, CMD, REM, IF/THEN/GOTO, ON GOTO/GOSUB, DIM/arrays, LET/assignment (numeric and string), string routines (STR$, TI$, string descriptors, descriptor stack, string memory management), numeric evaluation (FAC1/FAC2 floating-point routines, conversion between float and fixed/integer), function table dispatch and function implementations (SGN, INT, ABS, USR, FRE, POS, SQR, RND, LOG, EXP, COS, SIN, TAN, ATN, PEEK, LEN, STR$, VAL, ASC, CHR$, LEFT$, RIGHT$, MID$ and many internal helpers), operator precedence parsing and evaluation, boolean logic (AND/OR via bitwise sequence), comparisons (string and numeric), array creation/search/element addressing and bounds checking, FRE/garbage-collection hooks and string space compaction, DEF/FNx function definition/evaluation and function-variable handling, real-time clock / jiffy conversion usage for TI/STR$ etc., and many supporting low-level helpers (I/O channel open/close, print char to device, cursor handling, error message vectors). Registers/variables referenced are the BASIC-ROM zero page and workspace bytes used by the interpreter (e.g., $22-$23 return pointer temp, $5F-$60 pointers, $7A-$7B BASIC execute pointer, descriptor stack pointer $16, string space pointers $31-$34, etc.). Also contains many embedded data blocks such as PI and numeric constants and many JSR/JMP vectors used by the interpreter.",
      "references": [
        {
          "chunk": "tokeniser_and_uncrunch",
          "topic": "See tokeniser/crunch and uncrunch routines for conversion between source text and tokenized BASIC."
        },
        {
          "chunk": "memory_management_and_gc",
          "topic": "See memory open, check, and garbage collection references for string/array allocation and out-of-memory handling."
        },
        {
          "chunk": "interpreter_dispatch_and_statement_handlers",
          "topic": "See interpreter inner loop and per-command handlers (FOR, NEXT, GOTO, GOSUB, RETURN, IF, PRINT, INPUT, READ, DIM, LET, etc.)."
        }
      ],
      "ignore": true,
      "reason": "Moved to examples/basic_rom_disassembly.asm \u2014 too large for a single chunk"
    },
    {
      "start": 2801,
      "end": 2909,
      "name": "perform_def_and_fnx_handling",
      "description": "DEF and FNx handling: checks FNx syntax, scanning for parentheses and CHR$ tokens, sets FN/DEF flags, obtains variable and function addresses, validates numeric source types, prepares and pushes variable/execute pointers on the stack, calls DATA to fetch constants, and stores the execute pointer and variable pointer into the function. Contains the core flow for DEFINE/FNx evaluation and control transfer into user-defined function storage.",
      "references": [
        {
          "chunk": "str_destr_and_string_space_allocation",
          "topic": "string allocation and STR$ uses (string/CHR$ tokens scanned during FNx/DEF parsing)"
        },
        {
          "chunk": "string_concatenation_and_descriptor_ops",
          "topic": "descriptor layout used when FNx returns string values"
        }
      ]
    },
    {
      "start": 2910,
      "end": 3002,
      "name": "str$_entry_and_descriptor_allocation",
      "description": "STR$() entry and descriptor handling: ensure source numeric, call FAC1->string conversion routine, setup result descriptor pointer, copy descriptor pointer to working registers, and request making string-space A bytes long. Includes the 'string vector' path: saving descriptor pointer and calling the string-space allocator. Returns pointer/length in zero-page descriptors for later storage on the descriptor stack.",
      "references": [
        {
          "chunk": "string_space_allocate_and_gc_trigger",
          "topic": "makes space in string memory and triggers garbage collection if necessary"
        },
        {
          "chunk": "string_concatenation_and_descriptor_ops",
          "topic": "uses descriptor pointers to copy and place strings on descriptor stack"
        }
      ]
    },
    {
      "start": 3003,
      "end": 3034,
      "name": "allocate_string_space_and_gc_trigger",
      "description": "Make-space helper for strings: the routine that allocates A bytes in string memory (returns X=pointer low byte, Y=pointer high byte), updates bottom-of-string-space and utility pointers, tests for out-of-memory and garbage-collected flags, and triggers garbage collection when allocation would fail. Saves and restores necessary bytes and loops to retry allocation after GC.",
      "references": [
        {
          "chunk": "garbage_collection_main_routine",
          "topic": "calls garbage collection ($B526) when allocation fails"
        }
      ]
    },
    {
      "start": 3035,
      "end": 3055,
      "name": "gc_init_and_process_descriptor_stack",
      "description": "Initializes garbage collection state and iterates the descriptor stack: sets bottom-of-string-space ($33/$34) from $37/$38, clears index and working pointer ($4E/$4F), initializes highest-uncollected-string pointer ($5F/$60) from end-of-arrays ($31/$32), sets descriptor stack pointer ($22/$23) to $19, and loops calling the descriptor salvageability check (JSR $B5C7) until the descriptor stack is exhausted.",
      "references": [
        {
          "chunk": "collect_string_variables_setup_and_loop",
          "topic": "continues after descriptor stack: sets up variable collection"
        },
        {
          "chunk": "check_string_salvageability_for_variables_and_update_pointers",
          "topic": "the JSR $B5C7 called here is the salvageability check implemented in that chunk"
        },
        {
          "chunk": "collect_string_and_compact_memory",
          "topic": "when a string is chosen for collection the routine in that chunk performs the move/compaction"
        }
      ]
    },
    {
      "start": 3056,
      "end": 3070,
      "name": "collect_string_variables_setup_and_loop",
      "description": "Sets up and iterates over string variables: sets garbage-collection step size to 7 ($53), loads the start-of-variables pointer ($2D/$2E) into the working pointer ($22/$23), compares against variable/array boundaries, and repeatedly calls the variable-salvageability check (JSR $B5BD) until all variables are processed or the variable area end is reached.",
      "references": [
        {
          "chunk": "gc_init_and_process_descriptor_stack",
          "topic": "follows descriptor-stack processing"
        },
        {
          "chunk": "check_string_salvageability_for_variables_and_update_pointers",
          "topic": "uses the salvageability checks described there"
        },
        {
          "chunk": "iterate_string_arrays_and_prepare_descriptors",
          "topic": "after variables the routine continues to process arrays"
        }
      ]
    },
    {
      "start": 3071,
      "end": 3117,
      "name": "iterate_string_arrays_and_prepare_descriptors",
      "description": "Iterates string arrays and prepares per-array descriptors: saves start-of-arrays ($58/$59) as a working pointer, sets descriptor step size to 3 ($53) for array descriptors, loops through arrays comparing pointer to array-end ($32/$31), advances to the next array by adding array-size to the pointer (updating $58/$59), inspects array header bytes (name, flags, size, #dimensions), computes the descriptor start for the array elements (ASL*2 + 5), adjusts for carry into high byte, checks whether the array contains strings and, for each element descriptor, calls the salvageability check (JSR $B5C7) before moving to the next element.",
      "references": [
        {
          "chunk": "collect_string_variables_setup_and_loop",
          "topic": "follows variable collection"
        },
        {
          "chunk": "check_string_salvageability_for_variables_and_update_pointers",
          "topic": "calls the salvageability routine for each element"
        },
        {
          "chunk": "collect_string_and_compact_memory",
          "topic": "if an element needs collecting, control transfers to the collect routine"
        }
      ]
    },
    {
      "start": 3118,
      "end": 3177,
      "name": "check_string_salvageability_for_variables_and_update_pointers",
      "description": "Per-descriptor salvageability checks and pointer bookkeeping: loads names to determine if the descriptor is a string (BMI/BPL tests), reads string length and pointer, skips null or non-string entries, compares the string pointer against bottom-of-string-space ($33/$34) and current highest-uncollected-string ($5F/$60) to determine whether it's already been collected, updates the highest-uncollected-string pointer when appropriate ($5F/$60), saves the descriptor working pointer into $4E/$4F and copies the step size to $55, then advances the descriptor pointer by the step ($53) handling carry into the high byte. Ends by setting a flag indicating 'not moved' and returning (RTS).",
      "references": [
        {
          "chunk": "iterate_string_arrays_and_prepare_descriptors",
          "topic": "called repeatedly while scanning array element descriptors"
        },
        {
          "chunk": "gc_init_and_process_descriptor_stack",
          "topic": "also invoked from the descriptor-stack scanning loop"
        },
        {
          "chunk": "collect_string_and_compact_memory",
          "topic": "when this logic decides a string must be moved it leaves the working pointer for the collect routine"
        }
      ]
    },
    {
      "start": 3178,
      "end": 3211,
      "name": "collect_string_and_compact_memory",
      "description": "Performs the actual string collection/compaction: checks that a working pointer ($4E/$4F) exists, derives descriptor offset from step-size ($55) by masking and shifting, computes the block end (string start + length) into $5A/$5B, sets destination end to the current bottom-of-string-space ($33/$34) in $58/$59, calls the memory-shift/open-up routine (JSR $A3BF) to copy the string to the top of uncollected space, then writes the updated string pointer back into the descriptor (via ($4E),Y), increments the new-string-pointer high byte, and jumps back to re-run the main routine from the last ending with XA holding the new bottom-of-string-memory pointer.",
      "references": [
        {
          "chunk": "check_string_salvageability_for_variables_and_update_pointers",
          "topic": "collect is triggered after salvageability logic sets the working pointer/offset"
        },
        {
          "chunk": "gc_init_and_process_descriptor_stack",
          "topic": "after collection the routine re-runs from the last ending to continue processing"
        },
        {
          "chunk": "iterate_string_arrays_and_prepare_descriptors",
          "topic": "array and element descriptors ultimately reach this collection step when strings must be moved"
        }
      ]
    },
    {
      "start": 3212,
      "end": 3315,
      "name": "string_concatenation_and_descriptor_operations",
      "description": "String descriptor operations and concatenation: implement concatenation (first operand in descriptor, second from line), compute resultant length and check overflow, request allocation for result, copy strings into the utility buffer, and push result descriptors onto the descriptor stack. Includes helpers to copy string from descriptor to utility pointer, evaluate string descriptors (pop descriptor or use top-of-string-space), and clean descriptor stack when a descriptor is at top-of-stack.",
      "references": [
        {
          "chunk": "str_destr_and_string_space_allocation",
          "topic": "STR$ entry uses descriptor allocation and copying helpers"
        },
        {
          "chunk": "garbage_collection_main_routine",
          "topic": "descriptor stack layout maintained and used by GC"
        }
      ]
    },
    {
      "start": 3316,
      "end": 3328,
      "name": "descriptor_stack_check_and_cleanup",
      "description": "Checks and cleans up the descriptor stack. Compares YA with the top-of-stack descriptor pointer bytes ($18/$17), discards a descriptor stack item if AY matches, updates descriptor stack pointer ($16/$17) and last string pointer, clears Y, then returns (RTS).",
      "references": [
        {
          "chunk": "chr_string_creation",
          "topic": "uses descriptor stack space after creating string"
        },
        {
          "chunk": "pull_string_and_byte_param",
          "topic": "related descriptor stack manipulations"
        }
      ]
    },
    {
      "start": 3329,
      "end": 3343,
      "name": "chr_string_creation",
      "description": "Implementation of CHR$(): evaluates a byte expression (result in X), saves the character, makes a one-byte string (calls make string space routine), stores the character into the new string, and then jumps to the routine that checks space on the descriptor stack and pushes the new string's descriptor (address + length). Covers JSR $B7A1 (byte eval), string allocation (JSR $B47D), storing into the string, and JMP $B4CA to push descriptor.",
      "references": [
        {
          "chunk": "descriptor_stack_check_and_cleanup",
          "topic": "ensures descriptor stack has room for pushed descriptor"
        },
        {
          "chunk": "byte_parameter_parsing_and_evaluation",
          "topic": "uses the byte-expression evaluator (JSR $B7A1)"
        }
      ]
    },
    {
      "start": 3344,
      "end": 3374,
      "name": "left_string_function",
      "description": "Implementation of LEFT$(): pulls a string descriptor and a byte parameter from the stack (JSR $B761), compares the requested length with the string length, clamps the length if necessary, saves start offset and length on the stack, allocates target string space (JSR $B47D), pops the descriptor pointer (JSR $B6AA) to get actual source pointer and length, adjusts source pointer by start offset, and copies the requested bytes into the utility/string area (JSR $B68C), then pushes the result descriptor (JMP $B4CA).",
      "references": [
        {
          "chunk": "pull_string_and_byte_param",
          "topic": "used to retrieve descriptor and byte parameter (JSR $B761)"
        },
        {
          "chunk": "chr_string_creation",
          "topic": "uses same descriptor push routine (JMP $B4CA)"
        },
        {
          "chunk": "right_string_function",
          "topic": "RIGHT$ branches into LEFT$ processing for remainder copying"
        }
      ]
    },
    {
      "start": 3375,
      "end": 3382,
      "name": "right_string_function",
      "description": "Implementation of RIGHT$(): pulls string descriptor and byte parameter (JSR $B761), computes the start offset for the rightmost N characters by subtracting length from the requested byte and inverting, then jumps into the LEFT$ continuation (JMP $B706 / returns to LEFT$ processing) so the same copy/allocation path is used.",
      "references": [
        {
          "chunk": "left_string_function",
          "topic": "continues into LEFT$ processing to perform copy and allocation"
        },
        {
          "chunk": "pull_string_and_byte_param",
          "topic": "retrieves descriptor and byte parameter (JSR $B761)"
        }
      ]
    },
    {
      "start": 3383,
      "end": 3406,
      "name": "mid_string_function",
      "description": "Implementation of MID$(): sets a default length (255), scans input for parameters (commas/parentheses), gets the start index and optional length (JSR $B79E to get byte parameter), pulls the string descriptor and parameters (JSR $B761), handles null strings and out-of-range starts (illegal quantity), adjusts indexes (decrement start for zero-based offset), computes remaining length and clamps against requested length, and branches to the LEFT$/RIGHT$ copy/allocation sequence as appropriate.",
      "references": [
        {
          "chunk": "pull_string_and_byte_param",
          "topic": "used to fetch descriptor and parameters (JSR $B761)"
        },
        {
          "chunk": "left_string_function",
          "topic": "branches into LEFT$/RIGHT$ copy/allocation path"
        },
        {
          "chunk": "byte_parameter_parsing_and_evaluation",
          "topic": "uses routines to parse and evaluate numeric byte parameters"
        }
      ]
    },
    {
      "start": 3407,
      "end": 3429,
      "name": "pull_string_and_byte_param",
      "description": "Common helper routine that pulls string descriptor and a byte parameter from the BASIC function call stack: scans for closing ')', preserves and restores return address bytes, pulls the byte parameter (stored into X and copied to A), pulls the string pointer low/high into $50/$51, restores return address on the stack, clears index (Y=0), copies parameter to A (TXA) and returns. Returns pointer in descriptor ($50/$51), byte parameter in A and X, Y=0.",
      "references": [
        {
          "chunk": "left_string_function",
          "topic": "LEFT$ entry calls this helper (JSR $B761)"
        },
        {
          "chunk": "right_string_function",
          "topic": "RIGHT$ entry calls this helper (JSR $B761)"
        },
        {
          "chunk": "mid_string_function",
          "topic": "MID$ entry calls this helper (JSR $B761)"
        }
      ]
    },
    {
      "start": 3430,
      "end": 3440,
      "name": "len_and_eval_string",
      "description": "LEN() implementation and its helper: performs LEN by calling the evaluate-string routine (JSR $B782) which returns the string length in A (and in Y). The evaluate-string routine (JSR $B6A3) evaluates a string expression, clears the numeric/data-type flag (sets $0D=0 numeric), copies the evaluated length into Y and returns. LEN then converts Y into FAC1 byte form and returns (JMP $B3A2).",
      "references": [
        {
          "chunk": "asc_function",
          "topic": "ASC also calls same evaluate-string routine (JSR $B782)"
        },
        {
          "chunk": "pull_string_and_byte_param",
          "topic": "related descriptor handling for string expressions (JSR $B6A3 called to evaluate string)"
        }
      ]
    },
    {
      "start": 3441,
      "end": 3448,
      "name": "asc_function",
      "description": "ASC() implementation: evaluates a string expression (JSR $B782) to get length in A (and Y), checks for null string (error if zero length), sets index to first character (Y=0), loads the first character byte from the string pointer ($22) into A, moves it into Y (for FAC1 conversion), and then jumps to the FAC1 conversion/return routine (JMP $B3A2).",
      "references": [
        {
          "chunk": "len_and_eval_string",
          "topic": "shares the evaluate-string helper (JSR $B782)"
        },
        {
          "chunk": "illegal_quantity_error",
          "topic": "jumps to error handler if string is null"
        }
      ]
    },
    {
      "start": 3449,
      "end": 3451,
      "name": "illegal_quantity_error",
      "description": "Single-location jump to the illegal quantity error and warm start handler (JMP $B248). Used by string functions (e.g., MID$, ASC, byte-eval) when parameters or string length checks fail.",
      "references": [
        {
          "chunk": "asc_function",
          "topic": "ASC branches here on null string"
        },
        {
          "chunk": "mid_string_function",
          "topic": "MID$ branches here on invalid indices/lengths"
        },
        {
          "chunk": "byte_parameter_parsing_and_evaluation",
          "topic": "byte-evaluator may branch here on malformed byte expressions"
        }
      ]
    },
    {
      "start": 3452,
      "end": 3465,
      "name": "byte_parameter_parsing_and_evaluation",
      "description": "Routines for scanning and obtaining byte parameters: a memory-scan helper call (JSR $0073), a 'get byte parameter' entry that evaluates an expression and checks numeric type (JSR $AD8A), and a byte-expression evaluator (JSR $B1B8) that evaluates an integer expression, checks FAC1 mantissa bytes ($64/$65) for null/valid results, and then scans memory/returns (JMP $0079). Used by string functions to parse numeric byte parameters and check for range/type errors.",
      "references": [
        {
          "chunk": "mid_string_function",
          "topic": "uses byte-parameter parsing to retrieve the optional MID length"
        },
        {
          "chunk": "chr_string_creation",
          "topic": "uses byte-expression evaluator for CHR$ argument"
        },
        {
          "chunk": "pull_string_and_byte_param",
          "topic": "invoked during parameter parsing and retrieval sequences"
        }
      ]
    },
    {
      "start": 3466,
      "end": 3502,
      "name": "val_string_to_fac_and_restore_exec",
      "description": "VAL() implementation and FAC1 load: evaluate string, handle empty-string case (result zero), temporarily patch BASIC execute pointer to allow terminating and reading the string in place, NULL-terminate the string, call the string->FAC1 converter, and restore the original execute pointer. This sequence parses numeric text into the floating accumulator FAC1.",
      "references": [
        {
          "chunk": "parse_string_to_fac_and_exponent_handling",
          "topic": "detailed ASCII-to-FAC1 parsing invoked by VAL()"
        },
        {
          "chunk": "fac_to_ascii_conversion_and_number_formatting",
          "topic": "inverse operation (FAC1->ASCII) used by STR$ and printing"
        }
      ]
    },
    {
      "start": 3503,
      "end": 3560,
      "name": "peek_poke_wait_parameter_handling",
      "description": "PEEK/POKE/WAIT parameter extraction and integer conversion: evaluate address expression, convert FAC1 into a temporary integer, handle syntax for additional parameters (e.g., POKE value, WAIT mask), perform memory read/write for PEEK/POKE, and implement WAIT polling loop with optional mask/eor argument. Performs numeric checks and raises errors for illegal quantities or range problems.",
      "references": [
        {
          "chunk": "val_string_to_fac_and_restore_exec",
          "topic": "FAC1-to-integer conversion helper used for address parameters"
        }
      ]
    },
    {
      "start": 3561,
      "end": 3565,
      "name": "round_fac1_add_half_pointer_setup",
      "description": "Setup to round FAC1 by adding 0.5: loads the low/high bytes of a memory pointer pointing at the 0.5 constant and jumps to the routine that adds the memory (AY) operand to FAC1. Includes the blank/separator line after the comment.",
      "references": [
        {
          "chunk": "unpack_memory_operand_for_add",
          "topic": "calls unpack (AY) into FAC2 before add"
        },
        {
          "chunk": "add_fac2_to_fac1_alignment_and_mantissa_operations",
          "topic": "destination routine that performs the actual add of the memory operand to FAC1"
        }
      ]
    },
    {
      "start": 3566,
      "end": 3578,
      "name": "subtract_fac1_from_memory_and_fac2_initial_sign_handling",
      "description": "Entry points and initial sign/exponent handling for subtraction operations where FAC1 is subtracted from a memory operand (AY) or from FAC2. Calls the unpack routine to load the memory operand into FAC2, complements FAC1's sign to prepare for subtraction, computes sign comparison (FAC1 EOR FAC2), and begins exponent handling/branching for the subtract path (including a jump into the add/subtract alignment logic and a reference to the right-shift routine when large shifts are needed).",
      "references": [
        {
          "chunk": "unpack_memory_operand_for_add",
          "topic": "uses the BA8C unpack routine to load memory(AY) into FAC2"
        },
        {
          "chunk": "add_fac2_to_fac1_alignment_and_mantissa_operations",
          "topic": "branches/jumps into the main exponent alignment and mantissa add/subtract logic"
        }
      ]
    },
    {
      "start": 3579,
      "end": 3582,
      "name": "unpack_memory_operand_for_add",
      "description": "Unpack the memory operand pointed to by (AY) into FAC2 (JSR $BA8C). This small segment is the entry that prepares FAC2 when adding a memory operand to FAC1.",
      "references": [
        {
          "chunk": "add_fac2_to_fac1_alignment_and_mantissa_operations",
          "topic": "the unpacked FAC2 is then processed by the add FAC2->FAC1 routine"
        }
      ]
    },
    {
      "start": 3583,
      "end": 3586,
      "name": "fac1_zero_early_exit_copy_fac2",
      "description": "Entry check for FAC1 == 0. Branches if FAC1 is non-zero; if FAC1 is zero jump to routine that copies FAC2 into FAC1 and returns.",
      "references": [
        {
          "chunk": "save_rounding_and_load_exponents",
          "topic": "continues with exponent/rounding setup when FAC1 != 0"
        }
      ]
    },
    {
      "start": 3587,
      "end": 3596,
      "name": "save_rounding_and_load_exponents",
      "description": "Save FAC1 rounding byte into FAC2 rounding byte slot, set index to FAC2 exponent address, load FAC2 exponent into Y, test for zero exponent (early exit), then prepare for exponent subtraction (SEC/SBC) and branch to mantissa-add if exponents equal or to shift logic if FAC2 < FAC1.",
      "references": [
        {
          "chunk": "fac1_zero_early_exit_copy_fac2",
          "topic": "previous early-exit check"
        },
        {
          "chunk": "fac2_gt_fac1_swap_and_sign_setup",
          "topic": "path taken when FAC2 exponent > FAC1 exponent"
        },
        {
          "chunk": "exponent_diff_and_shift_smaller_mantissa",
          "topic": "path taken when FAC2 exponent < FAC1 exponent (align mantissas)"
        },
        {
          "chunk": "mantissa_add_path",
          "topic": "branch target when exponents equal"
        }
      ]
    },
    {
      "start": 3597,
      "end": 3606,
      "name": "fac2_gt_fac1_swap_and_sign_setup",
      "description": "Handle the case FAC2 > FAC1: save exponent into FAC1 exponent slot, fetch FAC2 sign bit and store as FAC1 sign, take two's complement of A (preparing sign/magnitude handling), clear Y, clear FAC2 rounding byte and set index to FAC1 exponent address (effectively swapping roles so the larger-magnitude operand is treated as the minuend).",
      "references": [
        {
          "chunk": "save_rounding_and_load_exponents",
          "topic": "branching condition that leads here"
        },
        {
          "chunk": "exponent_diff_and_shift_smaller_mantissa",
          "topic": "next step: compute exponent difference and shift smaller mantissa"
        },
        {
          "chunk": "mantissa_subtract_sequence",
          "topic": "subtraction path uses the larger-magnitude operand chosen here"
        }
      ]
    },
    {
      "start": 3607,
      "end": 3615,
      "name": "exponent_diff_and_shift_smaller_mantissa",
      "description": "Handle FAC2 < FAC1 (or swapped case): clear index and rounding byte for FAC1/FAC2 as needed, compare exponent difference with $F9 to ensure it's within range, copy exponent difference to Y, fetch rounding byte, perform an LSR on a mantissa byte, and call the shift routine (JSR) to shift the smaller mantissa right by Y to align mantissas.",
      "references": [
        {
          "chunk": "fac2_gt_fac1_swap_and_sign_setup",
          "topic": "prepares indices/signs used here"
        },
        {
          "chunk": "sign_compare_and_select_add_subtract",
          "topic": "after shifting, decide add vs subtract based on signs"
        },
        {
          "chunk": "shift_routine_reference",
          "topic": "calls the right-shift routine (JSR) to align mantissas"
        }
      ]
    },
    {
      "start": 3616,
      "end": 3625,
      "name": "sign_compare_and_select_add_subtract",
      "description": "After exponents are equal (alignment complete), test sign relationship (BIT on sign compare). If signs indicate addition, branch to add-mantissa path; otherwise set Y index to point to the larger operand's mantissa (choose correct Y/X mapping) and set carry for subtraction to prepare for the mantissa-subtract sequence.",
      "references": [
        {
          "chunk": "exponent_diff_and_shift_smaller_mantissa",
          "topic": "alignment completed before this decision"
        },
        {
          "chunk": "mantissa_add_path",
          "topic": "branch target if signs indicate addition"
        },
        {
          "chunk": "mantissa_subtract_sequence",
          "topic": "path taken when subtraction is required"
        }
      ]
    },
    {
      "start": 3626,
      "end": 3641,
      "name": "mantissa_subtract_sequence",
      "description": "Perform subtraction of the smaller mantissa from the larger: ones-complement A and ADC rounding byte to form two's-complement adjustment, save rounding, then perform SBC chains across mantissa bytes (mantissa4..mantissa1), storing the resulting FAC1 mantissa bytes. This implements magnitude subtraction when signs differ.",
      "references": [
        {
          "chunk": "sign_compare_and_select_add_subtract",
          "topic": "triggered by sign compare choosing subtraction"
        },
        {
          "chunk": "abs_and_normalise_fac1",
          "topic": "followed by absolute-value and normalization of FAC1"
        }
      ]
    },
    {
      "start": 3642,
      "end": 3653,
      "name": "abs_and_normalise_fac1",
      "description": "Take absolute value of FAC1 if negative (BCS skips, otherwise JSR to negate FAC1), then set up initial normalisation state: clear Y, clear A, clear carry for add, fetch FAC1 mantissa1 and branch to main normalisation loop if it's non-zero (decision whether further byte moves are required).",
      "references": [
        {
          "chunk": "mantissa_subtract_sequence",
          "topic": "normalization follows the subtraction result"
        },
        {
          "chunk": "normalisation_byte_shift_loop",
          "topic": "continues the normalization process, moving bytes and adjusting exponent offset"
        }
      ]
    },
    {
      "start": 3654,
      "end": 3672,
      "name": "normalisation_byte_shift_loop",
      "description": "Normalize FAC1 by shifting mantissa bytes left into position: move mantissa2->1, 3->2, 4->3, rounding->4; clear rounding byte; increment exponent offset by $08 each iteration and loop until offset reaches $20 (max). If exponent reaches zero as part of normalization, clear exponent/sign and return (RTS).",
      "references": [
        {
          "chunk": "abs_and_normalise_fac1",
          "topic": "initial setup for this loop"
        },
        {
          "chunk": "mantissa_add_path",
          "topic": "addition path will also jump into normalization/testing code"
        }
      ]
    },
    {
      "start": 3673,
      "end": 3688,
      "name": "mantissa_add_path",
      "description": "Add FAC2 mantissa into FAC1 mantissa: ADC rounding byte, save rounding, then perform ADC chains adding mantissa4..mantissa1 (with carries) and save results. Finally jump to a test/normalization entry point to handle carry-based normalisation.",
      "references": [
        {
          "chunk": "sign_compare_and_select_add_subtract",
          "topic": "entry here when signs indicate addition"
        },
        {
          "chunk": "post_add_normalisation_shift_loop",
          "topic": "performs rotation/normalisation when carry indicates overflow from addition"
        }
      ]
    },
    {
      "start": 3689,
      "end": 3696,
      "name": "post_add_normalisation_shift_loop",
      "description": "If the ADC chain produced a carry (C=1), perform normalization for overflow: increment exponent-offset, shift rounding byte left, ROL mantissa bytes (1..4) to incorporate carry into mantissa, and loop until normalized (BPL/BMI test based on sign of A).",
      "references": [
        {
          "chunk": "mantissa_add_path",
          "topic": "called after mantissa addition to normalise result"
        },
        {
          "chunk": "underflow_and_exponent_adjustment",
          "topic": "continue to exponent adjustments and underflow checks after normalization"
        }
      ]
    },
    {
      "start": 3697,
      "end": 3703,
      "name": "underflow_and_exponent_adjustment",
      "description": "After normalization, handle exponent adjustment and underflow: subtract saved exponent from FAC1 exponent (SBC), branch to clear result on underflow (if BCS), otherwise compute two's complement of exponent difference and store as FAC1 exponent (handling negative result storage).",
      "references": [
        {
          "chunk": "post_add_normalisation_shift_loop",
          "topic": "normalization precedes this exponent adjustment"
        },
        {
          "chunk": "overflow_handling_and_final_rols",
          "topic": "if carry indicates overflow, handle increment/rotate and possible error"
        }
      ]
    },
    {
      "start": 3704,
      "end": 3714,
      "name": "overflow_handling_and_final_rols",
      "description": "Handle overflow after final exponent test: if no overflow (BCC) just return (RTS). If overflow (C=1), increment FAC1 exponent; if increment wraps to zero, branch to overflow error/warmstart; otherwise rotate-right mantissa bytes and rounding byte to finalize normalisation and return. Includes final RTS and trailing blank lines.",
      "references": [
        {
          "chunk": "post_add_normalisation_shift_loop",
          "topic": "overflow case arises from addition normalization"
        },
        {
          "chunk": "underflow_and_exponent_adjustment",
          "topic": "complements the underflow/exponent logic"
        }
      ]
    },
    {
      "start": 3715,
      "end": 3745,
      "name": "negate_and_twos_complement_fac1",
      "description": "Negate FAC1: flip the sign bit and perform a two's-complement on the FAC1 mantissa (bytes 1..4) and the rounding byte. Increments the rounding byte then, on overflow, propagates carries through the mantissa bytes. Leaves FAC1 negated and normalized (returns via RTS). This routine is used during subtraction paths that require taking the absolute value before normalization.",
      "references": [
        {
          "chunk": "add_fac2_to_fac1_alignment_and_mantissa_operations",
          "topic": "invoked from the subtract/normalise path when a negation (absolute) is required"
        },
        {
          "chunk": "overflow_error_and_warm_start",
          "topic": "overflow from subsequent adjustments is handled by the overflow error path"
        }
      ]
    },
    {
      "start": 3746,
      "end": 3750,
      "name": "overflow_error_and_warm_start",
      "description": "Overflow error handler entry used when arithmetic overflow occurs: sets the error code to $0F (overflow error) and jumps to the central error/warm-start routine to report the error and restart.",
      "references": [
        {
          "chunk": "add_fac2_to_fac1_alignment_and_mantissa_operations",
          "topic": "target when exponent increment results in zero (overflow condition)"
        },
        {
          "chunk": "negate_and_twos_complement_fac1",
          "topic": "referenced as a fallback if mantissa/increment operations overflow into the error case"
        }
      ]
    },
    {
      "start": 3751,
      "end": 3785,
      "name": "fac_shift_helpers_and_facetemp_shifts",
      "description": "FAC shift helpers: routines to shift FACtemp / FACX left/right by multiples (including repeated 8-bit loops), move bytes in temporary accumulators, handle rounding bytes, and perform repeated rotate/shift operations used by exponent alignment in arithmetic operations.",
      "references": [
        {
          "chunk": "fac_rounding_and_arithmetic_entry_points",
          "topic": "called to shift FAC2 or FAC1 mantissas during addition/subtraction"
        }
      ]
    },
    {
      "start": 3786,
      "end": 3827,
      "name": "log_constants_and_log_function",
      "description": "Constants and LOG() implementation: floating constants and series coefficients for LOG(), setup and normalization of FAC1, transformations used to map x into series domain (1/root2 etc), performs necessary multiplies/divides and evaluates the series to compute LOG(x) returning the result in FAC1. Includes data tables for the LOG series and helper calls into the series evaluator.",
      "references": [
        {
          "chunk": "multiply_divide_and_convert_routines",
          "topic": "multiplication/division and FAC unpack/pack helpers used by LOG()"
        },
        {
          "chunk": "constants_sqr_exp_series_and_series_evaluation",
          "topic": "series evaluation framework reused across LOG/EXP/SIN/COS"
        }
      ]
    },
    {
      "start": 3828,
      "end": 3878,
      "name": "multiply_fac1_by_memory_shift_add_loop",
      "description": "Entry of FAC1 * (memory at AY) multiply: unpack operand, check for zero, call accumulator test/adjust, clear temporary 4-byte mantissa and rounding byte, then iterate through FAC1 bytes performing shift-and-add of FAC2 into a temporary mantissa. Implements the bit-loop that shifts the temp mantissa and conditionally adds FAC2 (includes ROR/LSR/ADC/STA sequences and final ROR of temp bytes). Returns to caller.",
      "references": [
        {
          "chunk": "unpack_memory_into_fac2",
          "topic": "unpacks the memory operand into FAC2 before this multiply routine"
        },
        {
          "chunk": "test_and_adjust_accumulators",
          "topic": "normalises exponents and checks overflow/underflow before multiply"
        }
      ]
    },
    {
      "start": 3879,
      "end": 3904,
      "name": "unpack_memory_into_fac2",
      "description": "Routine to unpack a floating-point number at the (AY) pointer into FAC2: saves pointer, reads 5 bytes (mantissa 4..1 and sign+mantissa1), normalises sign bit, saves exponent and prepares FAC2 mantissa/sign bytes. Also computes sign compare (FAC1 XOR FAC2) for later operations. Returns to caller.",
      "references": [
        {
          "chunk": "multiply_fac1_by_memory_shift_add_loop",
          "topic": "used by the FAC1 * (AY) multiply entry"
        },
        {
          "chunk": "divide_ay_by_fac1_core_algorithm",
          "topic": "used when dividing (AY) by FAC1 (unpacks divisor/operand into FAC2)"
        }
      ]
    },
    {
      "start": 3905,
      "end": 3931,
      "name": "test_and_adjust_accumulators",
      "description": "Adjust and test FAC1/FAC2 exponents before arithmetic: loads FAC2 exponent, handles zero/underflow, adds FAC1 exponent, checks for overflow/underflow, adjusts exponent by +$80 when appropriate, saves sign compare and returns. Contains branches to overflow/underflow error handling and paths to clear FAC1 exponent on underflow.",
      "references": [
        {
          "chunk": "multiply_fac1_by_memory_shift_add_loop",
          "topic": "called before the multiply shift/add to align/validate accumulators"
        },
        {
          "chunk": "divide_ay_by_fac1_core_algorithm",
          "topic": "invoked during division preparation to align exponents"
        }
      ]
    },
    {
      "start": 3932,
      "end": 3949,
      "name": "multiply_fac1_by_10_and_constant",
      "description": "Multiply FAC1 by 10 helper: rounds/copies FAC1 to FAC2, adjusts exponent for *10 via additions and an add FAC2-to-FAC1 subroutine (FAC1 = (FAC1 + FAC2)*2 then increment exponent). Includes the 5-byte floating constant representing 10 (data bytes). Handles overflow error if exponent overflows.",
      "references": [
        {
          "chunk": "test_and_adjust_accumulators",
          "topic": "used to check exponent range before/after scaling"
        }
      ]
    },
    {
      "start": 3950,
      "end": 3961,
      "name": "divide_fac1_by_10_setup",
      "description": "Set up a divide-by-10 operation: round and copy FAC1 to FAC2, load pointer to the floating 10 constant (low/high), clear sign, save sign compare and then branch into the generic divide-by-(AY) routine by unpacking (AY) into FAC1 and jumping to the divide routine entry.",
      "references": [
        {
          "chunk": "divide_ay_by_fac1_core_algorithm",
          "topic": "the generic divide routine called to perform FAC1/10"
        },
        {
          "chunk": "multiply_fac1_by_10_and_constant",
          "topic": "provides the floating-point representation of 10 used here"
        }
      ]
    },
    {
      "start": 3962,
      "end": 4030,
      "name": "divide_ay_by_fac1_core_algorithm",
      "description": "Core algorithm to compute (AY)/FAC1 or FAC2/FAC1 depending on call: unpacks source into FAC2, checks for divide-by-zero, rounds FAC1, subtracts exponents to set quotient exponent, calls test_and_adjust_accumulators, then performs the long division on 4-byte mantissas. Implements compare/shift/subtract loops that double FAC2, compare with FAC1, optionally subtract FAC1, and accumulate quotient bits into temp mantissa bytes. At the end it shifts the accumulator left (A<<6) to create the FAC1 rounding byte and jumps to copy temp mantissa into FAC1 and normalise. The routine contains branches to the divide-by-zero and overflow handlers.",
      "references": [
        {
          "chunk": "unpack_memory_into_fac2",
          "topic": "used to load the numerator (AY) into FAC2 before division"
        },
        {
          "chunk": "test_and_adjust_accumulators",
          "topic": "used to align exponents and detect overflow/underflow during division preparation"
        },
        {
          "chunk": "divide_by_zero_and_copy_temp_to_fac1",
          "topic": "handles the divide-by-zero error and final copy/normalise of the temporary quotient"
        }
      ]
    },
    {
      "start": 4031,
      "end": 4043,
      "name": "divide_by_zero_and_copy_temp_to_fac1",
      "description": "Divide-by-zero error handling and result finalisation: the divide-by-zero path sets up an error code and jumps to the error routine. The normal return path copies the 4-byte temporary mantissa into FAC1's mantissa bytes and jumps to the FAC1 normalisation/return helper.",
      "references": [
        {
          "chunk": "divide_ay_by_fac1_core_algorithm",
          "topic": "this is the target for the division routine's final jump or divide-by-zero branch"
        }
      ]
    },
    {
      "start": 4044,
      "end": 4125,
      "name": "pack_unpack_fac_and_copy_helpers",
      "description": "FAC pack/unpack helpers: unpack FAC1/FAC2 from memory (AY) into FAC registers, pack FAC1 back into memory or variables (to addresses like $5C and variable pointers), copy FAC2->FAC1 and FAC1->FAC2 routines, and the low-level routines to store FAC bytes into destination (including sign/mantissa/exponent layout adjustments). Also includes a generic pack-into-(XY) helper.",
      "references": [
        {
          "chunk": "multiply_divide_and_accumulator_algorithms",
          "topic": "these helpers are invoked to load/store FACs before numeric operations"
        },
        {
          "chunk": "fac_sign_abs_int_conversion_and_shifts",
          "topic": "copy/round helpers used before integer conversions"
        }
      ]
    },
    {
      "start": 4126,
      "end": 4136,
      "name": "round_fac1",
      "description": "Round FAC1: check FAC1 exponent for zero, shift the FAC1 rounding byte left, detect overflow from the rounding byte, call mantissa increment if needed, and normalise/return when increment overflows.",
      "references": [
        {
          "chunk": "save_a_as_integer_byte_and_prepare_fac1_for_abs",
          "topic": "prepares FAC1 mantissa/exponent for ABS/normalisation after sign handling"
        },
        {
          "chunk": "get_fac1_sign",
          "topic": "obtains FAC1 sign used by rounding/normalisation decisions"
        }
      ]
    },
    {
      "start": 4137,
      "end": 4152,
      "name": "get_fac1_sign",
      "description": "Extract FAC1 sign: returns A=$FF for negative, A=$01 for positive, A=$00 (and exits) for zero. Checks exponent for zero, loads FAC1 sign byte, rotates sign bit into carry and sets the appropriate A result byte.",
      "references": [
        {
          "chunk": "perform_sgn",
          "topic": "caller wrapper that invokes this sign-extraction routine"
        },
        {
          "chunk": "compare_fac1_with_pointer_AY",
          "topic": "uses sign extraction when comparing FAC1 with memory (AY)"
        }
      ]
    },
    {
      "start": 4153,
      "end": 4156,
      "name": "perform_sgn",
      "description": "SGN() entry: JSR to get FAC1 sign (returns A=$FF for negative, A=$01 for positive, A=$00 for zero). This wrapper simply calls the sign routine and returns the result in A.",
      "references": [
        {
          "chunk": "get_fac1_sign",
          "topic": "implements the SGN logic and returns the sign byte"
        },
        {
          "chunk": "save_a_as_integer_byte_and_prepare_fac1_for_abs",
          "topic": "subsequent code path often uses the sign result stored in A"
        }
      ]
    },
    {
      "start": 4157,
      "end": 4175,
      "name": "save_a_as_integer_byte_and_prepare_fac1_for_abs",
      "description": "Save A as integer byte and prepare FAC1 for ABS/normalisation: store the sign/indicator into FAC1 mantissa1 ($62), clear mantissa bytes 2 and 3, set exponent to $88, complement mantissa1 and rotate sign into carry, clear mantissa 3 and 4, store exponent, clear rounding byte and sign bit, then jump to the ABS+normalise routine.",
      "references": [
        {
          "chunk": "perform_sgn",
          "topic": "uses the sign result saved in A to create an integer byte"
        },
        {
          "chunk": "abs_fac1",
          "topic": "clears the sign bit and returns; this code prepares FAC1 then jumps to ABS+normalise"
        }
      ]
    },
    {
      "start": 4176,
      "end": 4179,
      "name": "abs_fac1",
      "description": "ABS() implementation for FAC1: clear FAC1 sign by logical shifting the sign byte (LSR $66) to zero the sign bit and return.",
      "references": [
        {
          "chunk": "save_a_as_integer_byte_and_prepare_fac1_for_abs",
          "topic": "prepares FAC1 and then uses ABS/normalise to finish"
        },
        {
          "chunk": "round_fac1",
          "topic": "normalisation and rounding routines interact with FAC1 sign clearing"
        }
      ]
    },
    {
      "start": 4180,
      "end": 4220,
      "name": "compare_fac1_with_pointer_ay",
      "description": "Compare FAC1 with the 4-byte floating value at address (AY): saves pointer, loads the target exponent and mantissa bytes, handles zero exponent and sign differences, compares exponents and mantissas (including normalising top bit and checking the rounding byte), and returns A=$00 if equal, A=$01 if FAC1>(AY), A=$FF if FAC1<(AY).",
      "references": [
        {
          "chunk": "get_fac1_sign",
          "topic": "used to determine sign-based comparison results"
        },
        {
          "chunk": "round_fac1",
          "topic": "uses the rounding byte when comparing mantissa4"
        },
        {
          "chunk": "perform_sgn",
          "topic": "provides the sign-byte convention used in comparison return values"
        }
      ]
    },
    {
      "start": 4221,
      "end": 4241,
      "name": "convert_fac1_floating_to_fixed",
      "description": "Convert FAC1 from floating to fixed integer: if FAC1 exponent is zero clear FAC1; subtract max-integer exponent ($A0), test sign and handle negative overflow (set overflow byte and twos-complement mantissa), compute shift count and branch to short or long shift routines, and clear overflow on success.",
      "references": [
        {
          "chunk": "shift_fac1_right_a_times",
          "topic": "short-shift path for shifting FAC1 right A times (<8 shifts)"
        },
        {
          "chunk": "shift_fac1_right_a_times",
          "topic": "calls long-shift subroutine for >8 shifts via JSR $B999/$B9B0"
        },
        {
          "chunk": "clear_fac1",
          "topic": "called when exponent is zero (result cleared)"
        }
      ]
    },
    {
      "start": 4242,
      "end": 4252,
      "name": "shift_fac1_right_a_times",
      "description": "Shift FAC1 right A times (byte-wise): copy shift count into Y, isolate FAC1 sign bit, shift mantissa1 right while OR'ing the sign into its top bit, store mantissa1, then call the variable-shift routine to perform Y right-shifts on the full mantissa and clear overflow when done.",
      "references": [
        {
          "chunk": "convert_fac1_floating_to_fixed",
          "topic": "invokes this routine to align fixed integer conversion"
        },
        {
          "chunk": "int_fac1_truncate_fractional",
          "topic": "INT() uses shifting as part of truncation process"
        }
      ]
    },
    {
      "start": 4253,
      "end": 4268,
      "name": "int_fac1_truncate_fractional",
      "description": "INT() implementation for FAC1: check exponent against max-integer ($A0); if number already integer or too large return, otherwise convert floating to fixed, save rounding and sign bytes, toggle sign for two's-complement handling, rotate sign into carry, set exponent to $A0, save mantissa4 for power function usage, and jump to ABS+normalise.",
      "references": [
        {
          "chunk": "convert_fac1_floating_to_fixed",
          "topic": "used to obtain integer representation when truncating fractional part"
        },
        {
          "chunk": "abs_fac1",
          "topic": "INT() finishes by doing ABS and normalising FAC1"
        }
      ]
    },
    {
      "start": 4269,
      "end": 4276,
      "name": "clear_fac1",
      "description": "Clear FAC1: clear mantissa bytes 1-4, clear index Y, and return (used by conversion and zero-result paths).",
      "references": [
        {
          "chunk": "convert_fac1_floating_to_fixed",
          "topic": "calls clear when FAC1 exponent is zero"
        },
        {
          "chunk": "compare_fac1_with_pointer_ay",
          "topic": "comparison may detect zero values which map to cleared FAC1"
        }
      ]
    },
    {
      "start": 4277,
      "end": 4363,
      "name": "ascii_to_fac_parsing_get_fac1_from_string",
      "description": "Convert ASCII numeric string to FAC1: full parser that processes sign, optional decimal point, digits, optional exponent ('E'/'e') with +/-, adjusts FAC1 by multiplying/dividing by 10^n as needed, performs rounding, and combines digits into FAC1 using FAC multiply/add helpers. Handles flags for negative, decimal point, exponent sign, and error cases (illegal quantity). Produces a normalized floating accumulator (FAC1).",
      "references": [
        {
          "chunk": "val_string_to_fac_parsing",
          "topic": "VAL() routine uses this parser to get FAC1 from a string"
        },
        {
          "chunk": "multiply_divide_and_accumulator_algorithms",
          "topic": "uses FAC multiplication/division primitives while building FAC1 from digits"
        }
      ]
    },
    {
      "start": 4364,
      "end": 4384,
      "name": "parse_exponential_part_digits",
      "description": "Parse the next character(s) of a numeric exponent in ASCII: read the exponent count byte, handle multi-digit accumulation (shifts and adds), test and handle a negative-exponent flag, convert an ASCII digit character to binary (subtract $30) and save the exponent count byte. Branches back to the input routine to fetch the next character.",
      "references": [
        {
          "chunk": "scientific_mode_limits_constants",
          "topic": "limits used later to choose scientific notation"
        },
        {
          "chunk": "convert_fac1_to_ascii_sign_and_zero_handling",
          "topic": "main FAC1 -> ASCII routine that consumes the exponent value"
        }
      ]
    },
    {
      "start": 4385,
      "end": 4389,
      "name": "scientific_mode_limits_constants",
      "description": "Data constants used as thresholds for deciding when to use scientific notation: three numeric constants (represented in ROM bytes) corresponding to maximum values allowing decimals, maximum value before switching to scientific notation, and the 1,000,000,000 boundary.",
      "references": [
        {
          "chunk": "choose_notation_and_scale_fac1_to_get_digit_count",
          "topic": "compares FAC1 against these constants to choose fixed vs scientific mode"
        }
      ]
    },
    {
      "start": 4390,
      "end": 4406,
      "name": "print_in_and_convert_line_number_to_fac1",
      "description": "Print the ' IN ' message and print the current line number: set up pointer to the literal ' IN ', JSR to print a null-terminated string, load the current line number bytes into X and A, store them as FAC1 mantissa bytes, set the FAC1 exponent (via JSR to the exponent setter) and call the FAC1->ASCII conversion routine, then JSR to print the resulting null-terminated string.",
      "references": [
        {
          "chunk": "convert_fac1_to_ascii_sign_and_zero_handling",
          "topic": "converts the FAC1 value (the line number) to an ASCII string"
        }
      ]
    },
    {
      "start": 4407,
      "end": 4421,
      "name": "convert_fac1_to_ascii_sign_and_zero_handling",
      "description": "Start of the FAC1-to-ASCII conversion routine: set up an output index, detect sign (save leading ' ' or '-' into the output buffer and save FAC1 sign), handle FAC1 == 0 as a special case (write a '0', [EOT] and exit). This block establishes the output buffer and handles the zero/leading-sign cases.",
      "references": [
        {
          "chunk": "choose_notation_and_scale_fac1_to_get_digit_count",
          "topic": "next: determine whether to scale/divide/multiply FAC1 and whether to use scientific notation"
        },
        {
          "chunk": "finalize_string_pointer_and_return",
          "topic": "special-case zero path jumps to final string pointer setup and return"
        }
      ]
    },
    {
      "start": 4422,
      "end": 4449,
      "name": "choose_notation_and_scale_fac1_to_get_digit_count",
      "description": "Decide fixed vs scientific representation and scale FAC1 accordingly: initialize the digit/exponent count, compare FAC1 exponent with thresholds (check if FAC1 < 1 or >= 1), use pointer lookups (e.g. 1,000,000,000 and the scientific limits) and JSR comparisons, then repeatedly multiply or divide FAC1 by 10 (adjusting the number exponent count) until the value is in the desired range for digit extraction.",
      "references": [
        {
          "chunk": "scientific_mode_limits_constants",
          "topic": "constants used to determine when to scale and when to use scientific notation"
        },
        {
          "chunk": "round_convert_and_prepare_digits",
          "topic": "after scaling, rounding and conversion to fixed-point is performed"
        }
      ]
    },
    {
      "start": 4450,
      "end": 4470,
      "name": "round_convert_and_prepare_digits",
      "description": "Round FAC1 and prepare to extract digits: add 0.5 (round), call routine to convert FAC1 floating to fixed representation, set up default digits-before-decimal count and compute the precise count (including handling very large counts), store exponent adjustment and digits-before-decimal into working locations. This block finishes the arithmetic preparation before emitting characters.",
      "references": [
        {
          "chunk": "choose_notation_and_scale_fac1_to_get_digit_count",
          "topic": "uses the computed exponent/digit counts from scaling"
        },
        {
          "chunk": "digit_extraction_loop_and_output_write",
          "topic": "next: extract digits from the fixed FAC1 and write them to the output buffer"
        }
      ]
    },
    {
      "start": 4471,
      "end": 4524,
      "name": "digit_extraction_loop_and_output_write",
      "description": "Prepare output buffer and extract digits: write the decimal point if needed and pad leading zeros, initialize table index and loop registers, then iterate adding table bytes (powers-of-ten bytes) to FAC1 mantissa bytes to determine each digit. Use carry sensing to decide digit sign, handle two's-complement negative results and convert the digit to ASCII (add '0'), write the digit into the output buffer, decrement the digits-before-decimal counter and output the decimal point when the integer digits are done.",
      "references": [
        {
          "chunk": "round_convert_and_prepare_digits",
          "topic": "relies on the fixed representation and digits-before-decimal computed earlier"
        },
        {
          "chunk": "digit_table_index_checks_and_loop_control",
          "topic": "index bounds checks and loop control for the digit extraction table"
        },
        {
          "chunk": "trim_trailing_zeroes_and_exponent_handling",
          "topic": "after digits are emitted, trailing zeros are removed and exponent written if needed"
        }
      ]
    },
    {
      "start": 4525,
      "end": 4535,
      "name": "digit_table_index_checks_and_loop_control",
      "description": "Loop control and table-index checks for digit extraction: restore variable pointer, recover the working 'character' state, toggle the test sense bit, mask out the digit, copy it for the next iteration, compare the current table index against the maximum allowed for decimal numbers and for time formatting, and branch appropriately to continue or exit the digit loop.",
      "references": [
        {
          "chunk": "digit_extraction_loop_and_output_write",
          "topic": "continues or exits the digit extraction loop based on these checks"
        }
      ]
    },
    {
      "start": 4536,
      "end": 4548,
      "name": "trim_trailing_zeroes_and_prepare_exponent",
      "description": "Remove trailing zeros from the fractional part and prepare exponent data: walk backwards in the output buffer removing '0' characters until a non-zero or the decimal point is found, restore the last character if the decimal point is reached, place a '+' placeholder, load the exponent count, and test for zero-exponent early exit (which will null-terminate the string and finish).",
      "references": [
        {
          "chunk": "digit_extraction_loop_and_output_write",
          "topic": "operates on the output produced by digit extraction"
        },
        {
          "chunk": "write_exponent_digits_and_null_terminate",
          "topic": "if exponent != 0, the exponent digits are formatted and appended"
        }
      ]
    },
    {
      "start": 4549,
      "end": 4571,
      "name": "write_exponent_digits_and_null_terminate",
      "description": "Format and append the exponent to the output string: handle negative exponent sign (convert stored negative count to positive and place '-'), store exponent sign ('+'/'-') and the letter 'E' into the buffer, convert the exponent count to ASCII by subtracting tens repeatedly (loop that extracts tens and ones), store the two exponent digits and then a null terminator. Branching is used to exit to finalization after storing these bytes.",
      "references": [
        {
          "chunk": "trim_trailing_zeroes_and_prepare_exponent",
          "topic": "continues from trimming and exponent count loading"
        },
        {
          "chunk": "finalize_string_pointer_and_return",
          "topic": "final step sets the (AY) pointer to the result and returns"
        }
      ]
    },
    {
      "start": 4572,
      "end": 4581,
      "name": "finalize_string_pointer_and_return",
      "description": "Finalize the output string and return: handle various exit paths that save the last character or a null terminator to the output buffer, set the result string pointer in (AY) (low and high bytes), and execute RTS to return to the caller.",
      "references": [
        {
          "chunk": "convert_fac1_to_ascii_sign_and_zero_handling",
          "topic": "the main FAC1->ASCII routine which ends here"
        },
        {
          "chunk": "print_in_and_convert_line_number_to_fac1",
          "topic": "caller that prints the converted line number string"
        }
      ]
    },
    {
      "start": 4582,
      "end": 4593,
      "name": "floating_point_basic_constants",
      "description": "Floating-point numeric constants used by BASIC math routines. Contains the 0.5 constant (first two bytes), a null return constant for undefined variables, and a table of signed power-of-ten constants from -100,000,000 down to -1 (positive and negative 5-byte floating representations).",
      "references": [
        {
          "chunk": "jiffy_count_constants",
          "topic": "time/jiffy constants located immediately after these numeric constants"
        },
        {
          "chunk": "exp_constants_series_table",
          "topic": "related floating-point constants used by EXP/LOG routines"
        }
      ]
    },
    {
      "start": 4594,
      "end": 4602,
      "name": "jiffy_count_constants",
      "description": "Jiffy (time) count constants used by the ROM clock/time routines. Contains negative and positive 5-byte constants representing jiffy-grouped values (10s hours, hours, 10s mins, mins, 10s secs, secs) used for time arithmetic.",
      "references": [
        {
          "chunk": "floating_point_basic_constants",
          "topic": "preceding numeric constants used across ROM math routines"
        },
        {
          "chunk": "checksum_and_spare_bytes",
          "topic": "data area (checksum & spare bytes) following the jiffy constants"
        }
      ]
    },
    {
      "start": 4603,
      "end": 4611,
      "name": "checksum_and_spare_bytes",
      "description": "Non-code data area: contains a checksum byte labelled 'not referenced' followed by multiple spare bytes (fill pattern AA). These bytes are unused by referenced routines and act as padding or reserved space in the ROM image.",
      "references": [
        {
          "chunk": "jiffy_count_constants",
          "topic": "jiffy constants immediately precede this area"
        },
        {
          "chunk": "sqr_entry_unpack_fac1",
          "topic": "executable code for SQR begins after this data/padding area"
        }
      ]
    },
    {
      "start": 4612,
      "end": 4618,
      "name": "sqr_entry_unpack_fac1",
      "description": "Entry sequence to perform SQR(): rounds and copies FAC1 to FAC2, loads the pointer to the 0.5 constant, and unpacks the memory (AY) into FAC1. This sets up FAC1 for the square-root/power routines.",
      "references": [
        {
          "chunk": "checksum_and_spare_bytes",
          "topic": "this code follows the spare bytes area"
        },
        {
          "chunk": "power_function_driver",
          "topic": "SQR shares unpacking/unary-operation patterns with the power/EXP driver"
        }
      ]
    },
    {
      "start": 4619,
      "end": 4659,
      "name": "power_function_driver",
      "description": "Driver for exponentiation/power operations (X^Y and related). Handles special cases: zero exponent, sign handling for negative integer exponents, integer-only negative-base exponents (calls INT) and checks for equality, copies and preserves signs, calls LOG to compute Y*LOG(X), converts pointers, calls EXP to compute the power, and post-processes resulting sign/negation. Includes stack sign save/restore and a final conditional negation of FAC1.",
      "references": [
        {
          "chunk": "sqr_entry_unpack_fac1",
          "topic": "SQR entry shows a similar unpack-to-FAC1 setup used by this driver"
        },
        {
          "chunk": "exp_entry_prepare",
          "topic": "this driver calls EXP(); see EXP entry for preparation and continuation"
        },
        {
          "chunk": "exp_constants_series_table",
          "topic": "log/exp computations use constants from the EXP series table"
        }
      ]
    },
    {
      "start": 4660,
      "end": 4670,
      "name": "exp_constants_series_table",
      "description": "Floating-point constants and the series table for EXP/log conversion: contains the 1/LOG(2) constant (1.44269504), a series count byte, and a list of 5-byte coefficients for the EXP series expansion (small constants up to 1.0). These constants are used when preparing and evaluating the EXP series kernels.",
      "references": [
        {
          "chunk": "power_function_driver",
          "topic": "power function driver uses these constants when converting/scaling with LOG/EXP"
        },
        {
          "chunk": "exp_entry_prepare",
          "topic": "EXP entry loads the 1.443 pointer and uses the series table"
        }
      ]
    },
    {
      "start": 4671,
      "end": 4681,
      "name": "exp_entry_prepare",
      "description": "Initial entry sequence to perform EXP(): sets pointers to the 1/LOG(2) constant, performs a convert-AY (FAC1*(AY)), applies rounding based on FAC1 rounding byte, optionally calls round FAC1, then jumps to the EXP kernel continuation in the KERNAL at $E000.",
      "references": [
        {
          "chunk": "exp_constants_series_table",
          "topic": "loads the 1/LOG(2) pointer and uses series coefficients from that table"
        },
        {
          "chunk": "exp_kernel_continuation_and_overflow_handling",
          "topic": "continues EXP computation at $E000 for exponent handling and series evaluation"
        }
      ]
    },
    {
      "start": 4682,
      "end": 4717,
      "name": "exp_kernel_continuation_and_overflow_handling",
      "description": "Continuation of EXP() in the KERNAL ($E000). This code saves FAC2 rounding byte, copies FAC1 to FAC2, checks the exponent against overflow limits and calls overflow/underflow handler if needed, uses INT() to normalise/adjust exponent, swaps FAC1 and FAC2 bytes, restores rounding byte, performs FAC2-from-FAC1 subtraction and a negation step, sets up a counter pointer into the coefficient table and jumps to the series-evaluation driver. Ends by testing/adjusting accumulators and returning.",
      "references": [
        {
          "chunk": "exp_entry_prepare",
          "topic": "entry code jumps here after initial prepare/rounding"
        },
        {
          "chunk": "series_evaluation_routine",
          "topic": "this routine sets up and then branches into the generic series evaluator"
        },
        {
          "chunk": "power_function_driver",
          "topic": "EXP called by the power driver for X^Y computation"
        }
      ]
    },
    {
      "start": 4718,
      "end": 4757,
      "name": "series_evaluation_routine",
      "description": "General series-evaluation framework used by EXP, SQR^2 path and other polynomial evaluations. Saves and restores pointer/count bytes, packs FAC1, reads the constants count from the table, iterates through the constants list (5 bytes per coefficient), converts each constant with convert AY (FAC1*(AY)), adds the (AY) term to FAC1, decrements the count, and loops until all coefficients are processed. Ends with RTS. This routine implements repeated FAC multiplications and adds to evaluate polynomial/series expansions.",
      "references": [
        {
          "chunk": "exp_kernel_continuation_and_overflow_handling",
          "topic": "called/entered by EXP kernel to evaluate exponentiation series"
        },
        {
          "chunk": "exp_constants_series_table",
          "topic": "reads coefficient counts and 5-byte constants from this table"
        },
        {
          "chunk": "power_function_driver",
          "topic": "power driver uses LOG/EXP which triggers series evaluation"
        }
      ]
    },
    {
      "start": 4758,
      "end": 4813,
      "name": "rnd_seed_and_rnd_function",
      "description": "RND() implementation and seed handling: LCG constants stored (multiplier and offset), RND() entry which checks FAC1 sign for behaviors (n<0 copy seed, n>0 get next sequence, n=0 read VIA timers), VIA timer read path to form a pseudo-random number, LCG path (multiply, add constants), normalization to valid FAC1 exponent range, and final packing of the generated number into the caller's variable (pack FAC1 into (XY)).",
      "references": [
        {
          "chunk": "fac_to_ascii_conversion_and_numeric_formatting",
          "topic": "RND() result may be formatted/printed using FAC->ASCII helpers"
        }
      ]
    },
    {
      "start": 4814,
      "end": 4850,
      "name": "basic_io_wrappers_and_error_handler",
      "description": "BASIC I/O wrapper helpers and centralized error handling: wrappers for channel output/input/open that call KERNAL routines and branch to BASIC I/O error handler if the underlying I/O reports errors. Includes the I/O error handler that maps certain codes to diagnostic behavior, restores memory pointers, and triggers warm starts on serious errors.",
      "references": [
        {
          "chunk": "sys_save_load_file_io_parsing",
          "topic": "higher-level BASIC file I/O (OPEN/CLOSE/LOAD/SAVE) uses these wrappers and error handling"
        }
      ]
    },
    {
      "start": 4851,
      "end": 4874,
      "name": "perform_sys_routine",
      "description": "Implementation of the SYS statement entry: evaluate numeric expression, convert FAC_1 to integer, push a synthetic return address and saved registers/status onto the stack, pull processor status and JMP indirect to the machine-code SYS vector; on return, save returned A/X/Y and status and RTS. (Lines show JSR to expression evaluation, conversion, PHA of crafted return address bytes, saving/restoring A/X/Y and status, and JMP ($0014) to call the SYS address.)",
      "references": [
        {
          "chunk": "perform_save_routine",
          "topic": "SAVE/LOAD/VERIFY file operations called elsewhere in BASIC I/O"
        },
        {
          "chunk": "set_filename_routine",
          "topic": "SYS may be used in programs that also use file I/O; filename routines used by LOAD/SAVE/OPEN"
        }
      ]
    },
    {
      "start": 4875,
      "end": 4884,
      "name": "perform_save_routine",
      "description": "BASIC SAVE implementation: call the shared parameter parser for LOAD/SAVE, take the start and end addresses from BASIC variables/index bytes and call the KERNAL save routine ($FFD8) to write RAM to device; branch to BASIC I/O error handler on error, otherwise RTS. (Includes LDX/LDY loads of start/end address bytes and the JSR $FFD8 call.)",
      "references": [
        {
          "chunk": "get_params_for_load_save",
          "topic": "parsing filename/device/addresses used by SAVE"
        },
        {
          "chunk": "perform_verify_and_load",
          "topic": "LOAD/VERIFY share the same parameter parsing and KERNAL device calls"
        }
      ]
    },
    {
      "start": 4885,
      "end": 4913,
      "name": "perform_verify_and_load",
      "description": "Combined VERIFY and LOAD handling: set the verify flag for VERIFY, set load flag for LOAD and store it at $0A, call shared parameter parser, obtain start/end addresses and call the KERNAL load routine ($FFD5). After the KERNAL call handle I/O status: for verify set VERIFY-specific error handling and check tape read error bit; for LOAD print 'OK' when applicable and then RTS. (Covers verify flag setup, calls to $E1D4, $FFD5/$FFB7 reads of I/O status, masking read error and printing the 'OK' string.)",
      "references": [
        {
          "chunk": "get_params_for_load_save",
          "topic": "uses the LOAD/SAVE parameter parsing routine to obtain device, filename and addresses"
        },
        {
          "chunk": "ready_return_and_warm_start",
          "topic": "LOAD may flow into READY/return or error handling paths that rebuild BASIC state"
        }
      ]
    },
    {
      "start": 4914,
      "end": 4933,
      "name": "ready_return_and_warm_start",
      "description": "Handle READY return to BASIC after device operations: read I/O status word, mask error bits, branch to error handling if needed. If returning to immediate mode, set the start-of-variables addresses, print 'READY.' and perform the warm start sequence (reset execution state, clear variables, flush stack, rebuild BASIC chain). Otherwise set BASIC execute pointer and rebuild line chaining before returning. (Includes calls to $FFB7, printing READY/OK strings, and jumping to warm start and rebuild routines.)",
      "references": [
        {
          "chunk": "perform_verify_and_load",
          "topic": "LOAD/VERIFY call this path when finishing successfully"
        },
        {
          "chunk": "perform_sys_routine",
          "topic": "SYS returns to BASIC using saved register/status conventions; both are part of BASIC control flow"
        }
      ]
    },
    {
      "start": 4934,
      "end": 4946,
      "name": "perform_open_and_close",
      "description": "BASIC OPEN and CLOSE entry points: both routines call the parameter parser for OPEN/CLOSE and then call the KERNAL open ($FFC0) or close ($FFC3) routines. They branch to BASIC I/O error handling on failure and RTS on success. (Includes JSR $E219 to get parameters, JSR $FFC0 to open, JSR $FFC3 to close, and branching to error or returning.)",
      "references": [
        {
          "chunk": "get_params_for_open_close",
          "topic": "OPEN/CLOSE parameter parsing and defaults"
        },
        {
          "chunk": "get_params_for_load_save",
          "topic": "shared patterns for parsing device/filename parameters"
        }
      ]
    },
    {
      "start": 4947,
      "end": 4966,
      "name": "get_params_for_load_save",
      "description": "Parser used by LOAD/SAVE/VERIFY to extract device number, command, and filename: clear filename buffer, set default device (cassette) and default command, set logical and address registers via KERNAL ($FFBA), check for end-of-token or ':' to exit early, invoke filename setter (JSR $E257), scan for additional bytes and finally return with registers arranged for the KERNAL save/load calls. (Covers clearing filename ($FFBD), defaults, repeated calls to $FFBA and the calls to E206/E200/E257 helpers.)",
      "references": [
        {
          "chunk": "scan_and_get_byte",
          "topic": "used to scan/consume a following byte or produce syntax error"
        },
        {
          "chunk": "set_filename_routine",
          "topic": "invokes the routine that evaluates and stores the filename string for KERNAL use"
        }
      ]
    },
    {
      "start": 4967,
      "end": 4976,
      "name": "scan_and_get_byte",
      "description": "Helper routine to scan for ',byte' parameter: calls the comma/byte scanner (E20E) and then jumps to the byte-parameter fetch routine, or uses the memory-scan exit to detect end-of-token or ':' and returns appropriately. (Includes JSR $E20E, JMP to get byte parameter at $B79E, and the E206/E20D branch/return sequence to handle end-of-token.)",
      "references": [
        {
          "chunk": "scan_comma_and_valid_byte",
          "topic": "performs the comma scan and then validates the following byte"
        },
        {
          "chunk": "get_params_for_load_save",
          "topic": "LOAD/SAVE parser calls this to fetch optional numeric parameters"
        }
      ]
    },
    {
      "start": 4977,
      "end": 4984,
      "name": "scan_comma_and_valid_byte",
      "description": "Two-step scanner: first scan for a comma (JSR $AEFD), else do syntax error and warm start; then scan for a valid following byte (JSR $0079) and branch to syntax error if no valid byte follows. This handles patterns like \",<byte>\" and enforces presence of the byte after the comma.",
      "references": [
        {
          "chunk": "scan_and_get_byte",
          "topic": "scan_and_get_byte calls this to enforce comma and byte presence"
        },
        {
          "chunk": "get_params_for_open_close",
          "topic": "OPEN/CLOSE parameter parsing also uses comma-and-byte scanning"
        }
      ]
    },
    {
      "start": 4985,
      "end": 5013,
      "name": "get_params_for_open_close",
      "description": "Parser for OPEN/CLOSE statements: clear filename buffer, require and fetch logical file number, set default device/command, call KERNAL $FFBA to set logical/addresses, handle optional device/file parameters and convert device numbers for screen vs devices, save logical/file/device values into temporary BASIC variables and prepare A/X/Y for the KERNAL open/close calls. (Covers scanning for byte parameters, saving to $49/$4A, device-number comparisons and adjustments, and repeated use of E206/E200/E20E helpers.)",
      "references": [
        {
          "chunk": "perform_open_and_close",
          "topic": "OPEN/CLOSE entry points call this parser to obtain their arguments"
        },
        {
          "chunk": "scan_comma_and_valid_byte",
          "topic": "uses comma-and-byte scanning to parse optional fields"
        }
      ]
    },
    {
      "start": 5014,
      "end": 5020,
      "name": "set_filename_routine",
      "description": "Filename-setting helper called by parameter parsers: evaluate an expression and a string to obtain the filename pointer, retrieve the string pointer from BASIC pointers ($22/$23) and call the KERNAL filename setter ($FFBD) to copy the filename into the KERNAL buffer. (Includes JSR $AD9E to evaluate expression, JSR $B6A3 to evaluate string, and JMP $FFBD to perform the actual filename copy.)",
      "references": [
        {
          "chunk": "get_params_for_load_save",
          "topic": "invokes this to place the user-supplied filename into the KERNAL buffer"
        },
        {
          "chunk": "get_params_for_open_close",
          "topic": "OPEN/CLOSE parser also sets filenames using this routine"
        }
      ]
    },
    {
      "start": 5021,
      "end": 5137,
      "name": "trig_functions_sin_cos_tan_atn_series",
      "description": "Trigonometric functions and series: COS() entry (adds pi/2 etc), SIN() implementation (rounding/copy FAC1->FAC2, division by constants, integer/quarter-cycle adjustments, series evaluation), TAN() (compute SIN, pack/unpack and divide), ATN() implementation with its own series and sign/exponent handling. Contains constants and series tables for SIN/COS/ATN and the logic to evaluate them via the series evaluation helper routines.",
      "references": [
        {
          "chunk": "constants_sqr_exp_series_and_series_evaluation",
          "topic": "shares series-evaluation code and constants for trig/exp/log"
        },
        {
          "chunk": "multiply_divide_and_accumulator_algorithms",
          "topic": "relies on multiply/divide primitives for series operations"
        }
      ]
    },
    {
      "start": 5138,
      "end": 5242,
      "name": "basic_warm_and_cold_start_initialisation",
      "description": "BASIC warm and cold start sequences and low-level initialization: warm start entry clears I/O channels and resets execution (handling interrupts), cold start calls routines to initialize BASIC vectors and RAM tables, prints start-up banner, sets stack pointer, and installs the zero-page character-getting stub into page zero. Also includes setting default BASIC vectors and USR()/conversion vector defaults.",
      "references": [
        {
          "chunk": "startup_message_and_memory_initialization",
          "topic": "cold start prints the startup banner and computes free memory"
        },
        {
          "chunk": "basic_vectors_and_startup_messages",
          "topic": "vector table bytes copied into RAM during initialization"
        }
      ]
    },
    {
      "start": 5243,
      "end": 5261,
      "name": "startup_message_and_memory_initialization",
      "description": "Print startup message and initialize memory pointers: compute bytes free (end - start addresses), print '**** COMMODORE 64 BASIC V2 ****' followed by 'BYTES FREE', then branch to NEW/CLEAR/RESTORE entry. Validates available memory for BASIC and calls the routines to clear and prepare BASIC program area.",
      "references": [
        {
          "chunk": "basic_warm_and_cold_start_initialisation",
          "topic": "invoked during cold start to present the banner & memory info"
        }
      ]
    },
    {
      "start": 5262,
      "end": 5290,
      "name": "basic_vectors_initialisation_and_startup_messages",
      "description": "BASIC vector bytes and startup messages: table of vector bytes (copied to $0300..), the code copying those vectors into RAM, and the startup message data (strings for banner, READY messages, and formatting characters). Prepares the in-RAM vectors used by BASIC runtime.",
      "references": [
        {
          "chunk": "basic_warm_and_cold_start_initialisation",
          "topic": "initialises vectors during cold start"
        }
      ]
    },
    {
      "start": 5291,
      "end": 5367,
      "name": "io_helpers_rs232_colour_and_cursor_base",
      "description": "I/O helpers, RS232 parity/start-bit handling, colour RAM helper, waiting for STOP-key, baud table and small hardware helpers: wrappers to open output channels, RS232 start-bit/parity flagging, save current colour to colour RAM, wait routine sampling keyboard/jiffy clock, baud rate table for PAL, and routines returning base address of I/O devices and screen geometry and read/set cursor position helper.",
      "references": [
        {
          "chunk": "basic_io_wrappers_and_error_handler",
          "topic": "open/close wrappers interact with channel open helpers"
        },
        {
          "chunk": "screen_keyboard_init_and_input_handling",
          "topic": "cursor/screen geometry helpers used by screen routines"
        }
      ]
    },
    {
      "start": 5368,
      "end": 5386,
      "name": "initialise_screen_and_keyboard_defaults",
      "description": "Initial setup of screen/keyboard state: calls VIC init, clears shift-mode switch and cursor blink phase, sets keyboard decode pointer, keyboard buffer size and repeat counters, default text colour, repeat speed and cursor flash timing/enable.",
      "references": [
        {
          "chunk": "initialise_vic_chip_registers",
          "topic": "VIC-II register initialization values and loop"
        },
        {
          "chunk": "build_line_start_table_and_clear_screen",
          "topic": "next step: build line-start table and clear the screen"
        }
      ]
    },
    {
      "start": 5387,
      "end": 5407,
      "name": "build_line_start_table_and_clear_screen",
      "description": "Constructs the start-of-line table for the 25 logical lines (marks line starts with high bit set), computes line pointers by adding the line length, writes an end-of-table marker, then loops to clear each screen line by calling the clear-screen-line routine 25 times.",
      "references": [
        {
          "chunk": "initialise_screen_and_keyboard_defaults",
          "topic": "prior keyboard/screen defaults"
        },
        {
          "chunk": "home_cursor_and_compute_line_pointers",
          "topic": "after clearing, home cursor and set pointers for cursor row/column"
        }
      ]
    },
    {
      "start": 5408,
      "end": 5438,
      "name": "home_cursor_and_compute_line_pointers",
      "description": "Homes the cursor (sets cursor row/column to zero) and computes screen pointers for the cursor position: iterates through logical-line pointers to convert row/column into screen memory addresses, handles logical-line start markers, and calls the screen-address fetch routine before returning.",
      "references": [
        {
          "chunk": "build_line_start_table_and_clear_screen",
          "topic": "uses the line-start table created earlier"
        },
        {
          "chunk": "initialise_vic_chip_registers",
          "topic": "VIC initialization called earlier during overall init"
        }
      ]
    },
    {
      "start": 5439,
      "end": 5444,
      "name": "orphan_bytes_and_reinitialise_sequence",
      "description": "Small sequence containing an apparent NOP (or orphan byte) followed by a call to the VIC initialization routine and a jump to the cursor-home routine \u2014 likely a short reinitialisation/entry path.",
      "references": [
        {
          "chunk": "initialise_vic_chip_registers",
          "topic": "calls the VIC init routine"
        },
        {
          "chunk": "home_cursor_and_compute_line_pointers",
          "topic": "jumps to the home-cursor routine"
        }
      ]
    },
    {
      "start": 5445,
      "end": 5455,
      "name": "initialise_vic_chip_registers",
      "description": "Initialises VIC-II: sets input/output devices (screen as output, keyboard as input) and writes a table of initialisation values into VIC-II registers via a loop that copies from a ROM table into the chip's registers.",
      "references": [
        {
          "chunk": "initialise_screen_and_keyboard_defaults",
          "topic": "called from overall initialisation"
        },
        {
          "chunk": "orphan_bytes_and_reinitialise_sequence",
          "topic": "entry path that calls this routine"
        }
      ]
    },
    {
      "start": 5456,
      "end": 5469,
      "name": "keyboard_buffer_read_and_shift",
      "description": "Reads a character from the keyboard buffer: moves bytes down the buffer (shifts out the first byte), decrements the buffer index, copies the current key into A, reenables interrupts, and flags that a byte was obtained.",
      "references": [
        {
          "chunk": "wait_for_key_and_autoload_run_sequence",
          "topic": "used by the wait-for-key loop"
        },
        {
          "chunk": "input_from_screen_or_keyboard_loop",
          "topic": "related input-processing routines that consume buffer data"
        }
      ]
    },
    {
      "start": 5470,
      "end": 5502,
      "name": "wait_for_key_and_autoload_run_sequence",
      "description": "Saves/outputs a character (calls the output routine) then waits for a key: disables cursor flashing and autoscroll while the keyboard buffer contains characters, handles overwriting the cursor-phase character, calls the keyboard-buffer read routine, detects the [SHIFT][RUN] special key sequence and, if present, fills the keyboard buffer with the automatic LOAD/CR/RUN/CR sequence for autoloading programs.",
      "references": [
        {
          "chunk": "keyboard_buffer_read_and_shift",
          "topic": "invokes the buffer-read routine to get keys"
        },
        {
          "chunk": "write_character_unshifted_and_control_dispatch",
          "topic": "calls the character output routine before waiting"
        }
      ]
    },
    {
      "start": 5503,
      "end": 5520,
      "name": "process_carriage_return_trim_spaces_prepare_input",
      "description": "Handles a carriage return key: distinguishes CR from other keys, trims trailing spaces from the current input line stored on screen (decrements end-of-line pointer past trailing spaces), records the input EOL pointer and clears input-from-screen flag and quote flag in preparation for executing the input.",
      "references": [
        {
          "chunk": "wait_for_key_and_autoload_run_sequence",
          "topic": "entered after key retrieval when CR is detected"
        },
        {
          "chunk": "set_input_cursor_pointers_and_bounds_check",
          "topic": "next: determine input cursor position to decide source"
        }
      ]
    },
    {
      "start": 5521,
      "end": 5531,
      "name": "set_input_cursor_pointers_and_bounds_check",
      "description": "Checks the input cursor row/column against internal logical-line pointers: determines whether the input came from the screen or keyboard by comparing the saved input cursor row to current pointers, saves cursor column if within bounds, and branches depending on position (inside line vs beyond end-of-line).",
      "references": [
        {
          "chunk": "process_carriage_return_trim_spaces_prepare_input",
          "topic": "called after trimming and preparing input"
        },
        {
          "chunk": "input_from_screen_or_keyboard_loop",
          "topic": "enters the main input-from-screen handling if relevant"
        }
      ]
    },
    {
      "start": 5532,
      "end": 5580,
      "name": "input_from_screen_or_keyboard_loop",
      "description": "Main routine for reading input either from the screen or waiting for a keyboard key: saves registers, branches to keyboard wait if needed, reads the character under the cursor from screen memory, masks and tests it for 'no key', handles quote mode and open-quote toggling, advances cursor column, may convert a screen-read into a CR (end of input) and route output accordingly, restores registers and returns with the character in A.",
      "references": [
        {
          "chunk": "keyboard_buffer_read_and_shift",
          "topic": "used when input source is the keyboard"
        },
        {
          "chunk": "toggle_open_quote_flag",
          "topic": "calls the quote-toggle helper when encountering a \" character"
        },
        {
          "chunk": "output_character_unshifted_and_control_dispatch",
          "topic": "outputs characters or handles CR when required"
        }
      ]
    },
    {
      "start": 5581,
      "end": 5590,
      "name": "toggle_open_quote_flag",
      "description": "Subroutine to detect the double-quote character (\"), toggle the cursor's quote-mode flag and return the quote character in A; used to enter/exit quote mode when typing or reading from screen.",
      "references": [
        {
          "chunk": "input_from_screen_or_keyboard_loop",
          "topic": "called when an open-quote is encountered"
        },
        {
          "chunk": "insert_uppercase_graphic_character",
          "topic": "quote mode affects how characters are inserted"
        }
      ]
    },
    {
      "start": 5591,
      "end": 5615,
      "name": "insert_uppercase_graphic_character",
      "description": "Handles insertion of printable characters: converts to uppercase/graphic set, respects reverse flag (inserts reversed characters), decrements insert-count if in insert mode, gets current colour and prints the character with that colour, advances the cursor and restores registers; clears the quote flag unless further inserts remain.",
      "references": [
        {
          "chunk": "toggle_open_quote_flag",
          "topic": "quote mode influences inserted characters"
        },
        {
          "chunk": "advance_cursor_autoscroll_and_newline_handling",
          "topic": "calls the cursor-advance routine after printing"
        }
      ]
    },
    {
      "start": 5616,
      "end": 5660,
      "name": "advance_cursor_autoscroll_and_newline_handling",
      "description": "Advances the logical cursor column and handles line wrap/scroll: tests if the cursor exceeded the current line length, handles maximum column wrap (back up and newline), checks autoscroll flag and either inserts/open-space on-screen or triggers screen scrolling, updates logical-line pointers and line length, computes new screen address pointers and handles newline behavior.",
      "references": [
        {
          "chunk": "insert_uppercase_graphic_character",
          "topic": "called after printing to advance the cursor"
        },
        {
          "chunk": "back_to_previous_line_logic",
          "topic": "used when needing to move up a line"
        }
      ]
    },
    {
      "start": 5661,
      "end": 5673,
      "name": "back_to_previous_line_logic",
      "description": "Attempts to move the cursor to the previous line: if already at top row it clears column and restores registers (popping saved return address), otherwise decrements row, recalculates screen pointers for the new row and stores the cursor column.",
      "references": [
        {
          "chunk": "advance_cursor_autoscroll_and_newline_handling",
          "topic": "used when characters push cursor backward across lines"
        },
        {
          "chunk": "home_cursor_and_compute_line_pointers",
          "topic": "related pointer computations for cursor positioning"
        }
      ]
    },
    {
      "start": 5674,
      "end": 5701,
      "name": "output_character_unshifted_and_control_dispatch",
      "description": "Outputs a character to the screen (unshifted path): saves registers and character, handles shifted-character dispatch (jumps to shifted handler), checks for CR to route to CR handler, processes printable range and quote toggling, and dispatches to other handlers for control characters if character is below SPACE.",
      "references": [
        {
          "chunk": "insert_uppercase_graphic_character",
          "topic": "alternative insert code (shifted route) for some characters"
        },
        {
          "chunk": "special_character_handling_and_insert_delete_branch",
          "topic": "further handling for control codes and special keys"
        }
      ]
    },
    {
      "start": 5702,
      "end": 5733,
      "name": "insert_delete_close_line_and_clear_last_char",
      "description": "Handles [INSERT]/[DELETE] control behavior: supports inserting reversed characters, tests for line-wrap/back-to-previous-line, shifts characters left to close up a deleted position across the line (moving both screen character bytes and colour RAM bytes), clears the last character on the line to SPACE and sets its colour, and returns appropriately.",
      "references": [
        {
          "chunk": "output_character_unshifted_and_control_dispatch",
          "topic": "invoked when control character is insert/delete"
        },
        {
          "chunk": "advance_cursor_autoscroll_and_newline_handling",
          "topic": "may call back to newline logic when moving across lines"
        }
      ]
    },
    {
      "start": 5734,
      "end": 5776,
      "name": "reverse_clear_home_and_cursor_movement",
      "description": "Handles various control keys: toggles reverse-video flag, executes CLR/HOME to home the cursor, processes CURSOR RIGHT (increment column and test line wrap/newline), processes CURSOR DOWN (increment row and adjust column within logical start boundaries), and sets colours or jumps to special-character checks as needed.",
      "references": [
        {
          "chunk": "insert_delete_close_line_and_clear_last_char",
          "topic": "shares handling of insert/delete and line adjustments"
        },
        {
          "chunk": "output_character_unshifted_and_control_dispatch",
          "topic": "continues dispatch for other control characters"
        }
      ]
    },
    {
      "start": 5777,
      "end": 5800,
      "name": "special_character_handling_and_insert_delete_branch",
      "description": "Final special-character handling: sets the colour code, masks high bit of character bytes to canonical ranges, handles $FF mapping to $5E, distinguishes printable vs control ranges, dispatches to insertion/shift/quote logic or to CR/insert-delete handling, and branches into the insert/delete processing path when appropriate.",
      "references": [
        {
          "chunk": "output_character_unshifted_and_control_dispatch",
          "topic": "continues handling for characters and decides where to route them"
        },
        {
          "chunk": "insert_delete_close_line_and_clear_last_char",
          "topic": "branches here when detecting insert/delete in non-quote mode"
        }
      ]
    },
    {
      "start": 5801,
      "end": 5827,
      "name": "insert_space_and_shift_screen_line",
      "description": "Open a space on the current screen line for inserting a character. Compares cursor column with max line length, calls the open-space routine, computes pointers, shifts characters and colour-ram bytes right along the line (using indirect indexed loads/stores), writes a space at the cursor position, stores the current colour code to colour RAM, increments the insert count, and branches to restore/exit. Also tests the insert count and branches to insert-a-reversed-character routine if needed.",
      "references": [
        {
          "chunk": "input_control_cursor_up_left_and_clear",
          "topic": "dispatches that may call this insert/shift code"
        },
        {
          "chunk": "set_colour_code",
          "topic": "colour code is saved to $0286 and used when inserting"
        }
      ]
    },
    {
      "start": 5828,
      "end": 5863,
      "name": "input_control_cursor_up_left_and_clear",
      "description": "Handle several input/control codes and cursor operations. Compares the input with control codes: CURSOR UP (move up a line, wrap to previous line if needed), toggles/clears the reverse flag (RVS OFF), handles CURSOR LEFT (moves left, possibly back to previous line via a line-decrement test), and handles CLR (clear screen). Restores b7 in A and calls the set-colour routine before jumping to the special-character handler.",
      "references": [
        {
          "chunk": "insert_space_and_shift_screen_line",
          "topic": "insert handling and insert-count test that may follow input handling"
        },
        {
          "chunk": "newline_and_carriage_return_handling",
          "topic": "cursor movement and newline interactions"
        },
        {
          "chunk": "set_colour_code",
          "topic": "called to set the colour code for the character"
        }
      ]
    },
    {
      "start": 5864,
      "end": 5885,
      "name": "newline_and_carriage_return_handling",
      "description": "Newline (line-feed) and carriage-return handling. Implements the newline routine: shifts the input cursor row, increments the cursor row, checks for last row and calls the screen-scroll routine if necessary, finds the start-of-logical-line pointer for the new row and sets screen pointers (JSR $E56C). Also implements CR output: clears insert count, reverse flag and quote-flag, resets cursor column and calls the newline routine, then restores registers and exits.",
      "references": [
        {
          "chunk": "scroll_screen_and_adjust_line_pointers",
          "topic": "scrolls the screen when newline reaches bottom"
        },
        {
          "chunk": "test_for_line_decrement",
          "topic": "used when moving left across line boundaries"
        },
        {
          "chunk": "test_for_line_increment_and_end_of_line",
          "topic": "used when moving right/end-of-line logic is required"
        }
      ]
    },
    {
      "start": 5886,
      "end": 5897,
      "name": "test_for_line_decrement",
      "description": "Routine that tests whether the cursor should move to the previous line when decrementing. Compares provided column with the cursor column and, if at line start, decrements the cursor row. Otherwise performs two iterations of adding one line length (ADC #$28) to test crossing line boundaries and returns.",
      "references": [
        {
          "chunk": "newline_and_carriage_return_handling",
          "topic": "called when cursor-left reaches start-of-line to move up a line"
        },
        {
          "chunk": "test_for_line_increment_and_end_of_line",
          "topic": "counterpart routine for testing line increment when moving right"
        }
      ]
    },
    {
      "start": 5898,
      "end": 5918,
      "name": "test_for_line_increment_and_end_of_line",
      "description": "Routine that tests whether the cursor should move to the next line when at end-of-line. Compares with a target column, does looped ADC #$28 tests, and if the cursor is at the end-of-line increments the cursor row unless already at the bottom of the screen. Returns to caller after updating the cursor row as necessary.",
      "references": [
        {
          "chunk": "test_for_line_decrement",
          "topic": "inverse test for moving between lines when cursor moves left"
        },
        {
          "chunk": "newline_and_carriage_return_handling",
          "topic": "newline logic that may call the scroll routine when incrementing past the bottom"
        }
      ]
    },
    {
      "start": 5919,
      "end": 5930,
      "name": "set_colour_code",
      "description": "Set the current colour code based on the character in A. Compares A against a table of ASCII colour codes (searching up to 0x0F entries). If a match is found, stores the resulting colour code into $0286; otherwise returns without changing the colour.",
      "references": [
        {
          "chunk": "ascii_colour_code_table",
          "topic": "the table of ASCII-to-colour mappings used by this routine"
        },
        {
          "chunk": "input_control_cursor_up_left_and_clear",
          "topic": "caller that invokes this routine to set colour from input"
        }
      ]
    },
    {
      "start": 5931,
      "end": 5950,
      "name": "ascii_colour_code_table",
      "description": "ASCII-to-colour lookup table used by the set-colour routine (addresses E8DA-E8E9). Lists the file bytes that map CHR$() codes to C64 colour values (black, white, red, cyan, purple, green, blue, yellow, orange, brown, light red, dark grey, medium grey, light green, light blue, light grey).",
      "references": [
        {
          "chunk": "set_colour_code",
          "topic": "routine that scans this table to set $0286"
        }
      ]
    },
    {
      "start": 5951,
      "end": 6000,
      "name": "scroll_screen_and_adjust_line_pointers",
      "description": "Screen-scrolling routine. Saves tape buffer start/end pointers on the stack, adjusts cursor and input-row markers, decrements the screen-row marker, loops to fetch screen addresses (JSR $E9F0), shifts screen lines up (JSR $E9C8), clears the last screen line (JSR $E9FF), then adjusts the start-of-logical-line bits in the start-of-line pointer tables (D9/DA), marks the last line as a logical start, loops to handle multi-line scrolls, restores/increments cursor and row markers, and finally updates keyboard column drive via VIA writes and reads the keyboard row port. Ensures tape pointers are preserved across the scroll.",
      "references": [
        {
          "chunk": "newline_and_carriage_return_handling",
          "topic": "calls this routine when newline reaches the bottom of the screen"
        },
        {
          "chunk": "insert_space_and_shift_screen_line",
          "topic": "shares line/colour RAM shifting concepts (but operates across whole screen lines)"
        },
        {
          "chunk": "set_colour_code",
          "topic": "colour state preserved while scrolling"
        }
      ]
    },
    {
      "start": 6001,
      "end": 6021,
      "name": "wait_delay_and_restore_tape_pointers",
      "description": "End-of-wait routine: restores processor status (PLP), conditionally performs a two-level delay loop (nested X/Y loops), clears the keyboard buffer index ($C6), reads the cursor row ($D6), then restores the tape buffer pointers ($AC-$AF) from the stack (PLA/STA) and returns (RTS).",
      "references": [
        {
          "chunk": "open_up_space_on_screen",
          "topic": "Uses the cursor row ($D6) and is followed by the open-up-space routine"
        }
      ]
    },
    {
      "start": 6022,
      "end": 6073,
      "name": "open_up_space_on_screen",
      "description": "Routine to open a space on the screen at the cursor row: increments the cursor row, looks up the start-of-line pointers (RAM/ROM tables), compares with the last line logic, either scrolls the screen (JSR $E8EA / JSR $E9C8) or clears a line (JSR $E9FF). Temporarily pushes tape buffer pointers to the stack while scanning/adjusting lines, updates the cursor row ($D6), and finally restores tape pointers and exits. Handles logical line marker ($02A5) and uses line pointer tables at $D9/$DA and ROM table at $ECEF.",
      "references": [
        {
          "chunk": "fetch_screen_address",
          "topic": "Called (JSR) to fetch a screen line start address used here"
        },
        {
          "chunk": "shift_screen_line_up_down",
          "topic": "Called (JSR $E9C8) to copy character/colour bytes between lines when scrolling"
        },
        {
          "chunk": "clear_screen_line_x",
          "topic": "Called to clear a full screen line when needed"
        },
        {
          "chunk": "calc_screen_line_colour_pointers_e9e0",
          "topic": "Called to compute the colour-RAM pointers for the source/target lines"
        },
        {
          "chunk": "wait_delay_and_restore_tape_pointers",
          "topic": "Earlier routine that restores tape pointers and returns; related flow"
        }
      ]
    },
    {
      "start": 6074,
      "end": 6087,
      "name": "shift_screen_line_up_down",
      "description": "Copies a whole 40-column screen line from a source (next/previous) to the current line: masks the line page (AND #$03), composes the source high byte (ORA $0288), saves source pointer high byte ($AD), calls a colour-pointer helper (JSR $E9E0) to set up colour RAM pointers, then loops 40 bytes (LDY #$27 down to 0) performing LDA ($AC),Y -> STA ($D1),Y for characters and LDA ($AE),Y -> STA ($F3),Y for colours. Returns (RTS).",
      "references": [
        {
          "chunk": "calc_screen_line_colour_pointers_e9e0",
          "topic": "Computes the colour-RAM pointers for the source line (JSR $E9E0)"
        },
        {
          "chunk": "fetch_screen_address",
          "topic": "Uses and updates indirect pointers ($AC/$AE / $D1/$D2) that are fetched elsewhere"
        }
      ]
    },
    {
      "start": 6088,
      "end": 6098,
      "name": "calc_screen_line_colour_pointers_e9e0",
      "description": "Helper (at $E9E0) that prepares the colour-RAM pointer corresponding to a given screen line pointer: calls EA24 to compute the base colour pointer, copies the source line pointer low byte ($AC) into $AE, masks the source high byte ($AD) to the 0-3 page (AND #$03), ORA #$D8 to map to the colour memory page, and stores the high byte into $AF. Returns (RTS).",
      "references": [
        {
          "chunk": "calculate_colour_ram_pointer_ea24",
          "topic": "Calls this routine (JSR $EA24) to compute the current screen line colour-RAM pointer; this helper adapts it for the source/target line"
        },
        {
          "chunk": "shift_screen_line_up_down",
          "topic": "Used by the line-shift routine to set the colour RAM pointers before copying bytes"
        }
      ]
    },
    {
      "start": 6099,
      "end": 6107,
      "name": "fetch_screen_address",
      "description": "Fetches a screen line start address for a given line index: reads low byte from the ROM table (LDA $ECF0,X -> $D1), reads high byte from RAM table ($D9,X), masks it to the 0-3 page (AND #$03), ORs with the screen memory page (ORA $0288), and stores the result as the current screen line pointer high byte ($D2). Returns (RTS).",
      "references": [
        {
          "chunk": "open_up_space_on_screen",
          "topic": "Used to resolve screen line addresses while opening a space"
        },
        {
          "chunk": "clear_screen_line_x",
          "topic": "Called before clearing a line to initialize the line pointer"
        }
      ]
    },
    {
      "start": 6108,
      "end": 6118,
      "name": "clear_screen_line_x",
      "description": "Clears a full screen line to spaces: sets Y counter to 39 (LDY #$27), fetches the screen address (JSR $E9F0), computes the colour-RAM pointer (JSR $EA24), saves the current colour to colour RAM (JSR $E4DA), loads the ASCII for space (LDA #$20) and stores it across the line via STA ($D1),Y while decrementing Y. Returns (RTS).",
      "references": [
        {
          "chunk": "fetch_screen_address",
          "topic": "Initializes the ($D1/$D2) pointer used to write the spaces"
        },
        {
          "chunk": "calculate_colour_ram_pointer_ea24",
          "topic": "Computes colour-RAM pointer for the current line before writing colours"
        }
      ]
    },
    {
      "start": 6119,
      "end": 6121,
      "name": "orphan_nop_ea12",
      "description": "Single-byte unused/orphan NOP at $EA12. No functional effect; likely padding in ROM.",
      "references": [
        {
          "chunk": "print_and_store_char_and_colour_at_cursor",
          "topic": "This NOP sits immediately before the print/save character routine"
        }
      ]
    },
    {
      "start": 6122,
      "end": 6135,
      "name": "print_and_store_char_and_colour_at_cursor",
      "description": "Print routine: copies the character (A) to Y (TAY), initializes a cursor countdown ($CD) for repeat timing, calculates the colour-RAM pointer (JSR $EA24), restores the character (TYA), then saves the character at the cursor column via STA ($D1),Y and stores the colour from X (TXA -> STA ($F3),Y). Returns (RTS).",
      "references": [
        {
          "chunk": "calculate_colour_ram_pointer_ea24",
          "topic": "Called to compute the colour-RAM pointer for the current line before storing the colour byte"
        }
      ]
    },
    {
      "start": 6136,
      "end": 6144,
      "name": "calculate_colour_ram_pointer_ea24",
      "description": "EA24: Computes the colour-RAM pointer for the current screen line: reads current screen line pointer low/high ($D1/$D2), saves low into $F3, masks the high byte to line page (AND #$03), ORs with the colour memory page (ORA #$D8), and saves the resulting high byte to $F4. Returns (RTS).",
      "references": [
        {
          "chunk": "shift_screen_line_up_down",
          "topic": "This routine is called (JSR) by the line-shift routine to set colour pointers"
        },
        {
          "chunk": "clear_screen_line_x",
          "topic": "Used when clearing a line to compute where to store colours"
        },
        {
          "chunk": "print_and_store_char_and_colour_at_cursor",
          "topic": "Used to compute the colour RAM pointer before storing the colour at the cursor"
        }
      ]
    },
    {
      "start": 6145,
      "end": 6191,
      "name": "irq_handler_and_cassette_motor_control",
      "description": "IRQ entry (EA31..EA86): increments the real-time clock (JSR $FFEA), handles cursor flashing (examines cursor enable $CC, decrements countdown $CD, toggles cursor phase $CF, saves/restores character under cursor $CE/$0287 and toggles bit 7 of that character, then calls the save-character routine to update the display), manages cassette motor control by reading 6510 port $01 and cassette sense bits (sets/clears motor bit $20 and interlock $C0), calls the keyboard scan routine (JSR $EA87), clears VIA ICR (LDA $DC0D), restores registers (PLA/TAY/TAX/PLA) and returns from interrupt (RTI).",
      "references": [
        {
          "chunk": "print_and_store_char_and_colour_at_cursor",
          "topic": "Called (JSR $EA1C) to write the toggled cursor-character and colour to screen"
        },
        {
          "chunk": "calculate_colour_ram_pointer_ea24",
          "topic": "Uses this helper (JSR $EA24) when manipulating the cursor colour byte"
        },
        {
          "chunk": "keyboard_scan_overview",
          "topic": "Calls the keyboard scan routine (JSR $EA87) described next"
        }
      ]
    },
    {
      "start": 6192,
      "end": 6200,
      "name": "keyboard_scan_overview",
      "description": "Commented overview of the keyboard-scan routine: describes steps performed by the scanner \u2014 1) test if any key is pressed and exit if none, 2) initialize I/O ports and set pointers to decode table 1 and clear character counter, 3) drive one line of port B low and test port A for closed key by shifting the byte read and checking carry; if carry clear then a key is closed and should be processed. (This is the explanatory comment immediately following the IRQ handler.)",
      "references": [
        {
          "chunk": "irq_handler_and_cassette_motor_control",
          "topic": "IRQ handler calls the keyboard-scan routine (JSR $EA87) described by this overview"
        },
        {
          "chunk": "open_up_space_on_screen",
          "topic": "Keyboard-scanning and cursor behavior interact with screen update routines described elsewhere"
        }
      ]
    },
    {
      "start": 6201,
      "end": 6320,
      "name": "keyboard_scan_entry_ea87_to_eb47",
      "description": "Keyboard scan entry starting at $EA87: overview of scan steps and full scan routine. Clears keyboard flags ($028D), drives VIA1 DRA ($DC00) and reads VIA1 DRB ($DC01) to detect rows/columns, iterates columns and rows, counts closed keys (saved to $CB), handles special SHIFT/CTRL/CBM/STOP keys by ORing into $028D, saves and restores column/row state, evaluates key decode (via tables pointed at by $F5/$F6), compares key count with last key ($C5) and handles repeat logic (repeat delay at $028C, repeat speed at $028B), and saves decoded character into keyboard buffer $0277 using buffer index $C6 if appropriate. Ends with RTS at $EB47.",
      "references": [
        {
          "chunk": "evaluate_shift_ctrl_c_keys_eb48_to_eb76",
          "topic": "evaluating SHIFT/CTRL/C= and selecting decode table"
        },
        {
          "chunk": "key_decode_tables_eb79_ec43",
          "topic": "character decode tables used by this routine (standard/shift/cbm/control)"
        },
        {
          "chunk": "special_character_codes_ec44_to_ec5e",
          "topic": "special character handling (switch upper/lower case, SHIFT+C= lock)"
        }
      ]
    },
    {
      "start": 6321,
      "end": 6344,
      "name": "evaluate_shift_ctrl_c_keys_eb48_to_eb76",
      "description": "Evaluate SHIFT/CTRL/C= state ($028D) and act on changes. Checks for SHIFT+C= combination and toggles character memory base ($D018) when the shift-mode switch is enabled; respects a locked shift-mode switch ($0291). Selects the appropriate decode table index (modifies the index if CTRL pressed), then loads the table pointer low/high into $F5/$F6 from the table-address block and jumps back into the main decode path ($EAE0) to continue key decoding.",
      "references": [
        {
          "chunk": "keyboard_scan_entry_ea87_to_eb47",
          "topic": "main scan routine that calls/evaluates this logic"
        },
        {
          "chunk": "key_decode_tables_eb79_ec43",
          "topic": "table pointers read by this code"
        },
        {
          "chunk": "special_character_codes_ec44_to_ec5e",
          "topic": "SHIFT+C= behavior and locking interacts with case switching"
        }
      ]
    },
    {
      "start": 6345,
      "end": 6381,
      "name": "key_decode_tables_eb79_ec43",
      "description": "Character decode table pointers and the decode tables themselves. Provides the table-address block at $EB79 (pointers for standard, shift, commodore, control) followed by: the standard key decode table (bytes at $EB81..$EBC1), the shifted key table ($EBC2..$EC02), and the CBM-key table ($EC03..$EC43). Each table ends with $FF as an end marker. These tables map keyboard matrix counts to PETSCII/scan codes used by the keyboard routine.",
      "references": [
        {
          "chunk": "keyboard_scan_entry_ea87_to_eb47",
          "topic": "uses the decode tables via pointers in $F5/$F6 to convert key counts to characters"
        },
        {
          "chunk": "evaluate_shift_ctrl_c_keys_eb48_to_eb76",
          "topic": "selects which of these tables to use"
        },
        {
          "chunk": "special_character_codes_ec44_to_ec5e",
          "topic": "some decoded codes are handled specially (case switching, SHIFT+C=)"
        }
      ]
    },
    {
      "start": 6382,
      "end": 6400,
      "name": "special_character_codes_ec44_to_ec5e",
      "description": "Checks for special decoded character codes after table lookup. Handles SWITCH TO LOWER CASE ($0E) and SWITCH TO UPPER CASE ($8E) by adjusting the character memory base ($D018) to point to lower- or upper-case character sets. Also handles the [SHIFT]+[C=] disable/lock check (compares with $08 and sets the lock bit when applicable). On change, saves new $D018 and branches to restore registers and set quote flag before exiting.",
      "references": [
        {
          "chunk": "key_decode_tables_eb79_ec43",
          "topic": "these special codes are values produced by the decode tables"
        },
        {
          "chunk": "evaluate_shift_ctrl_c_keys_eb48_to_eb76",
          "topic": "SHIFT+C= handling interacts with locking/toggling behavior"
        }
      ]
    },
    {
      "start": 6401,
      "end": 6408,
      "name": "shift_c_lock_handling",
      "description": "6502 code that implements SHIFT+C= handling: tests and toggles the shift-mode lock bit at zero page address $0291 (ORA/AND/STA $0291), compares with the enable code (#$09), sets unlock value (#$7F) when appropriate, and returns (JMP $E6A8). Restores registers and sets the quote flag as part of exiting.",
      "references": [
        {
          "chunk": "control_keyboard_table",
          "topic": "control-key mapping used when SHIFT/C= or other control keys interpreted"
        },
        {
          "chunk": "vicii_initialization_values",
          "topic": "context: screen/keyboard initialization sequence in ROM"
        }
      ]
    },
    {
      "start": 6409,
      "end": 6419,
      "name": "control_keyboard_table",
      "description": "Control-key decode table data bytes located at $EC78-$ECB8. Provides the mapping used by the keyboard routine for control-key combinations. The data bytes are presented in table form (including FF markers).",
      "references": [
        {
          "chunk": "shift_c_lock_handling",
          "topic": "invoked or consulted when control key sequences like SHIFT+C= are processed"
        },
        {
          "chunk": "auto_load_run_keyboard_buffer",
          "topic": "keyboard buffer format and sample entries for auto load/run"
        }
      ]
    },
    {
      "start": 6420,
      "end": 6497,
      "name": "vicii_initialization_values",
      "description": "VIC-II chip initialization bytes beginning at $ECB9. Includes sprite X,Y positions for sprites 0-7, sprite X high bits ($ECC9), control register settings (screen enable, 25/24 rows, bitmap/multicolor/text modes, vertical/horizontal fine scroll control), raster compare ($ECCB), light-pen coords ($ECCC-$ECCD), sprite enable/expand/multicolour/priority/collision registers ($ECCE-$ECD0,$ECD1-$ECD8), interrupt clear/enable bytes ($ECD2-$ECD3) and default border/background/sprite colours ($ECD9-$ECE6). Also notes that sprite 7 colour byte coincides with ASCII 'L' of the string 'LOAD'.",
      "references": [
        {
          "chunk": "screen_line_address_low_bytes",
          "topic": "screen memory mapping and line addresses used with VIC-II initialization"
        },
        {
          "chunk": "auto_load_run_keyboard_buffer",
          "topic": "the 'LOAD' token referenced in sprite 7 colour overlaps the auto load/run buffer"
        }
      ]
    },
    {
      "start": 6498,
      "end": 6501,
      "name": "auto_load_run_keyboard_buffer",
      "description": "Keyboard buffer data used for automatic LOAD/ RUN processing. Contains the ASCII/token sequence 'LOAD<CR>RUN<CR>' starting at $ECE7 (bytes 4C 4F 41 44 0D 52 55 4E ...).",
      "references": [
        {
          "chunk": "vicii_initialization_values",
          "topic": "sprite 7 colour byte overlaps the first character of the 'LOAD' buffer"
        },
        {
          "chunk": "control_keyboard_table",
          "topic": "control-key decoding can influence automatic keyboard sequences"
        }
      ]
    },
    {
      "start": 6502,
      "end": 6507,
      "name": "screen_line_address_low_bytes",
      "description": "Table of low bytes for the start addresses of each screen line (low-order bytes of line base addresses). Data present at $ECF0-$ED08 for 25/24 row display mapping (00,28,50,78,A0,C8,F0,18,40,68,90,B8,E0,08,30,58,80,A8,D0,F8,20,48,70,98,C0...).",
      "references": [
        {
          "chunk": "vicii_initialization_values",
          "topic": "used by VIC-II during screen initialization/memory layout"
        }
      ]
    },
    {
      "start": 6508,
      "end": 6527,
      "name": "serial_bus_commands_and_send_control_character",
      "description": "Helpers for serial bus device commands: ORA #$40 to set TALK ($ED09), a byte token (.BYTE $2C) used for a following BIT, ORA #$20 to set LISTEN ($ED0C), and a JSR to check RS-232 bus idle ($F0A4). Also includes the 'send a control character' sequence beginning at $ED11: PHA to save device address, test deferred character flag (BIT $94), set EOI if deferred, call Tx byte routine ($ED40), and clear deferred/EOI flags before restoring device address.",
      "references": [
        {
          "chunk": "defer_serial_command_sequence",
          "topic": "deferring a command uses the same serial control primitives and flags ($94,$A3)"
        },
        {
          "chunk": "serial_tx_byte_routine",
          "topic": "calls the Tx byte routine to transmit the control character on the serial bus"
        }
      ]
    },
    {
      "start": 6528,
      "end": 6548,
      "name": "defer_serial_command_sequence",
      "description": "Sequence to defer a serial command: STA $95 to save the deferred character, SEI to disable interrupts, set serial data/clock lines (JSRs to $EE97/$EE85), compare read byte with $3F (CMP #$3F), and read VIA2 DRA ($DD00) to manipulate ATN/data/clock lines. If conditions indicate, sets ATN low (ORA #$08; STA $DD00), then disables interrupts, toggles serial clock/data lines and waits (JSR $EE8E/$EE97/$EEB3) to defer the byte transmission by ~1ms.",
      "references": [
        {
          "chunk": "serial_bus_commands_and_send_control_character",
          "topic": "deferred characters and flags ($95,$94,$A3) are set/checked when sending control characters"
        },
        {
          "chunk": "serial_tx_byte_routine",
          "topic": "after deferring, the Tx byte routine is used to transmit the deferred byte"
        }
      ]
    },
    {
      "start": 6549,
      "end": 6600,
      "name": "serial_tx_byte_routine",
      "description": "Complete routine to transmit a byte on the IEC serial bus (starts at $ED40). Disables interrupts (SEI), sets serial data out high, checks serial data status (JSR $EEA9) to detect device presence, drives serial clock high/low via JSRs ($EE85/$EE8E), tests EOI flag (BIT $A3) and implements EOI handshake (wait for data high, then low, then high), then transmits 8 LSB-first bits: set bit count (#$08 into $A5), loop reading VIA2 DRA ($DD00) for timing/line status, shift/rotate transmit byte ($95), set data line accordingly (JSR $EEA0 or $EE97), pulse clock, delay (NOPs), write back VIA2 DRA with appropriate mask (AND/ORA/STA $DD00), decrement bit count (DEC $A5) and loop until done. Also handles serial bus timeout and device-not-present conditions.",
      "references": [
        {
          "chunk": "serial_bus_commands_and_send_control_character",
          "topic": "invoked by send-control-character helper and other serial command code"
        },
        {
          "chunk": "defer_serial_command_sequence",
          "topic": "used after deferring a command to actually send the deferred byte"
        }
      ]
    },
    {
      "start": 6601,
      "end": 6623,
      "name": "serial_device_detection_and_timeout",
      "description": "Wait for serial data line to be pulled low using VIA timer B (approx 1 ms), read VIA ICR, check timer A interrupt for timeout, get serial data status, enable interrupts and return. Error handling for device not present ($80) and serial bus timeout ($03) and branching to set serial status.",
      "references": [
        {
          "chunk": "serial_pin_control_and_1ms_delay",
          "topic": "uses VIA timer B and 1ms delay helper"
        },
        {
          "chunk": "input_byte_from_serial_bus",
          "topic": "related timeout and EOI handling code"
        }
      ]
    },
    {
      "start": 6624,
      "end": 6637,
      "name": "send_secondary_address_after_listen_and_talk_set_atn",
      "description": "Save deferred transmit byte and call the routine to set serial clock/data and transmit the byte (used for sending the secondary address after LISTEN or TALK). Includes small routine to set serial ATN high via VIA 2 DRA.",
      "references": [
        {
          "chunk": "serial_pin_control_and_1ms_delay",
          "topic": "sets/reads VIA 2 DRA to control ATN/clock/data lines"
        },
        {
          "chunk": "wait_for_serial_bus_end_after_send",
          "topic": "follow-up: wait for bus end after sending"
        }
      ]
    },
    {
      "start": 6638,
      "end": 6648,
      "name": "wait_for_serial_bus_end_after_send",
      "description": "Sequence to wait for end-of-transaction on the serial bus after sending: disable interrupts, force serial data low, set ATN high, set clock high, poll serial data status until clock low/high transitions complete, then re-enable interrupts and return.",
      "references": [
        {
          "chunk": "serial_pin_control_and_1ms_delay",
          "topic": "calls routines to set data/clock lines high/low and to sample data status"
        },
        {
          "chunk": "send_secondary_address_after_listen_and_talk_set_atn",
          "topic": "used after sending secondary address bytes"
        }
      ]
    },
    {
      "start": 6649,
      "end": 6661,
      "name": "output_byte_to_serial_bus",
      "description": "Transmit a byte onto the IEC serial bus with deferred-character handling. Tests deferred flag, shifts and stores deferred character, pushes/pulls stack to call Tx routine (ED40), saves deferred Tx byte, clears/sets flags and returns.",
      "references": [
        {
          "chunk": "send_secondary_address_after_listen_and_talk_set_atn",
          "topic": "stores deferred Tx byte used by LISTEN/TALK secondary sends"
        },
        {
          "chunk": "wait_for_serial_bus_end_after_send",
          "topic": "may be followed by waiting for bus end"
        }
      ]
    },
    {
      "start": 6662,
      "end": 6683,
      "name": "command_serial_bus_to_untalk_and_unlisten",
      "description": "Issue UNTALK and UNLISTEN commands on the IEC bus: disable interrupts, pull clock low, set ATN low (UNTALK = $5F, UNLISTEN = $3F), send control character, set ATN high again, perform a short delay, then set clock/data lines high and return.",
      "references": [
        {
          "chunk": "send_secondary_address_after_listen_and_talk_set_atn",
          "topic": "similar use of deferred Tx and ATN control"
        },
        {
          "chunk": "serial_pin_control_and_1ms_delay",
          "topic": "uses routines to set clock/data lines and the 1ms delay"
        }
      ]
    },
    {
      "start": 6684,
      "end": 6738,
      "name": "input_byte_from_serial_bus",
      "description": "Read a byte from the IEC serial bus: disable interrupts, initialize bit count/timeouts, set serial clock high, start VIA timer B for a timeout, poll clock/data lines to shift bits into the receive byte, handle timer A timeout to flag EOI or read timeout ($02), increment bit count for EOI detection, final bus-end sequence if needed, restore interrupts and return received byte.",
      "references": [
        {
          "chunk": "serial_device_detection_and_timeout",
          "topic": "shares timeout and EOI handling logic using VIA timers"
        },
        {
          "chunk": "serial_pin_control_and_1ms_delay",
          "topic": "calls routines to set clock/data and to sample VIA 2 DRA for line changes"
        }
      ]
    },
    {
      "start": 6739,
      "end": 6777,
      "name": "serial_pin_control_and_1ms_delay",
      "description": "Low-level helpers for IEC serial lines and timing: set serial clock out high, set serial clock out low, set serial data out high, set serial data out low, sample serial data status into the carry, and a 1ms delay loop (saves/restores registers and uses an X loop count). These routines operate by reading/writing VIA 2 DRA.",
      "references": [
        {
          "chunk": "send_secondary_address_after_listen_and_talk_set_atn",
          "topic": "used to control ATN and to transmit secondary addresses"
        },
        {
          "chunk": "wait_for_serial_bus_end_after_send",
          "topic": "used to manage final clock/data states on bus end"
        },
        {
          "chunk": "input_byte_from_serial_bus",
          "topic": "used extensively while sampling clock/data during input"
        }
      ]
    },
    {
      "start": 6778,
      "end": 6800,
      "name": "rs232_tx_nmi_and_parity_start",
      "description": "RS232 transmit NMI handler: check RS232 bit count ($B4), handle stop bits, shift output byte buffer ($B6), set working bit value, update RS232 parity byte ($BD) via EOR, decrement bit count, handle parity bit processing when bit count reaches zero, save next data bit to $B5 and return. Begins parity handling by testing pseudo 6551 command register.",
      "references": [
        {
          "chunk": "serial_pin_control_and_1ms_delay",
          "topic": "timing and line manipulation helpers (indirectly related for serial I/O)"
        }
      ]
    },
    {
      "start": 6801,
      "end": 6831,
      "name": "rs232_transmit_parity_and_stop_bits",
      "description": "6502 code and commentary handling RS-232 parity and stop-bit insertion for transmit. Covers odd/even/fixed mark-or-space parity modes, reading the RS232 parity byte, setting/clearing the parity bit, and adjusting the RS232 bit count to account for one or two stop bits (including the special case where parity is disabled and the parity bit becomes a stop bit). References the pseudo 6551 control register at $0293 and uses parity/status flags.",
      "references": [
        {
          "chunk": "rs232_compute_bit_count",
          "topic": "how many bits are transmitted (8/7/5 data bits and stop bit adjustments)"
        },
        {
          "chunk": "rs232_setup_next_tx_byte",
          "topic": "called after parity/stop-bit processing to set up the next Tx byte"
        }
      ]
    },
    {
      "start": 6832,
      "end": 6852,
      "name": "rs232_setup_next_tx_byte",
      "description": "Set up the next transmit byte for RS-232. Reads the pseudo 6551 command register ($0294), handles handshake/3-line vs. 2-line interface, tests VIA2 DRB ($DD01) for modem signals (DSR/CTS), clears parity state and next-bit register, loads the RS-232 bit count, and fetches a byte from the transmit buffer into the RS232 output byte buffer. Disables Timer A interrupt and returns when no bytes remain.",
      "references": [
        {
          "chunk": "rs232_transmit_parity_and_stop_bits",
          "topic": "parity/stop-bit decisions applied to the byte being transmitted"
        },
        {
          "chunk": "rs232_disable_timerA_set_via2_icr",
          "topic": "disables Timer A interrupt and programs VIA2 ICR when transmit queue empty"
        },
        {
          "chunk": "rs232_send_byte_to_tx_buffer",
          "topic": "how bytes are placed into the Tx buffer that this routine consumes"
        }
      ]
    },
    {
      "start": 6853,
      "end": 6861,
      "name": "rs232_set_dsr_cts_not_present",
      "description": "Small handlers that set RS-232 DSR or CTS as 'signal not present' in the status register. Implements loading appropriate bit masks into A and OR/STA into the RS-232 status register ($0297). Contains assembler annotation bytes used by the disassembly.",
      "references": [
        {
          "chunk": "rs232_setup_next_tx_byte",
          "topic": "this routine sets these flags when DSR/CTS are not present during Tx setup"
        },
        {
          "chunk": "rs232_open_channel_for_output",
          "topic": "DSR/CTS status is also relevant when opening the RS-232 channel for output"
        }
      ]
    },
    {
      "start": 6862,
      "end": 6872,
      "name": "rs232_disable_timerA_set_via2_icr",
      "description": "Disable Timer A interrupt and program VIA2 ICR for RS-232 operation. Saves the VIA2 ICR ($DD0D), merges with the RS-232 interrupt enable byte ($02A1), ensures the interrupt-enable bit is set, and stores the updated enable byte and ICR. Ends with RTS.",
      "references": [
        {
          "chunk": "rs232_setup_next_tx_byte",
          "topic": "called when Tx buffer is drained to disable Timer A and finalize VIA2 ICR"
        },
        {
          "chunk": "rs232_setup_for_transmit",
          "topic": "related to enabling/disabling interrupts before starting transmission"
        }
      ]
    },
    {
      "start": 6873,
      "end": 6883,
      "name": "rs232_compute_bit_count",
      "description": "Compute the number of bits to be transmitted based on the pseudo 6551 control register ($0293). Defaults to 9 bits (8 data + 1 stop) and decrements for 7- or 5-bit character formats. Returns with X set to the computed bit count.",
      "references": [
        {
          "chunk": "rs232_transmit_parity_and_stop_bits",
          "topic": "uses the computed bit count when adjusting parity/stop-bit behavior"
        },
        {
          "chunk": "rs232_setup_next_tx_byte",
          "topic": "value stored to $B4 and used for per-bit transmission"
        }
      ]
    },
    {
      "start": 6884,
      "end": 6913,
      "name": "rs232_rx_nmi_bit_processing",
      "description": "RS-232 receive NMI handler and bit-processing loop. Checks start-bit flag, decrements receiver bit count, assembles incoming bits into the shift registers ($AA/$A7), updates receiver parity, and branches to continue assembling until a full byte is ready. Also contains code to re-enable FLAG interrupts and program VIA2 ICR to set up reception of the next bit, and to disable timer B while awaiting the next bit.",
      "references": [
        {
          "chunk": "rs232_no_start_bit_received",
          "topic": "handler branch when no start bit was detected"
        },
        {
          "chunk": "rs232_received_byte_buffering_and_errors",
          "topic": "when a complete byte is received it is added to the Rx buffer and validated"
        }
      ]
    },
    {
      "start": 6914,
      "end": 6918,
      "name": "rs232_no_start_bit_received",
      "description": "Handler executed when no RS-232 start bit was detected. Checks the current data bit and, if still idle, loops to the routine that sets up to receive the next RS-232 bit. If a start bit is detected it jumps to flag the start and set parity.",
      "references": [
        {
          "chunk": "rs232_rx_nmi_bit_processing",
          "topic": "this is the branch target when the NMI finds no valid start bit"
        }
      ]
    },
    {
      "start": 6919,
      "end": 6957,
      "name": "rs232_received_byte_buffering_and_errors",
      "description": "Add a fully received RS-232 byte to the Rx circular buffer and perform status/error handling. Increments/stores the Rx buffer end pointer ($029B/$029C), saves the assembled byte, checks whether 9 bits were received (data+stop) and shifts appropriately, and writes the byte into the Rx buffer. Also performs parity checking using the pseudo 6551 command register ($0294) and sets Rx error bits (parity, overrun, break, frame) in the RS-232 status register ($0297). Branches back to the receive-bit setup after handling error/status updates.",
      "references": [
        {
          "chunk": "rs232_rx_nmi_bit_processing",
          "topic": "produces the assembled byte that this routine buffers and validates"
        },
        {
          "chunk": "rs232_no_start_bit_received",
          "topic": "can be reached after error conditions to restart bit reception"
        }
      ]
    },
    {
      "start": 6958,
      "end": 6983,
      "name": "rs232_open_channel_for_output",
      "description": "Open/configure the RS-232 channel for output (RTS/CTS/DSR handshake). Saves the output device number, checks handshake mode (3-line vs 2-line), tests VIA2 DRB ($DD01) modem inputs (DSR/CTS), waits for CTS/DSR as needed, toggles RTS in VIA2 DRB, and sets the RS-232 status when DSR is not present. Returns with carry clear to indicate success.",
      "references": [
        {
          "chunk": "rs232_set_dsr_cts_not_present",
          "topic": "sets the DSR/CTS-not-present bits used here"
        },
        {
          "chunk": "rs232_send_byte_to_tx_buffer",
          "topic": "after opening, bytes are queued for transmit into the Tx buffer"
        }
      ]
    },
    {
      "start": 6984,
      "end": 6995,
      "name": "rs232_send_byte_to_tx_buffer",
      "description": "Place a byte into the RS-232 transmit circular buffer. Calls setup_for_transmit (JSR $F028), then updates the Tx buffer end pointer ($029E/$029D), checks for full buffer, and stores the byte at the buffer slot via indirect indexed addressing.",
      "references": [
        {
          "chunk": "rs232_setup_for_transmit",
          "topic": "ensures transmit machinery/timer/interrupts are started before queuing bytes"
        },
        {
          "chunk": "rs232_setup_next_tx_byte",
          "topic": "consumes bytes from the Tx buffer to build the serial bitstream"
        }
      ]
    },
    {
      "start": 6996,
      "end": 7000,
      "name": "rs232_setup_for_transmit",
      "description": "Prepare the RS-232 transmit machinery: read the RS-232 interrupt-enable byte ($02A1), shift it to carry and branch if interrupts are already enabled (no further action). Otherwise load A with the Timer A start mask (LDA #$10) to start the Timer A-based bit-bang transmit timing (next instructions beyond this chunk perform the start).",
      "references": [
        {
          "chunk": "rs232_disable_timerA_set_via2_icr",
          "topic": "counterpart that disables or programs VIA2 ICR when interrupts are cleared"
        },
        {
          "chunk": "rs232_send_byte_to_tx_buffer",
          "topic": "called before queuing a byte to ensure the transmitter is running"
        }
      ]
    },
    {
      "start": 7001,
      "end": 7012,
      "name": "rs232_tx_timer_setup_and_start",
      "description": "Initialize and start VIA 2 timer A for RS-232 transmit: save VIA CRA, load baud-rate-derived timer low/high bytes from pseudo-6551 registers ($0299/$029A) into VIA timer A ($DD04/$DD05), enable timer A interrupt, call VIA ICR setup and the next-Tx-byte setup routine, then write CRA to start the timer.",
      "references": [
        {
          "chunk": "rs232_get_byte_from_rx_buffer",
          "topic": "RS232 status & buffer layout (receiving side)"
        },
        {
          "chunk": "rs232_input_highlevel_handshake_and_interrupt_control",
          "topic": "higher-level serial input/handshake handling and ICR management"
        }
      ]
    },
    {
      "start": 7013,
      "end": 7041,
      "name": "rs232_input_highlevel_handshake_and_interrupt_control",
      "description": "High-level logic for taking input from the RS-232 buffer: save input device number, examine pseudo-6551 command register for handshake/duplex configuration, handle 3-line vs full-duplex paths, check DSR/RTS/DTR lines via VIA 2 DRB and serial interrupt-enable flags, set/clear FLAG interrupt (VIA ICR) as needed and return with appropriate status.",
      "references": [
        {
          "chunk": "rs232_get_byte_from_rx_buffer",
          "topic": "fetch a byte from the Rx buffer when conditions allow"
        },
        {
          "chunk": "rs232_check_bus_idle_and_interrupt_clear",
          "topic": "bus-idle checks and clearing RS-232 interrupt enables"
        },
        {
          "chunk": "rs232_tx_timer_setup_and_start",
          "topic": "timer-driven transmit setup (related transmit control)"
        }
      ]
    },
    {
      "start": 7042,
      "end": 7056,
      "name": "rs232_get_byte_from_rx_buffer",
      "description": "Return one byte from the RS-232 receive circular buffer: inspect RS-232 status ($0297) and Rx buffer start/end indices ($029C/$029B), return null if buffer empty (and set Rx-empty bit), otherwise clear empty flag, load the byte via (buffer_ptr), increment start index, and return the byte.",
      "references": [
        {
          "chunk": "rs232_input_highlevel_handshake_and_interrupt_control",
          "topic": "called when higher-level checks permit receiving"
        },
        {
          "chunk": "rs232_device_input_handling_loop",
          "topic": "consumer of this routine when getting device input"
        }
      ]
    },
    {
      "start": 7057,
      "end": 7070,
      "name": "rs232_check_bus_idle_and_interrupt_clear",
      "description": "Check RS-232 bus idle and clear serial interrupt enables: push A, poll the RS-232 interrupt-enable byte for errors, loop until error bits clear, disable FLAG interrupt by writing VIA 2 ICR ($DD0D), clear the RS-232 interrupt-enable byte ($02A1), and restore A. Ensures interrupts are disabled when bus is idle.",
      "references": [
        {
          "chunk": "rs232_input_highlevel_handshake_and_interrupt_control",
          "topic": "used to manage FLAG/ICR when bus idle or errors present"
        },
        {
          "chunk": "rs232_get_byte_from_rx_buffer",
          "topic": "status bits updated when reading Rx buffer"
        }
      ]
    },
    {
      "start": 7071,
      "end": 7090,
      "name": "kernel_io_message_table",
      "description": "IGNORED: Kernel I/O message strings table used for user-facing prompts (I/O ERROR, SEARCHING, FOR, PRESS PLAY ON TAPE, LOADING, SAVING, VERIFYING, FOUND, OK, etc.). This is data, not code \u2014 included for completeness but marked ignored as non-technical content.",
      "references": [
        {
          "chunk": "display_control_io_message_if_direct_mode",
          "topic": "routine that prints these kernel I/O messages when direct mode is enabled"
        }
      ]
    },
    {
      "start": 7091,
      "end": 7104,
      "name": "display_control_io_message_if_direct_mode",
      "description": "If control messages are enabled (message-mode flag at $9D), iterate the kernel I/O message table (starts $F0BD), mask high bit, and output each character via the kernel CHROUT vector ($FFD2). Preserves processor status between character outputs and loops until end-of-message.",
      "references": [
        {
          "chunk": "kernel_io_message_table",
          "topic": "message text the routine reads and outputs"
        },
        {
          "chunk": "get_character_from_input_device",
          "topic": "message display is part of higher-level I/O operations"
        }
      ]
    },
    {
      "start": 7105,
      "end": 7122,
      "name": "get_character_from_input_device",
      "description": "Return a character from the currently selected input device: read input device number ($99); if keyboard (0) handle keyboard-specific buffer retrieval; if RS-232 device, call the RS-232 Rx routine and return its byte; otherwise return success/no-error with no byte. Preserves and restores index registers around the RS-232 call.",
      "references": [
        {
          "chunk": "rs232_get_byte_from_rx_buffer",
          "topic": "used to obtain a byte when input device is RS-232"
        },
        {
          "chunk": "display_control_io_message_if_direct_mode",
          "topic": "may display control messages during I/O"
        }
      ]
    },
    {
      "start": 7123,
      "end": 7165,
      "name": "input_character_from_channel_device_dispatch",
      "description": "Higher-level 'input a character from channel' dispatch: check input device \u2014 keyboard (save cursor pos and jump to screen/keyboard input), screen (prepare screen parameters and jump to screen input), IEC devices vs RS-232 vs tape. For RS-232 device and serial bus, branch to appropriate routines; for tape device, call the tape-byte routine and handle EOI and error conditions. Implements device-number-based routing for channel input.",
      "references": [
        {
          "chunk": "get_character_from_input_device",
          "topic": "lower-level input-device selection and keyboard handling"
        },
        {
          "chunk": "tape_get_byte_routine",
          "topic": "called when input device is tape"
        },
        {
          "chunk": "serial_bus_input_check_and_dispatch",
          "topic": "called when input device is the serial bus"
        },
        {
          "chunk": "rs232_device_input_handling_loop",
          "topic": "called when input device is the RS-232 device"
        }
      ]
    },
    {
      "start": 7166,
      "end": 7176,
      "name": "tape_get_byte_routine",
      "description": "Read the next byte from the tape buffer: bump the tape pointer, if buffer not yet exhausted return the next byte; if end reached, call the tape read initiation routine ($F841), handle read errors, clear the tape buffer index ($A6) and loop until a byte is available. Returns with carry clear on success, set on error.",
      "references": [
        {
          "chunk": "input_character_from_channel_device_dispatch",
          "topic": "invokes this to obtain bytes from tape devices"
        }
      ]
    },
    {
      "start": 7177,
      "end": 7184,
      "name": "serial_bus_input_check_and_dispatch",
      "description": "Handle input when the device is the serial bus: check the serial status byte ($90); if no errors, continue to serial input routine; otherwise return CR (0x0D) as [EOL] with carry clear. On success, jumps to the serial input bit-level handler (at $EE13).",
      "references": [
        {
          "chunk": "input_character_from_channel_device_dispatch",
          "topic": "handles 'serial bus' case within device dispatch"
        },
        {
          "chunk": "rs232_input_highlevel_handshake_and_interrupt_control",
          "topic": "related handshake and interrupt management for serial lines"
        }
      ]
    },
    {
      "start": 7185,
      "end": 7195,
      "name": "rs232_device_input_handling_loop",
      "description": "Get a byte from the RS-232 device: call the RS-232 get-byte routine, handle its error flag (BCS), test for null return and, if null, examine RS-232 status ($0297) for DSR/other status bits, looping or returning [EOL] as appropriate. Implements the higher-level loop around the Rx buffer retrieval for RS-232 devices.",
      "references": [
        {
          "chunk": "rs232_get_byte_from_rx_buffer",
          "topic": "core routine that returns bytes from the RS-232 buffer"
        },
        {
          "chunk": "serial_bus_input_check_and_dispatch",
          "topic": "serial-bus vs RS-232 device distinctions in input dispatch"
        }
      ]
    },
    {
      "start": 7196,
      "end": 7200,
      "name": "output_character_to_channel_device_selection",
      "description": "Start of character output to a channel: push the character to the stack, read the output device number ($9A) and compare with the screen device code. This entry covers the device-selection and dispatch start of the kernel CHROUT/OUTPUT routine (device routing), saving state in preparation for device-specific output.",
      "references": [
        {
          "chunk": "display_control_io_message_if_direct_mode",
          "topic": "uses the same CHROUT vector to output kernel messages"
        },
        {
          "chunk": "rs232_tx_timer_setup_and_start",
          "topic": "transmit timer setup used for serial device output"
        }
      ]
    },
    {
      "start": 7201,
      "end": 7240,
      "name": "output_char_to_cassette_and_rs232",
      "description": "Code for outputting a character to cassette or RS232. Saves the character to a buffer ($9E), preserves X and Y, distinguishes cassette vs RS232 via carry, handles cassette tape pointer bump and tape write initiation (JSR $F80D / $F864), handles tape write errors and data block setup, restores registers, and routes RS232 output to the RS232 send routine (JSR $F017) with a no-error exit. Also contains bit-shift/LSR and PLA operations used before the cassette/RS232 output path.",
      "references": [
        {
          "chunk": "open_channel_for_output_and_serial_bus",
          "topic": "used when selecting RS232/tape as output device"
        },
        {
          "chunk": "find_file_and_find_file_A",
          "topic": "file/device selection routines called before output"
        }
      ]
    },
    {
      "start": 7241,
      "end": 7275,
      "name": "open_channel_for_input",
      "description": "Routine to open a channel for input. Calls file lookup (JSR $F30F), verifies the file is open, sets file details (JSR $F31F), reads the device number ($BA) and handles special devices (keyboard and screen). Distinguishes serial bus devices vs RS232 vs other devices, branches to RS232 input handler if appropriate, or reports 'file not open' / 'not input file' errors. Includes checks of the secondary address and serial bus device presence via the serial status byte.",
      "references": [
        {
          "chunk": "find_file_and_find_file_A",
          "topic": "file lookup used to verify the logical file"
        },
        {
          "chunk": "set_file_details_from_table",
          "topic": "loads file/device details from tables"
        },
        {
          "chunk": "open_channel_for_output_and_serial_bus",
          "topic": "shares serial bus device selection logic"
        }
      ]
    },
    {
      "start": 7276,
      "end": 7310,
      "name": "open_channel_for_output_and_serial_bus_handling",
      "description": "Routine to open a channel for output. Finds the file (JSR $F30F), sets file details (JSR $F31F), checks device numbers to handle keyboard/screen/tape/RS232. For RS232 output it branches to the RS232 open handler; for tape it validates secondary address and saves output device number ($9A). Contains serial-bus LISTEN/TALK handling: issues LISTEN (JSR $ED0C), toggles ATN where needed, sends secondary address (JSR $EDB9/$EDBE), and verifies device presence via the serial status byte ($90). Returns with flag/status set.",
      "references": [
        {
          "chunk": "find_file_and_find_file_A",
          "topic": "file lookup prior to opening for output"
        },
        {
          "chunk": "output_char_to_cassette_and_rs232",
          "topic": "actual output paths used after opening the device"
        },
        {
          "chunk": "set_file_details_from_table",
          "topic": "populates device/secondary address used here"
        }
      ]
    },
    {
      "start": 7311,
      "end": 7367,
      "name": "close_specified_logical_file",
      "description": "Close a specified logical file. Finds the file (JSR $F314), returns OK if already closed, or sets file details (JSR $F31F) and branches by device type. For RS232: closes the RS232 device (JSR $F2F2), initializes RS232 output (JSR $F483), reads top-of-memory (JSR $FE27), and reclaims RS232 input/output buffer memory by adjusting the memory pointer bytes ($F8/$FA). For tape devices: obtains tape buffer pointer, writes a terminating character and initiates tape write, handles errors, and writes tape header when needed. For serial-bus devices: calls the serial-bus close routine. Restores file index before returning.",
      "references": [
        {
          "chunk": "close_file_index_and_table_compaction",
          "topic": "updates open-file tables and compacts entries after close"
        },
        {
          "chunk": "open_channel_for_input",
          "topic": "open/close symmetry for devices (keyboard/screen/serial/tape)"
        },
        {
          "chunk": "open_channel_for_output_and_serial_bus_handling",
          "topic": "serial-bus device closing complements LISTEN/TALK setup"
        }
      ]
    },
    {
      "start": 7368,
      "end": 7384,
      "name": "close_file_index_and_table_compaction",
      "description": "Close file index X and compact the logical-file tables. Copies the file index to X (TAX), decrements the open file count ($98), compares the index with the new count and if not the last entry, copies the last table entry (logical file number, device number, secondary address) over the closing file's table slots (tables at $0259, $0263, $026D). Flags OK and returns. Also clears and sets relevant status flags used by file management.",
      "references": [
        {
          "chunk": "close_specified_logical_file",
          "topic": "called after device-specific close operations to finalize the close"
        },
        {
          "chunk": "find_file_and_find_file_A",
          "topic": "uses the open-file count/index obtained from the find routine"
        }
      ]
    },
    {
      "start": 7385,
      "end": 7398,
      "name": "find_file_and_find_file_A",
      "description": "File lookup routines. 'Find a file' clears accumulator and the serial status byte ($90), and prepares to find the logical file. 'Find file A' (entry point) uses the open-file count ($98) as an index (LDX/DEX), returns immediately if no files, and scans the logical file table ($0259,X) comparing entries to find a match. Loops until match or exhausts entries, then returns with A set appropriately.",
      "references": [
        {
          "chunk": "set_file_details_from_table",
          "topic": "used immediately after a successful find to load file/device details"
        },
        {
          "chunk": "open_channel_for_input",
          "topic": "called by input open to validate/open the logical file"
        },
        {
          "chunk": "open_channel_for_output_and_serial_bus_handling",
          "topic": "called by output open to validate/open the logical file"
        }
      ]
    },
    {
      "start": 7399,
      "end": 7400,
      "name": "set_file_details_from_table",
      "description": "Entry comment for setting file details from the logical-file tables. This covers the declaration/label for the routine that loads file details from table,X (the actual load instruction begins on the following line outside this split).",
      "references": [
        {
          "chunk": "find_file_and_find_file_A",
          "topic": "called after finding a file to populate file/device details"
        },
        {
          "chunk": "open_channel_for_input",
          "topic": "uses these details for input device selection"
        },
        {
          "chunk": "open_channel_for_output_and_serial_bus_handling",
          "topic": "uses these details for output device selection"
        }
      ]
    },
    {
      "start": 7401,
      "end": 7407,
      "name": "save_logical_file_and_load_device_secondary",
      "description": "Finalize saving the logical file number and load the corresponding device number and secondary address from their tables into temporary zero-page variables ($B8/$BA/$B9). Returns to caller. (Instructions: STA $B8; LDA $0263,X -> STA $BA; LDA $026D,X -> STA $B9; RTS.)",
      "references": [
        {
          "chunk": "open_logical_file",
          "topic": "Uses the saved logical file ($B8) and the device/secondary in $BA/$B9 when opening files"
        }
      ]
    },
    {
      "start": 7408,
      "end": 7424,
      "name": "close_all_channels_and_files",
      "description": "Kernal routine to close all channels and files: clears the open file count and resets input/output channel assignments to the screen and keyboard. If the active input/output devices are not the screen, issues UNLISTEN/UNTALK to the serial bus as needed. (Clears $98, compares device numbers and calls serial bus commands.)",
      "references": [
        {
          "chunk": "open_logical_file",
          "topic": "Open logic increments/decrements the same open-file counters that this routine clears"
        }
      ]
    },
    {
      "start": 7425,
      "end": 7489,
      "name": "open_logical_file",
      "description": "Kernal routine to open a logical file: checks logical file validity, verifies it is not already open, enforces maximum open file count, updates logical-file, device-number and secondary-address tables, handles keyboard/screen special cases, and dispatches to device-specific open handlers (serial bus, RS232, tape). Includes tape header searching/creation and sets up tape buffer index. Flags OK on success and returns.",
      "references": [
        {
          "chunk": "send_secondary_address_and_filename",
          "topic": "Called when opening serial-bus style devices to send the secondary address and filename"
        },
        {
          "chunk": "open_rs232_device_and_buffer_setup",
          "topic": "Called when opening an RS232 device (device #2) to set up the 6551 registers, baud, and buffers"
        }
      ]
    },
    {
      "start": 7490,
      "end": 7516,
      "name": "send_secondary_address_and_filename",
      "description": "Send the secondary address and filename bytes over the serial bus when opening a device: issues LISTEN to the device, sends OPEN/secondary byte and the filename bytes, checks serial status for device presence and handles 'device not present' error, then issues UNLISTEN. Clears/uses $90 as serial status and loops through the filename buffer ($BB) of length $B7.",
      "references": [
        {
          "chunk": "open_logical_file",
          "topic": "Invoked to send the secondary address and filename for serial-bus devices during open"
        }
      ]
    },
    {
      "start": 7517,
      "end": 7568,
      "name": "open_rs232_device_and_buffer_setup",
      "description": "Open and initialize an RS232 device: calls RS232 output initializer, saves RS232 status, copies up to 4 filename bytes into the pseudo-6551 register area ($0293..), computes bit count and selects baud-timing values from NTSC/PAL tables, saves nonstandard bit timing, checks for DSR (and sets an error if absent), initializes Rx/Tx circular-buffer indices ($029B/$029C and $029E/$029D), reads the top-of-memory pointer and allocates 256-byte input/output buffers (saving pointers in $F8/$F7 and $FA/$F9). If buffers are not yet allocated, decrements top-of-memory and stores the resulting pointers. May call the top-of-memory setter on some conditions.",
      "references": [
        {
          "chunk": "initialise_rs232_output",
          "topic": "Called early in this routine to set up VIA registers and basic RS232 port lines (DTR/RTS/Tx)"
        },
        {
          "chunk": "set_top_of_memory_to_f0xx",
          "topic": "Helper that sets the system top-of-memory to $F000 when called by RS232 open logic"
        }
      ]
    },
    {
      "start": 7569,
      "end": 7573,
      "name": "set_top_of_memory_to_f0xx",
      "description": "Small helper that forces the system 'top of memory' high byte to $F0 and returns. (Performs SEC; LDA #$F0; JMP to vector that finalizes top-of-memory.) Used when RS232 buffer allocation needs the F000 page.",
      "references": [
        {
          "chunk": "open_rs232_device_and_buffer_setup",
          "topic": "Called when RS232 open needs to set buffers in the $F000 page"
        }
      ]
    },
    {
      "start": 7574,
      "end": 7586,
      "name": "initialise_rs232_output",
      "description": "Initialise the RS232 output port and VIA settings: disables interrupts, programs VIA2 ICR, sets DTR/RTS outputs via VIA2 DDRB/DRB, ensures Tx data line is high by OR'ing VIA2 DRA, and clears the RS232 interrupt-enable byte at $02A1. Returns to caller.",
      "references": [
        {
          "chunk": "open_rs232_device_and_buffer_setup",
          "topic": "Called by the RS232 open sequence to ensure VIA2 and RS232 lines are in a known state before programming 6551/baud"
        }
      ]
    },
    {
      "start": 7587,
      "end": 7591,
      "name": "load_ram_from_device_vector",
      "description": "Kernal entry that sets up the KERNAL 'setup pointer' (stores X/Y into $C3/$C4) and then jumps through the LOAD vector at $0330. This indirection usually transfers control to the actual LOAD implementation in the ROM.",
      "references": [
        {
          "chunk": "load_routine_entry_and_device_check",
          "topic": "The LOAD vector typically points into the load routine which begins by saving flags and checking the device number"
        }
      ]
    },
    {
      "start": 7592,
      "end": 7600,
      "name": "load_routine_entry_and_device_check",
      "description": "Start of the LOAD implementation: saves the load/verify flag, clears the serial status byte, fetches the device number ($BA) and rejects the keyboard (device #$03) as an illegal device for LOAD (branches to the 'illegal device number' error). Continues beyond to dispatch device-specific LOAD behavior.",
      "references": [
        {
          "chunk": "load_ram_from_device_vector",
          "topic": "This routine is the target of the LOAD vector invoked just before entering the ROM load logic"
        }
      ]
    },
    {
      "start": 7601,
      "end": 7663,
      "name": "serial_bus_load_and_receive",
      "description": "Handling of LOAD from serial-bus devices (commands to TALK, sending secondary address and filename, receiving program start address and bytes over the serial bus, load vs verify path, saving bytes to memory, checking for timeouts and STOP key, UNTALK and close device). Covers code at $F4B4..$F52E including serial status masking and read/verify loop.",
      "references": [
        {
          "chunk": "tape_load_sequence",
          "topic": "alternate path for tape device loads"
        },
        {
          "chunk": "print_searching_and_file_name",
          "topic": "prints 'Searching...' and filename used during load"
        },
        {
          "chunk": "display_loading_or_verifying",
          "topic": "displays 'LOADING' or 'VERIFYING' during data transfer"
        }
      ]
    },
    {
      "start": 7664,
      "end": 7728,
      "name": "tape_load_sequence",
      "description": "Tape-specific LOAD path: validate device, obtain tape buffer pointer, wait for PLAY, search for matching tape header (specific or any), handle serial status read-error flagging, extract load address from header into A/E/F pointers, set I/O start addresses and call tape read routine. Covers $F533..$F5AE including header find and address calculations.",
      "references": [
        {
          "chunk": "serial_bus_load_and_receive",
          "topic": "alternate serial-bus load path and shared post-read handling"
        },
        {
          "chunk": "print_searching_and_file_name",
          "topic": "uses 'Searching...' message during tape searches"
        },
        {
          "chunk": "display_loading_or_verifying",
          "topic": "updates status message before calling tape read"
        }
      ]
    },
    {
      "start": 7729,
      "end": 7751,
      "name": "print_searching_and_file_name",
      "description": "Routines to print user-facing messages when searching for a file: print the 'Searching...' message and optionally 'FOR ' and then print the filename bytes to the current output channel. Implements message-mode check, message indices, filename length/index handling and character output via channel output routine. Covers $F5AF..$F5D1.",
      "references": [
        {
          "chunk": "serial_bus_load_and_receive",
          "topic": "invoked to show status during serial-bus loads"
        },
        {
          "chunk": "tape_load_sequence",
          "topic": "invoked to show status during tape searches"
        },
        {
          "chunk": "display_loading_or_verifying",
          "topic": "follow-up status message after 'Searching...'"
        }
      ]
    },
    {
      "start": 7752,
      "end": 7760,
      "name": "display_loading_or_verifying",
      "description": "Select and display the status message 'LOADING' or 'VERIFYING' depending on the load/verify flag. Loads the message index into Y and jumps to the kernel I/O message display routine when in direct mode. Covers $F5D2..$F12B (entry $F5D2..$F5DA in this chunk).",
      "references": [
        {
          "chunk": "serial_bus_load_and_receive",
          "topic": "used to show status during serial-bus file transfers"
        },
        {
          "chunk": "tape_load_sequence",
          "topic": "used to show status before starting tape read"
        },
        {
          "chunk": "print_searching_and_file_name",
          "topic": "complements the 'Searching...' output flow"
        }
      ]
    },
    {
      "start": 7761,
      "end": 7770,
      "name": "setup_save_ram_to_device",
      "description": "Prepare parameters for SAVE: store end address (XY) into $AE/$AF, copy index (A) into start pointer, load I/O start addresses from the start pointer into $C1/$C2, then JMP through the indirect vector at $0332 to the actual save implementation (usually $F685). Covers $F5DD..$F5EA.",
      "references": [
        {
          "chunk": "save_dispatch_and_serial_bus_output",
          "topic": "continues into device-specific SAVE dispatch and serial-bus save implementation"
        }
      ]
    },
    {
      "start": 7771,
      "end": 7800,
      "name": "save_dispatch_and_serial_bus_output",
      "description": "Top-level SAVE dispatch and serial-bus SAVE implementation: validate device numbers (keyboard and screen illegal for SAVE), set up serial-bus secondary address ($60 ORed), verify filename present, send secondary address+filename, command devices to LISTEN, send post-LISTEN secondary address, copy I/O start address to buffer address, output buffer address bytes to the serial bus, and check read/write pointer condition (sets carry if pointer >= end). Covers $F5ED..$F624 (addresses and serial bus interactions for saving to devices).",
      "references": [
        {
          "chunk": "setup_save_ram_to_device",
          "topic": "caller that sets up start/end addresses before invoking this SAVE dispatch"
        },
        {
          "chunk": "print_searching_and_file_name",
          "topic": "uses filename handling/printing for SAVE user messages"
        }
      ]
    },
    {
      "start": 7801,
      "end": 7826,
      "name": "serial_output_loop_and_close_device",
      "description": "Serial device output and close logic: loop that reads bytes from the output buffer and sends them to the serial bus (JSR $EDDD), scans the STOP key, handles early stop by closing the serial device (JSR $F642), and commands the serial bus to UNLISTEN/LISTEN and send the secondary address. Includes bit/test of secondary address and final RTS.",
      "references": [
        {
          "chunk": "tape_save_entry_and_device_checks",
          "topic": "higher-level entry that checks device type and may invoke serial/tape operations"
        },
        {
          "chunk": "rs232_initialisation_and_checks",
          "topic": "related handling for RS232 device checks and illegal-device handling (see tape/RS232 decision)"
        }
      ]
    },
    {
      "start": 7827,
      "end": 7852,
      "name": "tape_save_entry_and_device_checks",
      "description": "Entry for SAVING to tape / device checks: tests whether target is RS232 (LSR/BCS), traps illegal device numbers (JMP $F713), obtains tape buffer pointer (JSR $F7D0), waits for PLAY/RECORD, prints 'saving <filename>', selects header type (relocatable vs non-relocatable), calls write-tape-header routine, initiates the tape write operation (JSR $F867), and handles the 'logical end of tape' header bit.",
      "references": [
        {
          "chunk": "serial_output_loop_and_close_device",
          "topic": "lower-level serial output/close used for serial devices"
        },
        {
          "chunk": "print_saving_message",
          "topic": "prints the 'SAVING <file name>' status"
        },
        {
          "chunk": "write_tape_header",
          "topic": "routine invoked to write the tape header"
        }
      ]
    },
    {
      "start": 7853,
      "end": 7860,
      "name": "print_saving_message",
      "description": "Print 'SAVING <file name>' helper: checks the kernel message flag ($9D), and if enabled indexes to the 'SAVING ' message and calls the kernel I/O message display (JSR $F12F) then jumps to the file-name print routine (JMP $F5C1).",
      "references": [
        {
          "chunk": "tape_save_entry_and_device_checks",
          "topic": "invoked prior to starting tape write to display the status"
        },
        {
          "chunk": "print_file_name",
          "topic": "continuation that actually prints the filename (JMP target $F5C1)"
        }
      ]
    },
    {
      "start": 7861,
      "end": 7901,
      "name": "increment_jiffy_clock_and_keyboard_sampling",
      "description": "Increment the system jiffy (real-time) clock: increments low/mid/high jiffy bytes with carry handling, subtracts a day's worth of jiffies ($4F1A01) to detect/day-wrap and clears the clock if necessary (comment notes an off-by-one bug), then samples VIA ports to read keyboard row/column state and stores the STOP-key column index.",
      "references": [
        {
          "chunk": "read_and_set_real_time_clock",
          "topic": "read/set helpers for the jiffy clock bytes"
        },
        {
          "chunk": "scan_stop_key_and_handle_stop",
          "topic": "uses the stored keyboard column value to determine STOP key presses"
        }
      ]
    },
    {
      "start": 7902,
      "end": 7915,
      "name": "read_and_set_real_time_clock",
      "description": "Read and set routines for the jiffy clock: 'read' returns the jiffy clock low/mid/high (LDA/LDX/LDY) with interrupts disabled; 'set' saves the provided jiffy clock bytes (STA/STX/STY) with interrupts disabled then re-enables interrupts.",
      "references": [
        {
          "chunk": "increment_jiffy_clock_and_keyboard_sampling",
          "topic": "the increment routine updates these jiffy clock bytes"
        }
      ]
    },
    {
      "start": 7916,
      "end": 7926,
      "name": "scan_stop_key_and_handle_stop",
      "description": "Scan the STOP key routine: reads saved stop-key column, compares to STOP pressed value, and if just STOP was pressed saves processor status, closes input/output channels (JSR $FFCC), saves the keyboard buffer index into $C6, and returns with appropriate flags.",
      "references": [
        {
          "chunk": "increment_jiffy_clock_and_keyboard_sampling",
          "topic": "relies on the stored stop-key column determined earlier"
        },
        {
          "chunk": "file_error_messages",
          "topic": "closing I/O channels during STOP interacts with error/IO reporting paths"
        }
      ]
    },
    {
      "start": 7927,
      "end": 7959,
      "name": "file_error_messages",
      "description": "File I/O error reporting: defines common file error codes ('too many files', 'file already open', 'file not open', 'file not found', 'device not present', 'not input file', 'not output file', 'missing file name', 'illegal device number'), pushes the error, closes channels, tests message-mode and displays the 'I/O ERROR #' message (JSR $F12F) if enabled, converts the error number to ASCII, outputs it (JSR $FFD2), and sets the carry to signal an error on return.",
      "references": [
        {
          "chunk": "scan_stop_key_and_handle_stop",
          "topic": "both may call JSR $FFCC to close channels"
        },
        {
          "chunk": "tape_save_entry_and_device_checks",
          "topic": "uses this error handling for illegal device and tape errors"
        }
      ]
    },
    {
      "start": 7960,
      "end": 7996,
      "name": "find_tape_header",
      "description": "Find the tape header in the tape buffer: saves the load/verify flag, initiates tape read (JSR $F841), scans the tape buffer (via ($B2),Y) searching for valid headers (program relocatable $01, program non-relocatable $03, data $04, or logical end $05), loops until a suitable header or end-of-tape/error. If a program header is found and kernel messages are enabled, prints 'FOUND ' and the tape filename (reads 21 bytes from tape buffer), then waits ~8.5 seconds for any key from the STOP key column before returning with the header populated.",
      "references": [
        {
          "chunk": "write_tape_header",
          "topic": "the counterpart routine used when saving/writing headers to tape"
        },
        {
          "chunk": "tape_save_entry_and_device_checks",
          "topic": "invokes this logic during LOAD/VERIFY and SAVE flows"
        }
      ]
    },
    {
      "start": 7997,
      "end": 8000,
      "name": "write_tape_header",
      "description": "Start of the write-tape-header routine: saves the selected header type into $9E and calls the helper to get the tape buffer start pointer into the X/Y registers (JSR $F7D0). (This is the entry that prepares the header buffer before the full header-write sequence.)",
      "references": [
        {
          "chunk": "tape_save_entry_and_device_checks",
          "topic": "invokes the write-tape-header routine when saving to tape"
        },
        {
          "chunk": "find_tape_header",
          "topic": "symmetrical operation for locating headers during LOAD/VERIFY"
        }
      ]
    },
    {
      "start": 8001,
      "end": 8057,
      "name": "create_tape_header_and_initiate_write",
      "description": "Builds/clears a tape header in the tape buffer: saves I/O start and tape end addresses, clears header bytes, writes header type, file name and start/end addresses into the header buffer, sets tape buffer start/end pointers (JSR $F7D7), sets write lead cycle count and calls the tape write entry (JSR $F86B). Restores saved registers and returns.",
      "references": [
        {
          "chunk": "set_tape_buffer_start_and_end_pointers",
          "topic": "called (JSR $F7D7) to derive I/O and end pointers from buffer start"
        },
        {
          "chunk": "initiate_tape_write",
          "topic": "calls the tape write entry (JSR $F86B)"
        },
        {
          "chunk": "get_tape_buffer_start_pointer",
          "topic": "helper used by the set-pointer routine that this code calls"
        }
      ]
    },
    {
      "start": 8058,
      "end": 8063,
      "name": "get_tape_buffer_start_pointer",
      "description": "Helper routine that loads the tape buffer start pointer into X (low) and Y (high). Compares the high byte with #$02 (typical RAM area check). Returns with X/Y containing the pointer.",
      "references": [
        {
          "chunk": "set_tape_buffer_start_and_end_pointers",
          "topic": "caller that uses the pointer in X/Y to set I/O and end pointers"
        },
        {
          "chunk": "create_tape_header_and_initiate_write",
          "topic": "higher-level routine that invokes the set-pointer routine which itself calls this helper"
        }
      ]
    },
    {
      "start": 8064,
      "end": 8076,
      "name": "set_tape_buffer_start_and_end_pointers",
      "description": "Sets the I/O start pointer (C1/C2) and the tape buffer end pointer (AE/AF) based on the tape buffer start pointer and a fixed buffer length. Calls the get_tape_buffer_start_pointer helper (JSR $F7D0), copies X/A to C1, adds buffer-length low and high bytes to compute AE/AF, and saves the index Y to $9F.",
      "references": [
        {
          "chunk": "get_tape_buffer_start_pointer",
          "topic": "obtains the buffer start pointer in X/Y"
        },
        {
          "chunk": "create_tape_header_and_initiate_write",
          "topic": "used to set start/end pointers before writing header data"
        }
      ]
    },
    {
      "start": 8077,
      "end": 8096,
      "name": "find_specific_tape_header",
      "description": "Locate a specific tape header on tape: calls a header-find routine (JSR $F72C) which returns the header in the buffer. If found, compares the requested filename against the header name byte-by-byte (using indices in $9E/$9F and ($B2) header buffer). On match sets carry (OK) and returns; on mismatch loops to next header or returns with error flagged.",
      "references": [
        {
          "chunk": "get_tape_buffer_start_pointer",
          "topic": "used indirectly by pointer-setup code that may be used prior to header searches"
        },
        {
          "chunk": "bump_tape_pointer",
          "topic": "advances to the next header/buffer entry if needed"
        }
      ]
    },
    {
      "start": 8097,
      "end": 8103,
      "name": "bump_tape_pointer",
      "description": "Increment the active tape buffer pointer/index ($A6) after processing a header or data byte. Uses get_tape_buffer_start_pointer (JSR $F7D0) to load a comparison index into Y, increments $A6 and compares Y with #$C0 (buffer length) to check wrapping/limit.",
      "references": [
        {
          "chunk": "get_tape_buffer_start_pointer",
          "topic": "called to obtain comparison index before bumping"
        },
        {
          "chunk": "find_specific_tape_header",
          "topic": "used to advance to the next header when a name comparison fails"
        }
      ]
    },
    {
      "start": 8104,
      "end": 8119,
      "name": "wait_for_play_prompt_and_display",
      "description": "High-level 'WAIT FOR PLAY' routine: queries cassette sense (JSR $F82E), if open displays the prompt 'PRESS PLAY ON TAPE' (via kernel I/O message JSR $F12F), scans for STOP key (JSR $F8D0), and loops until the PLAY switch is closed. When closed displays 'OK' and returns. Uses the cassette-sense helper and display routines.",
      "references": [
        {
          "chunk": "cassette_sense_return",
          "topic": "queries the 6510 I/O port to detect the cassette switch (called via JSR $F82E)"
        },
        {
          "chunk": "tape_motor_and_spinup_delay",
          "topic": "subsequent motor-control routines are used when starting actual tape operations"
        }
      ]
    },
    {
      "start": 8120,
      "end": 8127,
      "name": "cassette_sense_return",
      "description": "Reads the 6510 I/O port and tests the cassette sense line: loads a mask, BITs the port $01 and branches according to the bit to determine cassette switch state. Leaves flags accordingly and returns (intended to provide cassette sense in Z/Carry for callers).",
      "references": [
        {
          "chunk": "wait_for_play_prompt_and_display",
          "topic": "used to detect the PLAY switch state"
        },
        {
          "chunk": "wait_for_play_or_record_prompt",
          "topic": "used to detect PLAY/RECORD switch state for write operations"
        }
      ]
    },
    {
      "start": 8128,
      "end": 8135,
      "name": "wait_for_play_or_record_prompt",
      "description": "Wait-for-PLAY/RECORD routine used before writes: calls the cassette-sense helper (JSR $F82E); if switch open it displays 'PRESS RECORD & PLAY ON TAPE' and waits (branching back to the play prompt/display routine). Always uses the cassette sense helper and display message flow.",
      "references": [
        {
          "chunk": "cassette_sense_return",
          "topic": "called to read the cassette switch status"
        },
        {
          "chunk": "initiate_tape_write",
          "topic": "invoked by the write initiation path before starting a write"
        }
      ]
    },
    {
      "start": 8136,
      "end": 8155,
      "name": "initiate_tape_read",
      "description": "Entry point to start a tape read (load/verify): clears serial status and load/verify flags ($90,$93), calls set-pointer (JSR $F7D7), waits for PLAY (JSR $F817), exits if STOP pressed, disables interrupts (SEI), clears several tape-related state bytes ($AA,$B4,$B0,$9E,$9F,$9C), sets up CA1 interrupt enable and selects the tape read IRQ vector index (LDX #$0E) then branches (BNE) to the common tape read/write handler.",
      "references": [
        {
          "chunk": "set_tape_buffer_start_and_end_pointers",
          "topic": "called first to derive I/O and end pointers"
        },
        {
          "chunk": "wait_for_play_prompt_and_display",
          "topic": "waits for PLAY before enabling read"
        },
        {
          "chunk": "tape_read_write_setup_and_irq_save",
          "topic": "control then flows to the common tape read/write setup (branch to F875)"
        }
      ]
    },
    {
      "start": 8156,
      "end": 8167,
      "name": "initiate_tape_write",
      "description": "Entry point to start a tape write: calls set-pointer (JSR $F7D7), sets the write lead cycle count ($AB) (20 cycles or other value depending on entry), waits for PLAY/RECORD (JSR $F838), exits if STOP pressed, disables interrupts (SEI), loads an interrupt enable constant and selects the tape-write leader vector index (LDX #$08). Control then falls into the shared tape read/write handler.",
      "references": [
        {
          "chunk": "set_tape_buffer_start_and_end_pointers",
          "topic": "used to set buffer boundaries before writing"
        },
        {
          "chunk": "wait_for_play_or_record_prompt",
          "topic": "waits for RECORD+PLAY before starting a write"
        },
        {
          "chunk": "tape_read_write_setup_and_irq_save",
          "topic": "common setup for read/write that follows"
        }
      ]
    },
    {
      "start": 8168,
      "end": 8190,
      "name": "tape_read_write_setup_and_irq_save",
      "description": "Common tape read/write setup and IRQ handling: disables interrupts (LDY #$7F / STY $DC0D), saves and programs VIA control registers (CRA/CRB), starts timers (timer B single-shot and timer A), saves a shadow copy of VIA CRB, calls RS232/serial idle check (JSR $F0A4), blanks the screen (clear bits of $D011), saves the current IRQ vector ($0314/$0315 to $029F/$02A0), sets the kernel tape IRQ vector (JSR $FCBD), sets the copy count ($BE=2) for load+verify and calls new tape byte setup (JSR $FB97).",
      "references": [
        {
          "chunk": "initiate_tape_read",
          "topic": "branches here to continue read startup"
        },
        {
          "chunk": "initiate_tape_write",
          "topic": "branches here for write startup"
        },
        {
          "chunk": "tape_motor_and_spinup_delay",
          "topic": "motor start and delay follow this setup to stabilise tape speed"
        }
      ]
    },
    {
      "start": 8191,
      "end": 8200,
      "name": "tape_motor_and_spinup_delay",
      "description": "Enable cassette motor and perform long spin-up delay: read 6510 I/O port, mask and set the cassette motor bit, store motor interlock ($C0), then perform a nested delay loop (LDX/LDY with two nested decrement loops) to provide a large motor spin-up delay (counting to create ~326,656 cycles) before starting timed tape operations.",
      "references": [
        {
          "chunk": "tape_read_write_setup_and_irq_save",
          "topic": "called/used immediately after IRQ/vector setup to ensure motor is stabilised before data transfer"
        },
        {
          "chunk": "cassette_sense_return",
          "topic": "cassette sense/read routines are related to motor and switch control"
        }
      ]
    },
    {
      "start": 8201,
      "end": 8212,
      "name": "tape_write_loop_check_and_irq_reenable",
      "description": "End of the tape write loop: branch if more to do, re-enable tape interrupts (CLI), compare saved IRQ high byte with current IRQ high byte to detect completion, branch to clear saved IRQ address when done. Calls stop-key scanner and increments the real-time clock before looping.",
      "references": [
        {
          "chunk": "scan_stop_key_handler",
          "topic": "stop-key scanning and abort handling called from the loop"
        },
        {
          "chunk": "clear_saved_irq_address_and_return",
          "topic": "clearing the saved IRQ address when tape write is finished"
        }
      ]
    },
    {
      "start": 8213,
      "end": 8221,
      "name": "scan_stop_key_handler",
      "description": "Routine to poll the STOP key (JSR $FFE1). Clears/sets flags to indicate whether STOP was pressed, restores registers and return state if STOP occurred, and manipulates the return address on the stack so control returns to the caller that initiated the stop.",
      "references": [
        {
          "chunk": "tape_write_loop_check_and_irq_reenable",
          "topic": "called from the tape write loop to detect user abort"
        },
        {
          "chunk": "clear_saved_irq_address_and_return",
          "topic": "subsequent cleanup after STOP detection"
        }
      ]
    },
    {
      "start": 8222,
      "end": 8226,
      "name": "clear_saved_irq_address_and_return",
      "description": "Clear the saved IRQ address high byte ($02A0) and return (RTS). This is the cleanup step taken when a tape write operation finishes successfully.",
      "references": [
        {
          "chunk": "tape_write_loop_check_and_irq_reenable",
          "topic": "branch target when tape write done"
        }
      ]
    },
    {
      "start": 8227,
      "end": 8256,
      "name": "set_tape_timing_constants_prepare_via_timers",
      "description": "Compute and prepare tape timing constants used for pulse classification. Uses tape timing min/max bytes ($B0/$B1), performs shifts and additions to form thresholds, saves max byte in $B1. Then polls VIA1 timer B (DC06/DC07) until it reaches a minimum value, adds computed timing, and saves VIA timer A low/high (DC04/DC05). Saves CRA/CRB shadow copy and CRA to shadow ($02A4/$DC0E).",
      "references": [
        {
          "chunk": "check_flag_interrupt_and_invoke_irq",
          "topic": "this setup is invoked via JSR from the interrupt pre-check"
        },
        {
          "chunk": "irq_routine_read_t2c_and_compute_difference",
          "topic": "the IRQ routine reads timer values that depend on these timing thresholds"
        }
      ]
    },
    {
      "start": 8257,
      "end": 8268,
      "name": "check_flag_interrupt_and_invoke_irq",
      "description": "Check VIA1 ICR ($DC0D) for a FLAG interrupt (mask #$10). If a FLAG interrupt is pending, push a crafted return address and jump to the common IRQ-handling entry ($FF43) to save state and execute the IRQ routine; otherwise re-enable interrupts (CLI) and return (RTS).",
      "references": [
        {
          "chunk": "set_tape_timing_constants_prepare_via_timers",
          "topic": "runs after timing constants and timer reads"
        },
        {
          "chunk": "irq_routine_read_t2c_and_compute_difference",
          "topic": "FLAG interrupt handling routes execution to the IRQ routine"
        }
      ]
    },
    {
      "start": 8269,
      "end": 8291,
      "name": "cassette_pulse_types_and_loader_overview",
      "description": "Overview of the Commodore cassette data stream symbols and how the ROM loader decodes them. Defines the A (break/very long), B (short), C (medium), and D (long) pulse types with typical cycle times, and explains the IRQ-driven decoding strategy: a timer is started and an IRQ occurs either when the tape signal changes or the timer runs out; comparing which happened determines a '0' (short) or '1' (long).",
      "references": [
        {
          "chunk": "irq_routine_read_t2c_and_compute_difference",
          "topic": "the IRQ routine implements the described decoding algorithm"
        },
        {
          "chunk": "pulse_classification_and_store_character_calls",
          "topic": "the subsequent code classifies pulses into B/C/D and takes actions"
        }
      ]
    },
    {
      "start": 8292,
      "end": 8303,
      "name": "irq_routine_read_t2c_and_compute_difference",
      "description": "Start of the IRQ-driven tape read routine: read VIA1 timer B high/low (DC07/DC06), compute the elapsed count as ($FF - T2C_l) and ensure no rollover by comparing high bytes, save timer bytes ($DC04/$DC05) and copy timing constants into $B1/$B0 as preparation for pulse classification.",
      "references": [
        {
          "chunk": "restart_timer_b_and_save_icr_copies",
          "topic": "immediately restarts timer B and saves ICR copies after reading T2C"
        },
        {
          "chunk": "compute_shifted_timing_and_threshold_compare",
          "topic": "uses the computed difference for threshold comparisons"
        }
      ]
    },
    {
      "start": 8304,
      "end": 8312,
      "name": "restart_timer_b_and_save_icr_copies",
      "description": "Start timer B in single-shot mode (CRA/CRB writes), save CRB ($DC0F) and an ICR shadow copy ($02A3), and prepare stack/registers. Also stores copies of the VIA timer B bytes (DC06/DC07) for later use.",
      "references": [
        {
          "chunk": "irq_routine_read_t2c_and_compute_difference",
          "topic": "continues after computing $FFFF-T2C"
        },
        {
          "chunk": "compute_shifted_timing_and_threshold_compare",
          "topic": "the routine next shifts and compares the measured interval"
        }
      ]
    },
    {
      "start": 8313,
      "end": 8324,
      "name": "compute_shifted_timing_and_threshold_compare",
      "description": "Compute scaled timing values by shifting the measured ($FFFF - T2C) right twice (divide by 4) and compare it with a threshold computed as min + $3C (from $B0 plus constant). If the measured value is below threshold, branch to the short-pulse handling path. Saves intermediate results in $B1.",
      "references": [
        {
          "chunk": "cassette_pulse_types_and_loader_overview",
          "topic": "uses the timing difference concept described in the overview"
        },
        {
          "chunk": "pulse_classification_and_store_character_calls",
          "topic": "continues to classify pulses as B/C/D and possibly store bytes"
        }
      ]
    },
    {
      "start": 8325,
      "end": 8345,
      "name": "pulse_classification_and_store_character_calls",
      "description": "Classification of pulses into short/medium/long ranges by adding different offsets to min timing ($B0) and comparing with the computed max ($B1). Handles EOI (end-of-information) flag checks, may call the 'store the tape character' routine when a full byte is received, and branches to appropriate handlers for each pulse type. Uses constants added (#$30, #$26, #$2C) to discriminate B/C/D ranges.",
      "references": [
        {
          "chunk": "compute_shifted_timing_and_threshold_compare",
          "topic": "uses the computed timing thresholds to branch here"
        },
        {
          "chunk": "bit_count_handling_phase_toggle_and_timing_adjust",
          "topic": "after classifying a pulse, code updates bit counts, phase, and timing"
        }
      ]
    },
    {
      "start": 8346,
      "end": 8362,
      "name": "bit_count_handling_phase_toggle_and_timing_adjust",
      "description": "Process bit-count bookkeeping after a detected pulse: read the bit count ($B4), save receiver bit count ($A8), update start-bit check flag ($A9) via INC/DEC depending on branch outcomes, compute a timing adjustment into $92 (subtract max $B1 and add constant $92), toggle the bit cycle phase ($A4), and store X into $D7 for later comparison.",
      "references": [
        {
          "chunk": "pulse_classification_and_store_character_calls",
          "topic": "handles bookkeeping after a classified pulse"
        },
        {
          "chunk": "timer_a_check_clear_phase_and_timing_setup",
          "topic": "subsequent checks clear phase or set timing and may exit the IRQ"
        }
      ]
    },
    {
      "start": 8363,
      "end": 8380,
      "name": "timer_a_check_clear_phase_and_timing_setup",
      "description": "Further interrupt routine logic: if bit count nonzero, check VIA1 ICR shadow ($02A3) for timer-A interrupt enable and CRA shadow ($02A4) to decide whether to clear the bit cycle phase ($A4). Handles EOI flag testing and branches, sets timing by JSR $F8E2 when needed, and conditionally returns from interrupt (JMP $FEBC) to restore registers.",
      "references": [
        {
          "chunk": "bit_count_handling_phase_toggle_and_timing_adjust",
          "topic": "continues processing after updating phase/timing variables"
        },
        {
          "chunk": "timing_constant_fine_tuning_start_bit_and_sync_handling",
          "topic": "final timing tweaks and start-bit/sync handling occur next"
        }
      ]
    },
    {
      "start": 8381,
      "end": 8400,
      "name": "timing_constant_fine_tuning_start_bit_and_sync_handling",
      "description": "Fine-tune tape timing constants: load or clear timing-adjust flag ($92), increment/decrement the min timing byte ($B0) based on measured values, handle an embedded .BYTE patch entry, clear the timing-adjust flag, compare saved X ($D7) and branch accordingly, check start-bit detection counters ($A9) and save block synchronization number ($96). Finalize by toggling $9B with EOR and prepare to exit.",
      "references": [
        {
          "chunk": "timer_a_check_clear_phase_and_timing_setup",
          "topic": "continues with timing tuning and start-bit checks"
        },
        {
          "chunk": "pulse_classification_and_store_character_calls",
          "topic": "uses the sync/block counters that are updated here"
        }
      ]
    },
    {
      "start": 8401,
      "end": 8450,
      "name": "tape_and_timer_interrupt_timing_and_status_handling",
      "description": "Interrupt-time handling for tape/serial I/O timing and status. Covers decrementing the EOI flag, parity-count adjustments (LSR/ ROR on $D7/$BF), setting the timing maximum byte (LDX #$DA; JSR $F8E2), restoring registers/exit (JMP $FEBC), reading cassette block synchronization number ($96) and EOI checks, shifting and computing tape timing constants (LSR/SEC/SBC/ADC/ASL/TAX; JSR $F8E2), incrementing $9C, enabling/disabling Timer A interrupt via VIA ICR ($DC0D), saving parity/receiver-bit-count flags into $BD/$B6/$A8, and branching to the next stage that stores characters.",
      "references": [
        {
          "chunk": "store_tape_character_and_buffer_handling",
          "topic": "main routine that stores decoded tape characters, handles copies/counts, and writes/verifies buffer data"
        }
      ]
    },
    {
      "start": 8451,
      "end": 8472,
      "name": "store_character_entry_and_initial_timing",
      "description": "Entry to the KERNAL 'store character' routine. Calls new tape-byte setup (JSR $FB97), clears the byte-received flag ($9C), sets max byte timing (LDX #$DA) and invokes timing setup (JSR $F8E2). Loads the copies count ($BE) and, if non-zero, saves temporary receiver-input-bit storage ($A7). Tests serial-status bits ($AA) and branches into short-block/copies handling or early-exit paths. Sets short-block status and jumps to the common interrupt restore/exit when appropriate.",
      "references": [
        {
          "chunk": "rs232_parity_and_startbit_handling",
          "topic": "Follows when serial-status bit indicates another path (BVS/BPL branches) \u2014 handles bit/ parity processing and decisions to store or abort"
        },
        {
          "chunk": "interrupt_restore_and_checksum_validation",
          "topic": "Final early-exit target (JMP $FEBC) used by this entry's short-block and zero-copy exits"
        }
      ]
    },
    {
      "start": 8473,
      "end": 8498,
      "name": "rs232_parity_and_startbit_handling",
      "description": "Handles RS-232 receiver bit processing and parity/start-bit management. Examines flags (B5,B6), shifts temporary receiver bit storage ($A7), compares with the RS232 parity byte ($BD) and sets/clears carry/zero as needed. Computes nibble ($AA) counts, decrements counters, sets buffer start conditions, and may call the routine to copy the I/O start address to the buffer (JSR $FB8E). Sets serial status bits (via JSR $FE1C) to indicate short-block or parity conditions and branches to the common interrupt-restore exit where appropriate.",
      "references": [
        {
          "chunk": "store_character_entry_and_initial_timing",
          "topic": "This logic is reached from the entry/timing checks when serial-status bits select the RS232 path"
        },
        {
          "chunk": "buffer_copy_and_load_store",
          "topic": "When a byte or start-of-buffer is accepted this code calls FB8E and then control flows into buffer-copy/load handling"
        }
      ]
    },
    {
      "start": 8499,
      "end": 8532,
      "name": "buffer_copy_and_load_store",
      "description": "Manages copying received bytes into the receive buffer memory and related load/store bookkeeping. Checks flag $B5 and ORs status into the serial-status byte (JSR $FE1C) when needed. Calls the read/write-pointer check (JSR $FCD1) to detect buffer-end and branches to pointer-wrap/exit if necessary. Uses $A7 as a temporary receiver-bit counter; if loading, sets up Y=0 and compares the received RS232 byte ($BD) with the buffer byte at ($AC),Y. If loading a new byte, sets up X and $9E index and writes the incoming bytes to $0100+X (storing $AD and $AC), increments X, and stores the updated index back to $9E before jumping to the further completion/verify stage.",
      "references": [
        {
          "chunk": "rs232_parity_and_startbit_handling",
          "topic": "This section receives control after parity/start-bit checks decide the byte should be stored"
        },
        {
          "chunk": "verify_and_pointer_increment",
          "topic": "After storing the byte this code jumps to the verify/pointer-increment logic to finish the byte handling"
        }
      ]
    },
    {
      "start": 8533,
      "end": 8563,
      "name": "verify_and_pointer_increment",
      "description": "Performs buffer-compare/verify and pointer advancement. Uses $9F/$9E indexes to compare new data against existing buffer contents for verify operations, increments counters ($9F) for saved bytes, inspects the load/verify flag ($93) to decide whether to store the RS232 parity byte ($BD) into the buffer (STA ($AC),Y) or to skip. Calls the routine to increment the read/write pointer (JSR $FCDB) and branches to the common exit ($FEBC) when appropriate.",
      "references": [
        {
          "chunk": "buffer_copy_and_load_store",
          "topic": "This continues after copying fetched bytes into buffer memory and handles verify vs. load actions and pointer updates"
        },
        {
          "chunk": "interrupt_restore_and_checksum_validation",
          "topic": "Common exit and register-restore target after pointer increment or error handling"
        }
      ]
    },
    {
      "start": 8564,
      "end": 8595,
      "name": "interrupt_restore_timer_and_checksum_validation",
      "description": "Prepare for restoring CPU state and handle STOP/checksum finalization. Disables interrupts (SEI), disables Timer A interrupt and saves/reads VIA ICR ($DC0D). Manages copies count ($BE) and the receiver-bit temporary storage ($A7), decrementing and saving counts; if STOP conditions are met it calls the restore-for-STOP routine (JSR $FC93). Calls FB8E to copy the I/O start address to the buffer, clears the checksum index ($AB) and computes the checksum by iterating over buffer bytes (LDA ($AC),Y, EOR $AB) while incrementing the read/write pointer (JSR $FCDB/FCD1 checks). Compares the computed checksum with stored checksum ($BD) and sets the serial-status checksum-error bit (JSR $FE1C) on mismatch, then jumps to the common register-restore/exit ($FEBC).",
      "references": [
        {
          "chunk": "verify_and_pointer_increment",
          "topic": "Final pointer increment and possible early exit return here when read/write pointer handling finishes"
        },
        {
          "chunk": "store_character_entry_and_initial_timing",
          "topic": "Shares the common register-restore/exit target ($FEBC) used by initial short-block and other early exits"
        }
      ]
    },
    {
      "start": 8596,
      "end": 8596,
      "ignore": true,
      "reason": "The overlapped content is just blank/formatting lines between chunks; non-technical and should be ignored."
    },
    {
      "start": 8597,
      "end": 8600,
      "name": "copy_io_start_to_buffer_address",
      "description": "Small helper that copies the I/O start address into the buffer address registers. Loads I/O start address high/low bytes from $C2/$C1 and stores them into buffer address high/low $AD/$AC respectively. Used by the store/verify and checksum routines to set the buffer pointer.",
      "references": [
        {
          "chunk": "store_tape_character_and_buffer_handling",
          "topic": "invoked (JSR $FB8E) to set buffer address before writing/verifying bytes and before checksum computation"
        }
      ]
    },
    {
      "start": 8601,
      "end": 8602,
      "name": "copy_io_start_address_to_buffer_address",
      "description": "Copy I/O start address to tape buffer address: LDA $C2 -> STA $AD (buffer high), LDA $C1 -> STA $AC (buffer low), RTS. Used to set buffer pointer before tape read/write operations.",
      "references": [
        {
          "chunk": "store_character",
          "topic": "called when copying I/O start address to buffer before operations"
        },
        {
          "chunk": "tape_write_irq_routine",
          "topic": "tape routines use buffer pointers $AC/$AD"
        }
      ]
    },
    {
      "start": 8603,
      "end": 8603,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8604,
      "end": 8612,
      "name": "new_tape_byte_setup",
      "description": "Initialise for a new tape byte: LDA #$08 -> STA $A3 (bit count), clear A and store to $A4 (tape bit cycle phase), clear start-bit first-cycle flag ($A8), clear tape byte parity ($9B) and clear start-bit check flag ($A9). RTS.",
      "references": [
        {
          "chunk": "store_character",
          "topic": "called via JSR $FB97 when preparing to receive/store a new byte"
        },
        {
          "chunk": "tape_write_irq_routine",
          "topic": "used when sending bytes to tape (new byte setup)"
        }
      ]
    },
    {
      "start": 8613,
      "end": 8613,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8614,
      "end": 8638,
      "name": "send_lsb_from_tape_write_byte_to_tape",
      "description": "Send LSB of tape write byte: LDA $BD (tape write byte), LSR (shift LSB into carry), set default timing low byte #$60 (bit=0) or #$B0 (bit=1) depending on carry, write timer B low/high to VIA 1 ($DC06/$DC07), set VIA 1 CRB ($DC0F) to start timer B single shot (#$19), toggle tape out bit via 6510 port $01 (EOR #$08) and mask/store. Uses $BD (write byte), $9B (parity), and VIA registers $DC06/$DC07/$DC0F.",
      "references": [
        {
          "chunk": "write_time_constant_and_toggle_tape",
          "topic": "suboperation performed via JSR $FBB1"
        },
        {
          "chunk": "tape_write_irq_routine",
          "topic": "called repeatedly by the tape write IRQ sequence"
        }
      ]
    },
    {
      "start": 8639,
      "end": 8639,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8640,
      "end": 8644,
      "name": "flag_block_done_and_exit_interrupt",
      "description": "Flag block done and exit interrupt: SEC, ROR $B6 (mark buffer high byte negative and flag sync/data/checksum bytes written), BMI to restore/exit (branch always). Prepares for exit of tape write operation.",
      "references": [
        {
          "chunk": "tape_write_irq_routine",
          "topic": "used when the tape block write completes"
        }
      ]
    },
    {
      "start": 8645,
      "end": 8645,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8646,
      "end": 8667,
      "name": "tape_write_irq_header_and_first_start_cycle",
      "description": "Routine header and handling of the very first start-bit half-cycle. Describes the overall purpose of the tape write IRQ, checks the '$A8' first-cycle-done flag, sets the first start-cycle time constant (LD A #$10, LDX #$01 and JSR $FBB1), toggles the start-cycle flag (INC $A8) and checks for block-complete via the buffer high byte ($B6 BPL). If the block is complete, jumps to the block-complete tape routine (JMP $FC57).",
      "references": [
        {
          "chunk": "tape_write_start_bit_and_bit_send_phase",
          "topic": "continues processing after the first start-cycle to finish the start bit and begin sending data bits"
        },
        {
          "chunk": "tape_write_block_complete_and_leader_setup",
          "topic": "handles the block-complete path when buffer high byte indicates end-of-block"
        }
      ]
    },
    {
      "start": 8668,
      "end": 8701,
      "name": "tape_write_start_bit_and_bit_send_phase",
      "description": "Handles the second start-bit cycles and begins data-bit transmission. Checks the '$A9' start-bit-check flag, sets the time constant for the start-bit second cycles via JSR $FBAD, and increments the start-bit flag (INC $A9). Calls the bit-send routine (JSR $FBA6) to toggle the tape for the data-bit LSB. Manages the bit-cycle phase toggle ($A4 EOR #$01 STA $A4) and, during the second half of a bit, inverts the bit in the write byte ($BD), masks the LSB and updates the byte parity ($9B). Returns to restore registers when a half-cycle exit occurs (JMP $FEBC).",
      "references": [
        {
          "chunk": "tape_write_irq_header_and_first_start_cycle",
          "topic": "previously set up the first half-cycle; this continues to finish the start bit and begin bits"
        },
        {
          "chunk": "tape_write_shift_count_and_new_byte_setup",
          "topic": "after both half-cycles of a bit are done, code shifts the bit out, updates counts and may set up next byte"
        }
      ]
    },
    {
      "start": 8702,
      "end": 8732,
      "name": "tape_write_shift_count_and_new_byte_setup",
      "description": "Executed when a full bit (two half-cycles) has completed. Shifts the just-written bit out of the tape write byte (LSR $BD), decrements the bit count ($A3) and tests for end-of-byte (BEQ to parity/send-next). If data bits remain it restores registers and exits. When a byte completes, it calls new-byte setup (JSR $FB97), re-enables interrupts (CLI), handles cassette synchronization byte counting ($A5), clears the checksum ($D7 = 0), decrements the sync counter, and adjusts the sync value for the 'load' copy by checking copies ($BE) and ORA #$80, then stores the sync byte into $BD for transmission.",
      "references": [
        {
          "chunk": "tape_write_start_bit_and_bit_send_phase",
          "topic": "explains how the previous bit-cycle code leads into shifting and counting logic for byte completion"
        },
        {
          "chunk": "tape_write_block_data_and_checksum",
          "topic": "when synchronization bytes are exhausted, this chunk handles reading block data and checksum processing"
        }
      ]
    },
    {
      "start": 8733,
      "end": 8752,
      "name": "tape_write_block_data_and_checksum",
      "description": "Handles sending actual block data after sync bytes are done and deals with the checksum. Calls a pointer-check routine (JSR $FCD1) to decide whether the buffer pointer has reached the end. If pointer indicates block-complete, prepares the checksum byte to be written (INC $AD to force subsequent block-complete branch, LDA $D7 STA $BD) and exits. If block not complete, fetches the next byte from the buffer (LDY #$00; LDA ($AC),Y), stores it as the next tape write byte ($BD), XORs it into the checksum ($D7), calls the pointer-increment routine (JSR $FCDB) and returns.",
      "references": [
        {
          "chunk": "tape_write_shift_count_and_new_byte_setup",
          "topic": "continuation: when sync bytes are finished this chunk reads and processes block data"
        },
        {
          "chunk": "tape_write_parity_send",
          "topic": "if all data bits of a byte are done, control may transfer to parity-bit sending handled in that chunk"
        }
      ]
    },
    {
      "start": 8753,
      "end": 8757,
      "name": "tape_write_parity_send",
      "description": "Prepares and sends the parity bit after all data bits of a byte have been transmitted. Toggles the parity flip stored in $9B (LDA $9B; EOR #$01) and places the result into the tape write byte register ($BD) to be transmitted on the next bit cycles, then exits (JMP $FEBC).",
      "references": [
        {
          "chunk": "tape_write_shift_count_and_new_byte_setup",
          "topic": "this is the next step when a byte's data bits are exhausted (parity bit follows)"
        }
      ]
    },
    {
      "start": 8758,
      "end": 8768,
      "name": "tape_write_block_complete_and_leader_setup",
      "description": "Handles the end-of-block completion and post-block setup. Decrements copies count ($BE); if more copies remain it continues, otherwise it stops the cassette motor (JSR $FCCA). Sets the tape-write leader count ($A7 = #$50), prepares the leader-vector index (LDX #$08), disables interrupts (SEI) and sets the tape vector (JSR $FCBD) before the final branch back to restore/exit.",
      "references": [
        {
          "chunk": "tape_write_irq_header_and_first_start_cycle",
          "topic": "the block-complete jump (JMP $FC57) from the start-cycle code leads here to finish block processing"
        }
      ]
    },
    {
      "start": 8769,
      "end": 8790,
      "name": "write_tape_leader_irq_routine",
      "description": "Write tape leader IRQ routine: sets time constant (#$78) via JSR $FBAF, toggles tape and decrements leader cycle counters ($A7, $AB). When leader finished sets tape write vector and enables interrupts; uses $A5/$B6 to set sync counts. Interacts with $FB97 (new byte setup) and $FCBD (set tape vector).",
      "references": [
        {
          "chunk": "tape_write_irq_routine",
          "topic": "leader writing performed after block copy operations"
        },
        {
          "chunk": "set_tape_vector",
          "topic": "sets IRQ vector for tape routines (JSR $FCBD)"
        }
      ]
    },
    {
      "start": 8791,
      "end": 8807,
      "name": "restore_everything_for_STOP",
      "description": "Restore system state for STOP: save status (PHP), disable interrupts (SEI), adjust VIC vertical fine scroll D011 to unblank screen, stop cassette motor (JSR $FCCA), disable interrupts via VIA ICR ($DC0D), restore vectors (calls $FDDD), restore saved IRQ vectors from $02A0/$029F to $0315/$0314 if non-zero, restore status and return (PLP, RTS).",
      "references": [
        {
          "chunk": "stop_cassette_motor",
          "topic": "stop cassette motor via $FCCA"
        },
        {
          "chunk": "set_tape_vector",
          "topic": "tape vector settings restored/cleared during STOP"
        }
      ]
    },
    {
      "start": 8808,
      "end": 8808,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8809,
      "end": 8812,
      "name": "reset_vector_entry",
      "description": "Reset vector entry: JSR $FC93 (restore everything for STOP) and branch always to restore/exit. Used as reset vector handler entry point.",
      "references": [
        {
          "chunk": "restore_everything_for_STOP",
          "topic": "called from reset vector"
        }
      ]
    },
    {
      "start": 8813,
      "end": 8818,
      "name": "set_tape_vector",
      "description": "Set tape IRQ vector: LDA $FD93,X -> STA $0314 (IRQ vector low), LDA $FD94,X -> STA $0315 (IRQ vector high). RTS. Used to point $0314/$0315 to appropriate tape IRQ routines indexed by X.",
      "references": [
        {
          "chunk": "write_tape_leader_irq_routine",
          "topic": "calls this to set tape IRQ vector"
        },
        {
          "chunk": "tape_write_irq_routine",
          "topic": "vectors used when writing tape leader/data"
        }
      ]
    },
    {
      "start": 8819,
      "end": 8819,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8820,
      "end": 8824,
      "name": "stop_cassette_motor",
      "description": "Stop the cassette motor by manipulating 6510 port $01: read $01, OR #$20 (turn motor off bit), STA $01, RTS.",
      "references": [
        {
          "chunk": "restore_everything_for_STOP",
          "topic": "called when restoring system during STOP"
        }
      ]
    },
    {
      "start": 8825,
      "end": 8825,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8826,
      "end": 8833,
      "name": "check_read_write_pointer",
      "description": "Compare buffer pointer with end pointer and return with carry set if pointer >= end. Uses $AC (buffer low) - $AE (end low), and $AD (buffer high) - $AF (end high). SEC before subtraction and RTS.",
      "references": [
        {
          "chunk": "tape_write_irq_routine",
          "topic": "uses this routine to decide block completion"
        }
      ]
    },
    {
      "start": 8834,
      "end": 8834,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8835,
      "end": 8839,
      "name": "increment_read_write_pointer",
      "description": "Increment buffer address low byte $AC and if overflow increments high byte $AD. RTS.",
      "references": [
        {
          "chunk": "tape_write_irq_routine",
          "topic": "called to step through tape buffer addresses"
        }
      ]
    },
    {
      "start": 8840,
      "end": 8840,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8841,
      "end": 8855,
      "name": "reset_hardware_startup",
      "description": "Hardware reset entry: setup stack (LDX #$FF, TXS), SEI, CLD, call $FD02 to scan for autostart ROM at $8000, optionally JMP indirect ($8000) if autostart present, else continue initialization: restore horizontal fine scroll $D016 from X, JSR $FDA3 (initialise SID/CIA/IRQ), JSR $FD50 (RAM test), JSR $FD15 (restore default vectors), JSR $FF5B (initialise VIC/screen editor), CLI, and JMP ($A000) to run BASIC.",
      "references": [
        {
          "chunk": "scan_for_autostart_rom_and_signature",
          "topic": "scans $8000 for autostart image"
        },
        {
          "chunk": "initialise_sid_cia_and_irq",
          "topic": "initialises chips and IRQs"
        },
        {
          "chunk": "test_ram_and_find_ram_end",
          "topic": "RAM test called during reset"
        }
      ]
    },
    {
      "start": 8856,
      "end": 8856,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8857,
      "end": 8866,
      "name": "scan_for_autostart_rom_and_signature",
      "description": "Scan for autostart ROM at $8000: tests five characters (LDX #$05) comparing bytes at $FD0F,X with $8003,X. Returns Z=1 if match. Following this is the autostart signature bytes 'CBM80' at $FD10-$FD14.",
      "references": [
        {
          "chunk": "reset_hardware_startup",
          "topic": "called early during reset to detect autostart ROM"
        }
      ]
    },
    {
      "start": 8867,
      "end": 8867,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8868,
      "end": 8903,
      "name": "restore_default_io_vectors",
      "description": "Restore default I/O vectors: sets pointer to vector table at $0314 (LDX #$30, LDY #$FD), then reads or writes 31 bytes between $0314,Y and (XY) depending on carry. Contains alternate version in comments that avoids writing to ROM by writing extra copy to RAM. Ends with RTS.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "uses the vector table at $0314-$0332"
        }
      ]
    },
    {
      "start": 8904,
      "end": 8904,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8905,
      "end": 8929,
      "name": "kernal_vectors_list",
      "description": "KERNAL vector table ($0314 onward). Provides default vector addresses for many KERNAL services: IRQ ($0314), BRK ($0316), NMI ($0318), OPEN ($031A), CLOSE ($031C), CHKIN ($031E), CHKOUT ($0320), CLRCHN ($0322), CHRIN ($0324), CHROUT ($0326), STOP key scan ($0328), GETIN ($032A), CLRCHNALL ($032C), user function ($032E), LOAD ($0330), SAVE ($0332). Includes explanatory notes on $032E legacy behavior.",
      "references": [
        {
          "chunk": "restore_default_io_vectors",
          "topic": "routine that (re)initialises these vectors"
        },
        {
          "chunk": "irq_vector_dispatch",
          "topic": "vectors used by IRQ/BRK/NMI dispatch"
        }
      ]
    },
    {
      "start": 8930,
      "end": 8970,
      "name": "test_ram_and_find_ram_end",
      "description": "RAM test and memory top detection: clears page zero and other pages, sets tape buffer pointer ($B2/$B3), iterates to write/test patterns (0x55, rotated patterns) to detect RAM top, adjusts $C2 pointer, then calls $FE2D to set top of memory. Stores OS start ($0282) and screen page ($0288). RTS.",
      "references": [
        {
          "chunk": "reset_hardware_startup",
          "topic": "called during reset to locate RAM end"
        },
        {
          "chunk": "read_set_top_of_memory",
          "topic": "writes memory top via $FE2D"
        }
      ]
    },
    {
      "start": 8971,
      "end": 8971,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8972,
      "end": 8976,
      "name": "tape_irq_vector_table",
      "description": "Tape IRQ vector bytes at $FD9B-$FDA1, mapping tape routines to IRQ slots: write tape leader IRQ ($08) @ $FD9B, tape write IRQ ($0A) @ $FD9D, normal IRQ ($0C) @ $FD9F, read tape bits IRQ ($0E) @ $FDA1.",
      "references": [
        {
          "chunk": "set_tape_vector",
          "topic": "uses vectors stored in this table"
        },
        {
          "chunk": "tape_write_irq_routine",
          "topic": "uses the tape write IRQ vector"
        }
      ]
    },
    {
      "start": 8977,
      "end": 8977,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8978,
      "end": 9015,
      "name": "initialise_sid_cia_and_irq",
      "description": "Initialise SID, CIA and IRQs: disable interrupts (LDA #$7F -> STA $DC0D/$DD0D), clear VIA registers (DRA/DDRA etc), set VIA CRA/CRB for timer single-shot ($DC0E/$DD0E/$DC0F/$DD0F), configure data direction registers ($DC03, $DD03, $DC02, $DD02), clear SID volume/filter select ($D418), set 6510 port $01 ($01) and DDR $00, detect PAL/NTSC at $02A6 and set VIA timer A values accordingly ($DC04/$DC05). Jumps to further initialisation ($FF6E/$FDF3) depending on PAL/NTSC.",
      "references": [
        {
          "chunk": "reset_hardware_startup",
          "topic": "called during reset to initialise chips"
        },
        {
          "chunk": "initialise_vic_and_screen_editor",
          "topic": "subsequent initialisation performed after this"
        }
      ]
    },
    {
      "start": 9016,
      "end": 9016,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9017,
      "end": 9021,
      "name": "set_filename",
      "description": "Set filename pointer and length for I/O operations: STA $B7 (length), STX $BB (pointer low), STY $BC (pointer high). RTS.",
      "references": [
        {
          "chunk": "set_filename_wrapper",
          "topic": "wrapper entry at $FFBD"
        }
      ]
    },
    {
      "start": 9022,
      "end": 9022,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9023,
      "end": 9027,
      "name": "set_logical_first_second_addresses",
      "description": "Set logical file info: STA $B8 (logical file), STX $BA (device number), STY $B9 (secondary address). RTS.",
      "references": [
        {
          "chunk": "set_logical_addresses_wrapper",
          "topic": "wrapper at $FFBA / $FFBA jump"
        }
      ]
    },
    {
      "start": 9028,
      "end": 9028,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9029,
      "end": 9039,
      "name": "read_io_status_word",
      "description": "Read I/O status word: checks device number in $BA; if device == RS232 ($02) reads RS232 status at $0297, clears it, and returns previous status on stack. Uses PHA/PLA to preserve status. RTS.",
      "references": [
        {
          "chunk": "read_io_status_word_wrapper",
          "topic": "wrapper at $FFB7"
        }
      ]
    },
    {
      "start": 9040,
      "end": 9040,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9041,
      "end": 9048,
      "name": "control_kernal_messages",
      "description": "Control printing of KERNAL messages: STA $9D (message mode flag) and LDA $90 (serial status byte). Used to select error/control message printing. Returns via RTS.",
      "references": [
        {
          "chunk": "control_kernal_messages_wrapper",
          "topic": "wrapper at $FF90"
        }
      ]
    },
    {
      "start": 9049,
      "end": 9049,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9050,
      "end": 9052,
      "name": "set_timeout_on_serial_bus",
      "description": "Set serial bus timeout flag: STA $0285 stores the timeout configuration (bit 7 enable/disable). RTS.",
      "references": [
        {
          "chunk": "set_timeout_on_serial_bus_wrapper",
          "topic": "wrapper at $FFA2"
        }
      ]
    },
    {
      "start": 9053,
      "end": 9053,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9054,
      "end": 9064,
      "name": "read_set_top_of_memory",
      "description": "Read/set top of memory: Branch on carry to read or set. If reading (carry set) LDX $0283 and LDY $0284 to return pointer. If setting (carry clear) STX $0283 and STY $0284 to change top of memory. RTS.",
      "references": [
        {
          "chunk": "test_ram_and_find_ram_end",
          "topic": "calls this to set top of memory"
        },
        {
          "chunk": "read_set_top_of_memory_wrapper",
          "topic": "wrapper at $FF99"
        }
      ]
    },
    {
      "start": 9065,
      "end": 9065,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9066,
      "end": 9072,
      "name": "read_set_bottom_of_memory",
      "description": "Read/set bottom of memory: Branch on carry to read or set. If reading (carry set) LDX $0281 and LDY $0282; when setting STX $0281 and STY $0282. RTS.",
      "references": [
        {
          "chunk": "read_set_bottom_wrapper",
          "topic": "wrapper at $FF9C"
        }
      ]
    },
    {
      "start": 9073,
      "end": 9073,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9074,
      "end": 9076,
      "name": "nmi_vector_entry",
      "description": "NMI vector entry: disable interrupts (SEI) then JMP ($0318) to the NMI vector handler. No local work done here.",
      "references": [
        {
          "chunk": "nmi_handler",
          "topic": "actual NMI handler executed via vector"
        }
      ]
    },
    {
      "start": 9077,
      "end": 9077,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9078,
      "end": 9141,
      "name": "nmi_handler",
      "description": "NMI handler: saves A/X/Y on stack, disables interrupts, saves VIA 2 ICR, checks for autostart ROM and triggers autostart if present, increments real time clock (JSR $F6BC), scans stop key (JSR $FFE1), handles BRK/user-function default vector if STOP pressed (calls $FD15, $FDA3, $E518 then JMP into BASIC break handler), and runs RS232 NMI handling sublogic. Restores processor state and RTI at end. Interacts with VIA 2 registers ($DD0D), and RS232 interrupt enable byte $02A1.",
      "references": [
        {
          "chunk": "scan_for_autostart_rom_and_signature",
          "topic": "autostart detection used by NMI"
        },
        {
          "chunk": "rs232_interrupt_and_timing_handlers",
          "topic": "RS232 NMI handling uses FED6.. block"
        },
        {
          "chunk": "restore_default_io_vectors",
          "topic": "user-function default vector invoked via $FD15"
        }
      ]
    },
    {
      "start": 9142,
      "end": 9142,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9143,
      "end": 9162,
      "name": "baud_rate_tables_ntsc",
      "description": "Baud rate computation notes and NTSC baud rate table. Formula: (system clock / baud rate) / 2 - 100. System clocks: PAL 985248 Hz, NTSC 1022727 Hz. Table entries at $FEC2-$FED4 provide low/high bytes for baud word for common rates (50,75,110,134.5,150,300,600,1200,1800,2400).",
      "references": [
        {
          "chunk": "rs232_interrupt_and_timing_handlers",
          "topic": "baud words used by RS232 timing routines"
        }
      ]
    },
    {
      "start": 9163,
      "end": 9210,
      "name": "rs232_interrupt_and_timing_handlers",
      "description": "RS232 bit handling routines: Reads VIA 2 DRB for Rx bit ($DD01), stores received bit into $A7, adjusts VIA 2 timer B ($DD06/$DD07) for bit timing, starts timer B single-shot by writing $DD0F, updates RS-232 interrupt enable byte $02A1, and includes nonstandard bit timing routines ($FF07-$FF37) to set VIA timers from stored timing words at $0295/$0296/$0299/$029A. Ends by jumping into higher-level RS232 handler ($EF59).",
      "references": [
        {
          "chunk": "baud_rate_tables_ntsc",
          "topic": "baud word table used to compute timer values"
        },
        {
          "chunk": "nmi_handler",
          "topic": "called from NMI RS232 handling paths"
        }
      ]
    },
    {
      "start": 9211,
      "end": 9220,
      "name": "unused_and_save_status_for_irq",
      "description": "Small utilities and IRQ entry prologue: NOPs at $FF41-$FF42 (waste cycles), PHP/PLA/AND/ PHA sequence to prepare modified processor status for IRQ entry. Saves processor status with BRK bit cleared before further IRQ processing.",
      "references": [
        {
          "chunk": "irq_vector_dispatch",
          "topic": "prologue used prior to IRQ dispatch"
        }
      ]
    },
    {
      "start": 9221,
      "end": 9232,
      "name": "irq_vector_dispatch",
      "description": "IRQ dispatch entry: saves A,X,Y to stack and stack pointer (TSX), reads stacked status to detect BRK. If BRK set jumps to BRK vector ($0316), else jumps to IRQ vector ($0314). Used to dispatch iBRK/iIRQ.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "uses vectors at $0314/$0316 for IRQ/BRK"
        }
      ]
    },
    {
      "start": 9233,
      "end": 9233,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9234,
      "end": 9241,
      "name": "initialise_vic_and_screen_editor",
      "description": "Initialise VIC and screen editor: JSR $E518 (initialise screen & keyboard), wait for raster $00 (poll $D012), read VIC interrupt flag $D019 to detect PAL/NTSC, store result at $02A6, then JMP $FDDD to continue initialisation.",
      "references": [
        {
          "chunk": "initialise_sid_cia_and_irq",
          "topic": "called earlier during system reset sequence"
        }
      ]
    },
    {
      "start": 9242,
      "end": 9242,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9243,
      "end": 9250,
      "name": "init_timerA_and_serial_clock",
      "description": "Set up VIA 1 timer A: enable timer A interrupt (#$81 into $DC0D), read $DC0E, mask/load bits to set TOD and load/start timer A, write CRA ($DC0E) with start bits and then jump to set serial clock low ($EE8E).",
      "references": [
        {
          "chunk": "initialise_vic_and_screen_editor",
          "topic": "continues device initialisation"
        }
      ]
    },
    {
      "start": 9251,
      "end": 9251,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9252,
      "end": 9256,
      "name": "unused_padding_and_reentry",
      "description": "Unused byte(s) (0x03) followed by a jump to re-run VIC/screen initialisation ($FF5B). Acts as small padding/unusued area.",
      "references": [
        {
          "chunk": "initialise_vic_and_screen_editor",
          "topic": "jump target to initialise VIC"
        }
      ]
    },
    {
      "start": 9257,
      "end": 9257,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9258,
      "end": 9262,
      "name": "initialisation_jmp_shortcuts",
      "description": "Short JMP entries to reuse initialization routines: $FF81 JMP $FF5B (initialise VIC), $FF84 JMP $FDA3 (initialise SID/CIA/IRQ), $FF87 JMP $FD50 (RAM test). These are dispatch points used during reset/startup.",
      "references": [
        {
          "chunk": "reset_hardware_startup",
          "topic": "reset uses these short jumps during boot"
        }
      ]
    },
    {
      "start": 9263,
      "end": 9263,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9264,
      "end": 9268,
      "name": "restore_default_io_vectors_wrapper",
      "description": "KERNAL wrapper at $FF8A that JMPs to $FD15 to restore default I/O vectors (convenience API entry).",
      "references": [
        {
          "chunk": "restore_default_io_vectors",
          "topic": "actual implementation at $FD15"
        }
      ]
    },
    {
      "start": 9269,
      "end": 9278,
      "name": "read_set_vectored_io_wrapper",
      "description": "Wrapper at $FF8D that JMPs to $FD1A to read or set vectored I/O. Provides API entry for reading/writing the vector list stored at $0314.",
      "references": [
        {
          "chunk": "restore_default_io_vectors",
          "topic": "operates on the same vector table"
        }
      ]
    },
    {
      "start": 9279,
      "end": 9279,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9280,
      "end": 9290,
      "name": "control_kernal_messages_wrapper",
      "description": "Wrapper at $FF90 that JMPs to $FE18 to set the KERNAL message mode (enable/disable error/control messages).",
      "references": [
        {
          "chunk": "control_kernal_messages",
          "topic": "implementation at $FE18"
        }
      ]
    },
    {
      "start": 9291,
      "end": 9299,
      "name": "send_secondary_after_listen_wrapper",
      "description": "Wrapper at $FF93 that JMPs to $EDB9 to send a secondary address after a LISTEN command on the serial bus.",
      "references": [
        {
          "chunk": "serial_bus_secondary_address_send",
          "topic": "secondary address transmit routine ($EDB9) (external)"
        }
      ]
    },
    {
      "start": 9300,
      "end": 9300,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9301,
      "end": 9307,
      "name": "send_secondary_after_talk_wrapper",
      "description": "Wrapper at $FF96 that JMPs to $EDC7 to send a secondary address after TALK (send secondary to talk devices).",
      "references": [
        {
          "chunk": "serial_bus_secondary_address_send",
          "topic": "secondary address transmit routine ($EDC7) (external)"
        }
      ]
    },
    {
      "start": 9308,
      "end": 9308,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9309,
      "end": 9314,
      "name": "read_set_top_of_memory_wrapper",
      "description": "Wrapper at $FF99 that JMPs to $FE25 to read or set the top of memory (carry=1 read; carry=0 set).",
      "references": [
        {
          "chunk": "read_set_top_of_memory",
          "topic": "implementation at $FE25"
        }
      ]
    },
    {
      "start": 9315,
      "end": 9315,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9316,
      "end": 9321,
      "name": "read_set_bottom_wrapper",
      "description": "Wrapper at $FF9C that JMPs to $FE34 to read or set the bottom of memory (carry semantics).",
      "references": [
        {
          "chunk": "read_set_bottom_of_memory",
          "topic": "implementation at $FE34"
        }
      ]
    },
    {
      "start": 9322,
      "end": 9322,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9323,
      "end": 9327,
      "name": "scan_keyboard_wrapper",
      "description": "Wrapper at $FF9F that JMPs to $EA87 to scan the keyboard and queue pressed keys. Returns ASCII in queue for CHRIN/GETIN.",
      "references": [
        {
          "chunk": "keyboard_scan_interrupt_routine",
          "topic": "keyboard scanning performed by IRQ handler (external)"
        }
      ]
    },
    {
      "start": 9328,
      "end": 9328,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9329,
      "end": 9338,
      "name": "set_timeout_wrapper",
      "description": "Wrapper at $FFA2 that JMPs to $FE21 to set serial bus timeout flag. Bit 7 in accumulator controls enable/disable of timeouts.",
      "references": [
        {
          "chunk": "set_timeout_on_serial_bus",
          "topic": "implementation at $FE21"
        }
      ]
    },
    {
      "start": 9339,
      "end": 9339,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9340,
      "end": 9350,
      "name": "input_byte_from_serial_bus_wrapper",
      "description": "Wrapper at $FFA5 that JMPs to $EE13 to input a byte from the serial bus with full handshaking. TALK must be used first and TKSA used for secondary addresses.",
      "references": [
        {
          "chunk": "serial_input_sequence",
          "topic": "EE13 serial input implementation (external)"
        }
      ]
    },
    {
      "start": 9351,
      "end": 9351,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9352,
      "end": 9362,
      "name": "output_byte_to_serial_bus_wrapper",
      "description": "Wrapper at $FFA8 that JMPs to $EDDD to output a byte to the serial bus with full handshaking. LISTEN must be used before calling. Buffers one character and handles EOI on UNLISTEN.",
      "references": [
        {
          "chunk": "serial_output_sequence",
          "topic": "EDDD serial output implementation (external)"
        }
      ]
    },
    {
      "start": 9363,
      "end": 9363,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9364,
      "end": 9367,
      "name": "command_untalk_wrapper",
      "description": "Wrapper at $FFAB that JMPs to $EDEF to send an UNTALK command on the serial bus (stop devices talking).",
      "references": [
        {
          "chunk": "serial_bus_control",
          "topic": "UNTALK implementation (external)"
        }
      ]
    },
    {
      "start": 9368,
      "end": 9368,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9369,
      "end": 9376,
      "name": "command_unlisten_wrapper",
      "description": "Wrapper at $FFAE that JMPs to $EDFE to send an UNLISTEN command on the serial bus (stop devices listening).",
      "references": [
        {
          "chunk": "serial_bus_control",
          "topic": "UNLISTEN implementation (external)"
        }
      ]
    },
    {
      "start": 9377,
      "end": 9377,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9378,
      "end": 9384,
      "name": "command_listen_wrapper",
      "description": "Wrapper at $FFB1 that JMPs to $ED0C to command a device on the serial bus to LISTEN. Accumulator must hold device number (4..31).",
      "references": [
        {
          "chunk": "serial_bus_control",
          "topic": "LISTEN implementation (external)"
        }
      ]
    },
    {
      "start": 9385,
      "end": 9385,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9386,
      "end": 9390,
      "name": "command_talk_wrapper",
      "description": "Wrapper at $FFB4 that JMPs to $ED09 to command a device on the serial bus to TALK. Accumulator must hold device number (4..30).",
      "references": [
        {
          "chunk": "serial_bus_control",
          "topic": "TALK implementation (external)"
        }
      ]
    },
    {
      "start": 9391,
      "end": 9391,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9392,
      "end": 9397,
      "name": "read_io_status_word_wrapper",
      "description": "Wrapper at $FFB7 that JMPs to $FE07 to read the device I/O status word; useful after serial operations to check errors/timeouts/status.",
      "references": [
        {
          "chunk": "read_io_status_word",
          "topic": "implementation reads RS232 status for device 2"
        }
      ]
    },
    {
      "start": 9398,
      "end": 9398,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9399,
      "end": 9418,
      "name": "set_logical_addresses_wrapper",
      "description": "Wrapper at $FFBA that JMPs to $FE00 to set logical file number (STA $B8), device number (STX $BA) and secondary address (STY $B9). Includes device number table description and usage notes.",
      "references": [
        {
          "chunk": "set_logical_first_second_addresses",
          "topic": "implementation at $FE00"
        }
      ]
    },
    {
      "start": 9419,
      "end": 9419,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9420,
      "end": 9427,
      "name": "set_filename_wrapper",
      "description": "Wrapper at $FFBD that JMPs to $FDF9 to set the filename (length in A, XY pointer to filename).",
      "references": [
        {
          "chunk": "set_filename",
          "topic": "implementation at $FDF9"
        }
      ]
    },
    {
      "start": 9428,
      "end": 9428,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9429,
      "end": 9452,
      "name": "open_logical_file_wrapper",
      "description": "Wrapper at $FFC0 that JMPs ($031A) to the open logical file vector. OPEN sets up logical file table entries and must be preceded by SETLFS and SETNAM.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "OPEN vector at $031A"
        }
      ]
    },
    {
      "start": 9453,
      "end": 9453,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9454,
      "end": 9462,
      "name": "open_channel_for_input_wrapper",
      "description": "Wrapper at $FFC6 that JMPs ($031E) to open a channel for input (CHKIN). If device was on serial bus sends LISTEN/secondary automatically. Returns errors: 3=file not open,5=device not present,6:file not input.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "CHKIN vector at $031E"
        }
      ]
    },
    {
      "start": 9463,
      "end": 9463,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9464,
      "end": 9482,
      "name": "open_channel_for_output_wrapper",
      "description": "Wrapper at $FFC9 that JMPs ($0320) to open a channel for output (CHKOUT). Sends LISTEN/secondary for serial devices. Returns errors: 3=file not open,5=device not present,7:file not output.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "CHKOUT vector at $0320"
        }
      ]
    },
    {
      "start": 9483,
      "end": 9483,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9484,
      "end": 9496,
      "name": "close_input_and_output_channels_wrapper",
      "description": "Wrapper at $FFCC that JMPs ($0322) to close input and output channels. If serial channels are open sends UNTALK/UNLISTEN appropriately and resets I/O channels to defaults.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "CLRCHN vector at $0322"
        }
      ]
    },
    {
      "start": 9497,
      "end": 9511,
      "name": "input_character_from_channel_wrapper",
      "description": "Wrapper at $FFCF that JMPs ($0324) to input a character from the current input channel (CHRIN). For keyboard input it handles line editing and buffering into BASIC input buffer; returns character in A.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "CHRIN vector at $0324"
        }
      ]
    },
    {
      "start": 9512,
      "end": 9512,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9513,
      "end": 9524,
      "name": "output_character_to_channel_wrapper",
      "description": "Wrapper at $FFD2 that JMPs ($0326) to output a character to the current output channel (CHROUT). Care advised when sending to serial devices as multiple output channels may receive data.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "CHROUT vector at $0326"
        }
      ]
    },
    {
      "start": 9525,
      "end": 9525,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9526,
      "end": 9538,
      "name": "load_ram_from_device_wrapper",
      "description": "Wrapper at $FFD5 that JMPs to $F49E to load RAM from a device (or verify). Accumulator=0 for load, 1 for verify. SETLFS and SETNAM must be called first. Returns highest loaded RAM address.",
      "references": [
        {
          "chunk": "device_load_save_routines",
          "topic": "F49E implements load/verify (external)"
        }
      ]
    },
    {
      "start": 9539,
      "end": 9539,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9540,
      "end": 9548,
      "name": "save_ram_to_device_wrapper",
      "description": "Wrapper at $FFD8 that JMPs to $F5DD to save RAM to a device. Uses indirect page-zero address and XY target address. SETLFS/SETNAM required; special notes for device 1 (cassette).",
      "references": [
        {
          "chunk": "device_load_save_routines",
          "topic": "F5DD SAVE implementation (external)"
        }
      ]
    },
    {
      "start": 9549,
      "end": 9549,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9550,
      "end": 9556,
      "name": "set_real_time_clock_wrapper",
      "description": "Wrapper at $FFDB that JMPs to $F6E4 to set the real time clock. Time in jiffies should be in YXA (A=most significant) before calling.",
      "references": [
        {
          "chunk": "real_time_clock",
          "topic": "F6E4 clock set routine (external)"
        }
      ]
    },
    {
      "start": 9557,
      "end": 9557,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9558,
      "end": 9561,
      "name": "read_real_time_clock_wrapper",
      "description": "Wrapper at $FFDE that JMPs to $F6DD to read the real time clock into AXY (A most significant).",
      "references": [
        {
          "chunk": "real_time_clock",
          "topic": "F6DD read routine (external)"
        }
      ]
    },
    {
      "start": 9562,
      "end": 9562,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9563,
      "end": 9568,
      "name": "scan_stop_key_wrapper",
      "description": "Wrapper at $FFE1 that JMPs ($0328) to scan the STOP key. Returns Z set if STOP pressed, otherwise A contains last row of keyboard scan.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "STOP/scan vector at $0328"
        }
      ]
    },
    {
      "start": 9569,
      "end": 9569,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9570,
      "end": 9576,
      "name": "get_character_from_input_device_wrapper",
      "description": "Wrapper at $FFE4 that JMPs ($032A) to get a character from the input device (GETIN). For keyboard this behaves like CHRIN but returns 0 if buffer empty.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "GETIN vector at $032A"
        }
      ]
    },
    {
      "start": 9577,
      "end": 9577,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9578,
      "end": 9582,
      "name": "close_all_channels_and_files_wrapper",
      "description": "Wrapper at $FFE7 that JMPs ($032C) to close all open files and reset I/O channels. Useful cleanup routine.",
      "references": [
        {
          "chunk": "kernal_vectors_list",
          "topic": "CLRCHNALL vector at $032C"
        }
      ]
    },
    {
      "start": 9583,
      "end": 9583,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9584,
      "end": 9590,
      "name": "increment_real_time_clock_wrapper",
      "description": "Wrapper at $FFEA that JMPs to $F69B to increment the real time clock (normally called from IRQ at 1/60s).",
      "references": [
        {
          "chunk": "real_time_clock",
          "topic": "clock increment implementation at $F69B (external)"
        }
      ]
    },
    {
      "start": 9591,
      "end": 9594,
      "name": "return_xy_organization_of_screen_wrapper",
      "description": "Wrapper at $FFED that JMPs to $E505 to return the X,Y organisation of the screen in X and Y registers.",
      "references": [
        {
          "chunk": "screen_organisation",
          "topic": "E505 returns screen X/Y mapping (external)"
        }
      ]
    },
    {
      "start": 9595,
      "end": 9600,
      "name": "read_set_xy_cursor_position_wrapper",
      "description": "Wrapper at $FFF0 that JMPs to $E50A to read/set cursor X,Y position. Called with carry set to read XY into registers, carry clear to set cursor from XY.",
      "references": [
        {
          "chunk": "cursor_position",
          "topic": "E50A read/set cursor implementation (external)"
        }
      ]
    },
    {
      "start": 9601,
      "end": 9601,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9602,
      "end": 9606,
      "name": "return_base_address_of_io_devices_wrapper",
      "description": "Wrapper at $FFF3 that JMPs to $E500 to return the base address of memory-mapped I/O devices in XY.",
      "references": [
        {
          "chunk": "io_device_map",
          "topic": "E500 provides I/O base address (external)"
        }
      ]
    },
    {
      "start": 9607,
      "end": 9607,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9608,
      "end": 9609,
      "name": "rrby_signature",
      "description": "Data bytes 'RRBY' stored at $FFF6-$FFF9 (ASCII signature), used as data/identification in ROM.",
      "references": []
    },
    {
      "start": 9610,
      "end": 9610,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9611,
      "end": 9614,
      "name": "hardware_vectors_block",
      "description": "Hardware vectors in ROM: NMI vector ($FFFA -> $FE43), RESET vector ($FFFC -> $FCE2), IRQ vector ($FFFE -> $FF48). Bytes stored at $FFFA-$FFFE.",
      "references": [
        {
          "chunk": "nmi_vector_entry",
          "topic": "NMI vector points to NMI handler"
        },
        {
          "chunk": "reset_hardware_startup",
          "topic": "RESET vector points to hardware reset entry"
        },
        {
          "chunk": "irq_vector_dispatch",
          "topic": "IRQ vector points to IRQ entry routine"
        }
      ]
    }
  ],
  "source_md5": "8b43baa688afbcafa31a7bb09c96b8ea"
}
