{
  "source_file": "c64_rom_disassembly.txt",
  "context": "Fully Commented Commodore 64 ROM Disassembly - BASIC and KERNAL ROMs with 6502 assembly",
  "splits": [
    { "start": 1, "end": 29, "ignore": true, "reason": "Title, attribution, source URL, formatting notes" },
    {
      "start": 30, "end": 113,
      "name": "basic_rom_entry_commands",
      "description": "C64 BASIC ROM entry points and command dispatch tables at $A000 - cold/warm start entry, action addresses for primary commands END FOR NEXT DATA INPUT DIM READ LET GOTO RUN IF RESTORE GOSUB RETURN REM STOP ON WAIT LOAD SAVE VERIFY DEF POKE PRINT CONT LIST CLR CMD SYS OPEN CLOSE GET NEW, action addresses for functions SGN INT ABS USR FRE POS SQR RND LOG EXP COS SIN TAN ATN PEEK LEN STR$ VAL ASC CHR$ LEFT$ RIGHT$ MID$, operator precedence table",
      "references": [
        { "chunk": "basic_rom_keywords_errors", "topic": "BASIC keyword tokens, error messages, and message pointers" }
      ]
    },
    {
      "start": 114, "end": 233,
      "name": "basic_rom_keywords_errors",
      "description": "C64 BASIC ROM keyword token table and error messages - BASIC keyword token table with end markers, secondary keywords TAB TO SPC THEN NOT STEP, operators + - * / AND OR < = >, functions SGN through MID$ and GO, error messages 1-29 too many files through load, error message pointer table, BASIC messages OK ERROR IN READY BREAK, spare byte",
      "references": [
        { "chunk": "basic_rom_entry_commands", "topic": "BASIC ROM entry points and command dispatch tables" }
      ]
    },
    {
      "start": 234, "end": 353,
      "name": "basic_stack_memory_check",
      "description": "C64 BASIC stack and memory management routines - search stack for FOR/GOSUB activity, open space in memory set end of arrays, check room on stack for A bytes, check available memory do out of memory error if no room, garbage collection call and retry",
      "references": [
        { "chunk": "basic_error_warmstart", "topic": "Error handler, warm start, and BASIC input" }
      ]
    },
    {
      "start": 354, "end": 503,
      "name": "basic_error_warmstart",
      "description": "C64 BASIC error handling warm start and line editing - do out of memory error, error #X handler with message print, print string and warm start break entry, BASIC warm start vector, BASIC warm start loop read input, handle new BASIC line insert/delete copy crunched line into memory",
      "references": [
        { "chunk": "basic_stack_memory_check", "topic": "Stack and memory management routines" },
        { "chunk": "basic_tokenizer", "topic": "Tokenizer and line chaining" }
      ]
    },
    {
      "start": 504, "end": 654,
      "name": "basic_tokenizer",
      "description": "C64 BASIC tokenizer - rebuild BASIC line chaining, call for BASIC input, crunch BASIC tokens vector, crunch keywords into tokens with quote and DATA handling, REM skip, keyword table matching with shifted character shorthand",
      "references": [
        { "chunk": "basic_error_warmstart", "topic": "Error handler and BASIC line editing" },
        { "chunk": "basic_search_new_clr", "topic": "Line search, NEW, CLR, RESTORE commands" }
      ]
    },
    {
      "start": 655, "end": 751,
      "name": "basic_search_new_clr",
      "description": "C64 BASIC line search and memory commands - search BASIC for temporary integer line number, search from AX, perform NEW erase program, reset execute pointer and do CLR, perform CLR close channels clear strings variables arrays, do RESTORE and clear stack, flush BASIC stack clear continue pointer, set BASIC execute pointer to start of memory",
      "references": [
        { "chunk": "basic_tokenizer", "topic": "Tokenizer and line chaining" },
        { "chunk": "basic_list_uncrunch", "topic": "LIST command and token uncrunching" }
      ]
    },
    {
      "start": 752, "end": 851,
      "name": "basic_list_uncrunch",
      "description": "C64 BASIC LIST command and token uncrunching - perform LIST with optional line range n-m, print line numbers with detokenized output, handle quoted strings, uncrunch BASIC tokens vector, convert token bytes back to keyword text from table",
      "references": [
        { "chunk": "basic_search_new_clr", "topic": "Line search, NEW, CLR commands" },
        { "chunk": "basic_for_interpreter_loop", "topic": "FOR loop and interpreter inner loop" }
      ]
    },
    {
      "start": 852, "end": 977,
      "name": "basic_for_interpreter_loop",
      "description": "C64 BASIC FOR loop and interpreter inner loop - perform FOR setup push TO/STEP/variable on stack, interpreter inner loop with CTRL-C check, save continue pointer, check EOL/EOT, start new BASIC code execution, interpret BASIC code dispatch tokens to command routines, perform LET for non-token lines, handle GO TO",
      "references": [
        { "chunk": "basic_list_uncrunch", "topic": "LIST command" },
        { "chunk": "basic_flow_control", "topic": "RESTORE STOP END CONT RUN GOSUB GOTO RETURN" }
      ]
    },
    {
      "start": 978, "end": 1093,
      "name": "basic_flow_control",
      "description": "C64 BASIC flow control commands - perform RESTORE set DATA pointer, CTRL-C check vector, perform STOP/END with break message, perform CONT restore execution pointer, perform RUN clear and goto, perform GOSUB push return address, perform GOTO search for line number, search from start of memory or current position, perform RETURN pop stack restore line number",
      "references": [
        { "chunk": "basic_for_interpreter_loop", "topic": "FOR loop and interpreter" },
        { "chunk": "basic_data_if_on", "topic": "DATA IF REM ON commands and line number parsing" }
      ]
    },
    {
      "start": 1094, "end": 1199,
      "name": "basic_data_if_on",
      "description": "C64 BASIC DATA IF REM ON commands - perform RETURN error handling, undefined statement error, perform DATA skip to next statement, add Y to execute pointer, scan for next statement colon or EOL, scan for next line, perform IF evaluate condition then GOTO or THEN, perform REM skip to end of line, perform ON computed GOTO/GOSUB decrement counter and dispatch",
      "references": [
        { "chunk": "basic_flow_control", "topic": "RESTORE STOP END CONT RUN GOSUB GOTO RETURN" },
        { "chunk": "basic_let_linenumber", "topic": "LET assignment and line number parsing" }
      ]
    },
    {
      "start": 1200, "end": 1365,
      "name": "basic_let_linenumber",
      "description": "C64 BASIC LET and line number parsing - get fixed-point number into temporary integer multiply by 10 add digit, perform LET variable assignment evaluate expression, check numeric digit, assign value to numeric variable, assign string value copy descriptor, check not TI$",
      "references": [
        { "chunk": "basic_data_if_on", "topic": "DATA IF REM ON commands" },
        { "chunk": "basic_print_output", "topic": "PRINT CMD PRINT# output formatting" }
      ]
    },
    {
      "start": 1366, "end": 1516,
      "name": "basic_print_output",
      "description": "C64 BASIC PRINT output commands - perform PRINT# set channel and print, perform CMD set output channel, perform PRINT handle expressions TAB SPC comma semicolon, print formatted output, set XY to $0200-1 and print CR, print CR/LF, output cursor right, print null terminated string, print from utility pointer, print space or cursor right, print question mark, print character to output channel",
      "references": [
        { "chunk": "basic_let_linenumber", "topic": "LET assignment" },
        { "chunk": "basic_input_read", "topic": "GET INPUT READ commands" }
      ]
    },
    {
      "start": 1517, "end": 1721,
      "name": "basic_input_read",
      "description": "C64 BASIC input commands - bad input routine, perform GET single character, perform INPUT# from channel, close input/output channels, perform INPUT from keyboard with prompt, print question mark prompt, perform READ from DATA statements, perform GET from keyboard, input error messages EXTRA IGNORED and REDO FROM START",
      "references": [
        { "chunk": "basic_print_output", "topic": "PRINT output formatting" },
        { "chunk": "basic_next_expression", "topic": "NEXT loop and expression evaluator" }
      ]
    },
    {
      "start": 1722, "end": 1893,
      "name": "basic_next_expression",
      "description": "C64 BASIC NEXT and expression evaluation - input error messages, perform NEXT loop iteration compare with TO value check STEP sign, evaluate expression and check type mismatch, expression evaluator recursive descent parser, get vector execute function continue evaluation",
      "references": [
        { "chunk": "basic_input_read", "topic": "GET INPUT READ commands" },
        { "chunk": "basic_eval_stack_ops", "topic": "Stack operations and value parsing" }
      ]
    },
    {
      "start": 1894, "end": 2050,
      "name": "basic_eval_stack_ops",
      "description": "C64 BASIC evaluation stack and value operations - push sign round FAC1 put on stack, round FAC1 and put on stack, do functions dispatch, get value from line, get arithmetic element vector, PI as floating number, get value continued handle unary minus NOT FN functions, print quoted string to string utility area, evaluate expression handle open parenthesis",
      "references": [
        { "chunk": "basic_next_expression", "topic": "NEXT and expression evaluator" },
        { "chunk": "basic_variable_lookup", "topic": "Variable name setup and TI clock" }
      ]
    },
    {
      "start": 2051, "end": 2179,
      "name": "basic_variable_lookup",
      "description": "C64 BASIC variable lookup and system variables - check address range return Cb=1 if in BASIC ROM, variable name setup handle FN$ TI TI$ ST, create new variable if not found, set up variable from existing, read real time clock into FAC1 mantissa, get value from line continued numeric string handling",
      "references": [
        { "chunk": "basic_eval_stack_ops", "topic": "Stack operations and value parsing" },
        { "chunk": "basic_boolean_compare", "topic": "OR AND and comparison operators" }
      ]
    },
    {
      "start": 2180, "end": 2271,
      "name": "basic_boolean_compare",
      "description": "C64 BASIC boolean and comparison operators - perform OR bitwise, perform AND bitwise, perform comparisons less than equal greater than, handle string comparison, numeric comparison with FAC1 and FAC2, type checking string vs numeric mismatch error",
      "references": [
        { "chunk": "basic_variable_lookup", "topic": "Variable lookup and system variables" },
        { "chunk": "basic_dim_variable_search", "topic": "DIM and variable search" }
      ]
    },
    {
      "start": 2272, "end": 2462,
      "name": "basic_dim_variable_search",
      "description": "C64 BASIC DIM and variable search - perform DIM dimension array, search for variable in memory scan variable table, handle integer type variables, create new variable allocate 7 bytes, set variable pointer, -32768 as floating value, convert float to fixed, evaluate integer expression",
      "references": [
        { "chunk": "basic_boolean_compare", "topic": "Boolean and comparison operators" },
        { "chunk": "basic_array_operations", "topic": "Array find/make and element access" }
      ]
    },
    {
      "start": 2463, "end": 2577,
      "name": "basic_array_operations",
      "description": "C64 BASIC array operations - evaluate integer expression, find or make array allocation search array table, calculate array size multiply dimensions, allocate memory for new array, bad subscript error, illegal quantity error",
      "references": [
        { "chunk": "basic_dim_variable_search", "topic": "DIM and variable search" },
        { "chunk": "basic_array_access_functions", "topic": "Array element access POS DEF FN" }
      ]
    },
    {
      "start": 2578, "end": 2700,
      "name": "basic_array_access_functions",
      "description": "C64 BASIC array element access and functions - found array compute element offset, access multi-dimensional array elements, convert fixed integer AY to float FAC1, perform POS cursor position, perform DEF define user function",
      "references": [
        { "chunk": "basic_array_operations", "topic": "Array find/make" },
        { "chunk": "basic_fn_eval_str", "topic": "FN evaluation and STR$ string operations" }
      ]
    },
    {
      "start": 2701, "end": 2886,
      "name": "basic_fn_eval_str",
      "description": "C64 BASIC FN evaluation and STR$ - check FNx syntax validate function name, evaluate FNx user function call save/restore execute pointer and variable, restore BASIC execute pointer and function variable from stack, perform STR$ number to string conversion, do string vector",
      "references": [
        { "chunk": "basic_array_access_functions", "topic": "Array element access and POS DEF" },
        { "chunk": "basic_string_alloc_scan", "topic": "String space allocation and scanning" }
      ]
    },
    {
      "start": 2887, "end": 3002,
      "name": "basic_string_alloc_scan",
      "description": "C64 BASIC string allocation and scanning - restore execute pointer from stack, perform STR$ number to string, do string vector, make string space A bytes long, scan and setup string descriptor, evaluate length set string pointer",
      "references": [
        { "chunk": "basic_def_fn_str", "topic": "DEF FN and STR$" },
        { "chunk": "basic_string_garbage_collect", "topic": "String memory management and garbage collection" }
      ]
    },
    {
      "start": 3003, "end": 3211,
      "name": "basic_string_garbage_collect",
      "description": "C64 BASIC string memory and garbage collection - make space in string memory for string A long, garbage collection routine memory compaction scan variables arrays descriptors, find highest uncollected string, swap string to top of string space",
      "references": [
        { "chunk": "basic_string_alloc_scan", "topic": "String allocation and scanning" },
        { "chunk": "basic_string_concat_eval", "topic": "String concatenation and evaluation" }
      ]
    },
    {
      "start": 3212, "end": 3329,
      "name": "basic_string_concat_eval",
      "description": "C64 BASIC string concatenation and evaluation - concatenate two strings allocate space copy both, copy string from descriptor to utility pointer, evaluate string expression return descriptor, handle temporary strings clean up",
      "references": [
        { "chunk": "basic_string_garbage_collect", "topic": "String memory and garbage collection" },
        { "chunk": "basic_string_functions", "topic": "CHR$ LEFT$ RIGHT$ MID$ LEN ASC" }
      ]
    },
    {
      "start": 3330, "end": 3465,
      "name": "basic_string_functions",
      "description": "C64 BASIC string functions - perform CHR$ character from code, perform LEFT$ substring from start, perform RIGHT$ substring from end, perform MID$ substring from position, pull string data and byte parameter from stack, perform LEN string length, evaluate string get length in Y, perform ASC first character code, illegal quantity error, scan and get byte parameter, evaluate byte expression result in X",
      "references": [
        { "chunk": "basic_string_concat_eval", "topic": "String concatenation and evaluation" },
        { "chunk": "basic_val_poke_wait", "topic": "VAL PEEK POKE WAIT commands" }
      ]
    },
    {
      "start": 3466, "end": 3559,
      "name": "basic_val_poke_wait",
      "description": "C64 BASIC VAL POKE WAIT commands - perform VAL string to number conversion, restore BASIC execute pointer from temp, get parameters for POKE/WAIT address and byte, convert FAC1 to integer in temporary integer, perform PEEK memory read, perform POKE memory write, perform WAIT memory test loop until condition",
      "references": [
        { "chunk": "basic_string_functions", "topic": "CHR$ LEFT$ RIGHT$ MID$ LEN ASC" },
        { "chunk": "basic_float_add_sub", "topic": "Floating point addition and subtraction" }
      ]
    },
    {
      "start": 3560, "end": 3714,
      "name": "basic_float_add_sub",
      "description": "C64 BASIC floating point addition and subtraction - add 0.5 round FAC1, perform subtraction FAC1 from AY, subtract FAC1 from FAC2, add AY to FAC1, add FAC2 to FAC1 with mantissa alignment and overflow check, ABS and normalise FAC1, normalise FAC1 mantissa, clear FAC1 exponent sign, save FAC1 sign, add FAC2 mantissa to FAC1, negate FAC1 complement",
      "references": [
        { "chunk": "basic_val_poke_wait", "topic": "VAL POKE WAIT" },
        { "chunk": "basic_float_shift_log", "topic": "Floating point shift operations and LOG" }
      ]
    },
    {
      "start": 3715, "end": 3878,
      "name": "basic_float_shift_log",
      "description": "C64 BASIC floating point shift and LOG - negate FAC1 complement, overflow error, shift FCAtemp left A+8 times, LOG constants and series, perform LOG natural logarithm, do convert AY multiply FAC1 by AY",
      "references": [
        { "chunk": "basic_float_add_sub", "topic": "Floating point addition and subtraction" },
        { "chunk": "basic_float_multiply_divide", "topic": "Floating point multiply and divide" }
      ]
    },
    {
      "start": 3879, "end": 4043,
      "name": "basic_float_multiply_divide",
      "description": "C64 BASIC floating point multiply and divide - unpack memory AY into FAC2, test and adjust accumulators, multiply FAC1 by 10, 10 as floating value, divide FAC1 by 10, divide by AY, convert AY and do AY/FAC1 long division",
      "references": [
        { "chunk": "basic_float_shift_log", "topic": "Shift operations and LOG" },
        { "chunk": "basic_float_pack_convert", "topic": "FAC pack/unpack and type conversion" }
      ]
    },
    {
      "start": 4044, "end": 4175,
      "name": "basic_float_pack_convert",
      "description": "C64 BASIC FAC pack/unpack and type conversion - unpack memory AY into FAC1, pack FAC1 into $5C $57 variable pointer XY, copy FAC2 to FAC1, round and copy FAC1 to FAC2, round FAC1, get FAC1 sign, return sign in A, perform SGN, save A as integer byte, perform ABS, compare FAC1 with AY",
      "references": [
        { "chunk": "basic_float_multiply_divide", "topic": "Multiply and divide" },
        { "chunk": "basic_float_int_string", "topic": "Float-to-fixed INT and string conversion" }
      ]
    },
    {
      "start": 4176, "end": 4384,
      "name": "basic_float_int_string",
      "description": "C64 BASIC float to fixed INT and string conversion - perform ABS, compare FAC1 with AY, convert FAC1 floating to fixed, shift FAC1 A times right, perform INT floor function, clear FAC1 and return, get FAC1 from string parse decimal and scientific notation, do negate FAC1 and return",
      "references": [
        { "chunk": "basic_float_pack_convert", "topic": "FAC pack/unpack" },
        { "chunk": "basic_float_output", "topic": "FAC to ASCII string output" }
      ]
    },
    {
      "start": 4385, "end": 4606,
      "name": "basic_float_output",
      "description": "C64 BASIC FAC to ASCII output - limits for scientific mode, do IN line number message, print XA as unsigned integer, convert FAC1 to ASCII string result in AY with sign handling decimal point scientific notation, constants, jiffy counts, spare bytes",
      "references": [
        { "chunk": "basic_float_int_string", "topic": "Float-to-fixed and string conversion" },
        { "chunk": "basic_math_functions", "topic": "SQR power EXP functions" }
      ]
    },
    {
      "start": 4607, "end": 4681,
      "name": "basic_math_functions",
      "description": "C64 BASIC math functions - perform SQR square root, perform power function exponentiation, EXP constants and series, perform EXP exponential function e^x",
      "references": [
        { "chunk": "basic_float_output", "topic": "FAC to ASCII output" },
        { "chunk": "kernal_rnd_io_error", "topic": "KERNAL ROM start RND and I/O error handling" }
      ]
    },
    {
      "start": 4682, "end": 4810,
      "name": "kernal_rnd_io_error",
      "description": "C64 KERNAL ROM start at $E000 - EXP function continuation, RND values and perform RND random number generator seed from CIA timer, pack FAC1 into XY, handle BASIC I/O error, output character to channel with error check, input character from channel with error check",
      "references": [
        { "chunk": "basic_math_functions", "topic": "SQR power EXP" },
        { "chunk": "kernal_sys_load_save", "topic": "SYS LOAD SAVE OPEN CLOSE commands" }
      ]
    },
    {
      "start": 4811, "end": 4966,
      "name": "kernal_sys_load_save",
      "description": "C64 KERNAL BASIC I/O commands - pack FAC1, open channel for output/input with error check, get character from input device, perform SYS execute machine language save/restore registers, perform SAVE, perform VERIFY, perform LOAD, do READY return to BASIC, perform OPEN, perform CLOSE, get parameters for LOAD/SAVE",
      "references": [
        { "chunk": "kernal_rnd_io_error", "topic": "RND and I/O error handling" },
        { "chunk": "kernal_trig_init", "topic": "Trig functions and BASIC initialization" }
      ]
    },
    {
      "start": 4967, "end": 5137,
      "name": "kernal_trig_init",
      "description": "C64 KERNAL parameter scanning and trig functions - scan for comma and byte, get parameters for OPEN/CLOSE, set filename, perform COS SIN TAN trigonometric functions with series evaluation, perform ATN arctangent, ATN series constants",
      "references": [
        { "chunk": "kernal_sys_load_save", "topic": "SYS LOAD SAVE OPEN CLOSE" },
        { "chunk": "kernal_basic_startup", "topic": "BASIC startup CHRGET and initialization" }
      ]
    },
    {
      "start": 5138, "end": 5293,
      "name": "kernal_basic_startup",
      "description": "C64 KERNAL BASIC warm/cold start and initialization - BASIC warm start entry point, BASIC cold start entry point, character get subroutine for zero page CHRGET CHRGOT scan memory increment pointer, initialise BASIC RAM locations, print startup message initialise memory pointers, BASIC vectors copied to $0300, initialise BASIC vectors, BASIC startup messages, open channel for output",
      "references": [
        { "chunk": "kernal_trig_init", "topic": "Trig functions and parameter scanning" },
        { "chunk": "kernal_screen_init", "topic": "Screen editor initialization" }
      ]
    },
    {
      "start": 5294, "end": 5456,
      "name": "kernal_screen_init",
      "description": "C64 KERNAL screen initialization - open channel for output, flag RS232 start bit parity, save colour to colour RAM, wait for key from STOP key column, baud rate tables PAL, return base address I/O devices, return screen organization 40x25, read/set cursor position, initialise screen and keyboard, clear screen, home cursor, set screen pointers for cursor row column, orphan bytes, initialise VIC-II chip values",
      "references": [
        { "chunk": "kernal_basic_startup", "topic": "BASIC startup and initialization" },
        { "chunk": "kernal_keyboard_input", "topic": "Keyboard input and screen output" }
      ]
    },
    {
      "start": 5457, "end": 5616,
      "name": "kernal_keyboard_input",
      "description": "C64 KERNAL keyboard input - input from keyboard buffer, write character and wait for key, wait for key from keyboard handle cursor flash quote mode, input from screen or keyboard, if open quote toggle cursor quote flag, insert uppercase/graphic character",
      "references": [
        { "chunk": "kernal_screen_init", "topic": "Screen initialization" },
        { "chunk": "kernal_cursor_output", "topic": "Cursor movement and character output to screen" }
      ]
    },
    {
      "start": 5617, "end": 5786,
      "name": "kernal_cursor_output",
      "description": "C64 KERNAL cursor and character output - advance cursor handle line wrap, back onto previous line if possible, output character to screen handle control characters insert delete cursor movement reverse, colour codes, screen scrolling",
      "references": [
        { "chunk": "kernal_keyboard_input", "topic": "Keyboard input" },
        { "chunk": "kernal_screen_scroll_colour", "topic": "Screen scrolling and colour RAM" }
      ]
    },
    {
      "start": 5787, "end": 5951,
      "name": "kernal_screen_scroll_colour",
      "description": "C64 KERNAL screen scrolling and colour - output character continued, do newline, output CR carriage return, test line decrement/increment, set colour code from character, ASCII colour code table, scroll screen",
      "references": [
        { "chunk": "kernal_cursor_output", "topic": "Cursor and character output" },
        { "chunk": "kernal_screen_memory", "topic": "Screen memory operations" }
      ]
    },
    {
      "start": 5952, "end": 6144,
      "name": "kernal_screen_memory",
      "description": "C64 KERNAL screen memory operations - scroll screen continued, open space on screen, shift screen line up/down, calculate pointers to screen lines colour RAM, fetch screen address, clear screen line, orphan byte, print character A and colour X, save character and colour to screen at cursor, calculate pointer to colour RAM",
      "references": [
        { "chunk": "kernal_screen_scroll_colour", "topic": "Screen scrolling and colour" },
        { "chunk": "kernal_irq_keyboard_scan", "topic": "IRQ handler and keyboard scanning" }
      ]
    },
    {
      "start": 6145, "end": 6345,
      "name": "kernal_irq_keyboard_scan",
      "description": "C64 KERNAL IRQ and keyboard scan - IRQ vector handler scan keyboard check cursor flash update, scan keyboard matrix read CIA rows columns, evaluate SHIFT CTRL C= keys, table addresses for keyboard layouts",
      "references": [
        { "chunk": "kernal_screen_memory", "topic": "Screen memory operations" },
        { "chunk": "kernal_keyboard_tables", "topic": "Keyboard decode tables and VIC init values" }
      ]
    },
    {
      "start": 6346, "end": 6508,
      "name": "kernal_keyboard_tables",
      "description": "C64 KERNAL keyboard tables and VIC initialization - standard keyboard table, shifted keyboard table, CBM key keyboard table, check special character codes, control keyboard table, VIC-II chip initialisation values, keyboard buffer for auto load/run, low bytes of screen line addresses",
      "references": [
        { "chunk": "kernal_irq_keyboard_scan", "topic": "IRQ and keyboard scanning" },
        { "chunk": "kernal_serial_talk_listen", "topic": "Serial bus TALK and LISTEN" }
      ]
    },
    {
      "start": 6509, "end": 6623,
      "name": "kernal_serial_talk_listen",
      "description": "C64 KERNAL serial bus TALK LISTEN and transmit - command serial bus device to TALK $ED09, command devices to LISTEN $ED0C, send control character, defer command, transmit byte on serial bus bit-banging with handshake",
      "references": [
        { "chunk": "kernal_keyboard_tables", "topic": "Keyboard tables" },
        { "chunk": "kernal_serial_secondary_io", "topic": "Serial secondary address and byte I/O" }
      ]
    },
    {
      "start": 6624, "end": 6777,
      "name": "kernal_serial_secondary_io",
      "description": "C64 KERNAL serial secondary address and byte I/O - send secondary address after LISTEN, set serial ATN high, send secondary address after TALK, wait for serial bus end after send, output byte to serial bus, command serial bus UNTALK, command serial bus UNLISTEN, input byte from serial bus, set serial clock out high/low, set serial data out high/low, get serial data status in carry, 1ms delay",
      "references": [
        { "chunk": "kernal_serial_talk_listen", "topic": "Serial bus TALK LISTEN transmit" },
        { "chunk": "kernal_rs232_tx", "topic": "RS232 transmit routines" }
      ]
    },
    {
      "start": 6778, "end": 6883,
      "name": "kernal_rs232_tx",
      "description": "C64 KERNAL RS232 transmit routines - RS232 Tx NMI routine, do RS232 parity bit with bit count, setup next RS232 Tx byte from buffer, set DSR signal not present, set CTS signal not present, disable timer A interrupt, set VIA 2 ICR from A, compute bit count",
      "references": [
        { "chunk": "kernal_serial_secondary_io", "topic": "Serial byte I/O" },
        { "chunk": "kernal_rs232_rx", "topic": "RS232 receive and buffer routines" }
      ]
    },
    {
      "start": 6884, "end": 7070,
      "name": "kernal_rs232_rx",
      "description": "C64 KERNAL RS232 receive and buffer routines - RS232 Rx NMI receive, setup to receive RS232 bit, no start bit received, received whole byte add to buffer, open RS232 channel for output, send byte to RS232 buffer, setup for RS232 transmit, input from RS232 buffer, get byte from RS232 buffer, check RS232 bus idle",
      "references": [
        { "chunk": "kernal_rs232_tx", "topic": "RS232 transmit" },
        { "chunk": "kernal_io_messages", "topic": "Kernel I/O messages and character input" }
      ]
    },
    {
      "start": 7071, "end": 7195,
      "name": "kernal_io_messages",
      "description": "C64 KERNAL I/O messages and character input - kernel I/O messages strings I/O ERROR SEARCHING FOR LOADING SAVING, display control I/O message if in direct mode, get character from input device CHRIN, input character from channel handle keyboard screen RS232 serial, get byte from tape",
      "references": [
        { "chunk": "kernal_rs232_rx", "topic": "RS232 receive" },
        { "chunk": "kernal_chrout_chkin", "topic": "Character output and channel open" }
      ]
    },
    {
      "start": 7196, "end": 7363,
      "name": "kernal_chrout_chkin",
      "description": "C64 KERNAL character output and channel management - output character to channel CHROUT, output character to cassette or RS232 device, open channel for input CHKIN, open channel for output CHKOUT, close specified logical file",
      "references": [
        { "chunk": "kernal_io_messages", "topic": "I/O messages and character input" },
        { "chunk": "kernal_file_open_close", "topic": "File table management and OPEN" }
      ]
    },
    {
      "start": 7364, "end": 7516,
      "name": "kernal_file_open_close",
      "description": "C64 KERNAL file table and OPEN - serial bus device close, close file index X, find file in table, find file A, set file details from table, close all channels and files CLALL, close input output channels CLRCHN, open logical file OPEN",
      "references": [
        { "chunk": "kernal_chrout_chkin", "topic": "Character output and channel management" },
        { "chunk": "kernal_open_rs232_load", "topic": "RS232 device open and LOAD" }
      ]
    },
    {
      "start": 7517, "end": 7664,
      "name": "kernal_open_rs232_load",
      "description": "C64 KERNAL RS232 open and LOAD - send secondary address and filename, open RS232 device configure timer baud rate, set top of memory to F0xx, initialise RS232 output, load RAM from device LOAD with serial or tape",
      "references": [
        { "chunk": "kernal_file_open_close", "topic": "File table and OPEN" },
        { "chunk": "kernal_load_save_clock", "topic": "LOAD continuation SAVE and real time clock" }
      ]
    },
    {
      "start": 7665, "end": 7927,
      "name": "kernal_load_save_clock",
      "description": "C64 KERNAL LOAD/SAVE and clock - load continuation read bytes from serial/tape, print Searching Loading Verifying messages, print file name, save RAM to device SAVE with serial or tape, print Saving message, increment real time clock, read/set real time clock, scan stop key",
      "references": [
        { "chunk": "kernal_open_rs232_load", "topic": "RS232 open and LOAD" },
        { "chunk": "kernal_tape_header", "topic": "Tape header operations" }
      ]
    },
    {
      "start": 7928, "end": 8076,
      "name": "kernal_tape_header",
      "description": "C64 KERNAL tape header operations - file error messages too many files/file open/not open/not found/device not present/not input/output file/missing filename/illegal device number, find tape header exit with header in buffer, write tape header, get tape buffer start pointer, set tape buffer start and end pointers",
      "references": [
        { "chunk": "kernal_load_save_clock", "topic": "LOAD SAVE and clock" },
        { "chunk": "kernal_tape_find_play", "topic": "Tape find header and PLAY/RECORD" }
      ]
    },
    {
      "start": 8077, "end": 8212,
      "name": "kernal_tape_find_play",
      "description": "C64 KERNAL tape find and play - find specific tape header, bump tape pointer, wait for PLAY, return cassette sense in Zb, wait for PLAY/RECORD, initiate tape read, initiate tape write, tape read/write common, scan stop key flag abort",
      "references": [
        { "chunk": "kernal_tape_header", "topic": "Tape header operations" },
        { "chunk": "kernal_tape_encoding", "topic": "Tape stream encoding and timing" }
      ]
    },
    {
      "start": 8213, "end": 8450,
      "name": "kernal_tape_encoding",
      "description": "C64 KERNAL tape encoding and timing - scan stop key flag abort, clear saved IRQ address, set timing for tape pulses, tape stream symbols encoding four kinds of symbols short medium long break, tape read IRQ handling",
      "references": [
        { "chunk": "kernal_tape_find_play", "topic": "Tape find and PLAY/RECORD" },
        { "chunk": "kernal_tape_read_write", "topic": "Tape byte read/write and IRQ routines" }
      ]
    },
    {
      "start": 8451, "end": 8645,
      "name": "kernal_tape_read_write",
      "description": "C64 KERNAL tape store and write byte - store character from tape, copy I/O start address to buffer address, new tape byte setup, send lsb from tape write byte to tape, flag block done exit interrupt",
      "references": [
        { "chunk": "kernal_tape_encoding", "topic": "Tape encoding and timing" },
        { "chunk": "kernal_tape_write_leader", "topic": "Tape write IRQ and leader" }
      ]
    },
    {
      "start": 8646, "end": 8867,
      "name": "kernal_tape_write_leader",
      "description": "C64 KERNAL tape write IRQ and leader - tape write IRQ routine, write tape leader IRQ routine, restore everything for STOP, reset vector, set tape vector, stop cassette motor, check read/write pointer, increment read/write pointer, RESET hardware entry point, scan for autostart ROM at $8000, autostart ROM signature CBM80",
      "references": [
        { "chunk": "kernal_tape_read_write", "topic": "Tape store and write byte" },
        { "chunk": "kernal_vectors_ram_test", "topic": "I/O vectors and RAM test" }
      ]
    },
    {
      "start": 8868, "end": 8977,
      "name": "kernal_vectors_ram_test",
      "description": "C64 KERNAL I/O vectors and RAM test - restore default I/O vectors $FD15, set/read vectored I/O from XY, kernal vectors table, test RAM find RAM end, tape IRQ vectors",
      "references": [
        { "chunk": "kernal_tape_write_leader", "topic": "Tape write IRQ reset and autostart" },
        { "chunk": "kernal_sid_cia_init", "topic": "SID CIA initialization and file setup" }
      ]
    },
    {
      "start": 8978, "end": 9093,
      "name": "kernal_sid_cia_init",
      "description": "C64 KERNAL SID CIA and IRQ initialization - initialise SID CIA and IRQ, set filename SETNAM, set logical first second addresses SETLFS, read I/O status word READST, control kernal messages SETMSG, OR into serial status byte, set timeout on serial bus SETTMO, read/set top of memory MEMTOP, read/set bottom of memory MEMBOT",
      "references": [
        { "chunk": "kernal_vectors_ram_test", "topic": "I/O vectors and RAM test" },
        { "chunk": "kernal_nmi_irq_handler", "topic": "NMI handler and RS232 NMI" }
      ]
    },
    {
      "start": 9094, "end": 9253,
      "name": "kernal_nmi_irq_handler",
      "description": "C64 KERNAL NMI and IRQ handling - NMI vector and handler, user function default vector, RS232 NMI routine, baud rate calculation, save status do IRQ routine, IRQ vector, initialise VIC and screen editor",
      "references": [
        { "chunk": "kernal_sid_cia_init", "topic": "SID CIA initialization" },
        { "chunk": "kernal_jump_table", "topic": "KERNAL jump table and hardware vectors" }
      ]
    },
    {
      "start": 9254, "end": 9614,
      "name": "kernal_jump_table",
      "description": "C64 KERNAL jump table $FF81-$FFF3 and hardware vectors - initialise VIC screen editor, initialise SID CIA IRQ, RAM test, restore default I/O vectors, read/set vectored I/O, control kernal messages, SECOND TKSA MEMTOP MEMBOT SCNKEY SETTMO ACPTR CIOUT UNTLK UNLSN LISTN TALK READST SETLFS SETNAM OPEN CLOSE CHKIN CHKOUT CLRCHN CHRIN CHROUT LOAD SAVE SETTIM RDTIM STOP GETIN CLALL UDTIM SCREEN PLOT IOBASE, hardware vectors NMI RESET IRQ at $FFFA-$FFFE",
      "references": [
        { "chunk": "kernal_nmi_irq_handler", "topic": "NMI and IRQ handling" }
      ]
    }
  ]
}
