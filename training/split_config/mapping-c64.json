{
  "source_file": "mapping-c64.txt",
  "context": "*********",
  "splits": [
    {
      "start": 1,
      "end": 74,
      "ignore": true,
      "reason": "Project 64 header, credits, disclaimer and etext metadata (non-technical front matter)"
    },
    {
      "start": 75,
      "end": 129,
      "ignore": true,
      "reason": "Table of contents and book title block (non-technical / navigational material)"
    },
    {
      "start": 130,
      "end": 152,
      "name": "foreword_overview",
      "description": "Foreword that defines what a memory map is and explains the book's purpose as a programmer's reference for the Commodore 64 (general overview, intended audience).",
      "references": [
        {
          "chunk": "introduction_purpose_and_overview",
          "topic": "further explanation of book purpose and how to use it"
        },
        {
          "chunk": "chapter1_zero_page_and_basic_working_storage",
          "topic": "detailed memory map entries beginning in Chapter 1"
        }
      ],
      "ignore": true,
      "reason": "audit: Foreword/metadata only; contains no technical memory addresses, registers, code or actionable C64 programming details."
    },
    {
      "start": 153,
      "end": 153,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 154,
      "end": 180,
      "ignore": true,
      "reason": "Acknowledgements (non-technical)"
    },
    {
      "start": 181,
      "end": 181,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 182,
      "end": 236,
      "name": "introduction_purpose_and_overview",
      "description": "Introduction describing what a memory map is, how the Commodore 64 uses ROM and RAM, the role of OS and BASIC, and why a memory map is useful for PEEK/POKE and machine-language programming.",
      "references": [
        {
          "chunk": "chapter1_zero_page_and_basic_working_storage",
          "topic": "start of detailed memory map entries (zero page and beyond)"
        }
      ]
    },
    {
      "start": 237,
      "end": 242,
      "name": "memory_size_and_addressing",
      "description": "Introduces the Commodore 64 memory model: 64K (65536) bytes of addressable memory, each byte stores 0\u2013255, and any location is accessed by an address in the range 0\u201365535. Notes that memory locations can be read (and sometimes written) using these addresses.",
      "references": [
        {
          "chunk": "bits_bytes_and_binary_numbering",
          "topic": "how bytes are composed of bits and their numeric ranges"
        },
        {
          "chunk": "multi_byte_addresses_pages_and_byte_order",
          "topic": "how multiple bytes extend addressing and the page concept"
        },
        {
          "chunk": "format_of_memory_map_entries",
          "topic": "how addresses are represented and used in the book's memory map entries"
        }
      ]
    },
    {
      "start": 243,
      "end": 285,
      "name": "bits_bytes_and_binary_numbering",
      "description": "Explains bits and bytes: a byte is eight bits, combinations increase exponentially with each bit (examples for 1\u20133 bits), eight bits produce 256 combinations representing numbers 0\u2013255. Compares binary (base 2) to decimal (base 10) and lists bit positions and their weights: Bit0=1 through Bit7=128.",
      "references": [
        {
          "chunk": "memory_size_and_addressing",
          "topic": "the memory model that uses bytes as addressable units"
        },
        {
          "chunk": "multi_byte_addresses_pages_and_byte_order",
          "topic": "using multiple bytes to represent larger addresses"
        },
        {
          "chunk": "bitwise_logical_operations_and_examples",
          "topic": "bit-level operations that act on these bit positions"
        },
        {
          "chunk": "hexadecimal_and_nybbles",
          "topic": "relationship between 4-bit nybbles and hexadecimal digits"
        }
      ]
    },
    {
      "start": 286,
      "end": 308,
      "name": "multi_byte_addresses_pages_and_byte_order",
      "description": "Describes how two bytes are used to represent larger numbers/addresses (256*256=65536 combinations), the concept of pages (256-byte units, page numbering starting at 0), and byte-ordering for two-byte addresses (LSB/LSB-first and MSB), with the typical computation: address = LSB + 256 * MSB. Notes which part is stored at the lower/higher memory location.",
      "references": [
        {
          "chunk": "memory_size_and_addressing",
          "topic": "overall memory size and the need for multi-byte addresses"
        },
        {
          "chunk": "bits_bytes_and_binary_numbering",
          "topic": "why two bytes extend the numeric range beyond a single byte"
        },
        {
          "chunk": "format_of_memory_map_entries",
          "topic": "how two-byte pointers and vectors are documented in entries"
        }
      ]
    },
    {
      "start": 309,
      "end": 324,
      "name": "hexadecimal_and_nybbles",
      "description": "Introduces the hexadecimal (base 16) numbering system: digits 0\u20139 and A\u2013F (A=10 \u2026 F=15). Explains that two hex digits represent one byte (16*16=256 combinations) and that each hex digit maps to four bits (a 'nybble'). Notes the convention in the book of prefixing hexadecimal numbers with a dollar sign ($).",
      "references": [
        {
          "chunk": "bits_bytes_and_binary_numbering",
          "topic": "hexadecimal groups bits into 4-bit nybbles"
        },
        {
          "chunk": "bitwise_logical_operations_and_examples",
          "topic": "examples and masks are often expressed in hexadecimal"
        },
        {
          "chunk": "format_of_memory_map_entries",
          "topic": "how hexadecimal addresses are shown alongside decimal addresses"
        }
      ]
    },
    {
      "start": 325,
      "end": 389,
      "name": "bitwise_logical_operations_and_examples",
      "description": "Details logical (Boolean) bit operations used to manipulate single bits in bytes: AND (masking/clearing bits), OR (setting bits), and EOR/XOR (toggling bits). Explains when adding/subtracting bit values is unsafe and gives reliable formulas: BYTEVALUE AND (255-BITVALUE) to clear, BYTEVALUE OR BITVALUE to set, and EOR with a mask (or 255 for full complement) to flip bits. Includes binary examples demonstrating each operation and notes that EOR is available in machine language.",
      "references": [
        {
          "chunk": "bits_bytes_and_binary_numbering",
          "topic": "the bit weights (Bit0..Bit7) used in masks and operations"
        },
        {
          "chunk": "hexadecimal_and_nybbles",
          "topic": "masks and values are frequently represented in hexadecimal"
        },
        {
          "chunk": "format_of_memory_map_entries",
          "topic": "flags in the memory map are often manipulated using these operations"
        }
      ]
    },
    {
      "start": 390,
      "end": 431,
      "name": "format_of_memory_map_entries",
      "description": "Explains the structure and conventions used for memory-map entries in the book: large blocks (e.g., 256-page areas or ROM ranges) with overviews, grouped Location Range sections for tightly related addresses, and individual entries showing decimal and hexadecimal addresses plus mnemonic labels. Describes the meaning and sources of labels (Commodore guide, Jim Butterfield's PET maps), one-line descriptions followed by detailed explanations or sample programs, and distinctions between flags, pointers, and vectors.",
      "references": [
        {
          "chunk": "memory_size_and_addressing",
          "topic": "addresses and address ranges shown in entries"
        },
        {
          "chunk": "multi_byte_addresses_pages_and_byte_order",
          "topic": "pointers and vectors are typically two-byte values with LSB/MSB ordering"
        },
        {
          "chunk": "hexadecimal_and_nybbles",
          "topic": "entries present addresses in both decimal and hexadecimal"
        },
        {
          "chunk": "bitwise_logical_operations_and_examples",
          "topic": "flags described in entries are often manipulated with bitwise operations"
        }
      ]
    },
    {
      "start": 432,
      "end": 432,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 433,
      "end": 438,
      "name": "chapter_title_page_ignored",
      "description": "Non-technical title/heading block for Chapter 1 / Page 0. Marked ignored for semantic search (TOC/cover-like material).",
      "references": [],
      "ignore": true,
      "reason": "Non-technical title/heading block for Chapter 1 / Page 0. Marked ignored for semantic search (TOC/cover-like material)."
    },
    {
      "start": 439,
      "end": 463,
      "name": "zero_page_intro_and_basic_working_storage",
      "description": "Explains the significance of the 6502/6510 zero page (addresses $00-$FF): shorter/faster access, heavy use by system software, and that locations $00 and $01 are special I/O registers on the 6510. Notes the subsection 0-143 ($00-$8F) is reserved for BASIC working storage and can be used freely by pure machine-language programs that do not interact with BASIC.",
      "references": [
        {
          "chunk": "d6510_data_direction_register_at_0",
          "topic": "Details of the D6510 Data Direction Register at zero page location $00"
        },
        {
          "chunk": "r6510_internal_io_port_overview",
          "topic": "Overview of the R6510 internal I/O port at location $01 and how it controls ROM/RAM mapping and cassette I/O"
        }
      ]
    },
    {
      "start": 464,
      "end": 490,
      "name": "d6510_data_direction_register_at_0",
      "description": "Describes zero page location 0 ($00): the 6510 On-Chip I/O Data Direction Register (D6510). Lists each bit's meaning (Bits 0-5 significant; Bit 4 default input for cassette switch), default power-up value ($EF / 239), and explains that each bit sets the direction (input=0, output=1) for the corresponding bit on the internal I/O port at $01. Notes these are hardware-connected registers whose writes/reads affect devices.",
      "references": [
        {
          "chunk": "zero_page_intro_and_basic_working_storage",
          "topic": "Context: zero page significance and that locations 0 and 1 are special"
        },
        {
          "chunk": "r6510_internal_io_port_overview",
          "topic": "How the D6510 direction bits affect the behavior of R6510 port bits at $01"
        }
      ]
    },
    {
      "start": 491,
      "end": 514,
      "name": "r6510_internal_io_port_overview",
      "description": "Introduces location 1 ($01), the R6510 internal I/O port. Lists the meaning of each bit (Bit 0 LORAM, Bit 1 HIRAM, Bit 2 CHAREN, Bit 3 cassette data out, Bit 4 cassette switch sense, Bit 5 cassette motor control, Bits 6-7 unused). Explains the register's chief function: selecting which ROM/RAM and I/O blocks the CPU addresses, noting the C64's ROMs and I/O chips and that address space must be swapped to fit everything.",
      "references": [
        {
          "chunk": "d6510_data_direction_register_at_0",
          "topic": "Data direction required for reading cassette switch and for controlling port bits"
        },
        {
          "chunk": "loram_hiram_and_moving_rom_to_ram_examples",
          "topic": "Detailed behavior of LORAM/HIRAM (Bits 0-1), examples of copying ROM to RAM and switching ROMs"
        },
        {
          "chunk": "charen_bit_and_reading_character_rom_into_ram",
          "topic": "Details of CHAREN (Bit 2) and how to read the character ROM into RAM"
        },
        {
          "chunk": "cartridges_game_exrom_and_memory_configurations",
          "topic": "How cartridge lines (GAME/EXROM) interact with these port signals to change memory mapping"
        },
        {
          "chunk": "datasette_control_bits_and_motor_interlock",
          "topic": "Cassette-related bits (Bits 3-5) and motor/interlock behavior"
        }
      ]
    },
    {
      "start": 515,
      "end": 575,
      "name": "loram_hiram_and_moving_rom_to_ram_examples",
      "description": "Explains Bit 0 (LORAM) and Bit 1 (HIRAM): how setting/clearing them swaps BASIC ROM ($A000-$BFFF) and Kernal ROM ($E000-$FFFF) with RAM. Shows technique to copy ROM into RAM from BASIC (FOR I=40960 TO 49151:POKE I,PEEK(I):NEXT), explains why this works, and gives example POKEs to switch to RAM copy (POKE 1,PEEK(1) AND 254) and to restore ROM (POKE 1,PEEK(1) OR 1). Provides example modifications once BASIC is in RAM (changing READY prompt, keyword typos like FOR->FER, and altering ASC behavior via specific POKEs).",
      "references": [
        {
          "chunk": "r6510_internal_io_port_overview",
          "topic": "Definition of LORAM/HIRAM bits that allow ROM/RAM swapping"
        },
        {
          "chunk": "d6510_data_direction_register_at_0",
          "topic": "Data direction considerations when accessing I/O-controlled bits"
        },
        {
          "chunk": "replacing_roms_and_kernel_interrupts_notes",
          "topic": "Further notes on replacing ROMs with alternate OS/applications and interrupt/vector considerations"
        }
      ]
    },
    {
      "start": 576,
      "end": 589,
      "name": "replacing_roms_and_kernel_interrupts_notes",
      "description": "Discusses advanced uses of swapping ROMs: replacing ROM programs with a custom OS or application loaded into RAM, loading alternate languages, or switching out ROMs to give an application access to more RAM. Warns that switching out the Kernal requires disabling interrupts because interrupt vectors reside in the Kernal. Points to examples of inserting new commands via vectors in RAM BASIC.",
      "references": [
        {
          "chunk": "loram_hiram_and_moving_rom_to_ram_examples",
          "topic": "Practical examples of moving BASIC to RAM and modifying it"
        },
        {
          "chunk": "charen_bit_and_reading_character_rom_into_ram",
          "topic": "Switching character ROM in/out when doing character-set modifications"
        }
      ]
    },
    {
      "start": 590,
      "end": 627,
      "name": "charen_bit_and_reading_character_rom_into_ram",
      "description": "Explains Bit 2 (CHAREN): selecting character generator ROM vs. I/O devices. Describes that normally CHAREN=1 leaves character ROM inaccessible to PEEK while VIC-II can use it; setting CHAREN=0 maps the character ROM into $D000-$DFFF and disables I/O. Provides a BASIC example to read the 2K character ROM into RAM (including POKEs to disable interrupts, switch in ROM, loop to POKE BASE+I,PEEK(53248+I), and restore CHAREN and interrupts). Advises alignment of BASE on an even 2K boundary within VIC-II-addressed memory and references related VIC-II and character ROM sections.",
      "references": [
        {
          "chunk": "r6510_internal_io_port_overview",
          "topic": "Definition of CHAREN and how it conflicts with I/O device addressing"
        },
        {
          "chunk": "loram_hiram_and_moving_rom_to_ram_examples",
          "topic": "Similar technique of copying ROM into RAM applied to BASIC & Kernal"
        }
      ]
    },
    {
      "start": 628,
      "end": 653,
      "name": "cartridges_game_exrom_and_memory_configurations",
      "description": "Notes that Bits 0-2 aren't the only means to control memory mapping: expansion cartridges use GAME and EXROM lines on the expansion port to replace ROM/RAM segments. Describes possible cartridge mappings (8K at $8000-$9FFF, 8K at $A000-$BFFF replacing BASIC, 8K at $E000-$FFFF replacing Kernal, or 16K at $8000-$BFFF/$8000-$C000) and explains the Max-emulation mode when cartridge ROM replaces the Kernal (only first 6K RAM used, no access to character ROM, graphics data remapped from $E000 down to $2000). References the Commodore 64 Programmer's Reference Guide for more hardware details.",
      "references": [
        {
          "chunk": "r6510_internal_io_port_overview",
          "topic": "How cartridge signals (GAME/EXROM) combine with port bits to alter memory map"
        },
        {
          "chunk": "loram_hiram_and_moving_rom_to_ram_examples",
          "topic": "Implications of replacing ROMs and using alternate ROMs mapped by cartridges"
        }
      ]
    },
    {
      "start": 654,
      "end": 687,
      "name": "datasette_control_bits_and_motor_interlock",
      "description": "Covers cassette/Datasette-related functions of R6510 bits 3-5: Bit 3 is Cassette Data Output (writes tape data), Bit 4 is Cassette Switch Sense (reads whether a transport button is pressed; requires Bit 4 of D6510 at $00 to be set as input), and Bit 5 controls the Cassette Motor (0 allows motor to run when buttons pressed; 1 disables motor). Describes how the keyboard-scan interrupt routine normally controls the motor and an interlock at location 192 ($C0): how the interlock is used to prevent user control unless a transport button is pressed and how to POKE location 192 to gain control.",
      "references": [
        {
          "chunk": "d6510_data_direction_register_at_0",
          "topic": "Need to set corresponding D6510 direction bit (Bit 4) to input to read cassette switch sense correctly"
        },
        {
          "chunk": "r6510_internal_io_port_overview",
          "topic": "Cassette-related bits described in the R6510 port summary"
        }
      ]
    },
    {
      "start": 688,
      "end": 690,
      "name": "zero_page_unused_02",
      "description": "Zero-page location $02 marked as unused. Covers the single unused byte entry and any immediate blank/comment lines associated with it.",
      "references": [
        {
          "chunk": "adray1_float_to_int_vector",
          "topic": "next documented zero-page vector above (ADRAY1)"
        }
      ]
    },
    {
      "start": 691,
      "end": 714,
      "name": "adray1_float_to_int_vector",
      "description": "Zero-page vector ADRAY1 ($03-$04): points to the BASIC routine that converts a floating-point number to a two-byte signed integer. Includes rationale for using the vector (stability across ROM revisions) and a note referencing the USR-vector usage for calling BASIC routines.",
      "references": [
        {
          "chunk": "adray2_int_to_float_vector",
          "topic": "the complementary integer-to-floating-point conversion vector (ADRAY2)"
        },
        {
          "chunk": "zero_page_unused_02",
          "topic": "previous zero-page entry"
        }
      ]
    },
    {
      "start": 715,
      "end": 725,
      "name": "adray2_int_to_float_vector",
      "description": "Zero-page vector ADRAY2 ($05-$06): points to the BASIC routine that converts an integer to floating-point format. Notes its ROM address at the time, availability for machine-language programs interacting with BASIC, and a cross-reference to the USR-vector explanation.",
      "references": [
        {
          "chunk": "adray1_float_to_int_vector",
          "topic": "the inverse conversion vector (ADRAY1)"
        },
        {
          "chunk": "input_scanning_chars_charac_endchr_trmpos",
          "topic": "next group of BASIC input-scanning variables"
        }
      ]
    },
    {
      "start": 726,
      "end": 754,
      "name": "input_scanning_chars_charac_endchr_trmpos",
      "description": "BASIC input/text scanning variables: CHARAC ($07) stores ASCII values of characters significant to the scanner (quotes, comma, colon, end-of-line); ENDCHR ($08) used as a work byte during tokenization (often 0 or 34); TRMPOS ($09) holds the cursor column position prior to the last TAB or SPC (logical line position 0\u201379) and is used to compute tab/spaces behavior.",
      "references": [
        {
          "chunk": "adray2_int_to_float_vector",
          "topic": "previous zero-page vector entries"
        },
        {
          "chunk": "verck_load_verify_and_count",
          "topic": "next group: I/O and input-buffer indexing flags"
        }
      ]
    },
    {
      "start": 755,
      "end": 778,
      "name": "verck_load_verify_and_count",
      "description": "VERCK ($0A) and COUNT ($0B) usage: VERCK is a flag set by BASIC (0 for LOAD, 1 for VERIFY) passed to the Kernal LOAD routine; COUNT is used as an index into the BASIC input buffer at $200 during tokenization and also stores the number of array subscripts when building or referencing arrays. Explains how COUNT ends up equal to the tokenized line length after conversion.",
      "references": [
        {
          "chunk": "input_scanning_chars_charac_endchr_trmpos",
          "topic": "input scanning variables used by tokenization"
        },
        {
          "chunk": "array_and_tokenization_flags_dimflg_valtyp_intflg_garbfl",
          "topic": "related flags used when locating/creating variables and classifying data"
        }
      ]
    },
    {
      "start": 779,
      "end": 819,
      "name": "array_and_tokenization_flags_dimflg_valtyp_intflg_garbfl",
      "description": "Flags for array-handling and tokenization: DIMFLG ($0C) indicates array-related conditions (in array, DIMensioned, or use default dimensions); VALTYP ($0D) marks data type (255=$FF for string, 0 for numeric); INTFLG ($0E) marks numeric subtype (128=$80 for integer, 0 for floating point); GARBFL ($0F) used by LIST (to detect quoted strings), by garbage collection (to indicate GC already attempted), and as a work byte during tokenization.",
      "references": [
        {
          "chunk": "verck_load_verify_and_count",
          "topic": "previous I/O/indexing flag context"
        },
        {
          "chunk": "subflg_subscript_and_fn_handling",
          "topic": "next flag used when parsing variable names and function calls"
        }
      ]
    },
    {
      "start": 820,
      "end": 833,
      "name": "subflg_subscript_and_fn_handling",
      "description": "SUBFLG ($10): flag set when an opening parenthesis follows a variable name to indicate either an array subscript reference or a user-defined function (FN) call. Includes notes that FN names may clash with floating-point variable names and that redefining functions is permitted.",
      "references": [
        {
          "chunk": "array_and_tokenization_flags_dimflg_valtyp_intflg_garbfl",
          "topic": "related flags used while locating/creating variables"
        },
        {
          "chunk": "inpflg_input_get_read_flag",
          "topic": "next flag group describing input command distinctions"
        }
      ]
    },
    {
      "start": 834,
      "end": 853,
      "name": "inpflg_input_get_read_flag",
      "description": "INPFLG ($11): indicates which of GET, INPUT, or READ is executing so BASIC can handle their differences (152=$98 for READ, 64=$40 for GET, 0 for INPUT). Describes behavioral differences: INPUT shows ? prompt, echoes and waits for full line; GET accepts one character with no prompt; READ treats delimiters differently. Also used to select appropriate error messages.",
      "references": [
        {
          "chunk": "subflg_subscript_and_fn_handling",
          "topic": "previous parsing-related flag"
        },
        {
          "chunk": "tansgn_trig_and_comparison_flag",
          "topic": "next zero-page flag with dual trig/comparison roles"
        }
      ]
    },
    {
      "start": 854,
      "end": 866,
      "name": "tansgn_trig_and_comparison_flag",
      "description": "TANSGN ($12): stores the sign of TAN or SIN function results (positive/negative). Also reused by string and numeric comparison routines as an outcome indicator: 1 if A>B, 2 if A==B, 4 if A<B; composite values represent combined operators (e.g., >= or <=).",
      "references": [
        {
          "chunk": "inpflg_input_get_read_flag",
          "topic": "preceding input/command flag context"
        },
        {
          "chunk": "channl_current_io_channel",
          "topic": "next entry controlling BASIC I/O destination behavior"
        }
      ]
    },
    {
      "start": 867,
      "end": 915,
      "name": "channl_current_io_channel",
      "description": "CHANNL ($13): current logical-file (CMD) number used by BASIC to determine the active input/output device for prompting and output control. Explains default device numbers (0=keyboard input, 3=screen output) and how nonzero values change TAB behavior, suppress the ? prompt, and alter handling of carriage returns and EXTRA IGNORED. Describes how OPEN/CMD set this location and how many BASIC routines reset it back to the screen; notes trickery to make BASIC read tape data as keyboard input and references the keyboard buffer technique at $200.",
      "references": [
        {
          "chunk": "tansgn_trig_and_comparison_flag",
          "topic": "previous flag usage"
        },
        {
          "chunk": "linnum_target_line_integer",
          "topic": "next entry storing target line numbers used by control-flow commands"
        },
        {
          "chunk": "txttab_basic_text_pointer_and_relocation",
          "topic": "related techniques for redirecting I/O via BASIC text relocation and buffer tricks"
        }
      ]
    },
    {
      "start": 916,
      "end": 937,
      "name": "linnum_target_line_integer",
      "description": "LINNUM ($14-$15): two-byte low/high integer used to store the target line number for GOTO, LIST, ON, and GOSUB, or the line number to add/replace. LIST saves the highest line to list (or $FFFF to indicate to end). Describes how GOTO determines search start (comparison uses most significant byte only\u2014i.e., INT(TARGET/256) compared to INT(CURRENT/256)). Notes that PEEK, POKE, WAIT, and SYS use this location as a pointer address parameter.",
      "references": [
        {
          "chunk": "channl_current_io_channel",
          "topic": "previous I/O-related flags and behavior"
        },
        {
          "chunk": "temporary_string_stack_temppt_lastpt_tempst",
          "topic": "next zero-page area used for temporary string handling"
        }
      ]
    },
    {
      "start": 938,
      "end": 952,
      "name": "temporary_string_stack_temppt",
      "description": "TEMPPT ($16): pointer to the next available slot in the temporary string descriptor stack. Describes the stack layout (three 3-byte descriptors at $19-$21) and values TEMPPT can hold: $19 when empty, $1C with one entry, $1F with two entries, $22 when full. Explains error behavior: when full (34 decimal/$22), FORMULA TOO COMPLEX is raised; otherwise TEMPPT is incremented by three when adding an entry. Includes the immediately following blank/separator line.",
      "references": [
        {
          "chunk": "linnum_target_line_integer",
          "topic": "previous pointer and control-flow storage"
        },
        {
          "chunk": "temporary_string_stack_lastpt",
          "topic": "pointer to the last-used temporary string descriptor"
        }
      ]
    },
    {
      "start": 953,
      "end": 960,
      "name": "temporary_string_stack_lastpt",
      "description": "LASTPT ($17-$18): pointer to the address of the last string descriptor used in the temporary string descriptor stack. Describes relationship to TEMPPT: LASTPT should be three less than TEMPPT and the high byte at $18 will be zero in typical cases.",
      "references": [
        {
          "chunk": "temporary_string_stack_temppt",
          "topic": "pointer to next available stack entry"
        },
        {
          "chunk": "temporary_string_stack_tempst",
          "topic": "the actual descriptor stack entries"
        }
      ]
    },
    {
      "start": 961,
      "end": 972,
      "name": "temporary_string_stack_tempst",
      "description": "TEMPST ($19-$21): the temporary string descriptor stack itself. Each 3-byte descriptor stores information about temporary (unnamed) strings\u2014examples include literal strings in PRINT statements. The three bytes capture the string length and starting/ending displacements within BASIC string storage.",
      "references": [
        {
          "chunk": "temporary_string_stack_lastpt",
          "topic": "pointer to last descriptor used"
        },
        {
          "chunk": "index_and_resho_work_areas",
          "topic": "other nearby zero-page work areas used by BASIC"
        }
      ]
    },
    {
      "start": 973,
      "end": 985,
      "name": "index_and_resho_work_areas",
      "description": "INDEX ($22-$25) and RESHO ($26-$2A): miscellaneous temporary pointers and save area (INDEX) used by many BASIC routines for transient pointers and calculation results; RESHO is the floating-point multiplication/division work area and is also used to compute array storage size during DIM construction.",
      "references": [
        {
          "chunk": "temporary_string_stack_tempst",
          "topic": "previous temporary string storage and pointers"
        },
        {
          "chunk": "txttab_basic_text_pointer_and_relocation",
          "topic": "next two-byte pointer that controls BASIC program text location"
        }
      ]
    },
    {
      "start": 986,
      "end": 1067,
      "name": "txttab_basic_text_pointer_and_relocation",
      "description": "TXTTAB ($2B-$2C): two-byte pointer to the start of BASIC program text (commonly $0801). Full discussion of uses and relocation techniques: (1) emulate PET/CBM memory layout (example POKE program provided to move text display and BASIC start addresses), (2) raise BASIC start to create a safe low-memory area (example moving BASIC to $4001 for high-resolution graphics or reserving space for sprites/custom charsets), (3) keep multiple BASIC programs in memory simultaneously (techniques and references to magazine/books), including appending or switching programs, and (4) use TXTTAB with the SAVE-start pointer to save arbitrary regions of memory. Includes practical POKE examples and cross-references to other relevant zero-page/IO locations mentioned in the examples.",
      "references": [
        {
          "chunk": "index_and_resho_work_areas",
          "topic": "previous nearby work area variables"
        },
        {
          "chunk": "channl_current_io_channel",
          "topic": "I/O redirection techniques that relate to program relocation and buffers"
        }
      ]
    },
    {
      "start": 1068,
      "end": 1167,
      "name": "vartab_variable_storage_pointer_and_variable_format",
      "description": "VARTAB ($2D-$2E) pointer to the start of the BASIC variable storage area (address immediately after program text). Describes layout and format of non-array variable descriptors (7 bytes each): first two bytes store name (ASCII, second zero if single-letter) with high-bit (7th bit) patterns indicating type (no bits = floating point, first-bit = string, second-bit = FN, both bits = integer). Details of how the remaining five bytes are used per type: floating point (5-byte fp value), integer (2-byte value, high byte first), string (length byte + 2-byte pointer to string text), FN (pointer to function text and pointer to dependent variable). Explains variable creation order, search behavior (search from start of area), performance implications of variable ordering and defining variables after arrays, persistence of variables during execution, pointer resets on CLR/NEW/RUN/LOAD, chaining programs when LOAD is issued from a program (and related pointer/pointer-invalidations), and how SAVE uses this pointer as the byte after the last byte to save.",
      "references": [
        {
          "chunk": "array_storage_arytab",
          "topic": "array storage area starts at end of the nonarray variable area and arrays move when nonarray variables are added"
        },
        {
          "chunk": "strend_array_free_ram",
          "topic": "defines the boundary between array storage and free RAM; variable creation moves this pointer"
        },
        {
          "chunk": "memsiz_top_basic_memory",
          "topic": "CLR resets pointers relative to MEMSIZ; SAVE/LOAD interactions"
        }
      ]
    },
    {
      "start": 1168,
      "end": 1195,
      "name": "array_storage_arytab",
      "description": "ARYTAB ($2F-$30) pointer to the start of the BASIC array storage area (address immediately after nonarray variable storage). Format for arrays: two-byte name (same high-bit/type patterns as nonarray variables except no FN), two-byte low-byte-first offset to the next array, one-byte dimension count, then pairs of bytes holding each dimension+1 (DIM makes space for index 0). After the dimension descriptors come the array element values themselves; each element uses storage appropriate to its type (5 bytes for floating point, 2 for integer, 3 for string descriptor). Notes that actual string text for string elements is stored elsewhere (FREETOP area).",
      "references": [
        {
          "chunk": "vartab_variable_storage_pointer_and_variable_format",
          "topic": "variable name encoding and high-bit type flags same as nonarray variables"
        },
        {
          "chunk": "strend_array_free_ram",
          "topic": "STREND marks the end of array storage and start of free RAM"
        },
        {
          "chunk": "freetop_string_text_pointer",
          "topic": "string element text is stored in the string text area pointed to by FREETOP"
        }
      ]
    },
    {
      "start": 1196,
      "end": 1228,
      "name": "strend_array_free_ram_boundary_and_garbage_collection",
      "description": "STREND ($31-$32) pointer to the end of the BASIC array storage area (+1) and the start of free RAM. Explains strings grow downward from the top of memory; STREND is the last allowable address for string storage. Defining new variables moves this pointer upward; if a string allocation would cross this boundary garbage collection is triggered, and if insufficient space remains an OUT OF MEMORY error results. The FRE routine performs garbage collection and returns the difference between the address here (STREND) and the end of string text storage pointed to by FREETOP.",
      "references": [
        {
          "chunk": "freetop_string_text_pointer",
          "topic": "FREETOP holds the current end of string text and FRE compares it with STREND during GC"
        },
        {
          "chunk": "array_storage_arytab",
          "topic": "STREND marks the end of the array storage area described by ARYTAB"
        }
      ]
    },
    {
      "start": 1229,
      "end": 1234,
      "name": "frespc_temporary_string_pointer",
      "description": "FRESPC ($35-$36) \u2014 temporary pointer used by BASIC string routines. It holds a pointer to the most recently added or moved string and is used as a temporary working pointer while building or relocating string text.",
      "references": [
        {
          "chunk": "freetop_string_text_pointer",
          "topic": "FRESPC is a temporary working pointer used when updating the string text area whose boundaries are managed by FREETOP and STREND"
        }
      ]
    },
    {
      "start": 1235,
      "end": 1263,
      "name": "freetop_string_text_pointer_and_memsiz_top_basic_memory",
      "description": "FREETOP ($33-$34) pointer to the bottom of the string text storage area (the current end of string text and the top of free RAM). Describes that strings are built downward, the pointer is lowered when adding strings, and garbage collection raises it. Power-on sets FREETOP to the top of RAM; CLR sets FREETOP to the end of BASIC memory as indicated by MEMSIZ to allow reserving a safe area. MEMSIZ ($37-$38) is the pointer to the highest address usable by BASIC; on power-up it is set to the highest consecutive RAM byte before BASIC ROM (40959 / $9FFF). Explains users may lower MEMSIZ to reserve RAM (example: POKE 56,PEEK(56)-4:CLR) and why CLR is necessary, suggested uses for the reserved area (machine code, sprites, char sets), and VIC-II 16K addressing range considerations (you must lower MEMSIZ below $3FFF if not switching banks and you want sprite/char data within VIC-II addressable range).",
      "references": [
        {
          "chunk": "strend_array_free_ram",
          "topic": "FREETOP and STREND define the string text and free RAM boundaries; FRE interacts with STREND during garbage collection"
        },
        {
          "chunk": "vartab_variable_storage_pointer_and_variable_format",
          "topic": "CLR resets variable/string pointers relative to MEMSIZ; freeing or reserving memory affects variable/storage pointers"
        },
        {
          "chunk": "frespc_temporary_string_pointer",
          "topic": "FRESPC is used as a working pointer while modifying the string area whose limits are FREETOP and MEMSIZ"
        }
      ]
    },
    {
      "start": 1264,
      "end": 1274,
      "name": "rs232_buffer_allocation_and_clr_warning",
      "description": "Explains that opening RS-232 device (device 2) lowers pointers and end-of-user-RAM by 512 bytes to create two 256-byte input/output buffers; warns these buffers overwrite variables at the top of memory and notes that BASIC issues a CLR when device 2 is opened, so RS-232 should be opened before defining variables or reserving safe areas for machine code.",
      "references": [
        {
          "chunk": "datptr_pointer_to_current_data_item_and_sample_program",
          "topic": "example of pointer manipulation elsewhere in BASIC memory (DATA pointer example)"
        },
        {
          "chunk": "inpptr_input_source_pointer_for_get_read_input",
          "topic": "related pointer used by GET/READ/INPUT to locate input sources"
        }
      ]
    },
    {
      "start": 1275,
      "end": 1299,
      "name": "curlin_current_basic_line_number",
      "description": "CURLIN ($39-$3A) holds the current BASIC line number (LSB/MSB) being executed. Explains the special value $FF in the MSB indicating immediate (direct) mode, how illegal direct-mode keywords check this location, how CURLIN updates during RUN as each line is fetched, suggestion of using vector at 776 ($308) to implement a TRACE routine that prints this line number, and that CURLIN is used by BREAK and error messages and is copied to/from OLDLIN by STOP/END/BREAK and CONT.",
      "references": [
        {
          "chunk": "oldlin_previous_basic_line_number",
          "topic": "OLDLIN stores the previous BASIC line number and is copied to/from CURLIN by STOP/CONT"
        },
        {
          "chunk": "oldtxt_pointer_to_current_basic_statement",
          "topic": "OLDTXT holds the pointer to the text of the current statement referenced by CURLIN"
        }
      ]
    },
    {
      "start": 1300,
      "end": 1305,
      "name": "oldlin_previous_basic_line_number",
      "description": "OLDLIN ($3B-$3C) stores the previous (last executed) BASIC line number when program execution ends; CONT restores this value into CURLIN.",
      "references": [
        {
          "chunk": "curlin_current_basic_line_number",
          "topic": "CURLIN and OLDLIN are used together for STOP/CONT/BREAK behavior"
        }
      ]
    },
    {
      "start": 1306,
      "end": 1319,
      "name": "oldtxt_pointer_to_current_basic_statement",
      "description": "OLDTXT ($3D-$3E) stores the address (pointer) of the text of the BASIC statement currently being executed (value of TXTPTR saved at each new statement). END, STOP and BREAK save TXTPTR here and CONT restores it. CONT will fail to continue if OLDTXT is zeroed by LOAD, program modification, or error routines.",
      "references": [
        {
          "chunk": "curlin_current_basic_line_number",
          "topic": "CURLIN and OLDTXT together identify the current statement and its line number"
        },
        {
          "chunk": "datptr_pointer_to_current_data_item_and_sample_program",
          "topic": "DATPTR also points into BASIC text area for DATA items (contrast: OLDTXT points to executing statement text)"
        }
      ]
    },
    {
      "start": 1320,
      "end": 1331,
      "name": "datlin_current_data_line_number",
      "description": "DATLIN ($3F-$40) holds the line number of the current DATA statement being READ. Notes that DATLIN is not used to locate the next DATA item (that's DATPTR); DATLIN is moved to CURLIN for error messages so errors refer to the DATA line, not the READ line.",
      "references": [
        {
          "chunk": "datptr_pointer_to_current_data_item_and_sample_program",
          "topic": "DATPTR points to the address within the BASIC text where the current DATA item is read"
        }
      ]
    },
    {
      "start": 1332,
      "end": 1354,
      "name": "datptr_pointer_to_current_data_item_and_sample_program",
      "description": "DATPTR ($41-$42) is a pointer to the address within BASIC program text where DATA is currently being READ. RESTORE sets it to the program start pointer. Includes a sample BASIC program showing how to save and poke bytes into DATPTR to change the order DATA statements are READ (demonstrates reading DATA in arbitrary order by saving TXTPTR-like bytes into variables and poking them back into DATPTR before READ).",
      "references": [
        {
          "chunk": "datlin_current_data_line_number",
          "topic": "DATLIN provides the DATA line number used in error reporting when DATPTR points to DATA content"
        },
        {
          "chunk": "inpptr_input_source_pointer_for_get_read_input",
          "topic": "INPPTR is similar in that it points to the source of input (DATA statements or input buffer)"
        }
      ]
    },
    {
      "start": 1355,
      "end": 1361,
      "name": "inpptr_input_source_pointer_for_get_read_input",
      "description": "INPPTR ($43-$44) is the pointer used by READ, INPUT and GET to the source of incoming data \u2014 either DATA statements (via DATPTR) or the keyboard/input buffer at $200 (512).",
      "references": [
        {
          "chunk": "datptr_pointer_to_current_data_item_and_sample_program",
          "topic": "DATPTR points to DATA inside program text; INPPTR points to the source used by READ/INPUT/GET"
        }
      ]
    },
    {
      "start": 1362,
      "end": 1369,
      "name": "varnam_current_basic_variable_name",
      "description": "VARNAM ($45-$46) stores the current variable name being searched for, in the same two-byte format used in variable descriptors (see variable descriptor description at location 45 ($2D) for format details).",
      "references": [
        {
          "chunk": "varpnt_pointer_to_current_variable_descriptor",
          "topic": "VARPNT points to the descriptor (value storage) corresponding to the name in VARNAM"
        }
      ]
    },
    {
      "start": 1370,
      "end": 1381,
      "name": "varpnt_pointer_to_current_variable_descriptor",
      "description": "VARPNT ($47-$48) points to the address of the descriptor of the current BASIC variable \u2014 specifically to the byte immediately after the two-character variable name. Notes that during FN calls this does not point to the dependent variable (preventing accidental modification of a real variable with the same name).",
      "references": [
        {
          "chunk": "varnam_current_basic_variable_name",
          "topic": "VARNAM holds the two-byte variable name format used at VARPNT's descriptor"
        },
        {
          "chunk": "forpnt_for_next_index_variable_and_stack_behavior",
          "topic": "FOR/NEXT loops use dedicated pointer areas and interact with variable storage and the stack"
        }
      ]
    },
    {
      "start": 1382,
      "end": 1392,
      "name": "forpnt_for_next_index_variable_and_stack_behavior",
      "description": "FORPNT ($49-$4A) is a temporary pointer to the BASIC variable used as the loop index in FOR/NEXT. The variable address is first stored here, then pushed onto the stack, freeing FORPNT to be used as scratch space by statements like INPUT, GET, READ, LIST, WAIT, CLOSE, LOAD, SAVE, RETURN, and GOSUB. Refers to stack entry format at location 256 ($100) for FOR stack details.",
      "references": [
        {
          "chunk": "varpnt_pointer_to_current_variable_descriptor",
          "topic": "VARPNT and FORPNT both reference variable descriptors/addresses"
        },
        {
          "chunk": "opptr_math_operator_table_displacement",
          "topic": "OPPTR is another temporary pointer used during expression evaluation (unrelated to FOR stack but similar use of page-zero temporaries)"
        }
      ]
    },
    {
      "start": 1393,
      "end": 1400,
      "name": "opptr_math_operator_table_displacement",
      "description": "OPPTR ($4B-$4C) holds the displacement of the current math operator within an operator table during expression evaluation. It is also used as a save area for the pointer to the address of program text currently being read.",
      "references": [
        {
          "chunk": "opmask_comparison_mask_bits",
          "topic": "OPMASK is created during expression evaluation to indicate comparison type (less/equal/greater)"
        },
        {
          "chunk": "oldtxt_pointer_to_current_basic_statement",
          "topic": "OPPTR can be used to save program text pointers similar to OLDTXT's role with TXTPTR"
        }
      ]
    },
    {
      "start": 1401,
      "end": 1407,
      "name": "opmask_comparison_mask_bits",
      "description": "OPMASK ($4D) is a mask used by the expression evaluation routine to record the comparison operation type: less-than (1), equals (2), or greater-than (4).",
      "references": [
        {
          "chunk": "opptr_math_operator_table_displacement",
          "topic": "OPPTR and OPMASK are both used by the expression evaluator to track operator location and comparison type"
        }
      ]
    },
    {
      "start": 1408,
      "end": 1415,
      "name": "defpnt_function_descriptor_pointer",
      "description": "DEFPNT ($4E-$4F) points to the current FN descriptor. During DEF FN it points to the newly created descriptor; during FN execution it points to the FN descriptor where evaluation results should be stored.",
      "references": [
        {
          "chunk": "varpnt_pointer_to_current_variable_descriptor",
          "topic": "Function descriptors and variable descriptors both reside in BASIC descriptor areas and interact during FN evaluation"
        }
      ]
    },
    {
      "start": 1416,
      "end": 1422,
      "name": "dscpnt_temporary_string_descriptor_pointer_and_length",
      "description": "DSCPNT ($50-$52) is used by string assignment and handling routines: the first two bytes act as a temporary pointer to the current string descriptor, and the third byte holds the string length value.",
      "references": [
        {
          "chunk": "defpnt_function_descriptor_pointer",
          "topic": "Both DEFPNT and DSCPNT are temporary pointers used during evaluation/assignment of program elements (functions vs. strings)"
        },
        {
          "chunk": "varpnt_pointer_to_current_variable_descriptor",
          "topic": "String descriptors and variable descriptors are managed with temporary page-zero pointers such as VARPNT and DSCPNT"
        }
      ]
    },
    {
      "start": 1423,
      "end": 1428,
      "name": "four6_garbage_collection_constant",
      "description": "Definition of FOUR6 ($53): a constant used by the garbage-collection routines to indicate whether a three- or seven-byte string descriptor is being collected.",
      "references": [
        {
          "chunk": "basic_numeric_work_area_overview",
          "topic": "context of low-RAM BASIC workspace where this constant lives"
        }
      ]
    },
    {
      "start": 1429,
      "end": 1435,
      "name": "jmper_jump_to_function_instruction",
      "description": "Definition of JMPER ($54-$56): contains a 6502 JMP instruction ($4C) followed by the address of a required BASIC function taken from the function table at 41042 ($A052).",
      "references": [
        {
          "chunk": "basic_numeric_work_area_overview",
          "topic": "placement of JMPER within the BASIC work area"
        }
      ]
    },
    {
      "start": 1436,
      "end": 1440,
      "name": "basic_numeric_work_area_overview",
      "description": "Overview of the BASIC Numeric Work Area ($57-$60): notes that this is a busy, multi-use workspace used by many BASIC routines.",
      "references": [
        {
          "chunk": "fac1_accumulator_overview",
          "topic": "detailed floating-point accumulators stored nearby (FAC1/FAC2)"
        },
        {
          "chunk": "four6_garbage_collection_constant",
          "topic": "other nearby low-RAM constants and structures"
        }
      ]
    },
    {
      "start": 1441,
      "end": 1461,
      "name": "fac1_accumulator_overview",
      "description": "Floating Point Accumulator #1 (FAC1) overview ($61-$66): explains FAC1's central role in BASIC math operations (converting integers and strings to floats and back), describes the internal floating-point format (normalized mantissa and exponent power-of-two), and notes BASIC conversion/manipulation routines and references to related ROM locations (see entries for locations 3 and 5).",
      "references": [
        {
          "chunk": "fac1_fields_exponent_mantissa_sign",
          "topic": "detailed breakdown of FAC1 fields (exponent, mantissa, sign)"
        },
        {
          "chunk": "fac2_accumulator_overview",
          "topic": "other accumulator used with FAC1 for multi-value operations"
        }
      ]
    },
    {
      "start": 1462,
      "end": 1491,
      "name": "fac1_fields_exponent_mantissa_sign",
      "description": "Detailed layout of FAC1 subfields: FACEXP ($61) \u2014 exponent stored with bias of 129 (128 represents zero); FACHO ($62-$65) \u2014 four-byte normalized mantissa (MSB assumed 1), with first two bytes also used as signed integer result in high/low order; FACSGN ($66) \u2014 sign byte (0 = positive, $FF = negative).",
      "references": [
        {
          "chunk": "fac1_accumulator_overview",
          "topic": "FAC1 purpose and floating-point format summary"
        },
        {
          "chunk": "facov_rounding_overflow_byte",
          "topic": "handling of extra low-order mantissa bytes used in rounding"
        }
      ]
    },
    {
      "start": 1492,
      "end": 1498,
      "name": "series_evaluation_sign_flag",
      "description": "SGNFLG ($67): stores the number of separate terms (evaluations) required when resolving complex mathematical expressions \u2014 used by the formula evaluation routines.",
      "references": [
        {
          "chunk": "fbufpt_series_evaluation_pointer",
          "topic": "pointer to the temporary table used during series/formula evaluation"
        },
        {
          "chunk": "fac1_fields_exponent_mantissa_sign",
          "topic": "relation to FAC1 during multi-term evaluations"
        }
      ]
    },
    {
      "start": 1499,
      "end": 1506,
      "name": "fac1_overflow_digit_bits",
      "description": "BITS ($68): overflow byte for FAC1. Used as an intermediate storage location during conversions (integer or text string to floating point) to hold overflowed least-significant digits.",
      "references": [
        {
          "chunk": "fac1_fields_exponent_mantissa_sign",
          "topic": "role of BITS in FAC1 conversion processes"
        },
        {
          "chunk": "facov_rounding_overflow_byte",
          "topic": "additional low-order mantissa storage for rounding/accuracy"
        }
      ]
    },
    {
      "start": 1507,
      "end": 1514,
      "name": "fac2_accumulator_overview",
      "description": "Floating Point Accumulator #2 (FAC2) overview ($69-$6E): a second floating-point accumulator used alongside FAC1 for operations requiring two values (products, sums, differences). Its format mirrors FAC1.",
      "references": [
        {
          "chunk": "fac2_fields_exponent_mantissa_sign",
          "topic": "detailed FAC2 field layout (exponent, mantissa, sign)"
        },
        {
          "chunk": "fac1_fields_exponent_mantissa_sign",
          "topic": "use together with FAC1 for multi-value arithmetic"
        }
      ]
    },
    {
      "start": 1515,
      "end": 1522,
      "name": "fac2_fields_exponent_mantissa_sign",
      "description": "FAC2 subfields: ARGEXP ($69) \u2014 exponent for FAC2; ARGHO ($6A-$6D) \u2014 mantissa bytes for FAC2; ARGSGN ($6E) \u2014 sign byte for FAC2. The format is the same as FAC1.",
      "references": [
        {
          "chunk": "fac2_accumulator_overview",
          "topic": "summary of FAC2's purpose"
        },
        {
          "chunk": "arisgn_signed_comparison_result",
          "topic": "comparison result between FAC1 and FAC2 signs"
        }
      ]
    },
    {
      "start": 1523,
      "end": 1529,
      "name": "arisgn_signed_comparison_result",
      "description": "ARISGN ($6F): indicates whether FAC1 and FAC2 have like or unlike signs \u2014 0 indicates like signs, $FF (255) indicates unlike signs; used during signed comparisons.",
      "references": [
        {
          "chunk": "fac1_fields_exponent_mantissa_sign",
          "topic": "FAC1 sign semantics"
        },
        {
          "chunk": "fac2_fields_exponent_mantissa_sign",
          "topic": "FAC2 sign semantics"
        }
      ]
    },
    {
      "start": 1530,
      "end": 1538,
      "name": "facov_rounding_overflow_byte",
      "description": "FACOV ($70): holds the low-order mantissa byte for FAC1 used when the true mantissa has more significant figures than fit in four bytes. These extra least-significant figures extend intermediate accuracy and are used for final rounding.",
      "references": [
        {
          "chunk": "fac1_fields_exponent_mantissa_sign",
          "topic": "how extra mantissa precision is applied when operating on FAC1"
        }
      ]
    },
    {
      "start": 1539,
      "end": 1552,
      "name": "fbufpt_series_evaluation_pointer",
      "description": "FBUFPT ($71-$72): pointer to a temporary table in free RAM used for series/formula evaluation. Also used for TI$ work area, string setup pointer, and array-size evaluation workspace. Notes that despite some documentation labeling it as a tape buffer pointer, BASIC ROM disassembly shows no reference for that purpose (tape buffer pointer is at location 178 ($B2)).",
      "references": [
        {
          "chunk": "series_evaluation_sign_flag",
          "topic": "points to the temporary table used during series/formula evaluation"
        },
        {
          "chunk": "basic_numeric_work_area_overview",
          "topic": "part of the overall BASIC numeric and work area layout"
        }
      ]
    },
    {
      "start": 1553,
      "end": 1636,
      "name": "chrget_subroutine",
      "description": "CHRGET zero-page subroutine ($73-$8A) 'Get Next BASIC Text Character' copied from ROM into RAM for speed. Complete behavior: how it increments TXTPTR, returns character in A, sets status flags (carry/zero) to indicate digits or terminators, skips spaces, and its significance as a wedge insertion point for intercepting BASIC text input. Includes disassembled listing of CHRGET and CHRGOT, explanation of flags on exit (carry/zero) and wedge techniques (JMP WEDGE at INC $7A or CMP #$3A), and notes on wedge performance and alternate methods through BASIC RAM vectors.",
      "references": [
        {
          "chunk": "basic_numeric_work_area_and_fac",
          "topic": "Uses TXTPTR and interacts with numeric/text parsing"
        },
        {
          "chunk": "basic_runtime_editor_io_and_screen_pointers",
          "topic": "TXTPTR and other editing pointers used by CHRGET"
        }
      ]
    },
    {
      "start": 1637,
      "end": 1663,
      "name": "rnd_seed_and_random_behavior",
      "description": "RNDX ($8B-$8F) seed value for the RND function (five-byte float seed explained), initial ROM seed bytes, behavior of RND(X) depending on sign of X: X=0 uses hardware timers seed; positive X returns next in pseudorandom sequence; negative X scrambles seed from X. Typical usage patterns for seeding (RND(-TI), RND(-RND(0))) and notes on pseudorandom determinism.",
      "references": [
        {
          "chunk": "kernal_work_area_and_io_status",
          "topic": "RND/seed may be influenced by timer/IRQ behavior discussed in the Kernal section"
        },
        {
          "chunk": "chrget_subroutine",
          "topic": "Text parsing and randomness can both be influenced by interrupts mentioned near CHRGET discussion"
        }
      ]
    },
    {
      "start": 1664,
      "end": 1673,
      "name": "kernal_zero_page_overview_0x90_0xff",
      "description": "Overview of the Kernal zero-page work storage area $90-$FF: initialization behavior at power-on and warning about modifying these locations.",
      "references": [
        {
          "chunk": "st_status_io_status_word_0x90",
          "topic": "I/O status word (ST) and device status bits"
        },
        {
          "chunk": "stkey_stop_key_and_keyboard_matrix_0x91",
          "topic": "STOP-key detection and keyboard matrix"
        }
      ]
    },
    {
      "start": 1674,
      "end": 1704,
      "name": "st_status_io_status_word_0x90",
      "description": "Kernal I/O Status Word (ST) at $90: role in Kernal I/O routines; mapping of status bits for cassette (short/long block, unrecoverable error, checksum error, EOF) and serial devices (write/read timeouts, EOI, device absent). Example: testing EOF via IF ST AND 64. Reference to RS-232 status (location 663/$297).",
      "references": [
        {
          "chunk": "kernal_zero_page_overview_0x90_0xff",
          "topic": "overview of the Kernal zero-page area"
        },
        {
          "chunk": "stkey_stop_key_and_keyboard_matrix_0x91",
          "topic": "keyboard/STOP-key detection uses a different zero-page location"
        }
      ]
    },
    {
      "start": 1705,
      "end": 1737,
      "name": "stkey_stop_key_and_keyboard_matrix_0x91",
      "description": "STKEY ($91): updated by the IRQ routine ~60Hz; contains the last row of the keyboard matrix (includes STOP key). Explains bit polarity (1 = unpressed, 0 = pressed) and gives example values for no key, numeric and special keys including STOP ($7F). Notes on branching (BPL) to detect STOP key and differences from VIC keyboard matrix.",
      "references": [
        {
          "chunk": "kernal_zero_page_overview_0x90_0xff",
          "topic": "overview of the Kernal zero-page area"
        },
        {
          "chunk": "st_status_io_status_word_0x90",
          "topic": "ST status and device I/O (related to input operations)"
        }
      ]
    },
    {
      "start": 1738,
      "end": 1744,
      "name": "svxt_tape_read_timing_constant_0x92",
      "description": "SVXT ($92): adjustable timing constant used for tape reads to compensate for slight tape speed variation.",
      "references": [
        {
          "chunk": "verck_load_verify_flag_0x93",
          "topic": "LOAD/VERIFY behavior often used together with tape timing"
        },
        {
          "chunk": "kernal_zero_page_overview_0x90_0xff",
          "topic": "overview of the Kernal zero-page area"
        }
      ]
    },
    {
      "start": 1745,
      "end": 1751,
      "name": "verck_load_verify_flag_0x93",
      "description": "VERCK ($93): flag used by the Kernal load routine to select between LOAD (0) and VERIFY (1). The load/verify decision also depends on the A register value on entry to the routine.",
      "references": [
        {
          "chunk": "svxt_tape_read_timing_constant_0x92",
          "topic": "tape timing parameter used during LOAD/VERIFY operations"
        },
        {
          "chunk": "kernal_zero_page_overview_0x90_0xff",
          "topic": "overview of the Kernal zero-page area"
        }
      ]
    },
    {
      "start": 1752,
      "end": 1758,
      "name": "c3po_serial_output_buffer_flag_0x94",
      "description": "C3PO ($94): flag indicating the serial output routines have buffered a character for transmission (output buffer is occupied).",
      "references": [
        {
          "chunk": "bsour_serial_buffered_character_0x95",
          "topic": "holds the actual buffered character for serial output"
        },
        {
          "chunk": "st_status_io_status_word_0x90",
          "topic": "serial device status bits and timeouts"
        }
      ]
    },
    {
      "start": 1759,
      "end": 1764,
      "name": "bsour_serial_buffered_character_0x95",
      "description": "BSOUR ($95): the buffered character waiting to be sent on the serial bus. A value of $FF (255) indicates no character is waiting.",
      "references": [
        {
          "chunk": "c3po_serial_output_buffer_flag_0x94",
          "topic": "buffer-occupied flag corresponding to this buffered character"
        },
        {
          "chunk": "st_status_io_status_word_0x90",
          "topic": "serial status and error reporting"
        }
      ]
    },
    {
      "start": 1765,
      "end": 1767,
      "name": "syno_cassette_block_sync_number_0x96",
      "description": "SYNO ($96): cassette block synchronization number used in tape I/O to track block synchronization.",
      "references": [
        {
          "chunk": "svxt_tape_read_timing_constant_0x92",
          "topic": "tape timing constant related to tape block reads"
        },
        {
          "chunk": "verck_load_verify_flag_0x93",
          "topic": "LOAD/VERIFY operations that use cassette synchronization"
        }
      ]
    },
    {
      "start": 1768,
      "end": 1773,
      "name": "xsav_x_register_save_area_0x97",
      "description": "XSAV ($97): temporary .X register save area used by routines that get and put ASCII characters.",
      "references": [
        {
          "chunk": "kernal_zero_page_overview_0x90_0xff",
          "topic": "overview of temporary save areas in the Kernal zero page"
        },
        {
          "chunk": "bsour_serial_buffered_character_0x95",
          "topic": "character I/O routines that may use .X save"
        }
      ]
    },
    {
      "start": 1774,
      "end": 1788,
      "name": "ldtnd_open_files_count_and_index_0x98",
      "description": "LDTND ($98): number of currently open I/O files (max 10) and index into the end-of-file tables that hold file numbers, device numbers, and secondary addresses (see locations 601-631/$259-$277). Explains how OPEN increases and CLOSE decreases this value, and CLALL sets it to 0.",
      "references": [
        {
          "chunk": "ptr1_tape_pass1_error_log_index_0x9e",
          "topic": "other zero-page Kernal control variables"
        },
        {
          "chunk": "kernal_zero_page_overview_0x90_0xff",
          "topic": "overview of the Kernal zero-page area"
        }
      ]
    },
    {
      "start": 1789,
      "end": 1799,
      "name": "dfltn_default_input_device_0x99",
      "description": "DFLTN ($99): default input device (0 = keyboard). CHKIN ($F20E) updates this to the device number defining the input channel. BASIC calls CHKIN for INPUT# or GET#, then clears the channel after the operation.",
      "references": [
        {
          "chunk": "dflto_default_output_device_0x9a",
          "topic": "complementary default output device handling"
        },
        {
          "chunk": "ldtnd_open_files_count_and_index_0x98",
          "topic": "file/device table indexing used by CHKIN/CHKOUT"
        }
      ]
    },
    {
      "start": 1800,
      "end": 1811,
      "name": "dflto_default_output_device_0x9a",
      "description": "DFLTO ($9A): default output (CMD) device (default 3 = screen). CHKOUT ($F250) stores the device number for output channels. BASIC calls CHKOUT on PRINT# or CMD and clears the channel after PRINT# completes.",
      "references": [
        {
          "chunk": "dfltn_default_input_device_0x99",
          "topic": "default input device and CHKIN behavior"
        },
        {
          "chunk": "bsour_serial_buffered_character_0x95",
          "topic": "serial output buffering when printing to devices"
        }
      ]
    },
    {
      "start": 1812,
      "end": 1817,
      "name": "prty_tape_character_parity_0x9b",
      "description": "PRTY ($9B): tape character parity used to detect bit loss during tape data transmission.",
      "references": [
        {
          "chunk": "dpsw_tape_byte_received_flag_0x9c",
          "topic": "byte-received flag used together with parity checks"
        },
        {
          "chunk": "syno_cassette_block_sync_number_0x96",
          "topic": "cassette synchronization used in tape transfers"
        }
      ]
    },
    {
      "start": 1818,
      "end": 1824,
      "name": "dpsw_tape_byte_received_flag_0x9c",
      "description": "DPSW ($9C): flag indicating whether a complete tape data byte has been received or only partially received.",
      "references": [
        {
          "chunk": "prty_tape_character_parity_0x9b",
          "topic": "parity checks used to detect transmission errors"
        },
        {
          "chunk": "ptr1_tape_pass1_error_log_index_0x9e",
          "topic": "error logging indices used for tape pass corrections"
        }
      ]
    },
    {
      "start": 1825,
      "end": 1846,
      "name": "msgflg_kernal_message_control_0x9d",
      "description": "MSGFLG ($9D): Kernal message control flag set by SETMSG ($FE18). Controls display of Kernal error and control messages: 192 ($C0)=both error and control, 128=control only, 64=error only, 0=suppress all (used by BASIC in program/RUN mode). Notes about BASIC preferring its own messages.",
      "references": [
        {
          "chunk": "kernal_zero_page_overview_0x90_0xff",
          "topic": "overview of Kernal control flags in zero page"
        },
        {
          "chunk": "ldtnd_open_files_count_and_index_0x98",
          "topic": "file operations that may generate Kernal messages"
        }
      ]
    },
    {
      "start": 1847,
      "end": 1854,
      "name": "ptr1_tape_pass1_error_log_index_0x9e",
      "description": "PTR1 ($9E): index used to set up an error log of bytes with parity errors detected on the first pass of tape block transmission (each block sent twice).",
      "references": [
        {
          "chunk": "ptr2_tape_pass2_error_correction_index_0x9f",
          "topic": "second-pass correction index for tape error handling"
        },
        {
          "chunk": "dpsw_tape_byte_received_flag_0x9c",
          "topic": "byte-received flag used during error logging"
        }
      ]
    },
    {
      "start": 1855,
      "end": 1860,
      "name": "ptr2_tape_pass2_error_correction_index_0x9f",
      "description": "PTR2 ($9F): index used to correct bytes that were transmitted incorrectly on the first pass of tape data.",
      "references": [
        {
          "chunk": "ptr1_tape_pass1_error_log_index_0x9e",
          "topic": "first-pass error logging index"
        },
        {
          "chunk": "prty_tape_character_parity_0x9b",
          "topic": "parity used to detect tape transmission errors"
        }
      ]
    },
    {
      "start": 1861,
      "end": 1871,
      "name": "time_software_jiffy_clock_0xa0_a2",
      "description": "TIME ($A0-$A2): three-byte software jiffy clock updated 60 times/sec. Location $A2 increments every jiffy (~0.01667s), $A1 updates every 256 jiffies (~4.2267s), $A0 updates every 65536 jiffies (~18.2044min). After 24 hours the clock wraps to 0.",
      "references": [
        {
          "chunk": "stkey_stop_key_and_keyboard_matrix_0x91",
          "topic": "IRQ routine that updates the keyboard matrix and the jiffy clock"
        },
        {
          "chunk": "kernal_zero_page_overview_0x90_0xff",
          "topic": "overview of Kernal zero-page timing and control data"
        }
      ]
    },
    {
      "start": 1872,
      "end": 1896,
      "name": "jiffy_clock_and_TI_variables",
      "description": "Explains the BASIC reserved variables TI and TI$, how they are implemented as calls to the Kernal routines RDTIM and SETTIM, how reading/assigning them interacts with these routines, includes a short BASIC example showing setting the jiffy clock, and notes that the IRQ (keyboard) interrupt and routines that steal or redirect IRQ (e.g. tape I/O) will interfere with the software jiffy clock.",
      "references": [
        {
          "chunk": "tape_buffer_count_and_force_output_BUFPNT",
          "topic": "tape I/O interactions that can affect IRQ and the jiffy clock"
        },
        {
          "chunk": "tape_buffer_pointer_TAPE1_B2_B3",
          "topic": "cassette buffer pointer and tape operations"
        }
      ]
    },
    {
      "start": 1897,
      "end": 1902,
      "name": "temporary_data_storage_A3_A4",
      "description": "Describes the $A3-$A4 locations used as temporary data storage by the tape and serial I/O routines; general-purpose working area for those routines.",
      "references": [
        {
          "chunk": "cassette_sync_countdown_CNTDN",
          "topic": "other nearby temporary tape/serial housekeeping locations"
        },
        {
          "chunk": "rs232_input_byte_buffer_RIDATA_AA",
          "topic": "related serial/tape temporary buffers"
        }
      ]
    },
    {
      "start": 1903,
      "end": 1908,
      "name": "cassette_sync_countdown_CNTDN",
      "description": "Documents CNTDN ($A5), the cassette synchronization-character countdown used to count how many sync characters are sent before the actual data in a tape block.",
      "references": [
        {
          "chunk": "tape_buffer_count_and_force_output_BUFPNT",
          "topic": "buffer handling during tape write/read operations"
        },
        {
          "chunk": "tape_timing_constant_CMP0_B0_B1",
          "topic": "timing constants relevant to tape I/O"
        }
      ]
    },
    {
      "start": 1909,
      "end": 1916,
      "name": "tape_buffer_count_and_force_output_BUFPNT",
      "description": "Documents BUFPNT ($A6), which counts the number of bytes read into or written to the cassette/tape buffer. Notes that writes wait until the full 192-byte buffer is filled and that output can be forced with POKE 166,191.",
      "references": [
        {
          "chunk": "tape_buffer_pointer_TAPE1_B2_B3",
          "topic": "start address of the cassette buffer"
        },
        {
          "chunk": "tape_timing_constant_CMP0_B0_B1",
          "topic": "timing values that affect tape reads/writes"
        }
      ]
    },
    {
      "start": 1917,
      "end": 1922,
      "name": "rs232_input_bits_inbit_A7",
      "description": "Describes INBIT ($A7), used to temporarily store each received RS-232 serial bit and for miscellaneous cassette/tape I/O tasks.",
      "references": [
        {
          "chunk": "rs232_input_bit_count_BITCI_A8",
          "topic": "counts bits received to form a byte"
        },
        {
          "chunk": "rs232_input_byte_buffer_RIDATA_AA",
          "topic": "where assembled bits are stored as bytes"
        }
      ]
    },
    {
      "start": 1923,
      "end": 1930,
      "name": "rs232_input_bit_count_BITCI_A8",
      "description": "Documents BITCI ($A8), the RS-232 input bit count (also used as cassette temporary storage). Used to count bits received so the serial routine knows when a full word has been received; also used as an error flag during tape loads.",
      "references": [
        {
          "chunk": "rs232_start_bit_flag_RINONE_A9",
          "topic": "start-bit checking flag used along with bit counts"
        },
        {
          "chunk": "rs232_input_byte_buffer_RIDATA_AA",
          "topic": "assembly of counted bits into bytes"
        }
      ]
    },
    {
      "start": 1931,
      "end": 1937,
      "name": "rs232_start_bit_flag_RINONE_A9",
      "description": "Explains RINONE ($A9), the RS-232 flag used to detect a start bit. A value of 144 ($90) indicates no start bit was received; 0 indicates a start bit was received.",
      "references": [
        {
          "chunk": "rs232_input_bit_count_BITCI_A8",
          "topic": "counts bits after start bit detection"
        },
        {
          "chunk": "rs232_input_byte_buffer_RIDATA_AA",
          "topic": "building an input byte after start-bit detection"
        }
      ]
    },
    {
      "start": 1938,
      "end": 1946,
      "name": "rs232_input_byte_buffer_RIDATA_AA",
      "description": "Documents RIDATA ($AA), the RS-232 input byte buffer (also used for cassette temporary storage). Serial routines reassemble bits stored in INBIT/BITCI here into a byte that will be stored in the receiving buffer. Tape routines use RIDATA as a flag to distinguish data bytes from synchronization characters.",
      "references": [
        {
          "chunk": "rs232_input_parity_or_tape_leader_RIPRTY_AB",
          "topic": "parity detection and tape leader counting"
        },
        {
          "chunk": "rs232_input_bits_inbit_A7",
          "topic": "temporary bit storage for incoming serial data"
        }
      ]
    },
    {
      "start": 1947,
      "end": 1952,
      "name": "rs232_input_parity_or_tape_leader_RIPRTY_AB",
      "description": "Describes RIPRTY ($AB), used to detect RS-232 transmission errors (parity) and to count tape leader length (used to detect end of leader).",
      "references": [
        {
          "chunk": "rs232_input_byte_buffer_RIDATA_AA",
          "topic": "used to verify assembled bytes or tape leader completion"
        },
        {
          "chunk": "rs232_input_bit_count_BITCI_A8",
          "topic": "works with bit count to detect reception errors"
        }
      ]
    },
    {
      "start": 1953,
      "end": 1961,
      "name": "load_start_pointer_SAL_AC_AD",
      "description": "Documents SAL ($AC-$AD), the pointer to the starting address of a LOAD (and used for screen-scrolling). The pointer to the start of the RAM area to be SAVEd or LOADed is copied here as a working pointer and is restored at the end of the operation. Screen management routines temporarily use SAL as a working pointer.",
      "references": [
        {
          "chunk": "load_end_pointer_EAL_AE_AF",
          "topic": "matching ending pointer for SAVE/LOAD/VERIFY operations"
        },
        {
          "chunk": "tape_buffer_count_and_force_output_BUFPNT",
          "topic": "buffering during tape save/load operations"
        }
      ]
    },
    {
      "start": 1962,
      "end": 1967,
      "name": "load_end_pointer_EAL_AE_AF",
      "description": "Documents EAL ($AE-$AF), the pointer to the ending address for SAVE/LOAD/VERIFY operations. Set by the Kernal SAVE routine to mark the end of the region to be saved or loaded.",
      "references": [
        {
          "chunk": "load_start_pointer_SAL_AC_AD",
          "topic": "the start pointer paired with this end pointer"
        }
      ]
    },
    {
      "start": 1968,
      "end": 1974,
      "name": "tape_timing_constant_CMP0_B0_B1",
      "description": "Explains CMP0 ($B0-$B1), used for tape timing. Location $B0 contains the adjustable timing constant that influences the value at $92; other locations (e.g. location 199 referenced here) are also used in tape read timing.",
      "references": [
        {
          "chunk": "cassette_sync_countdown_CNTDN",
          "topic": "sync character countdown interacts with timing constants"
        },
        {
          "chunk": "tape_buffer_pointer_TAPE1_B2_B3",
          "topic": "buffer pointer whose reads depend on timing"
        }
      ]
    },
    {
      "start": 1975,
      "end": 1982,
      "name": "tape_buffer_pointer_TAPE1_B2_B3",
      "description": "Documents TAPE1 ($B2-$B3), the pointer to the start of the cassette buffer. On power-on this points to the cassette buffer address (828, $33C). It must contain an address >= 512 ($200), otherwise tape I/O will return an ILLEGAL DEVICE NUMBER error.",
      "references": [
        {
          "chunk": "tape_buffer_count_and_force_output_BUFPNT",
          "topic": "BUFPNT holds counts for the buffer pointed to by TAPE1"
        },
        {
          "chunk": "tape_timing_constant_CMP0_B0_B1",
          "topic": "timing used when reading/writing the buffer"
        }
      ]
    },
    {
      "start": 1983,
      "end": 1989,
      "name": "rs232_output_bit_count_BITTS_B4",
      "description": "Describes BITTS ($B4), which counts RS-232 output bits and is used for parity and stop-bit handling. Tape load routines also use this location to flag readiness to receive data bytes.",
      "references": [
        {
          "chunk": "rs232_next_bit_or_tape_eot_NXTBIT_B5",
          "topic": "next-bit/position information used with bit counting"
        },
        {
          "chunk": "rs232_output_byte_buffer_RODATA_B6",
          "topic": "where bytes are disassembled for output bit-wise"
        }
      ]
    },
    {
      "start": 1990,
      "end": 1996,
      "name": "rs232_next_bit_or_tape_eot_NXTBIT_B5",
      "description": "Documents NXTBIT ($B5), which holds the next bit to send for RS-232 output and is used by tape routines to indicate which part of a block the read routine is currently processing (effectively a tape EOT/position flag).",
      "references": [
        {
          "chunk": "rs232_output_bit_count_BITTS_B4",
          "topic": "used together to manage bit transmission and framing"
        },
        {
          "chunk": "rs232_output_byte_buffer_RODATA_B6",
          "topic": "provides the bits fed from the output byte buffer"
        }
      ]
    },
    {
      "start": 1997,
      "end": 2002,
      "name": "rs232_output_byte_buffer_RODATA_B6",
      "description": "Explains RODATA ($B6), the RS-232 output byte buffer. RS-232 routines disassemble each byte to be transmitted from the transmission buffer (pointed to by $F9) into this area so bits can be shifted out.",
      "references": [
        {
          "chunk": "rs232_output_bit_count_BITTS_B4",
          "topic": "bit counting and parity/stop-bit handling for output"
        },
        {
          "chunk": "rs232_next_bit_or_tape_eot_NXTBIT_B5",
          "topic": "holds the next bit generated from RODATA for transmission"
        }
      ]
    },
    {
      "start": 2003,
      "end": 2026,
      "name": "filename_length_FNLEN_B7_and_filename_behaviour",
      "description": "Covers FNLEN ($B7), which holds the length of the current filename and the behavior differences between disk and tape files. Disk filenames: 1\u201316 characters; tape filenames: 0\u2013187 characters. Notes on truncation of long tape names in messages, using tape filenames for machine-language program storage, the meaning of FNLEN being zero for unnamed tape operations, and that an RS-232 OPEN command may specify a 4-character filename copied to locations 659\u2013662 ($293\u2013$296) to determine baud rate, word length, and parity.",
      "references": [
        {
          "chunk": "rs232_input_byte_buffer_RIDATA_AA",
          "topic": "RS-232 device interactions and filename usage for OPEN commands"
        },
        {
          "chunk": "tape_buffer_pointer_TAPE1_B2_B3",
          "topic": "tape filenames and cassette-buffer usage"
        }
      ]
    },
    {
      "start": 2027,
      "end": 2043,
      "name": "current_logical_file_number_la",
      "description": "LA ($B8) \u2014 Holds the logical file number for the device currently in use. Notes maximum open files (five disk files, ten total), valid file number range (1\u2013255; 0 = system defaults), special behavior when the logical file number is >127 (an ASCII linefeed is sent after each carriage return), and that the BASIC OPEN command (e.g. OPEN 4,8,15) sets this location (logical file number corresponds to the first OPEN parameter).",
      "references": [
        {
          "chunk": "current_secondary_address_sa",
          "topic": "secondary address used alongside logical file numbers when opening devices"
        },
        {
          "chunk": "current_device_number_fa",
          "topic": "device number assignments that work together with logical file numbers"
        }
      ]
    },
    {
      "start": 2044,
      "end": 2092,
      "name": "current_secondary_address_sa",
      "description": "SA ($B9) \u2014 Holds the current secondary address for the open device. Covers valid ranges (0\u201331 for serial devices, 0\u2013127 for others), explains that secondary addresses are device-specific (keyboard/screen ignore them), disk drive usage (distinguishes multiple open files; 0,1 and 15\u201331 have special meaning; use 2\u201314 for ordinary disk file secondary addresses), and behaviors: disk OPEN with secondary 15 opens the DOS channel; LOAD with secondary 0 loads to start-of-BASIC pointer (43/$2B); LOAD/SAVE with secondary 1 load/save to addresses recorded in the file; unspecified LOAD/SAVE default to 0. Also covers Datasette conventions (0=read, 1=write, +2 = write End-of-Tape marker) and 1515/1525 printer secondary-address differences for character sets (7 = upper/lowercase, 0 or omitted = uppercase/graphics).",
      "references": [
        {
          "chunk": "current_logical_file_number_la",
          "topic": "logical file numbers used together with secondary addresses in OPEN statements"
        },
        {
          "chunk": "pointer_current_filename_fnadr",
          "topic": "filename pointer used when opening files (relevant to LOAD/SAVE and tape/disk behavior)"
        },
        {
          "chunk": "current_device_number_fa",
          "topic": "device number gives device type context for secondary-address meanings"
        }
      ]
    },
    {
      "start": 2093,
      "end": 2105,
      "name": "current_device_number_fa",
      "description": "FA ($BA) \u2014 Holds the number of the device currently being used. Lists device-number assignments: 0 = keyboard, 1 = Datasette recorder, 2 = RS-232/User Port, 3 = screen, 4\u20135 = printer, 8\u201311 = disk.",
      "references": [
        {
          "chunk": "current_secondary_address_sa",
          "topic": "secondary addresses are interpreted differently depending on the device number"
        },
        {
          "chunk": "current_logical_file_number_la",
          "topic": "logical file numbers identify open files for the currently selected device"
        }
      ]
    },
    {
      "start": 2106,
      "end": 2126,
      "name": "pointer_current_filename_fnadr",
      "description": "FNADR ($BB-$BC) \u2014 Two-byte pointer to the current filename used by OPEN/LOAD/SAVE operations. Notes that the pointer is unused for tape OPENs without a filename. Explains disk filename behavior with a shifted-space inside the name (rest of name appears outside quotes in directory and can act like comments; program can be referenced by quoted portion or full name; examples shown). Also explains RS-232 filename usage: up to four characters are allowed and are copied to $293\u2013$296 (659\u2013662 decimal) to control serial parameters like baud, parity, and word length.",
      "references": [
        {
          "chunk": "current_secondary_address_sa",
          "topic": "secondary address affects how LOAD/SAVE interpret filenames and load addresses"
        },
        {
          "chunk": "rs232_parity_and_cassette_temp_roprty",
          "topic": "RS-232 routines use related workspace locations (parity/temporary storage)"
        }
      ]
    },
    {
      "start": 2127,
      "end": 2133,
      "name": "rs232_parity_and_cassette_temp_roprty",
      "description": "ROPRTY ($BD) \u2014 Used as an output-parity work byte by the RS-232 routines and as temporary storage for the current character being read or sent by the cassette/tape routines.",
      "references": [
        {
          "chunk": "pointer_current_filename_fnadr",
          "topic": "RS-232 filename characters copied to $293\u2013$296 affect serial parameters; ROPRTY is used during RS-232 operations"
        },
        {
          "chunk": "tape_input_byte_buffer_mych",
          "topic": "tape routines use nearby workspace locations for assembling and temporarily storing characters"
        }
      ]
    },
    {
      "start": 2134,
      "end": 2139,
      "name": "cassette_block_count_fsblk",
      "description": "FSBLK ($BE) \u2014 Cassette read/write block count: used by tape routines to count the number of copies of a data block remaining to be read or written.",
      "references": [
        {
          "chunk": "tape_input_byte_buffer_mych",
          "topic": "FSBLK is used together with the tape input buffer when reading/writing blocks"
        },
        {
          "chunk": "io_start_address_stal",
          "topic": "STAL points to the RAM area used during LOAD/SAVE operations including tape I/O"
        }
      ]
    },
    {
      "start": 2140,
      "end": 2145,
      "name": "tape_input_byte_buffer_mych",
      "description": "MYCH ($BF) \u2014 Tape input byte buffer used by tape routines as a work area where incoming characters are assembled.",
      "references": [
        {
          "chunk": "cassette_block_count_fsblk",
          "topic": "FSBLK tracks how many blocks remain while MYCH holds the assembled bytes"
        },
        {
          "chunk": "tape_motor_interlock_cas1",
          "topic": "CAS1 and other tape-related locations coordinate tape hardware and data flow"
        }
      ]
    },
    {
      "start": 2146,
      "end": 2164,
      "name": "tape_motor_interlock_cas1",
      "description": "CAS1 ($C0) \u2014 Tape motor interlock. Maintained by the IRQ routine that scans the keyboard: when a recorder button is pressed the IRQ checks CAS1; if CAS1 contains 0 the motor is turned on by clearing Bit 5 of location 1; when the button is released the motor is turned off and CAS1 is set to 0. Because the IRQ runs 60 times/sec, software attempts to keep the motor bit set will be overridden unless CAS1 is set to a nonzero value after a button press. Explains interaction between software control and IRQ-driven button behavior.",
      "references": [
        {
          "chunk": "tape_input_byte_buffer_mych",
          "topic": "CAS1 affects tape hardware readiness while MYCH handles data bytes"
        },
        {
          "chunk": "cassette_block_count_fsblk",
          "topic": "CAS1 interacts with tape read/write operations counted by FSBLK"
        }
      ]
    },
    {
      "start": 2165,
      "end": 2174,
      "name": "io_start_address_stal",
      "description": "STAL ($C1-$C2) \u2014 Two-byte pointer to the I/O start address. Points to the beginning address in RAM currently being LOADed or SAVEd. For tape I/O it points to the cassette buffer; subsequent data blocks are loaded/saved directly to/from RAM. STAL indicates the RAM area used for blocks after the initial header.",
      "references": [
        {
          "chunk": "pointer_current_filename_fnadr",
          "topic": "STAL works together with filename/buffer pointers during LOAD/SAVE operations"
        },
        {
          "chunk": "cassette_block_count_fsblk",
          "topic": "STAL identifies where tape blocks are stored while FSBLK counts blocks remaining"
        }
      ]
    },
    {
      "start": 2175,
      "end": 2187,
      "name": "lstx_last_key_matrix_coordinate",
      "description": "LSTX ($C5) \u2014 Matrix coordinate of the last key pressed. Describes how this zero-page location is updated each IRQ for keyboard debouncing, how the OS uses it to suppress repeats, and that its values are based on the keyboard matrix explained at SFDX ($CB).",
      "references": [
        {
          "chunk": "sfdx_keyscan_matrix_coordinate_and_keymap",
          "topic": "keyboard matrix values and mapping list used to produce LSTX values"
        },
        {
          "chunk": "ndx_keyboard_buffer_count_and_dynamic_keyboard",
          "topic": "interaction between key debounce and keyboard buffer usage"
        }
      ]
    },
    {
      "start": 2188,
      "end": 2235,
      "name": "ndx_keyboard_buffer_count_and_dynamic_keyboard",
      "description": "NDX ($C6) \u2014 Number of characters in the keyboard buffer (queue). Explains the meaning of the count, the buffer-size limit (location 649/$289 default 10), and practical techniques: clearing the buffer by POKE 198, using dynamic keyboard programming to inject characters (simulate input), and an example POKE sequence (POKE 198,3:POKE 631,34:POKE 632,34:POKE 633,20) to force quoted input for INPUT statements.",
      "references": [
        {
          "chunk": "lstx_last_key_matrix_coordinate",
          "topic": "debounce/state of last key pressed that complements keyboard buffer handling"
        },
        {
          "chunk": "sfdx_keyscan_matrix_coordinate_and_keymap",
          "topic": "keyboard matrix interpretation used when injecting characters"
        }
      ]
    },
    {
      "start": 2236,
      "end": 2250,
      "name": "rvs_reverse_print_flag",
      "description": "RVS ($C7) \u2014 Reverse-print flag. Describes how CHR$(18) (CTRL+RVS-ON) sets this location to $12 (18) so printed characters are displayed reversed (screen code + $80), how directly POKEing a nonzero value achieves the same effect, and that the flag resets to zero on CTRL+RVS-OFF (CHR$(146)) or on every carriage return.",
      "references": [
        {
          "chunk": "keytab_keyboard_decode_tables",
          "topic": "character printing and how printed character codes interact with display routines"
        }
      ]
    },
    {
      "start": 2251,
      "end": 2257,
      "name": "indx_end_of_logical_line_pointer",
      "description": "INDX ($C8) \u2014 Pointer (column number) to the end of the logical line for input. Explains that it holds the last nonblank character column index for an input logical line (range 0\u201379 because logical lines can be up to 80 characters).",
      "references": [
        {
          "chunk": "lxsp_cursor_start_position",
          "topic": "cursor start X,Y and logical line position used when performing input editing"
        },
        {
          "chunk": "pnt_pointer_and_pntr_cursor_column",
          "topic": "screen line pointer and cursor column in relation to INDX"
        }
      ]
    },
    {
      "start": 2258,
      "end": 2272,
      "name": "lxsp_cursor_start_position",
      "description": "LXSP ($C9-$CA) \u2014 Cursor X,Y position at the start of input. Describes how these two locations store the logical line number and column when input begins, the range of values (logical line 1\u201325, column 1\u201340 or 1\u201380), and references the screen line link table for detailed logical-line behavior.",
      "references": [
        {
          "chunk": "ldtb1_screen_line_link_table",
          "topic": "logical vs. physical line mapping used by LXSP"
        },
        {
          "chunk": "indx_end_of_logical_line_pointer",
          "topic": "end-of-logical-line column index used during input"
        }
      ]
    },
    {
      "start": 2273,
      "end": 2324,
      "name": "sfdx_keyscan_matrix_coordinate_and_keymap",
      "description": "SFDX ($CB) \u2014 Matrix coordinate of the current key pressed and the key-to-index mapping. Explains how the keyscan interrupt stores a key matrix index here and shows the mapping of indexes 0\u201364 to physical keys and symbols (listing values like 0=INST/DEL, 1=RETURN, ... 63=RUN/STOP, 64=NO KEY PRESSED). Also notes that the RESTORE key is not part of the normal matrix and triggers NMI instead.",
      "references": [
        {
          "chunk": "lstx_last_key_matrix_coordinate",
          "topic": "LSTX holds the last key matrix coordinate used for debouncing"
        },
        {
          "chunk": "keytab_keyboard_decode_tables",
          "topic": "KEYTAB maps these matrix indexes to actual characters depending on shift/CTRL/Commodore-key state"
        }
      ]
    },
    {
      "start": 2325,
      "end": 2364,
      "name": "cursor_blink_flags_and_state",
      "description": "BLNSW ($CC), BLNCT ($CD), GDBLN ($CE), BLNON ($CF) \u2014 Cursor blink control and state. Covers BLNSW (cursor blink enable/disable: nonzero disables blink; guidance to POKE 204,0 to force blinking during programs), BLNCT (blink countdown timer that counts down from 20 every jiffy to produce ~3 blinks/sec), GDBLN (stores the normal screen code of the character under the cursor so it can be restored), and BLNON (tracks whether the cursor's current blink shows reversed or normal character: 0=reversed, 1=normal).",
      "references": [
        {
          "chunk": "pnt_pointer_and_pntr_cursor_column",
          "topic": "cursor position on screen used by blink routines"
        },
        {
          "chunk": "rvs_reverse_print_flag",
          "topic": "reversed-character printing concept related to cursor inversion"
        }
      ]
    },
    {
      "start": 2365,
      "end": 2371,
      "name": "crsw_input_source_flag",
      "description": "CRSW ($D0) \u2014 Input-from keyboard-or-screen flag. Describes how the Kernal CHRIN routine uses this flag to indicate input source: 3 indicates input available from the screen, 0 indicates a new line should be obtained from the keyboard.",
      "references": [
        {
          "chunk": "ndx_keyboard_buffer_count_and_dynamic_keyboard",
          "topic": "keyboard buffer usage affecting input source"
        }
      ]
    },
    {
      "start": 2372,
      "end": 2385,
      "name": "pnt_pointer_and_pntr_cursor_column",
      "description": "PNT ($D1-$D2) and PNTR ($D3) \u2014 PNT is a two-byte pointer to the address in screen RAM of the first column of the logical line containing the cursor; PNTR stores the cursor column within that logical line (0\u201379). Explains use of these pointers for locating current logical line and that PNTR matches the value returned by POS. Mentions interaction with TBLX and the Kernal PLOT routine for cursor movement.",
      "references": [
        {
          "chunk": "ldtb1_screen_line_link_table",
          "topic": "how PNT is computed using the screen-line link table"
        },
        {
          "chunk": "qtsw_quote_mode_and_hook_example",
          "topic": "editing modes that affect cursor behavior tracked by PNT/PNTR"
        }
      ]
    },
    {
      "start": 2386,
      "end": 2420,
      "name": "qtsw_quote_mode_and_hook_example",
      "description": "QTSW ($D4) \u2014 Quote mode flag and behaviors. Explains quote mode semantics (toggle per quote mark on a line), how nonprinting characters are printed literally while in quote/insert mode and deferred until PRINT, DELETE key exception, and ways to exit quote mode (closing quote or RETURN/SHIFT-RETURN). Includes a machine-language hook example (listing of DATA bytes and BASIC loader) that intercepts the keyscan interrupt to allow escaping quote mode with F1.",
      "references": [
        {
          "chunk": "insrt_insert_mode_flag",
          "topic": "insert mode interaction and differences from quote mode"
        },
        {
          "chunk": "pnt_pointer_and_pntr_cursor_column",
          "topic": "cursor/line pointers updated when quote/insert mode changes affect editing"
        }
      ]
    },
    {
      "start": 2421,
      "end": 2449,
      "name": "lnmx_tblx_and_ascii_temp_cursor_line_info",
      "description": "LNMX ($D5), TBLX ($D6), and ASCII temp ($D7). LNMX explains how the editor determines whether a new physical line can be added to the current logical line (maximum physical line length). TBLX stores the current cursor physical screen line number (0\u201324) and can be POKEd to move the cursor vertically (example provided). The ASCII temporary location holds the ASCII value of the last character printed to the screen.",
      "references": [
        {
          "chunk": "ldtb1_screen_line_link_table",
          "topic": "mapping of physical rows to logical lines used alongside LNMX and TBLX"
        }
      ]
    },
    {
      "start": 2450,
      "end": 2468,
      "name": "insrt_insert_mode_flag",
      "description": "INSRT ($D8) \u2014 Insert mode flag. Describes behavior when INST key is pressed: shifting the line right, allocating another physical line if needed and available, updating LNMX ($D5) and the screen line link table, and tracking how many insert spaces are open (any nonzero value is interpreted as the number of inserts). Explains how insert mode makes the editor act like quote mode until inserts are filled, with the difference that DELETE leaves a printed equivalent while INST inserts spaces normally.",
      "references": [
        {
          "chunk": "qtsw_quote_mode_and_hook_example",
          "topic": "similarities and differences between quote and insert modes"
        },
        {
          "chunk": "ldtb1_screen_line_link_table",
          "topic": "adjustments to the link table when inserts cause physical/logical line changes"
        }
      ]
    },
    {
      "start": 2469,
      "end": 2497,
      "name": "ldtb1_screen_line_link_table",
      "description": "LDTB1 ($D9-$F2) \u2014 Screen line link table and editor temporary storage (25 entries). Describes the two functions per entry: bits 0\u20133 indicate which of the four VIC-II screen memory pages contains the first byte of that row (used to compute the high byte of the screen address combined with a low-byte table at $ECF0), and the high bit ($80) is used as a flag by the editor to indicate whether the line is the first/only physical line of a logical line (set) or the second half of a logical line (cleared). Explains why separate high/low tables are needed on the C64 (screen memory relocatable).",
      "references": [
        {
          "chunk": "pnt_pointer_and_pntr_cursor_column",
          "topic": "PNT uses this table to compute the start address of the current logical line"
        },
        {
          "chunk": "lnmx_tblx_and_ascii_temp_cursor_line_info",
          "topic": "LNMX and TBLX rely on the link-table structure to manage logical/physical lines"
        }
      ]
    },
    {
      "start": 2498,
      "end": 2505,
      "name": "user_color_ram_pointer",
      "description": "USER ($F3-$F4) \u2014 Pointer to the address of the current screen color RAM location. Explains that this pointer is synchronized with PNT ($D1) and holds the address of the first byte of color RAM for the corresponding screen line.",
      "references": [
        {
          "chunk": "pnt_pointer_and_pntr_cursor_column",
          "topic": "synchronization between the screen RAM pointer and the color-RAM pointer"
        }
      ]
    },
    {
      "start": 2506,
      "end": 2535,
      "name": "keytab_keyboard_decode_tables",
      "description": "KEYTAB ($F5-$F6) \u2014 Vector to the keyboard decode table(s). Explains that KEYTAB points to one of four 64-byte tables which map the 64 keyboard matrix indexes to ASCII values depending on modifier state (unshifted, shifted, Commodore-logo, CTRL). Lists the addresses of the four default tables: 60289 ($EB81) unshifted, 60354 ($EBC2) shifted, 60419 ($EC03) Commodore-logo, 60536 ($EC78) CTRL. Clarifies the distinction between keyboard decode tables (which decide what character each key prints) and character-set tables used by the VIC-II (selected by $D018) which determine how screen codes are rendered.",
      "references": [
        {
          "chunk": "sfdx_keyscan_matrix_coordinate_and_keymap",
          "topic": "matrix indexes converted to characters using the tables pointed to by KEYTAB"
        },
        {
          "chunk": "rvs_reverse_print_flag",
          "topic": "printing/display behavior that may alter printed character codes (e.g., reversed)"
        }
      ]
    },
    {
      "start": 2536,
      "end": 2546,
      "name": "ribuf_rs232_input_buffer_pointer",
      "description": "RIBUF ($F7-$F8) \u2014 Pointer to the RS-232 input buffer. Explains that when device #2 (RS-232) is opened two 256-byte buffers are allocated at the top of memory, and this location points to the currently used input buffer. Advises BASIC programs to OPEN device 2 before assigning variables to avoid top-of-memory clashes because OPEN performs a CLR.",
      "references": [
        {
          "chunk": "robuf_rs232_output_buffer_pointer",
          "topic": "paired output buffer pointer used for RS-232 device 2"
        }
      ]
    },
    {
      "start": 2547,
      "end": 2553,
      "name": "robuf_rs232_output_buffer_pointer",
      "description": "ROBUF ($F9-$FA) \u2014 Pointer to the RS-232 output buffer. Describes that this pointer references the 256-byte output buffer used for transmitting data to RS-232 devices (device #2).",
      "references": [
        {
          "chunk": "ribuf_rs232_input_buffer_pointer",
          "topic": "input/output buffer pair used by the RS-232 driver (device 2)"
        }
      ]
    },
    {
      "start": 2554,
      "end": 2561,
      "name": "freezp_user_zero_page_bytes",
      "description": "FREEZP ($FB-$FE) \u2014 Four free zero-page bytes reserved for user programs. Explains that these four bytes are guaranteed not to be altered by BASIC, making them suitable for user-written machine-language routines that require zero-page addressing; other zero-page locations may be used but are not guaranteed safe.",
      "references": [
        {
          "chunk": "lstx_last_key_matrix_coordinate",
          "topic": "example of zero-page use in OS keyboard/state handling"
        }
      ]
    },
    {
      "start": 2562,
      "end": 2568,
      "name": "baszpt_basic_temp_float_to_ascii",
      "description": "BASZPT ($FF) \u2014 BASIC temporary byte used during floating-point to ASCII conversion. Describes its use as temporary storage in the conversion process. (Includes trailing blank lines from the original source.)",
      "references": [
        {
          "chunk": "freezp_user_zero_page_bytes",
          "topic": "adjacent zero-page usage and reserved bytes for BASIC/ML routines"
        }
      ]
    },
    {
      "start": 2569,
      "end": 2651,
      "name": "microprocessor_stack_overview_and_basic_usage",
      "description": "Overview of the 6510 microprocessor hardware stack (locations 256-511 / $100-$1FF): LIFO behavior, Stack Pointer operation, overflow/underflow effects, uses for return addresses and register saves, and availability for temporary programmer storage. Microsoft BASIC's reserved subregions within the stack area are documented: work area for floating-point to string conversions ($100-$10A), tape input error log BAD ($100-$13E), and the remainder reserved for the hardware stack ($13F-$1FF). Detailed description of how BASIC uses the stack: FOR pushes 18 bytes (structure: $81 constant, 2-byte pointer to variable, 5-byte FP TO value, 2-byte line number, 2-byte address of next character), GOSUB pushes 5 bytes (constant $8D, 2-byte return line, 2-byte pointer to BASIC text), and DEF pushes a similar 5-byte entry (dummy first byte).",
      "references": [
        {
          "chunk": "basic_kernal_working_storage_and_buf_input_buffer",
          "topic": "continues with BASIC and Kernal working storage and the BUF input buffer"
        }
      ]
    },
    {
      "start": 2652,
      "end": 2690,
      "name": "basic_kernal_working_storage_and_buf_input_buffer",
      "description": "Introduction to Chapter 3: BASIC and the Kernal working storage area. Purpose of the area (vectors, OS/Kernal routines, RS-232 registers, buffers for tape I/O, BASIC input, keyboard queue, OS variables/pointers). Detailed entry for BUF (512-600 / $200-$258): the BASIC line editor input buffer used in immediate mode and by INPUT/GET, how BASIC tokenizes or executes input, why INPUT/GET are illegal in immediate mode, the buffer length (89 bytes), screen editor limit (80 chars), and the last eight bytes often available to the programmer.",
      "references": [
        {
          "chunk": "microprocessor_stack_overview_and_basic_usage",
          "topic": "previous chapter material on stack usage by BASIC and Kernal"
        },
        {
          "chunk": "i_o_tables_lat_fat_sat_and_clall",
          "topic": "next: tables for open files, devices, and secondary addresses"
        }
      ]
    },
    {
      "start": 2691,
      "end": 2724,
      "name": "i_o_tables_lat_fat_sat_and_clall",
      "description": "Tables for File Numbers, Device Numbers, and Secondary Addresses (locations 601-630 / $259-$276). Layout and purpose of the three 10-byte tables (LAT at $259-$262 for logical file numbers, FAT at $263-$26C for device numbers, SAT at $26D-$276 for secondary addresses). How entries are added on OPEN (appended) and removed on CLOSE (tables compacted), increment/decrement of location 152 ($98) indicating active I/O files, and the Kernal CLALL routine effect (zeroing location 152 to empty tables).",
      "references": [
        {
          "chunk": "basic_kernal_working_storage_and_buf_input_buffer",
          "topic": "previous: description of working storage area and BUF"
        },
        {
          "chunk": "keyboard_buffer_dynamic_keyboard_and_program_merge_techniques",
          "topic": "next: keyboard buffer and dynamic keyboard techniques"
        }
      ]
    },
    {
      "start": 2725,
      "end": 2823,
      "name": "keyboard_buffer_dynamic_keyboard_and_program_merge_techniques",
      "description": "Keyboard buffer / queue (KEYD, 631-640 / $277-$280): FIFO behavior, interrupt deposit of ASCII codes, 10-character capacity (limited by XMAX at $289), behavior when full, interaction with GET and INPUT, and clearing the buffer via POKE 198 ($C6). The dynamic keyboard technique: programmatically POKEing PETASCII characters and count into the keyboard buffer to simulate typing (examples: printing statements to be entered, homing cursor, executing END to cause automatic entry). Examples and uses: adding/modifying/deleting program lines at runtime, entering numbered DATA statements, merging/telnetting ASCII program files. Procedures to create ASCII program files (OPEN/CMD/LIST) for tape and disk are shown, plus a full example merge program (lines 60000\u201360180) that reads an ASCII file and injects it into the keyboard buffer; notes on saving before running and how to merge additional programs.",
      "references": [
        {
          "chunk": "i_o_tables_lat_fat_sat_and_clall",
          "topic": "previous: I/O tables (LAT/FAT/SAT) used when opening devices referenced here"
        },
        {
          "chunk": "memory_pointers_memstr_memsiz_color_and_screen_base_hibase",
          "topic": "next: OS memory pointers and screen base/HIBASE which affect buffers and display"
        }
      ]
    },
    {
      "start": 2824,
      "end": 2824,
      "ignore": true,
      "reason": "Single blank line / formatting artifact between chunks, non-technical"
    },
    {
      "start": 2825,
      "end": 2857,
      "name": "memstr_and_memsiz_os_memory_pointers",
      "description": "Kernal pointers MEMSTR (locations 641-642, $281-$282) and MEMSIZ (643-644, $283-$284). MEMSTR: OS start of user RAM (initialized by RAMTAS to $0800). MEMSIZ: OS top-of-memory pointer determined by RAM test (RAMTAS), adjusted when RS-232 device opened/closed. References to Kernal routines RAMTAS, MEMBOT, MEMTOP (addresses $FD50, $FE34, $FE25).",
      "references": [
        {
          "chunk": "rs232_pseudo_6551_registers",
          "topic": "Opening RS-232 device can alter MEMSIZ to allocate buffers"
        }
      ]
    },
    {
      "start": 2858,
      "end": 2858,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2859,
      "end": 2865,
      "name": "timout_ieee_time_out_flag",
      "description": "TIMOUT (location 645, $285): Kernal variable used only with an external IEEE interface card to control IEEE Time-Out. See Kernal SETTMO routine (65057, $FE21).",
      "references": [
        {
          "chunk": "kernal_vector_table_and_vectors",
          "topic": "Related Kernal routines (SETTMO) are vectored through the Kernal"
        }
      ]
    },
    {
      "start": 2866,
      "end": 2866,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2867,
      "end": 2903,
      "name": "color_register_and_available_colors",
      "description": "COLOR (location 646, $286): current foreground color for text. Explains how PRINT writes both screen code and color RAM, how OS reads this location for color when printing. Methods to change it: CTRL/Commodore logo key combos, CHR$ or POKE. Includes full color table mapping POKE color code, color name, PETASCII code, and keys to press (values 0-15).",
      "references": [
        {
          "chunk": "gdcol_color_under_cursor",
          "topic": "GDCOL stores original color under cursor"
        },
        {
          "chunk": "hibase_screen_memory_top_page",
          "topic": "PRINT effects when HIBASE is changed to print to other memory (examples)"
        }
      ]
    },
    {
      "start": 2904,
      "end": 2913,
      "name": "gdcol_color_under_cursor",
      "description": "GDCOL (location 647, $287): stores the color code of the character currently under the blinking cursor so the OS can restore it when the cursor moves. Used together with COLOR at 646 ($286).",
      "references": [
        {
          "chunk": "color_register_and_available_colors",
          "topic": "COLOR register defines foreground color used when cursor blinks"
        }
      ]
    },
    {
      "start": 2914,
      "end": 2968,
      "name": "hibase_screen_memory_top_page_and_examples",
      "description": "HIBASE (location 648, $288): top page (1K page) of screen memory used by OS printing routines; multiply value by 256 to get start address. Default is 4 ($400). Explains relocating screen memory by manipulating VIC-II memory bank select (53272, $D018 and CIA #2 port). Shows examples of PRINTing to arbitrary memory, including printing sprite shape data and changing color RAM initialization by changing background color. Includes two BASIC example programs demonstrating printing to sprite shape area and printing characters in ROM.",
      "references": [
        {
          "chunk": "vicscn_video_screen_memory_area",
          "topic": "VICSCN default location ($0400-$07FF) and relation to HIBASE"
        },
        {
          "chunk": "sprite_shape_data_pointers",
          "topic": "Pointers to sprite shape data located at end of screen matrix"
        }
      ]
    },
    {
      "start": 2969,
      "end": 2982,
      "name": "xmax_keyboard_buffer_size",
      "description": "XMAX (location 649, $289): maximum keyboard buffer size. Default usually 10; may be extended up to 15 by altering this value (with caveats about possibly overwriting OS pointers at 641-644 and 55). Describes how keyboard buffer length (location 198, $C6) is compared to XMAX to ignore further keystrokes.",
      "references": [
        {
          "chunk": "keyboard_repeat_and_delay_flags",
          "topic": "Related keyboard timing and repeat behavior are in RPTFLAG / KOUNT / DELAY"
        }
      ]
    },
    {
      "start": 2983,
      "end": 2994,
      "name": "rptflag_key_repeat_control",
      "description": "RPTFLAG (location 650, $28A): flag controlling which keys repeat when held. Default 0 (only cursor keys, insert/delete, and space repeat). POKE 128 ($80) makes all keys repeat; POKE 64 ($40) disables repeating entirely.",
      "references": [
        {
          "chunk": "kount_key_repeat_timing_counter",
          "topic": "KOUNT and DELAY control timing for repeats"
        }
      ]
    },
    {
      "start": 2995,
      "end": 3009,
      "name": "kount_key_repeat_delay_counter",
      "description": "KOUNT (location 651, $28B): counter used to time delay between key repeats. Starts at 6; if DELAY (652) is zero, KOUNT is decremented at 1/60 second intervals while key is held. On reaching 0, key is reinserted into keyboard buffer and KOUNT is set to 4 for subsequent faster repeats (~15 per second).",
      "references": [
        {
          "chunk": "delay_key_repeat_initial_delay",
          "topic": "DELAY provides the initial longer delay before the first repeat"
        }
      ]
    },
    {
      "start": 3010,
      "end": 3022,
      "name": "delay_key_repeat_initial_delay",
      "description": "DELAY (location 652, $28C): initial delay counter for the time a key must be held before repeating begins. Default 16, counted down every 1/60 second. When it reaches 0, KOUNT is used to schedule first repeat (so total ~22/60 second before first repeat). After first repeat DELAY stays at 0.",
      "references": [
        {
          "chunk": "kount_key_repeat_delay_counter",
          "topic": "KOUNT is used for repeat interval once initial DELAY expires"
        }
      ]
    },
    {
      "start": 3023,
      "end": 3023,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3024,
      "end": 3054,
      "name": "shflag_shift_ctrl_logo_flag_and_keyboard_tables",
      "description": "SHFLAG (location 653, $28D): flag that encodes current SHIFT/CTRL/Commodore-logo key state. Bit values: 1=SHIFT, 2=Logo, 4=CTRL; values add for combinations. Used by OS to select one of four keyboard lookup tables (see location 245, $F5). Pressing SHIFT+Logo toggles character set (uppercase/graphics <-> lowercase/uppercase) unless disabled by MODE (657). Explains effect on dot-table base address (53272, $D018) and that this is distinct from key translations.",
      "references": [
        {
          "chunk": "mode_toggle_character_sets",
          "topic": "MODE flag can disable SHIFT+Logo character set toggle"
        },
        {
          "chunk": "keylog_vector_and_keyboard_table_setup",
          "topic": "KEYLOG vector is used to set up keyboard lookup tables based on SHFLAG"
        }
      ]
    },
    {
      "start": 3055,
      "end": 3055,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3056,
      "end": 3063,
      "name": "lstshf_last_pattern_shift_debounce",
      "description": "LSTSHF (location 654, $28E): stores last SHIFT/CTRL/Logo key pattern to debounce the special SHIFT keys and prevent rapid toggling of character sets during a single press.",
      "references": [
        {
          "chunk": "shflag_shift_ctrl_logo_flag_and_keyboard_tables",
          "topic": "Works together with SHFLAG to select keyboard tables and debounce"
        }
      ]
    },
    {
      "start": 3064,
      "end": 3172,
      "name": "keylog_vector_and_vicword_example",
      "description": "KEYLOG (locations 655-656, $28F-$290): RAM vector pointing to the OS routine that sets up which keyboard matrix lookup table to use based on SHFLAG. Explains that the interrupt-driven key-scan routine jumps through this vector, enabling user-supplied routines to intercept keypresses. Includes an example machine-language 'VICword'/64word program and DATA statements showing how to substitute BASIC keywords for single keystrokes (source code DATA and token tables), plus a mapping table of keys to SHIFT/Commodore substitution (A->PRINT/PRINT#, B->AND/OR, etc).",
      "references": [
        {
          "chunk": "basic_merge_utility_program",
          "topic": "Example programs and machine language patching techniques"
        },
        {
          "chunk": "register_storage_area",
          "topic": "Using storage/vectors to pass control to or from patched routines"
        }
      ]
    },
    {
      "start": 3173,
      "end": 3173,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3174,
      "end": 3189,
      "name": "mode_toggle_character_sets",
      "description": "MODE (location 657, $291): flag enabling/disabling SHIFT+Logo key toggle of character sets. POKE 128 ($80) disables the feature, POKE 0 enables it. Also modifiable via printing CHR$(8)/CTRL-H (disable) or CHR$(9)/CTRL-I (enable). References 53272 ($D018) and 49152 ($C000) for character set control.",
      "references": [
        {
          "chunk": "shflag_shift_ctrl_logo_flag_and_keyboard_tables",
          "topic": "SHFLAG selects tables; MODE controls the SHIFT+Logo set-toggle feature"
        },
        {
          "chunk": "hibase_screen_memory_top_page",
          "topic": "Changing dot-table base address ($D018) also changes character appearance"
        }
      ]
    },
    {
      "start": 3190,
      "end": 3190,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3191,
      "end": 3203,
      "name": "autodn_screen_scrolling_flag",
      "description": "AUTODN (location 658, $292): flag controlling screen autoscroll when cursor moves past 40th column of a logical line. 0 enables scrolling down to add a physical line; nonzero disables it. The OS temporarily disables scrolling if there are characters pending in keyboard buffer.",
      "references": [
        {
          "chunk": "xmax_keyboard_buffer_size",
          "topic": "Keyboard buffer state affects AUTODN behavior"
        }
      ]
    },
    {
      "start": 3204,
      "end": 3224,
      "name": "rs232_pseudo_6551_registers_intro",
      "description": "Introduction to RS-232 pseudo-6551 registers (locations 659-663 / $293-$297). The Commodore 64 emulates the 6551 UART in software; these RAM locations mimic 6551 control/command/status registers. Explains that filenames supplied when OPENing device 2 populate locations 659-662 and that some simulated features (nonstandard baud rates or higher baud rates) are not implemented.",
      "references": [
        {
          "chunk": "m51ctr_rs232_control_register",
          "topic": "Control register defines baud, wordlength and stop bits"
        },
        {
          "chunk": "m51cdr_rs232_command_register",
          "topic": "Command register defines parity, duplex and handshaking"
        }
      ]
    },
    {
      "start": 3225,
      "end": 3276,
      "name": "m51ctr_rs232_control_register",
      "description": "M51CTR (location 659, $293): Mock 6551 control register. Bit definitions: Bit7 stop-bits (0=1 stop,1=0 stop), Bits6-5 word length (00=8bits,01=7bits,10=6bits,11=5bits), Bits3-0 Baud rate selection with mapping for standard rates (e.g., 6=300, 10=2400) and notes on which higher rates are not implemented. First filename character stored here when opening RS-232 (e.g., OPEN 2,2,0,CHR$(6+32) sets this to 38 for 300 baud, 7-data bits, 1 stop).",
      "references": [
        {
          "chunk": "baudoftime_prescaler",
          "topic": "Prescaler values for CIA timers and BAUDOF determine actual bit timing"
        },
        {
          "chunk": "m51cdr_rs232_command_register",
          "topic": "Command register complements control settings for parity/duplex/handshake"
        }
      ]
    },
    {
      "start": 3277,
      "end": 3325,
      "name": "m51cdr_rs232_command_register",
      "description": "M51CDR (location 660, $294): Mock 6551 command register controlling parity type, duplex (bit4: 0=full,1=half), and handshake protocol (bit0: 0=3-line,1=X-line). Bits7-5 specify parity (patterns for none, odd, even, mark, space). The second filename character written when opening RS-232 is stored here to set these fields.",
      "references": [
        {
          "chunk": "m51ctr_rs232_control_register",
          "topic": "M51CTR sets baud/length/stop bits while M51CDR sets parity/duplex/handshakes"
        }
      ]
    },
    {
      "start": 3326,
      "end": 3343,
      "name": "m51ajb_nonstandard_baud_rate_storage",
      "description": "M51AJB (locations 661-662, $295-$296): storage for nonstandard bit timing values (user-defined baud rate) when low nybble of M51CTR is 0. Software emulation is not implemented; Commodore specified format if implemented: store PRESCALER = (system_clock / baud / 2) - 100 in low-byte, high-byte order. System CLOCK: NTSC 1.02273 MHz, PAL 0.98525 MHz.",
      "references": [
        {
          "chunk": "baudoftime_prescaler",
          "topic": "When implemented, these bytes would be used to set BAUDOF prescaler values"
        }
      ]
    },
    {
      "start": 3344,
      "end": 3344,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3345,
      "end": 3375,
      "name": "rsstat_rs232_status_register",
      "description": "RSSTAT (location 663, $297): Mock 6551 status register indicating RS-232 errors and conditions. Reading via ST or Kernal READST clears this location. Bit definitions: Bit7 Break detected, Bit6 DTR missing, Bit4 CTS missing, Bit3 Receiver buffer empty, Bit2 Receiver buffer overrun, Bit1 Framing error, Bit0 Parity error. Describes recommended handling for each error (resend on framing/parity, GET#2 if overrun, inspect data if Break).",
      "references": [
        {
          "chunk": "rs232_pseudo_6551_registers_intro",
          "topic": "RSSTAT is part of the pseudo-6551 register set"
        }
      ]
    },
    {
      "start": 3376,
      "end": 3382,
      "name": "bitnum_rs232_bits_left_counter",
      "description": "BITNUM (location 664, $298): holds number of bits left to be sent/received; used to determine how many zero bits to pad to reach word length specified by M51CTR.",
      "references": [
        {
          "chunk": "m51ctr_rs232_control_register",
          "topic": "BITNUM depends on the word-length configuration in M51CTR"
        }
      ]
    },
    {
      "start": 3383,
      "end": 3404,
      "name": "baudof_prescaler_for_rs232_timing",
      "description": "BAUDOF (locations 665-666, $299-$29A): prescaler value used by CIA #2 timers A/B to time RS-232 bit send/receive. Timers trigger NMI-driven RS-232 routines CLOCK/PRESCALER times per second, where CLOCK is system 02 frequency (NTSC 1,022,730 Hz, PAL 985,250 Hz) and PRESCALER is stored in CIA registers at $DD04-$DD07. Formula: PRESCALER = ((CLOCK / BAUDRATE) / 2) - 100. Tables of preset prescalers for NTSC/PAL stored at $FEC2 and $E4EC respectively.",
      "references": [
        {
          "chunk": "m51ajb_nonstandard_baud_rate_storage",
          "topic": "If nonstandard baud feature implemented it would relate to these prescalers"
        }
      ]
    },
    {
      "start": 3405,
      "end": 3440,
      "name": "rs232_fifo_buffer_indices",
      "description": "Locations 667-670 ($29B-$29E): 4 indices for the two 256-byte FIFO buffers used for RS-232 transmit and receive. Definitions: 667 RIDBE index to end of receive buffer (adds data), 668 RIDBS index to start of receive buffer (removes data), 669 RODBS index to start of transmit buffer (removes data), 670 RODBE index to end of transmit buffer (adds data). Explains dynamic wraparound FIFO behavior.",
      "references": [
        {
          "chunk": "tbuffer_cassette_io_buffer",
          "topic": "Contrast with cassette buffer usage (separate 192-byte buffer)"
        }
      ]
    },
    {
      "start": 3441,
      "end": 3454,
      "name": "irqtmp_save_area_for_cassette_io",
      "description": "IRQTMP (locations 671-672, $29F-$2A0): save area for IRQ vector during cassette (tape) I/O. Cassette read/write routines are IRQ-driven; they save the current IRQ vector here before changing it to their own routine. Notes that keyboard scanning, STOP-key check, and clock update are suspended during tape I/O.",
      "references": [
        {
          "chunk": "cinv_irq_vector",
          "topic": "IRQ vector (CINV) is changed during cassette I/O and saved here"
        }
      ]
    },
    {
      "start": 3455,
      "end": 3464,
      "name": "enabl_rs232_interrupts_enabled_flag",
      "description": "ENABL (location 673, $2A1): holds active NMI interrupt flag byte from CIA #2 Interrupt Control Register ($DD0D). Bit meanings: Bit4 (16) System waiting for receiver edge, Bit1 (2) System receiving data, Bit0 (1) System transmitting data. Used to indicate RS-232 interrupt-driven operation states.",
      "references": [
        {
          "chunk": "rs232_fifo_buffer_indices",
          "topic": "Interacts with transmit/receive buffers and NMI-driven RS-232 handling"
        }
      ]
    },
    {
      "start": 3465,
      "end": 3465,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3466,
      "end": 3474,
      "name": "cassette_cia1_register_save_areas",
      "description": "Locations 674-676 ($2A2-$2A4): save areas used during cassette I/O: indicator of CIA #1 Control Register B activity (674), save area for CIA #1 Interrupt Control Register during cassette read (675), and save area for CIA #1 Control Register A during cassette read (676). These hold CIA register values so they can be restored after tape I/O.",
      "references": [
        {
          "chunk": "irqtmp_save_area_for_cassette_io",
          "topic": "Used together when hooking cassette routines into IRQs"
        }
      ]
    },
    {
      "start": 3475,
      "end": 3495,
      "name": "pal_ntsc_flag_and_scroll_temp_index",
      "description": "Locations 677-678 ($2A5-$2A6): temporary index to next 40-column line for screen scrolling (677) and PAL/NTSC flag (678). PAL/NTSC flag set by test on power-on using raster interrupt on line 311; 0 = NTSC, 1 = PAL. Used for adjusting IRQ timer prescaler so IRQ occurs every 1/60 second for both standards.",
      "references": [
        {
          "chunk": "baudoftime_prescaler",
          "topic": "PAL/NTSC affects system clock and prescaler values for timing"
        }
      ]
    },
    {
      "start": 3496,
      "end": 3506,
      "name": "unused_ram_679_767",
      "description": "RAM area 679-767 ($2A7-$2FF) marked Unused. Recommended for programmers to use for machine language subroutines or graphics data. Notes on suitability for sprite/character data when VIC-II uses bottom 16K (default). Also mentions locations 704-767 suitable for sprite data block #11.",
      "references": [
        {
          "chunk": "sprite_shape_data_pointers",
          "topic": "Free RAM can be used to store sprite shape data referenced by sprite pointers"
        }
      ]
    },
    {
      "start": 3507,
      "end": 3507,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3508,
      "end": 3560,
      "name": "basic_indirect_vector_table_overview",
      "description": "BASIC indirect vector table (locations 768-779 / $300-$30B). Explains purpose of vectored BASIC routines (indirect JMP via RAM pointers) for compatibility and ease of hooking into BASIC. Discusses how the table is initialized to point to ROM addresses and how users can change vectors to add preprocessing and new commands. Describes general benefits of vectored routines and mentions example vector at 768 ($300) used by error handler.",
      "references": [
        {
          "chunk": "basic_vectors_768_779_entries",
          "topic": "Specific vectors (IERROR, IMAIN, ICRNCH, IQPLOP, etc.) are listed in the following entries"
        }
      ]
    },
    {
      "start": 3561,
      "end": 3561,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3562,
      "end": 3601,
      "name": "basic_vectors_768_779_entries",
      "description": "Entries for BASIC indirect vectors 768-779 ($300-$30B): IERROR (768-769) -> ERROR routine, IMAIN (770-771) -> main BASIC loop, ICRNCH (772-773) -> tokenizing/CRUNCH routine, IQPLOP (774-775) -> listing tokens (QPLOP), IGONE (776-777) -> execute next token (GONE), IEVAL (778-779) -> evaluate single-term arithmetic expression (EVAL). Each entry lists the ROM addresses vectored to and explains the role they play in BASIC input/tokenization/execution.",
      "references": [
        {
          "chunk": "basic_indirect_vector_table_overview",
          "topic": "Overview of why these vectors exist and how to modify them"
        },
        {
          "chunk": "qp_lop_and_crunch_handlers",
          "topic": "Related routines for token conversion and tokenizing (QPLOP, CRUNCH)"
        }
      ]
    },
    {
      "start": 3602,
      "end": 3602,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3603,
      "end": 3645,
      "name": "register_storage_area_for_sys_and_usr",
      "description": "Register storage area (locations 780-783 / $30C-$30F) used by the BASIC SYS command to preserve and restore 6510 internal registers (.A, .X, .Y, .P). Describes how POKEing these addresses before SYS sets registers for the machine language routine and how values are saved back after RTS. Shows usage example for calling Kernal PLOT (SYS 65520) by setting POKE 781,10; POKE 782,5; POKE 783,0:SYS 65520:PRINT \"HELLO\". Explains safety considerations regarding status flags (Interrupt disable) and how to clear/set them.",
      "references": [
        {
          "chunk": "usrpoke_usradd_and_usr_usage",
          "topic": "Related to USR and passing parameters to/from ML routines"
        }
      ]
    },
    {
      "start": 3646,
      "end": 3646,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3647,
      "end": 3680,
      "name": "sareg_sxreg_syreg_spreg_and_status_bits",
      "description": "Detailed definitions of SAREG (780 $30C), SXREG (781 $30D), SYREG (782 $30E), SPREG (783 $30F) being storage areas for .A, .X, .Y, and .P registers respectively. Lists the seven status bits mapping for .P: Negative(128), Overflow(64), unused(32), BREAK(16), Decimal(8), Interrupt Disable(4), Zero(2), Carry(1). Advises using POKE 783,0 to clear all flags before SYS but warns about clearing Interrupt Disable.",
      "references": [
        {
          "chunk": "register_storage_area_for_sys_and_usr",
          "topic": "Examples of using these storage locations before SYS calls"
        }
      ]
    },
    {
      "start": 3681,
      "end": 3734,
      "name": "usrpok_usradd_and_using_usr_calls",
      "description": "USRPOK (784 $310) = $4C (JMP) first byte for USR command; USRADD (785-786 $311-$312) contains the low/high bytes of address targeted by USR. These defaults point to BASIC error routine until set by user. Describes how USR allows passing numeric parameter to ML routine (X=USR(50) places 50 in FAC1), returning value via FAC1. Advises using vectored conversion routines (vectors at 3-6) to convert to/from floating point and signed integers. Includes formulas for computing high/low bytes for USRADD vector.",
      "references": [
        {
          "chunk": "register_storage_area_for_sys_and_usr",
          "topic": "SYS uses register storage; USR uses FAC1 for parameter passing"
        }
      ]
    },
    {
      "start": 3735,
      "end": 3736,
      "ignore": true,
      "reason": "Single-line note marking an unused byte (location 787) \u2014 not a technical section to index"
    },
    {
      "start": 3737,
      "end": 3737,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3738,
      "end": 3783,
      "name": "cinv_irq_vector_and_irq_handling",
      "description": "CINV (locations 788-789, $314-$315): vector to IRQ interrupt routine (default ~ $FA31). Describes that CIA #1 Timer B causes IRQ every 1/60 second, and this vector points to routine that updates software clock, stop-key check, cursor blink, tape interlock, and keyboard scanning. Advises precautions for users replacing IRQ routine (disable IRQs before changing vector, preserve registers and stack, determine IRQ source when multiple sources enabled), and recommends saving old vector for safe call-through.",
      "references": [
        {
          "chunk": "irqtmp_save_area_for_cassette_io",
          "topic": "Cassette I/O saves/restores IRQ vector here before changing it"
        }
      ]
    },
    {
      "start": 3784,
      "end": 3799,
      "name": "cbinv_brk_instruction_vector",
      "description": "CBINV (locations 790-791, $316-$317): vector for BRK instruction interrupt. Default points to a routine that calls Kernal initialization routines (RESTOR, IOINIT, part of CINT) and then jumps through BASIC warm start vector. Commonly changed by ML monitors to allow breakpoints to return to monitor for debugging.",
      "references": [
        {
          "chunk": "warm_start_and_brk_behavior",
          "topic": "Warm start vector and BRK/STOP/RESTORE behavior"
        }
      ]
    },
    {
      "start": 3800,
      "end": 3834,
      "name": "nminv_non_maskable_interrupt_vector",
      "description": "NMINV (locations 792-793, $318-$319): vector for Non-Maskable Interrupt (NMI). Sources: RESTORE key (direct to 6510 NMI) and CIA #2 interrupts. Describes default behavior: check cause (CIA #2 for RS-232, RESTORE for cartridge warm start or STOP/RESTORE sequence), potential to disable STOP/RESTORE by pointing vector to RTI (POKE 792,193), and notes side-effects (disables all NMIs including RS-232 I/O).",
      "references": [
        {
          "chunk": "m51cdr_rs232_command_register",
          "topic": "CIA #2 NMIs used for RS-232 handling"
        }
      ]
    },
    {
      "start": 3835,
      "end": 3835,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3836,
      "end": 3861,
      "name": "kernal_indirect_vectors_overview",
      "description": "Overview of Kernal indirect vectors (locations 794-813 / $31A-$32D): 39 Kernal routines have jump-table entries in ROM which indirect via these RAM vectors for 10 routines; their RAM addresses are initialized to ROM addresses but can be changed to add/replace Kernal routines. Warns about changing interrupt-driven vectors without disabling interrupts and points to Kernal VECTOR routine ($FD1A) for safe modifications. Mentions these routines mainly handle I/O and device support.",
      "references": [
        {
          "chunk": "kernal_vectors_794_819_entries",
          "topic": "Specific Kernal vector entries and their current ROM targets"
        }
      ]
    },
    {
      "start": 3862,
      "end": 3918,
      "name": "kernal_vectors_794_819_entries",
      "description": "Kernal vector entries (794-819 / $31A-$333) and short descriptions: IOPEN (794) OPEN, ICLOSE (796) CLOSE, ICHKIN (798) CHKIN, ICKOUT (800) CKOUT, ICLRCH (802) CLRCHN, IBASIN (804) CHRIN, IBSOUT (806) CHROUT, ISTOP (808) STOP (with notes on disabling STOP via POKE 808,239 etc), IGETIN (810) GETIN, ICLALL (812) CLALL, USRCMD (814) user-defined command vector (historical PET holdover), ILOAD (816) LOAD, ISAVE (818) SAVE. Each entry points to a Kernal routine address and can be modified.",
      "references": [
        {
          "chunk": "kernal_indirect_vectors_overview",
          "topic": "How and why these vectors can be changed"
        },
        {
          "chunk": "tbuffer_cassette_io_buffer",
          "topic": "Kernal I/O vectors used when accessing cassette device which uses TBUFFER"
        }
      ]
    },
    {
      "start": 3919,
      "end": 3923,
      "name": "unused_kernal_vectors_820_827",
      "description": "Locations 820-827 ($334-$33B): eight unused bytes in the Kernal vector area reserved for user vectors or other data.",
      "references": [
        {
          "chunk": "unused_ram_679_767",
          "topic": "Additional regions of free RAM are available for custom use"
        }
      ]
    },
    {
      "start": 3924,
      "end": 3976,
      "name": "tbuffer_cassette_io_buffer",
      "description": "TBUFFER (locations 828-1019 / $33C-$3FB): 192-byte cassette I/O buffer used for reading/writing tape device (device 1). Describes block structure stored here: block type identifier byte, header blocks (relocatable or nonrelocatable program headers), data header blocks for file I/O, and data storage blocks. Notes on how relocatable vs nonrelocatable files behave, and which bytes are used for buffering vs direct RAM transfer. Also notes that when unused it is commonly used by programmers for short ML routines or VIC-II graphics blocks.",
      "references": [
        {
          "chunk": "rs232_fifo_buffer_indices",
          "topic": "Contrast between cassette buffering (TBUFFER) and RS-232 FIFO buffers"
        }
      ]
    },
    {
      "start": 3977,
      "end": 3992,
      "name": "unused_1020_1023",
      "description": "Locations 1020-1023 ($3FC-$3FF): four unused bytes available to programs.",
      "references": [
        {
          "chunk": "unused_kernal_vectors_820_827",
          "topic": "Other areas of unused RAM available for user storage"
        }
      ]
    },
    {
      "start": 3993,
      "end": 4001,
      "name": "chapter_4_header",
      "description": "Chapter 4 header marking section '1K to 40K' \u2014 introduces the discussion of Screen Memory, Sprite Pointers, and BASIC Program Text. Formatting/artistic header lines.",
      "ignore": true,
      "reason": "Non-technical chapter header / decorative text"
    },
    {
      "start": 4002,
      "end": 4002,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4003,
      "end": 4056,
      "name": "vicscn_video_screen_memory_area",
      "description": "VICSCN (locations 1024-2047 / $400-$7FF): default video screen memory area (25 lines x 40 columns video matrix and sprite data pointers). Describes that the VIC-II memory bank select and VIC-II control register (53272 $D018, CIA #2 $DD00) determine the current location; explains how screen RAM stores screen codes and how PRINT/POKE to this area will display characters, with caveat about color RAM needing to be set (color RAM at 55296 $D800). Includes examples showing POKE to display characters and outlines how to initialize color RAM by changing background color before clearing the screen.",
      "references": [
        {
          "chunk": "hibase_screen_memory_top_page",
          "topic": "HIBASE contains top page number for screen memory used by OS print routines"
        },
        {
          "chunk": "sprite_shape_data_pointers",
          "topic": "Last bytes of the video matrix are used as sprite data pointers"
        }
      ]
    },
    {
      "start": 4057,
      "end": 4057,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4058,
      "end": 4082,
      "name": "sprite_shape_data_pointers",
      "description": "Locations 2040-2047 ($7F8-$7FF): the 8 bytes at the end of the video matrix point to sprite shape data blocks. Each sprite shape uses 64 bytes (63 used for 24x21 bitmap, rounded to block), and the pointer value times 64 gives the starting address of the sprite shape data block. Example: value 11 at 2040 => sprite 0 shape starts at address 704 (11*64).",
      "references": [
        {
          "chunk": "vicscn_video_screen_memory_area",
          "topic": "Sprite pointers are part of the video screen memory region"
        },
        {
          "chunk": "hibase_screen_memory_top_page",
          "topic": "Relocating screen memory affects the location of these sprite pointers"
        }
      ]
    },
    {
      "start": 4083,
      "end": 4105,
      "name": "basic_program_text_area",
      "description": "BASIC program text memory area (locations 2048-40959 / $800-$9FFF): stores tokenized BASIC program lines as linked records (next-line pointer low/high, two-byte line number low/high, tokenized program commands, terminated by 0). Describes tokenization (keywords stored as single bytes >=128), and layout of BASIC memory: program text, non-array variables and string descriptors, array variables, free area (FRE(0)), string text area (grows down), BASIC ROM. Notes that NEW does not zero text but replaces first link pointer with zeros allowing program recovery.",
      "references": [
        {
          "chunk": "basic_indirect_vector_table_overview",
          "topic": "BASIC uses many vectored routines for token handling and execution"
        }
      ]
    },
    {
      "start": 4106,
      "end": 4149,
      "name": "character_rom_image_vic_bank0",
      "description": "Character ROM image seen by VIC-II when using memory bank 0 (locations 4096-8191 / $1000-$1FFF). Describes that VIC-II can see character ROM here while CPU sees RAM; explains that VIC-II banking (bank 0 default) can make RAM at these addresses inaccessible to CPU for character data and sprite blocks 64-127. Notes implications for bitmap mode and character shape sourcing.",
      "references": [
        {
          "chunk": "character_rom_bank2_image",
          "topic": "Character ROM image also appears in bank 2 when VIC-II uses that bank"
        }
      ]
    },
    {
      "start": 4150,
      "end": 4170,
      "name": "autostart_rom_cartridge",
      "description": "Autostart ROM Cartridge area at 32768 ($8000): 8K or 16K cartridges can be plugged into expansion port and autostart if cartridge ROM contains PETASCII 'CBM80' signature ( bytes $C3,$C2,$CD,$38,$30 ) at locations 32772-32776 ($8004-$8008). Cartridge can be located at other banks (e.g., $A000 or $F000 to replace BASIC or Kernal). Discusses banked cartridges and possibility for bank switching.",
      "references": [
        {
          "chunk": "character_rom_image_vic_bank0",
          "topic": "Cartridge locations and VIC-II/CPU memory banking"
        }
      ]
    },
    {
      "start": 4171,
      "end": 4171,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4172,
      "end": 4193,
      "name": "character_rom_image_vic_bank2",
      "description": "Character ROM image for VIC-II when using memory bank 2 (locations 36864-40959 / $9000-$9FFF). VIC-II can access character generator ROM at different banks (0 or 2) but when using other banks, character shapes must be supplied in RAM by the user.",
      "references": [
        {
          "chunk": "character_rom_image_vic_bank0",
          "topic": "Both bank 0 and bank 2 present the character ROM to VIC-II"
        }
      ]
    },
    {
      "start": 4194,
      "end": 4194,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4195,
      "end": 4247,
      "name": "basic_rom_and_beginnings_of_basic_routines",
      "description": "Intro to BASIC ROM (locations 40960-49152 / $A000-$BFFF): BASIC V2 overview, heritage from PET/VIC, limitations and compatibility notes. Discusses that the ROM contains many routines; lists disassembly labels akin to Jim Butterfield's PET maps; recommends using vectored entry points rather than hardcoding ROM addresses. Also notes that BASIC can be bank-switched out so VIC-II can use RAM underneath (see $DD00). Provides context for subsequent listings of dispatch tables and routine addresses.",
      "references": [
        {
          "chunk": "statement_dispatch_table_and_tables",
          "topic": "Following sections list STMDSP, FUNDSP, OPTAB and other dispatch tables used by BASIC"
        }
      ]
    },
    {
      "start": 4248,
      "end": 4266,
      "name": "cold_start_vector",
      "description": "Cold Start Vector (locations 40960-40961 / $A000-$A001): points to BASIC initialization routine invoked after OS power-on init; prints the welcome message and BYTES FREE. References ROM entry at 58260 ($E394) for details of initialization.",
      "references": [
        {
          "chunk": "warm_start_and_brk_behavior",
          "topic": "Warm start (STOP/RESTORE) uses a different vector; BRK ties to similar behavior"
        }
      ]
    },
    {
      "start": 4267,
      "end": 4340,
      "name": "warm_start_vector_and_statement_dispatch_table",
      "description": "Warm Start Vector (40962-40963 / $A002-$A003): entry used to reset BASIC after STOP/RESTORE; does not disturb program. Followed by STMDSP (Statement Dispatch Vector Table, $A00C-$A051) which contains two-byte vectors pointing to routines performing each BASIC statement in token order. Reproduces the statement token->routine address mapping for tokens 128..162 (e.g., END 43057, FOR 42818, NEXT 44318, DATA 43256, INPUT# 43941, PRINT 43680, etc.).",
      "references": [
        {
          "chunk": "fndfor_and_crunch_qplop",
          "topic": "Related BASIC routines that interact with STMDSP during parsing/execution"
        }
      ]
    },
    {
      "start": 4341,
      "end": 4384,
      "name": "fundsp_function_dispatch_table",
      "description": "FUNDSP (41042-41087 / $A052-$A07F): Function dispatch vector table mapping BASIC functions (tokens 180..202) to ROM routine addresses that evaluate functions (SGN, INT, ABS, USR, FRE, POS, SQR, RND, LOG, EXP, COS, SIN, TAN, ATN, PEEK, LEN, STR$, VAL, ASC, CHR$, LEFT$, RIGHT$, MID$). Lists addresses for each function routine (e.g., SGN 48185, INT 48332, USR 784, FRE 45949, etc.).",
      "references": [
        {
          "chunk": "optab_operator_dispatch_table",
          "topic": "Functions interact with operator evaluation routines in OPTAB"
        }
      ]
    },
    {
      "start": 4385,
      "end": 4424,
      "name": "optab_operator_dispatch_table",
      "description": "OPTAB (41088-41117 / $A080-$A09D): Operator dispatch vector table mapping operator tokens (170..179) to routines that implement BASIC math operations and precedence. Lists operator token -> routine address mapping (ADD 47210, SUB 47187, MULT 47659, DIV 47890, EXP 49019, AND 45033, OR 45030, > 49076, = 44756, < 45078) and describes operator precedence rules used by BASIC expression evaluator.",
      "references": [
        {
          "chunk": "frmeval_evaluate_expression",
          "topic": "OPTAB used by FRMEVAL/EVAL routines to compute expressions"
        }
      ]
    },
    {
      "start": 4425,
      "end": 4425,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4426,
      "end": 4468,
      "name": "reslst_keyword_list_and_tokenization",
      "description": "RESLST (41118-41373 / $A09E-$A19D): list of BASIC reserved keywords in token order (tokens 128..202). Describes storage format (ASCII with bit7 set on last letter to mark end) and role in tokenizing input and LISTing programs. Also enumerates some miscellaneous keywords and their token numbers (TAB(, TO, FN, SPC(, THEN, NOT, STEP).",
      "references": [
        {
          "chunk": "crunch_tokenize_line",
          "topic": "CRUNCH routine consults this keyword table when tokenizing input lines"
        }
      ]
    },
    {
      "start": 4469,
      "end": 4528,
      "name": "errtab_error_messages_and_vectors",
      "description": "ERRTAB and related error message structures (41374-41828 / $A19E-$A364): ASCII text of BASIC error messages and Error Message Vector Table with pointers to starts of messages. Lists common BASIC error messages (TOO MANY FILES, FILE OPEN, SYNTAX, NEXT WITHOUT FOR, etc.) and references miscellaneous messages (cursor/READY/BREAK).",
      "references": [
        {
          "chunk": "error_and_omerr_handlers",
          "topic": "ERROR and OMERR routines use these tables to display messages"
        }
      ]
    },
    {
      "start": 4529,
      "end": 4574,
      "name": "stack_and_error_memory_routines",
      "description": "FNDFOR (find FOR entries on the BASIC stack), BLTU (open space in memory for new program line or variable), GETSTK (check for stack space), REASON (check for free memory and trigger garbage collection), OMERR (OUT OF MEMORY handler), and ERROR (general error handler vectored through RAM). Covers behavior, when each is used, and interaction with garbage collection and error messaging.",
      "references": [
        {
          "chunk": "basic_input_processing_and_program_storage",
          "topic": "main loop and READY handling, adding/replacing program lines"
        },
        {
          "chunk": "string_allocation_and_manipulation",
          "topic": "REASON/garbage collection interaction with string allocation"
        }
      ]
    },
    {
      "start": 4575,
      "end": 4581,
      "name": "ready_prompt",
      "description": "READY kernel routine: prints the word READY, sets the Kernal message flag to indicate direct mode is active, and falls through to the main BASIC loop.",
      "references": [
        {
          "chunk": "main_loop",
          "topic": "main BASIC loop that READY falls through to"
        }
      ]
    },
    {
      "start": 4582,
      "end": 4592,
      "name": "main_loop",
      "description": "MAIN: the main BASIC program loop (addresses $A480-$A49B). It vectored through RAM at $302, receives a line of input, checks for a line number, and either branches to store the line in the program or to execute statements immediately.",
      "references": [
        {
          "chunk": "ready_prompt",
          "topic": "READY prints and then falls through here"
        },
        {
          "chunk": "main1_add_replace_line",
          "topic": "subroutine for adding/replacing a program line when a line number is present"
        },
        {
          "chunk": "inlin_input_line",
          "topic": "routine used to get a line of input"
        }
      ]
    },
    {
      "start": 4593,
      "end": 4603,
      "name": "main1_add_replace_line",
      "description": "MAIN1: add or replace a line of program text. Calls subroutines to get the line number and tokenize keywords, searches for an existing line with the same number, deletes it by moving program text and variables downward, and then inserts the new tokenized line. Calls CLR which clears current program variables.",
      "references": [
        {
          "chunk": "crunch_tokenize",
          "topic": "tokenizes keywords in the input line before storage"
        },
        {
          "chunk": "findln_search_line_number",
          "topic": "searches for an existing line number to replace"
        },
        {
          "chunk": "clear_clr",
          "topic": "CLR is invoked, affecting variables"
        }
      ]
    },
    {
      "start": 4604,
      "end": 4611,
      "name": "linkprg_relink_tokenized_lines",
      "description": "LINKPRG: relinks lines of tokenized program text. Each program line contains a two-byte pointer to the next line; this routine scans to the end-of-line marker (0) and updates each line's link address by adding an offset to the current statement address.",
      "references": [
        {
          "chunk": "main1_add_replace_line",
          "topic": "used after inserting/moving lines so link pointers remain correct"
        }
      ]
    },
    {
      "start": 4612,
      "end": 4622,
      "name": "inlin_input_line",
      "description": "INLIN: input a line to the BASIC text buffer from the current input device (usually the keyboard). Uses the Kernal CHRIN routine to read characters into the text input buffer at $200 (512) until carriage return or 89 characters; an error occurs if the line exceeds 80 characters (keyboard normally limited to 80).",
      "references": [
        {
          "chunk": "main_loop",
          "topic": "MAIN calls this to obtain user input"
        },
        {
          "chunk": "crunch_tokenize",
          "topic": "CRUNCH processes the line placed in the input buffer by INLIN"
        }
      ]
    },
    {
      "start": 4623,
      "end": 4631,
      "name": "crunch_tokenize",
      "description": "CRUNCH: tokenizes a program line stored in the BASIC input buffer at $200. Scans the line and replaces keywords and valid abbreviations (outside quotes) with their one-byte token equivalents. This routine is vectored through RAM at $304 so new commands can be added by diverting the vector.",
      "references": [
        {
          "chunk": "inlin_input_line",
          "topic": "operates on lines placed into the input buffer by INLIN"
        },
        {
          "chunk": "linkprg_relink_tokenized_lines",
          "topic": "after CRUNCH and insertion, LINKPRG updates link addresses"
        }
      ]
    },
    {
      "start": 4632,
      "end": 4640,
      "name": "findln_search_line_number",
      "description": "FINDLN: searches program text for a two-byte integer line number (stored in bytes $14-$15). If found, sets pointers (bytes $5F-$60) to the link field address of the matching line and sets the Carry flag; if not found, clears the Carry flag.",
      "references": [
        {
          "chunk": "main1_add_replace_line",
          "topic": "used by MAIN1 to detect and locate an existing line to delete/replace"
        },
        {
          "chunk": "linkprg_relink_tokenized_lines",
          "topic": "after deletion/insertion, link pointers may need recalculation"
        }
      ]
    },
    {
      "start": 4641,
      "end": 4648,
      "name": "scrtch_new",
      "description": "SCRTCH (NEW): implements the NEW command by storing two zeros in the link address of the first program line to mark end-of-program and setting the end-of-program pointer ($2D-$2E) to the byte past those zeros. Execution continues into CLR to complete clearing operations.",
      "references": [
        {
          "chunk": "clear_clr",
          "topic": "NEW continues into CLR to finish clearing program state"
        }
      ]
    },
    {
      "start": 4649,
      "end": 4662,
      "name": "clear_clr",
      "description": "CLEAR (CLR): performs CLR operations. Closes all I/O files via the Kernal CLALL routine, removes string variables by copying end-of-memory pointer ($37-$38) to the bottom-of-strings pointer ($33-$34), and resets pointers for nonarray and array variables (copies end-of-program pointer $31-$32 to $2D-$2E and $2F-$30). RESTORE is called to set the DATA pointer to the start, and the stack is cleared. Note: variable storage areas are made unusable but not overwritten.",
      "references": [
        {
          "chunk": "scrtch_new",
          "topic": "SCRTCH (NEW) flows into CLR to complete clearing"
        },
        {
          "chunk": "runc_reset_text_pointer",
          "topic": "after CLEAR, text pointer may be reset before running"
        }
      ]
    },
    {
      "start": 4663,
      "end": 4670,
      "name": "runc_reset_text_pointer",
      "description": "RUNC: resets the CHRGET text pointer (TXTPTR, bytes $7A-$7B) so the next byte the interpreter reads comes from the beginning of program text. Prepares the interpreter to read program statements from start.",
      "references": [
        {
          "chunk": "list_listing_and_token_printing",
          "topic": "LIST and execution routines also rely on TXTPTR positioning"
        }
      ]
    },
    {
      "start": 4671,
      "end": 4677,
      "name": "list_listing_and_token_printing",
      "description": "LIST: performs the LIST command by saving the range of lines to be printed in pointers ($5F-$60 and $14-$15) and printing the program lines, translating one-byte tokens back to ASCII text.",
      "references": [
        {
          "chunk": "qplop_token_to_ascii",
          "topic": "QPLOP handles the conversion of tokens back to ASCII for LIST"
        }
      ]
    },
    {
      "start": 4678,
      "end": 4686,
      "name": "qplop_token_to_ascii",
      "description": "QPLOP: subroutine used by LIST to convert one-byte program tokens back to their ASCII text representations. Vectored through RAM at $306 so newly added commands can be listed by detouring this vector.",
      "references": [
        {
          "chunk": "list_listing_and_token_printing",
          "topic": "QPLOP is the token-to-ASCII component of LIST"
        }
      ]
    },
    {
      "start": 4687,
      "end": 4705,
      "name": "for_loop_behavior",
      "description": "FOR implementation details: FOR pushes information for the matching NEXT onto the stack, including the TO termination value (evaluated once when FOR executes). This means the TO expression's value is fixed for that loop iteration, preventing early termination by decreasing the TO variable (but allowing early end by increasing the FOR variable). FOR variables must be non-array floating point variables. Reusing a FOR variable while its loop is still active cancels that FOR and all intervening loops. See the interpreter's stack area (at $100) for NEXT/FOR stack layout.",
      "references": [
        {
          "chunk": "main_loop",
          "topic": "FOR is one of the statements executed when no line number is present"
        },
        {
          "chunk": "runc_reset_text_pointer",
          "topic": "execution uses the program text pointer set by RUNC"
        }
      ]
    },
    {
      "start": 4706,
      "end": 4712,
      "name": "newstt_set_up_next_statement",
      "description": "NEWSTT ($A7AE) \u2014 Tests for the STOP key, updates the pointer to the current line number, and positions the text pointer to read the beginning of the next BASIC statement.",
      "references": [
        {
          "chunk": "stop_key_break_test",
          "topic": "STOP key checking and break handling"
        },
        {
          "chunk": "gone_read_execute_next_statement",
          "topic": "statement dispatch after NEWSTT positions text pointer"
        }
      ]
    },
    {
      "start": 4713,
      "end": 4727,
      "name": "gone_read_execute_next_statement",
      "description": "GONE ($A7E4) \u2014 Read and execute the next statement. Describes statement token fetching, vectoring through RAM at $308, placing execution address on the stack so CHRGET returns into the statement handler, and handling invalid tokens or implied LET when ASCII < 128.",
      "references": [
        {
          "chunk": "newstt_set_up_next_statement",
          "topic": "preparation of text pointer for statement execution"
        },
        {
          "chunk": "let_statement_variable_assignment",
          "topic": "implied LET execution when no token present"
        }
      ]
    },
    {
      "start": 4728,
      "end": 4733,
      "name": "restor_restore_data_pointer",
      "description": "RESTOR ($A81D) \u2014 Perform RESTORE: resets the DATA pointer (locations $41-$42) to the start-of-BASIC pointer (locations $2B-$2C) so subsequent READs begin from program start.",
      "references": [
        {
          "chunk": "read_statement",
          "topic": "READ uses the DATA pointer that RESTORE resets"
        }
      ]
    },
    {
      "start": 4734,
      "end": 4739,
      "name": "stop_key_break_test",
      "description": "Test STOP Key for Break in Program ($A82C) \u2014 Calls the Kernal STOP routine; if the STOP key is pressed, the STOP (Kernal command at $F6ED) processing is invoked to break program execution.",
      "references": [
        {
          "chunk": "newstt_set_up_next_statement",
          "topic": "NEWSTT checks for the STOP key before advancing"
        },
        {
          "chunk": "end_statement_behavior",
          "topic": "END prints BREAK message if a STOP break occurred"
        }
      ]
    },
    {
      "start": 4740,
      "end": 4746,
      "name": "end_statement_behavior",
      "description": "END ($A831) \u2014 Perform END: preserves current line/text pointers for possible CONT, prints READY prompt, and prints a BREAK message first if the STOP key caused a break.",
      "references": [
        {
          "chunk": "cont_continue_statement",
          "topic": "CONT restores pointers saved by END"
        },
        {
          "chunk": "stop_key_break_test",
          "topic": "END prints the BREAK message when STOP caused break"
        }
      ]
    },
    {
      "start": 4747,
      "end": 4754,
      "name": "cont_continue_statement",
      "description": "CONT ($A857) \u2014 Perform CONT: restores the saved pointers to resume execution. If saved pointers are unavailable, prints CAN'T CONTINUE error.",
      "references": [
        {
          "chunk": "end_statement_behavior",
          "topic": "END saves pointers that CONT attempts to restore"
        }
      ]
    },
    {
      "start": 4755,
      "end": 4761,
      "name": "run_statement",
      "description": "RUN ($A871) \u2014 Perform RUN: calls the Kernal SETMSG to set the RUN message flag, performs a CLR to start execution. If a line number follows RUN, a GOTO to that line is performed after CLR.",
      "references": [
        {
          "chunk": "goto_statement",
          "topic": "RUN may perform a GOTO to a line after clearing"
        }
      ]
    },
    {
      "start": 4762,
      "end": 4769,
      "name": "gosub_statement",
      "description": "GOSUB ($A883) \u2014 Perform GOSUB: pushes the current text-character and current-line pointers and a block-type identifier (141, $8D) onto the stack to mark a GOSUB return point, then invokes GOTO to jump to the subroutine line.",
      "references": [
        {
          "chunk": "return_statement",
          "topic": "RETURN finds and uses the GOSUB data saved on the stack"
        },
        {
          "chunk": "goto_statement",
          "topic": "GOSUB uses the GOTO mechanism to jump to the subroutine"
        }
      ]
    },
    {
      "start": 4770,
      "end": 4778,
      "name": "goto_statement",
      "description": "GOTO ($A8A0) \u2014 Perform GOTO: scans the tokenized BASIC program to locate the target line number (starting at the current line if target is higher, otherwise from first line), and updates current statement/text pointers so execution continues at the target statement.",
      "references": [
        {
          "chunk": "linget_parse_line_number",
          "topic": "line number parsing used by GOTO and other statements"
        },
        {
          "chunk": "gosub_statement",
          "topic": "GOSUB calls GOTO to jump to a subroutine line"
        }
      ]
    },
    {
      "start": 4779,
      "end": 4786,
      "name": "return_statement",
      "description": "RETURN ($A8D2) \u2014 Perform RETURN: locates the GOSUB-saved block on the stack, restores the saved pointers to current line and character, and resumes execution where the GOSUB left off.",
      "references": [
        {
          "chunk": "gosub_statement",
          "topic": "GOSUB pushes the return block that RETURN retrieves"
        }
      ]
    },
    {
      "start": 4787,
      "end": 4794,
      "name": "data_statement",
      "description": "DATA ($A8F8) \u2014 Perform DATA: uses a helper routine to find the offset to the next statement and adds it to the current pointers, effectively skipping the DATA statement (similar to REM).",
      "references": [
        {
          "chunk": "datan_find_statement_end",
          "topic": "DATAN searches program text for end-of-statement delimiters"
        },
        {
          "chunk": "read_statement",
          "topic": "READ consumes DATA items that DATA lays out"
        }
      ]
    },
    {
      "start": 4795,
      "end": 4801,
      "name": "datan_find_statement_end",
      "description": "DATAN ($A906) \u2014 Search program text for the end of the current BASIC statement: starts at the current byte and searches until it finds a zero (line delimiter) or a colon not in quotes (statement delimiter).",
      "references": [
        {
          "chunk": "data_statement",
          "topic": "DATAN used by DATA to find the next statement offset"
        },
        {
          "chunk": "rem_statement",
          "topic": "REM also skips to the next statement delimiter"
        }
      ]
    },
    {
      "start": 4802,
      "end": 4809,
      "name": "if_statement",
      "description": "IF ($A928) \u2014 Perform IF: uses FRMEVAL to evaluate the following expression to a single term; if result is 0 (false) execution falls through to REM (i.e., skip), otherwise executes GOTO or the statement after THEN.",
      "references": [
        {
          "chunk": "frmeval_expression_evaluation",
          "topic": "FRMEVAL reduces the IF expression to a single term"
        },
        {
          "chunk": "rem_statement",
          "topic": "IF falls through to REM when false"
        }
      ]
    },
    {
      "start": 4810,
      "end": 4816,
      "name": "rem_statement",
      "description": "REM ($A93B) \u2014 Perform REM: skips all program text until the beginning of the next statement. REM is implemented as part of the IF handling and extends a few bytes beyond the REM token.",
      "references": [
        {
          "chunk": "if_statement",
          "topic": "REM is integrated into IF handling"
        },
        {
          "chunk": "datan_find_statement_end",
          "topic": "DATAN-like scanning logic for skipping to next statement"
        }
      ]
    },
    {
      "start": 4817,
      "end": 4827,
      "name": "on_goto_on_gosub_statement",
      "description": "ONGOTO ($A94B) \u2014 Perform ON GOTO / ON GOSUB: evaluates the selector to an integer, then decrements it while skipping comma-separated targets until it reaches the chosen item; executes GOTO or GOSUB for that item. If targets run out before the selector reaches zero, the statement does nothing.",
      "references": [
        {
          "chunk": "linget_parse_line_number",
          "topic": "line-number parsing for ON ... GOTO/GOSUB targets"
        },
        {
          "chunk": "gosub_statement",
          "topic": "ON GOSUB executes a GOSUB target"
        }
      ]
    },
    {
      "start": 4828,
      "end": 4835,
      "name": "linget_parse_line_number",
      "description": "LINGET ($A96B) \u2014 Convert an ASCII decimal number to a two-byte binary line number: parses a decimal ASCII number, produces a low-byte/high-byte two-byte integer, and checks that it lies within the valid 0\u201363999 BASIC line range.",
      "references": [
        {
          "chunk": "goto_statement",
          "topic": "GOTO uses LINGET to parse target line numbers"
        },
        {
          "chunk": "on_goto_on_gosub_statement",
          "topic": "ON GOTO/GOSUB uses LINGET for line numbers"
        }
      ]
    },
    {
      "start": 4836,
      "end": 4846,
      "name": "let_statement_variable_assignment",
      "description": "LET ($A9A5) \u2014 Perform LET: handles creation and assignment for all variable types (strings, floating point, integers, ST, TI, TI$), including array and scalar variables. Composed of subroutines to evaluate variable LHS, evaluate RHS expression, type-check suitability, and assign or create variables.",
      "references": [
        {
          "chunk": "frmeval_expression_evaluation",
          "topic": "LET uses expression evaluation for the RHS"
        },
        {
          "chunk": "frmnum_numeric_evaluation_and_type_check",
          "topic": "type checking for numeric vs string assignments"
        }
      ]
    },
    {
      "start": 4847,
      "end": 4852,
      "name": "print_hash_print_channel",
      "description": "PRINT# (PRINTN, $AA80) \u2014 Perform PRINT#: calls CMD to send text to a device and then closes the output channel using the Kernal CLRCHN routine ($F333).",
      "references": [
        {
          "chunk": "cmd_statement_output_channel",
          "topic": "PRINT# calls CMD to perform the output"
        },
        {
          "chunk": "print_statement",
          "topic": "PRINT variants and formatting rules"
        }
      ]
    },
    {
      "start": 4853,
      "end": 4860,
      "name": "cmd_statement_output_channel",
      "description": "CMD ($AA86) \u2014 Perform CMD: calls the Kernal CHKOUT routine to set the output channel and then calls PRINT to send included text. Unlike PRINT#, CMD leaves the output channel open for subsequent output.",
      "references": [
        {
          "chunk": "print_hash_print_channel",
          "topic": "PRINT# uses CMD and then closes the channel"
        },
        {
          "chunk": "print_statement",
          "topic": "CMD delegates text handling to PRINT"
        }
      ]
    },
    {
      "start": 4861,
      "end": 4869,
      "name": "print_statement",
      "description": "PRINT ($AAA0) \u2014 Perform PRINT: the main output routine with segments handling TAB, SPC, comma, semicolon, variables, PI, ST, TI, TI$. All output is eventually converted to strings and emitted character-by-character via the Kernal CHROUT routine.",
      "references": [
        {
          "chunk": "strout_string_output",
          "topic": "STRING output helper used by PRINT"
        },
        {
          "chunk": "cmd_statement_output_channel",
          "topic": "CMD uses PRINT for actual output"
        }
      ]
    },
    {
      "start": 4870,
      "end": 4877,
      "name": "strout_string_output",
      "description": "STROUT ($AB1E) \u2014 Print string whose address is in A (low byte) and Y (high byte): routine outputs a zero-terminated string pointed to by .A and .Y using CHROUT for each character.",
      "references": [
        {
          "chunk": "print_statement",
          "topic": "STROUT is a subroutine within PRINT for string output"
        }
      ]
    },
    {
      "start": 4878,
      "end": 4880,
      "name": "doagin_io_error_formatting",
      "description": "DOAGIN ($AB4D) \u2014 Error message formatting routines used by GET, INPUT, and READ to prepare and print input-related error messages.",
      "references": [
        {
          "chunk": "get_statement",
          "topic": "DOAGIN formats error messages for GET"
        },
        {
          "chunk": "read_statement",
          "topic": "READ and INPUT use the same error formatting helpers"
        }
      ]
    },
    {
      "start": 4881,
      "end": 4889,
      "name": "get_statement",
      "description": "GET ($AB7B) \u2014 Perform GET and GET#: ensures not in direct mode, optionally opens an input channel with Kernal CHKIN for GET#, calls shared READ I/O routines to fetch a single character, and closes the input channel if it opened one.",
      "references": [
        {
          "chunk": "read_statement",
          "topic": "GET uses READ's common I/O parsing"
        },
        {
          "chunk": "input_statement",
          "topic": "GET and INPUT share input handling logic"
        }
      ]
    },
    {
      "start": 4890,
      "end": 4898,
      "name": "input_hash_statement",
      "description": "INPUT# (INPUTN, $ABA5) \u2014 Perform INPUT#: opens an input channel via Kernal CHKIN, calls INPUT to read data, then closes the channel with CHKOUT. Extra data is discarded without an EXTRA IGNORED message; unsuitable data types produce FILE DATA ERROR.",
      "references": [
        {
          "chunk": "input_statement",
          "topic": "INPUT# delegates to INPUT for prompt/line handling"
        },
        {
          "chunk": "exignt_input_error_text",
          "topic": "EXTRA IGNORED message handling for input errors"
        }
      ]
    },
    {
      "start": 4899,
      "end": 4906,
      "name": "input_statement",
      "description": "INPUT ($ABBF) \u2014 Perform INPUT: checks that program is not in direct mode, prints prompts, receives a line of input from the device, and jumps to READ's common code to parse and assign the input to the named variables.",
      "references": [
        {
          "chunk": "read_statement",
          "topic": "INPUT uses READ to parse and assign input values"
        },
        {
          "chunk": "get_statement",
          "topic": "GET shares parts of input handling with INPUT"
        }
      ]
    },
    {
      "start": 4907,
      "end": 4914,
      "name": "read_statement",
      "description": "READ ($AC06) \u2014 Perform READ: common code for READ, GET and INPUT. Locates the next DATA item, reads the text, converts it to the appropriate data type, and assigns to numeric or string variables.",
      "references": [
        {
          "chunk": "data_statement",
          "topic": "READ consumes DATA laid out by DATA statements"
        },
        {
          "chunk": "doagin_io_error_formatting",
          "topic": "error formatting routines used when READ encounters bad input"
        }
      ]
    },
    {
      "start": 4915,
      "end": 4920,
      "name": "exignt_input_error_text",
      "description": "EXIGNT ($ACFC) \u2014 ASCII text storage for input error messages: contains the strings '?EXTRA IGNORED' and '?REDO FROM START', each followed by a carriage return and a zero byte, used by INPUT/READ error reporting.",
      "references": [
        {
          "chunk": "input_hash_statement",
          "topic": "INPUT# behavior regarding EXTRA IGNORED"
        },
        {
          "chunk": "read_statement",
          "topic": "READ/INPUT use these messages during error conditions"
        }
      ]
    },
    {
      "start": 4921,
      "end": 4931,
      "name": "next_statement_for_loop",
      "description": "NEXT ($AD1E) \u2014 Perform NEXT: finds corresponding FOR data on the stack, adds STEP to the FOR variable, compares to TO; if loop finished removes FOR stack entries, otherwise restores pointers from FOR stack entry so execution continues after the FOR statement.",
      "references": [
        {
          "chunk": "frmnum_numeric_evaluation_and_type_check",
          "topic": "numeric evaluation used in FOR/NEXT variable checks"
        },
        {
          "chunk": "let_statement_variable_assignment",
          "topic": "FOR variable updates are conceptually assignments handled like LET"
        }
      ]
    },
    {
      "start": 4932,
      "end": 4938,
      "name": "frmnum_numeric_evaluation_and_type_check",
      "description": "FRMNUM ($AD8A) \u2014 Evaluate numeric expression and/or check for data type mismatch: entry point(s) to check that a value matches the expected type (string vs numeric); produces TYPE MISMATCH if incompatible.",
      "references": [
        {
          "chunk": "frmeval_expression_evaluation",
          "topic": "FRMNUM is related to FRMEVAL routines for computing values"
        },
        {
          "chunk": "let_statement_variable_assignment",
          "topic": "type checking during assignment"
        }
      ]
    },
    {
      "start": 4939,
      "end": 4960,
      "name": "frmeval_expression_evaluation",
      "description": "FRMEVAL ($AD9E) \u2014 Evaluate expressions: the main expression-evaluation entry point and group of subroutines used across BASIC. Responsibilities include tokenizing ASCII expression text, separating operators and terms, error checking, performing operations to combine terms, handling string and numeric types (including variables and constants), and producing a single resulting value. Sets flags indicating string vs numeric result and whether numeric result is integer or floating-point.",
      "references": [
        {
          "chunk": "let_statement_variable_assignment",
          "topic": "LET uses FRMEVAL to compute right-hand expressions"
        },
        {
          "chunk": "if_statement",
          "topic": "IF uses FRMEVAL to evaluate its conditional expression"
        },
        {
          "chunk": "frmnum_numeric_evaluation_and_type_check",
          "topic": "FRMNUM works with FRMEVAL to perform type checking on evaluated values"
        }
      ]
    },
    {
      "start": 4961,
      "end": 5080,
      "name": "expression_evaluation_and_variable_management",
      "description": "Expression and single-term evaluation (EVAL, PIVAL), parentheses/syntax checks (PARCHK, CHKCLS, CHKOPN, CHKCOM), syntax error printing (SNERR), variable value retrieval (ISVAR), function dispatch (ISFUN), logical operators (OROP, ANDOP), comparison operations (DORE1), DIM (array dimensioning), variable lookup/creation (PTRGET, alphabetic name check, NOTFNS), and returning variable address (FINPTR). Explains parsing, dispatch, and variable descriptor creation.",
      "references": [
        {
          "chunk": "program_execution_control_and_statements",
          "topic": "FRMEVAL and EVAL are called from statements (LET, IF, etc.)"
        },
        {
          "chunk": "arrays_integers_and_definition_handling",
          "topic": "DIM/ARRAY handling and integer/subscript conversion routines used by expressions"
        }
      ]
    },
    {
      "start": 5081,
      "end": 5086,
      "name": "ary_descriptor_allocation_aryget",
      "description": "ARYGET: Allocating space for array descriptors. Explains that the routine allocates five bytes plus two bytes for every array dimension and gives the routine label/address ($B194). Includes the blank line following the description.",
      "references": [
        {
          "chunk": "array_lookup_and_creation_isary",
          "topic": "Uses array descriptors when searching for or creating arrays"
        },
        {
          "chunk": "umult_array_size_multiplication",
          "topic": "Computes multidimensional sizes used when allocating descriptors"
        }
      ]
    },
    {
      "start": 5087,
      "end": 5093,
      "name": "floating_point_constant_n32768",
      "description": "N32768: The five-byte floating-point representation of the constant -32768 used for range checking when converting floating-point numbers to signed 16-bit integers. Covers the routine label/address ($B1A5) and the following blank line.",
      "references": [
        {
          "chunk": "ayint_fp_to_signed_integer",
          "topic": "Used by AYINT for range checking during conversion"
        },
        {
          "chunk": "intidx_subscript_conversion",
          "topic": "Relevant to converting subscripts to integer values (positive-range checking)"
        }
      ]
    },
    {
      "start": 5094,
      "end": 5107,
      "name": "fp_to_signed_in_a_and_y_registers",
      "description": "Convert a floating-point number to a signed integer in the A (high byte) and Y (low byte) registers. Describes a routine (address $B1AA) that calls AYINT to range-check and convert the Floating Point Accumulator to a 16-bit signed integer in locations $64-$65, leaving high byte in A and low byte in Y. Notes that the vector at locations 3-4 points to this routine so it can be used by user USR calls. Includes the trailing blank line.",
      "references": [
        {
          "chunk": "ayint_fp_to_signed_integer",
          "topic": "Calls AYINT to perform range checking and conversion"
        },
        {
          "chunk": "givayf_int16_to_floating_point",
          "topic": "Inverse functionality: converting 16-bit signed integer back to floating point; both used with USR vectors"
        }
      ]
    },
    {
      "start": 5108,
      "end": 5113,
      "name": "intidx_subscript_conversion",
      "description": "INTIDX: Input and conversion of a floating-point subscript to a positive integer (routine at $B1B2). Ensures the subscript value is converted to an integer and that it is positive; intended for use when subscripts are supplied as floating-point values.",
      "references": [
        {
          "chunk": "ayint_fp_to_signed_integer",
          "topic": "Related conversion/range-checking routine used for numeric-to-integer conversions"
        },
        {
          "chunk": "array_lookup_and_creation_isary",
          "topic": "INTIDX is used when validating array subscripts during ISARY's processing"
        }
      ]
    },
    {
      "start": 5114,
      "end": 5122,
      "name": "ayint_fp_to_signed_integer",
      "description": "AYINT: Convert a floating-point number to a 16-bit signed integer (routine at $B1BF). Checks that the Floating Point Accumulator is within the signed 16-bit range (32767 to -32768), produces an ILLEGAL QUANTITY error on failure, and stores the result with high byte at $64 and low byte at $65. Includes the following blank line.",
      "references": [
        {
          "chunk": "floating_point_constant_n32768",
          "topic": "Uses -32768 constant for lower-range checking"
        },
        {
          "chunk": "fp_to_signed_in_a_and_y_registers",
          "topic": "Called by that routine to perform the actual conversion"
        },
        {
          "chunk": "intidx_subscript_conversion",
          "topic": "Related routine for subscript conversion and positivity checks"
        }
      ]
    },
    {
      "start": 5123,
      "end": 5130,
      "name": "array_lookup_and_creation_isary",
      "description": "ISARY: Find an array element or create a new array in RAM (routine at $B1D1). Describes searching for an existing array, validating subscripts, setting pointers to the array and element, and creating the array if not found (then setting pointers).",
      "references": [
        {
          "chunk": "ary_descriptor_allocation_aryget",
          "topic": "Uses descriptors allocated by ARYGET when creating new arrays"
        },
        {
          "chunk": "umult_array_size_multiplication",
          "topic": "Uses UMULT to compute total storage size for multidimensional arrays"
        },
        {
          "chunk": "bad_subscript_and_illegal_quantity_errors",
          "topic": "May trigger BAD SUBSCRIPT or ILLEGAL QUANTITY error messages when validation fails"
        },
        {
          "chunk": "intidx_subscript_conversion",
          "topic": "Converts floating-point subscripts to positive integers for ISARY's checks"
        }
      ]
    },
    {
      "start": 5131,
      "end": 5136,
      "name": "bad_subscript_and_illegal_quantity_errors",
      "description": "BSERR and FCERR: Small routines that print error messages. BSERR prints the BAD SUBSCRIPT message (label at $B245), and FCERR prints the ILLEGAL QUANTITY message (label at $B248).",
      "references": [
        {
          "chunk": "array_lookup_and_creation_isary",
          "topic": "ISARY may call BSERR when subscript validation fails"
        },
        {
          "chunk": "ayint_fp_to_signed_integer",
          "topic": "AYINT may call FCERR when conversion is out of legal range"
        }
      ]
    },
    {
      "start": 5137,
      "end": 5142,
      "name": "umult_array_size_multiplication",
      "description": "UMULT: Compute the size of a multidimensional array (routine at $B34C). Describes multiplying array dimensions together to determine total element count/storage requirements.",
      "references": [
        {
          "chunk": "array_lookup_and_creation_isary",
          "topic": "UMULT is used during array creation/size calculation in ISARY"
        },
        {
          "chunk": "ary_descriptor_allocation_aryget",
          "topic": "Results inform how much descriptor/storage space ARYGET must account for"
        }
      ]
    },
    {
      "start": 5143,
      "end": 5162,
      "name": "fre_free_memory_and_garbage_collection",
      "description": "FRE: Implementation of the FRE function (routine at $B37D). Describes how FRE calls the garbage collection routine to reclaim unused string text, computes free memory between bottom of string space and top of array storage, and then falls through to a routine that converts the (assumed) 16-bit signed free-memory value into floating-point format. Explains platform differences: on PET free memory never exceeded 32767, but on the C64 larger values appear negative when treated as signed 16-bit; gives a corrective expression (FRE(0)-6556*(FRE(0)<0) in the text) to obtain correct free-memory amounts. Includes the trailing blank line.",
      "references": [
        {
          "chunk": "givayf_int16_to_floating_point",
          "topic": "FRE falls through to the routine that converts a 16-bit signed integer to floating point"
        },
        {
          "chunk": "array_lookup_and_creation_isary",
          "topic": "Free memory calculations relate to array storage boundaries used by ISARY"
        }
      ]
    },
    {
      "start": 5163,
      "end": 5174,
      "name": "givayf_int16_to_floating_point",
      "description": "GIVAYF: Convert a 16-bit signed integer to a floating-point value (routine at $B391). Treats Accumulator as high byte and Y as low byte of a signed 16-bit integer, converts it into the Floating Point Accumulator, and notes that the RAM vector at 5-6 points to this routine so it can be used to return USR-call arguments in the floating-point accumulator. Includes the following blank line.",
      "references": [
        {
          "chunk": "fre_free_memory_and_garbage_collection",
          "topic": "Used by FRE to convert the signed 16-bit free-memory value into floating point"
        },
        {
          "chunk": "fp_to_signed_in_a_and_y_registers",
          "topic": "Complementary routine used to place converted integers into A and Y for USR calls"
        }
      ]
    },
    {
      "start": 5175,
      "end": 5184,
      "name": "pos_cursor_position_function",
      "description": "POS: Implementation of the POS function (routine at $B39E). Describes how POS calls the Kernal PLOT routine to obtain the cursor position on the logical line (equivalent to PEEK(211)). Notes that logical-line positions can exceed 39 (example: a long logical sentence returns 48). Includes the following blank line.",
      "references": [
        {
          "chunk": "errdir_illegal_direct_check",
          "topic": "POS is a statement-level function; ERRDIR handles other statement execution mode checks"
        }
      ]
    },
    {
      "start": 5185,
      "end": 5191,
      "name": "errdir_illegal_direct_check",
      "description": "ERRDIR: Check for illegal direct mode execution (routine at $B3A6). Describes how this routine is called by statements that prohibit execution in direct mode, checks a flag set when a line without a line number is entered, and causes an ILLEGAL DIRECT error if the flag indicates direct mode.",
      "references": [
        {
          "chunk": "def_define_function_statement_handling",
          "topic": "DEF and other statement handlers may call ERRDIR to enforce non-direct execution where required"
        }
      ]
    },
    {
      "start": 5192,
      "end": 5203,
      "name": "def_define_function_statement_handling",
      "description": "DEF: Implementation of the DEF statement (routine at $B3B3). Describes syntax checking for DEF, pushing five bytes onto the stack (first byte of the function statement, a two-byte pointer to the dependent variable descriptor for the function argument, and the address of the first character of the function definition in the program text). Notes that DEF must fit on one line but functions can be extended by nesting/calling other functions.",
      "references": [
        {
          "chunk": "getfnm_def_and_fn_syntax_check",
          "topic": "GETFNM is used to validate FN/DEF syntax and to locate/create the dependent variable"
        },
        {
          "chunk": "fndoer_fn_evaluation",
          "topic": "FN evaluation uses the information stored by DEF"
        }
      ]
    },
    {
      "start": 5204,
      "end": 5211,
      "name": "getfnm_def_and_fn_syntax_check",
      "description": "GETFNM: Check DEF and FN syntax (routine at $B3E1). Ensures that FN follows the DEF keyword correctly and that the dependent variable name is a valid floating-point variable; it calls the routine that finds or creates a variable to obtain a pointer to its address.",
      "references": [
        {
          "chunk": "def_define_function_statement_handling",
          "topic": "Validates the syntax and dependent variable referenced by DEF"
        },
        {
          "chunk": "fndoer_fn_evaluation",
          "topic": "GETFNM helps set up the variable descriptors that FNDOER uses during function evaluation"
        }
      ]
    },
    {
      "start": 5212,
      "end": 5220,
      "name": "fndoer_fn_evaluation",
      "description": "FNDOER: Evaluate FN expressions (routine at $B3F4). Describes how the FN evaluation works: evaluate the function argument expression (e.g., FN(A+B*C/D)) and then continue parsing using the rest of the text from the function definition statement. Explains that the function's variable descriptor area is used as working space and that the dependent variable is not permanently modified (so calls like FN(X) do not change the caller's X value).",
      "references": [
        {
          "chunk": "def_define_function_statement_handling",
          "topic": "Uses the stack/descriptor information pushed by DEF when evaluating user-defined functions"
        },
        {
          "chunk": "getfnm_def_and_fn_syntax_check",
          "topic": "Relies on syntax checks and variable pointers established by GETFNM"
        }
      ]
    },
    {
      "start": 5221,
      "end": 5228,
      "name": "strd_str_d_str$",
      "description": "STRD (STR$) entry: header and brief description. Explains that STR$ first validates its parameter as a number and then calls the floating-point-to-ASCII conversion routine and routines that create pointers to the resulting string constant.",
      "references": [
        {
          "chunk": "strlit_scan_and_setup",
          "topic": "string literal pointer setup called when creating string constants"
        },
        {
          "chunk": "getspa_allocate_string_space",
          "topic": "allocation routine STR$ may rely on for storing strings"
        }
      ]
    },
    {
      "start": 5229,
      "end": 5236,
      "name": "strlit_scan_and_setup",
      "description": "STRLIT: scans a string literal to determine its length, calls the memory allocation routine to reserve space, then either saves the string into string storage or creates a pointer to the string in the BASIC input text buffer (at $200 / 512).",
      "references": [
        {
          "chunk": "getspa_allocate_string_space",
          "topic": "allocates the space STRLIT requests"
        },
        {
          "chunk": "garbag_string_garbage_collection_overview",
          "topic": "may be invoked if allocation requires garbage collection"
        }
      ]
    },
    {
      "start": 5237,
      "end": 5243,
      "name": "getspa_allocate_string_space",
      "description": "GETSPA: routine to allocate space for a string. The requested amount is checked against available free memory; if insufficient, a garbage collection is triggered and allocation is retried.",
      "references": [
        {
          "chunk": "garbag_string_garbage_collection_overview",
          "topic": "invoked by GETSPA when space is insufficient"
        },
        {
          "chunk": "strlit_scan_and_setup",
          "topic": "calls GETSPA to reserve space for literals"
        }
      ]
    },
    {
      "start": 5244,
      "end": 5273,
      "name": "garbag_string_garbage_collection_overview",
      "description": "GARBAG: overall description of the string garbage-collection algorithm. Explains how updated string text is appended at the bottom of string text storage leaving obsolete older copies higher in memory; describes scanning descriptors to find the highest valid copy of each string, moving strings down to compact storage, and updating the bottom-of-text pointer (addresses $33-$34). Also discusses performance characteristics and how full collections are performed even when spare space exists, leading to potentially long delays for programs with many strings.",
      "references": [
        {
          "chunk": "garbag_check_most_eligible",
          "topic": "subroutine that checks whether a given string is the most eligible to collect"
        },
        {
          "chunk": "garbag_collect_string",
          "topic": "subroutine that moves a found string and updates its descriptor"
        },
        {
          "chunk": "getspa_allocate_string_space",
          "topic": "may call GARBAG when allocation fails"
        }
      ]
    },
    {
      "start": 5274,
      "end": 5280,
      "name": "garbag_check_most_eligible",
      "description": "Subroutine: Check for Most Eligible String to Collect. Part of the garbage collector that examines a string descriptor to determine whether the current string is the highest (most eligible) in memory and therefore a candidate to be moved/collected.",
      "references": [
        {
          "chunk": "garbag_string_garbage_collection_overview",
          "topic": "overall GC process this routine participates in"
        },
        {
          "chunk": "garbag_collect_string",
          "topic": "if eligible, this routine will be used to move the string"
        }
      ]
    },
    {
      "start": 5281,
      "end": 5285,
      "name": "garbag_collect_string",
      "description": "Subroutine: Collect a String. Moves a string's text up to high memory (toward the bottom of string storage) and updates the string descriptor to point to the new location.",
      "references": [
        {
          "chunk": "garbag_check_most_eligible",
          "topic": "first determines which strings are eligible before collection"
        },
        {
          "chunk": "movins_move_string",
          "topic": "MOVINS is the utility often used to move string bytes when collecting"
        }
      ]
    },
    {
      "start": 5286,
      "end": 5294,
      "name": "cat_concatenate_two_strings",
      "description": "CAT: Concatenate two strings (A$ + B$). Performs error checking to ensure the resulting length is valid, calls the allocation routine to reserve space, and builds the new concatenated string at the bottom of the string text area.",
      "references": [
        {
          "chunk": "movins_move_string",
          "topic": "used to move string data when building the concatenated result"
        },
        {
          "chunk": "getspa_allocate_string_space",
          "topic": "used to allocate space for the concatenated string"
        }
      ]
    },
    {
      "start": 5295,
      "end": 5301,
      "name": "movins_move_string",
      "description": "MOVINS: Utility routine to move a string in memory, typically used to place a string at the bottom of the string text area. Employed by concatenation and collection routines when relocating string bytes.",
      "references": [
        {
          "chunk": "cat_concatenate_two_strings",
          "topic": "relocates the newly built concatenated string"
        },
        {
          "chunk": "garbag_collect_string",
          "topic": "used to move strings during garbage collection"
        }
      ]
    },
    {
      "start": 5302,
      "end": 5311,
      "name": "frestr_discard_temporary_string",
      "description": "FRESTR: Discard a temporary string. Calls the routine that clears an entry from the temporary descriptor stack. If the descriptor was on the stack, it sets pointers to the string and its length and exits; if the string was at the bottom of string text storage, the bottom pointer is moved up to deallocate the string.",
      "references": [
        {
          "chunk": "fretms_remove_temp_descriptor",
          "topic": "routine called to remove an entry from the temporary descriptor stack"
        },
        {
          "chunk": "getspa_allocate_string_space",
          "topic": "freed space may be reclaimed for subsequent allocations"
        }
      ]
    },
    {
      "start": 5312,
      "end": 5318,
      "name": "fretms_remove_temp_descriptor",
      "description": "FRETMS: Remove an entry from the string descriptor stack. If a currently valid string's descriptor matches an entry on the temporary string descriptor stack, that stack entry is removed to keep descriptor bookkeeping consistent.",
      "references": [
        {
          "chunk": "frestr_discard_temporary_string",
          "topic": "FRESTR calls this routine to clear temp descriptors"
        }
      ]
    },
    {
      "start": 5319,
      "end": 5325,
      "name": "chrd_perform_chr$",
      "description": "CHRD (CHR$): Creates a one-byte string descriptor on the temporary string stack for the specified byte value and sets a pointer to that temporary string.",
      "references": [
        {
          "chunk": "frestr_discard_temporary_string",
          "topic": "temporary descriptors created by CHR$ are cleared by FRESTR/FRETMS when discarded"
        }
      ]
    },
    {
      "start": 5326,
      "end": 5332,
      "name": "leftd_perform_left$",
      "description": "LEFTD (LEFT$): Creates a temporary string descriptor for a new string consisting of a specified number of characters taken from the left side of a source string.",
      "references": [
        {
          "chunk": "pream_pull_string_params",
          "topic": "parameter-pulling routine used by LEFT$, RIGHT$, and MID$"
        },
        {
          "chunk": "rightd_perform_right$",
          "topic": "RIGHT$ reuses LEFT$'s tail-end logic by parameter manipulation"
        }
      ]
    },
    {
      "start": 5333,
      "end": 5340,
      "name": "rightd_perform_right$",
      "description": "RIGHTD (RIGHT$): Manipulates its parameters so that LEFT$'s tail-end code can be reused. Produces a temporary string descriptor for a string containing the specified number of characters taken from the right-hand end of the source string.",
      "references": [
        {
          "chunk": "leftd_perform_left$",
          "topic": "RIGHT$ reuses LEFT$'s implementation for producing substrings"
        },
        {
          "chunk": "pream_pull_string_params",
          "topic": "obtains the required parameters for RIGHT$"
        }
      ]
    },
    {
      "start": 5341,
      "end": 5348,
      "name": "midd_perform_mid$",
      "description": "MIDD (MID$): Manipulates parameters so that LEFT$'s tail-end code can be used to produce a substring. Creates a temporary string descriptor for a substring consisting of a specified number of characters taken from a given middle position in the source string.",
      "references": [
        {
          "chunk": "leftd_perform_left$",
          "topic": "MID$ reuses LEFT$ tail-end code after parameter adjustment"
        },
        {
          "chunk": "pream_pull_string_params",
          "topic": "fetches the common parameters used by MID$"
        }
      ]
    },
    {
      "start": 5349,
      "end": 5354,
      "name": "pream_pull_string_params",
      "description": "PREAM: Pulls the string-function parameters from the stack for LEFT$, RIGHT$, and MID$. Used to obtain the first two parameters common to these commands.",
      "references": [
        {
          "chunk": "leftd_perform_left$",
          "topic": "uses PREAM to get parameters"
        },
        {
          "chunk": "rightd_perform_right$",
          "topic": "uses PREAM to get parameters"
        },
        {
          "chunk": "midd_perform_mid$",
          "topic": "uses PREAM to get parameters"
        }
      ]
    },
    {
      "start": 5355,
      "end": 5360,
      "name": "len_perform_len",
      "description": "LEN: Performs the LEN function by reading the length field from a string descriptor and converting that integer length into a floating-point value for RETURN.",
      "references": [
        {
          "chunk": "pream_pull_string_params",
          "topic": "LEN does not need PREAM but is related as a basic string function"
        }
      ]
    },
    {
      "start": 5361,
      "end": 5369,
      "name": "asc_perform_asc_and_getbytc_header",
      "description": "ASC: Performs ASC by obtaining the first character of a string into the Y register (if the string is not null) and then calling the integer-to-floating-point conversion code used by POS. Also includes the header line for GETBYTC (next routine) at the end of this range.",
      "references": [
        {
          "chunk": "len_perform_len",
          "topic": "related simple string functions returning numeric values"
        },
        {
          "chunk": "getspa_allocate_string_space",
          "topic": "string memory and descriptors referenced by ASC when accessing characters"
        }
      ]
    },
    {
      "start": 5370,
      "end": 5437,
      "name": "input_number_handling_and_memory_access",
      "description": "Numeric parameter and address parsing and memory-access statements: GETBYTC (get byte 0\u2013255), VAL (convert string to floating point), GETNUM (get 16-bit address and 8-bit parameter for POKE/WAIT), GETADR (convert FP to unsigned 16-bit address), PEEK (read memory byte and return as FP), POKE (write byte to memory), and FUWAIT/WAIT (poll a memory location with mask and optional pattern using AND/XOR). Explains range checks, conversion to/from floating point, and use cases for WAIT.",
      "references": [
        {
          "chunk": "string_allocation_and_manipulation",
          "topic": "VAL converts string text to floating point using FIN/FINLOG"
        },
        {
          "chunk": "floating_point_arithmetic_and_constants",
          "topic": "GETADR/PEEK/POKE convert between FP and integer formats used by floating point routines"
        }
      ]
    },
    {
      "start": 5438,
      "end": 5447,
      "name": "faddh_and_fsub",
      "description": "FADDH (add 0.5 to FAC1) and FSUB (move a memory number into FAC2 to subtract FAC1 from it). Covers the FADDH entry and the FSUB entry including the description that FSUB moves the memory number into FAC2 and falls through to the next routine.",
      "references": [
        {
          "chunk": "fsubt_subtraction_operation",
          "topic": "Continuation: BASIC subtraction (FSUBT) complements sign and adds."
        },
        {
          "chunk": "fadd_faddt_fadd4_addition_operations",
          "topic": "Related addition routines (FADD family) which mirror FSUB functionality for addition."
        }
      ]
    },
    {
      "start": 5448,
      "end": 5453,
      "name": "fsubt_subtraction_operation",
      "description": "FSUBT \u2014 BASIC's subtraction operation. Describes subtracting the contents of FAC2 from FAC1 by complementing FAC2's sign and adding.",
      "references": [
        {
          "chunk": "faddh_and_fsub",
          "topic": "Related move/subtract entry (FSUB moves memory into FAC2 before subtraction)."
        },
        {
          "chunk": "fadd_faddt_fadd4_addition_operations",
          "topic": "Analogous addition routines (FADDT) for additive operations."
        }
      ]
    },
    {
      "start": 5454,
      "end": 5469,
      "name": "fadd_faddt_fadd4_addition_operations",
      "description": "FADD (move a number from memory into FAC2 to add FAC1 to it), FADDT (BASIC addition operation that adds FAC1 and FAC2 and stores result in FAC1), and FADD4 (post-addition borrow handling \u2014 make result negative if a borrow occurred). Covers the descriptions of how memory numbers are loaded into FAC2 and how FAC1/FAC2 are added and adjusted.",
      "references": [
        {
          "chunk": "faddh_and_fsub",
          "topic": "Opposite operation family: subtraction entries (FSUB/FSUBT)."
        },
        {
          "chunk": "normalization_negation_overflow",
          "topic": "Normalization and sign/overflow handling used after arithmetic operations."
        }
      ]
    },
    {
      "start": 5470,
      "end": 5478,
      "name": "normalization_negation_overflow",
      "description": "NORMAL (normalize FAC1), NEGFAC (replace FAC1 with its two's complement), and OVERR (print overflow error). Covers normalization of the floating point accumulator, two's-complement negation of FAC1, and overflow error messaging.",
      "references": [
        {
          "chunk": "fadd_faddt_fadd4_addition_operations",
          "topic": "Normalization often follows addition/subtraction routines."
        },
        {
          "chunk": "negop_not_operation_behavior",
          "topic": "Additional negation behavior (NOT operation) that affects FAC1 sign handling."
        }
      ]
    },
    {
      "start": 5479,
      "end": 5481,
      "name": "mulshf_shift_routine",
      "description": "MULSHF \u2014 SHIFT routine used by floating point arithmetic. Brief entry indicating a shift helper used in multiplication/division routines.",
      "references": [
        {
          "chunk": "fmultiplication_internals",
          "topic": "Shift operations used by FMULT and other multiplication internals."
        }
      ]
    },
    {
      "start": 5482,
      "end": 5488,
      "name": "fone_constant_one",
      "description": "FONE \u2014 five-byte floating point constant representing the value 1. Includes note that this representation is used by floating point routines and as the default STEP for FOR statements.",
      "references": [
        {
          "chunk": "fout_constants_tables",
          "topic": "Other floating point constants (1/2, powers tables) used by FP routines."
        },
        {
          "chunk": "fmultiplication_internals",
          "topic": "Used as a multiplicative identity in arithmetic routines."
        }
      ]
    },
    {
      "start": 5489,
      "end": 5494,
      "name": "logcn2_log_constants",
      "description": "LOGCN2 \u2014 table of eight floating point constants (five-byte FP format) used by the LOG function. Describes the constants table used during logarithm computation.",
      "references": [
        {
          "chunk": "log_natural_log_function",
          "topic": "Constants used directly by the LOG routine."
        },
        {
          "chunk": "exp_constants_and_exp_function",
          "topic": "Related exponential constants/tables used by EXP/LOG calculations."
        }
      ]
    },
    {
      "start": 5495,
      "end": 5500,
      "name": "log_natural_log_function",
      "description": "LOG \u2014 compute natural logarithm (log base e) of the number in FAC1 and leave the result in FAC1. Entry describes that LOG computes ln(FAC1) and stores result back into FAC1.",
      "references": [
        {
          "chunk": "logcn2_log_constants",
          "topic": "Uses the LOGCN2 constants table during calculation."
        },
        {
          "chunk": "exp_constants_and_exp_function",
          "topic": "EXP and LOG are related mathematical functions often sharing tables and methods."
        }
      ]
    },
    {
      "start": 5501,
      "end": 5524,
      "name": "fmultiplication_internals",
      "description": "FMULT (multiply FAC1 by FAC2 and store in FAC1), MLTPLY (multiply a byte by repeated addition helper), CONUPK (load FAC2 from a compact 4-byte format), MULDIV (add exponents of FACs), and MLDVEX (handle underflow/overflow). Covers the internal routines used to perform floating-point multiplication and exponent adjustments.",
      "references": [
        {
          "chunk": "mulshf_shift_routine",
          "topic": "Shift helper used in multiplication internals."
        },
        {
          "chunk": "mul_div_helpers_and_division",
          "topic": "Division and multiply-by-10 helpers used elsewhere in conversion and division routines."
        }
      ]
    },
    {
      "start": 5525,
      "end": 5549,
      "name": "mul_div_helpers_and_division",
      "description": "MUL10 (multiply FAC1 by 10 \u2014 used when converting floats to ASCII), TENC (the constant 10 in five-byte FP format), DIV10 (divide FAC1 by 10), FDIV (move a memory number to FAC2 to prepare division), and FDIVT (divide FAC2 by FAC1 with division-by-zero check). Covers helpers for multiplying/dividing by 10 and the division routines that operate on FAC1/FAC2.",
      "references": [
        {
          "chunk": "fmultiplication_internals",
          "topic": "Related multiplication internals; multiplication/division share exponent handling."
        },
        {
          "chunk": "fout",
          "topic": "MUL10/DIV10 used during float-to-ASCII conversion routines."
        }
      ]
    },
    {
      "start": 5550,
      "end": 5578,
      "name": "movement_and_rounding_routines",
      "description": "MOVFM (move five-byte FP from memory into FAC1), MOV2F (move FAC1 to memory), MOVFA (move FAC2 to FAC1), MOVAF (round and move FAC1 to FAC2), MOVEF (copy FAC1 to FAC2 without rounding), and ROUND (adjust rounding byte \u2014 may increment FAC1). Covers routines that move floating point values between memory and the two accumulators and rounding behavior.",
      "references": [
        {
          "chunk": "qint_and_int_integer_conversion",
          "topic": "Routines that convert between floating point and integer formats rely on these move/round helpers."
        },
        {
          "chunk": "fin_string_to_fp_finlog_and_constants",
          "topic": "MOVFM/MOV2F are used when loading/storing numbers during string conversion (FIN/FOUT)."
        }
      ]
    },
    {
      "start": 5579,
      "end": 5605,
      "name": "sign_and_comparison_routines",
      "description": "SIGN (put sign of FAC1 into .A: 0 for zero, 1 for positive, 255 for negative), SGN (convert sign into a floating point number in FAC1), ABS (make FAC1 positive), and FCOMP (compare FAC1 to a five-byte floating point number in memory, returning 0/1/255 in .A). Covers sign extraction, sign-to-FP conversion, absolute value, and comparison semantics.",
      "references": [
        {
          "chunk": "normalization_negation_overflow",
          "topic": "Sign and negation helpers complement normalization/overflow handling."
        },
        {
          "chunk": "qint_and_int_integer_conversion",
          "topic": "Comparisons and sign operations used before integer conversion routines."
        }
      ]
    },
    {
      "start": 5606,
      "end": 5618,
      "name": "qint_and_int_integer_conversion",
      "description": "QINT (convert FAC1 into a four-byte signed integer in memory locations 98-101), and INT (remove fractional part: call QINT then convert integer back to floating point). Covers the conversion of floating point values to integer form and back.",
      "references": [
        {
          "chunk": "movement_and_rounding_routines",
          "topic": "Routines like MOV2F/MOVFM are used to move integers and floats during conversions."
        },
        {
          "chunk": "sign_and_comparison_routines",
          "topic": "Sign and comparison results affect integer conversion behavior."
        }
      ]
    },
    {
      "start": 5619,
      "end": 5636,
      "name": "fin_finlog_and_conversion_constants",
      "description": "FIN (convert ASCII string to floating point FAC1 \u2014 used by VAL), FINLOG (add signed integer digit to FAC1 during parsing), and NO999 (table of three floating point constants: 99,999,999.5; 999,999,999.5; 1,000,000,000 used during string-to-FP conversion). Covers the internals of parsing ASCII numeric strings into floating point representation and constants used for range handling.",
      "references": [
        {
          "chunk": "movement_and_rounding_routines",
          "topic": "FIN uses MOVFM/MOVFA helpers during conversion."
        },
        {
          "chunk": "mul_div_helpers_and_division",
          "topic": "MUL10/DIV10 helpers are used when assembling numeric digits into floating point form."
        }
      ]
    },
    {
      "start": 5637,
      "end": 5653,
      "name": "inprt_linprt_and_fout_printing",
      "description": "INPRT (print 'IN' followed by a line number), LINPRT (convert and output line numbers: high byte in .A, low byte in .X converted to FP then to ASCII), and FOUT (convert contents of FAC1 to ASCII string and set pointer in .A/.Y). Covers routines that format and output numbers and line numbers to ASCII.",
      "references": [
        {
          "chunk": "fout_constants_tables",
          "topic": "FOUT relies on constants/tables (powers of -10, half) when converting floats to ASCII."
        },
        {
          "chunk": "fin_finlog_and_conversion_constants",
          "topic": "Complementary functionality: converting ASCII to FP and FP to ASCII."
        }
      ]
    },
    {
      "start": 5654,
      "end": 5672,
      "name": "fp_conversion_constants_tables",
      "description": "FHALF (the constant 1/2 in five-byte FP format \u2014 used for rounding and SQR), FOUTBL (table of powers of -10 as four-byte FP numbers for conversion), and FDCEND (table of constants for TI$ conversion: powers of -60 times 1 or 10). Covers the constants and tables used by floating point to ASCII (and TI$) conversions.",
      "references": [
        {
          "chunk": "inprt_linprt_and_fout_printing",
          "topic": "Tables used directly by FOUT and line-number printing routines."
        },
        {
          "chunk": "sqr_and_fpwrt_exponentiation",
          "topic": "FHALF is used for rounding and square-root routines."
        }
      ]
    },
    {
      "start": 5673,
      "end": 5677,
      "name": "bf52_unused_area",
      "description": "Unused area at $BF52 (address block $BF52): notes that the unused area is filled with bytes of value 170 ($AA). Simple metadata about unused ROM space.",
      "references": [
        {
          "chunk": "fp_conversion_constants_tables",
          "topic": "Adjacent constants/tables area before the unused block."
        }
      ]
    },
    {
      "start": 5678,
      "end": 5689,
      "name": "sqr_and_fpwrt_exponentiation",
      "description": "SQR (move FAC1 to FAC2, load 0.5 into FAC1 and fall through to exponentiation) and FPWRT (perform exponentiation: raise FAC2 to the power FAC1 and leave result in FAC1). Covers square-root operation entry and general power calculation called by UPARROW.",
      "references": [
        {
          "chunk": "fp_conversion_constants_tables",
          "topic": "SQR uses FHALF for 0.5 constant to compute square roots."
        },
        {
          "chunk": "exp_constants_and_exp_function",
          "topic": "Exponentiation and exponential function routines may share methods/tables."
        }
      ]
    },
    {
      "start": 5690,
      "end": 5697,
      "name": "negop_not_operation_behavior",
      "description": "NEGOP \u2014 implement NOT and '>' behavior for floating point accumulator. Describes negation of FAC1 by XORing the sign byte with $FF, leaving zero unchanged, and explains result semantics based on NOT X = -(X+1) (e.g., NOT true (-1) gives 0).",
      "references": [
        {
          "chunk": "normalization_negation_overflow",
          "topic": "Related sign/negation handling (NEGFAC) and overflow behavior."
        },
        {
          "chunk": "sign_and_comparison_routines",
          "topic": "SGN/SIGN/ABS interact with NEGOP semantics for logical operations."
        }
      ]
    },
    {
      "start": 5698,
      "end": 5708,
      "name": "exp_constants_and_exp_function",
      "description": "EXPCON (table of constants for EXP and LOG in five-byte FP format \u2014 used to calculate 2^N) and EXP (compute e^x: raise e to the power in FAC1, leave result in FAC1). Covers the exponential function and its supporting constants/tables.",
      "references": [
        {
          "chunk": "logcn2_log_constants",
          "topic": "LOG uses related constants/tables; EXP and LOG are mathematically related."
        },
        {
          "chunk": "sqr_and_fpwrt_exponentiation",
          "topic": "Exponentiation routines and FPWRT implement power calculations that may leverage exponential methods."
        }
      ]
    },
    {
      "start": 5709,
      "end": 5715,
      "name": "rom_split_note_and_footer",
      "description": "Note about routine split between BASIC ROM and Kernal ROM: routines are split at address $BFFF (49151) and the Kernal begins at $E000 (57344), so a JMP $E000 is appended resulting in BASIC routines in the C64 Kernal being three bytes higher in memory than VIC-20 equivalents. Footer/trailer lines included.",
      "references": [
        {
          "chunk": "bf52_unused_area",
          "topic": "Physical layout note adjacent to ROM data and unused area remarks."
        },
        {
          "chunk": "exp_constants_and_exp_function",
          "topic": "Example of a routine (EXP) that is split between BASIC ROM and Kernal ROM."
        }
      ]
    },
    {
      "start": 5716,
      "end": 5740,
      "name": "free_ram_c000_cfff",
      "description": "Description of the 4K free RAM area at $C000-$CFFF (49152\u201353247). Explains that this RAM is not contiguous with BASIC program/variable space and thus not counted in FRE(0), and enumerates typical uses (user machine code, alternate I/O drivers, character/sprite data). Warns about conflicts with common system additions (e.g., Universal Wedge at $CC00, Simon's BASIC) and the need to avoid RAM address collisions.",
      "references": [
        {
          "chunk": "io_memory_map_and_vicii_intro",
          "topic": "nearby I/O and ROM areas, caution when banking or using I/O RAM"
        },
        {
          "chunk": "floating_point_arithmetic_and_constants",
          "topic": "note that some FP/Kernal code is split across ROM areas (related to memory layout awareness)"
        }
      ]
    },
    {
      "start": 5741,
      "end": 5748,
      "ignore": true,
      "reason": "Chapter title / ASCII art header \u2014 non-technical formatting"
    },
    {
      "start": 5749,
      "end": 5749,
      "ignore": true,
      "reason": "Standalone blank lines and decorative ASCII-art header; non-technical formatting."
    },
    {
      "start": 5750,
      "end": 5800,
      "name": "d000_dfff_overview_i_o_devices_vic_sid_cia_colorram",
      "description": "Overview of the $D000-$DFFF 4K I/O block: VIC-II video chip, SID sound chip, two CIAs, Color RAM, optional character ROM access and 4K RAM; notes on address space images and future expansion. Sets stage for VIC-II register descriptions.",
      "references": [
        {
          "chunk": "vic_ii_registers_block_intro",
          "topic": "VIC-II registers start at $D000"
        },
        {
          "chunk": "sid_registers_overview",
          "topic": "SID register block at $D400"
        }
      ]
    },
    {
      "start": 5801,
      "end": 5900,
      "name": "bit_values_and_basic_bit_manipulation",
      "description": "Reminder of bit values (Bit0=1 through Bit7=128) and how to set/reset bits from BASIC using POKE with PEEK(... ) OR Bitvalue and PEEK(...) AND (255-Bitvalue).",
      "references": [
        {
          "chunk": "d000_dfff_overview_i_o_devices_vic_sid_cia_colorram",
          "topic": "Used for manipulating VIC-II and other I/O registers"
        }
      ]
    },
    {
      "start": 5901,
      "end": 6000,
      "name": "vic_ii_chip_registers_intro_and_video_memory_control",
      "description": "Intro to VIC-II registers ($D000-$D02E), VIC-II independent 16K video addressing (selectable 16K banks), Video Matrix and Character Dot-Data base selection ($D018), background and border color registers ($D021 and $D020), and basic text/graphics modes.",
      "references": [
        {
          "chunk": "character_generator_rom_and_vic_memory_setup",
          "topic": "Character Generator ROM (alternate entry at $C000)"
        }
      ]
    },
    {
      "start": 6001,
      "end": 6100,
      "name": "multicolor_and_extended_background_text_modes",
      "description": "Multicolor text mode (Bit 4 of $D016) \u2014 uses bit pairs reducing horizontal resolution and introduces Background Color Registers 1 and 2; Extended Background Color Mode \u2014 foreground from Color RAM, backgrounds chosen by character code ranges with Background Color Registers 0-3 ($D021-$D024) used for groups of codes.",
      "references": [
        {
          "chunk": "vic_ii_chip_registers_intro_and_video_memory_control",
          "topic": "Mode selection controlled from VIC-II control registers"
        }
      ]
    },
    {
      "start": 6101,
      "end": 6200,
      "name": "bitmap_graphics_mode_overview",
      "description": "Bitmap (hi-res) graphics mode enabled by Bit 5 of $D011: 320x200 dots, 1 bit per dot; mapping of bitmap and color memory within VIC-II 16K bank controlled by $D018; multicolor bitmap variations, color memory requirements (1K), differences from text mode layout.",
      "references": [
        {
          "chunk": "bitmap_pixel_addressing_and_plotting",
          "topic": "How to find and set individual pixels in bitmap mode"
        }
      ]
    },
    {
      "start": 6201,
      "end": 6300,
      "name": "sprite_graphics_introduction_and_data_pointers",
      "description": "Sprite system overview: eight sprites (0-7), each 24x21 dots, shapes come from 63-byte blocks pointed to by Sprite Data Pointers located in the last eight bytes of screen memory (default $07F8-$07FF). Pointer value * 64 gives address of sprite data (within VIC-II addressable 16K block).",
      "references": [
        {
          "chunk": "sprite_data_format_and_bit_patterns",
          "topic": "How sprite shape bytes map to dots"
        },
        {
          "chunk": "sprite_position_registers_and_msb_handling",
          "topic": "Sprite placement using horizontal/vertical registers and MSB register"
        }
      ]
    },
    {
      "start": 6301,
      "end": 6400,
      "name": "sprite_data_format_and_bit_patterns",
      "description": "How sprite shape bytes map to 24-dot lines (3 bytes per line): bit significance (bits 0-7 values), examples of byte patterns and their decimal equivalents, building multi-line sprites (example cross with 63 bytes and their layout).",
      "references": [
        {
          "chunk": "sprite_graphics_introduction_and_data_pointers",
          "topic": "Pointers map to these 63-byte blocks"
        }
      ]
    },
    {
      "start": 6401,
      "end": 6500,
      "name": "sprite_display_enable_position_and_color_registers",
      "description": "Steps to display a sprite: set Sprite Display Enable bits ($D015), set horizontal/vertical position registers ($D000-$D010), set Sprite Color Registers ($D027-$D02E), and optionally use expand registers for doubling size, collision detection registers for overlaps, priority register for foreground/background, and sprite multicolor mode ($D01C) with shared multicolor registers ($D025-$D026).",
      "references": [
        {
          "chunk": "sprite_data_format_and_bit_patterns",
          "topic": "Shape data must contain non-zero data for collisions/visibility"
        }
      ]
    },
    {
      "start": 6501,
      "end": 6600,
      "name": "sprite_position_registers_and_horizontal_msb",
      "description": "Sprite horizontal and vertical position registers ($D000-$D010) details: vertical positions range 0-255 representing top line of 21-line sprite; visible raster lines 50-249; horizontal positions 0-511 supported via eight 8-bit registers plus a Most Significant Bits register ($D010) which provides the 9th bit for each sprite; explanation of visible dot ranges and examples of setting positions and MSB handling.",
      "references": [
        {
          "chunk": "sprite_display_enable_position_and_color_registers",
          "topic": "Enable bits and colors necessary to make sprite visible"
        }
      ]
    },
    {
      "start": 6601,
      "end": 6700,
      "name": "sprite_position_registers_list_and_msb_bits",
      "description": "Register list for sprite positions: SP0X..SP7Y ($D000-$D00F) and MSIGX ($D010) mapping bits 0-7 to sprite 0-7 MSBs. Notes on defaults (initialized to 0) and behavior of MSB bits (add 256 when set).",
      "references": [
        {
          "chunk": "sprite_position_registers_and_horizontal_msb",
          "topic": "Usage examples and explanation"
        }
      ]
    },
    {
      "start": 6701,
      "end": 6800,
      "name": "vertical_fine_scrolling_and_control_register_$D011",
      "description": "Vertical fine scrolling and control register ($D011) bits: Bits0-2 fine vertical scroll (0-7 scanlines), Bit3 24/25 row selection, Bit4 screen blanking, Bit5 enable bitmap mode, Bit6 extended color text mode, Bit7 high bit of raster compare; default register value and explanation of vertical fine scrolling including need for coarse scroll when wrapping and sample BASIC code showing smooth scroll.",
      "references": [
        {
          "chunk": "raster_register_and_interrupts",
          "topic": "Bit 7 is high bit (9th) of raster compare at $D012"
        }
      ]
    },
    {
      "start": 6801,
      "end": 6900,
      "name": "vertical_scrolling_use_cases_blank_and_bus_timing",
      "description": "Details on Bit3 shortened display to aid vertical scrolling; Bit4 blanking to remove VIC-II bus delays and speed up 6510 by ~7% (useful for tape/disk timing), example timing test program and explanation of using POKE to clear screen blanking for loading from older 1540 drives.",
      "references": [
        {
          "chunk": "vertical_fine_scrolling_and_control_register_$D011",
          "topic": "Related scrolling bits and behavior"
        }
      ]
    },
    {
      "start": 6901,
      "end": 7000,
      "name": "bitmap_mode_selection_and_memory_control_$D018",
      "description": "Bitmap mode details: enabling via Bit5 of $D011; bitmap layout as 320x200; VIC memory control ($D018) sets character dot-data base and video matrix base (lower nybble for dot-data or bitmap offset, upper nybble for video matrix), color memory mapping 1K area, restrictions for bitmap placement within VIC-II 16K bank, and examples of default placements.",
      "references": [
        {
          "chunk": "bitmap_pixel_addressing_and_plotting",
          "topic": "How to find pixel byte for given X-Y in bitmap space"
        }
      ]
    },
    {
      "start": 7001,
      "end": 7100,
      "name": "bitmap_pixel_addressing_and_plotting",
      "description": "How bitmap data is arranged (character-like interleaved layout). Formula for finding the byte BY for a dot given X, Y, and BASE: BY = BASE + 40*(Y AND 256) + (Y AND 7) + (X AND 504). BASIC examples to set/reset bits with POKE/PEEK and optimization suggestions (array of powers of two BI(I)).",
      "references": [
        {
          "chunk": "bitmap_mode_selection_and_memory_control_$D018",
          "topic": "BASE and VIC memory bank selection are controlled by $D018"
        }
      ]
    },
    {
      "start": 7101,
      "end": 7200,
      "name": "bitmap_plotting_examples_and_basic_sample_programs",
      "description": "Sample BASIC programs demonstrating bitmap plotting, using BI array for bit masks, setting up bitmap at 8192 via $D018, enabling bitmap mode with $D011, clearing screen, and plotting a sine-wave pattern across the screen. Notes on BASIC performance vs machine language for plotting.",
      "references": [
        {
          "chunk": "bitmap_pixel_addressing_and_plotting",
          "topic": "Uses the BY formula and BI masks"
        }
      ]
    },
    {
      "start": 7201,
      "end": 7300,
      "name": "multicolor_bitmap_mode_and_bit-pair_plotting",
      "description": "Multicolor bitmap mode when Bit4 of $D016 is set along with bitmap mode: horizontal resolution reduces to 160 double-width dots; color for each bit-pair chosen from background register 0, upper/lower nybbles of Video Matrix, and Color RAM nybble; formulas for BY in multicolor (BY = BASE + (Y AND 248)*40 + (Y AND 7) + (2*X AND 504)), bit-pair mask arrays and code examples.",
      "references": [
        {
          "chunk": "bitmap_plotting_examples_and_basic_sample_programs",
          "topic": "Sample code demonstrates drawing in multicolor bitmap"
        }
      ]
    },
    {
      "start": 7301,
      "end": 7400,
      "name": "video_chip_reset_and_other_vic_scrolx_bits_$D016",
      "description": "Horizontal Fine Scrolling and Control Register ($D016) bits: Bits0-2 fine horizontal scroll (0-7), Bit3 38/40 column selection, Bit4 multicolor enable, Bit5 VIC-II reset (video off when set to 1), Bits6-7 unused; default value and coarse scroll interaction; sample BASIC to illustrate smooth horizontal scroll and need for raster interrupts for partial-screen scrolling.",
      "references": [
        {
          "chunk": "vertical_fine_scrolling_and_control_register_$D011",
          "topic": "Paired register controlling vertical vs horizontal fine-scrolling"
        }
      ]
    },
    {
      "start": 7401,
      "end": 7500,
      "name": "sprite_vertical_expansion_and_memory_control_$D017_$D018",
      "description": "Sprite vertical expansion register ($D017) bits to double sprite height per-sprite; VIC-II memory control register ($D018) bit usage to select Character Dot-Data base (bits1-3) and Video Matrix base (bits4-7) with examples for switching alternate character set and bitmap mode differences.",
      "references": [
        {
          "chunk": "sprite_display_enable_position_and_color_registers",
          "topic": "Sprite expansion complements sprite position/color registers"
        }
      ]
    },
    {
      "start": 7501,
      "end": 7600,
      "name": "video_matrix_base_character_dot-data_and_screen_relocation",
      "description": "Detailed explanation of VMCSB ($D018) upper and lower nybbles: lower 3 bits select character dot-data area offset in 1K even multiples, upper 4 bits select Video Matrix start 1K boundary (0-15). Notes about relocating screen: need to set BASIC's screen page at location 648 when moving Video Matrix, and examples of calculating actual address depending on VIC bank choice.",
      "references": [
        {
          "chunk": "bitmap_mode_selection_and_memory_control_$D018",
          "topic": "Bitmap placement constraints when using VMCSB"
        }
      ]
    },
    {
      "start": 7601,
      "end": 7700,
      "name": "vic_interrupt_flags_and_sources_$D019",
      "description": "VIC-II Interrupt Flag Register ($D019) bits: Bit0 raster compare flag, Bit1 sprite/foreground collision flag, Bit2 sprite/sprite collision flag, Bit3 light pen trigger flag, Bit7 any-VIC-IRQ indicator. Explanation of latched IRQ status, need to write 1 to clear, and how IRQ routine should check Bit7 then individual bits to determine source.",
      "references": [
        {
          "chunk": "irq_mask_register_and_raster_interrupts_$D01A",
          "topic": "Use IRQ Mask to enable/disable individual VIC IRQ sources"
        }
      ]
    },
    {
      "start": 7701,
      "end": 7800,
      "name": "irq_mask_register_and_raster_interrupts_$D01A",
      "description": "IRQ Mask Register ($D01A) bits to enable raster compare, sprite-foreground collision, sprite-sprite collision, and light pen IRQs; explanation of interrupts concept, steps to install an IRQ routine (SEI, enable raster IRQ bit, write raster compare 9-bit value to $D012 + $D011 bit7, set IRQ vector at $0314-$0315, CLI), and notes on preserving existing timer interrupt and chaining to it.",
      "references": [
        {
          "chunk": "vic_interrupt_flags_and_sources_$D019",
          "topic": "Checking and clearing flags when IRQ occurs"
        }
      ]
    },
    {
      "start": 7801,
      "end": 7900,
      "name": "raster_interrupt_examples_tables_and_sample_program",
      "description": "Detailed sample BASIC program showing use of raster-scan interrupt to split screen into mixed modes (hi-res bitmap, text, multicolor bitmap). Includes DATA table layout used by the interrupt routine (scanlines, background color, control regs), explanation of how DATA entries map to VIC registers during interrupts, and example of modifying table values to change screen layout.",
      "references": [
        {
          "chunk": "irq_mask_register_and_raster_interrupts_$D01A",
          "topic": "Installation and usage of raster interrupts"
        }
      ]
    },
    {
      "start": 7901,
      "end": 8000,
      "name": "sprite_irq_enable_and_priority_registers_$D01B_$D01C",
      "description": "Sprite to Foreground Priority Register ($D01B) bit definitions (select whether sprite is in front of or behind foreground), Sprite Multicolor control ($D01C) per-sprite bit to enable multicolor sprites and color source mapping for bit-pairs including Sprite Multicolor Registers ($D025-$D026) and Sprite Color Registers ($D027-$D02E). Also note fixed priority among sprites (lower-numbered sprites have priority).",
      "references": [
        {
          "chunk": "sprite_display_enable_position_and_color_registers",
          "topic": "How priority interacts with enabling and colors"
        }
      ]
    },
    {
      "start": 8001,
      "end": 8100,
      "name": "sprite_expand_and_collision_registers_$D01D_$D01E_$D01F",
      "description": "Sprite Horizontal Expansion Register ($D01D) bits for doubling width; Sprite collision detection registers ($D01E Sprite-Sprite, $D01F Sprite-Foreground) explanation: reading clears latched collisions, rules for what causes collisions (only nonzero shape bits count; multicolor 01 bit-pair treated as background and doesn't cause collisions), collisions can happen off-screen and in border-covered areas.",
      "references": [
        {
          "chunk": "sprite_position_registers_and_horizontal_msb",
          "topic": "Collision detection independent of onscreen position"
        }
      ]
    },
    {
      "start": 8101,
      "end": 8200,
      "name": "vic_color_registers_and_defaults_$D020-$D026",
      "description": "VIC-II color registers ($D020-$D026): Border Color ($D020), Background Color 0-3 ($D021-$D024) and Sprite Multicolor Registers ($D025-$D026). Note only lower 4 bits are connected when reading/writing; default color values listed for border and backgrounds and sprite multicolor defaults.",
      "references": [
        {
          "chunk": "color_ram_and_color_mapping",
          "topic": "Color RAM provides per-character foreground colors"
        }
      ]
    },
    {
      "start": 8201,
      "end": 8300,
      "name": "sprite_color_registers_$D027-$D02E_and_unconnected_space",
      "description": "Sprite Color Registers ($D027-$D02E) per-sprite color defaults for SP0-SP7, and notes about not-connected addresses ($D02F-$D03F) that always return $FF and ignore writes.",
      "references": [
        {
          "chunk": "sprite_expand_and_collision_registers_$D01D_$D01E_$D01F",
          "topic": "Sprite colors used by multicolor and hi-res sprite rendering"
        }
      ]
    },
    {
      "start": 8301,
      "end": 8400,
      "name": "vic_register_images_and_sid_register_block_intro_$D040-$D41C",
      "description": "Mirrored VIC-II register images in $D040-$D3FF due to limited decoding (every 64 bytes mirrors), then SID register block introduction ($D400-$D41C): 6581 SID provides three voices, each with frequency, pulse width, envelope (ADSR), waveform control, oscillator sync/ring mod, and programmable filters (low/high/band-pass).",
      "references": [
        {
          "chunk": "sid_voice_registers_and_controls",
          "topic": "Detailed SID register definitions follow"
        }
      ]
    },
    {
      "start": 8401,
      "end": 8419,
      "name": "sid_voice1_frequency_pulse_and_control_$D400-$D404",
      "description": "SID Voice 1 registers ($D400-$D404): FRELO1/FREHI1 16-bit frequency control with formula (FREQUENCY = REGISTER_VALUE * CLOCK / 16777216), PWLO1/PWHI1 12-bit pulse width (duty cycle relation), Voice 1 Control Register ($D404) bits for gate, sync, ring modulation, test, and waveform selection (triangle/saw/pulse/noise).",
      "references": [
        {
          "chunk": "sid_envelope_controls_and_adsr",
          "topic": "ADSR registers control envelope phases for each voice"
        }
      ]
    },
    {
      "start": 8420,
      "end": 8429,
      "name": "keyboard_joystick_confusion_and_keyscan_disable",
      "description": "Explains keyboard/joystick confusion because CIA #1 Data Port B is used for both keyboard rows and joystick 1. Presents techniques to avoid false reads: temporarily turning off keyscan (POKE 56333,127:POKE 56320,255 and restore with POKE 56333,129) or clearing keyboard buffer (POKE 198,0).",
      "references": [
        {
          "chunk": "reading_joystick_fire_buttons",
          "topic": "reading joystick trigger bits"
        },
        {
          "chunk": "ciaicr_interrupt_control",
          "topic": "manipulating CIA interrupt mask while disabling keyscan"
        }
      ]
    },
    {
      "start": 8430,
      "end": 8432,
      "name": "joystick_as_keypress_problem_and_workarounds",
      "description": "Notes the harder problem of mistaking joystick movement for keyboard keypresses (and vice versa). Typical workaround: use Controller Port 2 for games to avoid conflicts; anecdote about using joystick left to slow program listing (interpreted as CTRL by keyscan).",
      "references": [
        {
          "chunk": "keyboard_joystick_confusion_and_keyscan_disable",
          "topic": "turning off keyscan to isolate joystick reads"
        }
      ]
    },
    {
      "start": 8433,
      "end": 8433,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8434,
      "end": 8466,
      "name": "port_a_paddle_selection_sid_and_paddle_fire_buttons",
      "description": "Describes CIA #1 Data Port A (Port A) role selecting which paddles SID reads and reading paddle fire buttons. Bit 7=1 & Bit 6=0 -> SID reads paddles on Port 1; Bit 7=0 & Bit 6=1 -> SID reads paddles on Port 2. Notes conflict with keyscan (CIA #1 Data Port A used for keyscan writes) and necessity to disable keyscan IRQ to get accurate paddle readings. Also explains paddle fire buttons are read at CIA #1 Data Ports A and B: paddles on Controller Port 1 via Data Port B (56321,$DC01), Controller Port 2 via Data Port A (56320,$DC00). Fire buttons use Bits 2 and 3 (bit reads 0 when pushed).",
      "references": [
        {
          "chunk": "sid_potx_paddle_input",
          "topic": "SID POTX register used to read paddle positions ($D419/54297)"
        },
        {
          "chunk": "reading_joystick_fire_buttons",
          "topic": "reading joystick trigger bits at CIA ports"
        }
      ]
    },
    {
      "start": 8467,
      "end": 8467,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8468,
      "end": 8475,
      "name": "data_port_b_timer_output",
      "description": "Explains that CIA #1 Data Port B can act as an output controlled by Timer A or B: timers can be set so they do not generate interrupts but instead toggle or pulse Bit 6 (Timer A) or Bit 7 (Timer B) of Data Port B. Timer A can pulse Bit 6 for one machine cycle or toggle it; Timer B uses Bit 7 similarly.",
      "references": [
        {
          "chunk": "ciacra_control_register_a",
          "topic": "Control Register A bits to configure Timer A output/pulse/toggle"
        },
        {
          "chunk": "ciacrb_control_register_b",
          "topic": "Control Register B bits to configure Timer B output/pulse/toggle"
        }
      ]
    },
    {
      "start": 8476,
      "end": 8476,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8477,
      "end": 8517,
      "name": "ciapra_ciaprb_registers_cia1_data_ports",
      "description": "CIA #1 Data Port Register A (56320 $DC00) and Data Port Register B (56321 $DC01) bit-by-bit functions. CIAPRA bits 0-7 map to keyboard columns, joystick2 up/down/left/right/fire and paddle fire buttons, and select which paddles SID reads (Bits 6-7). CIAPRB bits 0-7 map to keyboard rows, joystick1 directions and fire, and Timer A/B output toggles on Bits 6-7.",
      "references": [
        {
          "chunk": "reading_joystick_fire_buttons",
          "topic": "examples reading joystick buttons using PEEK on these ports"
        },
        {
          "chunk": "data_port_b_timer_output",
          "topic": "timer outputs on Data Port B bits 6 and 7"
        }
      ]
    },
    {
      "start": 8518,
      "end": 8550,
      "name": "sid_adsr_filter_game_io_and_cia_intro_$D405-$DC00",
      "description": "SID Voice 1 ADSR registers ($D405-$D406) explanation of attack/decay and sustain/release nibble encodings and timing tables; Voice 2/3 registers mirror Voice 1 ($D407-$D414); Filter controls ($D415-$D418) cutoff (11-bit), resonance and routing bits; Volume/Filter Select ($D418) for output volume and filter selection; paddle inputs and random/ENV3 registers ($D419-$D41C); then Color RAM region introduction ($D800) followed by start of CIA #1 ($DC00) registers overview for keyboard, joysticks, timers, and data ports.",
      "references": [
        {
          "chunk": "sid_voice1_frequency_pulse_and_control_$D400-$D404",
          "topic": "Voice controls and ADSR interaction"
        },
        {
          "chunk": "color_ram_and_color_mapping",
          "topic": "Color RAM follows SID block in memory map"
        },
        {
          "chunk": "cia_1_registers_and_keyboard_matrix",
          "topic": "CIA #1 at $DC00 handles keyboard/joystick I/O"
        }
      ]
    },
    {
      "start": 8551,
      "end": 8561,
      "name": "ciddrb_register",
      "description": "CIDDRB (56323 $DC03) Data Direction Register B: Bit 0..7 mapping to select Data Port B bit direction (0=input, 1=output).",
      "references": [
        {
          "chunk": "cia_data_direction_registers_overview",
          "topic": "default DDR values and usage"
        }
      ]
    },
    {
      "start": 8562,
      "end": 8562,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8563,
      "end": 8613,
      "name": "cia_timers_register_behavior_and_timing",
      "description": "Description of CIA timer registers (two 16-bit timers A and B) at 56324-56327 ($DC04-$DC07). Reading returns current counter; writing stores to timer latch. Timers count down once per CPU cycle (NTSC ~1,022,730 Hz, PAL ~985,250 Hz). TIME = LATCH_VALUE / CLOCK_SPEED. When a timer underflows it sets its interrupt bit in the Interrupt Control Register (56333 $DC0D) or toggles/pulses Port B output if configured; timers reload latch and stop or continue depending on one-shot/continuous mode. Timer A may count microprocessor cycles or external CNT pulses; Timer B can count microprocessor cycles, CNT signals, Timer A underflows, or Timer A underflows when CNT pulses present, enabling a linked 32-bit timer.",
      "references": [
        {
          "chunk": "timalo_timahi_timblo_timbhi_list",
          "topic": "register addresses for timer low/high bytes"
        },
        {
          "chunk": "ciaicr_interrupt_control",
          "topic": "timer underflow sets interrupt bits in ICR"
        }
      ]
    },
    {
      "start": 8614,
      "end": 8639,
      "name": "cia1_timer_usage_on_c64",
      "description": "How CIA #1 timers are used on the C64: Timer A generates the IRQ used for keyboard scanning and software clock updates; both timers are used for tape timing. Typical Timer A latch for IRQ is low=149, high=66 (total 17045) for ~1/60 second intervals (NTSC). Tape routines take over IRQ vectors for tape I/O and use CIA #1 Timers A and B for timing.",
      "references": [
        {
          "chunk": "cia_timers_register_behavior_and_timing",
          "topic": "timer latch and timing formula"
        },
        {
          "chunk": "irq_handler_and_keyscan",
          "topic": "IRQ driven keyboard scanning and software clock update"
        }
      ]
    },
    {
      "start": 8640,
      "end": 8640,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8641,
      "end": 8707,
      "name": "time_of_day_clock_tod_description_and_usage",
      "description": "Time Of Day (TOD) Clock in the 6526 CIA: four registers (tenths, seconds, minutes, hours) stored in BCD. Hours register Bit 7 is AM/PM flag (1=PM). Reading hours latches the TOD registers (stops updates) until tenths register is read; writing hours latches writes until tenths written. Control Register B bit 7 selects whether TOD writes change alarm or clock. OS uses TOD in BASIC RND(0) seed (but RND(0) is flawed due to TOD not started by OS and BCD limitations). TOD has an alarm that can trigger an interrupt.",
      "references": [
        {
          "chunk": "tod_registers_list",
          "topic": "addresses and bit layouts for TOD registers"
        },
        {
          "chunk": "ciaicr_interrupt_control",
          "topic": "TOD alarm interrupt source in ICR"
        }
      ]
    },
    {
      "start": 8708,
      "end": 8708,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8709,
      "end": 8727,
      "name": "basic_tod_digital_clock_example",
      "description": "A BASIC example demonstrating reading and setting the CIA TOD registers (PEEK/POKE at 56328-56331). Includes code to display and set hour, minute, second, and tenths on the screen and to initialize display formatting.",
      "references": [
        {
          "chunk": "time_of_day_clock_tod_description_and_usage",
          "topic": "how to read and write TOD registers"
        }
      ]
    },
    {
      "start": 8728,
      "end": 8728,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8729,
      "end": 8779,
      "name": "tod_registers_list_and_serial_data_port",
      "description": "TOD register addresses and bit mappings: TODTEN 56328 ($DC08), TODSEC 56329 ($DC09), TODMIN 56330 ($DC0A), TODHRS 56331 ($DC0B). Also describes CIA Serial Data Register (56332 $DC0C): serial bit-wise I/O using SP and CNT user port lines; Control Register A selects input or output modes; Timer A used as baud generator for output. The C64 doesn't use on-chip serial port for its serial I/O.",
      "references": [
        {
          "chunk": "time_of_day_clock_tod_description_and_usage",
          "topic": "TOD BCD and latch behavior"
        },
        {
          "chunk": "ciacra_control_register_a",
          "topic": "bit controlling serial port direction (Bit 6)"
        }
      ]
    },
    {
      "start": 8780,
      "end": 8845,
      "name": "ciaicr_interrupt_control",
      "description": "CIA Interrupt Control Register (56333 $DC0D) bit definitions: Bit 0 Timer A (read=underflow flag, write=enable/disable), Bit 1 Timer B, Bit 2 TOD alarm, Bit 3 Serial shift register, Bit 4 FLAG line, Bits 5-6 unused, Bit 7 global: on write determines set/clear behavior for bits written with 1; on read indicates whether any CIA source caused an interrupt. Reading clears the register. Examples: POKE 56333,127 disables all interrupts; POKE 56333,129 enables Timer A interrupt.",
      "references": [
        {
          "chunk": "ciacra_control_register_a",
          "topic": "control of Timer A behavior"
        },
        {
          "chunk": "ciacrb_control_register_b",
          "topic": "control of Timer B behavior"
        }
      ]
    },
    {
      "start": 8846,
      "end": 8900,
      "name": "ciacra_control_register_a",
      "description": "CIA Control Register A (56334 $DC0E) bit-by-bit: Bit 0 start/stop Timer A; Bit 1 select Timer A output on Port B (Bit 6); Bit 2 Port B output mode (toggle/pulse); Bit 3 Timer A one-shot/continuous; Bit 4 force load latched value to Timer A; Bit 5 Timer A input mode (count microprocessor cycles or CNT line); Bit 6 Serial Port mode (1=output,0=input); Bit 7 TOD frequency selection (1=50Hz,0=60Hz). Explains how Bits 0-3 control timer modes, Bits1-2 for Port B output toggling/pulsing, Bit4 forces load, Bit5 selects counting source, etc.",
      "references": [
        {
          "chunk": "data_port_b_timer_output",
          "topic": "effects of Bits 1-2 on Port B outputs"
        },
        {
          "chunk": "tod_registers_list_and_serial_data_port",
          "topic": "Bit 6 serial port direction and Bit 7 TOD frequency"
        }
      ]
    },
    {
      "start": 8901,
      "end": 8952,
      "name": "ciacrb_control_register_b_and_register_images",
      "description": "CIA Control Register B (56335 $DC0F) bit definitions and functions: Bit 0 start/stop Timer B; Bit 1 Timer B output on Port B (Bit7); Bit 2 Port B output mode (toggle/pulse); Bit 3 Timer B one-shot/continuous; Bit 4 force load Timer B; Bits 5-6 Timer B input mode (00=CPU cycles,01=CNT pulses,10=count Timer A underflows,11=count Timer A underflows when CNT pulses present); Bit 7 selects whether writing TOD registers sets alarm (1) or clock (0). Also notes CIA#1 register image mirroring across 256-byte block (each 16-byte area is mirrored) and recommends using base addresses.",
      "references": [
        {
          "chunk": "ciaicr_interrupt_control",
          "topic": "interaction of timer underflows and interrupt flags"
        }
      ]
    },
    {
      "start": 8953,
      "end": 8979,
      "name": "cia2_registers_introduction_and_usage_on_c64",
      "description": "Overview of CIA #2 (56576-56591 $DD00-$DD0F). CIA #2 is identical in chip function to CIA #1 but on C64 is used for Serial Bus, RS-232, and the User Port. Data Port A selects the 16K bank of VIC-II memory for video. CIA #2's interrupt line is wired to the 6510 NMI line (not IRQ), so its interrupts cannot be masked by SEI; use the NMI vector for routines driven by this chip.",
      "references": [
        {
          "chunk": "ci2pra_ci2prb",
          "topic": "CIA #2 Data Port A/B bit mappings"
        },
        {
          "chunk": "user_port_pinout",
          "topic": "User Port lines exposed by CIA #2"
        }
      ]
    },
    {
      "start": 8980,
      "end": 9056,
      "name": "serial_bus_rs232_and_user_port_overview",
      "description": "Detailed description of the Serial Bus, RS-232 and User Port usage via CIA #2 Data Ports. Serial Bus uses bits in Port A for data and clock in/out and ATN (Bits 5,7 data; Bits 4,6 clock; Bit 3 ATN). RS-232 uses Port A Bit 2 for data output and many Port B bits for RS-232 control/status (DSR, CTS, DCD, RI, DTR, RTS, SIN). The User Port exposes Port B lines and Port A Bit 2 for general TTL-level I/O and includes CNT and SP lines for serial ports and timer functions. Notes that CIA #2 timers are used mostly for RS-232 timing.",
      "references": [
        {
          "chunk": "ci2pra_ci2prb",
          "topic": "bit-level mapping of serial and RS-232 signals to CIA #2 ports"
        },
        {
          "chunk": "user_port_pinout",
          "topic": "User Port DB-25 / connector pin mapping"
        }
      ]
    },
    {
      "start": 9057,
      "end": 9063,
      "name": "cia2_pc2_handshaking_line",
      "description": "Describes CIA #2 PC2 handshaking line: it is accessible from the User Port and goes low for one cycle following a read or write of CIA #2 Port B. It signals external devices when data has been read or written.",
      "references": [
        {
          "chunk": "user_port_pinout",
          "topic": "pin mapping of PC2 on User Port"
        }
      ]
    },
    {
      "start": 9064,
      "end": 9106,
      "name": "vic_ii_memory_banking_bits_in_cia2_porta",
      "description": "Explains that Bits 0-1 of CIA #2 Port A select the 16K VIC-II video memory bank (00=bank3 $C000-$FFFF, 01=bank2 $8000-$BFFF, 10=bank1 $4000-$7FFF, 11=bank0 $0000-$3FFF). Describes default power-on bank (bottom 16K) and why you might change banks. Overview of what each 16K block contains and issues when VIC-II sees ROMs under certain banks (character generator ROM mapping), and notes the technique to change banks from BASIC.",
      "references": [
        {
          "chunk": "changing_vic_memory_banks_from_basic",
          "topic": "procedures and POKE examples to change bank and VIC registers"
        },
        {
          "chunk": "character_generator_rom_and_user_defined_chars",
          "topic": "character ROM visibility under different banks"
        }
      ]
    },
    {
      "start": 9107,
      "end": 9176,
      "name": "vic_memory_blocks_and_considerations_for_graphics",
      "description": "Detailed descriptions of the four 16K memory blocks (Block 0..3) for VIC-II use: Block 0 (system variables, BASIC text, character ROM visible at $1000-$1FFF limiting graphics), Block 1 (BASIC program storage - available for graphics but lacks character ROM), Block 2 (8K RAM under BASIC ROM and 8K BASIC ROM area \u2014 VIC sees RAM under ROM for display but BASIC can't read it), Block 3 (RAM under Kernal ROM and I/O - good for graphics but may conflict with DOS). Includes considerations: copying character ROM, limits for bitmap/screen usage, and conflicts with OS/DOS at specific addresses.",
      "references": [
        {
          "chunk": "vic_ii_memory_banking_bits_in_cia2_porta",
          "topic": "bank bit patterns and selection"
        },
        {
          "chunk": "changing_vic_memory_banks_from_basic",
          "topic": "how to change banks and set VIC-II pointers"
        }
      ]
    },
    {
      "start": 9177,
      "end": 9252,
      "name": "changing_vic_memory_banks_from_basic_and_sample_program",
      "description": "Step-by-step procedure to change VIC-II 16K bank from BASIC: (1) set Data Direction Register for outputs if needed, (2) POKE 56578,PEEK(56578) OR 3; POKE 56576,(PEEK(56576) AND 252) OR (3-BANK) to set bank bits, (3) set VIC-II character memory pointer (53272 $D018) with TK offset, (4) set display memory with K*16 in same register, (5) set OS pointer at 648 ($288) to actual screen address (POKE 648,AD/256). Warns about STOP/RESTORE interaction and suggests disabling RESTORE. Includes a full sample BASIC program with machine language helper to copy Character ROM to RAM, an interrupt fix for RESTORE, and data bytes for ML routines.",
      "references": [
        {
          "chunk": "user_defined_characters_and_multicolor_text",
          "topic": "after switching banks how to set character memory and define user character sets"
        }
      ]
    },
    {
      "start": 9253,
      "end": 9293,
      "name": "ci2pra_ci2prb_and_data_direction_defaults",
      "description": "CIA #2 Data Port Register A (56576 $DD00) and Data Port B (56577 $DD01) bit definitions: Bits 0-1 bank select, Bit2 RS-232 Sout (User Port pin M), Bit3 Serial Bus ATN, Bit4 Serial Bus clock out, Bit5 Serial Bus data out, Bit6 serial bus clock in, Bit7 serial bus data in. CI2PRB maps RS-232 SIN/RTS/DTR/RI/DCD/PB5/CTS/DSR and Timer outputs on Bits 6-7. Default Data Direction Register A = 63 (all outputs except bits 6-7), DDR B default = 0 (all inputs); RS-232 open changes Port B bits 1-2 to outputs.",
      "references": [
        {
          "chunk": "serial_bus_rs232_and_user_port_overview",
          "topic": "how Port A/B map to serial bus and RS-232 signals"
        }
      ]
    },
    {
      "start": 9294,
      "end": 9408,
      "name": "cia2_data_direction_timers_tod_and_serial_port",
      "description": "CIA #2 Data Direction Registers (56578-56579 $DD02-$DD03) Bit mappings (0=input,1=output). Timer registers TI2ALO/TI2AHI/TI2BLO/TI2BHI at 56580-56583 $DD04-$DD07 mirror CIA#1 timer functionality; CIA#2 TOD registers at 56584-56587 $DD08-$DD0B (BCD format) behave like CIA#1 but OS doesn't use them. CI2SDR (56588 $DD0C) serial data port exists but OS does not use it. CI2ICR (56589 $DD0D) Interrupt Control Register mirrors CIA#1 functionality; FLAG line on CIA#2 is accessible via User Port and can cause interrupts for handshaking.",
      "references": [
        {
          "chunk": "ci2pra_ci2prb_and_data_direction_defaults",
          "topic": "default DDR setups and RS-232 opening effects"
        },
        {
          "chunk": "ciaicr_interrupt_control",
          "topic": "interrupt control semantics similar to CIA #1"
        }
      ]
    },
    {
      "start": 9409,
      "end": 9464,
      "name": "cia2_control_registers_images_and_expansion_range",
      "description": "CIA #2 Control Registers: CI2CRA (56590 $DD0E) and CI2CRB (56591 $DD0F) mirror CIA#1 Control Register bits (start timer, output on Port B, pulse/toggle mode, one-shot/continuous, force load, input mode selection, serial port mode, TOD frequency/select alarm vs clock). Notes on CIA#2 register-image mirroring across 256-byte range (56592-56831 $DD10-$DDFF) and advice not to use mirrored addresses. Also covers reserved I/O expansion ranges (56832-57087 $DE00-$DEFF) and cartridge uses of that space (e.g., CP/M module, Simon's BASIC).",
      "references": [
        {
          "chunk": "cia2_data_direction_timers_tod_and_serial_port",
          "topic": "timer and TOD register addresses"
        },
        {
          "chunk": "reserved_io_expansion_and_cartridge_usage",
          "topic": "DE00 expansion area and cartridge control"
        }
      ]
    },
    {
      "start": 9465,
      "end": 9520,
      "name": "reserved_io_expansion_and_character_generator_rom_intro",
      "description": "Reserved I/O Expansion area (56832-57087 $DE00-$DEFF) accessible via Expansion Port pin 7 used by cartridges (examples: CP/M module, Simon's BASIC). Notes an alternate character generator ROM (53248-57343 $D000-$DFFF) description: ROM holds 4096 bytes = two complete 256-character sets (8 bytes/character), representing shape bitmaps (8x8), and how bytes map to pixel columns via bit positions (bit weights 1..128).",
      "references": [
        {
          "chunk": "character_rom_byte_examples_and_graphic_tools",
          "topic": "examples of bytes forming character graphics and BASIC program to display shapes"
        },
        {
          "chunk": "vic_memory_blocks_and_considerations_for_graphics",
          "topic": "where Character ROM is visible to VIC-II depending on bank"
        }
      ]
    },
    {
      "start": 9521,
      "end": 9618,
      "name": "character_rom_byte_examples_and_graphic_tools",
      "description": "Explains how each character is 8 bytes long representing an 8x8 bitmap, bit-value table for bits 0..7 (1..128). Provides example: first 8 bytes for '@' are 60,102,110,110,96,98,60,0 and breaks down bits to show pixels. Includes a BASIC program to display any ROM character shape (PEEK from 53248). Discusses VIC-II limitations and character ROM mapping into visible RAM spaces; suggests copying ROM to RAM for user-defined characters and describes multicolor text mode needing custom character sets (enabled by Bit 4 of 53270 $D016).",
      "references": [
        {
          "chunk": "vic_memory_blocks_and_considerations_for_graphics",
          "topic": "where to place user-defined characters in VIC-II banks"
        },
        {
          "chunk": "changing_vic_memory_banks_from_basic_and_sample_program",
          "topic": "sample ML/BASIC routines to copy ROM to RAM"
        }
      ]
    },
    {
      "start": 9619,
      "end": 9669,
      "name": "chapter7_kernal_rom_intro_and_ram_underlying_kernal",
      "description": "Start of Chapter 7: overview of 8K Operating System (Kernal ROM). Advises this is a guide and disassembly may be needed for full details. Notes 8K of RAM under Kernal ROM that can be used by switching out the ROM and that VIC-II may access RAM under Kernal when using top 16K bank. Mentions Kernal version differences/patches (locations 58541-58623 and 65371-67407) and changes like Color RAM initialization behavior on newer Kernal versions.",
      "references": [
        {
          "chunk": "kernal_routines_list",
          "topic": "table of Kernal routines and vector entries in the following sections"
        },
        {
          "chunk": "kernal_patches_and_iobase_functions",
          "topic": "later Kernal patches and IOBASE routine summary"
        }
      ]
    },
    {
      "start": 9670,
      "end": 9715,
      "name": "kernal_polynomial_routines_and_rnd_constants",
      "description": "Kernal ROM entries for BASIC math/evaluation routines: POLY1 (57411 $E043) and POLY2 (57433 $E059) for function series evaluation; RMULC (57485 $E08D) and RADDC (57490 $E092) multiplicative and additive constants for RND stored as five-byte floating point numbers; RND routine (57495 $E097) explaining how RND(X) behaves depending on argument sign (positive uses linear congruential-like multiply/add; negative scrambles argument to seed; zero seeds using Timer A and TOD registers but with issues on C64 because OS doesn't start TOD and BCD constraints).",
      "references": [
        {
          "chunk": "time_of_day_clock_tod_description_and_usage",
          "topic": "TOD registers and RND(0) seed source and limitations"
        }
      ]
    },
    {
      "start": 9716,
      "end": 9776,
      "name": "kernal_calls_for_basic_io_and_sys_save_load",
      "description": "Kernal routines used by BASIC: area to call Kernal I/O (57593 $E0F9) which handles CHROUT/CHRIN/CHKOUT/CHKIN/GETIN and buffers for RS-232; SYS (57642 $E12A) saves/restores .A,.X,.Y,.P around machine language calls; SAVE (57686 $E156) sets the save range and calls Kernal SAVE; VERIFY (57701 $E165) sets verify flag and falls through to LOAD; LOAD (57704 $E168) prepares and calls Kernal LOAD and relinks BASIC as needed. Notes LOAD behavior in programs (nonrelocating loads) and gives BASIC pattern to avoid re-running after nonrelocating LOAD.",
      "references": [
        {
          "chunk": "kernal_chrin_chrout_and_file_routines",
          "topic": "higher-level CHRIN/CHROUT/OPEN/CLOSE routines that follow"
        }
      ]
    },
    {
      "start": 9777,
      "end": 9871,
      "name": "kernal_math_trig_routines_and_constants",
      "description": "Kernal floating-point math routines: COS, SIN (57956 $E264 and 57960 $E268), TAN (58036 $E2B4) and associated constant tables for PI/2, 2*PI, 1/4 and SIN/TAN evaluation constants (58080-58095 $E2E0-$E2EF, 58095 contains SINCON table). Also ATN (58126 $E30E) and its constants ATNCON (58174 $E33E) tables. These implement trig and inverse trig via series and table constants.",
      "references": [
        {
          "chunk": "kernal_polynomial_routines_and_rnd_constants",
          "topic": "POLY routines used for series evaluation"
        }
      ]
    },
    {
      "start": 9872,
      "end": 9956,
      "name": "basic_initialization_warmstart_and_rnd_seed",
      "description": "BASIC initialization and start routines: Warm/Cool start entries (58235 $E37B warm start, 58260 $E394 cold start), INIT and INITAT (58303 $E3BF, 58274 $E3A2) copying CHRGET routine to page 0, initial RND seed value (59298 $E3BA) and INIT which initializes BASIC zero-page locations. Print BASIC startup messages routine (58402 $E422), vectors table and copying BASIC vectors to RAM (58439 $E447, 58451 $E453), and power-up messages stored at 58464 $E460.",
      "references": [
        {
          "chunk": "chapter7_kernal_rom_intro_and_ram_underlying_kernal",
          "topic": "context for routines executed on power-up and RAM under Kernal"
        }
      ]
    },
    {
      "start": 9957,
      "end": 10020,
      "name": "kernal_patches_iobase_and_screen_plot_routines",
      "description": "Kernal patches area (58551-58623 $E4B7-$E4FF) with fixes for compatibility and bug patches (example at 58541 $E4AD). IOBASE (58624 $E500) documented routine to return base address of I/O in .X/.Y (current returns X=0,Y=$DC pointing to CIA#1). SCREEN (58629 $E505) returns screen columns (.X) and rows (.Y). PLOT (58634 $E50A) documented routine to read/set cursor position via .X/.Y and carry flag. These routines are vectored to support portability.",
      "references": [
        {
          "chunk": "ciapra_ciaprb_registers_cia1_data_ports",
          "topic": "IOBASE returns CIA base address used for port access"
        },
        {
          "chunk": "changing_vic_memory_banks_from_basic_and_sample_program",
          "topic": "SCREEN/PLOT interplay when changing screen pointers"
        }
      ]
    },
    {
      "start": 10021,
      "end": 10120,
      "name": "screen_keyboard_initialization_and_chr_routines",
      "description": "Kernal screen and keyboard initialization routines (58648 $E518 Initialize Screen & Keyboard, 58692 $E544 initialize screen line link table and clear screen). CHROUT/CHRIN support: LP2 (58804 $E5B4) get char from keyboard buffer, routines to wait for CR/read input line (58826 $E5CA), and CHRIN screen/keyboard handling (58930 $E632). Also routines for quote checking, add character to screen, return from CHROUT screen output, advance cursor, scrolling, insert blank lines, and moving screen lines (various addresses between 59012..59888).",
      "references": [
        {
          "chunk": "kernal_polynomial_routines_and_rnd_constants",
          "topic": "misc math routines unrelated but nearby in Kernal mapping"
        },
        {
          "chunk": "kernal_chrin_chrout_and_file_routines",
          "topic": "higher-level I/O routines calling these screen/keyboard handlers"
        }
      ]
    },
    {
      "start": 10121,
      "end": 10220,
      "name": "screen_store_color_ram_and_irq_keyscan",
      "description": "Screen write and Color RAM synchronization routines: Store to screen (59932 $EA1C, 59940 $EA24), synchronize Color RAM pointer to screen (59940 $EA24), clear screen line and cursor blink timing (59903 $E9FF, 59923 $EA13). IRQ entry (59953 $EA31) is main IRQ handler called by CIA#1 Timer A (~1/60s) to update software clock, cursor flash, tape interlock and call keyboard scan routine (SCNKEY 60039 $EA87). SCNKEY reads keyboard via CIA#1 and decodes keycodes into PETASCII.",
      "references": [
        {
          "chunk": "cia1_timer_usage_on_c64",
          "topic": "Timer A used to generate the IRQ which drives keyscan and software clock"
        },
        {
          "chunk": "keyboard_decode_tables_and_vectors",
          "topic": "where keycodes are translated into PETASCII tables"
        }
      ]
    },
    {
      "start": 10221,
      "end": 10320,
      "name": "keyboard_decode_tables_and_vectors",
      "description": "Keyboard decoding and tables: SCNKEY (60039 $EA87) reads keyboard and returns keycode; routines decode keystroke and place ASCII in keyboard buffer (60128 $EAE0), set up proper keyboard decode table (60232 $EB48) which chooses among four 64-entry PETASCII decode tables (standard 60289 $EB81, SHIFT 60354 $EBC2, Commodore Logo 60419 $EC03, CONTROL 60536 $EC78). Also includes keyboard decode table vectors (60281 $EB79) and handling of SHIFT/Logo toggles to change character set (SET LOWERCASE/UPPERCASE 60484 $EC44 and related toggles).",
      "references": [
        {
          "chunk": "character_rom_byte_examples_and_graphic_tools",
          "topic": "switching character sets may require mapping character ROM/pointers"
        }
      ]
    },
    {
      "start": 10321,
      "end": 10420,
      "name": "serial_bus_kernal_routines_talk_listen_cioout",
      "description": "Kernal routines for Serial Bus operations: TALK (60681 $ED09) and LISTEN (60684 $ED0C) documented routines to command devices on serial bus, subroutines to send command codes and bytes (60689 $ED11, 60736 $ED40), CIOUT (60893 $EDDD) to send a byte over serial bus (buffers bytes and sends final byte with EOI on UNLISTEN), UNTLK (60911 $EDEF), UNLSN (60926 $EDFE), ACPTR (60947 $EE13) to receive a byte from a TALKer. Time-out/Error handler (60848 $EDB0) handles device non-responses. SECOND/TKSA documented functions (60857 $EDB9, 60871 $EDC7) to send secondary addresses.",
      "references": [
        {
          "chunk": "serial_bus_rs232_and_user_port_overview",
          "topic": "Serial Bus signals and their mapping to CIA #2 ports"
        }
      ]
    },
    {
      "start": 10421,
      "end": 10520,
      "name": "rs232_bit_control_and_nmi_related_routines",
      "description": "RS-232 line-control subroutines: routines to set serial clock line low/high (61061 $EE85, 61070 $EE8E), set serial data output low (61079 $EE97), read serial bus data and clock bits into processor flags (61097 $EEA9). 1 msec delay, NMI-driven RS-232 send/receive bit routines (61107 $EEB3, 61115 $EEBB), RS-232 error handler (61230 $EF2E), set word length for RS-232 characters (61258 $#F4A), and NMI handlers to receive/send RS-232 bits (61273 $EF59 and 61273+).",
      "references": [
        {
          "chunk": "cia2_control_registers_images_and_expansion_range",
          "topic": "CIA #2 timers and NMI mapping for RS-232 timing"
        }
      ]
    },
    {
      "start": 10521,
      "end": 10620,
      "name": "rs232_chkin_chkrout_getin_and_cio_handling",
      "description": "Kernal RS-232 device-specific routines: CHKOUT/CHKIN/GETIN implementations for RS-232 logical files (61409 $EFE1 CHKOUT entry, 61460 $F014 CHROUT for RS-232, 61517 $F04D CHKIN, 61574 $F086 GETIN). These routines handle defining logical files for RS-232, sending/receiving bytes, checking for buffer empty/overrun and error conditions. Also a routine to stop CIA #2 NMIs for serial/cassette timing-critical operations (61604 $F0A4).",
      "references": [
        {
          "chunk": "serial_bus_kernal_routines_talk_listen_cioout",
          "topic": "higher-level serial bus I/O uses these subroutines"
        }
      ]
    },
    {
      "start": 10621,
      "end": 10720,
      "name": "cassette_routines_and_i_o_setup",
      "description": "Cassette/tape I/O related Kernal routines: routines to manage tape buffers and I/O: messages and control (61629 $F0BD Kernal control messages text stored at 61629 $F0BD), printing messages when file found or searching (61739 $F12B), GETIN CHRIN/CHROUT documented jump table entries and behavior regarding keyboard/screen vs devices (61758 $F13E GETIN, 61783 $F157 CHRIN, 61898 $F1CA CHROUT), and OPEN/CLOSE file operations calling Kernal (57790 $E1BE OPEN, 57799 $E1C7 CLOSE).",
      "references": [
        {
          "chunk": "kernal_chrin_chrout_and_file_routines",
          "topic": "OPEN/CLOSE/SETNAM/SETLFS interactions with tape and serial I/O"
        }
      ]
    },
    {
      "start": 10721,
      "end": 10820,
      "name": "tape_io_handlers_irq_and_timing",
      "description": "Tape I/O implementation details: routines to find tape file headers, write/read tape blocks, set timers (Timer B) and IRQ vectors for tape I/O (63605 $F875 common code, 63696 $F8D0 STOP key test during tape I/O, 63714 $F8E2 adjust CIA#1 Timer A for tape bit timing, 63788 $F92C Read Tape Data (IRQ), 64096 $FA60 receive/store next cassette character). Also routines to toggle tape data output line (64422 $FBA6) using CIA#1 Timer B/CNT and 6510 port bit toggles.",
      "references": [
        {
          "chunk": "cia_timers_register_behavior_and_timing",
          "topic": "how timers are used for cassette bit timing"
        }
      ]
    },
    {
      "start": 10821,
      "end": 10920,
      "name": "power_on_reset_autostart_and_vector_routines",
      "description": "Power-On Reset routine (64738 $FCE2) executed on reset: sets interrupt disable, stack pointer, tests for autostart cartridge and jumps to cold start vector if found, else initializes Kernal (IOINIT, RAMTAS, RESTOR, CINT) and enters BASIC cold start. Autostart cartridge check (64770 $FD02 and 64784 $FD10) looks for 'CBM80' pattern in cartridge header. RESTOR routine (64789 $FD15) restores RAM vectors for default I/O, and VECTOR (64794 $FD1A) sets RAM vector table from table pointed by .X/.Y allowing save/restore of vector tables (recommend SEI/CLI around VECTOR calls).",
      "references": [
        {
          "chunk": "kernal_patches_iobase_and_screen_plot_routines",
          "topic": "IOINIT is called during reset to initialize CIAs and VIC defaults"
        }
      ]
    },
    {
      "start": 10921,
      "end": 11020,
      "name": "ramtas_ioinit_setnam_setlfs_and_memtop_membot",
      "description": "RAM initialization and top/bottom pointers: RAMTAS (64848 $FD50) clears page 0,2,3, sets tape buffer pointer, non-destructively tests RAM to determine top of RAM pointer (stored at 643-4), sets bottom of RAM pointer (641-642) to $800, and sets screen pointer at 648 ($288)=4. Table of IRQ vectors (64923 $FD9B) lists vectors used for cassette write/read and normal keyscan IRQ. IOINIT (64931 $FDA3) initializes CIAs and turns SID volume off and sets CIA#1 Timer A for 1/60s. SETNAM (65017 $FDF9) and SETLFS (65024 $FE00) are documented Kernal routines to set filename parameters and logical file/device/secondary address. MEMTOP (65061 $FE25) and MEMBOT (65076 $FE34) read/set top and bottom of RAM pointers via .X/.Y and carry flag.",
      "references": [
        {
          "chunk": "tape_io_handlers_irq_and_timing",
          "topic": "tape buffer pointer and RAMTAS setup for tape I/O"
        },
        {
          "chunk": "changing_vic_memory_banks_from_basic_and_sample_program",
          "topic": "MEMTOP may be used when manipulating memory pointers for screen and BASIC"
        }
      ]
    },
    {
      "start": 11021,
      "end": 11120,
      "name": "nmi_brk_handlers_and_rs232_baud_tables",
      "description": "NMI interrupt entry point (65091 $FE43): handles NMI by jumping through RAM vector at 792 ($318). Standard handler checks if RS-232 caused NMI; otherwise treats as RESTORE. BRK warm start (65126 $FE66) handles STOP/RESTORE combo. NMI RS-232 handler (65138 $FE72) handles RS-232 bit send/receive. RS-232 baud rate tables for NTSC (65218 $FEC2) provide prescaler values for baud rates; formula for prescaler: ((CLOCK/BAUD)/2)-100 where CLOCK is CPU clock (NTSC 1,022,730 Hz, PAL 985,250 Hz).",
      "references": [
        {
          "chunk": "rs232_bit_control_and_nmi_related_routines",
          "topic": "NMI is used for RS-232 bit timing via CIA#2 timers"
        },
        {
          "chunk": "cia2_control_registers_images_and_expansion_range",
          "topic": "CIA#2 timers control RS-232 NMIs"
        }
      ]
    },
    {
      "start": 11121,
      "end": 11134,
      "name": "tape_motor_and_pointer_routines",
      "description": "Tape-related Kernal routines: 'Turn Off the Tape Motor' (heading), 'Check the Tape Read/Write Pointer' (compares current and ending tape read/write addresses), and 'Advance the Tape Read/Write Pointer' (increments the current read/write pointer by one byte).",
      "references": [
        {
          "chunk": "ramtas_ram_test_and_memory_pointers",
          "topic": "initializes tape buffer pointer and top/bottom of RAM"
        },
        {
          "chunk": "irq_vector_table",
          "topic": "IRQ vectors that point to cassette read/write routines"
        }
      ]
    },
    {
      "start": 11135,
      "end": 11150,
      "name": "power_on_reset_routine",
      "description": "Power-on RESET routine behavior (vector at $FFFC): sets interrupt disable, stack pointer, clears decimal flag, tests for autostart cartridge and jumps to cartridge cold start if present; otherwise calls Kernal init routines (IOINIT, RAMTAS, RESTOR, CINT), clears interrupt disable, and enters BASIC via the cold start vector.",
      "references": [
        {
          "chunk": "autostart_cartridge_check_and_signature_text",
          "topic": "autostart cartridge test and required signature text"
        },
        {
          "chunk": "ioinit_initialize_cia_and_sid",
          "topic": "CIA/SID initialization called during RESET"
        },
        {
          "chunk": "ramtas_ram_test_and_memory_pointers",
          "topic": "RAM test and pointer setup called during RESET"
        },
        {
          "chunk": "restore_and_vector_table_management",
          "topic": "RESTOR called from RESET to restore RAM vectors"
        }
      ]
    },
    {
      "start": 11151,
      "end": 11165,
      "name": "autostart_cartridge_check_and_signature_text",
      "description": "Autostart cartridge detection: routine compares characters at $8004-$8008 (locations 32772-32776) to a 5-character signature. The required signature is the PETASCII values for 'CBM' with the high bit set (+128) followed by the characters '80'. Zero flag set on match.",
      "references": [
        {
          "chunk": "power_on_reset_routine",
          "topic": "RESET calls this check to decide cartridge cold-start behavior"
        }
      ]
    },
    {
      "start": 11166,
      "end": 11200,
      "name": "restore_and_vector_table_management",
      "description": "RESTOR and VECTOR Kernal routines and the ROM table of default RAM vectors: RESTOR restores the 16 RAM vectors for I/O to their default ROM values; VECTOR reads or writes the 16 RAM vectors using the address in X/Y and the Carry flag to select store/load operations; includes note about executing SEI/CLI around VECTOR. Also documents the ROM table of default vectors at $FD30.",
      "references": [
        {
          "chunk": "ramtas_ram_test_and_memory_pointers",
          "topic": "RAM initialization that complements vector setup"
        },
        {
          "chunk": "ioinit_initialize_cia_and_sid",
          "topic": "I/O initialization affected by vector values"
        },
        {
          "chunk": "power_on_reset_routine",
          "topic": "RESET calls RESTOR/VECTOR as part of initialization"
        }
      ]
    },
    {
      "start": 11201,
      "end": 11216,
      "name": "ramtas_ram_test_and_memory_pointers",
      "description": "RAMTAS routine (RAM Test and Set Pointers): clears zero page and pages 2 and 3, sets tape buffer pointer to $33C, performs nondestructive RAM test from $0400 upwards to determine top of RAM (stores in top-of-RAM pointer), sets bottom-of-RAM pointer to $0800 (start of BASIC program text), and sets the screen memory pointer used by the OS.",
      "references": [
        {
          "chunk": "power_on_reset_routine",
          "topic": "RAMTAS is called during system RESET"
        },
        {
          "chunk": "tape_motor_and_pointer_routines",
          "topic": "tape buffer pointer initialized here"
        }
      ]
    },
    {
      "start": 11217,
      "end": 11217,
      "ignore": true,
      "reason": "Trailing blank lines after RAMTAS section \u2014 non-technical"
    },
    {
      "start": 11218,
      "end": 11225,
      "name": "irq_vector_table",
      "description": "Table of IRQ vectors: contains four IRQ vectors used by the system \u2014 pointing to cassette write part 1, cassette write part 2, the standard scan keyboard IRQ, and the cassette read routine.",
      "references": [
        {
          "chunk": "tape_motor_and_pointer_routines",
          "topic": "IRQ entries reference cassette read/write routines"
        },
        {
          "chunk": "ioinit_initialize_cia_and_sid",
          "topic": "IRQ timing setup (CIA timers) is part of system I/O initialization"
        }
      ]
    },
    {
      "start": 11226,
      "end": 11226,
      "ignore": true,
      "reason": "Blank lines separating the IRQ vector table from the next entry; non-technical spacing."
    },
    {
      "start": 11227,
      "end": 11235,
      "name": "ioinit_initialize_cia_and_sid",
      "description": "IOINIT routine: initializes the Complex Interface Adapter (CIAs), turns SID volume off, and as part of initialization sets CIA #1 Timer A to generate IRQs at 1/60 second intervals.",
      "references": [
        {
          "chunk": "power_on_reset_routine",
          "topic": "IOINIT is called during RESET"
        },
        {
          "chunk": "irq_vector_table",
          "topic": "IRQ vectors used together with CIA timer interrupts"
        }
      ]
    },
    {
      "start": 11236,
      "end": 11246,
      "name": "setnam_set_filename_parameters",
      "description": "SETNAM routine: sets filename parameters for file operations. Stores the string length from A to the filename-length location and stores the pointer to the ASCII filename from X/Y into the filename pointer locations; prepares for OPEN, LOAD, or SAVE.",
      "references": [
        {
          "chunk": "setlfs_set_logical_file_device_secondary",
          "topic": "SETLFS sets device, file number, and secondary address used with SETNAM"
        }
      ]
    },
    {
      "start": 11247,
      "end": 11247,
      "ignore": true,
      "reason": "Blank lines between routines; non-technical formatting."
    },
    {
      "start": 11248,
      "end": 11261,
      "name": "setlfs_set_logical_file_device_secondary",
      "description": "SETLFS routine: sets the current logical file number (from A), device number (from X), and secondary address (from Y) for subsequent OPEN, LOAD, or SAVE operations. Set Y=$FF if no secondary address is used.",
      "references": [
        {
          "chunk": "setnam_set_filename_parameters",
          "topic": "SETNAM and SETLFS are used together to prepare file operations"
        },
        {
          "chunk": "readst_read_io_status_word",
          "topic": "I/O status affected by device operations initiated after SETLFS"
        }
      ]
    },
    {
      "start": 11262,
      "end": 11262,
      "ignore": true,
      "reason": "Blank lines between routines; non-technical formatting."
    },
    {
      "start": 11263,
      "end": 11275,
      "name": "readst_read_io_status_word",
      "description": "READST routine: returns the I/O status word (in A) which records I/O errors; if the device was RS-232, its status register is also read and cleared. See device-specific status code entries for meanings.",
      "references": [
        {
          "chunk": "rs232_receive_next_bit_nmi",
          "topic": "RS-232 routines and status affected by NMI-driven RS-232 handling"
        },
        {
          "chunk": "setlfs_set_logical_file_device_secondary",
          "topic": "READST is used after device file operations"
        }
      ]
    },
    {
      "start": 11276,
      "end": 11296,
      "name": "setmsg_message_control_flag",
      "description": "SETMSG routine: controls Kernal printing of control messages and error messages via bits in the message control flag. Bit 6 controls general Kernal control messages (SEARCHING FOR, LOADING, etc.); Bit 7 controls Kernal error messages. Describes which messages are suppressed or printed and notes BASIC's separate message handling.",
      "references": [
        {
          "chunk": "power_on_reset_routine",
          "topic": "message control flag behavior during system initialization and BASIC operation"
        },
        {
          "chunk": "readst_read_io_status_word",
          "topic": "I/O errors relate to messages controlled by SETMSG"
        }
      ]
    },
    {
      "start": 11297,
      "end": 11312,
      "name": "settmo_ieee_timeout_flag",
      "description": "SETTMO routine: sets the IEEE bus time-out flag (entered via jump table). Loading A < 128 enables timeouts (64 ms wait for device response), A >= 128 disables timeouts. Intended for use with Commodore IEEE add-on card.",
      "references": [
        {
          "chunk": "setlfs_set_logical_file_device_secondary",
          "topic": "SETLFS and SETTMO both affect device I/O behavior"
        }
      ]
    },
    {
      "start": 11313,
      "end": 11324,
      "name": "memtop_read_set_top_of_ram_pointer",
      "description": "MEMTOP routine: read or set the top-of-RAM pointer. If called with Carry set, the pointer is loaded into X/Y; if Carry clear, the pointer is set from X/Y.",
      "references": [
        {
          "chunk": "ramtas_ram_test_and_memory_pointers",
          "topic": "RAMTAS initializes top-of-RAM pointer determined during RAM test"
        },
        {
          "chunk": "membot_read_set_bottom_of_ram_pointer",
          "topic": "MEMBOT is the complementary routine for bottom-of-RAM"
        }
      ]
    },
    {
      "start": 11325,
      "end": 11335,
      "name": "membot_read_set_bottom_of_ram_pointer",
      "description": "MEMBOT routine: read or set the bottom-of-RAM pointer. If called with Carry set, the pointer is loaded into X/Y; if Carry clear, the pointer is set from X/Y.",
      "references": [
        {
          "chunk": "memtop_read_set_top_of_ram_pointer",
          "topic": "MEMTOP/MEMBOT together manage RAM top/bottom pointers"
        },
        {
          "chunk": "ramtas_ram_test_and_memory_pointers",
          "topic": "RAMTAS initializes bottom-of-RAM pointer during system init"
        }
      ]
    },
    {
      "start": 11336,
      "end": 11336,
      "ignore": true,
      "reason": "Blank lines between routines; non-technical formatting."
    },
    {
      "start": 11337,
      "end": 11355,
      "name": "nmi_interrupt_entry_point",
      "description": "NMI entry point (vector at $FFFA): NMI handler sets Interrupt disable, jumps through RAM vector at $318 to continuation. Standard handler checks whether NMI was caused by RS-232; if not, assumes RESTORE key and checks for autostart cartridge, STOP key and BRK execution as appropriate; RS-232-caused NMIs bypass some checks and proceed to RS-232 bit timing checks.",
      "references": [
        {
          "chunk": "nmi_rs232_handler",
          "topic": "continuation of NMI processing for RS-232 bit timing"
        },
        {
          "chunk": "power_on_reset_routine",
          "topic": "cartridge/keyboard checks similar to RESET behavior"
        },
        {
          "chunk": "brk_warm_start_routine",
          "topic": "BRK routine invoked in some NMI conditions (STOP+RESTORE)"
        }
      ]
    },
    {
      "start": 11356,
      "end": 11364,
      "name": "brk_warm_start_routine",
      "description": "BRK (Warm Start) routine: executed on STOP/RESTORE combination or BRK vector; calls Kernal initialization routines RESTOR, IOINIT and part of CINT, then exits through the BASIC warm start vector.",
      "references": [
        {
          "chunk": "restore_and_vector_table_management",
          "topic": "RESTOR is called by BRK to restore RAM vectors"
        },
        {
          "chunk": "ioinit_initialize_cia_and_sid",
          "topic": "IOINIT called by BRK as part of reinitialization"
        }
      ]
    },
    {
      "start": 11365,
      "end": 11371,
      "name": "nmi_rs232_handler",
      "description": "NMI RS-232 handler (continuation): checks if it's time to send or receive a bit on the RS-232 channel and performs the appropriate action when the RS-232 timer indicates a bit period.",
      "references": [
        {
          "chunk": "rs232_baud_rate_tables_ntsc",
          "topic": "uses baud rate prescaler values and timing formulas to decide interrupt timing"
        },
        {
          "chunk": "rs232_receive_next_bit_nmi",
          "topic": "calls subroutine to receive the next RS-232 bit"
        }
      ]
    },
    {
      "start": 11372,
      "end": 11392,
      "name": "rs232_baud_rate_tables_ntsc",
      "description": "RS-232 baud rate prescaler table for NTSC machines: contains prescaler values for standard baud rates (50 up to 2400). Explains formula used for timer reload: ((CLOCK/BAUD)/2)-100, and notes NTSC clock (1,022,730 Hz) vs PAL (985,250 Hz) requiring a separate PAL table.",
      "references": [
        {
          "chunk": "nmi_rs232_handler",
          "topic": "NMI-driven RS-232 handling uses these prescalers for timing"
        },
        {
          "chunk": "rs232_receive_next_bit_nmi",
          "topic": "receive routine uses timing determined by the baud-rate table"
        }
      ]
    },
    {
      "start": 11393,
      "end": 11393,
      "ignore": true,
      "reason": "Blank lines separating RS-232 baud table text from the next routine; non-technical spacing."
    },
    {
      "start": 11394,
      "end": 11399,
      "name": "rs232_receive_next_bit_nmi",
      "description": "RS-232 'Receive the Next Bit' NMI subroutine: called by the NMI handler to input the next RS-232 data bit and then calls the next subroutine to reload the timer that causes subsequent interrupts.",
      "references": [
        {
          "chunk": "nmi_rs232_handler",
          "topic": "invoked from the NMI RS-232 handler when a bit period occurs"
        },
        {
          "chunk": "rs232_baud_rate_tables_ntsc",
          "topic": "timer reload values are derived from the baud-rate table"
        }
      ]
    },
    {
      "start": 11400,
      "end": 11400,
      "ignore": true,
      "reason": "Blank lines between RS-232 subroutine and following entries; non-technical formatting."
    },
    {
      "start": 11401,
      "end": 11403,
      "name": "load_timer_with_prescaler_values",
      "description": "Routine to load CIA timer with prescaler values obtained from the RS-232 baud rate lookup table.",
      "references": [
        {
          "chunk": "rs232_baud_rate_tables_ntsc",
          "topic": "reads prescaler values from the NTSC baud table"
        }
      ]
    },
    {
      "start": 11404,
      "end": 11423,
      "name": "main_irq_brk_interrupt_entry_point",
      "description": "Main IRQ/BRK entry at $FF48 (65352); hardware IRQ/BRK vector at $FFFE (65534) points here. Saves A/X/Y on stack, tests BRK bit of status (.P) to determine BRK vs IRQ. If BRK, exits through RAM BRK vector at $0316 (790). Otherwise exits through RAM IRQ vector at $0314 (788), typically to keyboard-scan handler at $EA31 (59953). When installing custom handlers into these vectors, ensure saved registers are pulled from stack before returning.",
      "references": [
        {
          "chunk": "irq_vector_table_overview",
          "topic": "system IRQ vector table references standard IRQ routines"
        },
        {
          "chunk": "scnkey_scan_keyboard",
          "topic": "IRQ usually vectored to keyboard scan routine"
        }
      ]
    },
    {
      "start": 11424,
      "end": 11432,
      "name": "kernal_patches_pal_ntsc_timer_compensation",
      "description": "Patched area in later Kernal versions (locations $FF5B-$FF7F area) used to detect PAL vs NTSC and compensate timing so the 1/60s IRQ is accurate on both systems.",
      "references": [
        {
          "chunk": "cint_initialize_screen_editor_and_vic_ii_chip",
          "topic": "CINT contains the PAL/NTSC detection patch"
        }
      ]
    },
    {
      "start": 11433,
      "end": 11452,
      "name": "cint_initialize_screen_editor_and_vic_ii_chip",
      "description": "CINT routine at $FF5B (65371, entry via jump table $FF81 / 65409). Initializes the VIC-II to defaults, sets keyboard as input and screen as output, initializes cursor flash vars, builds screen line link table, clears screen, and homes cursor. Newer Kernal versions include a PAL/NTSC test (via raster compare status) and set PAL/NTSC flag at location 678 ($2A6), then programs CIA #1 Timer A with appropriate prescaler values for 1/60s IRQ.",
      "references": [
        {
          "chunk": "kernal_patches_pal_ntsc_timer_compensation",
          "topic": "patch code used in CINT for PAL/NTSC detection"
        }
      ]
    },
    {
      "start": 11453,
      "end": 11453,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11454,
      "end": 11459,
      "name": "cint_timing_patch_end",
      "description": "End-of-routine patch bytes that adjust for the extra length of the updated CINT routine to ensure correct timer setup for 1/60s IRQ.",
      "references": [
        {
          "chunk": "cint_initialize_screen_editor_and_vic_ii_chip",
          "topic": "continues/finishes the CINT initialization and PAL/NTSC timer setup"
        }
      ]
    },
    {
      "start": 11460,
      "end": 11460,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11461,
      "end": 11471,
      "name": "kernal_version_identifier_byte",
      "description": "Kernal version identifier byte at $FF80 (65408). First version used $AA (170); later common version uses 0. The PET 64 uses $64 (100) so software (e.g., Commodore 64 logo) can detect PET 64 and adjust display.",
      "references": []
    },
    {
      "start": 11472,
      "end": 11472,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11473,
      "end": 11499,
      "name": "kernal_jump_table_description",
      "description": "Description of the Kernal jump table area ($FF81-$FFF5 / 65409-65525). Each 3-byte entry is a JMP instruction and an address; programs should call through these stable entry points to be robust across OS/ROM revisions. The first 15 entries ($FFC0-$FFEA / 65472-65514) are consistent across Commodore machines. Some routines are also vectored through the RAM vector table at $0314-$031A (788-794) which can be changed in RAM.",
      "references": [
        {
          "chunk": "kernal_jump_table_entries_list",
          "topic": "detailed list of jump table entries and meanings"
        },
        {
          "chunk": "ram_vector_table_and_custom_vectors",
          "topic": "RAM vectors referenced as alternative vectoring points"
        }
      ]
    },
    {
      "start": 11500,
      "end": 11539,
      "name": "kernal_jump_table_entries_list",
      "description": "List of Kernal jump table entries ($FF81-$FFF3 / 65409-65523) with names, RAM vectors, ROM addresses, and short descriptions. Includes CINT, IOINIT, RAMTAS, RESTOR, VECTOR, SETMSG, SECOND, TKSA, MEMTOP, MEMBOT, SCNKEY, SETTMO, ACPTR, CIOUT, UNTLK, UNLSN, LISTEN, TALK, READST, SETLFS, SETNAM, OPEN, CLOSE, CHKIN, CHKOUT, CLRCHN, CHRIN, CHROUT, LOAD, SAVE, SETTIM, RDTIM, STOP, GETIN, CLALL, UDTIM, SCREEN, PLOT, IOBASE. (Entries listed with both jump-table and referenced vector/addresses.)",
      "references": [
        {
          "chunk": "kernal_jump_table_description",
          "topic": "explains why to use these entries"
        },
        {
          "chunk": "ram_vector_table_and_custom_vectors",
          "topic": "some entries are also vectored through RAM for customization"
        }
      ]
    },
    {
      "start": 11540,
      "end": 11563,
      "name": "6510_hardware_vectors",
      "description": "The 6510 CPU reserves last six bytes of memory for three hardware vectors: NMI vector at $FFFA (65530) points to main NMI routine ($FE43 / 65091); System Reset (RES) vector at $FFFC (65532) points to power-on routine ($FCE2 / 64738); IRQ/BRK vector at $FFFE (65534) points to main IRQ handler ($FF48 / 65352). These tell the CPU where to start execution for NMI, RES, and IRQ/BRK events.",
      "references": [
        {
          "chunk": "nmi_interrupt_entry_point",
          "topic": "NMI vector target"
        },
        {
          "chunk": "main_irq_brk_interrupt_entry_point",
          "topic": "IRQ/BRK vector target"
        }
      ]
    },
    {
      "start": 11564,
      "end": 11642,
      "name": "appendix_a_beginner_guide_to_typing_in_programs",
      "description": "Appendix A: Beginner's guide to typing in programs. Explains what a program is, BASIC programs, importance of exact typing (characters, punctuation, spacing), use of braces for special characters, DATA statements caveats (typos can crash machine), saving frequently, and a 'Get to Know Your Machine' checklist. Contains a short 'A Quick Review' checklist of typing and checking lines before running.",
      "references": []
    },
    {
      "start": 11643,
      "end": 11697,
      "name": "appendix_b_how_to_type_in_programs_conventions",
      "description": "Appendix B: Listing conventions for typing programs. Explains notation: braces { } for special characters (e.g., {DOWN}), underlining for shifted keys, [<>] for Commodore key combinations, {A} for CTRL-A, and explains quote mode for programmable cursor control and insertion. Advises pressing RETURN to exit quote mode.",
      "references": [
        {
          "chunk": "appendix_b_cursor_and_color_control_table",
          "topic": "table showing how to type cursor and color control keys"
        }
      ]
    },
    {
      "start": 11698,
      "end": 11718,
      "name": "appendix_b_cursor_and_color_control_table",
      "description": "Appendix B table mapping printed control names to keys to press. Examples: [CLR] -> SHIFT CLR/HOME, [HOME] -> CLR/HOME, [UP] -> SHIFT CRSR UP/DOWN, [LEFT] -> SHIFT CRSR LEFT/RIGHT, [BLU] -> CTRL 7, and special bracketed [<n>] entries mapped to Commodore key combinations (C= n). Also relates function keys F1-F8 and shifted variants.",
      "references": []
    },
    {
      "start": 11719,
      "end": 11756,
      "name": "appendix_c_screen_location_table",
      "description": "Appendix C: Screen Location Table showing the memory addresses for screen RAM by row and column. Example: Row 0 addresses 1024, 1064, 1104, 1144, 1184; subsequent rows and their addresses are listed up to Row 24, and columns 0..39 mapping. Useful for converting row/column to screen memory address.",
      "references": [
        {
          "chunk": "appendix_d_screen_color_memory_table",
          "topic": "color RAM addresses correspond to screen location mapping"
        }
      ]
    },
    {
      "start": 11757,
      "end": 11797,
      "name": "appendix_d_screen_color_memory_table",
      "description": "Appendix D: Screen color memory table shows color RAM addresses by screen row and column (color RAM starts at 55296 = $D800). Lists addresses for each 5-line block and column mapping 0..39. Use these addresses to POKE per-character foreground color values.",
      "references": [
        {
          "chunk": "appendix_e_screen_color_codes",
          "topic": "color values to POKE into color RAM are listed in Appendix E"
        }
      ]
    },
    {
      "start": 11798,
      "end": 11863,
      "name": "appendix_e_screen_color_codes_and_poking_locations",
      "description": "Appendix E: Color codes and where to POKE them. Lists low-nybble, high-nybble, and multicolor-select values for colors Black..Light Gray (numeric values like 0..15 and their high-nybble equivalents). Describes where to POKE color values depending on mode: border color at 53280, text/extended/multicolor/bitmap modes and which addresses (53281..53284, color RAM at $D800, screen memory at $0400) and whether to use low/high nybbles or OR high/low nybbles for bitmap modes. Notes on extended color mode bit usage (bits 6-7) and bitmap OR behavior.",
      "references": [
        {
          "chunk": "appendix_d_screen_color_memory_table",
          "topic": "use these addresses with the color codes listed here"
        }
      ]
    },
    {
      "start": 11864,
      "end": 11864,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11865,
      "end": 11873,
      "name": "appendix_f_ascii_codes_omitted",
      "description": "Appendix F header noting that ASCII codes section is omitted from this text (widely available elsewhere and not suitable for textual formatting).",
      "references": [],
      "ignore": true,
      "reason": "audit: Explicitly omitted ASCII table; contains no technical content or usable data."
    },
    {
      "start": 11874,
      "end": 11874,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11875,
      "end": 11883,
      "name": "appendix_g_screen_codes_omitted",
      "description": "Appendix G header noting that Screen Codes section is omitted from this text (widely available elsewhere and not suitable for textual formatting).",
      "references": [],
      "ignore": true,
      "reason": "audit: Appendix explicitly omits all screen code data; contains no technical information or useful mappings."
    },
    {
      "start": 11884,
      "end": 11884,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11885,
      "end": 11930,
      "name": "appendix_h_commodore_64_keycodes",
      "description": "Appendix H: Commodore 64 keycodes table. Maps keys A-Z, 0-9, function and control keys to numeric keycode values found at location 197. Examples: A=10, B=28, C=20, 1=56, 2=59, RETURN=1, SPACE=60, RUN/STOP=63. Provides a short BASIC one-line program to PEEK(197) repeatedly to display current keycode: 10 PRINT PEEK(197):GOTO 10.",
      "references": []
    },
    {
      "start": 11931,
      "end": 12256,
      "ignore": true,
      "reason": "Index by memory location \u2014 non-technical navigational material (to be ignored for chunking into technical knowledge nodes)."
    },
    {
      "start": 12257,
      "end": 12261,
      "ignore": true,
      "reason": "End of document footer/credits \u2014 non-technical closing material."
    }
  ],
  "source_md5": "ce2333e00f321e5374f87905b69b9193"
}
