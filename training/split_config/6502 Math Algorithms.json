{
  "source_file": "6502 Math Algorithms.txt",
  "context": "6502 Multiplication and Division Algorithms - Source: llx.com",
  "splits": [
    {
      "start": 1,
      "end": 9,
      "ignore": true,
      "reason": "Document title, source URL, author and decorative separators (non-technical metadata)."
    },
    {
      "start": 10,
      "end": 31,
      "name": "introduction_overview",
      "description": "Explains the problem: 6502 lacks hardware multiply/divide instructions; scope (mostly unsigned integers); goal to show understandable methods and mention extension to signed numbers and fractional numbers.",
      "references": [
        {
          "chunk": "multiplying_by_constant",
          "topic": "fast methods when multiplying by constants"
        },
        {
          "chunk": "multplying_arbitrary_pencil_method",
          "topic": "general multiply algorithm overview"
        },
        {
          "chunk": "dividing_arbitrary_pencil",
          "topic": "general divide algorithm overview"
        }
      ]
    },
    {
      "start": 32,
      "end": 74,
      "name": "strength_reduction_and_eliminating_multiplication",
      "description": "Strength reduction: eliminate multiplication by rewriting code (example: replacing repeated I*23 in a loop with repeated addition). Emphasizes minimizing work and preferring specialized code for multiply-by-constant cases.",
      "references": [
        {
          "chunk": "multiplying_by_constant",
          "topic": "detailed multiply-by-constant techniques"
        }
      ]
    },
    {
      "start": 75,
      "end": 95,
      "name": "multiply_by_two_basic",
      "description": "Introduces multiplying by a constant on the 6502, shows that multiplying by two is the simplest case and provides the single-byte and two-byte implementations using ASL and ROL. Includes the heading and brief note that wider numbers extend similarly.",
      "references": [
        {
          "chunk": "multiply_by_powers_of_two_repeated_shifts",
          "topic": "Uses repeated ASL/ROL to multiply by 4,8,16 etc."
        },
        {
          "chunk": "multiply_by_non_power_of_two_strategy",
          "topic": "Strategy for constants not powers of two (use sums of powers of two)"
        }
      ]
    },
    {
      "start": 96,
      "end": 115,
      "name": "multiply_by_powers_of_two_repeated_shifts",
      "description": "Explains that multiplying by 4, 8, 16, ... is done by repeating the multiply-by-2 operation. Shows example code for multiplying a one-byte value by 4 and a two-byte value by repeated ASL/ROL operations.",
      "references": [
        {
          "chunk": "multiply_by_two_basic",
          "topic": "Basic ASL/ROL single- and two-byte multiply-by-2 examples"
        },
        {
          "chunk": "multiply_by_non_power_of_two_strategy",
          "topic": "Combining power-of-two results to form other constants"
        }
      ]
    },
    {
      "start": 116,
      "end": 126,
      "name": "multiply_by_non_power_of_two_strategy",
      "description": "Describes the general approach for constants that are not powers of two: form the constant as a sum of powers of two and add the shifted results. Notes that temporary memory is usually required to hold intermediate results.",
      "references": [
        {
          "chunk": "multiply_by_3_two_byte_example",
          "topic": "Concrete two-byte example using 3x = 2x + x"
        },
        {
          "chunk": "multiply_by_10_example_using_shifts_and_adds",
          "topic": "Example composing 8x and 2x to form 10x"
        },
        {
          "chunk": "binary_decomposition_of_constants_examples",
          "topic": "How to read the binary representation of a constant to find required shifts"
        }
      ]
    },
    {
      "start": 127,
      "end": 142,
      "name": "multiply_by_3_two_byte_example",
      "description": "Step-by-step two-byte assembly code to multiply a two-byte number by 3 using the identity 3x = 2x + x. Shows shifting the operand into RESULT and then adding the original low/high bytes with ADC to produce RESULT = 3*NUM.",
      "references": [
        {
          "chunk": "multiply_by_non_power_of_two_strategy",
          "topic": "Uses the 2x + x decomposition described in the strategy"
        },
        {
          "chunk": "binary_decomposition_of_constants_examples",
          "topic": "Binary view of 3 (11b) explains why 2x + x is used"
        }
      ]
    },
    {
      "start": 143,
      "end": 166,
      "name": "multiply_by_10_example_using_shifts_and_adds",
      "description": "Example assembly demonstrating multiplication by 10. Starts by storing NUM into RESULT, uses repeated ASL/ROL to form 2x and 4x, adds NUM to form 5x, then shifts to get 10x. Shows full sequence for two-byte values and comments on composing 8x + 2x (or 2*(4x+x)).",
      "references": [
        {
          "chunk": "multiply_by_non_power_of_two_strategy",
          "topic": "Illustrates composing powers of two to make 10x"
        },
        {
          "chunk": "binary_decomposition_of_constants_examples",
          "topic": "Binary representation of 10 (1010b) corresponds to needed shifts"
        }
      ]
    },
    {
      "start": 167,
      "end": 191,
      "name": "binary_decomposition_of_constants_examples",
      "description": "Explains how to determine which powers of two to combine by inspecting the binary representation of the constant. Provides examples: 3 = 11b (1x + 2x), 10 = 1010b (2x + 8x), and 25 = 11001b (1x + 8x + 16x). Includes annotated binary diagrams showing the contributions of each '1' bit.",
      "references": [
        {
          "chunk": "multiply_by_3_two_byte_example",
          "topic": "Example of 3 as 11b -> 2x + x"
        },
        {
          "chunk": "multiply_by_10_example_using_shifts_and_adds",
          "topic": "Example of 10 as 1010b -> 8x + 2x"
        },
        {
          "chunk": "multiply_by_non_power_of_two_strategy",
          "topic": "Binary decomposition is the method used to choose which shifts/adds to perform"
        }
      ]
    },
    {
      "start": 192,
      "end": 198,
      "name": "need_for_general_multiply_routine",
      "description": "Notes the limitation of the constant-multiplication techniques when both multiplicand and multiplier are unknown at runtime and points out the need for a general multiply-anything-by-anything routine in that case.",
      "references": [
        {
          "chunk": "multiply_by_non_power_of_two_strategy",
          "topic": "Constant-based strategies vs. general multiplication"
        },
        {
          "chunk": "multiply_by_powers_of_two_repeated_shifts",
          "topic": "Fast shift-based methods are only applicable when the multiplier is known"
        }
      ]
    },
    {
      "start": 199,
      "end": 233,
      "name": "multplying_arbitrary_pencil_method",
      "description": "High-level description of schoolbook multiplication (decimal example) converted to algorithm: initialize answer to 0, for each digit of multiplier remove rightmost digit, multiply multiplicand by that digit, add shifted result to the answer. Leads into binary version of the same idea.",
      "references": [
        {
          "chunk": "binary_multiplication_algorithm",
          "topic": "binary adaptation of the pencil-and-paper algorithm"
        }
      ]
    },
    {
      "start": 234,
      "end": 271,
      "name": "binary_multiplication_algorithm",
      "description": "Binary multiplication algorithm: analogous to decimal but simpler because digits are 0/1. Algorithm: set answer to 0; for each bit in multiplier, remove rightmost bit; if bit==1 add multiplicand shifted appropriately to answer. Example binary multiplication (110 x 101) and explanation of 'stairstep' shift trick used in machine code implementations.",
      "references": [
        {
          "chunk": "one_byte_multiplication_routine",
          "topic": "one-byte machine code implementation of this algorithm"
        },
        {
          "chunk": "two_byte_multiplication_routine",
          "topic": "extension to wider operands"
        }
      ]
    },
    {
      "start": 272,
      "end": 297,
      "name": "one_byte_multiplication_routine",
      "description": "6502 one-byte unsigned multiply (schoolbook/binary algorithm) implementation. Registers and instructions: LDA #0 to init RESULT, LDX #8 for 8 bits, loop LSR NUM2 to get low bit, BCC to skip add, CLC/ADC NUM1 to add (if bit=1), ROR A and ROR RESULT to perform 'stairstep' shifting and capture carry, DEX/BNE for loop, final STA RESULT+1 to store hi byte. Notes that multiplying one-byte values yields a two-byte result and how to extend the method.",
      "references": [
        {
          "chunk": "binary_multiplication_algorithm",
          "topic": "algorithmic origin"
        },
        {
          "chunk": "two_byte_multiplication_routine",
          "topic": "4-byte result from two 2-byte operands"
        }
      ]
    },
    {
      "start": 298,
      "end": 323,
      "name": "two_byte_multiplication_routine",
      "description": "6502 implementation of unsigned multiplication for two-byte operands producing a four-byte result. Key instructions: initializing RESULT hi words, LDX #16 for 16 bits, shifting bits out of NUM2 with LSR/ ROR NUM2+1/NUM2, conditional add sequence using TAY, CLC, LDA NUM1, ADC RESULT+2, STA RESULT+2, TYA, ADC NUM1+1; then the 'stairstep' shifts ROR A and ROR RESULT+2/RESULT+1/RESULT, and loop control DEX/BNE. Explains generalization to wider numbers.",
      "references": [
        {
          "chunk": "one_byte_multiplication_routine",
          "topic": "same algorithm on a larger width"
        },
        {
          "chunk": "extending_multiplication_to_wider_numbers",
          "topic": "how to generalize further"
        }
      ]
    },
    {
      "start": 324,
      "end": 331,
      "name": "extending_multiplication_to_wider_numbers",
      "description": "Notes that once the binary multiply algorithm is understood, routines for other operand widths are straightforward to write; advises readers to generalize the shown examples rather than bloating the document with many size variants.",
      "references": [
        {
          "chunk": "two_byte_multiplication_routine",
          "topic": "example of extension to two-byte operands"
        }
      ]
    },
    {
      "start": 332,
      "end": 366,
      "name": "division_by_two_and_powers_of_two",
      "description": "Division by 2: use LSR for single-byte, and for two-byte use LSR NUMHI then ROR NUMLO to shift right across two bytes. Remainder returned in the carry flag. For higher powers of two, repeat shifts; remainder bits are the bits shifted into carry (lowest bit shifted out is lowest remainder bit, etc.). Notes that dividing by non-power-of-two constants is harder and often general division is preferable if remainder needed.",
      "references": [
        {
          "chunk": "dividing_arbitrary_pencil",
          "topic": "general division algorithm"
        }
      ]
    },
    {
      "start": 367,
      "end": 398,
      "name": "dividing_arbitrary_pencil",
      "description": "Long division (pencil-and-paper) analogy and algorithm: find the largest multiple of divisor less than the current leftmost portion of dividend, subtract, bring down next digit, repeat. Illustrated with decimal example (12345 / 67 -> quotient 184 remainder 17). Introduces binary division as the same process with binary digits.",
      "references": [
        {
          "chunk": "binary_division_example_and_code",
          "topic": "binary example and trial-subtract implementation"
        }
      ]
    },
    {
      "start": 399,
      "end": 426,
      "name": "binary_division_example_and_concept",
      "description": "Binary long division example showing repetitive trial-subtractions where each step subtracts either 0 or the divisor. Demonstrates easier branching because only two subtractions possible. Explains the high-level code approach: shift dividend bits into a work area, attempt subtraction with the divisor; if subtraction succeeds record a 1 in quotient and keep remainder, otherwise record 0 and discard subtraction result.",
      "references": [
        {
          "chunk": "two_byte_division_routine",
          "topic": "example 6502 code implementing this trial-subtract method"
        }
      ]
    },
    {
      "start": 427,
      "end": 462,
      "name": "two_byte_division_routine",
      "description": "6502 code example dividing a two-byte NUM1 (dividend) by two-byte NUM2 (divisor), leaving quotient in NUM1 and remainder in REM. Key steps: initialize REM to 0, set X = #16 for 16 bits, loop: ASL NUM1 then ROL NUM1+1 to shift hi bit of NUM1 into REM, ROL REM/REM+1, trial subtraction using SEC/SBC NUM2 and NUM2+1, BCC to detect failure, STA REM+1/STY REM to keep subtraction result, INC NUM1 to set quotient bit, DEX/BNE loop. Illustrates trial-subtract method and quotient bit recording.",
      "references": [
        {
          "chunk": "binary_division_example_and_concept",
          "topic": "conceptual origin"
        },
        {
          "chunk": "quotient_and_remainder_widths",
          "topic": "considerations about quotient and remainder sizes"
        }
      ]
    },
    {
      "start": 463,
      "end": 475,
      "name": "quotient_and_remainder_widths",
      "description": "Important caveat on widths: quotient must be as wide as the dividend (e.g., dividing by 1 yields quotient equal to dividend), and remainder must be as wide as the divisor (can be as large as divisor-1). Warns against assuming dividing an N-byte dividend by a smaller divisor produces a proportionally smaller quotient. Notes that additional size-specific routines are straightforward to write.",
      "references": [
        {
          "chunk": "two_byte_division_routine",
          "topic": "example implementation where quotient occupies dividend width"
        }
      ]
    },
    {
      "start": 476,
      "end": 504,
      "name": "need_for_speed_and_sentinel_multiply_optimization",
      "description": "Performance-minded optimizations for the one-byte multiply. Introduces sentinel-bit technique: preload RESULT with $80 as sentinel in hi byte so the loop can terminate using BCC when sentinel falls into carry. Code reduces DEY from loop by using carry for loop control: LDA #$80; STA RESULT; ASL A; L1 LSR NUM2; BCC L2; CLC ADC NUM1; L2 ROR A; ROR RESULT; BCC L1; STA RESULT+1. Notes savings in cycles and that Y register preserved. (Assumes RESULT in page 0 for additional savings.)",
      "references": [
        {
          "chunk": "one_byte_multiplication_routine",
          "topic": "original routine being optimized"
        },
        {
          "chunk": "remove_clc_trick",
          "topic": "further micro-optimization to remove CLC"
        }
      ]
    },
    {
      "start": 505,
      "end": 525,
      "name": "remove_clc_trick",
      "description": "Micro-optimization to remove CLC from the loop by decrementing NUM1 once before the loop and using ADC NUM1 instead of CLC/ADC NUM1; code: LDA #$80; STA RESULT; ASL A; DEC NUM1; loop LSR NUM2; BCC L2; ADC NUM1; L2 ROR A; ROR RESULT; BCC L1; STA RESULT+1. Notes cost of initial DEC and break-even (useful if NUM2 has at least three 1-bits).",
      "references": [
        {
          "chunk": "need_for_speed_and_sentinel_multiply_optimization",
          "topic": "builds on sentinel optimization"
        }
      ]
    },
    {
      "start": 526,
      "end": 544,
      "name": "table_lookup_tradeoffs_for_speed",
      "description": "Discusses that even optimized routines are relatively slow (~151 cycles worst-case) and introduces table lookup as the fastest method: precompute multiplication/division results and look up answers. Notes tradeoff between speed and memory: full multiplication table for arbitrary 1-byte operands is too large for 6502 direct access, so algebraic reduction can shrink tables.",
      "references": [
        {
          "chunk": "algebraic_square_trick",
          "topic": "reducing multiplication table size using square identities"
        }
      ]
    },
    {
      "start": 545,
      "end": 566,
      "name": "algebraic_square_trick",
      "description": "Mathematical trick to reduce table size using binomial identities: (a+b)^2 = a^2 + 2ab + b^2 and (a-b)^2 = a^2 - 2ab + b^2. Subtracting yields (a+b)^2 - (a-b)^2 = 4ab, so ab = ((a+b)^2 - (a-b)^2)/4 = (a+b)^2/4 - (a-b)^2/4. So multiplication can be computed with two table lookups of squares (predivided by 4), an addition and subtraction, and shifts.",
      "references": [
        {
          "chunk": "table_method_implementation_tricks",
          "topic": "implementation details to make square-table method practical"
        },
        {
          "chunk": "pointer_setup_for_square_tables",
          "topic": "how to set table pointers for efficient lookup"
        }
      ]
    },
    {
      "start": 567,
      "end": 591,
      "name": "table_method_implementation_tricks",
      "description": "Practical tricks to implement the square-table multiplication: store x^2/4 to save one byte per entry (2 bytes instead of 3) since both (a+b)^2 and (a-b)^2 lose same low bits so subtraction cancels; store both (a+b)^2/4 and (a-b)^2/4 tables (total ~2048 bytes); offset (a-b)^2/4 table by one so -A-1 indexing with EOR #$FF works without adding 1; page-align tables for streamlined (indirect,Y) indexing. These tricks minimize memory and speed costs.",
      "references": [
        {
          "chunk": "algebraic_square_trick",
          "topic": "the identity used"
        },
        {
          "chunk": "pointer_setup_for_square_tables",
          "topic": "how to supply pointers in page zero"
        }
      ]
    },
    {
      "start": 592,
      "end": 604,
      "name": "pointer_setup_for_square_tables",
      "description": "Setup routine to initialize four page-zero pointers to the two precomputed square tables (sum and diff tables): LDA #SSQLO/256 STA PSLO+1; LDA #SSQHI/256 STA PSHI+1; LDA #DSQLO/256 STA PDLO+1; LDA #DSQHI/256 STA PDHI+1. Explains tables must be page-aligned for the subsequent indexed indirect (PSLO),Y lookups.",
      "references": [
        {
          "chunk": "table_lookup_multiply_routine",
          "topic": "consuming these pointers to compute product"
        }
      ]
    },
    {
      "start": 605,
      "end": 621,
      "name": "table_lookup_multiply_routine",
      "description": "6502 routine to multiply two bytes using the square-table trick. Caller: put one operand in A and the other in Y. Steps: STA PSLO/PSHI to set index into sum table by A; EOR #$FF and STA PDLO/PDHI to index diff table by -A-1; LDA (PSLO),Y to get (a+y)^2/4 (lo), SEC; SBC (PDLO),Y subtract (-a+y)^2/4 (lo), TAX to save result low, LDA (PSHI),Y SBC (PDHI),Y to get hi. Leaves product in A (high byte) and X (low byte). Notes worst-case ~38 cycles with page-crossing indexing.",
      "references": [
        {
          "chunk": "pointer_setup_for_square_tables",
          "topic": "table pointer initialization"
        },
        {
          "chunk": "table_lookup_tradeoffs_for_speed",
          "topic": "tradeoff explanation"
        }
      ]
    },
    {
      "start": 622,
      "end": 627,
      "name": "table_result_placement_and_cycle_count",
      "description": "Explains the routine result placement: product high byte in accumulator (A), product low byte in X. Notes worst-case timing: 38 cycles (when all indexing crosses a page boundary).",
      "references": [
        {
          "chunk": "table_lookup_multiply_routine",
          "topic": "where the product is left after the routine"
        }
      ]
    },
    {
      "start": 628,
      "end": 639,
      "name": "square_tables_storage_note",
      "description": "Notes that the square tables required for the square-table multiplication are too long to show in the document and are provided separately. Reminder that tables must be page-aligned or the (indirect),Y indexing won't work.",
      "references": [
        {
          "chunk": "table_lookup_multiply_routine",
          "topic": "requires the externally-provided square tables"
        }
      ]
    },
    {
      "start": 640,
      "end": 670,
      "name": "signed_numbers_overview_and_sign_computation",
      "description": "Discussion of signed numbers: most routines presented are for unsigned values. LSR and ROR are not sign-preserving. Usual method: compute sign of the result first (if operands have same sign result positive, else negative). For two's-complement representation the sign of the result is found by EORing high bytes; the sign is then in the high bit of A/N flag. After determining sign, make operands positive, multiply, then apply sign to result.",
      "references": [
        {
          "chunk": "negation_methods",
          "topic": "how to make numbers positive or negate after computation"
        },
        {
          "chunk": "signed_multiply_wrapper",
          "topic": "sample wrapper around unsigned multiply"
        }
      ]
    },
    {
      "start": 671,
      "end": 671,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 672,
      "end": 696,
      "name": "negation_methods",
      "description": "How to negate numbers on 6502: to negate a value in A (quickest): EOR #$FF; CLC; ADC #1 (two's complement). To negate memory-held multi-byte numbers, subtract them from zero using SEC/SBC: LDA #0; SEC; SBC NUM; STA NUM; LDA #0; SBC NUM+1; STA NUM+1. Use these methods to make operands positive for unsigned routines.",
      "references": [
        {
          "chunk": "signed_multiply_wrapper",
          "topic": "uses these negation techniques"
        }
      ]
    },
    {
      "start": 697,
      "end": 728,
      "name": "signed_multiply_wrapper",
      "description": "Example wrapper to multiply two signed one-byte numbers using an unsigned multiply routine. Steps: compute sign via LDA NUM1; EOR NUM2; PHP to save sign; normalize operands to positive if negative (BPL check then EOR #$FF; CLC; ADC #1; STA back); call JSR MUL1BYTE (unsigned); PLP to restore sign; if negative then negate 2-byte RESULT via subtraction-from-zero sequence. Shows how to adapt unsigned multiply for signed operands.",
      "references": [
        {
          "chunk": "one_byte_multiplication_routine",
          "topic": "the unsigned multiply routine called (MUL1BYTE)"
        },
        {
          "chunk": "negation_methods",
          "topic": "negation used for inputs and output"
        },
        {
          "chunk": "signed_division_conventions_wrapper",
          "topic": "analogous wrapper approach exists for division"
        }
      ]
    },
    {
      "start": 729,
      "end": 776,
      "name": "signed_division_conventions_wrapper",
      "description": "Discussion of signed division: preserve dividend = divisor*quotient + remainder. Two common conventions: floored division (quotient <= mathematical quotient, remainder >=0) and toward-zero division (quotient truncated toward zero, remainder has sign of dividend). Implementation uses wrapper around unsigned division: compute sign of quotient (EOR high bytes), make both numbers positive, call unsigned division, then adjust results depending on convention: floored — if quotient should be negative negate it and leave remainder; toward-zero — if quotient negative negate quotient then add 1, and if original dividend negative then negate remainder. Notes wrapper is analogous to signed multiplication example.",
      "references": [
        {
          "chunk": "two_byte_division_routine",
          "topic": "unsigned routine used as core"
        },
        {
          "chunk": "negation_methods",
          "topic": "used to adjust sign of quotient/remainder"
        }
      ]
    },
    {
      "start": 777,
      "end": 786,
      "ignore": true,
      "reason": "Document revision history and modification timestamps (non-technical metadata)."
    }
  ],
  "source_md5": "09452e81565e562be3c0fb3de58139c1"
}
