{
  "source_file": "Intro to c64 Demos.txt",
  "context": "An Introduction to Programming C-64 Demos",
  "splits": [
    {
      "start": 1,
      "end": 8,
      "ignore": true,
      "reason": "Title page, author and contact header (non-technical metadata)"
    },
    {
      "start": 9,
      "end": 87,
      "ignore": true,
      "reason": "Table of contents (non-technical)"
    },
    {
      "start": 88,
      "end": 88,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 89,
      "end": 104,
      "name": "introduction_overview",
      "description": "Document introduction: purpose, scope and high-level goals for teaching C-64 demo programming; outlines learning-by-doing approach and motivation.",
      "references": [
        {
          "chunk": "why_c64_demos_overview",
          "topic": "reasons to use the C-64 for demos"
        }
      ]
    },
    {
      "start": 105,
      "end": 111,
      "ignore": true,
      "reason": "Contributors and update note (acknowledgements / revision note)"
    },
    {
      "start": 112,
      "end": 112,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 113,
      "end": 119,
      "name": "why_c64_demos_overview",
      "description": "Overview question: why program demos and why use the Commodore 64; sets up the next sections that examine reasons in depth.",
      "references": [
        {
          "chunk": "why_demos",
          "topic": "why program demos (motivation)"
        },
        {
          "chunk": "why_c64_cpu",
          "topic": "CPU characteristics of the C-64"
        }
      ]
    },
    {
      "start": 120,
      "end": 129,
      "name": "why_demos",
      "description": "Arguments for coding demos: fun, learning low-level programming, control of hardware, use of interrupts, and learning fundamentals such as pointers and efficient coding.",
      "references": [
        {
          "chunk": "learning_machine_language",
          "topic": "learning 6502 assembly"
        },
        {
          "chunk": "interrupts_overview",
          "topic": "importance of interrupts in demos"
        }
      ]
    },
    {
      "start": 130,
      "end": 138,
      "name": "why_c64_cpu",
      "description": "C-64 CPU details: 6510 (6502 variant), simple instruction set, three main registers (A, X, Y), memory-mapped I/O; benefits and constraints for demo coding.",
      "references": [
        {
          "chunk": "learning_machine_language",
          "topic": "6502 assembly learning advice"
        }
      ]
    },
    {
      "start": 139,
      "end": 139,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 140,
      "end": 145,
      "name": "why_c64_vic",
      "description": "VIC-II (graphics chip) overview: quirky features and bugs that enable unique effects; timing-sensitive register writes (e.g. $d020 and $d021) required for raster effects.",
      "references": [
        {
          "chunk": "d012_raster_register",
          "topic": "raster timing and $d012"
        },
        {
          "chunk": "raster_bars_timing",
          "topic": "creating raster bars by changing $d020/$d021"
        }
      ]
    },
    {
      "start": 146,
      "end": 151,
      "name": "why_c64_old_and_slow",
      "description": "Why the C-64 being old and slow is an advantage: forces efficient algorithms and clever programming rather than brute-force CPU usage.",
      "references": [
        {
          "chunk": "a_few_words_about_optimization",
          "topic": "optimization strategies for 6502"
        }
      ]
    },
    {
      "start": 152,
      "end": 161,
      "name": "learning_machine_language",
      "description": "Advice on learning 6502 machine language: get a tutorial and a reference (Programmer's Reference Guide), learn key instructions and addressing modes, then study C-64 memory map (Mapping the C-64).",
      "references": [
        {
          "chunk": "tools_intro",
          "topic": "assemblers and monitors to practice machine code"
        }
      ]
    },
    {
      "start": 162,
      "end": 163,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 164,
      "end": 183,
      "name": "flashing_border_example",
      "description": "Simple example: flash the border by repeatedly INC $D020 and JMP loop. Assembler origin *=$1000, label use, INC semantics vs LDA/ADC/STA, $D020 is border colour register.",
      "references": [
        {
          "chunk": "why_c64_vic",
          "topic": "VIC register $d020 controls border colour"
        },
        {
          "chunk": "using_a_monitor",
          "topic": "how to enter and run short machine code examples"
        }
      ]
    },
    {
      "start": 184,
      "end": 184,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 185,
      "end": 215,
      "name": "clearing_screen_example",
      "description": "Example code to clear the screen: set $d020/$d021 to 0, use TAX to set X, loop storing $20 (space) into screen memory at $0400-$07FF using STA $0400,X etc., DEX/BNE loop indexing technique and wrap-around behaviour.",
      "references": [
        {
          "chunk": "screen_and_colour_ram",
          "topic": "screen memory at $0400 and length"
        },
        {
          "chunk": "using_an_assembler",
          "topic": "Turbo Assembler syntax used in examples"
        }
      ]
    },
    {
      "start": 216,
      "end": 216,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 217,
      "end": 221,
      "name": "tools_intro",
      "description": "Overview of essential tools: a monitor and/or assembler (Turbo Assembler recommended for examples). Pros and cons of monitor vs assembler for demo coding.",
      "references": [
        {
          "chunk": "using_a_monitor",
          "topic": "monitor commands and usage"
        },
        {
          "chunk": "using_an_assembler",
          "topic": "Turbo Assembler commands and workflow"
        }
      ]
    },
    {
      "start": 222,
      "end": 222,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 223,
      "end": 247,
      "name": "using_a_monitor",
      "description": "Monitor usage: assemble single instructions with .a address mnemonic, disassemble with .d, run with .g, monitor auto-increments assembly address; typical cartridge monitors (Action Replay, Final Cartridge) supported.",
      "references": [
        {
          "chunk": "flashing_border_example",
          "topic": "entering and running small monitor programs"
        }
      ]
    },
    {
      "start": 248,
      "end": 249,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 250,
      "end": 263,
      "name": "using_an_assembler",
      "description": "Turbo Assembler usage notes: entering editor (sys $9000), assemble (←-3), save/assemble to disk, restore to assembler (RESTORE may return to editor), versions may differ (macros, undocumented opcodes).",
      "references": [
        {
          "chunk": "tools_intro",
          "topic": "why assemblers are preferred by many demo coders"
        }
      ]
    },
    {
      "start": 264,
      "end": 264,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 265,
      "end": 267,
      "name": "cross_assemblers_and_emulators",
      "description": "Cross assemblers on other platforms and emulators (VICE) are usable, but always test on real hardware because some VIC bugs and sprite behavior aren't perfectly emulated.",
      "references": [
        {
          "chunk": "d012_raster_register",
          "topic": "hardware raster behavior differences in emulators"
        }
      ]
    },
    {
      "start": 268,
      "end": 268,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 269,
      "end": 277,
      "name": "demo_programming_overview",
      "description": "Demo components: graphics, sound, and code. Focus on graphics effects, music playback is usually simple via standard players; loaders needed for multi-part demos may be used (IRQ loaders).",
      "references": [
        {
          "chunk": "irq_loaders",
          "topic": "loading parts from disk without interrupting demo"
        },
        {
          "chunk": "graphics_intro",
          "topic": "graphics primitives (sprites, chars, bitmap)"
        }
      ]
    },
    {
      "start": 278,
      "end": 278,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 279,
      "end": 321,
      "name": "d012_raster_register",
      "description": "Detailed explanation of $D012: reading it returns current raster line; writing it sets next raster interrupt line. On PAL machines there are 318 raster lines; bit 7 of $D011 extends $D012 (provides the 8th bit). Example code shows polling $D012 to synchronize actions (border flash, music play JSR at $1003) and demonstrates using $D012 for timing graphics and music.",
      "references": [
        {
          "chunk": "how_to_implement_interrupts_example",
          "topic": "using raster interrupts (vectors and $d012 writes)"
        },
        {
          "chunk": "raster_bars_timing",
          "topic": "making raster bars by changing $d020/$d021 at specific lines"
        }
      ]
    },
    {
      "start": 322,
      "end": 322,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 323,
      "end": 326,
      "name": "graphics_intro",
      "description": "Intro to graphics on the C-64: need to know VIC registers, screen memory (default $0400), and colour RAM ($D800). Subsequent sections cover sprites, character graphics and bitmap graphics.",
      "references": [
        {
          "chunk": "sprites_basics_and_pointers",
          "topic": "hardware sprites"
        },
        {
          "chunk": "bitmap_graphics_koala_example",
          "topic": "bitmap/KOLALA picture display"
        }
      ]
    },
    {
      "start": 327,
      "end": 328,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 329,
      "end": 349,
      "name": "sprites_basics_and_pointers",
      "description": "Sprite fundamentals: 8 hardware sprites, operations needed to use sprites (display, set position, shape, colour). Sprite pointers reside after screen memory ($07F8..$07FF default), each pointer byte selects a 64-byte-aligned sprite data block in current VIC bank (pointer*64). Sprite data is 63 bytes aligned to 64 bytes. VIC banks are $0000-$3FFF, $4000-$7FFF, etc.",
      "references": [
        {
          "chunk": "sprites_important_addresses",
          "topic": "registers for enabling sprites and coordinates ($D015, $D000..$D00F, $D010, $D027..)"
        },
        {
          "chunk": "sprite_multiplexer",
          "topic": "re-using hardware sprites by changing Y coords and pointers mid-frame"
        }
      ]
    },
    {
      "start": 350,
      "end": 351,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 352,
      "end": 358,
      "name": "sprites_important_addresses",
      "description": "Important sprite registers: $07F8..$07FF sprite pointers, $D015 sprite enable bits, X coordinate registers $D000, $D002.., Y coordinate registers $D001, $D003..; X high bit for each sprite stored in $D010. Sprite colour registers at $D027/$D028 etc. Single-colour sprites use those colour registers.",
      "references": [
        {
          "chunk": "sprite_example_movement",
          "topic": "example that uses these registers to move a sprite"
        }
      ]
    },
    {
      "start": 359,
      "end": 359,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 360,
      "end": 419,
      "name": "sprite_example_movement",
      "description": "Full example of moving sprite 0: enabling sprite via $D015, setting colour via $D027, coordinates via $D000/$D001, pointer $07F8 to $80 (sprite data at $2000). Main loop polls $D012 for raster line $FF before updating coordinates and direction logic, demonstrates jerky movement problem caused by timer interrupts.",
      "references": [
        {
          "chunk": "d012_raster_register",
          "topic": "polling $d012 for frame sync"
        },
        {
          "chunk": "interrupts_overview",
          "topic": "timer/CIA interrupts can cause jerky movement"
        }
      ]
    },
    {
      "start": 420,
      "end": 433,
      "name": "character_graphics_screen_and_colour_ram",
      "description": "Character graphics basics: custom charsets for better-looking text/graphics. Screen memory default at $0400 (size $03E8), colour RAM is fixed at $D800 (per-character colours). Example: to show 'A' in upper-left, poke screen code to $0400 and colour value to $D800.",
      "references": [
        {
          "chunk": "changing_charset_and_d018",
          "topic": "pointing character set and screen memory via $D018"
        }
      ]
    },
    {
      "start": 434,
      "end": 442,
      "name": "changing_charset_and_d018",
      "description": "$D018 usage: selects VIC locations for screen memory (upper 4 bits) and character set (lower 4 bits) of a 14-bit address; count $0400 chunks for screen location and $0800 chunks for charsets; example: screen at $0400 and charset at $2000 yields $D018 = $18.",
      "references": [
        {
          "chunk": "altering_charset_realtime_example",
          "topic": "real-time charset modification example that sets $D018 and pokes into char memory"
        }
      ]
    },
    {
      "start": 443,
      "end": 443,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 444,
      "end": 495,
      "name": "altering_charset_realtime_example",
      "description": "Example program to modify the character set in realtime: clears screen and charset ($2000), sets $D018 to $18 (screen $0400, chars $2000), main loop polls $D012 for raster $FF and then inverts a byte in charset at $2000+counter to create animation (DYCP-like effects). Explains char data layout (char N at $2000 + N*8).",
      "references": [
        {
          "chunk": "text_scroller_implementation",
          "topic": "DYCP and realtime charset updates used for scrollers and animated fonts"
        }
      ]
    },
    {
      "start": 496,
      "end": 496,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 497,
      "end": 500,
      "name": "multicolor_character_graphics_note",
      "description": "Note about multicolour character graphics: each character can have 3 colours (one from colour RAM per-char, two shared in $D022 and $D023). $D022/$D023 are global for multicolour characters.",
      "references": [
        {
          "chunk": "changing_charset_and_d018",
          "topic": "multicolour setup relates to charset placement and $D018"
        }
      ]
    },
    {
      "start": 501,
      "end": 501,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 502,
      "end": 564,
      "name": "bitmap_graphics_koala_example",
      "description": "Bitmap concepts and Koala Paint example: bitmap needs ~ $2000 bytes; Koala format layout (bitmap, screen RAM, colour RAM) requires copying data into $0400 and $D800 and setting VIC registers ($D011,$D016,$D018) to enter bitmap/multicolour or hires modes. Example code copies Koala screen/colour data from $3F40/$4328 etc. to $0400/$D800, sets $D011=$3B (bitmap mode), $D016=$18 for multicolour and $D018=$18 to point screen at $0400 and bitmap at $2000.",
      "references": [
        {
          "chunk": "bitmap_screen_layout",
          "topic": "C-64 bitmap memory layout and addressing non-linearity"
        }
      ]
    },
    {
      "start": 565,
      "end": 571,
      "name": "bitmap_screen_layout",
      "description": "C-64 bitmap layout explanation: bitmap bytes are arranged like charset character cells (vertical-chunk order) rather than a single linear pixel row; first byte is top-left cell, next byte is below it until the 8th, then next cell to the right, making plotting and indexing non-linear.",
      "references": [
        {
          "chunk": "bitmap_graphics_koala_example",
          "topic": "practical example using Koala layout"
        }
      ]
    },
    {
      "start": 572,
      "end": 572,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 573,
      "end": 579,
      "name": "displaying_bitmaps_single_and_multicolor",
      "description": "Displaying bitmaps: hires vs multicolour differences. Single-colour hires uses screen RAM upper/lower nybbles for two colours; multicolour uses colour RAM. Example: set $D011=$3B, $D016=$08 for single-colour, $D018 appropriately for screen and bitmap addresses.",
      "references": [
        {
          "chunk": "bitmap_graphics_koala_example",
          "topic": "how to set VIC registers for bitmap modes"
        }
      ]
    },
    {
      "start": 580,
      "end": 580,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 581,
      "end": 589,
      "name": "interrupts_overview",
      "description": "Introduction to interrupts in demo programming: importance for smooth timing, avoiding jitter, and enabling loaders (IRQ loaders). Focuses on raster interrupts and NMIs as the most relevant types for demos.",
      "references": [
        {
          "chunk": "d012_raster_register",
          "topic": "polling $d012 vs raster interrupts"
        }
      ]
    },
    {
      "start": 590,
      "end": 603,
      "name": "why_interrupts_and_interrupt_types",
      "description": "Why use interrupts: avoid polling, stable timing, use of CIAs for timers, VIC for raster and sprite-collision interrupts. IRQ loaders rely on interrupts to load parts without breaking demo display.",
      "references": [
        {
          "chunk": "irq_loaders",
          "topic": "use of interrupts by loaders"
        }
      ]
    },
    {
      "start": 604,
      "end": 604,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 605,
      "end": 670,
      "name": "how_to_implement_interrupts_example",
      "description": "Step-by-step raster IRQ setup example: SEI, disable CIA interrupts ($DC0D,$DD0D), enable raster interrupts ($D01A bit0), initialize VIC registers ($D011,$D016,$D018), write IRQ vector to $0314/$0315 (low/high byte of handler), set $D012 to raster line, ACK CIAs and VIC ($DC0D,$DD0D, ASL $D019), CLI. Interrupt handler example flashes border (INC $D020), ACK via ASL $D019, restore registers from stack and RTI. Discusses why SEI/CLI, ACK sequence, alternative of jumping to ROM handler $EA31/$EA81, and testing by RTS / JMP $EA31 to remain at BASIC prompt.",
      "references": [
        {
          "chunk": "d012_raster_register",
          "topic": "writing $d012 to select raster line"
        },
        {
          "chunk": "stable_raster_interrupts",
          "topic": "techniques to reduce jitter in raster interrupts"
        }
      ]
    },
    {
      "start": 671,
      "end": 673,
      "name": "playing_music_with_interrupts",
      "description": "Playing music inside IRQ handler: initialize music player before IRQ setup, then JSR to music-play routine from the interrupt handler to play music synchronized with frames.",
      "references": [
        {
          "chunk": "how_to_implement_interrupts_example",
          "topic": "where to JSR music player inside IRQ handler"
        }
      ]
    },
    {
      "start": 674,
      "end": 674,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 675,
      "end": 686,
      "name": "multiple_interrupts_per_frame",
      "description": "Using more than one raster interrupt per frame: two approaches — (i) single raster IRQ and then poll $D012 for second line (bad if main loop needs time), or (ii) chain interrupts by changing $0314/$0315 and $D012 inside each interrupt to point to the next handler/line, enabling multiple IRQs per frame.",
      "references": [
        {
          "chunk": "stable_raster_interrupts",
          "topic": "need for stable raster when scheduling many in-line IRQs"
        }
      ]
    },
    {
      "start": 687,
      "end": 688,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 689,
      "end": 707,
      "name": "stable_raster_interrupts",
      "description": "Problem of jitter: IRQ latency depends on the instruction being executed when IRQ occurs. Techniques to achieve stable raster interrupts: double-interrupt method (two IRQs with NOP alignment and branch to remove last cycle jitter), sync with sprite fetch (stalling via sprite data fetch timing), triggering or syncing with a Bad Line (FORCED VIC memory fetch yields stable timing). Author's preference: sync with sprite.",
      "references": [
        {
          "chunk": "sprite_multiplexer",
          "topic": "using sprite fetch timing for synchronization"
        },
        {
          "chunk": "fld_flexible_line_distance",
          "topic": "Bad Line manipulation techniques"
        }
      ]
    },
    {
      "start": 708,
      "end": 708,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 709,
      "end": 713,
      "name": "nmis_and_disabling_restore",
      "description": "NMIs (Non-Maskable Interrupts) and disabling RESTORE NMI: cannot mask NMIs; technique to neutralize is set an NMI vector ($0318/$0319) pointing to an RTI/empty handler and avoid ACKing (or set up CIA2 timer to generate NMI and return immediately) so NMIs don't disrupt demo.",
      "references": [
        {
          "chunk": "how_to_implement_interrupts_example",
          "topic": "IRQ vs NMI vectors ($0314/$0315 vs $0318/$0319)"
        }
      ]
    },
    {
      "start": 714,
      "end": 714,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 715,
      "end": 723,
      "name": "interesting_effects_overview",
      "description": "Intro to demo effects section: lists effects of increasing complexity (text scroller, raster bars, border opening, FLD, sprite multiplexing, FLI/AFLI/IFLI, side border open, plasmas, bumpmapping, 3D) and references that additional code/examples can be found in magazines and referenced docs.",
      "references": [
        {
          "chunk": "text_scroller_implementation",
          "topic": "text scroller basics"
        },
        {
          "chunk": "fli_afli_ifli_formats",
          "topic": "FLI and AFLI techniques"
        }
      ]
    },
    {
      "start": 724,
      "end": 724,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 725,
      "end": 757,
      "name": "text_scroller_implementation",
      "description": "Text scroller fundamentals: set up IRQ before scroller area, use $D016 X-scroll lower 3 bits (0..7) for sub-character X scrolling; decrement X-scroll each frame, when wraps from 0->7 shift characters left in screen RAM and insert next char from text buffer; suggestions: start with X-scroll animation then add line copy routine, text buffer wrap, colours in $D800, custom charsets, larger fonts and Y-movement via $D011.",
      "references": [
        {
          "chunk": "changing_charset_and_d018",
          "topic": "using custom charsets for nicer scroller fonts"
        },
        {
          "chunk": "fld_flexible_line_distance",
          "topic": "use FLD to move scroller up/down"
        }
      ]
    },
    {
      "start": 758,
      "end": 758,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 759,
      "end": 771,
      "name": "raster_bars_timing",
      "description": "Raster bars technique: change $D020 and/or $D021 on each raster line to create coloured bars. Timing critical: create a loop with exact cycle counts (63 cycles PAL, 65 NTSC) to update colours per line; watch sprite fetch interference, page-crossing cycle differences, and use different registers for counting vs table indexing to produce rolling effects.",
      "references": [
        {
          "chunk": "d012_raster_register",
          "topic": "waiting for specific raster lines (via $D012) to start raster bars"
        }
      ]
    },
    {
      "start": 772,
      "end": 772,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 773,
      "end": 779,
      "name": "opening_top_and_bottom_border",
      "description": "Open top and bottom border trick: set screen to 25 lines (bit 3 of $D011), then on the last visible text line (raster $F8/$F9/$FA) clear that bit so VIC doesn't re-enable border — effectively opens upper/lower border. Must set the bit back after a few lines to reset for next frame. Sprites can be shown in border; normal graphics cannot.",
      "references": [
        {
          "chunk": "opening_side_border",
          "topic": "side border opening uses similar concepts but needs per-line timing"
        }
      ]
    },
    {
      "start": 780,
      "end": 780,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 781,
      "end": 789,
      "name": "fld_flexible_line_distance",
      "description": "FLD (Flexible Line Distance): delays display of next character line by manipulating Bad Line triggering via $D011. Method: read $D012, add desired delay, mask to low 3 bits (AND #$07), OR proper upper bits for text mode (ORA #$18), and STA $D011 repeatedly to postpone the next Bad Line, enabling vertical scrolling effects and removal of Bad Line artifacts.",
      "references": [
        {
          "chunk": "bitmap_graphics_koala_example",
          "topic": "use FLD to avoid Bad Lines when updating bitmap areas"
        }
      ]
    },
    {
      "start": 790,
      "end": 790,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 791,
      "end": 797,
      "name": "sprite_multiplexer",
      "description": "Sprite multiplexer principle: change Y coordinates (and optionally pointers) while sprite is being displayed so the sprite reappears lower on the screen, enabling reuse of hardware sprites. New Y must be at least $15 greater than previous to be visible. Pointer changes must be timed carefully to avoid mid-draw corruption.",
      "references": [
        {
          "chunk": "sprites_basics_and_pointers",
          "topic": "sprite pointers and coordinate registers"
        }
      ]
    },
    {
      "start": 798,
      "end": 798,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 799,
      "end": 806,
      "name": "tech_tech_effects",
      "description": "Tech-tech effects: per-line X-scroll by changing $D016 lower 3 bits allows 0..7 px shift per character row, but limited to 7 px. To get wider shifts, switch character sets mid-frame (change $D018 lower 4 bits) to charsets shifted by one pixel; with 7 charsets you can get up to 56-pixel wide tech-tech using VIC page space and charset swaps. Alternative: change VIC bank via $DD00 for more graphics.",
      "references": [
        {
          "chunk": "changing_charset_and_d018",
          "topic": "using multiple charsets via $D018 for wider shifts"
        }
      ]
    },
    {
      "start": 807,
      "end": 819,
      "name": "fli_afli_ifli_formats",
      "description": "FLI (Flexible Line Interpretation) family: FLI gives more colours per character using 8 screen RAMs and one bitmap by triggering a Bad Line each raster line and changing $D018 to point to different screen RAMs per-line (values $08,$18,...,$78). AFLI is hires variant (uses $4000 bytes). IFLI interlaces two FLI frames and alternates X-scroll for perceived higher resolution. Notes: FLI bug: first 3 chars per line unusable; AFLI will show grey, which may require sprites to mask.",
      "references": [
        {
          "chunk": "stable_raster_interrupts",
          "topic": "FLI gives stable raster as a side-effect"
        }
      ]
    },
    {
      "start": 820,
      "end": 820,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 821,
      "end": 825,
      "name": "opening_side_border",
      "description": "Opening the side border: requires a stable raster and per-line timing; analogous to top/bottom border method but uses $D016 manipulations per raster line. Hint: use DEC $D016 then INC $D016 for timing; test with $D021 to find correct timing next to right border.",
      "references": [
        {
          "chunk": "stable_raster_interrupts",
          "topic": "need for stable raster timing"
        }
      ]
    },
    {
      "start": 826,
      "end": 826,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 827,
      "end": 836,
      "name": "plasmas_bumpmappers_3d_overview",
      "description": "Overview of higher-level effects (plasmas, bumpmappers, 3D): not C-64-specific algorithms, often implemented as character/bitmap-based approximations (8x8 or 4x4 chunking, half-FLI to force Bad Line every 4th raster for 80x50 effect), or vector plotters on bitmap requiring optimized line-drawing and plotting code.",
      "references": [
        {
          "chunk": "bitmap_screen_layout",
          "topic": "bitmap layout considerations for plotters"
        }
      ]
    },
    {
      "start": 837,
      "end": 838,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 839,
      "end": 843,
      "name": "the_rest_notes",
      "description": "Closing notes: encourages experimentation and combining basic effects; suggests there may still be undiscovered VIC tricks but less likely.",
      "references": []
    },
    {
      "start": 844,
      "end": 844,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 845,
      "end": 861,
      "name": "exercise_sample_demo_spec",
      "description": "Recommended exercise: build a small demo part containing a logo at top, 8 sprites moving in sine patterns (tables for X/Y, offsets per sprite), a bottom scroller, raster bars in top/bottom border, and a playing tune (ripped tunes often at $1000). Advice to pack/crunch the demo for distribution and testing.",
      "references": [
        {
          "chunk": "sine_editors_and_sample_basic",
          "topic": "creating sine tables for sprite motion"
        },
        {
          "chunk": "irq_loaders",
          "topic": "using IRQ loaders for multi-part demos"
        }
      ]
    },
    {
      "start": 862,
      "end": 862,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 863,
      "end": 869,
      "name": "tools_cartridges_overview",
      "description": "Cartridge recommendation: Action Replay (esp. v6) or Final Cartridge. Important features: fast loader and monitor for development, memory movement and debugging.",
      "references": [
        {
          "chunk": "using_a_monitor",
          "topic": "monitor features needed for debugging"
        }
      ]
    },
    {
      "start": 870,
      "end": 870,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 871,
      "end": 881,
      "name": "packers_and_crunchers",
      "description": "Packers (RLE) and crunchers (dictionary-based compressors) for reducing load size and time; recommended tools (PuCrunch for PC/Amiga side crunching), REU usage to speed crunching, linking packing methods vs packing memory areas.",
      "references": [
        {
          "chunk": "everything_works_until_i_pack_it",
          "topic": "packing can expose uninitialized memory bugs"
        }
      ]
    },
    {
      "start": 882,
      "end": 882,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 883,
      "end": 889,
      "name": "irq_loaders",
      "description": "IRQ loaders: load data while the demo runs by performing drive I/O in main loop without disturbing interrupt routines; often include init routine (overwritable) and loader routine (kept); some support on-the-fly decrunching; loader compatibility varies by drive.",
      "references": [
        {
          "chunk": "how_to_implement_interrupts_example",
          "topic": "interrupts needed for IRQ loaders"
        }
      ]
    },
    {
      "start": 890,
      "end": 890,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 891,
      "end": 895,
      "name": "sprite_char_graphics_editors",
      "description": "Editors: sprite, character and bitmap editors and conversion utilities; variety of tools exist for multi-/single-colour bitmaps, fonts, sprites and special formats.",
      "references": []
    },
    {
      "start": 896,
      "end": 896,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 897,
      "end": 915,
      "name": "sine_editors_and_sample_basic",
      "description": "Sine editors and generating tables: produce sine tables for sprite movement and effects; example BASIC program provided to poke a sine table into memory (loop over 2π with SIN(I) * amplitude). Suggests splitting larger values for scrolling bigger logos.",
      "references": [
        {
          "chunk": "sprite_example_movement",
          "topic": "using sine tables for coordinated sprite movement"
        }
      ]
    },
    {
      "start": 916,
      "end": 916,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 917,
      "end": 923,
      "name": "music_editors_overview",
      "description": "Overview of popular C-64 music editors: DMC and JCH editor (tracker-like), Sidwinder (optimized player), EMS and Odintracker (simple but may have packer issues). Player characteristics: rastertime and memory usage considerations.",
      "references": []
    },
    {
      "start": 924,
      "end": 924,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 925,
      "end": 929,
      "name": "text_editors_and_scroll_writers",
      "description": "Text editors and scroll text writers: tools to prepare scrolling text and support for custom page sizes for non-standard fonts or partial-screen displays.",
      "references": [
        {
          "chunk": "text_scroller_implementation",
          "topic": "preparing text data for scrollers"
        }
      ]
    },
    {
      "start": 930,
      "end": 930,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 931,
      "end": 933,
      "name": "noters",
      "description": "Noters: small utilities to produce release notes; advice on creating custom notes per release or using a generic noter for small releases.",
      "references": []
    },
    {
      "start": 934,
      "end": 934,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 935,
      "end": 936,
      "name": "other_tools_short_note",
      "description": "Miscellaneous other tools exist; if you need a tool, someone likely already wrote it.",
      "references": []
    },
    {
      "start": 937,
      "end": 938,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 939,
      "end": 942,
      "name": "common_pitfalls_intro",
      "description": "Common pitfalls section header: reference area to check when encountering mysterious bugs or unexpected behaviour.",
      "references": []
    },
    {
      "start": 943,
      "end": 947,
      "name": "final_cartridge_problems",
      "description": "Advice about Final Cartridge: some demos behave differently when cartridge present; if problems occur, test with cart removed to isolate cartridge-related interference.",
      "references": []
    },
    {
      "start": 948,
      "end": 948,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 949,
      "end": 951,
      "name": "graphics_at_1000_or_9000_warning",
      "description": "Warning: graphics placed in $1000-$1FFF or $9000-$9FFF may appear to use standard CBM charset because VIC will always see the ROM charset in these areas; do not place custom charsets/sprite data there.",
      "references": [
        {
          "chunk": "changing_charset_and_d018",
          "topic": "proper placement of charsets and how $D018 points to them"
        }
      ]
    },
    {
      "start": 952,
      "end": 952,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 953,
      "end": 955,
      "name": "garbage_in_vertical_border_or_behind_fld",
      "description": "If garbage appears in top/bottom border or during FLD, clear the last byte of the current VIC bank (e.g. $3FFF for default bank) but beware this may overwrite code/data and cause crashes.",
      "references": [
        {
          "chunk": "opening_top_and_bottom_border",
          "topic": "border behaviour and VIC bank end being displayed"
        }
      ]
    },
    {
      "start": 956,
      "end": 956,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 957,
      "end": 961,
      "name": "everything_works_until_i_pack_it",
      "description": "Post-pack bugs: often caused by uninitialized memory assumptions that different packers reveal; try different packers or ensure all memory is initialized before packing.",
      "references": [
        {
          "chunk": "packers_and_crunchers",
          "topic": "packers/crunchers differences and reliability"
        }
      ]
    },
    {
      "start": 962,
      "end": 962,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 963,
      "end": 973,
      "name": "a_few_words_about_optimization",
      "description": "Optimization overview for demo coding: keep screen updating each frame, optimize per-iteration cycle counts, prefer algorithmic improvements and then instruction-level optimizations for effects where computations exceed frame time.",
      "references": [
        {
          "chunk": "how_to_optimize_computations",
          "topic": "instruction-level and table-based optimizations"
        }
      ]
    },
    {
      "start": 974,
      "end": 974,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 975,
      "end": 980,
      "name": "how_to_optimize_computations",
      "description": "General strategies to optimize 6502 code: reduce cycles per computation, consult opcode cycle tables, and use techniques like removing unnecessary instructions, substituting faster instruction sequences, loop unrolling, zero page usage and lookup tables.",
      "references": [
        {
          "chunk": "use_the_zero_page",
          "topic": "using zero page for faster LDA/STA"
        },
        {
          "chunk": "loop_unrolling",
          "topic": "example and benefits of loop unrolling"
        }
      ]
    },
    {
      "start": 981,
      "end": 984,
      "name": "removing_instructions",
      "description": "Remove unnecessary instructions to save cycles; e.g., some CLC instructions can sometimes be omitted if flags are already correct.",
      "references": [
        {
          "chunk": "substituting_instructions",
          "topic": "replace sequences with single faster instructions (INC vs LDX/INX/STX)"
        }
      ]
    },
    {
      "start": 985,
      "end": 993,
      "name": "substituting_instructions",
      "description": "Substitution example: replacing LDX var / INX / STX var sequence (10 cycles) with INC var (faster), when the loaded value isn't needed later. Illustrates choosing instruction sequences to reduce cycles.",
      "references": [
        {
          "chunk": "removing_instructions",
          "topic": "general advice to drop unnecessary ops"
        }
      ]
    },
    {
      "start": 994,
      "end": 994,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 995,
      "end": 1024,
      "name": "loop_unrolling",
      "description": "Loop unrolling example: a loop of INC table,X / DEX / BNE takes ~12 cycles per iteration (256 iterations ~3074 cycles). Unrolled static sequence of INC table+N saves branch/loop overhead: 256 * 6 cycles = 1536 cycles. Trade-off: memory usage vs speed.",
      "references": [
        {
          "chunk": "using_tables",
          "topic": "table-driven approaches often used with unrolled code"
        }
      ]
    },
    {
      "start": 1025,
      "end": 1026,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1027,
      "end": 1029,
      "name": "use_the_zero_page",
      "description": "Zero page performance tip: LDA/STA to zero page addresses take fewer cycles (3 cycles) than absolute addressing (4 cycles); use zero page for frequently accessed variables.",
      "references": []
    },
    {
      "start": 1030,
      "end": 1030,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1031,
      "end": 1033,
      "name": "using_tables",
      "description": "Use lookup tables (e.g., precomputed sine tables) to avoid expensive runtime computations; tables trade memory for speed and are commonly used for effects like sine-based motion and precomputed shifts.",
      "references": [
        {
          "chunk": "sine_editors_and_sample_basic",
          "topic": "creating sine tables in BASIC or with table editors"
        }
      ]
    },
    {
      "start": 1034,
      "end": 1034,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1035,
      "end": 1037,
      "name": "other_optimizations",
      "description": "Generic optimization advice: unroll loops, remove unnecessary instructions, use tables and zero page; always look for smarter data/layout changes to simplify computation.",
      "references": []
    },
    {
      "start": 1038,
      "end": 1038,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1039,
      "end": 1041,
      "name": "other_ways_to_make_code_faster",
      "description": "Higher-level optimization: change data or algorithm to enable faster routines; sometimes reformatting data allows simpler and faster code.",
      "references": []
    },
    {
      "start": 1042,
      "end": 1042,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1043,
      "end": 1047,
      "name": "reusing_stuff",
      "description": "Re-use computation results between frames or code paths to avoid redundant expensive calculations; cache results in tables or variables when appropriate.",
      "references": []
    },
    {
      "start": 1048,
      "end": 1048,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1049,
      "end": 1052,
      "name": "making_assumptions_about_data",
      "description": "Don't over-generalize: write code assumptions for your specific data to remove unnecessary checks and branches; tailor routines to expected inputs for speed.",
      "references": []
    },
    {
      "start": 1053,
      "end": 1054,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1055,
      "end": 1060,
      "name": "other_documents_needed",
      "description": "References and recommended additional documents to study beyond this tutorial; encourages learning from demos and extracting techniques by inspection.",
      "references": [
        {
          "chunk": "references_lines",
          "topic": "list of specific documents and articles"
        }
      ]
    },
    {
      "start": 1061,
      "end": 1070,
      "name": "references_lines",
      "description": "Specific references: 'Mapping the C-64' (memory map), 'Programmer's Reference Guide' (opcode table & cycles), 'All About Your C-64', and Christian Bauer's VIC-II article. FTP/Project links mentioned.",
      "references": [
        {
          "chunk": "urls_lines",
          "topic": "FTP URLs for further downloads"
        }
      ]
    },
    {
      "start": 1071,
      "end": 1078,
      "name": "magazines_with_tutorials",
      "description": "Magazines with demo programming tutorials: C=Hacking (assembler tutorials and effects), Discovery (demo articles), Coders World (disk mag with beginner-friendly code examples). Locations and availability discussed.",
      "references": [
        {
          "chunk": "references_lines",
          "topic": "documentation references"
        }
      ]
    },
    {
      "start": 1079,
      "end": 1086,
      "name": "urls_lines",
      "description": "Suggested FTP sites with demos and tools: ftp://c64.rulez.org/pub/c64/, ftp://utopia.hacktic.nl/pub/c64/, ftp://ftp.elysium.pl/; general advice to search for required tools online.",
      "references": []
    },
    {
      "start": 1087,
      "end": 1100,
      "name": "contacting_the_author",
      "description": "Author contact info (email and postal): puterman@civitas64.de and snail-mail address in Uppsala, Sweden. Invitation to provide feedback on the document.",
      "references": []
    },
    {
      "start": 1101,
      "end": 1109,
      "name": "copying_document_policy",
      "description": "Copyright / distribution policy: document released into the public domain; encourage mirroring, conversion to other formats, and contributions via patches or source changes.",
      "references": []
    },
    {
      "start": 1110,
      "end": 1110,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1111,
      "end": 1113,
      "name": "about_document_header",
      "description": "About this document header and title: metadata identifying the document and its generation process.",
      "references": []
    },
    {
      "start": 1114,
      "end": 1116,
      "ignore": true,
      "reason": "Copyright notices (non-technical/legal metadata)"
    },
    {
      "start": 1117,
      "end": 1117,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1118,
      "end": 1122,
      "name": "translation_and_commandline_info",
      "description": "LaTeX2HTML translator notes and command-line used for generating the document; timestamp of translation initiation.",
      "references": []
    },
    {
      "start": 1123,
      "end": 1144,
      "name": "footnotes_and_footer",
      "description": "Document footnotes explaining side remarks (danger of pointers, assembler neutrality, Turbo Assembler RESTORE caveat, PAL/NTSC refresh rates, 14-bit VIC addressing detail, bitmap layout note, cycle counting note) and final footer/timestamps.",
      "references": [
        {
          "chunk": "d012_raster_register",
          "topic": "note on PAL vs NTSC refresh rates and raster line counts"
        },
        {
          "chunk": "bitmap_screen_layout",
          "topic": "note clarifying bitmap layout vs other platforms"
        }
      ]
    }
  ],
  "source_md5": "54902969297084ae2a0abba6a72462fc"
}
