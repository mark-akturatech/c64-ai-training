{
  "source_file": "6502 machine language.txt",
  "context": "MACHINE",
  "splits": [
    {
      "start": 1,
      "end": 257,
      "ignore": true,
      "reason": "Front matter: title, author/publishing credits, copyright and legal notices, table of contents, preface, acknowledgements, and other non-technical front-matter."
    },
    {
      "start": 258,
      "end": 321,
      "name": "introduction_and_chapter_overview",
      "description": "Introductory motivation for learning machine language (speed, versatility, comprehension), portability of skills across systems, prerequisites, and an overview of Chapter 1 topics (inner workings, binary/hex notation, 650x architecture, machine language monitor, first commands, simple program).",
      "references": [
        {
          "chunk": "inner_workings_binary",
          "topic": "begins detailed coverage of binary numbers and bits"
        },
        {
          "chunk": "monitors_overview",
          "topic": "introduces the machine language monitor mentioned in the chapter topics"
        }
      ]
    },
    {
      "start": 322,
      "end": 364,
      "name": "inner_workings_binary",
      "description": "Explanation of basic binary concepts: digital circuits have two states; representation of ON/OFF as 1/0; bits and bytes; grouping eight bits as a byte; bit numbering (bit 0 at right to bit 7 at left) and reasons for that numbering.",
      "references": [
        {
          "chunk": "hexadecimal_notation",
          "topic": "shows how humans use hex to represent binary groups"
        },
        {
          "chunk": "number_ranges",
          "topic": "applies bit weights to compute numeric ranges for addresses and data"
        }
      ]
    },
    {
      "start": 365,
      "end": 418,
      "name": "bus_overview_650x",
      "description": "Defines the bus concept (groups of wires used together), lists 650x family chips (6502, 6510, 6509, 7501), and explains the address bus: 16 address lines sent by the CPU to select a memory/device chip; how a single chip is selected among many. Includes Figure 1.1 (address bus illustration) and remarks about address decoding.",
      "references": [
        {
          "chunk": "data_bus_two_way",
          "topic": "explains data flow once a chip is selected"
        },
        {
          "chunk": "memory_elements_and_mapped_io",
          "topic": "describes types of devices attached to the address bus (RAM/ROM/IA)"
        }
      ]
    },
    {
      "start": 419,
      "end": 465,
      "name": "data_bus_two_way",
      "description": "Describes the 8-bit two-way data bus used by the 650x: data format examples, read vs write operations, the role of control lines (timing and read/write direction) and Figure 1.2 (two-way data bus illustration).",
      "references": [
        {
          "chunk": "bus_overview_650x",
          "topic": "complements address bus selection process"
        },
        {
          "chunk": "number_ranges",
          "topic": "relates data bus width (8 bits) to 256 possible values per memory location"
        }
      ]
    },
    {
      "start": 466,
      "end": 511,
      "name": "number_ranges",
      "description": "Explains numeric ranges derived from bus widths: 16-bit address bus yields 65,536 addresses; 8-bit data bus yields 256 values. Introduces bit weighting for converting binary addresses to decimal (weights 1..32768) and includes a diagram showing eight- and sixteen-bit weights (Figure 1.3).",
      "references": [
        {
          "chunk": "inner_workings_binary",
          "topic": "uses bit concepts to compute numeric weights"
        },
        {
          "chunk": "hexadecimal_notation",
          "topic": "introduces hex as a convenient human representation of these binary values"
        }
      ]
    },
    {
      "start": 512,
      "end": 560,
      "name": "hexadecimal_notation",
      "description": "Introduces hexadecimal as a compact human representation of binary: grouping bits in nibbles (4 bits), hex digit table mapping 0000..1111 to 0..F, notation using $ prefix (e.g. $12AC), and representation of 8-bit values with two hex digits (example: %01011011 = $5B).",
      "references": [
        {
          "chunk": "hex_to_decimal",
          "topic": "gives the algorithm to convert hex to decimal"
        },
        {
          "chunk": "decimal_to_hexadecimal_methods",
          "topic": "covers methods to convert decimal to hex"
        }
      ]
    },
    {
      "start": 561,
      "end": 606,
      "name": "hex_to_decimal",
      "description": "Algorithm to convert hexadecimal to decimal: stepwise multiply-then-add method illustrated on $12AC, with explanation about speaking hex digits (say 'one two A C' rather than 'twenty-four').",
      "references": [
        {
          "chunk": "hexadecimal_notation",
          "topic": "explains the hex digit grouping used by this conversion"
        },
        {
          "chunk": "decimal_to_hexadecimal_methods",
          "topic": "provides the inverse conversion techniques"
        }
      ]
    },
    {
      "start": 607,
      "end": 642,
      "name": "decimal_to_hexadecimal_methods",
      "description": "Methods for converting decimal to hexadecimal: standard repeated-division-by-16 algorithm (remainders give hex digits right-to-left), a useful fraction-to-hex table for calculators (fractions .0000 to .9375 mapping to 0..F), worked example converting 4780 to $12AC, and notes on alternative methods/tools and programmer experience.",
      "references": [
        {
          "chunk": "hexadecimal_notation",
          "topic": "explains why hex is used to represent binary values"
        },
        {
          "chunk": "number_ranges",
          "topic": "applies conversions when interpreting addresses or values"
        }
      ]
    },
    {
      "start": 643,
      "end": 714,
      "name": "memory_elements_and_mapped_io",
      "description": "Describes the three main device types on the memory bus: RAM (read/write program/data storage), ROM (read-only routines/OS), and IA (interface adapters: memory-mapped I/O devices like PIA/VIA/CIA/VIC/SID). Includes Figure 1.4 illustrating RAM/ROM/IA on the memory bus and an example of memory-mapped I/O ($D020 sets C64 border color). Also discusses address ranges and device decoding.",
      "references": [
        {
          "chunk": "bus_overview_650x",
          "topic": "explains how devices are selected using the address bus"
        },
        {
          "chunk": "microprocessor_registers",
          "topic": "registers are used to address or manipulate data in these memory elements"
        }
      ]
    },
    {
      "start": 715,
      "end": 758,
      "name": "microprocessor_registers",
      "description": "Introduces the 650x internal registers: PC (16-bit program counter), A/X/Y (8-bit data registers), SR (status register / PSW), and SP (stack pointer). Includes a block diagram (Figure 1.5) showing registers relative to the address and data buses and notes that PC will be discussed next in more detail.",
      "references": [
        {
          "chunk": "instruction_execution_fetch_cycle",
          "topic": "details how PC is used to fetch instructions"
        },
        {
          "chunk": "data_registers_a_x_y",
          "topic": "describes usage of A/X/Y for data operations"
        }
      ]
    },
    {
      "start": 759,
      "end": 800,
      "name": "instruction_execution_fetch_cycle",
      "description": "Describes the instruction fetch/execute cycle: PC places an address on the address bus, PC increments, memory returns the instruction on the data bus, the CPU executes it, then repeats with the next PC. Includes diagram Figure 1.6 and explanation of sequential execution and branching.",
      "references": [
        {
          "chunk": "microprocessor_registers",
          "topic": "PC behavior relates to the register set"
        },
        {
          "chunk": "detail_program_execution",
          "topic": "gives a step-by-step walk-through of executing the sample program"
        }
      ]
    },
    {
      "start": 801,
      "end": 829,
      "name": "data_registers_a_x_y",
      "description": "Explains the roles of the A, X, and Y registers: they hold/manipulate 8-bit data, can be loaded from memory and stored back, and act as intermediaries because the 650x cannot move memory-to-memory directly. Notes later special roles (A as accumulator) but treats them as interchangeable for now.",
      "references": [
        {
          "chunk": "first_program_exchange_example",
          "topic": "demonstrates using A and X to swap two memory bytes"
        },
        {
          "chunk": "instruction_execution_fetch_cycle",
          "topic": "registers receive data as part of instruction execution"
        }
      ]
    },
    {
      "start": 830,
      "end": 896,
      "name": "first_program_exchange_example",
      "description": "A step-by-step first program: goal to exchange contents of $0380 and $0381. Planning (can't copy memory-to-memory directly), choose registers (LDA $0380, LDX $0381, STA $0381, STX $0380) and append BRK to stop. Introduces assembly mnemonics (LDA/LDX/STA/STX/BRK) and hand-assembly concept. Explains little-endian address byte order (low byte first) and why addresses need two bytes after opcodes.",
      "references": [
        {
          "chunk": "opcode_encoding_and_translation",
          "topic": "shows machine code opcodes corresponding to the mnemonics used"
        },
        {
          "chunk": "choosing_program_location",
          "topic": "selects where to put the assembled program in RAM (cassette buffer $033C)"
        }
      ]
    },
    {
      "start": 897,
      "end": 926,
      "name": "opcode_encoding_and_translation",
      "description": "Provides opcode values for common instructions used in the example (LDA AD, LDX AE, LDY AC, BRK 00, STA 8D, STX 8E, STY 8C). Shows full assembled machine-code listing for the swap program, explains left-side object code vs right-side assembly/source code, defines assembly/hand-assembly, and notes the assembled program length (13 bytes).",
      "references": [
        {
          "chunk": "first_program_exchange_example",
          "topic": "assembly source that was translated here"
        },
        {
          "chunk": "entering_program_with_mlm",
          "topic": "how to place these hex bytes into memory using a monitor"
        }
      ]
    },
    {
      "start": 927,
      "end": 940,
      "name": "choosing_program_location",
      "description": "Discusses selecting a RAM location for the test program: suggests cassette buffer starting at $033C (decimal 828) for short test programs, and notes the need to use a machine language monitor to enter the code into RAM.",
      "references": [
        {
          "chunk": "opcode_encoding_and_translation",
          "topic": "the assembled bytes to be placed at the chosen address"
        },
        {
          "chunk": "monitors_overview",
          "topic": "introduces monitors used to load or enter code into memory"
        }
      ]
    },
    {
      "start": 941,
      "end": 965,
      "name": "monitors_overview",
      "description": "Explains the concept of monitors vs. operating system/BASIC monitors: monitors are programs for direct machine-language interaction. Notes that PET/CBM has a built-in MLM, VIC-20 and C64 typically require an added monitor (cartridge or RAM load), and PLUS/4 has a powerful built-in MLM. Gives common entry commands (SYS 4, SYS 8, or MONITOR) depending on machine.",
      "references": [
        {
          "chunk": "machine_language_monitor_usage",
          "topic": "details the typical features and commands of a machine language monitor"
        },
        {
          "chunk": "entering_program_with_mlm",
          "topic": "practical steps to enter assembled code using a monitor"
        }
      ]
    },
    {
      "start": 966,
      "end": 983,
      "name": "machine_language_monitor_usage",
      "description": "More on MLM availability and usage: monitors can be extended or replaced, come on cartridges or as ROM/RAM loads, can be bought or club-provided. Advises obtaining/starting a monitor and gives machine-specific examples to enter it (SYS 4 for PET/CBM, SYS 8 for VIC/C64, MONITOR on PLUS/4).",
      "references": [
        {
          "chunk": "monitors_overview",
          "topic": "context and machine-specific entry points"
        },
        {
          "chunk": "monitor_register_display",
          "topic": "what you'll see when you enter an MLM (register display example)"
        }
      ]
    },
    {
      "start": 984,
      "end": 1034,
      "name": "monitor_register_display",
      "description": "Explains the typical monitor display when entering an MLM: example header showing B*, and register titles (PC SR AC XR YR SP). Describes meanings: B* (break), PC (next instruction address), SR (status register), AC/XR/YR (A/X/Y contents), SP (stack pointer example $01F8), and mentions IRQ as an extra monitor field stored in memory. Explains the period prompt as 'ready' for commands.",
      "references": [
        {
          "chunk": "mlm_commands_reference",
          "topic": "commands to use from the monitor (exit .X, display memory .M, run .G, etc.)"
        },
        {
          "chunk": "displaying_memory_and_format",
          "topic": "how memory displays appear and what the hex bytes mean"
        }
      ]
    },
    {
      "start": 1035,
      "end": 1076,
      "name": "mlm_commands_reference",
      "description": "Lists key machine language monitor commands and their meanings: .X to exit to BASIC, .M to display memory ranges, .R to display registers, .G to go/start program at address, and warns about .S/.L save/load until familiar with BASIC pointers. Emphasizes monitors don't accept BASIC commands and BASIC won't accept MLM commands.",
      "references": [
        {
          "chunk": "monitor_register_display",
          "topic": "register display that appears when you enter the MLM"
        },
        {
          "chunk": "entering_program_with_mlm",
          "topic": "use of .M and .G when entering and running a program"
        }
      ]
    },
    {
      "start": 1077,
      "end": 1111,
      "name": "displaying_memory_and_format",
      "description": "Demonstrates the .M memory display command (.M 1000 1010): explains format of lines showing base address and eight hex byte values, clarifies that the monitor prints hex values, and notes monitors typically show eight bytes per line and will fill the remainder of a line even when end address is earlier than line end.",
      "references": [
        {
          "chunk": "editing_memory_and_registers",
          "topic": "how to change memory bytes shown by .M using screen editing"
        },
        {
          "chunk": "entering_program_with_mlm",
          "topic": "using .M prior to editing memory to place a program"
        }
      ]
    },
    {
      "start": 1112,
      "end": 1139,
      "name": "editing_memory_and_registers",
      "description": "Explains changing memory contents (screen editing): position the cursor over displayed hex byte, type new value, press RETURN to write it to memory; warns to press RETURN before moving to next line. Also covers changing registers via .R display and typing new values (cautioning not to change SR and SP unless you know the consequences).",
      "references": [
        {
          "chunk": "displaying_memory_and_format",
          "topic": "shows the display you will edit"
        },
        {
          "chunk": "entering_program_with_mlm",
          "topic": "practical example of entering assembled bytes by editing memory"
        }
      ]
    },
    {
      "start": 1140,
      "end": 1186,
      "name": "entering_program_with_mlm",
      "description": "Step-by-step: map assembled bytes to addresses starting at $033C, show listing with addresses and hex bytes, use .M 033C 0348 to display the target area, type over the hex bytes line-by-line (press RETURN to commit each line), and verify with another .M to ensure the program is correctly written to RAM.",
      "references": [
        {
          "chunk": "choosing_program_location",
          "topic": "explains the cassette buffer $033C chosen as the target area"
        },
        {
          "chunk": "preparing_and_running_program",
          "topic": "next steps to prepare data values and run the program with .G"
        }
      ]
    },
    {
      "start": 1187,
      "end": 1222,
      "name": "preparing_and_running_program",
      "description": "Preparation before running the swap program: initialize memory locations $0380/$0381 to known values (example: 11 and 99) via .M editing, then run the program with .G 033C. Notes that execution is extremely fast, BRK returns to MLM with B* display, and suggests checking register changes and memory to confirm the swap.",
      "references": [
        {
          "chunk": "entering_program_with_mlm",
          "topic": "how the program was entered before running"
        },
        {
          "chunk": "detail_program_execution",
          "topic": "gives a step-by-step account of what the CPU did during the run"
        }
      ]
    },
    {
      "start": 1223,
      "end": 1253,
      "name": "summary_learning_points",
      "description": "Concise summary of Chapter 1 takeaways: computers use binary; hex is a human shorthand; 650x addresses memory via the memory bus; 650x has internal registers (PC, A/X/Y, SR, SP); PC points to next instruction; A/X/Y are used to load/store data; 650x uses little-endian address ordering (low byte first); and the machine language monitor provides a direct hexadecimal interface to inspect/change memory.",
      "references": [
        {
          "chunk": "microprocessor_registers",
          "topic": "details register roles summarized here"
        },
        {
          "chunk": "monitors_overview",
          "topic": "monitor concepts referenced in the summary"
        }
      ]
    },
    {
      "start": 1254,
      "end": 1276,
      "name": "detail_program_execution",
      "description": "Detailed step-by-step execution trace for the running of the example program: CPU reads opcode at $033C ($AD), recognizes two-byte operand requirement, fetches $033D and $033E ($80,$03) to form effective address $0380, PC advanced, executes LDA reading $0380 into A, and continues with next instruction at $033F—illustrates the multi-fetch nature of instructions with multi-byte operands.",
      "references": [
        {
          "chunk": "instruction_execution_fetch_cycle",
          "topic": "general fetch-execute cycle explained earlier"
        },
        {
          "chunk": "preparing_and_running_program",
          "topic": "practical context: the example program that was run"
        }
      ]
    },
    {
      "start": 1277,
      "end": 1308,
      "name": "questions_and_projects",
      "description": "Practice questions and project suggestions: ideas about screen memory locations across different Commodore machines ($8000, $1E00, $0400, $0C00), notes on pitfalls (screen scroll, color visibility), and a programming challenge to rotate five memory locations end-around using only the three registers (A,X,Y).",
      "references": [
        {
          "chunk": "memory_elements_and_mapped_io",
          "topic": "screen memory is a memory-mapped resource described earlier"
        },
        {
          "chunk": "data_registers_a_x_y",
          "topic": "challenge relies on clever use of the three data registers"
        }
      ]
    },
    {
      "start": 1309,
      "end": 1337,
      "name": "chapter2_overview_and_toc",
      "description": "Chapter 2 title and table of contents for the chapter: lists topics covered (calling machine-language subroutines, PRINT subroutine, immediate addressing, calling from BASIC, tiny assembler programs, indexed addressing, simple loops, disassembly).",
      "references": [
        {
          "chunk": "calling_subroutines_concept",
          "topic": "introduces machine-language subroutines (JSR/RTS)"
        },
        {
          "chunk": "chrout_output_subroutine",
          "topic": "key output subroutine CHROUT is covered later"
        }
      ]
    },
    {
      "start": 1338,
      "end": 1366,
      "name": "calling_subroutines_concept",
      "description": "Explains the machine-language subroutine mechanism: JSR (jump to subroutine) and RTS (return from subroutine), how the program counter changes, nesting of subroutines, and the analogy to BASIC's GOSUB/RETURN.",
      "references": [
        {
          "chunk": "chapter2_overview_and_toc",
          "topic": "chapter topics and context"
        },
        {
          "chunk": "prewritten_kernal_subroutines",
          "topic": "calls to ROM 'kernal' subroutines described next"
        }
      ]
    },
    {
      "start": 1367,
      "end": 1386,
      "name": "prewritten_kernal_subroutines",
      "description": "Introduces the Commodore 'kernal' ROM routines: persistent system subroutines present on all Commodore machines; brief background on the term 'kernal' and that details are in the reference manuals.",
      "references": [
        {
          "chunk": "calling_subroutines_concept",
          "topic": "follows explanation of JSR/RTS"
        },
        {
          "chunk": "common_kernal_subroutines_table",
          "topic": "lists three important kernal routines and their addresses"
        }
      ]
    },
    {
      "start": 1387,
      "end": 1401,
      "name": "common_kernal_subroutines_table",
      "description": "Table of three major kernal subroutines used in following examples: $FFD2 CHROUT (output ASCII character), $FFE4 GETIN (input ASCII character), $FFE1 STOP (checks RUN/STOP key). Notes on using CHROUT to print to the screen.",
      "references": [
        {
          "chunk": "prewritten_kernal_subroutines",
          "topic": "context for kernal routines"
        },
        {
          "chunk": "chrout_output_subroutine",
          "topic": "detailed CHROUT behavior follows"
        }
      ]
    },
    {
      "start": 1402,
      "end": 1431,
      "name": "chrout_output_subroutine",
      "description": "Detailed description of the CHROUT subroutine at $FFD2: purpose (sends A register to output channel), typical use (screen output), character encoding (ASCII/PET ASCII), preservation of registers A/X/Y across the call, and status flags (carry may indicate output problems on some machines).",
      "references": [
        {
          "chunk": "common_kernal_subroutines_table",
          "topic": "CHROUT location and role"
        },
        {
          "chunk": "printing_single_character_steps",
          "topic": "how to use CHROUT to print a single character"
        }
      ]
    },
    {
      "start": 1432,
      "end": 1438,
      "name": "printing_single_character_steps",
      "description": "Two-step example for printing one character with CHROUT: load ASCII code into A (e.g., LDA #$58 for 'X') then JSR $FFD2 to call CHROUT.",
      "references": [
        {
          "chunk": "chrout_output_subroutine",
          "topic": "uses CHROUT to output the A register"
        },
        {
          "chunk": "why_not_poke_screen_vs_ch_rout",
          "topic": "contrast CHROUT with direct screen POKEs"
        }
      ]
    },
    {
      "start": 1439,
      "end": 1480,
      "name": "why_not_poke_screen_vs_ch_rout",
      "description": "Explains reasons to use CHROUT instead of directly writing (POKE) to screen memory: automatic cursor placement, automatic scrolling, ASCII vs screen codes, screen memory location variability, honoring control characters (RETURN, cursor movement, color), and automatic color handling on VIC/64.",
      "references": [
        {
          "chunk": "printing_single_character_steps",
          "topic": "alternative to direct POKE to display characters"
        },
        {
          "chunk": "print_project_building_H_program",
          "topic": "practical printing example using CHROUT"
        }
      ]
    },
    {
      "start": 1481,
      "end": 1511,
      "name": "print_project_building_H_program",
      "description": "Starts a small project to print the letter 'H' using address $033C (cassette buffer). Introduces immediate addressing symbol (#), example instructions (LDA #$48; JSR $FFD2; BRK) and the use of the monitor for assembling and testing.",
      "references": [
        {
          "chunk": "why_not_poke_screen_vs_ch_rout",
          "topic": "explains why CHROUT is preferable for this task"
        },
        {
          "chunk": "monitor_assembler_extensions_nonsymbolic",
          "topic": "use the monitor assembler to create the program"
        }
      ]
    },
    {
      "start": 1512,
      "end": 1533,
      "name": "monitor_assembler_extensions_nonsymbolic",
      "description": "Describes monitor assembler extensions: many machine-language monitors include an .A assemble command; some built-in monitors (PET/CBM) need extensions; assemblers are typically nonsymbolic (require numeric addresses rather than labels).",
      "references": [
        {
          "chunk": "print_project_building_H_program",
          "topic": "assemble the tiny printing program using the monitor"
        },
        {
          "chunk": "assembling_using_monitor_example",
          "topic": "example .A command usage and behavior"
        }
      ]
    },
    {
      "start": 1534,
      "end": 1585,
      "name": "assembling_using_monitor_example",
      "description": "Step-by-step example of using the monitor .A assemble command at $033C: entering LDA #$48, JSR $FFD2, BRK; monitor feedback, error handling (question mark), resulting object bytes placed in memory; advice to view assembled bytes with .M display.",
      "references": [
        {
          "chunk": "monitor_assembler_extensions_nonsymbolic",
          "topic": "context for the .A assembler command"
        },
        {
          "chunk": "display_memory_and_object_bytes",
          "topic": "viewing the assembled bytes in memory with .M"
        }
      ]
    },
    {
      "start": 1586,
      "end": 1598,
      "name": "display_memory_and_object_bytes",
      "description": "Using the monitor memory display (.M) to inspect object bytes placed in memory (example .:033C A9 48 20 D2 FF 00 xx xx) and explanation that bytes after BRK are irrelevant for program execution.",
      "references": [
        {
          "chunk": "assembling_using_monitor_example",
          "topic": "follow-up: inspect what the assembler stored"
        },
        {
          "chunk": "disassembler_checking_and_editing",
          "topic": "use the disassembler to translate bytes back to readable source"
        }
      ]
    },
    {
      "start": 1599,
      "end": 1650,
      "name": "disassembler_checking_and_editing",
      "description": "Explains the monitor's disassembler (.D): inverse-assembly to translate bytes back to mnemonics, how to disassemble starting at an address (example .D 033C), reading the listing, editing errors directly by changing bytes on the left-hand side, and re-assembling a corrected line.",
      "references": [
        {
          "chunk": "display_memory_and_object_bytes",
          "topic": "disassembling the bytes you inspected"
        },
        {
          "chunk": "running_program_with_monitor",
          "topic": "run the program after verifying with the disassembler"
        }
      ]
    },
    {
      "start": 1651,
      "end": 1665,
      "name": "running_program_with_monitor",
      "description": "How to execute the assembled program from the monitor using .G address (e.g., .G 033C), expectations for output, and a simple extension exercise to print more characters.",
      "references": [
        {
          "chunk": "disassembler_checking_and_editing",
          "topic": "run the program once it's checked"
        },
        {
          "chunk": "linking_machine_language_with_basic",
          "topic": "next: how to run machine code from BASIC using SYS"
        }
      ]
    },
    {
      "start": 1666,
      "end": 1731,
      "name": "linking_machine_language_with_basic",
      "description": "Explains linking machine language with BASIC: change BRK to RTS so a machine-language routine can return to BASIC, editing the byte for BRK to RTS (00 -> 60) or re-assembling the final line, using .X to return to BASIC, calling via SYS 828 (address $033C), and combining BASIC loops with machine-language SYS calls. Also lists the three different subroutine call types (GOSUB, SYS, JSR).",
      "references": [
        {
          "chunk": "running_program_with_monitor",
          "topic": "running from the monitor vs running from BASIC"
        },
        {
          "chunk": "loops_introduction_indexed_addressing",
          "topic": "building loops for longer output strings"
        }
      ]
    },
    {
      "start": 1732,
      "end": 1783,
      "name": "loops_introduction_indexed_addressing",
      "description": "Introduces loops for printing multiple characters and indexed addressing: storing the string HELLO as data at $034A-$034F, using an index register (X) to step through addresses (LDA $034A,X), explanation of immediate addressing (#), and the concept of effective address formed by base + X/Y indexing.",
      "references": [
        {
          "chunk": "linking_machine_language_with_basic",
          "topic": "useful to combine BASIC and machine language for repeated output"
        },
        {
          "chunk": "loop_implementation_inx_cpx_bne_full_code",
          "topic": "complete loop implementation and control flow"
        }
      ]
    },
    {
      "start": 1784,
      "end": 1827,
      "name": "loop_implementation_inx_cpx_bne_full_code",
      "description": "Detailed loop implementation for printing HELLO: sample assembled lines (LDX #$00; LDA $034A,X; JSR $FFD2; INX; CPX #$06; BNE $033E; RTS), explanation of increment/decrement instructions (INX/INY/DEX/DEY), CPX compare and branch-not-equal behavior, and full assembled listing with addresses.",
      "references": [
        {
          "chunk": "loops_introduction_indexed_addressing",
          "topic": "uses indexed addressing to implement the loop"
        },
        {
          "chunk": "storing_data_message_and_basic_call_loops",
          "topic": "how to place string data and call the routine from BASIC"
        }
      ]
    },
    {
      "start": 1828,
      "end": 1852,
      "name": "storing_data_message_and_basic_call_loops",
      "description": "How to place the HELLO data into memory using .M 034A 034F and replacing bytes (48 45 4C 4C 4F 0D), running the program (SYS 828) to print HELLO, and sample BASIC loop to call the machine-language routine multiple times.",
      "references": [
        {
          "chunk": "loop_implementation_inx_cpx_bne_full_code",
          "topic": "the loop expects the character data at $034A-$034F"
        },
        {
          "chunk": "save_cassette_disk_pointer_issues",
          "topic": "issues with saving programs stored in cassette buffer area"
        }
      ]
    },
    {
      "start": 1853,
      "end": 1869,
      "name": "save_cassette_disk_pointer_issues",
      "description": "Explains problems saving machine-language code stored in the cassette buffer on VIC/64: SAVE-to-tape may overwrite the cassette buffer; some disk commands also use that buffer and may destroy the program. Notes that pointer issues related to BASIC variables when saving/loading are discussed in Chapter 6.",
      "references": [
        {
          "chunk": "storing_data_message_and_basic_call_loops",
          "topic": "why saving the example program is problematic on some machines"
        },
        {
          "chunk": "stopgap_save_using_data_and_poke",
          "topic": "workaround: store code as BASIC DATA and reconstruct with POKE"
        }
      ]
    },
    {
      "start": 1870,
      "end": 1926,
      "name": "stopgap_save_using_data_and_poke",
      "description": "A practical workaround for short programs: use BASIC PRINT PEEK to list bytes from memory (FOR J=828 TO 847:PRINT PEEK(J)), transcribe the decimal bytes into DATA statements, and reconstruct the machine code with a READ/POKE loop (FOR J=828 TO 847:READ X:POKE J,X:NEXT J). Includes example DATA lines and a full BASIC program to store and run the routine safely.",
      "references": [
        {
          "chunk": "save_cassette_disk_pointer_issues",
          "topic": "addresses the cassette/disk save problem"
        },
        {
          "chunk": "summary_learning_points_and_exercises",
          "topic": "summarizes what was learned and suggests projects"
        }
      ]
    },
    {
      "start": 1927,
      "end": 1982,
      "name": "summary_learning_points_and_exercises",
      "description": "Summary of key points ('Things You Have Learned'): JSR, RTS, SYS, CHROUT at $FFD2, monitor assembler and disassembler, immediate addressing (#), index registers X/Y and INX/DEX/INY/DEY. Followed by Questions and Projects: exercises using ASCII table, clearing screen with ASCII $93, printing messages, counting up vs down with X, using cursor movements and color to draw a box with HELLO inside.",
      "references": [
        {
          "chunk": "stopgap_save_using_data_and_poke",
          "topic": "practical save/reload technique referenced in the summary"
        },
        {
          "chunk": "chrout_output_subroutine",
          "topic": "reminder to use CHROUT for output and control characters"
        }
      ]
    },
    {
      "start": 1983,
      "end": 2011,
      "name": "chapter_overview_flags_logic_input",
      "description": "Chapter title and overview listing the topics covered: flags (Z, C, N, V), signed numbers, status register, interrupts, logical operators (AND, ORA, EOR), GETIN and STOP input subroutines.",
      "references": [
        {
          "chunk": "flags_introduction_and_z_flag",
          "topic": "Detailed explanation of flags and the Z flag"
        },
        {
          "chunk": "logical_operations_overview",
          "topic": "Logical operator topics introduced in the chapter"
        },
        {
          "chunk": "getin_subroutine_keyboard_input",
          "topic": "Input subroutines introduced here"
        }
      ]
    },
    {
      "start": 2012,
      "end": 2108,
      "name": "flags_introduction_and_z_flag",
      "description": "Introduces the concept of flags (status bits that link instructions across interrupts). Detailed description of the Z (zero/equals) flag: which instructions affect it (loads, increments, arithmetic, compares), which do not (stores, branches), examples showing how successive instructions change Z and how BEQ/BNE use Z.",
      "references": [
        {
          "chunk": "chapter_overview_flags_logic_input",
          "topic": "Chapter overview"
        },
        {
          "chunk": "c_flag_description",
          "topic": "Other testable flags (C)"
        },
        {
          "chunk": "comparison_instructions_and_branch_usage",
          "topic": "How CPX/CMP set Z for branches"
        }
      ]
    },
    {
      "start": 2109,
      "end": 2141,
      "name": "c_flag_description",
      "description": "Description of the C (carry / greater-or-equal) flag: meaning after comparisons, behavior in arithmetic, which instructions affect it (compare and arithmetic), branch instructions BCS/BCC, and direct set/clear via SEC and CLC. Notes on substituting branches (BNE vs BCC) in example loops.",
      "references": [
        {
          "chunk": "flags_introduction_and_z_flag",
          "topic": "Related Z flag behavior and compare/branch examples"
        },
        {
          "chunk": "v_flag_and_overflow",
          "topic": "Contrast with V flag for signed overflow"
        }
      ]
    },
    {
      "start": 2142,
      "end": 2208,
      "name": "n_flag_and_signed_numbers_introduction",
      "description": "Explanation of the N (negative / high-bit) flag: it reflects the high bit of a register and is affected by most register-changing instructions; branch instructions BMI/BPL test N. Includes a diversion explaining signed numbers and two's-complement representation, how high bit denotes negative in signed interpretation, and examples of counting past zero in hex.",
      "references": [
        {
          "chunk": "c_flag_description",
          "topic": "Other flag descriptions (C)"
        },
        {
          "chunk": "v_flag_and_overflow",
          "topic": "Signed-number overflow and the V flag"
        },
        {
          "chunk": "comparison_instructions_and_branch_usage",
          "topic": "How compares interact with N in practice"
        }
      ]
    },
    {
      "start": 2209,
      "end": 2252,
      "name": "v_flag_and_overflow",
      "description": "Details of the V (overflow / signed arithmetic overflow) flag: affected only by addition/subtraction and meaningful only for signed numbers. Typical uses (including BIT instruction which copies bit 6 into V), branch instructions BVS/BVC, direct clear via CLV, possibility of hardware setting on some chips. Includes a brief diversion explaining 'overflow' for signed vs unsigned and which flag (V vs C) indicates it.",
      "references": [
        {
          "chunk": "n_flag_and_signed_numbers_introduction",
          "topic": "Signed numbers explanation that makes V meaningful"
        },
        {
          "chunk": "flag_summary_and_status_register_overview",
          "topic": "Summary of flags and branching instructions"
        }
      ]
    },
    {
      "start": 2253,
      "end": 2325,
      "name": "flag_summary_and_status_register_overview",
      "description": "Concise flag summary table (Z, C, N, V) with their meanings, activity level, and corresponding branch instructions. Complete overview of the processor Status Register (SR): bit positions (7..0 = N V - B D I Z C), meanings of each bit including unused bit 5, B (break), D (decimal mode) with SED/CLD cautions, I (interrupt disable) with SEI/CLI, and examples for interpreting SR hex values. Warning about manually editing SR in monitor.",
      "references": [
        {
          "chunk": "flags_introduction_and_z_flag",
          "topic": "Z flag details referenced in SR"
        },
        {
          "chunk": "c_flag_description",
          "topic": "C flag referenced in SR"
        },
        {
          "chunk": "v_flag_and_overflow",
          "topic": "V flag and CLV instruction"
        }
      ]
    },
    {
      "start": 2326,
      "end": 2367,
      "name": "comparison_instructions_and_branch_usage",
      "description": "How to compare bytes using CMP/CPX/CPY (value must be in A/X/Y and the other value in memory or immediate). List of branch tests available after compare (BEQ, BNE, BCS, BCC). Examples showing how to combine branches to test for 'less than or equal to' (CPY #$05 then BEQ/BCC) and an optimized version (CPY #$06 then BCC). Emphasis on using common sense to reason about comparisons.",
      "references": [
        {
          "chunk": "flag_summary_and_status_register_overview",
          "topic": "Which flags compares affect (Z/C/N)"
        },
        {
          "chunk": "flags_introduction_and_z_flag",
          "topic": "Z flag behavior in compares"
        }
      ]
    },
    {
      "start": 2368,
      "end": 2405,
      "name": "instruction_review_and_branch_limits",
      "description": "Review of previously covered instructions and their categories: Load (LDA/LDX/LDY), Store (STA/STX/STY), Compare (CMP/CPX/CPY). Notes about register specializations (INX/INY/DEX/DEY for X/Y, A as accumulator for arithmetic). Review of subroutine calls (JSR/RTS) and BRK usage for debugging. Discussion of branch instructions (eight of them) and their limited short-range hops (around a hundred memory locations).",
      "references": [
        {
          "chunk": "comparison_instructions_and_branch_usage",
          "topic": "Compare + branch examples"
        },
        {
          "chunk": "logical_operations_overview",
          "topic": "Next topic: logical instructions that operate on A"
        }
      ]
    },
    {
      "start": 2406,
      "end": 2436,
      "name": "logical_operations_overview",
      "description": "Introduction to the three logical operations that work on the A register: AND (logical AND), ORA (logical OR), and EOR (exclusive OR). Notes on commutativity, the 'value and mask' mental model, and the per-bit independent operation of these instructions making them ideal for extracting or manipulating bits.",
      "references": [
        {
          "chunk": "instruction_review_and_branch_limits",
          "topic": "Logical operators operate on the A register discussed in instruction review"
        },
        {
          "chunk": "logical_and_and_examples",
          "topic": "AND details and example"
        },
        {
          "chunk": "logical_ora_and_examples",
          "topic": "ORA details and example"
        },
        {
          "chunk": "logical_eor_and_examples",
          "topic": "EOR details and example"
        }
      ]
    },
    {
      "start": 2437,
      "end": 2468,
      "name": "logical_and_and_examples",
      "description": "Detailed explanation of the AND instruction applied to A, with a truth table showing how AND masks can turn bits off. Example showing how to turn off bits 4,5,6 of $C7 using AND #$8F (mask 10001111b) and the resulting value.",
      "references": [
        {
          "chunk": "logical_operations_overview",
          "topic": "Conceptual intro to logical ops"
        },
        {
          "chunk": "logical_ora_and_examples",
          "topic": "Complementary operation ORA turns bits on"
        }
      ]
    },
    {
      "start": 2469,
      "end": 2498,
      "name": "logical_ora_and_examples",
      "description": "Detailed explanation of the ORA instruction applied to A, with a truth table showing how ORA masks can turn bits on. Example showing how to turn on bits 4,5,6 of $C7 using ORA #$70 (mask 01110000b) and the resulting value.",
      "references": [
        {
          "chunk": "logical_and_and_examples",
          "topic": "AND turns bits off; ORA is complementary"
        },
        {
          "chunk": "logical_eor_and_examples",
          "topic": "EOR flips bits (another common bitwise tool)"
        }
      ]
    },
    {
      "start": 2499,
      "end": 2531,
      "name": "logical_eor_and_examples",
      "description": "Detailed explanation of the EOR (exclusive OR) instruction applied to A, with a truth table showing how EOR masks flip bits when the mask bit is 1 and leave them unchanged when mask bit is 0. Example showing inversion of bits 4,5,6 of $C7 with EOR #$70 (01110000b) producing the resulting value.",
      "references": [
        {
          "chunk": "logical_ora_and_examples",
          "topic": "ORA turns bits on; comparison with EOR flipping bits"
        },
        {
          "chunk": "why_logical_operations_and_ascii_conversion",
          "topic": "Using logical ops for ASCII-to-binary conversion"
        }
      ]
    },
    {
      "start": 2532,
      "end": 2569,
      "name": "why_logical_operations_and_ascii_conversion",
      "description": "Explains why logical operators are useful: to control individual bits (IA port I/O control lines), to mask input bits for testing (use AND and check Z), to create oscillating effects (EOR), and for code translation tasks. Provides ASCII vs binary example (ASCII '5' = %00110101 vs binary 5 = %00000101) and notes how AND/ORA can convert between ASCII and numeric values more simply than arithmetic.",
      "references": [
        {
          "chunk": "logical_eor_and_examples",
          "topic": "EOR example and flipping bits"
        },
        {
          "chunk": "getin_subroutine_keyboard_input",
          "topic": "GETIN returns ASCII input useful to convert with logical ops"
        }
      ]
    },
    {
      "start": 2570,
      "end": 2625,
      "name": "getin_subroutine_keyboard_input",
      "description": "Description of the GETIN system subroutine at $FFE4 for keyboard input: behavior similar to BASIC GET (reads keyboard buffer, non-blocking, returns immediately), return values (ASCII in A or zero if no key), X/Y likely clobbered, special keys detected. Includes boxed subroutine documentation with registers and status notes. Recommends following GETIN with CHROUT to echo input to screen.",
      "references": [
        {
          "chunk": "stop_subroutine_runstop_key",
          "topic": "STOP subroutine checks RUN/STOP key (another input-related system call)"
        },
        {
          "chunk": "numeric_key_waiting_subroutine_project",
          "topic": "Example program using GETIN to read numeric keys"
        }
      ]
    },
    {
      "start": 2626,
      "end": 2665,
      "name": "stop_subroutine_runstop_key",
      "description": "Description of the STOP system subroutine at $FFE1 to check the RUN/STOP key: use frequently to make RUN/STOP effective for machine code programs, behavior on return (Z set if pressed), differences on PET/CBM (may return to BASIC and not to caller), registers affected and status behavior. Includes boxed documentation with registers and action details.",
      "references": [
        {
          "chunk": "getin_subroutine_keyboard_input",
          "topic": "Related input subroutine GETIN"
        },
        {
          "chunk": "numeric_key_waiting_subroutine_project",
          "topic": "Programming project uses STOP to allow aborting"
        }
      ]
    },
    {
      "start": 2666,
      "end": 2757,
      "name": "numeric_key_waiting_subroutine_project",
      "description": "Step-by-step programming project that implements a subroutine to wait for a numeric key (0-9): checks RUN/STOP via JSR $FFE1, calls GETIN ($FFE4) to read a key, uses CMP #$30 and BCC to reject values < '0', CMP #$3A and BCS to reject > '9' (note why #$3A is used), echoes valid key via JSR $FFD2, converts ASCII digit to binary with AND #$0F, and returns RTS. Includes notes on assembler addresses and testing.",
      "references": [
        {
          "chunk": "getin_subroutine_keyboard_input",
          "topic": "Uses GETIN for keyboard input"
        },
        {
          "chunk": "stop_subroutine_runstop_key",
          "topic": "Uses STOP to detect RUN/STOP key"
        },
        {
          "chunk": "why_logical_operations_and_ascii_conversion",
          "topic": "Converts ASCII to binary using AND #$0F"
        }
      ]
    },
    {
      "start": 2758,
      "end": 2798,
      "name": "recap_things_you_have_learned",
      "description": "Concise recap of chapter takeaways: role of flags linking instructions, which instructions affect flags, the four testable flags (Z, C, N, V) and their branches, status register contents including B/D/I flags, interrupts preserving state, signed numbers in two's-complement, and logical operator functions (AND/ORA/EOR) for bit manipulation.",
      "references": [
        {
          "chunk": "flag_summary_and_status_register_overview",
          "topic": "SR and flag summaries that underpin the recap"
        },
        {
          "chunk": "logical_operations_overview",
          "topic": "Summary references logical operators and their uses"
        }
      ]
    },
    {
      "start": 2799,
      "end": 2811,
      "name": "questions_and_projects",
      "description": "Exercises and suggested projects: extend numeric/alphabetic acceptance, accept alphabetic characters only and modify high bit with ORA #$80 before printing, accept numeric digits only and AND #$FE before printing (ask what happens), reinforcing chapter concepts through practice.",
      "references": [
        {
          "chunk": "numeric_key_waiting_subroutine_project",
          "topic": "Base project to modify for accepting more characters"
        },
        {
          "chunk": "logical_ora_and_examples",
          "topic": "Use ORA #$80 in one exercise"
        },
        {
          "chunk": "logical_and_and_examples",
          "topic": "Use AND #$FE in one exercise"
        }
      ]
    },
    {
      "start": 2812,
      "end": 2817,
      "ignore": true,
      "reason": "Contains only blank lines and page/figure markers (:56:, :57:)—non-technical formatting artifacts."
    },
    {
      "start": 2818,
      "end": 2838,
      "name": "chapter_header_and_toc_ignored",
      "description": "Non-technical chapter header and mini table-of-contents for Chapter 4. Contains the chapter title and a short list of topics covered (Numbers, Big numbers, Arithmetic, Rotate/shift, Multiplication, Subroutines). Marked as ignored (non-technical).",
      "references": [
        {
          "chunk": "numbers_signed_unsigned",
          "topic": "entry point for the discussion of signed vs unsigned numbers"
        }
      ]
    },
    {
      "start": 2839,
      "end": 2855,
      "name": "numbers_signed_unsigned",
      "description": "Introduces the distinction between signed and unsigned single-byte numbers. Explains programmer's choice, single-byte signed range (-128..+127) vs unsigned (0..255), and that the machine does not treat them differently except for how the programmer tests flags (e.g., N for sign).",
      "references": [
        {
          "chunk": "chapter_header_and_toc_ignored",
          "topic": "chapter header and topics list"
        },
        {
          "chunk": "big_numbers_multi_byte",
          "topic": "multi-byte (big) numbers and sizing"
        }
      ]
    },
    {
      "start": 2856,
      "end": 2866,
      "name": "multi_byte_numbers_intro",
      "description": "Using multiple bytes to hold larger numbers; carry flag signals overflow from lower bytes; programmer must write code to handle multi-byte arithmetic and carries.",
      "references": [
        {
          "chunk": "addition_and_multi_byte_addition",
          "topic": "multi-byte addition example using ADC and carry propagation"
        },
        {
          "chunk": "right_shift_and_ror",
          "topic": "multi-byte division using ROR and carry linking"
        }
      ]
    },
    {
      "start": 2867,
      "end": 2874,
      "name": "number_size_ranges",
      "description": "Table of ranges for unsigned and signed numbers by byte length: 1 byte 0..255 / -128..+127; 2 bytes 0..65535 / -32768..+32767; 3 bytes 0..16,777,215 / -8,388,608..+8,388,607; 4 bytes up to >4 billion / ~-2 billion..+2 billion.",
      "references": [
        {
          "chunk": "multi_byte_numbers_intro",
          "topic": "choosing number size based on required range"
        }
      ]
    },
    {
      "start": 2875,
      "end": 2883,
      "name": "scaling_and_signed_multi_byte_sign",
      "description": "Notes on binary fractions and scaling (e.g., dollars as integer cents); for multi-byte signed numbers the sign is stored as the high bit of the highest byte only.",
      "references": [
        {
          "chunk": "number_size_ranges",
          "topic": "using extra bytes for larger ranges and scaled values"
        }
      ]
    },
    {
      "start": 2884,
      "end": 2885,
      "name": "addition_and_multi_byte_addition",
      "description": "Principles of addition on the 6502: start at low-order byte, clear carry with CLC before sequences, use ADC which includes incoming carry and sets C on unsigned overflow; check V for signed overflow. Examples: single-byte addition, adding two unsigned numbers at $0380+$0381 storing to $0382; two-byte addition using low byte then high byte with ADC and CLC at start; BCS for unsigned overflow and BVS for signed overflow.",
      "references": [
        {
          "chunk": "signed_vs_unsigned_numbers",
          "topic": "use V vs C flags to detect overflow for signed vs unsigned"
        },
        {
          "chunk": "subtraction_and_multi_byte_subtraction",
          "topic": "subtraction uses inverted borrow (SEC before SBC), analogous multi-byte rules"
        }
      ]
    },
    {
      "start": 2886,
      "end": 2978,
      "name": "addition_multi_byte_machine_code",
      "description": "Principles of addition applied to bytes and multi-byte values: start at the low-order byte, include any previous carry, clear the carry with CLC before starting a new addition, and treat a final carry on unsigned additions as overflow. Includes a decimal example and ASCII figure illustrating carries. Gives machine-language translation: use CLC, perform additions in A with ADC from low to high bytes, and check flags after completion (C for unsigned overflow, V for signed overflow). Includes example code for 1-byte and 2-byte additions (LDA/ADC/STA sequences) and suggestion to branch on carry or overflow to error routines. Notes that signed multi-byte additions use the same code but check V (BVS) instead of C.",
      "references": [
        {
          "chunk": "big_numbers_multi_byte",
          "topic": "why carries matter across bytes and how to size numbers"
        },
        {
          "chunk": "subtraction_multi_byte_machine_code",
          "topic": "related rules for subtraction (inverted borrow, SEC, SBC)"
        }
      ]
    },
    {
      "start": 2979,
      "end": 2979,
      "name": "subtraction_multi_byte_machine_code",
      "description": "Explains subtraction as 'upside-down' addition: carry flag role is inverted (an 'inverted borrow'), and before subtraction the carry must be set with SEC. For unsigned overflow detection, verify the carry is set after the subtraction; a clear carry indicates underflow/borrow. Rules: set C with SEC before a multi-byte subtraction, work from low-order byte up using SBC in A (carry links borrows), and check flags when complete (general instruction to check for overflow).",
      "references": [
        {
          "chunk": "addition_multi_byte_machine_code",
          "topic": "complementary rules for addition (CLC/ADC) and how carries/borrows propagate"
        }
      ]
    },
    {
      "start": 2980,
      "end": 3014,
      "name": "subtraction_and_multi_byte_subtraction",
      "description": "Subtraction rules on 6502: treat subtraction as 'upside-down' addition, set carry with SEC before subtraction sequence (carry acts as inverted borrow), perform low byte first, check C for unsigned overflow (clear means overflow) or V for signed overflow (set means overflow). Example: SEC; LDA $0380; SBC $0381; STA $0382.",
      "references": [
        {
          "chunk": "addition_and_multi_byte_addition",
          "topic": "analogous handling of carries/borrows for multi-byte arithmetic"
        }
      ]
    },
    {
      "start": 3015,
      "end": 3034,
      "name": "comparing_multi_byte_numbers",
      "description": "Comparing multi-byte unsigned numbers: subtract one number from the other (need not keep result) and inspect carry. If C set after subtraction, the minuend >= subtrahend; if C clear, minuend < subtrahend. CMP/CPX/CPY useful for single-byte compares.",
      "references": [
        {
          "chunk": "subtraction_and_multi_byte_subtraction",
          "topic": "using subtraction/C flag to compare multi-byte unsigned values"
        }
      ]
    },
    {
      "start": 3035,
      "end": 3103,
      "name": "left_shift_and_rol",
      "description": "ASL (arithmetic shift left) multiplies a byte by two: bits shift left, bit shifted out goes to C, zero injected into low bit. For multi-byte shifts, use ROL (rotate left) which shifts bits left and pushes previous carry into low bit—linking across bytes by starting at low-order byte with ASL then ROL on higher bytes. Descriptions and diagrams illustrating carry movement and usage.",
      "references": [
        {
          "chunk": "addition_and_multi_byte_addition",
          "topic": "ASL/ROL produce carries which behave like overflow bits"
        },
        {
          "chunk": "multiplication_by_shifts_and_adds",
          "topic": "use shifts and adds to build multiplications"
        }
      ]
    },
    {
      "start": 3104,
      "end": 3156,
      "name": "multiplication_by_shifts_and_adds",
      "description": "Multiplication techniques using shifts and adds: multiply by two via ASL, combine ASL/ROL for multi-byte. To multiply by 4 or 8, repeat shifts. To multiply by 10: multiply by 2 twice (x4), add original (x5), then multiply by 2 again (x10). Typical use: building decimal input routines where digits are accumulated via multiply-by-ten and add.",
      "references": [
        {
          "chunk": "left_shift_and_rol",
          "topic": "use ASL and ROL for multi-byte multiplication"
        }
      ]
    },
    {
      "start": 3157,
      "end": 3233,
      "name": "right_shift_and_ror",
      "description": "Divide-by-two operations: LSR (logical shift right) shifts bits right, injects zero into high bit, low bit goes into carry (C holds remainder). ROR (rotate right) moves carry into high bit and shifts everything right, passing the low bit into carry. For multi-byte division start at high-order byte with LSR and use ROR on lower bytes to propagate bits. Diagrams and multi-byte example provided.",
      "references": [
        {
          "chunk": "left_shift_and_rol",
          "topic": "mirror operations for division vs multiplication (LSR/ROR vs ASL/ROL)"
        }
      ]
    },
    {
      "start": 3234,
      "end": 3252,
      "name": "shift_rotate_comments",
      "description": "Comments on shift/rotate: these instructions operate on A or directly on memory (LSR A vs LSR $addr). When applied to memory, flags N, Z, and C are affected according to resulting memory contents. Distinction logical vs arithmetic refers to sign treatment; bits themselves move the same way.",
      "references": [
        {
          "chunk": "right_shift_and_ror",
          "topic": "effect on flags when shifting memory directly"
        },
        {
          "chunk": "left_shift_and_rol",
          "topic": "ASL/ROL differences and memory operations"
        }
      ]
    },
    {
      "start": 3253,
      "end": 3282,
      "name": "subroutines_intro_and_example",
      "description": "Subroutines in machine language: RTS returns to caller (BASIC or ML). Example subroutine listing (addresses $033C-$0351) that accepts numeric keys, echoes them, converts ASCII to binary and uses JSR $FFE1, BEQ, JSR $FFE4, CMP #$30 / BCC / CMP #$3A / BCS, JSR $FFD2, AND #$0F, RTS.",
      "references": [
        {
          "chunk": "addition_program_using_subroutine",
          "topic": "reuse subroutine to build a small calculator example"
        }
      ]
    },
    {
      "start": 3283,
      "end": 3375,
      "name": "addition_program_using_subroutine",
      "description": "Project: build a simple addition program using the numeric-input subroutine. Machine code placed at $0352: calls subroutine to get digits, stores first digit at $03C0, prints '+', uses TAX to save A in X, prints '=', retrieves back, CLC then ADC $03C0, ORA #$30 to convert to ASCII, JSR $FFD2 to print result, print CR ($0D), and RTS. Notes on using STA $03C0, TAX/TXA, and ASCII conversion.",
      "references": [
        {
          "chunk": "subroutines_intro_and_example",
          "topic": "uses the numeric-input subroutine defined earlier"
        },
        {
          "chunk": "immediate_mode",
          "topic": "use of immediate ASCII constants like #$2B and #$3D"
        }
      ]
    },
    {
      "start": 3376,
      "end": 3391,
      "name": "addition_program_enhancements",
      "description": "Project suggestion: extend the simple addition program to allow two-digit results (max 18). Compare for result > 9 and, if so, print '1' then subtract ten, etc.",
      "references": [
        {
          "chunk": "addition_program_using_subroutine",
          "topic": "extension to handle multi-digit output and carry"
        }
      ]
    },
    {
      "start": 3392,
      "end": 3436,
      "name": "things_you_learned_ch4",
      "description": "Chapter 4 summary bullets: signed vs unsigned numbers; multi-byte numbers and carry handling; ADC with CLC for add; SBC with SEC for subtract; checking C and V for overflow depending on signed/unsigned; ASL/ROL and LSR/ROR use for multiply/divide; shift/rotate can operate on A or memory; subroutines in machine language.",
      "references": [
        {
          "chunk": "addition_and_multi_byte_addition",
          "topic": "ADC/CLC rules recapped"
        },
        {
          "chunk": "left_shift_and_rol",
          "topic": "ASL/ROL summary"
        }
      ]
    },
    {
      "start": 3437,
      "end": 3466,
      "name": "chapter4_questions_projects",
      "description": "Questions and projects: write subtraction and conditional arithmetic programs; use LSR to test odd/even; practice input/output and arithmetic in ML routines.",
      "references": [
        {
          "chunk": "addition_program_using_subroutine",
          "topic": "similar techniques for subtraction project"
        }
      ]
    },
    {
      "start": 3467,
      "end": 3498,
      "name": "chapter_5_overview",
      "description": "Chapter 5 header: addressing modes to be discussed including implied/accumulator, immediate, absolute/zero-page, indexing, relative branches, indirect, indirect-indexed, and indexed-indirect.",
      "references": [
        {
          "chunk": "addressing_modes_overview",
          "topic": "full list and organization of addressing modes"
        }
      ]
    },
    {
      "start": 3499,
      "end": 3528,
      "name": "addressing_modes_overview",
      "description": "Overview of 650x addressing modes: implied/accumulator (no address), immediate (value in instruction), absolute/zero-page (single memory address), absolute,x/y and zero-page,x/y indexing (range of 256), indirect (address stored at memory), relative (branch offsets), and combined indirect/indexed and indexed,indirect for flexible data access.",
      "references": [
        {
          "chunk": "implied_address_mode",
          "topic": "no-address instructions such as INX/BRK/TAY"
        },
        {
          "chunk": "indirect_indexed_addressing",
          "topic": "indirect,Y to reach anywhere in memory"
        }
      ]
    },
    {
      "start": 3529,
      "end": 3545,
      "name": "implied_address_mode",
      "description": "Implied addressing (no memory operand): instructions like INX, BRK, TAY have no operand and occupy one byte. NOP is debated as 'no address' since it does nothing.",
      "references": [
        {
          "chunk": "nop_and_use_in_testing",
          "topic": "NOP specifics and uses"
        }
      ]
    },
    {
      "start": 3546,
      "end": 3604,
      "name": "nop_and_use_in_testing",
      "description": "NOP (opcode $EA) does nothing but is useful for replacing or reserving bytes (testing, leaving space, removing BRK). Examples: replacing removed bytes with NOPs to keep code alignment. Using BRK between modules for debug then replacing BRK ($00) with NOPs for release.",
      "references": [
        {
          "chunk": "implied_address_mode",
          "topic": "NOP as a no-op implied instruction"
        }
      ]
    },
    {
      "start": 3605,
      "end": 3628,
      "name": "accumulator_mode_and_memory_modifying_instructions",
      "description": "Accumulator addressing: shift/rotate instructions can operate on accumulator using syntax like ASL A. INC/DEC operate directly on memory and affect N and Z flags. When instructions modify memory, addressing mode differs from implied or accumulator.",
      "references": [
        {
          "chunk": "shift_rotate_comments",
          "topic": "effects on flags when shifting memory or A"
        }
      ]
    },
    {
      "start": 3629,
      "end": 3666,
      "name": "immediate_mode",
      "description": "Immediate addressing (e.g., LDA #$34) embeds a value in the instruction (two bytes). Use immediate for constants but beware of overusing it (hard-coded values make porting harder). Some instructions like STA cannot use immediate mode.",
      "references": [
        {
          "chunk": "addition_program_using_subroutine",
          "topic": "immediate ASCII constants for printing characters"
        }
      ]
    },
    {
      "start": 3667,
      "end": 3711,
      "name": "absolute_addressing_mode",
      "description": "Absolute addressing specifies a full 16-bit memory address ($0000-$FFFF) and accesses a single memory location. JSR and JMP use absolute addressing. Limitations: absolute reaches one fixed location only (no range).",
      "references": [
        {
          "chunk": "jmp_indirect_mode_and_rom_link",
          "topic": "JMP ($addr) indirect variant for ROM link"
        }
      ]
    },
    {
      "start": 3712,
      "end": 3756,
      "name": "zero_page_addressing",
      "description": "Zero-page addressing targets addresses $0000-$00FF using a single byte operand (e.g., LDA $90) which is smaller and faster. Zero page is heavily used for system variables and special addressing modes; it's a limited resource often conserved.",
      "references": [
        {
          "chunk": "zero_page_indexed_addressing",
          "topic": "zero-page indexed addressing wraps within zero page"
        },
        {
          "chunk": "basic_variable_table_and_types",
          "topic": "BASIC and system variables are often stored in zero page"
        }
      ]
    },
    {
      "start": 3757,
      "end": 3799,
      "name": "absolute_indexed_addressing",
      "description": "Absolute, indexed addressing (absolute,X and absolute,Y) adds index register X or Y to a full absolute address, giving access to a 256-byte range starting at base address. Indexing always increases the address; wrap-around only occurs if address crosses page boundary.",
      "references": [
        {
          "chunk": "zero_page_indexed_addressing",
          "topic": "contrast with zero-page indexed which wraps within page 0"
        }
      ]
    },
    {
      "start": 3800,
      "end": 3852,
      "name": "zero_page_indexed_addressing",
      "description": "Zero-page indexed addressing (e.g., LDA $E0,X) adds the index to a zero-page base and wraps within page 0. All of zero page can be reached by indexing; allows negative indexing representation (e.g., X=$FF as -1). Mostly uses X for addressing; LDX/STX can use Y in some cases.",
      "references": [
        {
          "chunk": "zero_page_addressing",
          "topic": "advantages and costs of using zero page"
        }
      ]
    },
    {
      "start": 3853,
      "end": 3898,
      "name": "relative_branching_mode",
      "description": "Relative address mode used by branch instructions: one-byte signed offset indicating forward/backward jump from next instruction (range -128..+127). Branch address computed from target minus (PC after branch). Long branches limited to +/-127; use JMP for farther transfers. Branches are relocation-friendly.",
      "references": [
        {
          "chunk": "jmp_indirect_mode_and_rom_link",
          "topic": "contrast relative branches with JMP absolute/indirect"
        }
      ]
    },
    {
      "start": 3899,
      "end": 3974,
      "name": "jmp_indirect_mode_and_rom_link",
      "description": "JMP indirect mode (JMP ($1234)) fetches a two-byte target address from the supplied address (low byte first) and jumps there. Useful in ROM to allow variable jumps: ROM code uses indirect jumps via RAM-stored vectors (e.g., interrupt vectors) allowing system behavior to be changed by modifying RAM pointers.",
      "references": [
        {
          "chunk": "using_irq_vector_and_masking_interrupts",
          "topic": "interrupt vectors stored in RAM and used via indirect jump"
        }
      ]
    },
    {
      "start": 3975,
      "end": 4051,
      "name": "indirect_indexed_addressing",
      "description": "Indirect, indexed addressing (LDA ($C0),Y): operand is an address in zero page containing a two-byte base address; Y is added to that base to form the effective address. Allows reaching anywhere in memory by setting the indirect pointer and scanning within a chunk with Y. Indirect pointer must be in zero page.",
      "references": [
        {
          "chunk": "indexed_indirect_addressing",
          "topic": "comparison with indexed,indirect (X first) mode"
        },
        {
          "chunk": "screen_manipulation_setup_and_indirect_pointer",
          "topic": "practical use to manipulate screen memory across pages"
        }
      ]
    },
    {
      "start": 4052,
      "end": 4100,
      "name": "indexed_indirect_addressing",
      "description": "Indexed, indirect addressing (LDA ($C0,X)) adds X to the supplied zero-page address first to select one of several indirect addresses, then fetches the two-byte pointer there. Useful for tables of indirect pointers (e.g., per-line buffers). Typically X is even to step two-byte pointers.",
      "references": [
        {
          "chunk": "indirect_indexed_addressing",
          "topic": "contrast between (addr),Y and (addr,X) forms"
        }
      ]
    },
    {
      "start": 4101,
      "end": 4136,
      "name": "zero_page_management_hunt",
      "description": "Zero-page scarcity on Commodore machines: only a few free locations (e.g., $00FC-$00FF on VIC/64). Strategies to obtain pointers: find unused locations, use 'work areas' in memory maps, temporarily relocate zero-page contents to other RAM (careful with interrupts).",
      "references": [
        {
          "chunk": "indirect_indexed_addressing",
          "topic": "need two zero-page bytes per indirect pointer"
        }
      ]
    },
    {
      "start": 4137,
      "end": 4164,
      "name": "screen_manipulation_project_overview",
      "description": "Project plan: change a window on the screen spanning multiple lines and columns using indirect, indexed addressing. Use an indirect pointer per line (in zero page) to the start of a line and Y index to walk columns within each line, then advance indirect pointer to next line.",
      "references": [
        {
          "chunk": "indirect_indexed_addressing",
          "topic": "core addressing mode used in the screen manipulation project"
        }
      ]
    },
    {
      "start": 4165,
      "end": 4216,
      "name": "screen_manipulation_setup_and_indirect_pointer",
      "description": "Setup for screen manipulation: choose line length (e.g., $28 for 40 columns) and screen page (PET/CBM $8000 or VIC/64 from $0288); store screen start address low/high into zero-page locations (e.g., $00BB/$00BC). Initialize X as line counter and prepare to loop over lines. Example code storing values and setting indirect pointer low byte to zero.",
      "references": [
        {
          "chunk": "zero_page_management_hunt",
          "topic": "choose safe zero-page addresses for indirect pointers"
        }
      ]
    },
    {
      "start": 4217,
      "end": 4310,
      "name": "screen_manipulation_loop_and_line_advance",
      "description": "Detailed loop: for each line, set Y to starting column offset (e.g., #$04), use LDA ($BB),Y to read screen character, CMP #$20 and BEQ to skip spaces, EOR #$80 to flip high bit, STA ($BB),Y to write back. Increment Y, CPY #$12 (end column), BCC back. After finishing line, CLC, add line length to indirect pointer low byte (ADC $03A0), store back to $BB and handle carry with ADC #$00 to high byte, INX to count lines and BNE to next line. RTS when finished.",
      "references": [
        {
          "chunk": "indirect_indexed_addressing",
          "topic": "practical use of LDA ($BB),Y and STA ($BB),Y to modify screen memory"
        }
      ]
    },
    {
      "start": 4311,
      "end": 4339,
      "name": "screen_manipulation_bare_bones_test_and_notes",
      "description": "Testing the screen manipulation routine: disassemble and run from BASIC using a loop to call machine code by SYS. Notes on slowing output with BASIC loops. Project ideas: change which columns or selectively affect characters (e.g., only 'S'). Note for VIC/C64: color nybble memory may need adjustment when POKEing screen memory.",
      "references": [
        {
          "chunk": "screen_manipulation_loop_and_line_advance",
          "topic": "testing and iteration via BASIC SYS calls"
        },
        {
          "chunk": "vic_c64_color_note",
          "topic": "color nybble considerations on VIC/C64"
        }
      ]
    },
    {
      "start": 4340,
      "end": 4378,
      "name": "chapter5_summary_addressing_modes",
      "description": "Chapter 5 summary: recap of implied/accumulator/immediate modes; absolute/zero-page addressed single locations; absolute/zero-page indexed for ranges up to 256; relative branches limited reach; indirect (JMP) and indirect, indexed as most important for data anywhere in memory; indirect addresses must reside in zero page.",
      "references": [
        {
          "chunk": "addressing_modes_overview",
          "topic": "summary of all modes and tradeoffs"
        }
      ]
    },
    {
      "start": 4379,
      "end": 4400,
      "name": "chapter5_questions_projects",
      "description": "Exercises: clear the screen avoiding indirect,indexed, then write version using indirect,indexed; design addressing strategy for repeating a typed line ten times; rewrite routines without immediate addressing and consider pros/cons.",
      "references": [
        {
          "chunk": "screen_manipulation_project_overview",
          "topic": "screen clearing/manipulation projects"
        }
      ]
    },
    {
      "start": 4401,
      "end": 4427,
      "name": "chapter_6_overview",
      "description": "Chapter 6 header and outline: where to put ML programs, BASIC memory layout, loading and SOV pointer, BASIC variable types, exchanging data with BASIC.",
      "references": [
        {
          "chunk": "basic_memory_layout_overview",
          "topic": "BASIC memory layout and important pointers"
        }
      ]
    },
    {
      "start": 4428,
      "end": 4480,
      "name": "basic_memory_layout_overview",
      "description": "Overview of BASIC RAM layout: cassette buffer below BASIC area; Start-of-BASIC (SOB) pointer locations vary by machine ($0401 PET, $0801 C64, etc.); End-of-BASIC signaled by three zero bytes; SOV (start-of-variables) usually just after end-of-BASIC indicated by pointer; SOA (start-of-arrays), EOA, BOS (bottom-of-strings), TOM (top-of-memory) pointers described and their pointer locations by machine.",
      "references": [
        {
          "chunk": "sov_pointer_dangers_and_effects",
          "topic": "important role of SOV in protection and potential problems"
        }
      ]
    },
    {
      "start": 4481,
      "end": 4560,
      "name": "basic_memory_pointers_and_meanings",
      "description": "Detailed description of BASIC pointers: SOV marks where variables are stored (pointer at $2A/$2B PET or $2D/$2E VIC/C64); SAVE saves memory from SOB to just before SOV; SOA, EOA, TOM, BOS pointer meanings and their machine-specific pointer addresses; dynamic strings behavior and garbage collection notes.",
      "references": [
        {
          "chunk": "monitor_save_command_format_and_load_relocation",
          "topic": ".S/.L monitor operations and effect on pointers"
        }
      ]
    },
    {
      "start": 4561,
      "end": 4586,
      "name": "danger_of_using_free_memory_between_eoa_and_bos",
      "description": "Warning: region between EOA and BOS appears free but is used for dynamic strings which can move down; placing ML code there is unsafe because BOS moves down as strings are created and may overwrite code until garbage collection runs when BOS touches EOA.",
      "references": [
        {
          "chunk": "where_to_put_machine_language_programs",
          "topic": "safer areas for ML programs: cassette buffer, top-of-memory, after end-of-BASIC with SOV adjusted"
        }
      ]
    },
    {
      "start": 4587,
      "end": 4610,
      "name": "where_to_put_machine_language_programs",
      "description": "Options for placing ML programs: cassette buffer for short tests (190 bytes); move down TOM to install permanent ML near top-of-memory (requires pointer changes); place ML after end-of-BASIC and move SOV upward so variables don't overwrite ML—each method's tradeoffs and persistence discussed.",
      "references": [
        {
          "chunk": "basic_memory_layout_overview",
          "topic": "relationship of SOB, SOV, SOA, EOA, TOM"
        }
      ]
    },
    {
      "start": 4611,
      "end": 4645,
      "name": "moving_pointers_and_caution",
      "description": "Notes on moving pointers: after changing TOM or SOV, return to BASIC and use CLR/NEW to align pointers; caution about restoring machine configuration when program loaded; VIC-20 specifics: video chip sees RAM in $0000-$1FFF and start-of-BASIC is often moved to free low memory for video effects; careful manipulation required.",
      "references": [
        {
          "chunk": "vic_and_c64_memory_extras",
          "topic": "VIC/C64-specific RAM areas and use of top-of-memory"
        }
      ]
    },
    {
      "start": 4646,
      "end": 4696,
      "name": "vic_and_c64_memory_extras",
      "description": "Commodore 64 extra RAM at $C000-$CFFF (4K) often used by utilities; option to remove BASIC from C64 to reclaim $0801-$CFFF (~50K) via POKE $01,$36/ $01,$37 (be careful). On VIC machines, moving SOB pointer is common to make video space; ensure screen-related RAM limits when planning ML and video effects.",
      "references": [
        {
          "chunk": "where_to_put_machine_language_programs",
          "topic": "placing ML in high memory or moving SOB"
        }
      ]
    },
    {
      "start": 4697,
      "end": 4769,
      "name": "sov_pointer_dangers_and_effects",
      "description": "The 'wicked' SOV: rules and pitfalls. Variables written starting at SOV; SAVE/LOAD behaviors; changes to BASIC move memory up/down up to SOV; if SOV is corrupted (e.g., set into cassette buffer) variables, SAVE, or editing operations can overwrite programs, cause massive unintended saves, or corrupt ROM/zero page leading to system failure.",
      "references": [
        {
          "chunk": "basic_memory_pointers_and_meanings",
          "topic": "role of SOV in SAVE and LOAD"
        }
      ]
    },
    {
      "start": 4770,
      "end": 4809,
      "name": "sov_issue_consequences_and_student_experience",
      "description": "Real-world anecdotes: students load ML into cassette buffer incorrectly and move SOV resulting in variables overwriting BASIC, SAVE writing enormous amounts, or memory moves wrapping and corrupting system—leading to lost confidence. Emphasizes verifying SOV pointer and understanding consequences.",
      "references": [
        {
          "chunk": "sov_pointer_dangers_and_effects",
          "topic": "practical consequences and debugging approach"
        }
      ]
    },
    {
      "start": 4810,
      "end": 4834,
      "name": "monitor_save_command_format_and_load_relocation",
      "description": "Machine language monitor .S save format: .S\"NAME\",device,begin,end+1 (e.g., .S\"PROGRAM\",01,033C,0361). For disk .S include drive (e.g., .S\"0:PROGRAM\",08,033C,0361). Note on LOAD from BASIC: use LOAD with ,1 flag to prevent relocation on VIC/C64 (LOAD\"PROGRAM\",8,1). .L monitor command may load without relocating pointers depending on monitor.",
      "references": [
        {
          "chunk": "checking_and_fixing_memory_pointers",
          "topic": "after loading, verify SOV pointer with .M to ensure safety"
        }
      ]
    },
    {
      "start": 4835,
      "end": 4889,
      "name": "load_chaining_and_programmed_load_behavior",
      "description": "Programmed LOAD from within BASIC preserves pointers (no SOV change) but resets program execution to first statement (chaining behavior). Use variable flags to avoid infinite re-load loops (e.g., IF A=1 GOTO...). Advice: understand chained LOAD behavior when building bootstraps.",
      "references": [
        {
          "chunk": "monitor_save_command_format_and_load_relocation",
          "topic": "difference between .L and BASIC LOAD behaviors"
        }
      ]
    },
    {
      "start": 4890,
      "end": 4920,
      "name": "sov_blunders_with_high_memory_programs",
      "description": "Loading ML into high memory can leave SOV just above it making little room for variables (OUT OF MEMORY). Recommended order: load high-memory ML first, then BASIC so SOV points appropriately; may need to adjust TOM and NEW between loads.",
      "references": [
        {
          "chunk": "where_to_put_machine_language_programs",
          "topic": "order of loads and pointer adjustments"
        }
      ]
    },
    {
      "start": 4921,
      "end": 4934,
      "name": "checking_and_fixing_memory_pointers",
      "description": "How to inspect and fix pointers: use monitor .M to display pointer ranges (e.g., .M 002B 003A for VIC/64). Modify incorrect pointer bytes by editing and pressing RETURN. Always verify SOV is sound before running ML/BASIC combos.",
      "references": [
        {
          "chunk": "monitor_save_command_format_and_load_relocation",
          "topic": "check SOV after loads and saves"
        }
      ]
    },
    {
      "start": 4935,
      "end": 4962,
      "name": "placing_ml_after_eob_and_saving_together",
      "description": "Placing ML after end-of-BASIC and moving SOV upward creates a single unit (BASIC+ML) that saves/loads together. Caution: after marrying ML and BASIC, don't change BASIC (lines added/removed will relocate ML and break SYS addresses). Use LOAD/SAVE to preserve unit integrity.",
      "references": [
        {
          "chunk": "basic_variable_table_and_types",
          "topic": "SOV must be adjusted so variables don't overwrite ML placed after EOB"
        }
      ]
    },
    {
      "start": 4963,
      "end": 5059,
      "name": "basic_variable_table_and_types",
      "description": "BASIC variable table layout: each variable occupies 7 bytes (2-byte name + 5-byte value area). High bits over name bytes encode type: integer (high bit set on both), string (high bit set on second char), function (high bit set on first char). String descriptor uses 3 bytes (length + 2-byte address). Floating variables use 5 bytes; integers use first 2 bytes storing value directly (little-endian). Examples show floating and integer variable encodings.",
      "references": [
        {
          "chunk": "data_exchange_methods_between_basic_and_machine_language",
          "topic": "ML can read variables by scanning variable table starting at SOV"
        }
      ]
    },
    {
      "start": 5060,
      "end": 5102,
      "name": "data_exchange_methods_between_basic_and_machine_language",
      "description": "Exchanging data: simplest via POKE/PEEK to shared memory. More advanced: ML locates BASIC variable table via SOV pointer, scans variable names using indirect, indexed addressing, and extracts integer values (straightforward) or floating/descriptors (more complex). Shortcut: define variables in known order to avoid name search.",
      "references": [
        {
          "chunk": "basic_variable_table_and_types",
          "topic": "structure of variable entries for ML extraction"
        }
      ]
    },
    {
      "start": 5103,
      "end": 5119,
      "name": "placing_ml_behind_end_of_basic_and_basic_example",
      "description": "Project overview and BASIC driver program used to call machine language. Explains intent to place ML code after the end-of-BASIC, gives the example Commodore 64 BASIC listing (lines 100-150) which initializes V%, loops five times, reads VALUE into V%, calls ML with SYS, and prints the result.",
      "references": [
        {
          "chunk": "estimating_ml_location_and_sys_setup",
          "topic": "how to choose the ML start address and change the SYS line"
        },
        {
          "chunk": "saving_basic_and_preparing_to_write_machine_code",
          "topic": "options for developing BASIC and ML parts separately"
        }
      ]
    },
    {
      "start": 5120,
      "end": 5126,
      "name": "estimating_ml_location_and_sys_setup",
      "description": "Guidance for estimating the BASIC program size and choosing a safe start address for machine language. Concludes that ML can be placed at $0880 (decimal 2176) and instructs changing the BASIC SYS line to SYS 2176 while advising not to run the program yet.",
      "references": [
        {
          "chunk": "placing_ml_behind_end_of_basic_and_basic_example",
          "topic": "BASIC driver program that will call the ML routine"
        },
        {
          "chunk": "saving_basic_and_preparing_to_write_machine_code",
          "topic": "saving BASIC before adding ML code"
        }
      ]
    },
    {
      "start": 5127,
      "end": 5132,
      "name": "saving_basic_and_preparing_to_write_machine_code",
      "description": "Options for development workflow: save the BASIC program to tape/disk so BASIC and ML can be refined independently; for this example, the ML will be assembled directly into memory. Prepares the user to switch to the machine language monitor.",
      "references": [
        {
          "chunk": "estimating_ml_location_and_sys_setup",
          "topic": "the chosen ML start address ($0880)"
        },
        {
          "chunk": "extract_variable_bytes_and_prepare_for_shifts",
          "topic": "assemble the ML code in the monitor starting at $0880"
        }
      ]
    },
    {
      "start": 5133,
      "end": 5161,
      "name": "extract_variable_bytes_and_prepare_for_shifts",
      "description": "Machine code assembled at $0880 to extract the two bytes of integer variable V% via indirect Y addressing ($2D), storing the high and low bytes into temporary zero-page/work locations $033C/$033D and duplicate copies into $033E/$033F. Includes a brief suggestion to optimize via indexing and the ASL/ROL sequence to multiply the extracted value by 4 (two successive ASL/ROL pairs on $033D/$033C).",
      "references": [
        {
          "chunk": "adding_x4_to_original_to_get_x5",
          "topic": "add the original copies to produce times-five"
        },
        {
          "chunk": "placing_ml_behind_end_of_basic_and_basic_example",
          "topic": "the BASIC program that calls this ML routine"
        }
      ]
    },
    {
      "start": 5162,
      "end": 5174,
      "name": "adding_x4_to_original_to_get_x5",
      "description": "Code and explanation to form the original value times five. Shows CLC; LDA low byte ($033D); ADC low-byte original ($033F); store result back to $033D; then LDA high byte ($033C); ADC high-byte original ($033E); STA $033C. Explains that $033C/$033D now hold the original value times five.",
      "references": [
        {
          "chunk": "extract_variable_bytes_and_prepare_for_shifts",
          "topic": "the x4 value produced earlier in $033C/$033D and original copies in $033E/$033F"
        },
        {
          "chunk": "double_to_make_times_ten_and_store_back",
          "topic": "final doubling to get times-ten and storing result back into V%"
        }
      ]
    },
    {
      "start": 5175,
      "end": 5190,
      "name": "double_to_make_times_ten_and_store_back",
      "description": "Final ASL/ROL pair to double the times-five value into times-ten (ASL $033D; ROL $033C). Then code to write the resulting high and low bytes back into the integer variable V% using indirect Y addressing: LDY #$02; LDA $033C; STA ($2D),Y; LDY #$03; LDA $033D; STA ($2D),Y; RTS.",
      "references": [
        {
          "chunk": "adding_x4_to_original_to_get_x5",
          "topic": "x5 value that is doubled here"
        },
        {
          "chunk": "store_ordering_and_adjust_sov_pointer",
          "topic": "importance of byte order and adjusting the SOV pointer after embedding ML"
        }
      ]
    },
    {
      "start": 5191,
      "end": 5203,
      "name": "store_ordering_and_adjust_sov_pointer",
      "description": "Notes on storing the bytes back into the variable and the byte-order convention for Commodore integer variables (high-order byte first, low-order byte second — opposite of 6502 address order). Instructs changing the start-of-variables (SOV) pointer at $2D/$2E to point above the ML program (example: set to $08C8) and shows the .M display format for $2D/$2E.",
      "references": [
        {
          "chunk": "double_to_make_times_ten_and_store_back",
          "topic": "code that writes the high/low bytes back into V%"
        },
        {
          "chunk": "disassemble_list_save_and_run_instructions",
          "topic": "checking, disassembling, and returning to BASIC after adjusting SOV"
        }
      ]
    },
    {
      "start": 5204,
      "end": 5210,
      "name": "disassemble_list_save_and_run_instructions",
      "description": "Instructions to verify the ML placement: disassemble and check, return to BASIC, LIST to view the BASIC program (ML is hidden), save to include ML with BASIC, then RUN the BASIC program and test entering numbers to confirm they are multiplied by ten.",
      "references": [
        {
          "chunk": "store_ordering_and_adjust_sov_pointer",
          "topic": "adjusting the SOV pointer so SAVE includes ML safely"
        },
        {
          "chunk": "overflow_testing_and_project_extension",
          "topic": "testing limits and adding overflow handling"
        }
      ]
    },
    {
      "start": 5211,
      "end": 5223,
      "name": "overflow_testing_and_project_extension",
      "description": "Notes and exercises about overflow: reminder that the example ML routine does not check for overflow, encouragement to test the largest number that can be multiplied by ten without error and observe behavior at overflow. Project suggestion: add overflow checks and decide on behavior (print message, set to zero, etc.) without breaking to the monitor. Reminder to adjust SOV pointer if the program grows.",
      "references": [
        {
          "chunk": "double_to_make_times_ten_and_store_back",
          "topic": "places where overflow could occur (during shifts and ADCs)"
        },
        {
          "chunk": "disassemble_list_save_and_run_instructions",
          "topic": "testing the BASIC/ML program after changes"
        }
      ]
    },
    {
      "start": 5224,
      "end": 5274,
      "name": "chapter6_summary_ml_and_basic_linking",
      "description": "Chapter 6 summary: options for staging ML programs (cassette buffer, top-of-memory, after EOB); C64 extra RAM $C000-$CFFF; importance of setting SOV correctly; monitor .S/.L usage; BASIC variables are integer/real/string and ML can interface (integers easiest).",
      "references": [
        {
          "chunk": "where_to_put_machine_language_programs",
          "topic": "recap of placement strategies"
        },
        {
          "chunk": "example_ml_times_ten_using_basic_variables_and_sov_adjust",
          "topic": "practical ML+BASIC example"
        }
      ]
    },
    {
      "start": 5275,
      "end": 5301,
      "name": "chapter6_questions_projects",
      "description": "Exercises: write BASIC+ML to divide a POKEd value by two and return; write a bootstrap (BASIC LOAD then SYS) to call ML from cassette buffer; create boot loaders for sprites or screens; ML routine to change variable names (dangerous).",
      "references": [
        {
          "chunk": "data_exchange_methods_between_basic_and_machine_language",
          "topic": "practical ML/BASIC data exchange tasks"
        }
      ]
    },
    {
      "start": 5302,
      "end": 5326,
      "name": "chapter_7_overview",
      "description": "Chapter 7 header and topics: the stack for temporary storage, USR (alternative to SYS), interrupts IRQ/NMI/BRK, IA chips (PIA/VIA/CIA), and infiltrating BASIC (the wedge).",
      "references": [
        {
          "chunk": "stack_overview",
          "topic": "stack for temporary storage"
        },
        {
          "chunk": "using_irq_vector_and_masking_interrupts",
          "topic": "interrupts overview"
        }
      ]
    },
    {
      "start": 5327,
      "end": 5342,
      "name": "chapter7_preface",
      "description": "Preface: encouragement to review fundamentals and note that following chapters provide fine tuning; good time to ensure comfort with basics before tackling advanced topics.",
      "references": []
    },
    {
      "start": 5343,
      "end": 5410,
      "name": "stack_overview",
      "description": "Stack basics: LIFO discipline located in page 1 ($0100-$01FF). Stack Pointer (SP) holds offset (push goes to $0100+SP then SP--). Leave stack as you found it. Within BASIC environment SP starts around $FA; values below ~$40 indicate trouble. Stack wraps in hardware but programmer must avoid overruns.",
      "references": [
        {
          "chunk": "pha_pla_and_php_plp_usage",
          "topic": "PHA/PLA use to push/pop A"
        },
        {
          "chunk": "jsr_rts_stack_return_behavior",
          "topic": "JSR/RTS push return address on stack"
        }
      ]
    },
    {
      "start": 5411,
      "end": 5462,
      "name": "pha_pla_and_php_plp_usage",
      "description": "PHA/PLA: push and pull accumulator A to/from stack for temporary storage. PHP/PLP: push/pull processor status flags, useful to save condition flags across operations. Examples and usage recommendations (e.g., save/restore flags around delayed action). Note both affect stack pointer by one byte each.",
      "references": [
        {
          "chunk": "stack_overview",
          "topic": "general stack behavior and best practices"
        }
      ]
    },
    {
      "start": 5463,
      "end": 5493,
      "name": "jsr_rts_stack_return_behavior",
      "description": "JSR pushes return address-1 (two bytes, high byte first) onto stack; RTS pulls two bytes, adds one, and resumes at that address+1. Example demonstrates where PC gets stored and how RTS calculates return point; stack can be inspected to see caller address.",
      "references": [
        {
          "chunk": "manipulating_stack_for_control_flow",
          "topic": "fake return addresses to achieve JMP-like behavior via RTS"
        }
      ]
    },
    {
      "start": 5494,
      "end": 5521,
      "name": "interrupts_and_rti",
      "description": "Interrupt mechanics: IRQ/NMI/BRK. When interrupt occurs, CPU finishes current instruction, pushes PC (two bytes, high-first) and status register (one byte) to stack (3 bytes total), then loads ISR address from vectors: IRQ/BRK from $FFFE/$FFFF, NMI from $FFFA/$FFFB. RTI restores status and PC from stack. BRK sets B flag in status to distinguish it from IRQ.",
      "references": [
        {
          "chunk": "using_irq_vector_and_masking_interrupts",
          "topic": "IRQ vectors and how to change them safely"
        }
      ]
    },
    {
      "start": 5522,
      "end": 5542,
      "name": "interrupt_types_and_behavior",
      "description": "Details: IRQ fires ~60Hz on Commodore machines; NMI used for RESTORE and RS-232 (machine-specific); BRK behaves like IRQ but sets B flag. ROM interrupt code typically pushes A/X/Y/etc for ISR preservation. Understand stack contents during interrupt (PC and SR) differ from JSR/RTS stored address (no '-1').",
      "references": [
        {
          "chunk": "interrupts_and_rti",
          "topic": "mechanics and differences between BRK and IRQ"
        }
      ]
    },
    {
      "start": 5543,
      "end": 5572,
      "name": "manipulating_stack_for_control_flow",
      "description": "Using the stack for control flow: pushing two bytes as a fake return address then executing RTS acts as JMP to that address (e.g., LDA #$24 PHA; LDA #$68 PHA; RTS -> JMP $2469). Use with table-driven dispatch: LDA TABLE1,X PHA; LDA TABLE2,X PHA; RTS allows indirect jumps dependant on X.",
      "references": [
        {
          "chunk": "jsr_rts_stack_return_behavior",
          "topic": "stack contents expected by RTS"
        }
      ]
    },
    {
      "start": 5573,
      "end": 5600,
      "name": "usr_function_vs_sys_command",
      "description": "USR function vs SYS command: SYS executes a fixed numeric address as subroutine; USR executes address stored in USR vector and is used as a function returning a value to BASIC. USR argument is computed into floating accumulator (shared memory $5E-$63 on PET or $61-$66 on VIC/C64) before call; result returned in floating accumulator. Beginners often avoid floating-point passing and use POKEs or integer variables.",
      "references": [
        {
          "chunk": "basic_variable_table_and_types",
          "topic": "floating accumulator and variable formats when exchanging data"
        }
      ]
    },
    {
      "start": 5601,
      "end": 5605,
      "name": "usr_return_value_and_floating_accumulator",
      "description": "Explains that the BASIC USR() function returns the value in the floating accumulator; if unchanged it returns the argument (example: PRINT USR(5) returns 5).",
      "references": [
        {
          "chunk": "usr_and_sys_contrast",
          "topic": "USR vs SYS usage (see later summary of USR/SYS)"
        }
      ]
    },
    {
      "start": 5606,
      "end": 5606,
      "name": "interrupts_intro_and_irq_vectors",
      "description": "Introduction to interrupts (NMI, IRQ, BRK). Gives IRQ vector addresses: PET/CBM $0090-$0091 (dec 144-145) and VIC/Commodore 64 $0314-$0315 (dec 788-789). Discusses why changing the IRQ vector affects system services (clock, keyboard, cassette motor, cursor, input) and the need to preserve normal interrupt service when adding your own handler.",
      "references": [
        {
          "chunk": "interrupt_vector_modification_and_sei_cli",
          "topic": "Masks and safe modification of IRQ vector"
        },
        {
          "chunk": "interrupt_project_example",
          "topic": "Example of diverting the IRQ vector to custom code"
        }
      ]
    },
    {
      "start": 5607,
      "end": 5660,
      "name": "using_irq_vector_and_masking_interrupts",
      "description": "Changing IRQ vector in RAM (e.g., $0090 on PET, $0314 on VIC/C64) allows directing interrupts to ML routines. Must SEI (disable IRQ) before changing vector and CLI after to avoid partial update race. Alternative: disable interrupt source via IA chips by POKEs (machine-specific addresses) to prevent interrupts during vector update. Warnings: changing IRQ vector may disrupt keyboard, tape, and system services; restore original vector before load/save.",
      "references": [
        {
          "chunk": "interrupt_project_c64_example",
          "topic": "example of saving original vector and replacing with custom ISR"
        },
        {
          "chunk": "ia_chips_pia_via_cia_and_interrupt_latching",
          "topic": "IA chips control interrupt gating and event latching"
        }
      ]
    },
    {
      "start": 5661,
      "end": 5684,
      "name": "interrupt_masking_pokes_and_warnings",
      "description": "Machine-specific POKEs to disable/enable interrupts: C64 POKE 56333,127 to disable and 56333,129 to re-enable; VIC-20 POKE 37166,127 / 37166,192; PET POKE 59411,60 / 59411,61. Warning: POKEs may disable keyboard and other services—do not run as direct commands unless you can restore state (e.g., from ML).",
      "references": [
        {
          "chunk": "using_irq_vector_and_masking_interrupts",
          "topic": "machine-specific register writes to gate interrupts"
        }
      ]
    },
    {
      "start": 5685,
      "end": 5689,
      "name": "interrupt_vector_warnings",
      "description": "Warnings about modifying the IRQ vector: avoid leaving it in an inconsistent state (half old/half new address) and the need to prevent interrupts while updating a two-byte vector.",
      "references": [
        {
          "chunk": "interrupts_intro_and_irq_vectors",
          "topic": "Why changing vector matters"
        }
      ]
    },
    {
      "start": 5690,
      "end": 5753,
      "name": "interrupt_project_c64_example",
      "description": "Commodore 64 interrupt example: ISR at $033C copies $91 to $0400 then JMP indirect to previously saved original IRQ routine via ($03A0). Setup routine copies original IRQ vector from $0314/$0315 to $03A0 (save), then SEI and store $033C into $0314/$0315 and CLI to enable custom interrupt; teardown restores $0314/$0315 from $03A0. SYS 836 to enable, SYS 861 to disable. Notes on color nybble table at $D800 for visible output issues.",
      "references": [
        {
          "chunk": "using_irq_vector_and_masking_interrupts",
          "topic": "how to set vector and preserve original using saved indirect address"
        },
        {
          "chunk": "vic_and_c64_memory_extras",
          "topic": "use of $D800 color memory to fix visual artifacts"
        }
      ]
    },
    {
      "start": 5754,
      "end": 5754,
      "ignore": true,
      "reason": "Single blank line after the project—non-technical formatting, safe to ignore."
    },
    {
      "start": 5755,
      "end": 5760,
      "name": "ia_chips_pia_via_cia_and_interrupt_latching",
      "description": "Interface Adapter (IA) chips: PIA (peripheral), VIA (versatile), CIA (complex) handle event latching and interrupt control. They latch transient events into flags and can gate interrupt signals to CPU. Latching ensures brief signals are captured until software clears them; IA chips provide fine control over interrupts including enabling/disabling and flag clearing.",
      "references": [
        {
          "chunk": "using_irq_vector_and_masking_interrupts",
          "topic": "interaction between IA chip settings and CPU interrupt masking"
        }
      ]
    },
    {
      "start": 5761,
      "end": 5824,
      "name": "ia_chips_overview_and_latching",
      "description": "Overview of IA (interface adapter) chips: PIA (Peripheral IA), VIA (Versatile IA), CIA (Complex IA). Main functions listed: event latching & interrupt control. Explains latching: event flags hold briefly-occurring signals until CPU clears them; interrupt enable register links flags to IRQ line; IFR (interrupt flag register) is used to read/clear flags and logical operations (AND/ORA/EOR) extract bits.",
      "references": [
        {
          "chunk": "ia_chip_timers_io",
          "topic": "IA chip timers and I/O functions"
        },
        {
          "chunk": "interrupt_project_example",
          "topic": "Practical use of IA flags with IRQ"
        }
      ]
    },
    {
      "start": 5825,
      "end": 5841,
      "name": "ia_chips_timers_and_io",
      "description": "IA chip functions continue: (2) timers on IA chips count down and often set interrupt flags on overflow; (3) input/output ports on IA chips connect to external devices with outputs typically latching (a store sets a port state). Advises reading full chip specs for details.",
      "references": [
        {
          "chunk": "ia_chips_overview_and_latching",
          "topic": "Complement to latching/interrupts"
        }
      ]
    },
    {
      "start": 5842,
      "end": 5866,
      "name": "ia_chip_tips_and_ier_behavior",
      "description": "Practical tips: many IA addresses behave differently on read vs write. Turning off interrupt flags can require unintuitive stores. The IER (interrupt enable register) often uses the high bit to toggle enable/disable actions; examples given: Commodore 64 store $7F to $DC0C (or $DC0D) to disable interrupts, store $81 to re-enable; VIC-20 and PET equivalents are provided earlier. Warns that disabling interrupts via POKE may disable keyboard and should not be done carelessly.",
      "references": [
        {
          "chunk": "interrupts_intro_and_irq_vectors",
          "topic": "Addresses and POKE examples for disabling interrupts"
        }
      ]
    },
    {
      "start": 5867,
      "end": 5890,
      "name": "infiltrating_basic_wedge_intro_and_CHRGET_location",
      "description": "Introduces the idea of a 'wedge'—modifying BASIC's frequently-used zero-page subroutine used to get characters from BASIC text (CHRGET/CHRGOT). Gives typical locations: $0070-$0087 (most PET/CBM) and $0073-$008A (VIC-20, C64). Notes the routine is self-modifying and is used to fetch and classify characters (numeric, end-of-command, etc.).",
      "references": [
        {
          "chunk": "wedge_and_CHRGET_code_examples",
          "topic": "Detailed CHRGET/CHRGOT code and numeric test"
        }
      ]
    },
    {
      "start": 5891,
      "end": 5910,
      "name": "CHRGET_CHRGOT_basic_behavior_and_objectives",
      "description": "Explains CHRGET/CHRGOT behavior: CHRGET increments the program pointer (CHRGOT+1) and conditionally increments higher byte; CHRGOT then loads a character from the BASIC program buffer. Lists objectives when examining characters: skip spaces, set Z flag and exit on zero or colon ($3A), and set/clear C flag to indicate whether the character is numeric ($30-$39).",
      "references": [
        {
          "chunk": "infiltrating_basic_wedge_intro_and_CHRGET_location",
          "topic": "Where CHRGET lives and what it does"
        }
      ]
    },
    {
      "start": 5911,
      "end": 5945,
      "name": "CHRGET_numeric_test_and_flags",
      "description": "Shows pseudocode of CHRGOT: LDA $xxxx; CMP #$3A; BCS EXIT (colon test); CMP #$20; BEQ CHRGET (skip spaces). Demonstrates an odd but correct test sequence using SEC; SBC #$30; SEC; SBC #$D0 which leaves A unchanged but sets C if < $30 and Z if zero—achieving the numeric test and setting flags as required. Exit via RTS.",
      "references": [
        {
          "chunk": "breaking_into_basic_wedge_constraints",
          "topic": "Constraints when modifying CHRGET/CHRGOT"
        }
      ]
    },
    {
      "start": 5946,
      "end": 5978,
      "name": "breaking_into_basic_wedge_constraints",
      "description": "Discusses modifying BASIC (the wedge): constraints include preserving A/X/Y registers and flags, avoiding slowing BASIC, and careful placement for PET/CBM (modify in CHRGET or after LDA in CHRGOT). Notes VIC-20 and C64 provide a helpful vector at $0308/$0309 allowing control before each BASIC command.",
      "references": [
        {
          "chunk": "infiltrating_basic_wedge_intro_and_CHRGET_location",
          "topic": "CHRGET locations and wedge opportunities"
        },
        {
          "chunk": "txtptr_and_$0308_vector",
          "topic": "Use of $0308 vector to intercept commands on VIC/C64"
        }
      ]
    },
    {
      "start": 5979,
      "end": 5996,
      "name": "txtptr_and_$0308_vector",
      "description": "Explains TXTPTR (text pointer) — address of instruction at CHRGOT pointing to the BASIC command being executed. On VIC-20/C64 a vector at $0308/$0309 provides control immediately before each BASIC command, allowing wedges to examine BASIC text (via indirect indexed addressing) and leave TXTPTR positioned correctly on return.",
      "references": [
        {
          "chunk": "breaking_into_basic_wedge_constraints",
          "topic": "Why $0308 vector simplifies wedge insertion"
        }
      ]
    },
    {
      "start": 5997,
      "end": 6040,
      "name": "ampersand_wedge_command_implementation_part1",
      "description": "Implementation of a wedge command for VIC and C64: use $0308 vector to intercept commands. Code example starts at $033C: LDY #$01; LDA ($7A),Y to peek next char via TXTPTR; CMP #$26 (ampersand) and branch. If not ampersand, JMP via indirect vector to regular BASIC. If ampersand, call CHRGET to move pointer and then prepare to print ten asterisks using CHROUT ($FFD2) in a loop and then print carriage return ($0D), then JMP back to BASIC interpreter.",
      "references": [
        {
          "chunk": "ampersand_wedge_command_installation",
          "topic": "Code to install wedge vector and enable via SYS"
        },
        {
          "chunk": "kernal_chrout_and_charget",
          "topic": "Use of $FFD2 (CHROUT) and $0073 (CHRGET) in wedge"
        }
      ]
    },
    {
      "start": 6041,
      "end": 6058,
      "name": "ampersand_wedge_command_installation",
      "description": "Shows the code to install the wedge via $0308 vector: save old vector into $03A0/$03A1, then store new vector address $033C into $0308/$0309, and return (RTS). Instructs to invoke the installer with SYS 862. Explains that BASIC will now accept '&' as the special command.",
      "references": [
        {
          "chunk": "ampersand_wedge_command_implementation_part1",
          "topic": "Intercept code that handles '&' command"
        }
      ]
    },
    {
      "start": 6059,
      "end": 6072,
      "name": "testing_ampersand_wedge",
      "description": "How to test the wedge: write a small BASIC program with an '&' command, run it and get SYNTAX ERROR, then run SYS 862 to enable wedge. When re-run, '&' prints ten asterisks. Notes caution that infiltrating BASIC is tricky.",
      "references": [
        {
          "chunk": "ampersand_wedge_command_installation",
          "topic": "SYS 862 installs wedge"
        }
      ]
    },
    {
      "start": 6073,
      "end": 6121,
      "name": "things_you_have_learned_interrupts_stack_usr_sys",
      "description": "Summary bullets: stack location and LIFO behavior; importance of matching push/pop; PHA/PLA/PHP/PLP usage; JSR/RTS stack mechanics; interrupts/BRK push three items and RTI restores; USR function vs SYS command; ROM-provided interrupt sequences push A/X/Y and branch through an indirect address for user modification; IA chips functions and CHRGET subroutine as an infiltration point for BASIC expansion.",
      "references": [
        {
          "chunk": "interrupt_project_example",
          "topic": "Example that used IRQ vector modification"
        },
        {
          "chunk": "infiltrating_basic_wedge_intro_and_CHRGET_location",
          "topic": "CHRGET as wedge entry point"
        }
      ]
    },
    {
      "start": 6122,
      "end": 6166,
      "name": "questions_and_projects_interrupts_and_wedges",
      "description": "Questions/projects related to interrupts and wedges: ideas to redirect IRQ to display zero page contents, discussion prompt about using stack for parameter passing to subroutines, ideas for scrolling listings (SYS, wedge, or interrupt?), checking stack contents to see SYS return address.",
      "references": [
        {
          "chunk": "things_you_have_learned_interrupts_stack_usr_sys",
          "topic": "Suggested projects relate to learned items"
        }
      ]
    },
    {
      "start": 6167,
      "end": 6176,
      "name": "chapter8_timing_io_and_conclusion_introduction",
      "description": "Chapter 8 header and table of contents: topics covered include estimating program speed, input/output from tape/disk/printer, instruction review, debugging, symbolic assemblers, and next steps.",
      "references": [
        {
          "chunk": "timing_rules_and_memory_cycles",
          "topic": "Timing rules introduced in this chapter"
        },
        {
          "chunk": "input_output_kernal_calls",
          "topic": "I/O handling via KERNAL routines covered later"
        }
      ]
    },
    {
      "start": 6177,
      "end": 6232,
      "name": "timing_rules_and_memory_cycles",
      "description": "Timing advice: interrupts affect timing (add ~10%); count loops multiplicatively; clock/memory cycle ~1 microsecond varies by model; most instructions timing equals memory cycles fetched (minimum two cycles); indexed accesses, page-cross penalties, branch timing differences; special-case exceptions like shifts, INC/DEC, JSR/RTS.",
      "references": [
        {
          "chunk": "timing_example_and_cycle_counting",
          "topic": "Worked example counting cycles"
        }
      ]
    },
    {
      "start": 6233,
      "end": 6269,
      "name": "timing_example_and_cycle_counting",
      "description": "Example routine that ANDs contents of 100 locations ($17E0-$1844) and a detailed cycle-by-cycle breakdown: instruction counts for LDX, LDA immediate, AND (with page-cross penalties), INX, CPX, BCC, RTS, totaling 1171 cycles (~1.17 ms) and suggestion to add 10% for interrupts and extra cycles for being a subroutine (JSR).",
      "references": [
        {
          "chunk": "timing_rules_and_memory_cycles",
          "topic": "Applies the timing rules to a concrete example"
        }
      ]
    },
    {
      "start": 6270,
      "end": 6271,
      "name": "sei_lockout_caution",
      "description": "Short caution: SEI can be used to lock out interrupts for precise timing but is potentially dangerous and seldom necessary.",
      "references": [
        {
          "chunk": "timing_rules_and_memory_cycles",
          "topic": "When to consider disabling interrupts for timing"
        }
      ]
    },
    {
      "start": 6272,
      "end": 6369,
      "name": "input_output_kernal_calls_and_output_switching",
      "description": "KERNAL I/O overview: CHROUT ($FFD2) sends ASCII chars to the current output channel; GETIN ($FFE4) reads keyboard/input into A. You can redirect input/output to logical files using CHKIN ($FFC6) and CHKOUT ($FFC9), and restore default channels with CLRCHN ($FFCC). Diagram (Figure 8.1) shows how CHKIN/CHKOUT/CLRCHN switch input/output channels. Notes that CHKOUT/CHKIN change A and X registers and may set carry flag on errors. Give usage pattern: LDX #file; JSR $FFC9 to set output, JSR $FFD2 to send characters; JSR $FFCC to restore.",
      "references": [
        {
          "chunk": "output_example_print_to_printer",
          "topic": "Practical example sending 'HI' to printer using CHKOUT and CHROUT"
        },
        {
          "chunk": "input_example_read_sequential_file",
          "topic": "Reading from a logical input file using CHKIN and GETIN"
        }
      ]
    },
    {
      "start": 6370,
      "end": 6419,
      "name": "output_example_print_to_printer",
      "description": "Step-by-step example: open logical file 1 in BASIC (printer/cassette/disk variants), then in machine code LDX #$01; JSR $FFC9 to switch output to logical file 1; send characters 'H' and 'I' and RETURN using LDA #$48 / JSR $FFD2 etc; finally JSR $FFCC to restore and RTS. Notes the machine code doesn't care which device logical file 1 refers to.",
      "references": [
        {
          "chunk": "input_output_kernal_calls_and_output_switching",
          "topic": "Use of CHKOUT and CHROUT"
        }
      ]
    },
    {
      "start": 6420,
      "end": 6461,
      "name": "switching_input_chkin_and_clrchn",
      "description": "Switching input: CHKIN ($FFC6) selects a logical input file (LDX #file; JSR $FFC6). CLRCHN ($FFCC) restores keyboard/screen default. CHKIN and CLRCHN change A and X and may set carry on error. Notes differences between file GETIN ($FFE4) behavior vs keyboard: a binary zero from file is a real CHR$(0) versus keyboard 'no key pressed'. Use ST ($90 on VIC/C64, $96 on PET/CBM) to detect end-of-file or errors.",
      "references": [
        {
          "chunk": "input_example_read_sequential_file",
          "topic": "Example reading a sequential file using CHKIN/GETIN and CLRCHN"
        }
      ]
    },
    {
      "start": 6462,
      "end": 6546,
      "name": "input_example_read_sequential_file",
      "description": "Example program to read a sequential file to the screen: BASIC shows opening files; machine code example: LDX #$01; JSR $FFC6 to switch input; loop: JSR $FFE4 (GETIN) then JSR $FFD2 (CHROUT) to echo to screen; LDA $90 (ST) and BEQ back to loop until ST nonzero; finally JSR $FFCC and RTS. Explains ST semantics and locations for ST on different machines.",
      "references": [
        {
          "chunk": "switching_input_chkin_and_clrchn",
          "topic": "How CHKIN and CLRCHN are used in this example"
        }
      ]
    },
    {
      "start": 6547,
      "end": 6662,
      "name": "file_transfer_program_machine_and_basic",
      "description": "File transfer example: BASIC front-end prompts for devices and opens logical files; machine code (example at $0A00 on C64) switches input (LDX #1; JSR $FFC6), JSR $FFE4 to get char, then saves ST onto stack (LDX $90; PHP) and pushes A (PHA); JSR $FFCC; LDX #$02; JSR $FFC9 to set output; PLA to restore char; JSR $FFD2 to send; JSR $FFCC to disconnect; PLP to retrieve ST flags and branch accordingly (BEQ back to input loop). Important: don't switch input and output simultaneously; manage ST checks carefully. Warns to adjust start-of-variables pointer ($002D/$002E) to avoid overwriting machine code.",
      "references": [
        {
          "chunk": "switching_input_chkin_and_clrchn",
          "topic": "Using CHKIN/CHKOUT/CLRCHN in coordinated file transfers"
        }
      ]
    },
    {
      "start": 6663,
      "end": 6749,
      "name": "instruction_set_review",
      "description": "Review of the 650x instruction set: loads/stores (LDA/LDX/LDY/STA/STX/STY/CMP/CPX/CPY), logical/arithmetic (AND/ORA/EOR/ADC/SBC), shifts/rotates (ASL/ROL/LSR/ROR), INC/DEC/INX/DEX/INY/DEY, branches (BEQ/BNE/BCS/BCC/BMI/BPL/BVS/BVC), JMP, subroutines (JSR/RTS/RTI), status set/clear (SEC/CLC/SEI/CLI/SED/CLD/CLV), transfers (TAX/TAY/TSX/TXA/TYA/TXS), stack ops (PHA/PLA/PHP/PLP), BIT instruction (test bits and set flags), and NOP/BRK. Notes BIT semantics and calls out special behaviors.",
      "references": [
        {
          "chunk": "programming_model_and_registers",
          "topic": "Processor status and register model relevant to instructions"
        },
        {
          "chunk": "instruction_timing_and_opcode_table",
          "topic": "Timing and opcode encodings for these instructions"
        }
      ]
    },
    {
      "start": 6750,
      "end": 6798,
      "name": "debugging_methods_and_use_of_monitor",
      "description": "Debugging techniques: use breakpoints by replacing opcodes with BRK (00) to invoke monitor and inspect registers/memory; replace BRK with original opcode when done, use .G to continue; consider single-step to trace execution. Advice: write sensibly, insert stop-key tests (JSR $FFE1) to regain control, be aware of and avoid clobbering monitor workspace addresses while debugging.",
      "references": [
        {
          "chunk": "symbolic_assemblers_and_source_management",
          "topic": "Symbolic assemblers help reduce retyping and address errors during debugging"
        }
      ]
    },
    {
      "start": 6799,
      "end": 6845,
      "name": "symbolic_assemblers_and_source_management",
      "description": "Advantages of symbolic assemblers over small monitors: labels, forward references, automatic address fixups, comments in source, printable listings, save/load source for iterative development. Discusses pain of inserting bytes mid-code when using monitors versus easy insertion with assemblers.",
      "references": [
        {
          "chunk": "debugging_methods_and_use_of_monitor",
          "topic": "How assemblers simplify debugging and maintenance"
        }
      ]
    },
    {
      "start": 6846,
      "end": 6861,
      "name": "where_to_go_from_here_overview",
      "description": "Encouraging note on next steps: many application areas (math, BASIC augmentation, graphics, music, hardware interfaces). Machine language knowledge opens up more advanced texts and deeper understanding of hardware/software interplay.",
      "references": [
        {
          "chunk": "symbolic_assemblers_and_source_management",
          "topic": "Using assemblers when developing larger projects"
        }
      ]
    },
    {
      "start": 6862,
      "end": 6915,
      "name": "what_you_have_learned_chapter8_summary",
      "description": "Summary bullets for the chapter: estimating run times, switching input/output to files with CHKIN/CHKOUT and restoring with CLRCHN, using $FFE4 and $FFD2 for I/O, opening vs connecting to channels, full instruction set coverage reminder.",
      "references": [
        {
          "chunk": "input_output_kernal_calls_and_output_switching",
          "topic": "I/O subroutines and channel handling"
        },
        {
          "chunk": "instruction_set_review",
          "topic": "Instruction coverage summary"
        }
      ]
    },
    {
      "start": 6916,
      "end": 6946,
      "name": "chapter8_questions_and_projects",
      "description": "Challenge exercises: count occurrences of 'S' or RETURN ($0D) in a sequential file using machine language; write programs to print repeated messages to printer; create machine-language equivalents of PRINT# to send DOS commands (e.g., scratch a file); write a typewriter utility program with delete handling.",
      "references": [
        {
          "chunk": "file_transfer_program_machine_and_basic",
          "topic": "File handling examples useful for these projects"
        }
      ]
    },
    {
      "start": 6947,
      "end": 6968,
      "name": "appendix_a_header_and_6502_variants",
      "description": "Appendix A heading and note on 6502 family differences: 6502 uses addresses $00/$01 as normal memory; 6510/7501 use $00 as directional register and $01 as I/O (cassette/memory control); 6509 uses $00 to switch program bank and $01 to switch bank for (..),Y addressing.",
      "references": [
        {
          "chunk": "programming_model_and_registers",
          "topic": "6502 core register concepts referenced in Appendix A"
        }
      ]
    },
    {
      "start": 6969,
      "end": 7000,
      "name": "addressing_modes_descriptions",
      "description": "Definitions of addressing modes used by 6502: accumulator, immediate, absolute, zero page, indexed zero page (ZP,X / ZP,Y), indexed absolute (ABS,X / ABS,Y), implied, relative (branch offsets -128..+127), indexed indirect (IND,X) and indirect indexed (IND),Y, and absolute indirect. Explains how effective addresses are formed for each mode.",
      "references": [
        {
          "chunk": "instruction_timing_and_opcode_table",
          "topic": "Opcode formats and sizes for these addressing modes"
        }
      ]
    },
    {
      "start": 7001,
      "end": 7050,
      "name": "instruction_alphabetic_list_part1",
      "description": "Alphabetical list of many 6502 instructions with short mnemonic descriptions: ADC, AND, ASL, BCC/BCS/BEQ/BIT/BMI/BNE/BPL/BRK/BVC/BVS, CLC/CLD/CLI/CLV/CMP/CPX/CPY, DEC/DEX/DEY, EOR, INC/INX/INY, JMP/JSR — presents names and brief actions.",
      "references": [
        {
          "chunk": "instruction_alphabetic_list_part2",
          "topic": "Continuation of alphabetic instruction list"
        }
      ]
    },
    {
      "start": 7051,
      "end": 7126,
      "name": "instruction_mnemonics_reference",
      "description": "Compact reference list of 6502/Commodore 64 instruction mnemonics with short descriptions. Covers arithmetic and logical ops (ADC, AND, EOR, ORA, SBC), shifts and rotates (ASL, LSR, ROL, ROR), branch instructions (BCC, BCS, BEQ, BMI, BNE, BPL, BVC, BVS), status/flag control (CLC, CLD, CLI, CLV, SEC, SED, SEI), compare instructions (CMP, CPX, CPY), increment/decrement and memory modify (INC, INX, INY, DEC, DEX, DEY), bit test (BIT), jumps and subroutine control (JMP, JSR, RTS, RTI, BRK), loads and stores (LDA, LDX, LDY, STA, STX, STY), stack operations (PHA, PHP, PLA, PLP), transfer instructions between registers and stack pointer (TAX, TAY, TSX, TXA, TXS, TYA), and the NOP instruction. Includes surrounding blank lines and page markers as they appear in the original listing.",
      "references": [
        {
          "chunk": "programming_model_registers_and_flags",
          "topic": "Shows CPU register layout and processor status flags referenced by many instructions (A, X, Y, PC, S, P)"
        }
      ]
    },
    {
      "start": 7127,
      "end": 7176,
      "name": "programming_model_registers_and_flags",
      "description": "The 6502 programming model: diagrams and descriptions of the processor registers and the processor status register. Includes 8-bit accumulator (A) and index registers (X, Y); 16-bit program counter shown as PCH/PCL labeled \"PC\"; stack pointer format illustrated (leading '1' then S) labeled \"S\"; and the processor status register P with bit order 'N V - B D I Z C' and per-flag meanings: N = Negative (1 = negative), V = Overflow (1 = true), - (unused), B = BRK command, D = Decimal Mode (1 = true), I = IRQ Disable (1 = disable), Z = Zero (1 = result zero), C = Carry (1 = true). Contains Figure A.1 labelling the diagrams.",
      "references": [
        {
          "chunk": "instruction_mnemonics_reference",
          "topic": "Provides the instruction set whose behaviour depends on the registers and flags (A, X, Y, PC, S, P)"
        }
      ]
    },
    {
      "start": 7177,
      "end": 7193,
      "name": "logical_ops_opcode_endings",
      "description": "Opcode encoding grid for logical and related instructions (ORA, AND, EOR, ADC, STA, LDA, CMP, SBC). Shows opcode hex values arranged by addressing mode (IMM, ZP, ZP,X, (IND,X), (IND),Y, ABS, ABS,X, ABS,Y) and includes the note that these opcodes end in -1, -5, -9, or -D.",
      "references": [
        {
          "chunk": "shifts_rotates_inc_dec_ldx_ldy_opcode_endings",
          "topic": "Similar opcode-ending pattern table for shifts/rotates and inc/dec/ldx/ldy"
        },
        {
          "chunk": "instruction_table_header",
          "topic": "Instruction table header describing addressing modes and cycle counts"
        },
        {
          "chunk": "instruction_timing_table_part1",
          "topic": "Detailed opcode + cycle rows for many of these instructions"
        }
      ]
    },
    {
      "start": 7194,
      "end": 7209,
      "name": "shifts_rotates_inc_dec_ldx_ldy_opcode_endings",
      "description": "Opcode encoding grid for shift/rotate and register/memory modify instructions (ASL, ROL, LSR, ROR, STX, LDX, DEC, INC). Lists hex opcodes by addressing mode (IMM, ZP, ZP,X, ZP,Y, ABS, ABS,X, ABS,Y) and notes that these opcodes end in -2, -6, or -E.",
      "references": [
        {
          "chunk": "logical_ops_opcode_endings",
          "topic": "Logical ops opcode-ending patterns for comparison"
        },
        {
          "chunk": "single_byte_opcode_nibble_map",
          "topic": "Single-byte opcode layout (control and register ops)"
        },
        {
          "chunk": "instruction_timing_table_part1",
          "topic": "Detailed timing/opcode rows for many of these instructions"
        }
      ]
    },
    {
      "start": 7210,
      "end": 7222,
      "name": "branches_jumps_and_misc_opcodes_overview",
      "description": "Overview block showing branch opcodes (BPL, BMI, BVC, BVS, BCC, BCS, BNE, BEQ) with their low-nibble patterns, jump/JSR opcodes (JMP, JSR) and a small misc. table for BIT, STY, LDY, CPY, CPX showing ABS/(IND) and addressing-mode opcodes. Includes the summary note 'Misc. -0, -4, -C'.",
      "references": [
        {
          "chunk": "single_byte_opcode_nibble_map",
          "topic": "Single-byte opcode patterns and control instructions"
        },
        {
          "chunk": "instruction_table_header",
          "topic": "Addresses/mode column definitions and cycle counts used by these opcodes"
        },
        {
          "chunk": "instruction_timing_table_part1",
          "topic": "Full timing/opcode rows for branches and jump-related instructions"
        }
      ]
    },
    {
      "start": 7223,
      "end": 7237,
      "name": "single_byte_opcode_nibble_map",
      "description": "4x4 nibble-style map of single-byte opcodes arranged by low nibble columns (0-, 8-, A-, etc) and high nibble rows (-0, -8, -A). Shows single-byte instructions such as BRK, RTI, RTS, PHP, CLC, PLP, SEC, PHA, CLI, PLA, SEI, register transfers/flags (DEY, TYA, TAY, CLV, INY, CLD, INX, SED, TXA, TXS, TAX, TSX, DEX, NOP) and labels this section 'Single-byte Op Codes -0, -8, -A'.",
      "references": [
        {
          "chunk": "branches_jumps_and_misc_opcodes_overview",
          "topic": "Branch and jump opcode overview that complements the single-byte map"
        },
        {
          "chunk": "instruction_table_header",
          "topic": "Header information for the instruction timing table that follows"
        }
      ]
    },
    {
      "start": 7238,
      "end": 7246,
      "name": "instruction_table_header",
      "description": "Figure A.2 marker and the INSTRUCTIONS table header. Defines addressing-mode columns and their byte counts (Imm, Abs, ZP, Acc, Imp, (IX), (I)Y, ZP,X, AbsX, AbsY, Rel, Ind, ZP,Y) and shows the OP/N and flag bits format used in the following timing/opcode tables.",
      "references": [
        {
          "chunk": "instruction_timing_table_part1",
          "topic": "First portion of the instruction timing/opcode table using these headers"
        },
        {
          "chunk": "instruction_timing_table_part2",
          "topic": "Second portion of the instruction timing/opcode table using these headers"
        }
      ]
    },
    {
      "start": 7247,
      "end": 7277,
      "name": "instruction_timing_table_part1",
      "description": "First part of the instruction timing/opcode table (rows and timing/opcode details). Covers ADC, AND, ASL, BCC, BCS, BEQ, BIT, BMI, BNE, BPL, BRK, BVC, BVS, CLC, CLD, CLI, CLV, CMP, CPX, CPY, DEC, DEX, DEY, EOR, INC, INX, INY, JMP, and JSR. Shows opcode hex per addressing mode, cycle counts, and special notes such as page-boundary extra cycles and branch timing variants.",
      "references": [
        {
          "chunk": "instruction_table_header",
          "topic": "Header defining the addressing-mode columns and cycle counts used here"
        },
        {
          "chunk": "instruction_timing_table_part2",
          "topic": "Continuation of the instruction timing/opcode table (remaining instructions)"
        },
        {
          "chunk": "instruction_table_notes_and_figure",
          "topic": "Explanation of table symbols (!, @, M6, M7, #, $) and Figure A.4"
        }
      ]
    },
    {
      "start": 7278,
      "end": 7311,
      "name": "instruction_timing_table_part2",
      "description": "Second part of the instruction timing/opcode table continuing on the next page. Covers LDA, LDX, LDY, LSR, NOP, ORA, PHA, PHP, PLA, PLP, ROL, ROR, RTI, RTS, SBC, SEC, SED, SEI, STA, STX, STY, TAX, TAY, TSX, TXA, TXS, and TYA. Includes opcode hex values by addressing mode and cycle counts, including page-cross and branch behavior notations.",
      "references": [
        {
          "chunk": "instruction_timing_table_part1",
          "topic": "First part of the timing/opcode table (complementary rows)"
        },
        {
          "chunk": "instruction_table_header",
          "topic": "Addressing-mode and cycle-count column definitions"
        },
        {
          "chunk": "instruction_table_notes_and_figure",
          "topic": "Table symbol explanations used here"
        }
      ]
    },
    {
      "start": 7312,
      "end": 7321,
      "name": "instruction_table_notes_and_figure",
      "description": "Notes for the instruction timing/opcode table (Figure A.4). Explains symbols used in the table: '!' (add 1 cycle if page boundary crossed), '@' (branch cycles if not taken or taken), M6/M7 memory bit notes, '#' (Borrow = Not Carry), '$' (decimal mode Z flag invalid and accumulator zero check), and includes Figure A.4 marker.",
      "references": [
        {
          "chunk": "instruction_timing_table_part1",
          "topic": "Applies when interpreting the timing/opcode rows in part 1"
        },
        {
          "chunk": "instruction_timing_table_part2",
          "topic": "Applies when interpreting the timing/opcode rows in part 2"
        },
        {
          "chunk": "instruction_table_header",
          "topic": "Defines the columns and OP/N layout that the notes annotate"
        }
      ]
    },
    {
      "start": 7322,
      "end": 7360,
      "name": "appendix_b_header_and_characteristics_intro",
      "description": "Appendix B header: characteristics of Commodore machines and notation. Advises that maps may be too big/small for particular uses and that the maps that follow are a guide. Introduces the PET original ROM subsection.",
      "references": [
        {
          "chunk": "pet_original_rom_characteristics",
          "topic": "Start of PET descriptions and distinctions"
        }
      ]
    },
    {
      "start": 7361,
      "end": 7411,
      "name": "pet_original_and_upgrade_rom_characteristics",
      "description": "Describes PET variants: Original ROM (identified by '*** COMMODORE BASIC ***' power-up text), Upgrade ROM ('### COMMODORE BASIC ###') and notes about disk handling, garbage collection delay on Upgrade ROM, and upgrade benefits. Introduces PET/CBM 4.0 ROM and 80-column variants with '*** COMMODORE BASIC 4.0 ***' string, new disk commands and elimination of garbage-collection delays.",
      "references": [
        {
          "chunk": "pet_4_0_and_80column",
          "topic": "Details about 4.0 ROM and 80-column models"
        }
      ]
    },
    {
      "start": 7412,
      "end": 7437,
      "name": "vic20_overview_zero_page_and_sys_features",
      "description": "VIC-20 overview: new design with color/graphics/sound, changed memory architecture and zero page layout; BASIC similar to Upgrade ROM; no built-in monitor (must load one); SYS command allows preloading A/X/Y via POKE into addresses 780/781/782; warns about location variability depending on memory expansion.",
      "references": [
        {
          "chunk": "commodore_64_overview_memory_and_SYS",
          "topic": "Similarities and differences with C64"
        }
      ]
    },
    {
      "start": 7438,
      "end": 7461,
      "name": "commodore_64_overview_memory_and_SYS",
      "description": "Commodore 64 overview: similar to VIC-20 with 6510 CPU (addresses 0/1 for bank switching); consistent BASIC start and screen memory at $0400; a bank of RAM at $C000-$CFFF useful for staging machine code; sometimes desirable to write entirely in machine language (swap out BASIC). SYS command allows preloading A/X/Y like VIC.",
      "references": [
        {
          "chunk": "vic20_overview_zero_page_and_sys_features",
          "topic": "Shared features with VIC-20"
        }
      ]
    },
    {
      "start": 7462,
      "end": 7479,
      "name": "commodore_plus4_overview",
      "description": "Commodore PLUS/4 overview: uses 7501 CPU (6502-compatible), BASIC expanded, screen memory and BASIC RAM moved, color/sound implemented differently, built-in machine-language monitor with assemble/disassemble features, memory arrangement more sophisticated.",
      "references": [
        {
          "chunk": "commodore_64_overview_memory_and_SYS",
          "topic": "PLUS/4 similarities with C64"
        }
      ]
    },
    {
      "start": 7480,
      "end": 7506,
      "name": "b_series_6509_and_bank_switching",
      "description": "B-series computers (B-128, B-256, CBM-128/256) overview: use 6509 CPU with bank-switched memory; different zero page; cassette buffer location moved; more complex bank-switching requiring transfer sequences and bootstraps; built-in monitor with new commands (.V .@). Advises beginners to consider simpler models.",
      "references": [
        {
          "chunk": "appendix_c_memory_maps",
          "topic": "Bank-switching affects memory map and placement of code/data"
        }
      ]
    },
    {
      "start": 7507,
      "end": 7536,
      "name": "appendix_c_header_and_memory_maps_intro",
      "description": "Appendix C heading: introduction to memory maps, advice about their limitations (too big/too small), guidance for beginners and advanced programmers, and that POKE/PEEK locations should be checked in the maps that follow.",
      "references": [
        {
          "chunk": "pet_original_memory_map_part1",
          "topic": "Start of detailed PET memory map"
        }
      ]
    },
    {
      "start": 7537,
      "end": 7615,
      "name": "pet_original_memory_map_part1",
      "description": "Original ROM PET zero page guidance and start of a detailed memory map: notes 'Great Zero-Page Hunt' and lists critical zero-page locations not to modify (e.g., $03, $05, $64-$67, $7A-$87, etc.). Memory map entries begin: $0000-$0002 USR jump, various zero-page uses through $00FF, tape buffers, stack, and screen pointers; includes many labeled addresses and their purposes in PET original ROM.",
      "references": [
        {
          "chunk": "pet_original_memory_map_part2",
          "topic": "Continuation of PET memory map (more addresses)"
        }
      ]
    },
    {
      "start": 7616,
      "end": 7655,
      "name": "pet_original_memory_map_part2",
      "description": "Continuation of the PET original memory map covering jiffy clock, keyboard buffer, IRQ/BRK vectors, ST status, file tables, tape buffers, and available RAM regions. Lists many zero-page and low-memory system locations and their uses, and ROM/Kernal ranges such as F000-FFFF for Kernal ROM.",
      "references": [
        {
          "chunk": "pia_via_charts",
          "topic": "Addresses for PIA/VIA chips listed in PET memory map"
        }
      ]
    },
    {
      "start": 7656,
      "end": 7714,
      "name": "pet_original_memory_map_part3_and_IO_devices",
      "description": "Further PET memory map: details about tape #1/#2 buffers, monitor extension vector, available RAM ranges, screen RAM addresses, BASIC ROM, KERNAL ROM, and PIA/VIA chip address ranges. Mentions PIA/VIA chart pointers.",
      "references": [
        {
          "chunk": "pia_via_charts",
          "topic": "Detailed PIA/VIA register descriptions follow"
        }
      ]
    },
    {
      "start": 7715,
      "end": 7790,
      "name": "upgrade_rom_and_basic_4_0_memory_map_intro",
      "description": "Upgrade ROM and BASIC 4.0 zero-page guidance: lists available temporary zero-page areas (e.g., $1F-$27, $4B-$50, $54-$5D) and critical locations to avoid modifying. Introduces differences shown by asterisk in the full memory map that follows and provides the beginning of the detailed Upgrade ROM/4.0 memory map layout.",
      "references": [
        {
          "chunk": "upgrade_ROM_memory_map_part1",
          "topic": "Detailed Upgrade ROM memory map entries"
        }
      ]
    },
    {
      "start": 7791,
      "end": 7870,
      "name": "upgrade_ROM_memory_map_part1",
      "description": "Detailed Upgrade ROM/4.0 memory map entries: zero-page definitions and offsets ($0000-$00FF), CHRGET locations, vectors, ST and keyboard status, tape constants, and the start of higher memory regions and work areas. Notes differences for 40- and 80-column machines and pointers for many internal functions.",
      "references": [
        {
          "chunk": "upgrade_ROM_memory_map_part2",
          "topic": "Continue through higher zero-page and screen tables"
        }
      ]
    },
    {
      "start": 7871,
      "end": 7941,
      "name": "upgrade_ROM_memory_map_part2_and_pia_via_intro",
      "description": "Continues Upgrade ROM memory map: screen line wrap tables, file logical/device/secondary address tables, tape input buffers, BASIC/DOS areas, and references to PIA/VIA chip usage. Introduces PIA 6520 charts and layout.",
      "references": [
        {
          "chunk": "pia_via_charts",
          "topic": "PIA 1 and 2 contact diagrams and register functions"
        }
      ]
    },
    {
      "start": 7942,
      "end": 8010,
      "name": "pia_charts_and_keyboard_and_ieee_function_map",
      "description": "PIA (6520) charts showing register roles at addresses like $E810-$E813 (PIA1 keyboard interface) and $E820-$E823 (PIA2 IEEE-488). Depicts functions per bit such as tape sense, keyboard row select, retrace latch, cassette motor control, and interrupt controls. These diagrams show which PIA pins map to system functions.",
      "references": [
        {
          "chunk": "via_chart_and_timers",
          "topic": "VIA (6522) chart follows with timers and port direction registers"
        }
      ]
    },
    {
      "start": 8011,
      "end": 8049,
      "name": "via_chart_and_timers",
      "description": "VIA (6522) chart (addresses $E840-$E84F): lists inputs/outputs for data handshake (/DAV,/NRFD), retrace, tape motor, timers (Timer1/Timer2), shift register, data direction registers A/B, timer latches, IRQ/status and enable registers. Shows how VIA provides timers, latches and port control for system devices.",
      "references": [
        {
          "chunk": "pia_charts_and_keyboard_and_ieee_function_map",
          "topic": "Related PIA register mappings"
        }
      ]
    },
    {
      "start": 8050,
      "end": 8100,
      "name": "cbm_crt_controller_6545_parameters_and_notes",
      "description": "CBM 8032 / FAT-40 6545 CRT controller typical register values and notes: lists typical decimal values for registers $E880/$E881 and describes fields like Horizontal Total, Characters Displayed, Sync positions, Vertical total/adjustment, Scan lines, Cursor registers. Notes that registers are write-only, register 0 changes can damage CRT, and Register 12 bit meanings (invert video, alternate character set). (Figure C.4)",
      "references": [
        {
          "chunk": "via_chart_and_timers",
          "topic": "CRT controller works alongside VIA/PIA timers and control"
        }
      ]
    },
    {
      "start": 8101,
      "end": 8140,
      "name": "vic20_zero_page_guidance_and_memory_map_intro",
      "description": "VIC-20 zero-page guidance: available areas ($FC-$FF, $22-$2A, $4E-$53, $57-$60) and a list of zero-page locations to avoid modifying. Begins VIC-20 memory map with zero-page entries ($0000-$003E etc.), CHRGET subroutine locations ($0073-$008A), RND seed values, and ST at $0090, plus SYS register save locations at $030C-$030F and vectors at $0314-$032F.",
      "references": [
        {
          "chunk": "vic20_memory_map_continued",
          "topic": "Full VIC-20 memory map with cassette buffer and ROM areas"
        }
      ]
    },
    {
      "start": 8141,
      "end": 8220,
      "name": "vic20_memory_map_part1",
      "description": "VIC-20 detailed memory map (continuation): keyboard buffer and status locations, tape buffer pointers, jiffy clock, file tables, cassette buffer regions ($033C-$03FB), RAM expansion areas, normal BASIC memory, character bitmaps ROM at $8000, VIC 6560 registers at $9000, VIA locations at $9110-$912F for NMI/IRQ interfaces and timers, and color nybble areas at $9400+ and $9600+.",
      "references": [
        {
          "chunk": "vic_6560_register_map",
          "topic": "VIC 6560 register meanings at $9000 range"
        },
        {
          "chunk": "vic20_via_usage",
          "topic": "VIA mapping for VIC-20 at $9110-$912F"
        }
      ]
    },
    {
      "start": 8221,
      "end": 8300,
      "name": "vic20_memory_map_part2_and_device_tables",
      "description": "Further VIC-20 memory map entries: screen line tables ($00D9-$00F0), screen and color pointers, SYS register save areas, error message links, LOAD/SAVE links, and further available RAM/ROM areas for expansions and plug-in ROMs. Notes typical default vectors and their addresses.",
      "references": [
        {
          "chunk": "vic20_memory_map_part1",
          "topic": "Prior parts of VIC-20 memory map"
        }
      ]
    },
    {
      "start": 8301,
      "end": 8380,
      "name": "vic_6560_register_map_and_sound_paddle_bits",
      "description": "VIC 6560 (video chip) register map (addresses $9000-$900F): Left/Top margins, columns/rows, input raster value, screen & character address bits, light-pen horizontal/vertical, paddle inputs X/Y, voice frequencies (Voice 1-3), noise frequency, multicolor mode and amplitude, background/foreground/frame colors. (Figure C.6)",
      "references": [
        {
          "chunk": "vic20_memory_map_part1",
          "topic": "Where the VIC registers are mapped in the VIC-20 map"
        }
      ]
    },
    {
      "start": 8381,
      "end": 8458,
      "name": "vic20_6522_usage_and_registers",
      "description": "VIC-20 6522 (VIA) usage at $9110-$911F and $9120-$912F: mapping of RS-232 or parallel port signals (DSR, CTS, DCD, RI, DTR, RTS), data direction registers, timers for tape RS232 timing, timer latches, shift register (often unused), control registers for CB1/CB2/CA1/CA2 and their interrupt/status bits. Figures C.7 and C.8 show pin functions and usage for serial/tape/joystick/keyboard.",
      "references": [
        {
          "chunk": "vic_6560_register_map_and_sound_paddle_bits",
          "topic": "VIC chip registers relate to VIA interrupt/timer inputs"
        }
      ]
    },
    {
      "start": 8459,
      "end": 8460,
      "ignore": true,
      "reason": "Figure caption / page marker (non-technical); safe to ignore."
    },
    {
      "start": 8461,
      "end": 8515,
      "name": "vic20_6522_usage_keyboard",
      "description": "VIC-20 6522 VIA register usage for $9120-$912F: keyboard row select and column input ($9120/$9121), Data Direction Registers for these ports ($9122/$9123), Timer 1 (cassette tape read or keyboard & clock interrupt) and its latch, Timer 2 (serial bus or tape R/W timing), shift register (unused), control register bits (T1/T2/shift controls), CB/CA control functions (serial bus data out, SRQ in, serial clock out, tape in), IRQ/interrupt status and enable registers, and $912F marked unused.",
      "references": [
        {
          "chunk": "vic20_6522_usage_rs232_userport",
          "topic": "6522 registers used for RS-232 / user port ($9110-$911F)"
        }
      ]
    },
    {
      "start": 8516,
      "end": 8516,
      "name": "vic20_via_usage_continued_and_serial_mappings",
      "description": "Continuation of 6522 usage for VIC-20: further details on timer controls, latch controls, CB1/CB2/CA1/CA2 controls, interrupt status/enable mapping, joystick select lines, keyboard column inputs, and serial clock/data signals at addresses $9120-$912F.",
      "references": [
        {
          "chunk": "vic20_6522_usage_and_registers",
          "topic": "Full VIA usage for VIC-20"
        }
      ]
    },
    {
      "start": 8517,
      "end": 8535,
      "name": "c64_zero_page_overview",
      "description": "Commodore 64: 'The Great Zero-Page Hunt' summary. Lists zero-page locations typically available for user programs ($FC-$FF, $22-$2A, $4E-$53, $57-$60) and warns about critical OS/BASIC zero-page locations that must not be modified (detailed ranges such as $13, $16-$18, $2B-$38, $53-$54, etc.).",
      "references": [
        {
          "chunk": "c64_memory_map_zero_page_part1",
          "topic": "Detailed zero-page memory map entries"
        }
      ]
    },
    {
      "start": 8536,
      "end": 8537,
      "name": "commodore64_zero_page_guidance_and_memory_map_intro",
      "description": "Commodore 64 zero-page guidance (available areas $FC-$FF, work areas like $22-$2A, $4E-$53, etc.) and critical zero-page addresses to avoid. Begins the C64 memory map with $0000 chip directional/I/O registers, float/fixed vectors, zero-page pointers for BASIC, and describes SYS register save locations. Shows vectors for IRQ/BRK/NMI and OPEN/CLOSE/IO vectors around $0314-$0331.",
      "references": [
        {
          "chunk": "commodore64_memory_map_part2",
          "topic": "Continuation of C64 memory map covering ROM and device areas"
        }
      ]
    },
    {
      "start": 8538,
      "end": 8636,
      "name": "c64_memory_map_zero_page_part1",
      "description": "Commodore 64 memory map — zero page and low memory entries (addresses $0000-$00AD). Includes zero-page entries such as chip directional register ($0000), Chip I/O/memory and tape control ($0001), float-fixed vectors, BASIC internals (input buffer pointer, DIM flag, type flags, DATA scanning flags, pointers, accumulator storage, cassette buffer length, CHRGET subroutine area, RND seed, status word ST at $0090, keyboard PIA flags, tape timing constants, serial buffers, jiffy clock $00A0-$00A2) and other low memory work areas up through pointer ranges at $00AC-$00AD.",
      "references": [
        {
          "chunk": "c64_zero_page_overview",
          "topic": "overview of safe/unsafe zero-page locations"
        }
      ]
    },
    {
      "start": 8637,
      "end": 8637,
      "name": "commodore64_memory_map_part2_rom_and_vectors",
      "description": "Continues the Commodore 64 memory map: details zero-page pointer meanings ($003B-$0070 areas), accumulators, file tables, tape pointers, cassette buffer, default IRQ/BRK/NMI/USR vectors, cassette buffer region, available RAM and ROM mapping including character sets, VIC/VIA/CIA/I/O addresses (e.g., $9000-$91FF for VIC/VIA on VIC-20 mapping earlier), and notes on chip-direction registers at $0000-$0001 for 6510 bank switching.",
      "references": [
        {
          "chunk": "interrupts_intro_and_irq_vectors",
          "topic": "C64 IRQ vector location and effect on system services"
        },
        {
          "chunk": "ia_chips_overview_and_latching",
          "topic": "CIA/VIA/PIA chips control interrupts & I/O mapped in the memory map"
        }
      ]
    },
    {
      "start": 8638,
      "end": 8725,
      "name": "c64_memory_map_zero_page_part2",
      "description": "Commodore 64 memory map — continued low memory and system pointers ($00AE-$02BF). Covers tape buffer end addresses, tape timing constants, I/O start addresses, Kernal setup pointer, keyboard variables, screen pointers, RS-232 and cassette state bytes, jiffy clock, serial flags, CIA (6526) control/logging bytes on zero page ($02A1-$02A6), sprite data area ($02C0-$02FE), and other work areas through $02BF.",
      "references": [
        {
          "chunk": "c64_memory_map_zero_page_part1",
          "topic": "previous zero-page entries ($0000-$00AD)"
        },
        {
          "chunk": "c64_vic2_sprite_registers",
          "topic": "sprite registers and sprite data area (VIC-II)"
        },
        {
          "chunk": "c64_cia1_registers",
          "topic": "CIA registers (6526) referenced in zero page"
        }
      ]
    },
    {
      "start": 8726,
      "end": 8776,
      "name": "c64_memory_map_high_memory",
      "description": "Commodore 64 memory map — higher regions and ROM/IO mapping. Shows stack ($0100-$01FF), BASIC input buffer and tables ($0200-$02FF), screen memory ($0400-$07E7), BASIC RAM ($0800-$9FFF), alternative ROM/plug-in spaces ($8000-$9FFF), BASIC ROM ($A000-$BFFF), RAM ($C000-$CFFF), video chip (6566) area ($D000-$D02E), color memory ($D400-$D41C), CIA chips ($DC00-$DD0F), alternative ROM character set at $D000-$DFFF, OS ROM at $E000-$FFFF, and notes about alternatives with RAM/ROM overlays.",
      "references": [
        {
          "chunk": "c64_vic2_sprite_registers",
          "topic": "VIC-II registers located in the $D000 range"
        },
        {
          "chunk": "c64_sid_registers",
          "topic": "SID registers in $D400 range"
        }
      ]
    },
    {
      "start": 8777,
      "end": 8778,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8779,
      "end": 8831,
      "name": "c64_cia1_registers",
      "description": "Commodore 64 CIA 1 (6526) register usage ($DC00-$DC0F). Lists Port A ($DC00) and Port B ($DC01) bit meanings: paddle selects, joystick 0 bits, keyboard row select, keyboard column read, Data Direction Registers ($DC02/$DC03), Timer A/B functionality (cassette/keyboard interrupts, TOD clock), shift register (unused), interrupt control/status ($DC0D-$DC0F) and other CA/CB control bits (light pen, serial clock, PB6/PB7 outputs, one-shot modes).",
      "references": [
        {
          "chunk": "c64_cia2_registers",
          "topic": "CIA 2 registers are similar, with NMI behavior"
        }
      ]
    },
    {
      "start": 8832,
      "end": 8832,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8833,
      "end": 8889,
      "name": "c64_cia2_registers",
      "description": "Commodore 64 CIA 2 (6526) register usage ($DD00-$DD0F). Shows Port A/Port B bit usage for serial bus, RS-232, user port (DSR, CTS, DCD, RI, DTR, RTS), Data Direction Registers defaults, Timer A/B for RS-232 timing, TOD clock registers (unused on C64), shift register (unused), interrupt control/status (NMI and other bits), and CA/CB control functions (serial in/out, PB6/PB7 outputs, timer one-shots).",
      "references": [
        {
          "chunk": "c64_cia1_registers",
          "topic": "CIA1 compared (IRQ vs NMI roles)"
        }
      ]
    },
    {
      "start": 8890,
      "end": 8894,
      "ignore": true,
      "reason": "Contains a figure label and page marker (non-technical formatting) — safe to ignore."
    },
    {
      "start": 8895,
      "end": 8931,
      "name": "c64_vic2_sprite_registers",
      "description": "Commodore 64 VIC-II (6566) sprite register layout. Sprite X position bytes at $D000-$D00E (even addresses), corresponding Y positions at $D001-$D00F (odd addresses); sprite color registers at $D027-$D02E; single-bit control registers: $D010 (X-Position high bit), $D015 (sprite enable), $D017 (Y-expand), $D01B (background priority), $D01C (multicolor enable), $D01D (X-expand), $D01E (sprite collision interrupt), $D01F (sprite/background collision interrupt).",
      "references": [
        {
          "chunk": "c64_memory_map_high_memory",
          "topic": "VIC-II registers live in the $D000 video region"
        }
      ]
    },
    {
      "start": 8932,
      "end": 8935,
      "ignore": true,
      "reason": "Figure caption and page marker only; non-technical."
    },
    {
      "start": 8936,
      "end": 8988,
      "name": "c64_sid_registers",
      "description": "Commodore 64 SID (6581) register usage. Voice frequency low/high bytes: Voice1 $D400/$D401, Voice2 $D407/$D408, Voice3 $D40E/$D40F. Pulse width and high bits at $D402-$D403 etc. Waveform and control registers (Tst, Rng, Syn, On/Off, Mod) at $D404/$D40B/$D412. ADSR envelopes: Attack/Decay ($D405/$D40C/$D413), Sustain/Release ($D406/$D40D/$D414). Filter & Volume: $D415 low bits, $D416 filter freq high byte, $D417 resonance & filter voices selection, $D418 master volume/filter shape/voice3 off. Sense read-only registers: $D419 paddle X, $D41A paddle Y, $D41B voice 3 output, $D41C envelope 3.",
      "references": [
        {
          "chunk": "c64_memory_map_high_memory",
          "topic": "SID I/O region in $D400 area"
        }
      ]
    },
    {
      "start": 8989,
      "end": 8990,
      "ignore": true,
      "reason": "Figure caption / page marker between sections — non-technical."
    },
    {
      "start": 8991,
      "end": 9049,
      "name": "plus4_preliminary_overview",
      "description": "Preliminary Commodore PLUS/4 (C264) and Commodore 16 information — early memory/zero-page similarities to VIC/64, pointers and BASIC pointers mostly same, notes about possible changes before release, and a preliminary memory map summary listing selected zero-page differences and vector locations.",
      "references": [
        {
          "chunk": "plus4_ted_chip_registers",
          "topic": "TED I/O control registers at FF00-FF3F"
        }
      ]
    },
    {
      "start": 9050,
      "end": 9051,
      "ignore": true,
      "reason": "Blank/page marker lines between PLUS/4 overview and TED section — non-technical."
    },
    {
      "start": 9052,
      "end": 9128,
      "name": "plus4_ted_chip_registers",
      "description": "Preliminary mapping of the 'TED' video chip registers ($FF00-$FF3F). Includes Timer 1/2/3 low/high bytes ($FF00-$FF05), control bits at $FF06/$FF07 (ECM, BMM, Blank, Rows, X/Y adjust, PAL/RUS, Freeze, MCM, Columns), keyboard latch at $FF08, IRQ flags and IER masks at $FF09-$FF0A, RC and CUR registers, voice and sound controls, color and background matrices, ROM/RAM select ($FF3E/$FF3F) and other TED registers. Note: field boundaries approximate.",
      "references": [
        {
          "chunk": "plus4_preliminary_overview",
          "topic": "PLUS/4 memory overview and TED I/O region"
        }
      ]
    },
    {
      "start": 9129,
      "end": 9154,
      "name": "bseries_zero_page_overview",
      "description": "B-Series machines (B-128, CBM-256, etc.) zero-page guidance. Multiple zero pages exist (banked systems). For bank 15 (ROM bank) system variables are kept; free areas include $E6-$FF and work areas $20-$2B, $64-$6E. Cautions about critical zero-page locations to avoid modifying (list of addresses such as $1A, $1D-$1F, $2D-$41, etc.).",
      "references": [
        {
          "chunk": "bseries_memory_map_banks_overview",
          "topic": "Detailed B-series memory map including bank descriptions"
        }
      ]
    },
    {
      "start": 9155,
      "end": 9156,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9157,
      "end": 9183,
      "name": "bseries_memory_map_intro",
      "description": "Introduction to B-Series memory map changes for machines released after April 1983 (revised machine language monitor). Notes on CHRGOT relocation, 'split' BASIC vectors, three-byte vectors including bank number, accessible jump table, and program placement strategies (use spare 1K at $0400-$07FF or plug-in RAM/ROM in bank 15 or other banks).",
      "references": [
        {
          "chunk": "bseries_zero_page_overview",
          "topic": "zero-page details and caution areas"
        }
      ]
    },
    {
      "start": 9184,
      "end": 9185,
      "ignore": true,
      "reason": "Page break/marker between B-series memory map intro and the BASIC-address table — non-technical."
    },
    {
      "start": 9186,
      "end": 9224,
      "name": "bseries_basic_addresses_table_part1",
      "description": "B-Series memory map — overview and bank-specific entries. Lists '-All Banks' entries ($0000-$0001 6509 regs), Bank 1 BASIC program area and input buffer ($0002-F000, FA5E-FB00), B256/B128 bank comments and usage for BASIC program/arrays. This section starts the detailed bank listings and explains where BASIC program text, arrays, and other structures live across banks.",
      "references": [
        {
          "chunk": "bseries_memory_map_banks_overview",
          "topic": "full B-series memory map and vectors (continued)"
        }
      ]
    },
    {
      "start": 9225,
      "end": 9312,
      "name": "bseries_memory_map_bank15_zeropage",
      "description": "B-Series Bank 15 zero-page and low memory layout (addresses $0002-$00C7 and beyond). Contains USR jump, TI$ time elements, PRINT USING pointer, BASIC pointers (start-of-BASIC, start/end of variables/arrays), various accumulators and BASIC working storage, string pointers, function and descriptor pointers, monitor save vectors, and numerous zero-page fields for BASIC and monitor use.",
      "references": [
        {
          "chunk": "bseries_zero_page_overview",
          "topic": "explanation of using bank 15 and safe working areas"
        }
      ]
    },
    {
      "start": 9313,
      "end": 9386,
      "name": "bseries_memory_map_bank15_part2",
      "description": "Continuation of B-Series Bank 15 zero-page and vectors ($00C8-$03FF). Includes screen line pointers, keyboard tables, CHRGET/CHRGOT links, various BASIC vectors and link addresses ($0280-$0295) and temporary work areas, IRQ/BRK/NMI vectors defaults, and lists of other ROM/default vector addresses for monitor and BASIC initialization.",
      "references": [
        {
          "chunk": "bseries_memory_map_bank15_zeropage",
          "topic": "continued bank 15 zero-page and vectors"
        }
      ]
    },
    {
      "start": 9387,
      "end": 9479,
      "name": "bseries_memory_map_high_and_io",
      "description": "B-Series memory map high regions and I/O mapping: file logical address tables, file device tables, top/bottom of system/user memory pointers, IEEE vectors, open/close/load/save vectors, restart vectors, free RAM areas ($0400-$07FF reserved for DOS), plug-in RAM/ROM reservations, cartridge and ROM mappings (e.g., BASIC ROM $8000-$BFFF), video/sound/I/O device addresses (6545, 6581, 6526, 6551, 6525), and Kernal ROM ($E000-$FFFF). Table based on a B-128 example.",
      "references": [
        {
          "chunk": "bseries_memory_map_bank15_part2",
          "topic": "vector defaults and link addresses used in this map"
        },
        {
          "chunk": "bseries_6545_crtc_registers",
          "topic": "CRTC registers and typical values"
        }
      ]
    },
    {
      "start": 9480,
      "end": 9480,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9481,
      "end": 9536,
      "name": "bseries_6545_crtc_registers",
      "description": "B-Series 6545 CRT Controller (CRTC) register details ($D800-$D801 two-register interface). Lists register indices and meanings: horizontal total, horizontal displayed, horizontal sync position and widths, vertical total, vertical total adjust, vertical displayed, vertical sync position, mode, scan lines, cursor start/end, display/cursor/light-pen addresses; typical values are provided for many registers and notes about write/read permissions (most registers write-only; some read/write).",
      "references": [
        {
          "chunk": "bseries_memory_map_high_and_io",
          "topic": "screen RAM and video controller addresses"
        }
      ]
    },
    {
      "start": 9537,
      "end": 9537,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9538,
      "end": 9561,
      "name": "bseries_6525_triport1",
      "description": "B-Series Tri Port Adapter 6525 (Tri Port 1) register usage ($DE00-$DE07). Describes port bits meanings: NRFD, NDAC, EOI, DAV, ATN, RFN, Cassette sense/motor/out, network signals (ARB, Rx, Tx), SRQ, IFC, Data Direction Registers for $DE00/$DE01, IRQ/active interrupt registers and control bits, CA/CB and graphics/power/IEEE flags.",
      "references": [
        {
          "chunk": "bseries_6525_triport2",
          "topic": "second tri port adapter mapping ($DF00-$DF07)"
        }
      ]
    },
    {
      "start": 9562,
      "end": 9563,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9564,
      "end": 9581,
      "name": "bseries_6525_triport2",
      "description": "B-Series Tri Port Adapter 6525 (Tri Port 2) register usage ($DF00-$DF07). Mappings include keyboard matrix input ($DF00), select lines ($DF01), CRT mode and keyboard read controls ($DF02), and corresponding data direction registers ($DF03-$DF05), with notes on unused registers.",
      "references": [
        {
          "chunk": "bseries_6525_triport1",
          "topic": "other tri port mapping and interrupt registers"
        }
      ]
    },
    {
      "start": 9582,
      "end": 9583,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 9584,
      "end": 9605,
      "name": "c64_rom_detail_intro",
      "description": "Commodore 64 ROM detail introduction. Explains purpose of ROM memory map for disassembly and understanding built-in subroutines, cautioning against relying on ROM subroutines for production code because they change between machines; recommends using kernal jump table ($FFD2, $FFE4, $FFE1, $FFC6, $FFC9, $FFCC) instead. References 'Mapping the Commodore 64' for deeper study.",
      "references": [
        {
          "chunk": "c64_rom_vectors_a000_to_ba80",
          "topic": "list of ROM routine addresses and brief descriptions"
        }
      ]
    },
    {
      "start": 9606,
      "end": 9607,
      "ignore": true,
      "reason": "Page marker between ROM detail intro and ROM vectors section — non-technical."
    },
    {
      "start": 9608,
      "end": 9653,
      "name": "c64_rom_vectors_a000_to_aa80",
      "description": "Commodore 64 ROM routine table (addresses and brief descriptions). Entries from A000 (ROM control vectors) through AA80 (Perform PRINT#) including keyword action vectors, function and operator vectors, many BASIC routines (scan stack, move memory, check stack depth, handling new line, print messages, token crunching, line re-chain, input handling, FOR/GOSUB/RETURN mechanisms, and various BASIC operation handlers).",
      "references": [
        {
          "chunk": "c64_rom_vectors_aa86_to_bafe",
          "topic": "continuation of ROM routine listings"
        }
      ]
    },
    {
      "start": 9654,
      "end": 9655,
      "ignore": true,
      "reason": "Page marker between two ROM-vector listings — non-technical."
    },
    {
      "start": 9656,
      "end": 9744,
      "name": "c64_rom_vectors_aa86_to_bafe",
      "description": "Continuation of Commodore 64 ROM routine table (AA86 through BAFE/BBA2 etc). Includes Perform CMD/PRINT, input routines, FLOAT/FIXED conversions, arithmetic/array/string routines, garbage collection, string handling, math functions, and floating-point/math helpers including multiply and divide subroutines and other numeric operations.",
      "references": [
        {
          "chunk": "c64_rom_vectors_bb.._to_e..",
          "topic": "later ROM routines continuing through Exxx"
        }
      ]
    },
    {
      "start": 9745,
      "end": 9790,
      "name": "c64_rom_vectors_bba2_to_e0f9",
      "description": "Further ROM routines (BBA2 through E0F9). Contains FAC (floating accumulator) memory routines, floating/integer conversions, advanced math and transcendental function routines (LOG, SQR, EXP, RND), compare and series evaluation routines, and references to ROM float/series evaluation address ranges and helpers.",
      "references": [
        {
          "chunk": "c64_rom_vectors_e12a_to_f04d",
          "topic": "Kernal and I/O related ROM routines and vectors"
        }
      ]
    },
    {
      "start": 9791,
      "end": 9859,
      "name": "c64_rom_vectors_e12a_to_efcd",
      "description": "ROM routines list from E12A through EFCD. Covers SYS, SAVE/VERIFY/LOAD handling, file open/close parameters, math trig evaluations (COS, SIN, TAN, ATN), warm restart and initialization routines (E394, E3BF), CHRGET for zero page, vectors initialization, screen I/O, serial bus routines and many serial/RS-232 helper functions (send/receive transitions, timing, error handling).",
      "references": [
        {
          "chunk": "c64_rom_vectors_efe1_to_fffa",
          "topic": "remaining Kernal and IRQ/NMI/serial handlers up to hardware vectors"
        }
      ]
    },
    {
      "start": 9860,
      "end": 9928,
      "name": "c64_rom_vectors_efe1_to_f04d",
      "description": "ROM/Kernal routines covering EFxx and F0xx ranges (EFxx to F04D). Includes RS-232/serial send/receive, parity/error handling, timer/bit-count helpers, serial clock control, routines for serial bus 'talk'/'listen' messaging, and serial input/output controls. Also includes references to later file and tape handling routines.",
      "references": [
        {
          "chunk": "c64_rom_vectors_f157_to_fffa",
          "topic": "I/O, tape and file routines, IRQ/NMI management and hardware vectors"
        }
      ]
    },
    {
      "start": 9929,
      "end": 9970,
      "name": "c64_rom_vectors_fb97_to_fffa",
      "description": "End of ROM routine listing and Kernal vectors (FB97 through FFFA). Includes tape operations (new character setup, write to tape), IRQ/BRK/interrupt entry points, power/reset entry points, vector initialization (FDxx), enable timer, file details save, and concluding hardware/jumbo jump tables and hardware vectors (FFFA etc).",
      "references": [
        {
          "chunk": "appendix_d_superchart_and_petscii",
          "topic": "Appendix D PET character sets follow the Kernal listing"
        }
      ]
    },
    {
      "start": 9971,
      "end": 9975,
      "ignore": true,
      "reason": "Page-break and non-content lines before Appendix D — ignore."
    },
    {
      "start": 9976,
      "end": 9984,
      "ignore": true,
      "reason": "Appendix D title and section header (non-technical document division)"
    },
    {
      "start": 9985,
      "end": 10009,
      "name": "appendix_d_superchart_intro",
      "description": "Appendix D introduction: 'Superchart' overview for PET character sets (PETSCII). Explains columns: ASCII (PET ASCII characters), Screen (Commodore screen codes as used in screen memory), BASIC (codes used inside BASIC programs), and 6502 opcodes included for convenience. Notes on uppercase/graphics sets, lowercase mapping, and mention of graphical chart availability.",
      "references": [
        {
          "chunk": "appendix_d_petscii_table",
          "topic": "full PETSCII and code mapping table"
        }
      ]
    },
    {
      "start": 10010,
      "end": 10010,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 10011,
      "end": 10043,
      "name": "petscii_table_codes_0_29",
      "description": "PETSCII / Superchart mapping for codes DEC 0–29 (HEX 00–1D). Shows columns: Decimal, Hex, ASCII, SCREEN glyphs, BASIC token where applicable, and suggested 6502 instruction mnemonics. Includes control characters like BRK (end-line), bell, lock/unlock, cursor controls and early 6502 opcodes for low codes.",
      "references": [
        {
          "chunk": "petscii_table_codes_30_78",
          "topic": "continues the PETSCII mapping for codes 30–78"
        }
      ]
    },
    {
      "start": 10044,
      "end": 10097,
      "name": "petscii_table_codes_30_78",
      "description": "PETSCII / Superchart mapping for codes DEC 30–78 (HEX 1E–4E). Contains printable characters (space, punctuation, digits), screen glyph variations, BASIC tokens, and corresponding 6502 opcodes (JSR, AND, BIT, ROL, PLP, etc.) for many codes.",
      "references": [
        {
          "chunk": "petscii_table_codes_0_29",
          "topic": "previous block covering codes 0–29"
        },
        {
          "chunk": "petscii_table_codes_79_127",
          "topic": "continues the mapping for codes 79–127"
        }
      ]
    },
    {
      "start": 10098,
      "end": 10151,
      "name": "petscii_table_codes_79_127",
      "description": "PETSCII / Superchart mapping for codes DEC 79–127 (HEX 4F–7F). Shows uppercase/lowercase letters with screen mode variants, BASIC token mappings and many associated 6502 instructions (JMP, PHA, ADC/ADC variants, RTS, SEI/CLI, etc.).",
      "references": [
        {
          "chunk": "petscii_table_codes_30_78",
          "topic": "previous block covering codes 30–78"
        },
        {
          "chunk": "petscii_table_codes_128_176",
          "topic": "continues with extended PETSCII codes 128–176"
        }
      ]
    },
    {
      "start": 10152,
      "end": 10205,
      "name": "petscii_table_codes_128_176",
      "description": "PETSCII / Superchart mapping for codes DEC 128–176 (HEX 80–B0). Covers the PETSCII 'upper' range used for BASIC keywords and color/graphics control tokens (END, FOR, NEXT, INPUT, RUN, SYS, etc.), screen-mode glyphs, and many 6502 mnemonics (STA, STY, TXA, TAY, LDY/LDA/LDX #imm, BCC).",
      "references": [
        {
          "chunk": "petscii_table_codes_79_127",
          "topic": "previous block covering codes 79–127"
        },
        {
          "chunk": "petscii_table_codes_177_225",
          "topic": "continues with PETSCII codes 177–225"
        }
      ]
    },
    {
      "start": 10206,
      "end": 10259,
      "name": "petscii_table_codes_177_225",
      "description": "PETSCII / Superchart mapping for codes DEC 177–225 (HEX B1–E1). Contains more BASIC keyword tokens and function names mapped to character codes (>, =, <, SGN, INT, ABS, FRE, POS, etc.), screen representations, and 6502 operations for those byte values (LDA/LDX/LDY variants, TSX, CLV, CPY/CMP instructions).",
      "references": [
        {
          "chunk": "petscii_table_codes_128_176",
          "topic": "previous block covering codes 128–176"
        },
        {
          "chunk": "petscii_table_codes_226_255",
          "topic": "continues with PETSCII codes 226–255"
        }
      ]
    },
    {
      "start": 10260,
      "end": 10293,
      "name": "petscii_table_codes_226_255",
      "description": "PETSCII / Superchart mapping for codes DEC 226–255 (HEX E2–FF). Final portion of the table: includes CPX/SBC/INC/INX/NOP/SED/BEQ and other 6502 opcodes aligned with byte values, plus remaining screen/BASIC token mappings and special glyphs (including pi symbol occurrences and unused/reserved PETSCII values).",
      "references": [
        {
          "chunk": "petscii_table_codes_177_225",
          "topic": "previous block covering codes 177–225"
        }
      ]
    },
    {
      "start": 10294,
      "end": 10296,
      "ignore": true,
      "reason": "Page marker between PETSCII table and ASCII explanation — non-technical."
    },
    {
      "start": 10297,
      "end": 10333,
      "name": "appendix_d_ascii_explanation",
      "description": "Explanation of ASCII vs Commodore PET ASCII differences. Describes how PET graphics and text modes map to ASCII: numeric and punctuation largely match, but Commodore upper case letters map to PET lower case in text mode, etc. Gives rules for converting Commodore PETSCII to ASCII for transmission: (1) if < $3F transmit directly; (2) if between $40 and $5F OR with $20; (3) if between $C0 and $DF AND with $7F. Notes that equivalent rules exist for receiving from ASCII.",
      "references": [
        {
          "chunk": "appendix_d_petscii_table",
          "topic": "full PETSCII mapping table for reference"
        }
      ]
    },
    {
      "start": 10334,
      "end": 10335,
      "ignore": true,
      "reason": "Page marker between ASCII explanation and hex-digit chart — non-technical."
    },
    {
      "start": 10336,
      "end": 10373,
      "name": "first_hex_digit_chart",
      "description": "Visual aid 'First Hexadecimal Digit' chart showing ASCII characters arranged by the high hex nibble (0-F) to help interpret PETSCII/ASCII code layouts. The table shows dec/hex mapping to characters across columns for quick lookup.",
      "references": []
    },
    {
      "start": 10374,
      "end": 10375,
      "ignore": true,
      "reason": "Page marker between hex-digit chart and control-character section — non-technical."
    },
    {
      "start": 10376,
      "end": 10399,
      "name": "control_character_representations",
      "description": "List of control character names and short descriptions (NUL, SOH, STX, ETX, EOT, ENQ, ACK, BEL, BS, HT, LF, VT, FF, CR, SO, SI, SUB, ESC, etc.) with notes indicating use categories: (CC) Communication Control, (FE) Format Effector, (IS) Information Separator.",
      "references": [
        {
          "chunk": "appendix_d_petscii_table",
          "topic": "control characters as they appear in the PETSCII table"
        }
      ]
    },
    {
      "start": 10400,
      "end": 10402,
      "ignore": true,
      "reason": "Figure D.1 caption only — non-technical."
    },
    {
      "start": 10403,
      "end": 10434,
      "name": "special_graphic_characters",
      "description": "List of special graphic characters in PETSCII with common ASCII equivalents: space, punctuation, brackets, slashes, arithmetic symbols, braces, tilde, and notes that '->' marks characters that correspond to PET ASCII set.",
      "references": []
    },
    {
      "start": 10435,
      "end": 10493,
      "name": "exercise_ch6_vic20_unexpanded",
      "description": "Appendix E, From Chapter 6 — VIC-20 (Unexpanded) exercise. BASIC program to input 5 values and call a machine language routine via SYS to multiply by ten. Shows BASIC lines 100-150 and the machine language assembly intended to start at $1080 (decimal 4224), including LDA/STA using indirect addressing, shifts (ASL/ROL), ADC/CLC, and final RTS. Instructions on changing the start-of-variables pointer for placement above the machine code are also included.",
      "references": [
        {
          "chunk": "vic20_exercise_change_sov",
          "topic": "how to change SOV pointer so variables sit above ML program"
        }
      ]
    },
    {
      "start": 10494,
      "end": 10496,
      "ignore": true,
      "reason": "Page marker between exercise and the next exercise subsection — non-technical."
    },
    {
      "start": 10497,
      "end": 10502,
      "name": "vic20_exercise_change_sov",
      "description": "Instruction snippet showing how to change the Start-Of-Variables pointer on VIC-20: display SOV with '.M 002D 002E' and change the pointer bytes; example shows editing to place pointer above the machine language program (hex C8 10 ...).",
      "references": [
        {
          "chunk": "exercise_ch6_vic20_unexpanded",
          "topic": "VIC-20 exercise that requires moving SOV"
        }
      ]
    },
    {
      "start": 10503,
      "end": 10503,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 10504,
      "end": 10550,
      "name": "exercise_ch6_pet_cbm_version",
      "description": "Appendix E, From Chapter 6 — PET/CBM version of the 'times ten' exercise. BASIC program similar to VIC-20, with machine language target at $0480 (decimal 1152). Provides the assembly listing for the PET/CBM variant (LDA ($2A),Y style indirect loads, storing to $033C/$033D/$033E/$033F, shifts and rotates, ADC/CLC, storing back via indirect addressing, and RTS), and instructions to change the SOV pointer (.M 002A 002B and example bytes).",
      "references": [
        {
          "chunk": "pet_cbm_change_sov",
          "topic": "how to change SOV pointer on PET/CBM"
        }
      ]
    },
    {
      "start": 10551,
      "end": 10556,
      "name": "pet_cbm_change_sov",
      "description": "PET/CBM example to change start-of-variables pointer: display SOV pointer with '.M 002A 002B' and change pointer bytes (example '.:002D C8 04 .. .. .. .. .. ..').",
      "references": [
        {
          "chunk": "exercise_ch6_pet_cbm_version",
          "topic": "PET/CBM 'times ten' example that may require moving SOV"
        }
      ]
    },
    {
      "start": 10557,
      "end": 10557,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 10558,
      "end": 10604,
      "name": "exercise_ch7_interrupt_vic20",
      "description": "Appendix E, From Chapter 7 — An Interrupt Project (VIC-20 unexpanded). Provides a small interrupt demonstration: assembly to load a byte from $0091 (keyboard/IO), store it to screen position $1E00, and jump to an IRQ link at $03A0. Shows how to place the link address into $03A0/1 by reading $0314/0315 and storing into $03A0/1, and the 'fire up' sequence to install the new vector (SEI, set $0314/$0315 to new vector, CLI) with an RTS. Also shows how to restore original interrupt vector (read $03A0/1 and restore to $0314/0315). Notes SYS 836 to enable, SYS 861 to turn off; warns about white-on-white display possibility.",
      "references": [
        {
          "chunk": "exercise_ch7_interrupt_pet",
          "topic": "PET/CBM variant of the interrupt project"
        }
      ]
    },
    {
      "start": 10605,
      "end": 10646,
      "name": "exercise_ch7_interrupt_pet",
      "description": "Appendix E, From Chapter 7 — An Interrupt Project (PET/CBM variant). Similar interrupt demo adapted for PET/CBM: stores a byte from $009B to $8000, sets up $03A0 with current IRQ link ($0090/$0091), shows firing up the program by writing new vector bytes to $0090/$0091 and enabling interrupts (SEI, LDA #$3C -> STA $0090, LDA #$03 -> STA $0091, CLI), and how to restore original vectors. Notes SYS 836 to invoke, SYS 861 to turn off; no color on PET so characters always visible.",
      "references": [
        {
          "chunk": "exercise_ch7_interrupt_vic20",
          "topic": "VIC-20 interrupt project for comparison"
        }
      ]
    },
    {
      "start": 10647,
      "end": 10662,
      "name": "project_adding_command_petcbm",
      "description": "Appendix E Project: Adding a Command — PET/CBM notes. Explains that adding a BASIC command on PET/CBM is nontrivial: no neat link at $0308/9; would require overwriting part of the CHRGET routine ($0070-$0087), supplying replacement code, then inserting the new features. The book omits the full PET/CBM equivalent implementation.",
      "references": []
    },
    {
      "start": 10663,
      "end": 10666,
      "ignore": true,
      "reason": "Page markers/appendix header transition into Appendix F — non-technical."
    },
    {
      "start": 10667,
      "end": 10721,
      "name": "floating_point_representation",
      "description": "Appendix F: Commodore floating-point representation. Packed format: 5 bytes (Exponent byte eeeeeeee, followed by 4-byte mantissa smmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm — high bit of mantissa represents sign in packed representation). Unpacked format: 6 bytes (Exponent, then 1mmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm, and a sign byte sxxxxxxx with sign in high-order bit only). Rules: exponent 0 means value 0; exponent > $80 means integer part with decimal point set to the right; exponent <= $80 means fraction < 1. Example: represent +27 (exponent $85, mantissa $D8 00 00 00) and packed as 85 D8 00 00 00.",
      "references": []
    },
    {
      "start": 10722,
      "end": 10724,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 10725,
      "end": 10753,
      "name": "uncrashing_overview",
      "description": "Appendix G introduction: 'Uncrashing'. Discusses debugging with BRK instruction breakpoints and outlines 'uncrashing' as a last-resort recovery technique for when programs crash and unsaved work would otherwise be lost. Notes behavior varies by machine and the approach depends on available hardware/monitor features.",
      "references": [
        {
          "chunk": "pet_cbm_uncrashing",
          "topic": "PET/CBM uncrash procedure using diagnostic sense switch and reset pushbutton"
        },
        {
          "chunk": "vic64_uncrashing",
          "topic": "VIC/Commodore 64 uncrash tips using RUN/STOP + RESTORE or reset switch"
        }
      ]
    },
    {
      "start": 10754,
      "end": 10783,
      "name": "pet_cbm_uncrashing",
      "description": "PET/CBM uncrashing procedure for later models: requires hardware additions (toggle switch from PUP diagnostic sense pin 5 to ground, and a momentary reset pushbutton to ground the reset line). Toggle ON and press pushbutton to return to machine language monitor; then exit to BASIC (.X) and issue CLR or use '.;' followed by RETURN. Warns original ROM PETs cannot be uncrashed and recommends seeking hardware-savvy assistance for modifications.",
      "references": [
        {
          "chunk": "uncrashing_overview",
          "topic": "general uncrashing strategies"
        }
      ]
    },
    {
      "start": 10784,
      "end": 10800,
      "name": "vic64_uncrashing",
      "description": "VIC/Commodore 64 uncrash notes: try holding RUN/STOP and tapping RESTORE; otherwise use a reset switch (available on some cartridge-motherboard accessories) to perform nondestructive reset (memory preserved). If monitor entry location is known, use appropriate SYS to recover monitor. Emphasizes nondestructive memory test on reset.",
      "references": [
        {
          "chunk": "uncrashing_overview",
          "topic": "general uncrashing strategies"
        }
      ]
    },
    {
      "start": 10801,
      "end": 10802,
      "ignore": true,
      "reason": "Page marker between VIC/64 uncrashing and PLUS/4 uncrashing — non-technical."
    },
    {
      "start": 10803,
      "end": 10808,
      "name": "plus4_uncrashing",
      "description": "Commodore PLUS/4 uncrash tip: press RESET next to power switch while holding RUN/STOP and CTRL to enter machine language monitor.",
      "references": [
        {
          "chunk": "uncrashing_overview",
          "topic": "machine-specific uncrash methods"
        }
      ]
    },
    {
      "start": 10809,
      "end": 10814,
      "ignore": true,
      "reason": "Page markers and blank lines before Appendix H — non-technical."
    },
    {
      "start": 10815,
      "end": 10863,
      "name": "supermon_instructions",
      "description": "Appendix H: Supermon instructions overview. Supermon is a monitor generator that locates a good spot in memory and writes a machine language monitor (MLM). Lists essential commands (.R registers, .M memory, .S save, .L load, .G go, .X exit) and extras (.A assemble, .D disassemble). Additional commands in many versions: .F fill memory, .H hunt for pattern, .T transfer a block. Notes some versions include single-step '.I'.",
      "references": []
    },
    {
      "start": 10864,
      "end": 10869,
      "name": "do_it_yourself_supermon_note",
      "description": "Note indicating the book omits a 'Do-It-Yourself' Supermon raw monitor listing (6 pages of raw bytes) and suggests obtaining monitors from internet sources instead.",
      "references": [
        {
          "chunk": "supermon_instructions",
          "topic": "Supermon usage and commands"
        }
      ]
    },
    {
      "start": 10870,
      "end": 10880,
      "ignore": true,
      "reason": "Multiple page markers between the DIY Supermon note and Appendix I — non-technical."
    },
    {
      "start": 10881,
      "end": 10905,
      "name": "appendix_i_overview",
      "description": "Appendix I: IA (Interface Adapter) Chip Information overview. Lists chips covered (6520 PIA, 6522 VIA, 6525 TPA, 6526 CIA, 6545 CRTC, 6560 VIC, 6566 VIC-II, 6581 SID) and notes material adapted from manufacturer specs; emphasizes this info is informative and not essential for basic machine language programming.",
      "references": [
        {
          "chunk": "6520_pia_overview",
          "topic": "first detailed chip covered: 6520 PIA"
        }
      ]
    },
    {
      "start": 10906,
      "end": 10918,
      "name": "6520_pia_overview",
      "description": "6520 Peripheral Interface Adapter (PIA) overview. Describes PIA as an I/O device that interfaces the microprocessor to peripherals via two 8-bit bi-directional data ports, an 8-bit microprocessor data bus, four interrupt/control lines, and logic for peripheral interrupts. Explains the PIA is programmed during system initialization and provides flexible peripheral control.",
      "references": [
        {
          "chunk": "6520_pia_block_diagram",
          "topic": "block diagram showing data bus, control and peripheral ports"
        }
      ]
    },
    {
      "start": 10919,
      "end": 10919,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 10920,
      "end": 10950,
      "name": "6520_pia_block_diagram",
      "description": "Block diagram and figure (I.1) illustrating the 6520 PIA functional configuration: connection between microprocessor data bus/control lines and the two 8-bit peripheral data ports and control logic. Shows conceptual data/control flow between processor and peripheral devices via PIA.",
      "references": [
        {
          "chunk": "6520_pia_overview",
          "topic": "PIA explanation and functions"
        }
      ]
    },
    {
      "start": 10951,
      "end": 10960,
      "name": "6520_data_input_register",
      "description": "6520 Data Input Register behavior: when the CPU writes data to the PIA, the data on the bus is latched into the Data Input Register and transferred into internal registers to ensure glitch-free transitions on peripheral output lines; this makes transitions smooth and maintains stable voltages on outputs except when changing state.",
      "references": []
    },
    {
      "start": 10961,
      "end": 10962,
      "ignore": true,
      "reason": "Page marker between 6520 data input description and control registers section — non-technical."
    },
    {
      "start": 10963,
      "end": 10999,
      "name": "6520_control_registers",
      "description": "6520 Control Registers (CRA and CRB) summary and bit layout (Figure I.2). Control registers manage interrupt lines CA1/CA2/CB1/CB2 and peripheral control lines, select access to Data Direction Registers (DDRA, DDRB) and Output Registers (ORA, ORB), and include interrupt status bits (/IRQA, /IRQB) in bits 6/7 used by the CPU to determine source of interrupts. Describes typical use and frequent access during operation.",
      "references": [
        {
          "chunk": "6520_ddr",
          "topic": "Data Direction Registers referenced by CRA/CRB"
        },
        {
          "chunk": "control_of_irqa",
          "topic": "how CRA bits affect /IRQA"
        }
      ]
    },
    {
      "start": 11000,
      "end": 11015,
      "name": "6520_ddr",
      "description": "6520 Data Direction Registers (DDRA, DDRB). Each bit programs the corresponding Peripheral I/O port line as input (0) or output (1). Typically programmed during system initialization (Reset) but can be changed during operation to support devices like keyboards.",
      "references": [
        {
          "chunk": "6520_output_registers",
          "topic": "Peripheral Output Registers depend on DDR settings"
        }
      ]
    },
    {
      "start": 11016,
      "end": 11016,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11017,
      "end": 11026,
      "name": "6520_output_registers",
      "description": "6520 Peripheral Output Registers (ORA, ORB). Store output data for the Peripheral I/O port. Writing a 0 drives the corresponding line low (if configured as output), writing a 1 drives it high. ORA controls Peripheral A port lines; ORB controls Peripheral B port lines.",
      "references": []
    },
    {
      "start": 11027,
      "end": 11028,
      "ignore": true,
      "reason": "Page marker between output registers and interrupt-status/control section — non-technical."
    },
    {
      "start": 11029,
      "end": 11036,
      "name": "6520_interrupt_status_control",
      "description": "Interrupt Status Control: logic that interprets Control Register contents, detects active transitions on CA1/CA2/CB1/CB2 inputs, sets interrupt flags accordingly and performs actions needed for peripheral interrupt control.",
      "references": [
        {
          "chunk": "control_of_irqa",
          "topic": "details for CA1/CA2 control bits and interaction with /IRQA"
        },
        {
          "chunk": "control_of_irqb",
          "topic": "details for CB1/CB2 control bits and interaction with /IRQB"
        }
      ]
    },
    {
      "start": 11037,
      "end": 11038,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11039,
      "end": 11046,
      "name": "6520_reset",
      "description": "6520 Reset (/RES) behaviour: active low Reset clears all 6520 registers to logic zero; can be used as power-on reset or master reset during operation.",
      "references": []
    },
    {
      "start": 11047,
      "end": 11064,
      "name": "6520_interrupt_request_line",
      "description": "6520 Interrupt Request Lines (/IRQA, /IRQB): active low lines that interrupt the microprocessor. Each request line has two interrupt flag bits (bits 6 and 7 in CRA/CRB) that can cause the request line to go low; these flags can be masked/disabled by corresponding control bits to allow the CPU to enable/disable interrupts from each CA/CB input.",
      "references": [
        {
          "chunk": "6520_control_registers",
          "topic": "CRA/CRB bits layout and how flags are stored"
        }
      ]
    },
    {
      "start": 11065,
      "end": 11066,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11067,
      "end": 11080,
      "name": "control_of_irqa",
      "description": "Control of /IRQA specifics: CRA bit 7 is set by an active CA1 transition, and interrupting from this flag is disabled by CRA bit 0 being 0. CRA bit 6 is set by CA2 active transition and controlled by CRA bit 3. Both bits 6 and 7 are reset by a 'Read Peripheral Output Register A' operation (reading Port A).",
      "references": [
        {
          "chunk": "6520_interrupt_request_line",
          "topic": "how ISO flags map to /IRQA line"
        }
      ]
    },
    {
      "start": 11081,
      "end": 11082,
      "ignore": true,
      "reason": "Page marker between IRQA control discussion and IRQB control section — non-technical."
    },
    {
      "start": 11083,
      "end": 11093,
      "name": "control_of_irqb",
      "description": "Control of /IRQB specifics: mirrors /IRQA control. CRB bit 7 set by CB1 active transition; interrupting controlled by CRB bit 0. CRB bit 6 set by CB2 active transition; interrupting controlled by CRB bit 3. Bits 6/7 in CRB are reset by 'Read Peripheral B Output Register' operation.",
      "references": [
        {
          "chunk": "6520_control_registers",
          "topic": "CRB bits usage analogous to CRA"
        }
      ]
    },
    {
      "start": 11094,
      "end": 11095,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11096,
      "end": 11107,
      "name": "6520_interrupt_summary",
      "description": "Summary of interrupt conditions: /IRQA goes low when (CRA-7=1 and CRA-0=1) OR (CRA-6=1 and CRA-3=1). /IRQB goes low when (CRB-7=1 and CRB-0=1) OR (CRB-6=1 and CRB-3=1). Emphasizes flags link peripheral signals to processor interrupts and interrupt disable bits allow CPU control.",
      "references": []
    },
    {
      "start": 11108,
      "end": 11116,
      "name": "6520_peripheral_io_ports",
      "description": "6520 Peripheral I/O Ports operation: each peripheral I/O line programmable as input or output via DDR bits; '1' means output, '0' means input. Typically set during reset but can be changed dynamically for device control.",
      "references": []
    },
    {
      "start": 11117,
      "end": 11117,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11118,
      "end": 11124,
      "name": "6520_interrupt_input_lines_intro",
      "description": "Intro to 6520 interrupt input/peripheral control lines (CA1, CA2, CB1, CB2). These lines provide special control functions and enhance the two general-purpose I/O ports (PA0-PA7/PB0-PB7).",
      "references": [
        {
          "chunk": "6520_peripheral_a_ca1_ca2",
          "topic": "detailed behavior of CA1 and CA2"
        },
        {
          "chunk": "6520_peripheral_b_cb1_cb2",
          "topic": "detailed behavior of CB1 and CB2"
        }
      ]
    },
    {
      "start": 11125,
      "end": 11125,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11126,
      "end": 11170,
      "name": "6520_peripheral_a_ca1_ca2",
      "description": "6520 Peripheral A control lines CA1 and CA2. CA1 is input-only and sets CRA bit 7 on active transition (polarity selected via CRA bit 1). CA2 can be input interrupt or peripheral control output: as input (CRA bit 5=0) it sets CRA bit 6 on selected active transition; as output CA2 can be a pulse generated when the processor reads Port A (configured via CRA bits) or act as handshake signal together with CA1 for controlled data transfers, or be used as a simple output set by CRA bits.",
      "references": [
        {
          "chunk": "control_of_irqa",
          "topic": "CRA bit interactions and how reads clear flags"
        }
      ]
    },
    {
      "start": 11171,
      "end": 11171,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11172,
      "end": 11181,
      "name": "6520_peripheral_b_cb1_cb2",
      "description": "6520 Peripheral B control lines CB1 and CB2. CB1 operates as interrupt input like CA1 (sets CRB bit 7 on selected active transition). CB2 input mode mirrors CA2 input mode; CB2 output modes behave differently: CB2 pulse output occurs when processor writes to Peripheral B Output Register and 'handshaking' operates on transfers from CPU to peripheral.",
      "references": [
        {
          "chunk": "control_of_irqb",
          "topic": "CRB bit usage for CB interrupts"
        }
      ]
    },
    {
      "start": 11182,
      "end": 11184,
      "ignore": true,
      "reason": "Page marker between 6520 peripheral I/O discussion and 6545 CRTC section — non-technical."
    },
    {
      "start": 11185,
      "end": 11231,
      "name": "6545_crtc_concept_and_register_map",
      "description": "6545-1 CRT Controller (CRTC) concept and register map overview. The 6545-1 interfaces the 650x family to raster CRT displays. Presents register index map R0-R17 with names and stored info (e.g., R0 Horizontal Total, R1 Horizontal Displayed, R2 Horizontal Sync Position, R3 VSYNC/HSYNC widths, R4 Vertical Total, R5 Vertical Total Adjust, R6 Vertical Displayed, R7 Vertical Sync Position, R8 Mode Control, R9 Scan Line, R10 Cursor Start, R11 Cursor End, R12/R13 Display Start Address high/low, R14/R15 Cursor Position, R16/R17 Light Pen registers) and notes on R/W capabilities.",
      "references": [
        {
          "chunk": "bseries_6545_crtc_registers",
          "topic": "typical register values for the B-series 6545 mapping"
        }
      ]
    },
    {
      "start": 11232,
      "end": 11238,
      "name": "crtc_horizontal_total",
      "description": "CRTC Register R0: Horizontal Total — an 8-bit register containing the total number of displayed and non-displayed character times per horizontal line minus one. It determines HSYNC frequency.",
      "references": [
        {
          "chunk": "6545_crtc_concept_and_register_map",
          "topic": "full list of CRTC registers and indexes"
        }
      ]
    },
    {
      "start": 11239,
      "end": 11239,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11240,
      "end": 11245,
      "name": "crtc_horizontal_displayed",
      "description": "CRTC Register R1: Horizontal Displayed — 8-bit register specifying number of displayed character positions per horizontal line.",
      "references": [
        {
          "chunk": "crtc_horizontal_total",
          "topic": "horizontal total vs displayed relationship"
        }
      ]
    },
    {
      "start": 11246,
      "end": 11246,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11247,
      "end": 11253,
      "name": "crtc_horizontal_sync_position",
      "description": "CRTC Register R2: Horizontal Sync Position — 8-bit register giving the HSYNC position in character location numbers along the horizontal line, affecting left/right positioning (side margins) of displayed text.",
      "references": []
    },
    {
      "start": 11254,
      "end": 11256,
      "ignore": true,
      "reason": "Page marker between horizontal sync position and HV sync widths — non-technical."
    },
    {
      "start": 11257,
      "end": 11283,
      "name": "crtc_hv_sync_widths",
      "description": "CRTC Register R3: VSYNC and HSYNC widths. R3's bits control VSYNC width (bits 7-4) and HSYNC width (bits 3-0) expressed in scan lines and character clock times respectively. If bits 4-7 are all zero, VSYNC defaults to 16 scan lines. Provides timing flexibility to match various CRT monitors without external one-shots.",
      "references": [
        {
          "chunk": "6545_crtc_concept_and_register_map",
          "topic": "R3 bit positions and overall register map"
        }
      ]
    },
    {
      "start": 11284,
      "end": 11292,
      "name": "crtc_vertical_total",
      "description": "CRTC Register R4: Vertical Total — 7-bit register containing total number of character rows in a frame minus one. Combined with R5 this determines frame rate and vertical timing.",
      "references": []
    },
    {
      "start": 11293,
      "end": 11294,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11295,
      "end": 11301,
      "name": "crtc_vertical_total_adjust",
      "description": "CRTC Register R5: Vertical Total Adjust — 5-bit write-only register for fine adjustment of the number of additional scan lines needed to complete a frame, used to fine-tune frame time.",
      "references": []
    },
    {
      "start": 11302,
      "end": 11302,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11303,
      "end": 11308,
      "name": "crtc_vertical_displayed",
      "description": "CRTC Register R6: Vertical Displayed — 7-bit register specifying number of displayed character rows per frame (vertical size of displayed text).",
      "references": []
    },
    {
      "start": 11309,
      "end": 11311,
      "ignore": true,
      "reason": "Blank/page markers around vertical-display vs vertical-sync sections — non-technical."
    },
    {
      "start": 11312,
      "end": 11317,
      "name": "crtc_vertical_sync_position",
      "description": "CRTC Register R7: Vertical Sync Position — 7-bit register selecting the character row at which VSYNC pulse is generated, used to vertically position displayed text.",
      "references": []
    },
    {
      "start": 11318,
      "end": 11319,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11320,
      "end": 11361,
      "name": "crtc_mode_control",
      "description": "CRTC Register R8: Mode Control — bits select interface mode (interlacing), video display RAM addressing mode (binary or row/column addressing), display enable skew (delay display enable by one character time), cursor skew (delay cursor by one character time), and other mode bits. Bit pair 1:0 select interface non-interlace/interlace; bit for RAM addressing when '1' selects row/column; several bits must be set to proper values (some bits unused).",
      "references": [
        {
          "chunk": "6545_crtc_concept_and_register_map",
          "topic": "R8's placement among CRTC registers"
        }
      ]
    },
    {
      "start": 11362,
      "end": 11363,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11364,
      "end": 11369,
      "name": "crtc_scan_line",
      "description": "CRTC Register R9: Scan Line — 5-bit register specifying the number of scan lines per character row including spacing.",
      "references": []
    },
    {
      "start": 11370,
      "end": 11371,
      "ignore": true,
      "reason": "Page marker between scan-line and cursor start/end sections — non-technical."
    },
    {
      "start": 11372,
      "end": 11394,
      "name": "crtc_cursor_start_end",
      "description": "CRTC Registers R10 (Cursor Start) and R11 (Cursor End) — 5-bit registers to select starting and ending scan lines for the cursor. Bits 6 and 5 of R10 select cursor mode (no blinking, no cursor, blink at 1/16 field rate, blink at 1/32 field rate). R14/R15 control the cursor character position over the address field.",
      "references": [
        {
          "chunk": "crtc_mode_control",
          "topic": "cursor skew bit interaction with R10/R11"
        }
      ]
    },
    {
      "start": 11395,
      "end": 11395,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 11396,
      "end": 11400,
      "name": "crtc_display_start_address",
      "description": "CRTC Registers R12 (Display Start Address High) and R13 (Display Start Address Low) — together form a 14-bit address pointing to the first character of the displayed scan (the character at the upper-left of the display). Note: this section continues beyond line 11400 in the source; this chunk captures the start of the explanation.",
      "references": [
        {
          "chunk": "6545_crtc_concept_and_register_map",
          "topic": "R12/R13 as part of the CRTC register set"
        }
      ]
    },
    {
      "start": 11401,
      "end": 14000,
      "name": "vic_and_io_chip_specifications",
      "description": "Consolidated detailed specifications for video, audio and I/O chips (6560/6566/6567 VIC variants, 6522 VIA, 6526 CIA, 6525 TPI, 6581/6582 SID, register maps, modes, MOB/sprite details, color codes, timers, interrupts and related interfacing details).",
      "no_refine": true
    },
    {
      "start": 14001,
      "end": 14009,
      "name": "6525_interrupt_latch_input_polarity",
      "description": "Behavior of the 6525 Tri-port interface interrupt latches with respect to input polarity and the Interrupt Enable bits. Explains that I4 and I3 latches are set on negative transitions when IE4/IE3=0 and on positive transitions when IE4/IE3=1; all other latches (I2,I1,I0) are set on negative transitions.",
      "references": [
        {
          "chunk": "6525_interrupt_latch_register_ILR",
          "topic": "how latched inputs are recorded in ILR"
        },
        {
          "chunk": "6525_active_interrupt_register_AIR",
          "topic": "how latched interrupts become active in AIR"
        }
      ]
    },
    {
      "start": 14010,
      "end": 14016,
      "name": "6525_interrupt_latch_register_ILR",
      "description": "Interrupt Latch Register (ILR) layout and clearing behavior. Shows bit layout (I4..I0), notes ILR clears on read of AIR according to ILR <- ILR xor AIR.",
      "references": [
        {
          "chunk": "6525_active_interrupt_register_AIR",
          "topic": "ILR interacts with AIR when servicing interrupts"
        },
        {
          "chunk": "6525_interrupt_stack_note",
          "topic": "reads of AIR affect the interrupt stack"
        }
      ]
    },
    {
      "start": 14017,
      "end": 14017,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14018,
      "end": 14022,
      "name": "6525_active_interrupt_register_AIR",
      "description": "Active Interrupt Register (AIR) layout and clearing behavior. Shows bit layout (A4..A0) and notes that AIR clears on write to AIR. Describes that AIR indicates the currently-active interrupt(s) and is used to inform the CPU which interrupt occurred.",
      "references": [
        {
          "chunk": "6525_interrupt_latch_register_ILR",
          "topic": "reading AIR clears ILR bits via ILR xor AIR"
        },
        {
          "chunk": "6525_interrupt_priority_select",
          "topic": "AIR behavior differs with priority mode"
        }
      ]
    },
    {
      "start": 14023,
      "end": 14024,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14025,
      "end": 14029,
      "name": "6525_interrupt_priority_select",
      "description": "Interrupt Priority Select (IP) bit description. Shows the single-bit IP register and explains IP = 0 means No Priority mode, IP = 1 means Interrupts Prioritized mode.",
      "references": [
        {
          "chunk": "6525_functional_description_IP0_no_priority",
          "topic": "behavior when IP = 0"
        },
        {
          "chunk": "6525_functional_description_IP1_intro_priority_order",
          "topic": "behavior when IP = 1"
        }
      ]
    },
    {
      "start": 14030,
      "end": 14032,
      "ignore": true,
      "reason": "Page marker between interrupt-priority select and functional description — non-technical."
    },
    {
      "start": 14033,
      "end": 14048,
      "name": "6525_functional_description_IP0_no_priority",
      "description": "Functional description of 6525 operation when IP = 0 (No Priority). Explains that ILR contents are immediately transferred to AIR, /IRQ is asserted, reading AIR resets /IRQ and clears ILR bits via ILR xor AIR, and writing AIR clears AIR and may trigger new interrupts. Notes multiple simultaneous interrupts may be present in AIR and must be handled by software.",
      "references": [
        {
          "chunk": "6525_interrupt_latch_register_ILR",
          "topic": "ILR to AIR transfer and ILR xor AIR clearing"
        },
        {
          "chunk": "6525_interrupt_stack_note",
          "topic": "cautions about reading/writing AIR"
        }
      ]
    },
    {
      "start": 14049,
      "end": 14049,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14050,
      "end": 14060,
      "name": "6525_functional_description_IP1_intro_priority_order",
      "description": "Introduction to IP = 1 mode (Interrupts Prioritized). Specifies the priority order I4 > I3 > I2 > I1 > I0 and notes that in this mode at most one AIR bit is set at a time. Describes the high-level flow: interrupts are latched into ILR, /IRQ asserted, and the appropriate AIR bit set.",
      "references": [
        {
          "chunk": "6525_IP1_example_single_interrupt",
          "topic": "example of single interrupt under IP=1"
        },
        {
          "chunk": "6525_IP1_example_higher_priority_interrupt",
          "topic": "example when a higher priority interrupt arrives"
        },
        {
          "chunk": "6525_IP1_example_lower_priority_interrupt",
          "topic": "example when a lower priority interrupt arrives"
        }
      ]
    },
    {
      "start": 14061,
      "end": 14061,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14062,
      "end": 14076,
      "name": "6525_IP1_example_single_interrupt",
      "description": "IP = 1 example A: single interrupt servicing. Step-by-step sequence when I1 occurs alone: I1 latched in ILR; /IRQ pulled low; A1 set in AIR; CPU reads AIR (which resets I1 in ILR and /IRQ); CPU services interrupt; CPU signals completion by writing AIR which clears A1.",
      "references": [
        {
          "chunk": "6525_functional_description_IP1_intro_priority_order",
          "topic": "priority mode overview"
        },
        {
          "chunk": "6525_active_interrupt_register_AIR",
          "topic": "AIR set/cleared during this sequence"
        }
      ]
    },
    {
      "start": 14077,
      "end": 14078,
      "ignore": true,
      "reason": "Page marker between two examples of IP=1 interrupt behavior — non-technical."
    },
    {
      "start": 14079,
      "end": 14102,
      "name": "6525_IP1_example_higher_priority_interrupt",
      "description": "IP = 1 example B: handling of a lower-priority interrupt (I1) that is followed by a higher-priority interrupt (I2). Sequence: I1 is latched and serviced; during service I2 arrives, A2 is set and A1 cleared, /IRQ pulls low; the processor's state is stacked automatically; processor reads AIR to identify I2 and services it; writing AIR clears A2 and the processor resumes I1 service; internal circuitry prevents a lower-priority interrupt from interrupting the resumed higher-priority processing.",
      "references": [
        {
          "chunk": "6525_interrupt_stack_note",
          "topic": "interrupt stack pushes on AIR read and pops on AIR write"
        },
        {
          "chunk": "6525_IP1_example_single_interrupt",
          "topic": "contrast with single-interrupt behavior"
        }
      ]
    },
    {
      "start": 14103,
      "end": 14116,
      "name": "6525_IP1_example_lower_priority_interrupt",
      "description": "IP = 1 example C: behavior when a lower-priority interrupt occurs during servicing of a higher-priority interrupt. Sequence: I1 is latched and being serviced; during service I0 (lower priority) is latched; upon completion of I1 and writing AIR to clear A1, the latched I0 is transferred to AIR and /IRQ is reasserted, beginning a new interrupt sequence for I0.",
      "references": [
        {
          "chunk": "6525_functional_description_IP1_intro_priority_order",
          "topic": "priority ordering I4..I0"
        },
        {
          "chunk": "6525_active_interrupt_register_AIR",
          "topic": "transfer of latched interrupts from ILR to AIR"
        }
      ]
    },
    {
      "start": 14117,
      "end": 14132,
      "name": "6525_interrupt_stack_note",
      "description": "Important note about the 6525's Interrupt Stack used to maintain priority interrupt information. Explains that a read of AIR pushes the interrupt stack and a write to AIR pops it; warns against extraneous reads/writes to AIR (should only read AIR to respond to an interrupt and write AIR to signal service completion).",
      "references": [
        {
          "chunk": "6525_active_interrupt_register_AIR",
          "topic": "read/write operations affect AIR and the stack"
        },
        {
          "chunk": "6525_IP1_example_higher_priority_interrupt",
          "topic": "stack usage when nesting interrupts occurs"
        }
      ]
    },
    {
      "start": 14133,
      "end": 14176,
      "name": "disk_user_guide_program_list",
      "description": "Appendix J: Disk User's Guide introduction and program list. Lists optional disk programs provided with the book (SUPERMON variants, UNICOPY64 and related files, COPY-ALL variants, CROSS REF, FACTORS, PENTOMINOS and related files, STRING THING, sample files, and others). Notes these are supplementary programs available on the optional disk.",
      "references": [
        {
          "chunk": "disk_programs_public_domain_and_supermon_usage",
          "topic": "how to obtain and use programs from the disk"
        },
        {
          "chunk": "unicopy64_overview",
          "topic": "details for UNICOPY64 program"
        },
        {
          "chunk": "factors_program_overview",
          "topic": "details for FACTORS program"
        },
        {
          "chunk": "pentominos_program_overview",
          "topic": "details for PENTOMINOS program"
        }
      ]
    },
    {
      "start": 14177,
      "end": 14209,
      "name": "disk_programs_public_domain_and_supermon_usage",
      "description": "Notes about the disk programs: they are public domain and available from user groups. Guidance for using SUPERMON builders: they are monitor generators that build a monitor in RAM; after building you should remove the builder program (RUN/STOP .X, NEW, then SYS to return to the monitor). The monitor is built near top-of-memory (check TOM). After placement, other programs may be loaded while Supermon stays until power-off.",
      "references": [
        {
          "chunk": "disk_user_guide_program_list",
          "topic": "list of disk programs"
        },
        {
          "chunk": "supermon64_overview",
          "topic": "see SUPERMON64 in the program list"
        }
      ]
    },
    {
      "start": 14210,
      "end": 14218,
      "name": "unicopy64_overview",
      "description": "UNICOPY64: a machine-language utility for copying files on the Commodore 64. The program copies file data into RAM during the input phase and writes it out to disk or tape during the output phase. It is written entirely in machine language apart from the SYS that starts it.",
      "references": [
        {
          "chunk": "unicopy_inst_description",
          "topic": "BASIC instructions file UNICOPY INST"
        },
        {
          "chunk": "unicopy_list_and_assy_description",
          "topic": "assembly listing and analysis of UNICOPY"
        }
      ]
    },
    {
      "start": 14219,
      "end": 14219,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14220,
      "end": 14223,
      "name": "unicopy_inst_description",
      "description": "UNICOPY INST: a BASIC program that explains how to use UNICOPY64.",
      "references": [
        {
          "chunk": "unicopy64_overview",
          "topic": "utility described by UNICOPY INST"
        }
      ]
    },
    {
      "start": 14224,
      "end": 14243,
      "name": "unicopy_list_and_assy_description",
      "description": "UNICOPY LIST and ]UNICOPY ASSY: assembly listing and data file for UNICOPY. The listing is of special interest because UNICOPY is written in machine language and performs tasks often more conveniently done in BASIC (file open/close etc.). The listing uses symbolic addresses and supports output to screen or printer; cassette output uses ROM routines.",
      "references": [
        {
          "chunk": "unicopy64_overview",
          "topic": "the program being listed"
        }
      ]
    },
    {
      "start": 14244,
      "end": 14257,
      "name": "copy_all_description",
      "description": "COPY-ALL and COPY-ALL.64: utilities for copying files between disk drives or to/from cassette. Combines machine language and BASIC: two SYS commands—one to get directory and one to perform copying. Uses a BASIC string as a transfer buffer; technique similar to STRING THING.",
      "references": [
        {
          "chunk": "string_thing_description",
          "topic": "similar BASIC string technique"
        }
      ]
    },
    {
      "start": 14258,
      "end": 14279,
      "name": "cross_ref_program_description",
      "description": "CROSS REF and CROSS REF 64: program that prepares a cross-reference listing for BASIC programs on disk, cross-referencing line numbers and variables. Implements character classification via a 256-element table and a state-transition table. The BASIC program has a second SYS that prints line numbers and uses an efficient binary-to-decimal conversion using decimal mode.",
      "references": [
        {
          "chunk": "factors_program_overview",
          "topic": "also uses binary-to-decimal conversion technique"
        }
      ]
    },
    {
      "start": 14280,
      "end": 14310,
      "name": "factors_program_overview",
      "description": "FACTORS program (PET/CBM and V64 variants): finds factors of numbers up to 19 digits. Highlights: decimal input handling for up to 19 digits, division with remainder to find factors, binary-to-decimal conversion for output, and a '30-counter' divisor-selection technique (try only multiples of 30 plus 1,7,11,17,19,23,29 after testing 2,3,5). The machine code is relocated by BASIC to $1300. Note for students: disassembly hints and utilities.",
      "references": [
        {
          "chunk": "factors_variables",
          "topic": "variables used by FACTORS (addresses like $0349..$0379)"
        },
        {
          "chunk": "factors_program_map",
          "topic": "program entry points and subroutines (addresses $1300..$1565)"
        }
      ]
    },
    {
      "start": 14311,
      "end": 14323,
      "name": "factors_variables",
      "description": "FACTORS program variable addresses and purposes: $0349 (times a factor divides), $034A (equals/asterisk char), $034B (zero suppression flag), $034C (30-counter), $0350-$0357 (value under analysis), $0358-$035F (work area), $0360-$0367 (base value for 30-counter), $036C-$0379 (division work area with remainder $036C-$036F and quotient $0370-$0377).",
      "references": [
        {
          "chunk": "factors_program_map",
          "topic": "program routines that operate on these variables"
        }
      ]
    },
    {
      "start": 14324,
      "end": 14350,
      "name": "factors_program_map",
      "description": "FACTORS program map: addresses and short descriptions of major routines. Main routine at $1300 (start/clear work area), input handling at $131D-$133A, factoring routines start $1350 (initial divisors) and $1365 (higher divisors), printing and division routines in the $13xx-$15xx ranges (including multiply-by-two $140B, division $1415, printing and formatting routines up to $1565 for 30-count values).",
      "references": [
        {
          "chunk": "factors_variables",
          "topic": "memory locations used by routines listed here"
        }
      ]
    },
    {
      "start": 14351,
      "end": 14354,
      "name": "factors_runstop_key",
      "description": "User note for FACTORS: the program can take a long time on large numbers; the RUN/STOP key is active to allow the user to stop execution.",
      "references": [
        {
          "chunk": "factors_program_overview",
          "topic": "practical runtime considerations"
        }
      ]
    },
    {
      "start": 14355,
      "end": 14355,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14356,
      "end": 14376,
      "name": "pentominos_program_overview",
      "description": "PENTOMINOS program: puzzle-solving machine-language program that fits pieces into a selected rectangular shape visibly (shows attempts on screen). The machine-language logic follows the BASIC program closely; shape tables are rearranged for machine-language convenience and pieces are indexed in a 0–255 range corresponding to piece and rotation. No indirect addressing and no subroutines (written to mirror BASIC). Program relocates to $156D (tables at $12FA) except B128 variant.",
      "references": [
        {
          "chunk": "pentominos_variables",
          "topic": "variables and tables used by PENTOMINOS"
        },
        {
          "chunk": "pentominos_program_map",
          "topic": "addresses for routines like Start, Try piece, Put piece in"
        }
      ]
    },
    {
      "start": 14377,
      "end": 14409,
      "name": "pentominos_variables",
      "description": "PENTOMINOS program variables and utility note: includes an optional UTILITIES note (WFDis disassembler), and variables such as $033C (piece number), $033D-$033E (board size W1/W2), $033F (P1 pieces placed), $0340-$034B log U(..), $034C-$0357 T(..) piece rotations, $0358-$035C X(..) locations, $035D-$0361 Y(..), $0362-$0370 tables to place pieces, $037F-$039C board edge table, $039D-$03D8 B(..) board.",
      "references": [
        {
          "chunk": "pentominos_program_map",
          "topic": "program entry points that manipulate these variables"
        }
      ]
    },
    {
      "start": 14410,
      "end": 14424,
      "name": "pentominos_program_map",
      "description": "PENTOMINOS program map: addresses and corresponding BASIC line equivalences. Startup at $156D (BASIC line 1070), clear screen $15A4 (1120), variable setup $15A9, find space $15CC (2010), get new piece $1600 (2030), try piece $1609 (2060), put piece in $1686 (2120), print solution $16E0 (2170), undraw/rotate/give up/look for new piece at addresses $1701-$17C1.",
      "references": [
        {
          "chunk": "pentominos_variables",
          "topic": "data structures and tables used by these routines"
        }
      ]
    },
    {
      "start": 14425,
      "end": 14429,
      "name": "pentominos_b128_notes",
      "description": "Notes about B128 variant of PENTOMINOS: does not align to the same addresses; illustrates the B128 'boot' loading system. Files whose names begin with '+' are loaded by the bootstrap program and should not be loaded directly.",
      "references": [
        {
          "chunk": "pentominos_program_overview",
          "topic": "differences in B128 variant relocation and boot handling"
        }
      ]
    },
    {
      "start": 14430,
      "end": 14449,
      "name": "string_thing_description",
      "description": "STRING THING (and STRING THING V64): a simple machine-language utility POKEable from BASIC to substitute for INPUT#. Overcomes INPUT# limitations (80-character limit, comma/colon splitting, loss of leading spaces). STRING THING reads everything up to RETURN or EOF; it's pure BASIC that POKEs machine code into the cassette buffer and uses the first variable as an input buffer.",
      "references": [
        {
          "chunk": "copy_all_description",
          "topic": "similar use of BASIC strings as transfer buffers"
        }
      ]
    },
    {
      "start": 14450,
      "end": 14453,
      "ignore": true,
      "reason": "Page markers between 'STRING THING' description and the Glossary — non-technical."
    },
    {
      "start": 14454,
      "end": 14477,
      "name": "glossary_header_and_a_terms",
      "description": "Glossary title and definitions for A-terms: Absolute Address, Accumulator, Address Bus, Address mode, Address, Algorithm, Arithmetic shift or rotate, Assembler, Assembly, and Assembly code.",
      "references": [
        {
          "chunk": "glossary_b_to_e_terms",
          "topic": "continues alphabetically with Assembly language through Execute (B–E terms)"
        },
        {
          "chunk": "glossary_f_to_m_terms",
          "topic": "subsequent glossary entries (F–M terms)"
        },
        {
          "chunk": "glossary_machine_monitor_memory_rom",
          "topic": "later hardware/memory and machine-monitor terms"
        },
        {
          "chunk": "glossary_registers_screen_stack_and_numbers",
          "topic": "remaining entries covering registers, stack, and numeric representations"
        }
      ]
    },
    {
      "start": 14478,
      "end": 14522,
      "name": "glossary_b_to_e_terms",
      "description": "Glossary definitions covering B–E: Assembly language, Binary, Bit, Bootstrap, Breakpoint, Bug, Bus, Byte, Calling point, Channel, Comment, Commutative, Control bus, Data bus, Debugging, Decimal, Decrement, Descriptor, Disassembler, Dynamic string, Effective address, Event flag, and Execute.",
      "references": [
        {
          "chunk": "glossary_header_and_a_terms",
          "topic": "previous A-terms and glossary header"
        },
        {
          "chunk": "glossary_f_to_m_terms",
          "topic": "next alphabetical block (F–M terms)"
        },
        {
          "chunk": "glossary_machine_monitor_memory_rom",
          "topic": "related machine/monitor/memory terms later in the glossary"
        },
        {
          "chunk": "glossary_registers_screen_stack_and_numbers",
          "topic": "related runtime concepts such as stack and registers found later"
        }
      ]
    },
    {
      "start": 14523,
      "end": 14566,
      "name": "glossary_f_to_m_terms",
      "description": "Glossary definitions covering F–M: File, Flag, Floating accumulator, Garbage collection, Increment, Index, Index register, Indirect address, Instruction, Interrupt, Interrupt enable register, Interrupt flag, Interrupt flag register, Interrupt source, Kernal, Label (symbolic address), Latch, Load, Logical file number, Logical operator, Logical shift or rotate, Machine code, and Machine language.",
      "references": [
        {
          "chunk": "glossary_b_to_e_terms",
          "topic": "previous block with B–E terms"
        },
        {
          "chunk": "glossary_machine_monitor_memory_rom",
          "topic": "further machine/monitor/memory-related terms (M–R region)"
        },
        {
          "chunk": "glossary_registers_screen_stack_and_numbers",
          "topic": "later entries on registers, stack, and numeric formats"
        }
      ]
    },
    {
      "start": 14567,
      "end": 14609,
      "name": "glossary_machine_monitor_memory_rom",
      "description": "Glossary definitions focused on machine/monitor and memory concepts: Machine language monitor, Memory, Memory mapped, Memory page, Microcomputer, Microprocessor, Monitor (program/screen), Non-maskable interrupt (NMI), Non-symbolic assembler, Object code, Octothorpe (#), Operand, Operating system, Operation code (op code), Overflow, Pointer, Processor status word (status register), Pull, Push, Random access memory (RAM), Read, and Read only memory (ROM).",
      "references": [
        {
          "chunk": "glossary_f_to_m_terms",
          "topic": "previous F–M glossary items including Machine language"
        },
        {
          "chunk": "glossary_registers_screen_stack_and_numbers",
          "topic": "subsequent entries about registers, screen memory, stack, and numeric representations"
        },
        {
          "chunk": "glossary_header_and_a_terms",
          "topic": "start of glossary and A-terms"
        }
      ]
    },
    {
      "start": 14610,
      "end": 14649,
      "name": "glossary_registers_screen_stack_and_numbers",
      "description": "Glossary definitions covering registers, screen, stack, and numeric concepts: Register, Screen editing, Screen memory, Selected (chip/device selection), Self-modifying, Signed number, Source code, Stack, Status register / processor status word, Store, Subroutine, Symbolic address (label), Symbolic assembler, Testable flag, Two's complement, Unsigned number, Write, and Zero page.",
      "references": [
        {
          "chunk": "glossary_machine_monitor_memory_rom",
          "topic": "related memory, machine, and monitor terms"
        },
        {
          "chunk": "glossary_f_to_m_terms",
          "topic": "earlier entries including interrupts and machine language"
        },
        {
          "chunk": "glossary_b_to_e_terms",
          "topic": "earlier B–E terms such as Effective address and Event flag"
        }
      ]
    },
    {
      "start": 14650,
      "end": 14653,
      "ignore": true,
      "reason": "Page markers between Glossary and Index; the Index is navigational and should be ignored for technical splitting."
    },
    {
      "start": 14654,
      "end": 15095,
      "ignore": true,
      "reason": "Index (non-technical navigational material). Contains alphabetical index entries, page references, and should be ignored for content-splitting."
    },
    {
      "start": 15096,
      "end": 15096,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 15097,
      "end": 15108,
      "name": "kernal_subroutines_table",
      "description": "Table of six major Kernal subroutines and their addresses and effects. Shows Address, Name, Action, and Registers Changed: $FFC6 CHKIN (switch input to logical file X) affects A,X; $FFC9 CHKOUT affects A,X; $FFCC CLRCHN restores I/O defaults affects A,X; $FFD2 CHROUT outputs ASCII char in A (none); $FFE1 STOP checks RUN/STOP key (A); $FFE4 GETIN gets ASCII char into A (affects A,X,Y).",
      "references": [
        {
          "chunk": "glossary",
          "topic": "Kernal and Kernal subroutine terminology"
        },
        {
          "chunk": "copy_all_description",
          "topic": "programs that call Kernal I/O routines"
        }
      ]
    },
    {
      "start": 15109,
      "end": 15124,
      "name": "important_memory_addresses_table",
      "description": "Table of Some Important Memory addresses (hex) for PET/CBM, VIC, C64. Pointers such as Start of BASIC ($0028/$002B), Start of Variables ($002A/$002D), End of Arrays ($002E/$0031), Bottom of Strings ($0030/$0033), Top of Memory ($0034/$0037). Also lists Status word ST ($0096/$0090), USR jump ($0000/$0310), CHRGET subroutine ($0070/$0073), Floating accumulator ($005E/$0061), and Keytouch register ($0097/$00CB). (Table maps common system pointers across machine variants.)",
      "references": [
        {
          "chunk": "glossary",
          "topic": "definitions of TOM, pointers, and memory layout"
        },
        {
          "chunk": "disk_user_guide_program_list",
          "topic": "monitor placement near top-of-memory (TOM)"
        }
      ]
    }
  ],
  "source_md5": "76f0f3b1bdc124a749946cfa9f5acbf8"
}
