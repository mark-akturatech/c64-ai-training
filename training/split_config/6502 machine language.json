{
  "source_file": "6502 machine language.txt",
  "context": "Machine Language for the Commodore 64 and Other Commodore Computers by James Butterfield",
  "splits": [
    {
      "start": 1,
      "end": 156,
      "ignore": true,
      "reason": "Title page, copyright, publisher info, e-text conversion note, table of contents"
    },
    {
      "start": 157,
      "end": 294,
      "name": "ml_introduction_preface",
      "description": "Machine language introduction and preface - why learn machine language speed versatility comprehension, teaching approach hands-on learning, prerequisites BASIC fundamentals, transferable skills to other 6502 machines Apple Atari, acknowledgements Commodore PET VIC-20 C64"
    },
    {
      "start": 295,
      "end": 1312,
      "name": "ml_first_concepts",
      "description": "6502 machine language first concepts Chapter 1 - inner workings of microcomputers, data bus address bus control bus, binary number system bits bytes, hexadecimal notation conversion, 6510 processor inner architecture registers accumulator X Y index stack pointer program counter status register, machine language monitor usage, computer memory layout RAM ROM, first machine language commands LDA STA LDX STX LDY STY, writing and entering simple programs, memory addresses"
    },
    {
      "start": 1313,
      "end": 1984,
      "name": "ml_controlling_output",
      "description": "6502 machine language controlling output Chapter 2 - calling machine language subroutines JSR RTS, the PRINT subroutine CHROUT $FFD2, immediate addressing mode LDA #value, calling machine language from BASIC SYS command, tiny assembler programs, indexed addressing LDA address X LDA address Y, simple loops DEX DEY BNE, loop counters, disassembly reading machine code, INX INY increment registers"
    },
    {
      "start": 1985,
      "end": 2817,
      "name": "ml_flags_logic_input",
      "description": "6502 machine language flags logic and input Chapter 3 - processor status flags zero flag Z carry flag C negative flag N overflow flag V, signed numbers two's complement, status register processor flags, CMP compare instruction CPX CPY, branch instructions BEQ BNE BCC BCS BMI BPL BVC BVS, first concepts of interrupt IRQ, logical operators ORA AND EOR bit manipulation, the GETIN subroutine $FFE4 keyboard input, the STOP subroutine $FFE1, SEC SED CLC CLD CLV set clear flags"
    },
    {
      "start": 2818,
      "end": 3477,
      "name": "ml_numbers_arithmetic_subroutines",
      "description": "6502 machine language numbers arithmetic and subroutines Chapter 4 - signed and unsigned numbers, big numbers multiple byte arithmetic, add ADC and subtract SBC with carry borrow, 16-bit addition subtraction, rotate and shift instructions ROL ROR ASL LSR, multiplication algorithm shift and add, division algorithm, home-grown subroutines JSR RTS nesting, passing parameters to subroutines, PHA PLA push pull accumulator stack"
    },
    {
      "start": 3478,
      "end": 4406,
      "name": "ml_address_modes",
      "description": "6502 machine language address modes Chapter 5 - non-address modes implied immediate register accumulator, absolute addressing 16-bit address, zero page addressing 8-bit address faster smaller, indexing X Y registers absolute indexed zero page indexed, relative addressing for branches signed offset -128 to +127, indirect addressing JMP indirect, indirect indexed (zeropage) Y post-indexed, indexed indirect (zeropage X) pre-indexed, addressing mode summary table"
    },
    {
      "start": 4407,
      "end": 5307,
      "name": "ml_linking_basic_machine_language",
      "description": "6502 machine language linking BASIC Chapter 6 - where to put machine language program, BASIC memory layout, loading and SOV pointer start of variables, BASIC variables fixed floating and string formats, exchanging data with BASIC, reading BASIC variables from machine language, passing parameters via SYS, peeking and poking, relocatable code, putting ML in BASIC REM statements"
    },
    {
      "start": 5308,
      "end": 6163,
      "name": "ml_stack_usr_interrupt_wedge",
      "description": "6502 machine language stack USR interrupt and wedge Chapter 7 - hardware stack $0100-$01FF temporary storage push pull PHA PHP PLA PLP, TSX TXS stack pointer manipulation, USR function alternative to SYS, interrupts IRQ NMI BRK interrupt request non-maskable interrupt break, SEI CLI enable disable interrupts, interrupt handler save restore registers, the IA chips PIA VIA CIA interface adapters, infiltrating BASIC the wedge technique CHRGET vector"
    },
    {
      "start": 6164,
      "end": 6948,
      "name": "ml_timing_io_conclusion",
      "description": "6502 machine language timing I/O and conclusion Chapter 8 - how to estimate program speed cycle counting instruction timing, input and output from tape disk printer, KERNAL I/O routines OPEN CLOSE CHKIN CHKOUT CHRIN CHROUT CLRCHN SETLFS SETNAM LOAD SAVE, serial bus communication, review of all 6502 instructions summary, debugging techniques, symbolic assemblers advantages, where to go from here advanced topics"
    },
    {
      "start": 6949,
      "end": 7326,
      "name": "ml_6502_instruction_set",
      "description": "6502 instruction set reference Appendix A - complete 6502/6510/6509/7501 instruction set table, all opcodes with addressing modes and hex values, ADC AND ASL BCC BCS BEQ BIT BMI BNE BPL BRK BVC BVS CLC CLD CLI CLV CMP CPX CPY DEC DEX DEY EOR INC INX INY JMP JSR LDA LDX LDY LSR NOP ORA PHA PHP PLA PLP ROL ROR RTI RTS SBC SEC SED SEI STA STX STY TAX TAY TSX TXA TXS TYA, instruction timing cycles, status flag effects"
    },
    {
      "start": 7327,
      "end": 7511,
      "name": "ml_commodore_machine_characteristics",
      "description": "6502 Commodore machine characteristics Appendix B - comparison of PET CBM VIC-20 Commodore 64 Plus/4 B-128, memory sizes, BASIC versions, I/O chip differences, screen dimensions, character sets, serial bus vs IEEE-488"
    },
    {
      "start": 7512,
      "end": 8520,
      "name": "ml_memory_maps_pet_vic20",
      "description": "Commodore memory maps Appendix C part 1 - original ROM PET and upgrade ROM PET/CBM zero page hunt, PET memory map BASIC pointers, VIC-20 memory map zero page locations, VIC-20 BASIC and KERNAL addresses, available zero page locations for user programs, system vectors, I/O chip addresses, screen memory locations"
    },
    {
      "start": 8521,
      "end": 9975,
      "name": "ml_memory_maps_c64_plus4",
      "description": "Commodore 64 and Plus/4 memory maps Appendix C part 2 - C64 zero page hunt available locations, C64 complete memory map zero page BASIC pointers $00-$FF, page 1 stack $100-$1FF, pages 2-3 working storage $200-$3FF, screen memory $400-$7FF, BASIC text $800-$9FFF, BASIC ROM $A000-$BFFF, free RAM $C000-$CFFF, I/O area $D000-$DFFF VIC-II SID CIA, KERNAL ROM $E000-$FFFF, C64 KERNAL jump table $FF81-$FFF3, Plus/4 preliminary memory map, B-series B-128 CBM-256 memory map"
    },
    {
      "start": 9976,
      "end": 10434,
      "name": "ml_character_sets",
      "description": "Commodore character sets Appendix D - PETSCII character code tables, screen codes vs PETSCII codes, control characters, reverse video, color codes, graphics characters, uppercase lowercase character sets, PET VIC-20 C64 character encoding"
    },
    {
      "start": 10435,
      "end": 10666,
      "name": "ml_exercises_alternative_machines",
      "description": "Machine language exercises for alternative Commodore machines Appendix E - adaptations for PET CBM VIC-20 Plus/4 B-128, differences in memory locations and KERNAL routines, SYS addresses, screen I/O differences, exercise modifications for each platform"
    },
    {
      "start": 10667,
      "end": 10724,
      "name": "ml_floating_point_format",
      "description": "Commodore BASIC floating point format Appendix F - floating point number representation, 5-byte format exponent mantissa sign, converting between floating point and integer, FAC1 FAC2 floating point accumulators, BASIC ROM routines for number conversion"
    },
    {
      "start": 10725,
      "end": 10814,
      "name": "ml_uncrashing",
      "description": "Uncrashing Commodore computers Appendix G - recovering from system crashes, NMI restore key technique, reset button, machine language monitor recovery, protecting programs during crash recovery, saving work after crash"
    },
    {
      "start": 10815,
      "end": 10880,
      "name": "ml_supermon_instructions",
      "description": "Supermon machine language monitor instructions Appendix H - do-it-yourself Supermon monitor, monitor commands A assemble D disassemble G go execute M memory display R register display X exit, breakpoints, entering and editing machine code, memory examine and modify"
    },
    {
      "start": 10881,
      "end": 11184,
      "name": "ml_6520_pia_specs",
      "description": "6520 PIA Peripheral Interface Adapter chip specifications Appendix I - two 8-bit bidirectional data ports, data direction registers, control registers, interrupt flags, CA1 CA2 CB1 CB2 control lines, handshaking modes, register map"
    },
    {
      "start": 11185,
      "end": 11431,
      "name": "ml_6545_crtc_specs",
      "description": "6545-1 CRTC CRT Controller chip specifications - video display controller, horizontal and vertical timing registers, character display format, cursor control, light pen register, screen memory addressing, interlace modes, register map R0-R17"
    },
    {
      "start": 11432,
      "end": 11731,
      "name": "ml_6560_vic_specs",
      "description": "6560 VIC Video Interface Chip specifications - VIC-20 video chip, color video graphics, screen matrix, character generator, 16 colors, sound generation, light pen input, register map, interlace scan, A/D converter inputs, video matrix and color memory addressing"
    },
    {
      "start": 11732,
      "end": 12206,
      "name": "ml_6522_via_specs",
      "description": "6522 VIA Versatile Interface Adapter chip specifications - two 8-bit bidirectional I/O ports PA PB, two 16-bit interval timers T1 T2, serial shift register, handshaking CA1 CA2 CB1 CB2, interrupt flag register IFR, interrupt enable register IER, timer modes one-shot free-running, pulse counting, register map"
    },
    {
      "start": 12207,
      "end": 12631,
      "name": "ml_6526_cia_specs",
      "description": "6526 CIA Complex Interface Adapter chip specifications - two 8-bit bidirectional I/O ports, two 16-bit timers Timer A Timer B, real time clock TOD tenths seconds minutes hours, 8-bit serial shift register, interrupt control ICR, control registers CRA CRB, timer modes, serial port, TOD alarm, register map, used in C64 at $DC00 and $DD00"
    },
    {
      "start": 12632,
      "end": 13343,
      "name": "ml_6567_vic2_specs",
      "description": "6566/6567 VIC-II Video Interface Chip specifications - C64 video controller, 47 control registers, 320x200 high resolution bitmapped graphics, 160x200 multicolor mode, 40x25 text mode, 8 sprites with priority and collision detection, smooth scrolling, raster interrupt, 16 colors, light pen input, memory banking 4x16K banks, register map, sprite data pointers, character generator addressing"
    },
    {
      "start": 13344,
      "end": 13866,
      "name": "ml_6581_sid_specs",
      "description": "6581 SID Sound Interface Device chip specifications - three independent audio oscillators voices, four waveform types triangle sawtooth pulse noise, ADSR envelope generator attack decay sustain release, programmable filter low-pass high-pass band-pass, ring modulation, oscillator synchronization, master volume, random number generator, analog-to-digital converter potentiometer input, external audio input, register map 29 registers"
    },
    {
      "start": 13867,
      "end": 14138,
      "name": "ml_6525_triport_specs",
      "description": "6525 TPA Tri-Port Interface chip specifications - three 8-bit I/O ports PA PB PC, data direction registers, active interrupt input, register map"
    },
    {
      "start": 14139,
      "end": 14454,
      "name": "ml_disk_users_guide",
      "description": "Commodore disk user's guide Appendix J - 1541 disk drive commands, OPEN CLOSE PRINT# INPUT# GET# for disk access, sequential files read write, relative files, command channel, disk status error channel, program files, directory listing, scratch rename copy commands, disk initialization formatting"
    },
    {
      "start": 14455,
      "end": 14653,
      "name": "ml_glossary",
      "description": "Machine language glossary - definitions of key terms: absolute address, accumulator, address bus, algorithm, architecture, ASCII, assembler, binary, bit, branch, breakpoint, buffer, bus, byte, carry flag, clock, compiler, data bus, disassembler, flag, hexadecimal, index register, instruction set, interrupt, KERNAL, mnemonic, NMI, opcode, operand, overflow, program counter, register, ROM, stack, status register, subroutine, two's complement, vector, zero page"
    },
    {
      "start": 14654,
      "end": 15125,
      "ignore": true,
      "reason": "Index - page number references not useful for semantic search"
    }
  ],
  "source_md5": "76f0f3b1bdc124a749946cfa9f5acbf8"
}
