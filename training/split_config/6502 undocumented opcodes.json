{
  "source_file": "6502 undocumented opcodes.txt",
  "source_md5": "2e7b52b6be582afd91ed240989ffbb4c",
  "context": "6502 Undocumented Opcodes Comprehensive Reference v0.99 by groepaz/solution",
  "splits": [
    {
      "start": 1,
      "end": 8,
      "ignore": true,
      "reason": "Title, version, author information"
    },
    {
      "start": 9,
      "end": 193,
      "ignore": true,
      "reason": "Table of contents"
    },
    {
      "start": 194,
      "end": 274,
      "name": "undoc_preface_and_scope",
      "description": "6502 undocumented opcodes preface: scope of document covering NMOS 6502 6510 8500 8502 variants, intended audience, license information, what the document covers, terminology: unintended opcodes vs illegal opcodes vs undocumented opcodes"
    },
    {
      "start": 275,
      "end": 426,
      "name": "undoc_naming_conventions",
      "description": "6502 undocumented opcode naming conventions: mnemonic variations across assemblers and documents, SLO ASO, RLA, SRE LSE, RRA, SAX AXS AAX, LAX, DCP DCM, ISC ISB INS, ANC ANC2 AAC, ALR ASR, ARR, SBX AXS SAX, USBC, LAS LAR, NOP DOP TOP SKB SKW, JAM KIL HLT, SHA AHX AXA, SHX A11 SXA XAS, SHY SAY SYA, TAS SHS XAS, ANE XAA, LXA LAX OAL ATX, processor status flag naming N V B D I Z C"
    },
    {
      "start": 427,
      "end": 1258,
      "name": "undoc_opcode_matrix",
      "description": "6502 full opcode matrix with undocumented opcodes: complete 16x16 hex opcode table $00-$FF showing all 256 opcodes, legal and illegal, with addressing mode notation, cycle counts, stability classification, color coding for stable unstable and highly unstable opcodes, cross-reference annotations for each undocumented opcode explaining its sub-operations"
    },
    {
      "start": 1259,
      "end": 1669,
      "name": "undoc_overview_table",
      "description": "6502 unintended opcodes overview summary table: all undocumented opcodes listed with mnemonic function description addressing modes opcodes bytes cycles flags affected, stability classification stable vs unstable vs highly-unstable, grouped by type: combined operations SLO RLA SRE RRA SAX LAX DCP ISC, immediate+implied ANC ALR ARR SBX USBC, load/store combos LAS, NOPs, JAMs, unstable address high byte SHA SHX SHY TAS, magic constant ANE LAX#imm"
    },
    {
      "start": 1670,
      "end": 1791,
      "name": "undoc_slo",
      "description": "6502 undocumented opcode SLO (ASO): stable combined ASL+ORA operation, shift left memory then OR with accumulator, all addressing modes zp zpx izx izy abs abx aby, opcodes $07 $17 $03 $13 $0F $1F $1B, flags N Z C affected, cycle counts, practical usage examples including 16-bit shift, flag testing, parity calculation"
    },
    {
      "start": 1792,
      "end": 1992,
      "name": "undoc_rla",
      "description": "6502 undocumented opcode RLA: stable combined ROL+AND operation, rotate left memory then AND with accumulator, all addressing modes zp zpx izx izy abs abx aby, opcodes $27 $37 $23 $33 $2F $3F $3B, flags N Z C affected, cycle counts, practical usage examples including bit masking and extraction"
    },
    {
      "start": 1993,
      "end": 2194,
      "name": "undoc_sre",
      "description": "6502 undocumented opcode SRE (LSE): stable combined LSR+EOR operation, logical shift right memory then exclusive-OR with accumulator, all addressing modes zp zpx izx izy abs abx aby, opcodes $47 $57 $43 $53 $4F $5F $5B, flags N Z C affected, cycle counts, practical usage examples including parity check and bit extraction"
    },
    {
      "start": 2195,
      "end": 2370,
      "name": "undoc_rra",
      "description": "6502 undocumented opcode RRA: stable combined ROR+ADC operation, rotate right memory then add to accumulator with carry, all addressing modes zp zpx izx izy abs abx aby, opcodes $67 $77 $63 $73 $6F $7F $7B, flags N V Z C affected, cycle counts, affected by decimal mode D flag, practical usage examples"
    },
    {
      "start": 2371,
      "end": 2558,
      "name": "undoc_sax",
      "description": "6502 undocumented opcode SAX (AXS AAX): stable store A AND X to memory, addressing modes zp zpy izx abs, opcodes $87 $97 $83 $8F, no flags affected, cycle counts, practical usage examples including lookup table indexing, bit field manipulation, storing masked values"
    },
    {
      "start": 2559,
      "end": 2742,
      "name": "undoc_lax",
      "description": "6502 undocumented opcode LAX: stable load accumulator and X register simultaneously from memory, addressing modes zp zpy izx izy abs aby, opcodes $A7 $B7 $A3 $B3 $AF $BF, flags N Z affected, cycle counts, practical usage examples including fast variable loading and index setup"
    },
    {
      "start": 2743,
      "end": 2970,
      "name": "undoc_dcp",
      "description": "6502 undocumented opcode DCP (DCM): stable combined DEC+CMP operation, decrement memory then compare with accumulator, all addressing modes zp zpx izx izy abs abx aby, opcodes $C7 $D7 $C3 $D3 $CF $DF $DB, flags N Z C affected, cycle counts, practical usage examples including loop counters and indirect indexed decrement"
    },
    {
      "start": 2971,
      "end": 3166,
      "name": "undoc_isc",
      "description": "6502 undocumented opcode ISC (ISB INS): stable combined INC+SBC operation, increment memory then subtract from accumulator with borrow, all addressing modes zp zpx izx izy abs abx aby, opcodes $E7 $F7 $E3 $F3 $EF $FF $FB, flags N V Z C affected, cycle counts, affected by decimal mode D flag, practical usage examples including loop counter with subtraction"
    },
    {
      "start": 3167,
      "end": 3271,
      "name": "undoc_anc",
      "description": "6502 undocumented opcode ANC: stable immediate AND with accumulator then copy N flag to carry, opcodes $0B $2B, 2 bytes 2 cycles, flags N Z C affected, practical usage as AND that also sets carry from bit 7, example for fast sign-to-carry transfer"
    },
    {
      "start": 3272,
      "end": 3381,
      "name": "undoc_alr",
      "description": "6502 undocumented opcode ALR (ASR): stable immediate AND with accumulator then logical shift right, opcode $4B, 2 bytes 2 cycles, flags N Z C affected, practical usage examples including fast AND+shift combinations, division by power of 2 with masking"
    },
    {
      "start": 3382,
      "end": 3600,
      "name": "undoc_arr",
      "description": "6502 undocumented opcode ARR: stable immediate AND with accumulator then rotate right, opcode $6B, 2 bytes 2 cycles, flags N V Z C affected, C and V flags set differently than normal ROR using bit 6 and bit 5 of result, affected by decimal mode D flag with BCD fixup, practical usage examples"
    },
    {
      "start": 3601,
      "end": 3737,
      "name": "undoc_sbx",
      "description": "6502 undocumented opcode SBX (AXS): stable compare-like subtract, X = (A AND X) minus immediate without borrow, opcode $CB, 2 bytes 2 cycles, flags N Z C affected, carry not used as input unlike SBC, practical usage examples including fast X decrement by arbitrary value, combined table index calculation"
    },
    {
      "start": 3738,
      "end": 3975,
      "name": "undoc_usbc",
      "description": "6502 undocumented opcode USBC: stable duplicate SBC at opcode $EB, identical to legal SBC $E9, subtract immediate from accumulator with borrow, flags N V Z C affected, affected by decimal mode D flag, existence explained by opcode matrix encoding pattern"
    },
    {
      "start": 3976,
      "end": 4061,
      "name": "undoc_las",
      "description": "6502 undocumented opcode LAS (LAR LAE LDS): stable load A X SP with memory AND stack pointer, A X SP = memory AND SP, opcode $BB absolute Y indexed, 3 bytes 4+1 cycles, flags N Z affected, practical usage limited due to SP dependency"
    },
    {
      "start": 4062,
      "end": 4506,
      "name": "undoc_nop_variants",
      "description": "6502 undocumented NOP variants: NOP with various addressing modes, implied NOPs at $1A $3A $5A $7A $DA $FA, immediate NOPs DOP at $80 $82 $89 $C2 $E2, zeropage NOPs DOP at $04 $44 $64, zeropage X NOPs DOP at $14 $34 $54 $74 $D4 $F4, absolute NOP TOP at $0C, absolute X NOPs TOP at $1C $3C $5C $7C $DC $FC, all stable, byte counts cycle counts, practical usage for timing adjustment and code alignment, raster synchronization examples"
    },
    {
      "start": 4507,
      "end": 4660,
      "name": "undoc_jam",
      "description": "6502 JAM (KIL HLT) opcodes: CPU halt instructions at $02 $12 $22 $32 $42 $52 $62 $72 $92 $B2 $D2 $F2, processor enters endless loop, only reset or NMI can recover, internal bus behavior during jam state, test code references"
    },
    {
      "start": 4661,
      "end": 4790,
      "name": "undoc_unstable_opcodes_intro",
      "description": "6502 unstable opcodes introduction: classification of unstable vs stable undocumented opcodes, two groups of unstable opcodes: address high byte group SHA SHX SHY TAS affected by page boundary crossing, magic constant group ANE LAX#imm affected by analog chip characteristics and CPU state, RDY line dependency, testing methodology"
    },
    {
      "start": 4791,
      "end": 4865,
      "name": "undoc_sha",
      "description": "6502 unstable opcode SHA (AHX AXA): store A AND X AND (high byte of address + 1) to memory, opcodes $9F absolute Y $93 indirect Y, unstable due to page boundary crossing behavior, high byte of target address may be corrupted when page boundary crossed, flags not affected"
    },
    {
      "start": 4866,
      "end": 4951,
      "name": "undoc_shx",
      "description": "6502 unstable opcode SHX (A11 SXA XAS): store X AND (high byte of address + 1) to memory, opcode $9E absolute Y indexed, unstable due to page boundary crossing affecting stored value and target address, practical usage for raster synchronization exploiting dummy read behavior"
    },
    {
      "start": 4952,
      "end": 5137,
      "name": "undoc_shy",
      "description": "6502 unstable opcode SHY (SAY SYA): store Y AND (high byte of address + 1) to memory, opcode $9C absolute X indexed, unstable due to page boundary crossing affecting stored value and target address, practical usage for raster bar synchronization examples with precise timing"
    },
    {
      "start": 5138,
      "end": 5258,
      "name": "undoc_tas",
      "description": "6502 unstable opcode TAS (SHS XAS): store A AND X into stack pointer then store A AND X AND (high byte of address + 1) to memory, opcode $9B absolute Y indexed, unstable due to page boundary crossing, modifies stack pointer as side effect, practical usage examples"
    },
    {
      "start": 5259,
      "end": 5413,
      "name": "undoc_ane",
      "description": "6502 highly unstable opcode ANE (XAA): A = (A OR magic constant) AND X AND immediate, opcode $8B, magic constant varies between individual CPU chips approximately $EF or $EE or $FF, depends on analog characteristics temperature and RDY line state, truly unstable behavior, real-world usage in Spectipede and Turrican 3, testing methodology"
    },
    {
      "start": 5414,
      "end": 5564,
      "name": "undoc_lax_immediate",
      "description": "6502 highly unstable opcode LAX immediate: A X = (A OR magic constant) AND immediate, opcode $AB, same magic constant dependency as ANE, depends on analog CPU characteristics, more stable when A is loaded immediately before, real-world usage in Wizball, used as de facto stable in some commercial software"
    },
    {
      "start": 5565,
      "end": 6091,
      "name": "undoc_unintended_addressing_modes",
      "description": "6502 unintended addressing modes cycle-by-cycle: detailed bus timing for undocumented addressing mode variants, absolute Y indexed read-modify-write 7 cycles, zeropage X indexed indirect read-modify-write 8 cycles, zeropage indirect Y indexed read-modify-write 8 cycles, comparison with legal addressing mode cycle timing, address bus data bus read/write for each cycle, visual6502 simulation links"
    },
    {
      "start": 6092,
      "end": 6120,
      "name": "undoc_decimal_mode_intro",
      "description": "6502 unintended decimal mode introduction: BCD binary coded decimal mode overview, D flag affecting only ADC and SBC, invalid BCD values behavior, decimal correction rules for addition and subtraction nibble fixup, N V Z C flag behavior differences in decimal mode, Z flag always set by binary result ignoring BCD"
    },
    {
      "start": 6121,
      "end": 6415,
      "name": "undoc_decimal_mode_adc",
      "description": "6502 decimal mode ADC detailed: BCD addition algorithm, low nibble and high nibble decimal correction, N V flags set after lower nibble fix before upper nibble fix, Z flag set by binary result, C flag set after full BCD correction, complete C pseudocode for decimal ADC, invalid BCD value examples, hex-to-ASCII conversion trick using decimal mode, hex-to-BCD conversion, NMOS vs CMOS 65C02 BCD behavior differences detection"
    },
    {
      "start": 6416,
      "end": 6636,
      "name": "undoc_decimal_mode_sbc",
      "description": "6502 decimal mode SBC detailed: BCD subtraction algorithm, low nibble and high nibble decimal correction, N V flags not affected by decimal mode unlike ADC, Z flag set by binary result, C flag works as borrow, complete C pseudocode for decimal SBC, USBC $EB identical behavior, wraparound $00 minus $01 equals $99"
    },
    {
      "start": 6637,
      "end": 6708,
      "name": "undoc_decimal_mode_arr",
      "description": "6502 decimal mode ARR detailed: AND then ROR with BCD fixup, N flag from original carry, V flag from bit 6 change, low nibble BCD fixup if nibble plus lowmost bit exceeds 5, high nibble BCD fixup sets carry, complete C pseudocode for decimal ARR behavior"
    },
    {
      "start": 6709,
      "end": 6973,
      "name": "undoc_decimal_mode_isc_rra",
      "description": "6502 decimal mode ISC and RRA: ISC increment then subtract inherits decimal mode from SBC, RRA rotate right then add inherits decimal mode from ADC, complete opcode tables with addressing modes bytes cycles flags, test code references for verification"
    },
    {
      "start": 6974,
      "end": 7082,
      "name": "undoc_memory_access_dummy_fetches",
      "description": "6502 unintended memory accesses dummy fetches: single byte instructions always fetch PC+1, accumulator mode ASL LSR ROL ROR dummy read, implied mode instructions dummy read, stack push PHA PHP dummy read, cycle-by-cycle bus timing tables for each instruction type"
    },
    {
      "start": 7083,
      "end": 7337,
      "name": "undoc_memory_access_stack_interrupts",
      "description": "6502 dummy memory accesses stack and interrupts: BRK software interrupt cycle timing with signature byte read, RTI return from interrupt with dummy reads, hardware interrupt IRQ NMI RESET cycle timing, RESET does not write to stack RW stays high, dummy reads from stack during pull operations PLA PLP, RTS dummy reads, JSR dummy read from stack, practical example acknowledging CIA interrupts via RTI at $DD0C"
    },
    {
      "start": 7338,
      "end": 7545,
      "name": "undoc_memory_access_indexed",
      "description": "6502 dummy memory accesses indexed instructions: absolute indexed page boundary crossing dummy read from incorrect address before high byte correction, zeropage indirect Y indexed dummy read, zeropage indexed dummy read from unindexed address, practical examples: acknowledge both CIA interrupts in one instruction, 5-cycle wide raster splits, sprites far right in border DMA cycle exploitation"
    },
    {
      "start": 7546,
      "end": 7868,
      "name": "undoc_memory_access_zp_stack_branches",
      "description": "6502 dummy memory accesses zeropage indexed indirect, stack operations, and branches: zeropage X indexed indirect dummy read from direct offset, JSR dummy read from stack, RTS dummy reads from PC+1 stack and target, PLA PLP dummy reads, branch instructions dummy reads from PC+2 when taken and from wrong-page address when crossing page boundary, cycle-by-cycle bus timing for each"
    },
    {
      "start": 7869,
      "end": 8173,
      "name": "undoc_dummy_writes_rmw",
      "description": "6502 dummy writes read-modify-write instructions: RMW instructions write unmodified value before writing modified value, absolute RMW double-write timing, practical examples: acknowledge VIC-II interrupt with single INC $D019, acknowledge and disable CIA timer with DEC $DC0D, toggle SID gate bit, grey dots technique, ghostbyte under ROM double-write exploitation for VIC timing tricks, REU transfer start via RMW at $FF00, RDY and AEC bus signals during DMA"
    },
    {
      "start": 8174,
      "end": 8655,
      "name": "undoc_dummy_writes_indexed_rmw",
      "description": "6502 dummy writes indexed read-modify-write: zeropage RMW old data writeback, absolute X indexed RMW dummy read and old data writeback 7 cycles, absolute Y indexed RMW dummy read and old data writeback 7 cycles, zeropage X indexed RMW dummy read and old data writeback 6 cycles, zeropage indirect Y indexed RMW 8 cycles, zeropage X indexed indirect RMW 8 cycles, cycle-by-cycle bus timing tables with visual6502 simulation links"
    },
    {
      "start": 8656,
      "end": 8706,
      "name": "undoc_bugs_and_quirks",
      "description": "6502 unintended bugs and quirks: zeropage addressing page wrap behavior indexed zeropage cannot leave page zero, indirect JMP page wrap bug fetches high byte from wrong address $C0FF wraps to $C000, interrupts do not clear decimal flag D requiring manual CLD in handlers, break flag B always appears set in PHP and BRK pushes, distinguishing BRK from IRQ using pushed status byte B flag"
    },
    {
      "start": 8707,
      "end": 9136,
      "name": "undoc_assembler_naming_appendix",
      "description": "6502 undocumented opcode naming across assemblers appendix: comparison table of mnemonic names used by KickAssembler, ACME, ca65, dasm, 64tass for all undocumented opcodes SLO RLA SRE RRA SAX LAX DCP ISC ANC ALR ARR SBX SHA SHX SHY TAS LAS LAX#imm ANE NOP JAM, opcode values per addressing mode"
    },
    {
      "start": 9137,
      "end": 9215,
      "name": "undoc_combined_examples",
      "description": "6502 undocumented opcode combined usage examples: negating 16-bit number using LAX SBX SBC, smart addition using LAX SBX to save 4 cycles replacing LDA CLC ADC TAX, multiply 8-bit by power of 2 with 16-bit result using LAX AND SAX, read and clear rightmost set bit using LAX DEX SAX EOR"
    },
    {
      "start": 9216,
      "end": 9731,
      "name": "undoc_6_sprites_fli_and_blackmail_fli",
      "description": "6502 undocumented opcodes in demo effects: 6 sprites over FLI routine from Darwin demo using SRE ASL SLO RRA SAX RMW opcodes for precise VIC-II register timing with accumulator side effects, Blackmail FLI Graph v2.2 technique exploiting opcode byte values as color RAM data during open bus reads, per-line color RAM manipulation using $Ax row opcodes LDY LDA LDX LAX as color selectors, complete code listings for all 16 color variants, lookup table layout"
    },
    {
      "start": 9732,
      "end": 9733,
      "ignore": true,
      "reason": "Page number marker"
    },
    {
      "start": 9734,
      "end": 9819,
      "ignore": true,
      "reason": "References and external URLs"
    },
    {
      "start": 9820,
      "end": 9981,
      "ignore": true,
      "reason": "Greets and thanks acknowledgments"
    },
    {
      "start": 9982,
      "end": 10018,
      "ignore": true,
      "reason": "Wanted section requesting contributions"
    },
    {
      "start": 10019,
      "end": 10120,
      "ignore": true,
      "reason": "Document version history and changelog"
    }
  ]
}
