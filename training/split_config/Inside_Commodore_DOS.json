{
  "source_file": "Inside_Commodore_DOS.txt",
  "context": "byRiclianll",
  "splits": [
    {
      "start": 1,
      "end": 76,
      "ignore": true,
      "reason": "Title page, author credits, publisher and copyright information (non-technical front matter)"
    },
    {
      "start": 77,
      "end": 78,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 79,
      "end": 266,
      "ignore": true,
      "reason": "Table of Contents (non-technical index of chapters and pages)"
    },
    {
      "start": 267,
      "end": 268,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 269,
      "end": 315,
      "name": "introduction_purpose_and_scope",
      "description": "Chapter 1 introduction: purpose of the manual, intended audience, scope, relationship to the 1541 User's Manual, authors' disassembly work and research notes.",
      "references": [
        {
          "chunk": "programs_listing_and_restrictions",
          "topic": "program listings and restrictions"
        },
        {
          "chunk": "disk_housekeeping_overview",
          "topic": "topics the manual will cover (e.g., formatting, recovery)"
        }
      ]
    },
    {
      "start": 316,
      "end": 350,
      "name": "programs_listing_and_restrictions",
      "description": "Section 1.1: Notes about the 46 BASIC disk utility programs included with the book — copyright restrictions, recommended precautions, inclusion of machine-language source listings (.PAL), and testing disclaimers.",
      "references": [
        {
          "chunk": "typing_conventions_and_lister",
          "topic": "how programs were prepared for printing"
        }
      ]
    },
    {
      "start": 351,
      "end": 351,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 352,
      "end": 363,
      "name": "typing_conventions_and_lister",
      "description": "Section 1.2 intro: Explanation that program listings were converted with a lister program to WordPro format and control characters were spelled out in curly brackets (e.g., {CLR}).",
      "references": [
        {
          "chunk": "control_character_table_and_notes",
          "topic": "control-character mapping table and typing instructions"
        }
      ]
    },
    {
      "start": 364,
      "end": 443,
      "name": "control_character_table_and_notes",
      "description": "Table of listing conventions and control-character mappings used in listings: {CLR}, {HOME}, {DOWN}, {UP}, {RIGHT}, {LEFT}, {RVS}, {ROFF}. Shows the Commodore keypresses to enter these. Includes notes: repetition notation ({DOWN 5}), 40-column width listing, and spaces must be typed exactly.",
      "references": [
        {
          "chunk": "typing_conventions_and_lister",
          "topic": "why control characters were spelled out"
        }
      ]
    },
    {
      "start": 444,
      "end": 486,
      "name": "dos_characteristics_advantages_disadvantages",
      "description": "Chapter 2 introduction & Section 2.1: Purpose of a DOS and Commodore's approach — the 1541 is an 'intelligent peripheral' with its own 6502 CPU, RAM, 6522 chips, and ROM DOS. Lists advantages (no host RAM used, concurrent operations, shareable) and disadvantages (hard to customize, ROM replacement needed for updates).",
      "references": [
        {
          "chunk": "communicating_with_1541_methods",
          "topic": "how the computer communicates with the 1541"
        },
        {
          "chunk": "overview_of_1541_dos_and_hardware",
          "topic": "ROM routines and 6502 in the 1541 (see later chapters)"
        }
      ]
    },
    {
      "start": 487,
      "end": 531,
      "name": "communicating_with_1541_methods",
      "description": "Section 2.2: Three ways the C64/VIC-20 communicates with the 1541: (1) LOAD/SAVE/VERIFY BASIC commands, (2) I/O via the command channel (channel 15), and (3) I/O via data communication channels for file read/write. Introduces focus on the command channel for the rest of the manual.",
      "references": [
        {
          "chunk": "command_channel_functions",
          "topic": "what the command channel is used for"
        },
        {
          "chunk": "direct_access_programming_overview",
          "topic": "data channels and direct-access programming (Chapter 5)"
        }
      ]
    },
    {
      "start": 532,
      "end": 532,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 533,
      "end": 555,
      "name": "command_channel_functions",
      "description": "Section 2.3: The command channel (secondary address 15) functions: monitor drive error status, send DOS housekeeping commands (format, scratch, rename), and instruct DOS to read/write specific disk areas. Notes that Chapter 5 covers reading/writing in detail.",
      "references": [
        {
          "chunk": "using_command_channel_steps",
          "topic": "how to use the command channel from BASIC (OPEN/PRINT#/GET#/CLOSE)"
        }
      ]
    },
    {
      "start": 556,
      "end": 569,
      "name": "using_command_channel_steps",
      "description": "Section 2.4: Four-step recipe to use the command channel from BASIC: (1) OPEN the channel, (2) send commands with PRINT#, (3) read messages with GET# or INPUT#, (4) CLOSE the channel.",
      "references": [
        {
          "chunk": "open_statement_syntax_and_usage",
          "topic": "OPEN statement details"
        },
        {
          "chunk": "print_command_syntax_and_notes",
          "topic": "PRINT# command usage"
        },
        {
          "chunk": "input_get_syntax_and_usage",
          "topic": "GET# and INPUT# to read DOS responses"
        },
        {
          "chunk": "close_statement_and_channel_behaviour",
          "topic": "closing channels and effects"
        }
      ]
    },
    {
      "start": 570,
      "end": 570,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 571,
      "end": 597,
      "name": "open_statement_syntax_and_usage",
      "description": "OPEN statement for establishing communication to the 1541: SYNTAX: OPEN file#, device, channel; EXAMPLE: OPEN 15,8,15. Explains file# (1-127), device (8 typical), channel (2-15; 15 = command channel). Notes channels 0 & 1 reserved for DOS; 2-14 are data channels. OPEN may be used in immediate mode or in programs.",
      "references": [
        {
          "chunk": "using_command_channel_steps",
          "topic": "overall steps to use command channel"
        }
      ]
    },
    {
      "start": 598,
      "end": 632,
      "name": "print_command_syntax_and_notes",
      "description": "PRINT# usage to send commands to the disk: SYNTAX: PRINT# file#, \"command\". EXAMPLE: PRINT#15,\"NO: MY DISKETTE, MD\". Explains the 'NO:' (NEW) command, parameters (disk name up to 16 chars, comma, two-character disk ID written to each sector), and the important syntax detail — PRINT# (no space before '#') and don't use ?# abbreviation.",
      "references": [
        {
          "chunk": "new_command_syntax_and_parameters",
          "topic": "NEW command example and ID semantics"
        }
      ]
    },
    {
      "start": 633,
      "end": 633,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 634,
      "end": 668,
      "name": "input_get_syntax_and_usage",
      "description": "INPUT# and GET# to read DOS responses from the command channel: SYNTAX: INPUT# file#, varlist or GET# file#, varlist. INPUT# reads through the next carriage return (used mainly for error status monitoring); GET# reads a single byte (commonly used in direct-access programming). Notes: correct keywords are INPUT# and GET# (no space before '#'); they cannot be used in immediate mode.",
      "references": [
        {
          "chunk": "checking_error_status_subroutine",
          "topic": "example that reads error status using INPUT#"
        }
      ]
    },
    {
      "start": 669,
      "end": 699,
      "name": "checking_error_status_subroutine",
      "description": "Example BASIC subroutine to check the drive error status using the command channel: OPEN 15,8,15 ; INPUT#15,EN,EM$,ET,ES ; checks error code EN (<20 means no error) ; prints EN, EM$, ET, ES ; CLOSE 15. Explains EN (error number), EM$ (message), ET (track), ES (sector), and refers to full error list in the 1541 User's Manual and Chapter 7.",
      "references": [
        {
          "chunk": "input_get_syntax_and_usage",
          "topic": "uses INPUT# to read the error message"
        },
        {
          "chunk": "validate_operation_and_risks_unclosed_files",
          "topic": "error handling and consequences during validate/housekeeping"
        }
      ]
    },
    {
      "start": 700,
      "end": 727,
      "name": "close_statement_and_channel_behaviour",
      "description": "CLOSE statement usage: SYNTAX: CLOSE file#. EXAMPLE: CLOSE 15. Notes that loading/running/editing closes communication channels automatically; the command channel is closed properly but data channels are aborted (not closed) which can leave files not properly closed on the drive. Recommends habitually closing files when finished.",
      "references": [
        {
          "chunk": "input_get_syntax_and_usage",
          "topic": "closing after reading error messages"
        }
      ]
    },
    {
      "start": 728,
      "end": 754,
      "name": "disk_housekeeping_overview",
      "description": "Section 2.5: Disk housekeeping chores handled by DOS: NEW (format), ERASE, INITIALIZE, RENAME, SCRATCH (delete), COPY. Notes that these commands are executed by the drive independently while the computer can continue working until the next disk operation is attempted.",
      "references": [
        {
          "chunk": "new_command_syntax_and_parameters",
          "topic": "formatting (NEW) command details"
        },
        {
          "chunk": "initialize_command_purpose_and_syntax",
          "topic": "INITIALIZE command details"
        },
        {
          "chunk": "rename_command_syntax_and_restrictions",
          "topic": "RENAME command details"
        },
        {
          "chunk": "copy_command_syntax_and_restrictions",
          "topic": "COPY command details"
        },
        {
          "chunk": "scratch_command_wildcards_unclosed_files_and_consequences",
          "topic": "SCRATCH command and unclosed-file risks"
        },
        {
          "chunk": "validate_command_syntax",
          "topic": "VALIDATE command"
        }
      ]
    },
    {
      "start": 755,
      "end": 763,
      "name": "dos_support_short_syntax_note",
      "description": "Note about the DOS SUPPORT program (from 1541TEST/DEMO): it provides a shorter syntax for sending commands using > or @ keys, automatically handles opening/closing and quoting. This reduced syntax works only in immediate mode, not in programs.",
      "references": [
        {
          "chunk": "using_command_channel_steps",
          "topic": "alternative immediate-mode shortcut for command entry"
        }
      ]
    },
    {
      "start": 764,
      "end": 764,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 765,
      "end": 816,
      "name": "new_command_syntax_and_parameters",
      "description": "The NEW (format) command syntax and parameters: OPEN 15,8,15 ; PRINT#15,\"NO:DISK NAME, ID\" ; CLOSE 15. Explains NO: (N = NEW, 0 optional drive number), disk name (up to 16 chars, cosmetic), comma, two-character disk ID (written to every sector and used to prevent accidental overwrites). Notes that a 'full' new formats all tracks and takes ~2-3 minutes.",
      "references": [
        {
          "chunk": "dos_support_short_syntax_note",
          "topic": "alternate short syntax in DOS SUPPORT"
        },
        {
          "chunk": "short_new_vs_full_new_and_notes",
          "topic": "short new (erase) behavior"
        }
      ]
    },
    {
      "start": 817,
      "end": 848,
      "name": "short_new_vs_full_new_and_notes",
      "description": "Explains the 'short' new (omit ID): PRINT#15,\"NO:DISK NAME\" or PRINT#15,\"N:DISK NAME\" — only works on previously formatted disks; it erases first directory sector and writes empty BAM (track 18 sectors 0-1) without reformatting entire disk. Advises copying files before doing a 'full' new on disks with read/write errors, and notes short new won't fix physical sector errors.",
      "references": [
        {
          "chunk": "new_command_syntax_and_parameters",
          "topic": "NEW command and ID semantics"
        },
        {
          "chunk": "getting_out_of_trouble_recovery_methods",
          "topic": "see Chapter 8 for recovery from new-related problems"
        }
      ]
    },
    {
      "start": 849,
      "end": 850,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 851,
      "end": 897,
      "name": "initialize_command_purpose_and_syntax",
      "description": "INITIALIZE command: not formatting. Syntax: OPEN 15,8,15 ; PRINT#15,\"I0\" (or \"I\") ; CLOSE 15. INITIALIZE reads the disk ID and BAM into the drive's internal memory so DOS knows where to write next. Recommends initializing each time a disk is inserted (don't rely on autoinit). INITIALIZE clears the error channel and turns off flashing LED; retrieve error status before initializing if needed.",
      "references": [
        {
          "chunk": "bam_sector_dump_and_overview",
          "topic": "BAM resides on track 18 sector 0 and is read into memory by INITIALIZE"
        }
      ]
    },
    {
      "start": 898,
      "end": 898,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 899,
      "end": 934,
      "name": "rename_command_syntax_and_restrictions",
      "description": "RENAME command syntax: OPEN 15,8,15 ; PRINT#15,\"R0:NEW NAME=OLD NAME\" ; CLOSE 15 (alternate: 'R:NEW=OLD'). Explains RO: (rename on drive 0, 0 optional), new file name up to 16 alphanumeric chars (no commas/colons/semicolons/wildcards or cursor control chars), exact spelling required for old name, cannot rename a file currently open for read/write.",
      "references": [
        {
          "chunk": "scratch_command_wildcards_unclosed_files_and_consequences",
          "topic": "effects of unclosed files on directory operations"
        }
      ]
    },
    {
      "start": 935,
      "end": 971,
      "name": "copy_command_syntax_and_restrictions",
      "description": "COPY command syntax: OPEN 15,8,15 ; PRINT#15,\"CO:NEW=0:ORIGINAL\" ; CLOSE 15. 'C' short for COPY. Restrictions: new file must have different name, COPY doesn't work on relative files, and there must be enough space on the disk. Drive numbers are optional on single-drive setups.",
      "references": [
        {
          "chunk": "copy_command_append_multiple_files",
          "topic": "copy can also combine sequential files"
        }
      ]
    },
    {
      "start": 972,
      "end": 1011,
      "name": "copy_command_append_multiple_files",
      "description": "COPY command can append multiple sequential data files into one target file using syntax: PRINT#15,\"CO:COMBINED=0:FILE1,0:FILE2,0:FILE3\". While available, merging files this way is rarely used and cannot append a subroutine into a BASIC program (use third-party tools to merge into BASIC).",
      "references": [
        {
          "chunk": "copy_command_syntax_and_restrictions",
          "topic": "basic copy usage and restrictions"
        }
      ]
    },
    {
      "start": 1012,
      "end": 1013,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1014,
      "end": 1036,
      "name": "scratch_command_overview_and_basic_syntax",
      "description": "Introduces the Scratch (delete) command, defines an unclosed file (directory entry with zero blocks and file-type preceded by '*'), and shows the basic syntax to scratch a file from BASIC: OPEN 15,8,15; PRINT#15,\"SO:FILE NAME\"; CLOSE 15. Includes the alternate shorthand PRINT* 15,\"S:FILE NAME\", a worked example and DOS 5.1 prompt examples.",
      "references": [
        {
          "chunk": "wildcards_in_scratch_commands",
          "topic": "covers wildcard usage and cautions when scratching multiple files"
        },
        {
          "chunk": "unclosed_file_definition_and_causes",
          "topic": "gives the formal definition of an unclosed file and points to causes and recovery"
        }
      ]
    },
    {
      "start": 1037,
      "end": 1052,
      "name": "scratch_command_parameter_and_wildcard_introduction",
      "description": "Explains that the scratch command requires a single parameter (the file name, preceded by S or SCRATCH) and introduces wildcards in file names: asterisk (*) and question mark (?). Warns to use wildcards with extreme caution because multiple files may be affected. Begins an example showing use of the asterisk wildcard (files beginning with a given letter).",
      "references": [
        {
          "chunk": "scratch_command_overview_and_basic_syntax",
          "topic": "contains the core OPEN/PRINT# syntax examples"
        },
        {
          "chunk": "asterisk_wildcard_examples_and_dangers",
          "topic": "details examples of asterisk wildcard effects and catastrophic misuse"
        }
      ]
    },
    {
      "start": 1053,
      "end": 1070,
      "name": "asterisk_wildcard_examples_and_dangers",
      "description": "Shows a concrete example (T*) where all files beginning with a given letter are scratched and explains the behavior (no match → no scratch). Demonstrates a catastrophic example using SO:* which scratches every file on the diskette (equivalent to a short NEW) and warns to be careful.",
      "references": [
        {
          "chunk": "wildcards_in_scratch_commands",
          "topic": "general wildcard explanation and cautions"
        },
        {
          "chunk": "multiple_wildcards_and_priority_rules",
          "topic": "explains combining wildcards and how '*' takes priority over '?'"
        }
      ]
    },
    {
      "start": 1071,
      "end": 1088,
      "name": "question_mark_wildcard_usage_and_example",
      "description": "Describes the question-mark wildcard (?) as a mask for characters of no importance. Provides an example to scratch files whose eight-character names end in \".C64\" using four question marks (\"????.C64\"), explains why a trailing *.C64 would not match in that case, and gives sample filenames that would or would not be affected.",
      "references": [
        {
          "chunk": "asterisk_wildcard_examples_and_dangers",
          "topic": "shows how '*' behaves and why caution is needed"
        },
        {
          "chunk": "multiple_wildcards_and_priority_rules",
          "topic": "examples combining ? and * and discusses priority rules"
        }
      ]
    },
    {
      "start": 1089,
      "end": 1101,
      "name": "multiple_wildcards_and_priority_rules",
      "description": "Demonstrates using more than one wildcard in the same scratch command (example: \"T?ST*\") and lists filenames that would be scratched (TEST, TASTY, TESTING123) and one that would not (TOAST). Explains that '*' has priority over '?' — any characters after '*' are ignored — and notes nonsensical patterns like \"T*ST???\".",
      "references": [
        {
          "chunk": "question_mark_wildcard_usage_and_example",
          "topic": "covers '?' usage and examples"
        },
        {
          "chunk": "asterisk_wildcard_examples_and_dangers",
          "topic": "covers '*' examples including disk-wide scratch"
        }
      ]
    },
    {
      "start": 1102,
      "end": 1122,
      "name": "unclosed_file_definition_and_common_causes",
      "description": "Defines an unclosed file type (file-type byte begins with '*', e.g., *SEQ, *PRG) indicating the file was never properly closed. Lists common causes: (1) disk-full during save/write, (2) bad sector encountered during write, (3) file left open because the program forgot to CLOSE or the program was aborted (RUN/STOP or RUN/STOP+RESTORE), and (4) the program had a syntax error returning to immediate mode. References Chapter 8 for recovery procedures.",
      "references": [
        {
          "chunk": "scratch_command_overview_and_basic_syntax",
          "topic": "initial defines unclosed files in the context of the scratch command"
        },
        {
          "chunk": "warnings_consequences_and_recovery_after_scratch",
          "topic": "explains why unclosed files must not be scratched and how to validate/recover"
        }
      ]
    },
    {
      "start": 1123,
      "end": 1140,
      "name": "warnings_consequences_and_recovery_after_scratch",
      "description": "Strongly warns never to scratch an unclosed file because aborted writes leave the disk's internal organization (BAM) inconsistent with file contents; further writes can overwrite active files and cause overlapping files and a 'poisoned' disk. Advises using the DOS validate command when in doubt. Explains that scratch does not physically erase data but frees sectors and zeroes the file-type byte in the directory; if you inadvertently scratch a file, stop and do not write to the disk — recovery is possible if you avoid subsequent writes. Points to Chapter 8 for detailed recovery steps.",
      "references": [
        {
          "chunk": "unclosed_file_definition_and_common_causes",
          "topic": "lists the causes of unclosed files referenced here"
        },
        {
          "chunk": "scratch_command_overview_and_basic_syntax",
          "topic": "contains the core scratch syntax and examples"
        }
      ]
    },
    {
      "start": 1141,
      "end": 1141,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1142,
      "end": 1167,
      "name": "validate_command_syntax",
      "description": "VALIDATE command syntax: OPEN 15,8,15 ; PRINT#15,\"VO\" (or \"V\") ; CLOSE 15. 'V' is VALIDATE; 0 (drive number) optional on a single 1541. VALIDATE reconstructs the BAM by freeing all blocks, tracing each directory file and marking blocks in use, then writing the new BAM to disk.",
      "references": [
        {
          "chunk": "bam_sector_dump_and_overview",
          "topic": "the BAM on track 18 sector 0 is rebuilt by VALIDATE"
        }
      ]
    },
    {
      "start": 1168,
      "end": 1168,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1169,
      "end": 1223,
      "name": "validate_operation_and_risks_unclosed_files",
      "description": "Detailed behavior of VALIDATE: It frees all blocks in the BAM, traces each file listed in directory to re-allocate blocks, then writes the new BAM. If it encounters an unclosed file, the file-type byte is set to 0 (scratched) and its blocks are not traced (they become free). Explains why SCRATCHing an unclosed file is dangerous (it may deallocate sectors that belong to other files leading to a poisoned disk). VALIDATE aborts if unreadable sectors encountered; new BAM is not written until process completes, so DOS falls back to old BAM if aborted. Recommends recovery procedures covered in Chapter 8.",
      "references": [
        {
          "chunk": "scratch_command_wildcards_unclosed_files_and_consequences",
          "topic": "contrast VALIDATE vs SCRATCH on unclosed files"
        },
        {
          "chunk": "getting_out_of_trouble_recovery_methods",
          "topic": "recovery procedures for aborted validates and corrupted disks"
        }
      ]
    },
    {
      "start": 1224,
      "end": 1240,
      "name": "diskette_formatting_overview",
      "description": "Chapter 3 overview: When a diskette is new it must be formatted (NEW). Formatting writes 35 concentric tracks and creates sectors (varying by track), a directory, and the Block Availability Map (BAM) on track 18. Introduces that each sector is composed of a header block and a data block.",
      "references": [
        {
          "chunk": "layout_of_tracks_and_sectors",
          "topic": "detailed track and sector organization"
        },
        {
          "chunk": "header_block_structure_and_fields",
          "topic": "header block contents"
        },
        {
          "chunk": "data_block_structure_and_fields",
          "topic": "data block contents"
        }
      ]
    },
    {
      "start": 1241,
      "end": 1295,
      "name": "layout_of_tracks_and_sectors",
      "description": "Section 3.1: Tracks (1-35) are concentric; track 1 outermost, track 35 innermost. Each track is divided into 17 or more sectors; each sector holds 256 bytes. Commodore uses zone bit rates: outer tracks have more sectors. Table of track zones: Zone 1 (tracks 1-17) sectors 0-20 (21 sectors), Zone 2 (18-24) 19 sectors, Zone 3 (25-30) 18 sectors, Zone 4 (31-35) 17 sectors. Total of 683 sectors created at format time. Effective usable sectors after directory/BAM reduce to 664 sectors (169,984 bytes).",
      "references": [
        {
          "chunk": "zone_clock_rates_and_capacity",
          "topic": "clock rates and bits/rotation per zone"
        },
        {
          "chunk": "sector_structure_overview",
          "topic": "how each sector is organized (header + data blocks)"
        }
      ]
    },
    {
      "start": 1296,
      "end": 1363,
      "name": "zone_clock_rates_and_capacity",
      "description": "Explains how Commodore varies the data clock rate per zone to pack more sectors on outer tracks. Lists divisors and clock rates: Zone 1 divisor 13 → 307,692 bits/sec (61,538.4 bits/rotation), Zone 2 divisor 14 → 285,714 bits/sec, Zone 3 divisor 15 → 266,667 bits/sec, Zone 4 divisor 16 → 250,000 bits/sec. Recording density varies across disk; formatted disk capacity and effective usable bytes are given (total storage vs usable after overhead).",
      "references": [
        {
          "chunk": "layout_of_tracks_and_sectors",
          "topic": "zone concept and sector counts per track"
        }
      ]
    },
    {
      "start": 1364,
      "end": 1364,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1365,
      "end": 1433,
      "name": "sector_structure_overview",
      "description": "Section 3.2: Each sector contains a header block (identifying the sector) followed by a data block (256 bytes). Sectors are separated by inter-record gaps and each block begins with a SYNC MARK (10+ ones, typically 40) to signal start of header/data block. Header blocks are written only during formatting; data blocks are rewritten when data is recorded.",
      "references": [
        {
          "chunk": "header_block_structure_and_fields",
          "topic": "header block byte-by-byte description"
        },
        {
          "chunk": "data_block_structure_and_fields",
          "topic": "data block fields, checksums, off bytes, and tail gap"
        }
      ]
    },
    {
      "start": 1434,
      "end": 1537,
      "name": "header_block_structure_and_fields",
      "description": "Section 3.3: Header block layout: SYNC MARK, Header ID byte ($08), Header checksum (EOR of track, sector, two ID bytes), Sector number, Track number, ID char #2 (ID HI), ID char #1 (ID LO), several $0F 'OFF' bytes used as padding during format, and a header gap of eight $55 bytes (4040 uses nine). Note that header block is written only during formatting and never rewritten.",
      "references": [
        {
          "chunk": "sector_structure_overview",
          "topic": "header vs data block roles"
        },
        {
          "chunk": "bam_sector_dump_and_overview",
          "topic": "location and format differences that affect compatibility (4040 vs 1541)"
        }
      ]
    },
    {
      "start": 1538,
      "end": 1539,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1540,
      "end": 1635,
      "name": "data_block_structure_and_fields",
      "description": "Section 3.4: Data block layout: SYNC MARK, Data Block ID byte (normally $07), 256 data bytes (DOS uses first two bytes as forward track/sector pointer for chained sectors), Data Block checksum (EOR of all 256 data bytes), two $00 OFF bytes (padding), and the inter-sector (tail) gap. Inter-sector gap length varies by zone and drive (4-12 bytes between sectors typical; longer between last sector and sector 0). Data blocks (including sync) are rewritten whenever data is recorded.",
      "references": [
        {
          "chunk": "header_block_structure_and_fields",
          "topic": "differences between header and data blocks"
        }
      ]
    },
    {
      "start": 1636,
      "end": 1664,
      "name": "information_management_and_directory_location",
      "description": "Chapter 4, Section 4.1: Overview of DOS information management tasks: keep track of free vs used sectors, assign names and locations to files, and track sector chains for files. DOS stores directory and BAM on track 18 (BAM at sector 0; directory entries in sectors 1-18), centering directory to minimize head movement.",
      "references": [
        {
          "chunk": "bam_sector_dump_and_overview",
          "topic": "BAM layout and example dump"
        },
        {
          "chunk": "directory_entries_overview_and_track18_sector1_example",
          "topic": "directory entries layout and example (track 18 sector 1)"
        }
      ]
    },
    {
      "start": 1665,
      "end": 1665,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1666,
      "end": 1679,
      "name": "how_to_display_the_directory",
      "description": "Section heading and the exact keystrokes to display the directory for the 1541TEST/DEMO disk: LOAD \"*0\",8 then LIST. Includes the immediate (brief) output shown before the directory itself appears (the '35' output) and prepares the reader for the following directory display.",
      "references": [
        {
          "chunk": "example_directory_listing_output",
          "topic": "contains the directory text that appears after these commands"
        },
        {
          "chunk": "directory_header_and_entry_fields",
          "topic": "explains the fields shown in the displayed directory"
        }
      ]
    },
    {
      "start": 1680,
      "end": 1782,
      "name": "example_directory_listing_output",
      "description": "The full on-screen directory listing produced for the 1541TEST/DEMO disk. Shows: drive number (0), quoted disk name ('1541 TEST /DEMO' padded to 16 chars), disk ID (ZX), DOS version/format (2A), a sequence of directory entries each showing blocks used, filename in quotes, and file type (PRG), and the final '558 BLOCKS FREE.' count.",
      "references": [
        {
          "chunk": "how_to_display_the_directory",
          "topic": "how to produce this listing with LOAD \"*0\",8 and LIST"
        },
        {
          "chunk": "directory_header_and_entry_fields",
          "topic": "breaks down the meaning of the drive number, disk name/ID, DOS version, and the three fields in each directory entry"
        },
        {
          "chunk": "active_files_and_blocks_free_calculation",
          "topic": "shows how the 'BLOCKS FREE' value is calculated from formatted capacity and file block usage"
        }
      ]
    },
    {
      "start": 1783,
      "end": 1799,
      "name": "directory_header_and_entry_fields",
      "description": "Explains the elements shown at the top of the directory and the structure of each directory entry: the leading drive number (a holdover from dual-drive systems), the diskette name (padded to 16 characters — padding defined), the two-character disk ID (cosmetic, often the original formatting ID), and the DOS version/format indicator (e.g., '2A', another legacy holdover). Also enumerates the three fields present in each directory entry: 1) number of blocks/sectors the file occupies, 2) the file name, and 3) the file type.",
      "references": [
        {
          "chunk": "example_directory_listing_output",
          "topic": "the sample listing that uses these header fields and entry fields"
        },
        {
          "chunk": "active_files_and_blocks_free_calculation",
          "topic": "uses the entry block counts to compute blocks free"
        },
        {
          "chunk": "display_vs_on_disk_and_bam_intro",
          "topic": "notes that the displayed directory is a presentation and introduces the BAM as the on-disk structure to be examined next"
        }
      ]
    },
    {
      "start": 1800,
      "end": 1805,
      "name": "active_files_and_blocks_free_calculation",
      "description": "Describes the contents summary in the example: the demo disk has 15 active files (all PRG), and the final directory line shows remaining available blocks. Explains the arithmetic used to obtain '558 BLOCKS FREE' as the formatted capacity (664 blocks) minus the sum of blocks used by active files (664 - 106 = 558).",
      "references": [
        {
          "chunk": "example_directory_listing_output",
          "topic": "where the '15 active files', 'PRG' types, and '558 BLOCKS FREE.' appear"
        },
        {
          "chunk": "directory_header_and_entry_fields",
          "topic": "the block counts referenced come from the per-file directory entry fields"
        },
        {
          "chunk": "display_vs_on_disk_and_bam_intro",
          "topic": "leads into examining on-disk structures (BAM) that record free/used blocks"
        }
      ]
    },
    {
      "start": 1806,
      "end": 1809,
      "name": "display_vs_on_disk_and_bam_intro",
      "description": "Notes that the textual directory displayed on-screen is not necessarily the same as how directory information is stored on the disk. Introduces the Block Availability Map (BAM) as the next topic to examine the disk's actual allocation map.",
      "references": [
        {
          "chunk": "directory_header_and_entry_fields",
          "topic": "contrasts the on-screen fields with the underlying on-disk structures"
        },
        {
          "chunk": "active_files_and_blocks_free_calculation",
          "topic": "the BAM is the structure that actually tracks free/used blocks used to compute 'blocks free'"
        },
        {
          "chunk": "example_directory_listing_output",
          "topic": "the displayed listing whose on-disk representation will be explored via the BAM"
        }
      ]
    },
    {
      "start": 1810,
      "end": 1889,
      "name": "bam_sector_dump_and_overview",
      "description": "Section 4.3: Hex dump example of track 18 sector 0 (the BAM) from the 1541TEST/DEMO disk. Shows BAM bytes for tracks (bytes 4-143), disk name (bytes 144-159), disk ID (bytes 162-163), DOS version/format type (bytes 165-166), and unused area. Illustrates the BAM does not occupy the entire sector and includes other directory information.",
      "references": [
        {
          "chunk": "bam_structure_and_field_offsets",
          "topic": "table mapping byte offsets to BAM contents"
        },
        {
          "chunk": "bam_entry_format_and_track14_example",
          "topic": "how each track is represented by four bytes in the BAM"
        }
      ]
    },
    {
      "start": 1890,
      "end": 1926,
      "name": "bam_structure_and_field_offsets",
      "description": "Table of the BAM sector (track 18 sector 0) byte field offsets and purposes: bytes 0-1 pointer to first directory sector (18/1), byte 2 ASCII format char (A = 1541/4040 format), byte 3 unused, bytes 4-143 the Block Availability Map (4 bytes per track for 35 tracks = 140 bytes), bytes 144-159 diskette name (ASCII padded), bytes 160-161 shifted spaces, bytes 162-163 disk ID, bytes 165-166 DOS version/format type (e.g., 2A), remaining bytes unused.",
      "references": [
        {
          "chunk": "bam_sector_dump_and_overview",
          "topic": "example hex dump of the BAM"
        },
        {
          "chunk": "bam_entry_format_and_track14_example",
          "topic": "per-track four-byte BAM entry unpacked"
        }
      ]
    },
    {
      "start": 1927,
      "end": 1928,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 1929,
      "end": 1950,
      "name": "bam_entry_format_and_track14_example",
      "description": "Explains that the BAM uses 4 bytes per track: first byte = number of free blocks on that track; next three bytes = bit map (1 bit per sector) describing free (1) vs allocated (0) sectors for up to 21 sectors per track. Example: track 14 entry located at byte 14*4 = $38 shows first byte $11 (decimal 17 free blocks) and the next three bytes form the bit map.",
      "references": [
        {
          "chunk": "bam_bit_map_for_track14",
          "topic": "detailed bit-map decoding for track 14"
        }
      ]
    },
    {
      "start": 1951,
      "end": 2203,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 2204,
      "end": 2246,
      "name": "bam_entries_11_zone_and_total_blocks_free_explanation",
      "description": "Final BAM table rows showing HEX $11 entries and the summed total line ('+ 17' and '574  BLOCKS  FREE') followed by an explanatory note. The note explains the discrepancy between the raw calculated free blocks (574) and the directory-reported 'blocks free' (558) by noting that DOS reserves track 18 for its own use (16 sectors on that track remain free but are reserved and not reported).",
      "references": [
        {
          "chunk": "bam_entries_12_zone_and_garbled_rows",
          "topic": "precedes these final $11 rows"
        },
        {
          "chunk": "bam_table_zone_1f_entries",
          "topic": "the BAM table begins with $1F entries earlier in the listing"
        }
      ]
    },
    {
      "start": 2247,
      "end": 2296,
      "name": "bam_bit_map_for_track14",
      "description": "Detailed decoding of the three-bit-map bytes for track 14: shows the three bytes (locations $39-$3B) values (e.g., $D7, $5F, $1F) and their binary representations. Explains how bits map to sector numbers (byte for sectors 0-7, next for 8-15, third for 16-20), and that bit=1 denotes FREE, bit=0 denotes ALLOCATED. Confirms bit counts match the first-byte 'blocks free' value ($11 = 17).",
      "references": [
        {
          "chunk": "bam_entry_format_and_track14_example",
          "topic": "per-track BAM format"
        }
      ]
    },
    {
      "start": 2297,
      "end": 2297,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2298,
      "end": 2348,
      "name": "bam_track18_bit_map_example",
      "description": "Example decoding of BAM entry for track 18 (the directory track): shows bytes $EC, $FF, $07 corresponding to binary patterns and explains free sectors mapping (e.g., 16 sectors free as indicated by first byte $10). Demonstrates how partial (third) bitmap byte is used since max sectors per track is 21.",
      "references": [
        {
          "chunk": "bam_bit_map_for_track14",
          "topic": "similar bit-map decoding technique applied to track 18"
        },
        {
          "chunk": "directory_entries_overview_and_track18_sector1_example",
          "topic": "directory sectors reside on track 18 sectors 1-18"
        }
      ]
    },
    {
      "start": 2349,
      "end": 2359,
      "name": "directory_entries_intro_track18_sector1",
      "description": "Introductory text for section 4.4: explains that bytes 0-1 of track 18 sector 0 point to the next directory block, states that the BAM points to track 18 sector 1, and labels the raw dump for the disk image (\"1541 TEST /DEMO\" and \"TRACK 18 - SECTOR 01\"). This chunk prepares the reader for the detailed sector dump that follows.",
      "references": [
        {
          "chunk": "file_entry_how_to_use_#1",
          "topic": "first directory/file entry dump (HOW TO USE)"
        },
        {
          "chunk": "file_entry_part_tw_#2",
          "topic": "second directory/file entry dump (PART TW)"
        }
      ]
    },
    {
      "start": 2360,
      "end": 2404,
      "name": "file_entry_how_to_use_#1",
      "description": "Raw hex + ASCII dump and decoded text for directory FILE ENTRY #1. Contains the bytes and ASCII showing the filename fragment \"HOW TO USE\" (shown as hex bytes and padded area), and the contextual offsets and padding for this entry as found in track 18 sector 1.",
      "references": [
        {
          "chunk": "directory_entries_intro_track18_sector1",
          "topic": "sector header and context"
        },
        {
          "chunk": "file_entry_part_tw_#2",
          "topic": "next directory/file entry (ENTRY #2)"
        }
      ]
    },
    {
      "start": 2405,
      "end": 2968,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 2969,
      "end": 3000,
      "name": "directory_sector_entry_format",
      "description": "Formal layout of any directory sector: byte 0 = track of next directory block, byte 1 = sector of next directory block, bytes 2-31 = File entry #1 (32 bytes), bytes 32-33 unused, bytes 34-63 = File entry #2, bytes 64-65 unused, bytes 66-95 = File entry #3, bytes 96-97 unused, bytes 98-127 = File entry #4, bytes 128-129 unused, bytes 130-159 = File entry #5, etc. Specifies the structure used to store multiple file entries per directory sector.",
      "references": [
        {
          "chunk": "directory_entries_overview_and_track18_sector1_example",
          "topic": "example dump showing this byte layout in practice"
        },
        {
          "chunk": "bam_sector_dump_and_overview",
          "topic": "BAM links and directory pointer at bytes 0-1 of the BAM sector"
        }
      ]
    },
    {
      "start": 3001,
      "end": 3030,
      "name": "directory_sector_layout_table",
      "description": "Table describing the layout of a directory sector: byte offsets and their purposes. Lists bytes 0-1 as forward pointer to next directory block, eight file entry slots (bytes ranges 2-31, 34-63, ... 226-255) and unused/gap bytes between entries.",
      "references": [
        {
          "chunk": "sample_directory_sector_raw_dump",
          "topic": "example hex dump"
        },
        {
          "chunk": "single_directory_file_entry_example",
          "topic": "how an individual file entry is stored within those byte ranges"
        }
      ]
    },
    {
      "start": 3031,
      "end": 3074,
      "name": "single_directory_file_entry_example",
      "description": "Illustration of a single directory file entry (hex bytes shown). Introduction to the elements present in a file entry and note that eight file entries are stored per sector; leads into explanation of the significance of bytes 0-1 for the first sector.",
      "references": [
        {
          "chunk": "directory_sector_layout_table",
          "topic": "byte ranges for file entries"
        },
        {
          "chunk": "file_entry_forward_pointer_and_chaining",
          "topic": "how bytes 0-1 chain directory sectors"
        }
      ]
    },
    {
      "start": 3075,
      "end": 3075,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3076,
      "end": 3184,
      "name": "file_entry_forward_pointer_and_chaining",
      "description": "Explains the role of the first two bytes in a directory sector entry (forward pointer pointing to next directory sector). Discusses disk rotation, sector staggering (typically increments of 10; directory staggered by 3) and gives the sector filling sequence for a full directory (lists sequences for sectors 0(BAM), 1,4,7,... etc).",
      "references": [
        {
          "chunk": "directory_sector_layout_table",
          "topic": "location of the forward pointer in the directory sector"
        },
        {
          "chunk": "sample_directory_sector_raw_dump",
          "topic": "example where bytes point to next directory block"
        }
      ]
    },
    {
      "start": 3185,
      "end": 3272,
      "name": "file_type_byte_and_file_types_table_part1",
      "description": "Introduces the file-type byte (first byte) in a directory file entry. Begins the Commodore file types table, covering file types such as $00 (scratched), $80 (deleted), $81 (sequential), $82 (program/PRG), $83 (user/USR), $84 (relative/REL), and the unclosed variants ($01-$04) up through $03 entries. Explains that $82 indicates a PRG in examples.",
      "references": [
        {
          "chunk": "file_types_table_part2",
          "topic": "continuation of the file type table"
        },
        {
          "chunk": "single_directory_file_entry_example",
          "topic": "example showing $82 program file"
        }
      ]
    },
    {
      "start": 3273,
      "end": 3275,
      "ignore": true,
      "reason": "Note line about editing file-type byte and unusual types; treated with the file types table chunk."
    },
    {
      "start": 3276,
      "end": 3289,
      "name": "file_entry_start_pointer_to_first_sector",
      "description": "Explains bytes 2 and 3 in a directory file entry: a pointer (track, sector) to the first sector of that file on disk. Demonstrates how these two bytes are interpreted to find where the file's first block resides.",
      "references": [
        {
          "chunk": "single_directory_file_entry_example",
          "topic": "file entry showing pointer bytes"
        },
        {
          "chunk": "program_file_storage_description",
          "topic": "how the file's first sector is structured"
        }
      ]
    },
    {
      "start": 3290,
      "end": 3330,
      "name": "file_name_field_and_padded_shifted_spaces",
      "description": "Describes the filename field in a directory entry: file names are up to 16 characters padded with shifted-space ($A0) characters. The shifted spaces do not display as part of the name in directory listings. Example: 'HOW TO USE' is stored with $A0 padding.",
      "references": [
        {
          "chunk": "single_directory_file_entry_example",
          "topic": "example showing name bytes"
        },
        {
          "chunk": "program_file_storage_description",
          "topic": "how filenames relate to file data"
        }
      ]
    },
    {
      "start": 3331,
      "end": 3351,
      "name": "relative_file_fields_and_reserved_null_bytes",
      "description": "Explains bytes reserved for relative files and unused fields in a standard directory entry: bytes $15-$16 point to the first set of side sectors for relative (REL) files, $17 holds the record size for relative files, and the next four bytes are unused (null) for other file types.",
      "references": [
        {
          "chunk": "file_types_table_part2",
          "topic": "relative file type ($84) explained"
        }
      ]
    },
    {
      "start": 3352,
      "end": 3371,
      "name": "at_replacement_reserved_bytes_and_process",
      "description": "Details the two bytes reserved for DOS during an @-replacement (SAVE \"@0:...\",8) operation: during @ replacement the file-type byte is ORed with $20, bytes 28-29 hold the track/sector pointer to the new copy while the copy is written, then these are moved to bytes 3-4 and restored. Mentions a bug in the @ replacement (see Chapter 9).",
      "references": [
        {
          "chunk": "file_entry_start_pointer_to_first_sector",
          "topic": "how the track/sector pointer is used"
        }
      ]
    },
    {
      "start": 3372,
      "end": 3373,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3374,
      "end": 3410,
      "name": "file_block_count_bytes",
      "description": "Explains the final two bytes of a directory entry: the number of blocks the file occupies on disk. The value is low-byte + high-byte * 256. Example calculation: 13 + 0*256 = 13 blocks in the sample entry.",
      "references": [
        {
          "chunk": "single_directory_file_entry_example",
          "topic": "example with block count bytes"
        }
      ]
    },
    {
      "start": 3411,
      "end": 3479,
      "name": "directory_example_entries_1_to_4",
      "description": "Breakdown of the first four directory entries from the 1541TEST/DEMO disk (track 18, sector 01): shows raw bytes for each directory entry (entry 1..4), the decoded file type ($82 = PRG), start track/sector, filename, and file length in blocks. Entries include 'HOW TO USE', 'HOW PART TWO', 'VIC-20 WEDGE', 'C-64 WEDGE'.",
      "references": [
        {
          "chunk": "directory_sector_layout_table",
          "topic": "which byte ranges these entries occupy"
        },
        {
          "chunk": "file_types_table_part1",
          "topic": "interpreting the file type $82"
        }
      ]
    },
    {
      "start": 3480,
      "end": 3550,
      "name": "directory_example_entries_5_to_8",
      "description": "Breakdown of directory entries 5-8 from the 1541TEST/DEMO disk: shows raw bytes and decoded information for files like 'DOS 5.1', 'COPY/ALL', 'PRINTER TEST', 'DISK ADDR CHANGE' including file types ($82 PRG), start track/sector, names, and block counts.",
      "references": [
        {
          "chunk": "directory_example_entries_1_to_4",
          "topic": "continuation of example directory"
        }
      ]
    },
    {
      "start": 3551,
      "end": 3627,
      "name": "directory_chain_end_and_next_block_dump_intro",
      "description": "States that the next directory sector (track 18, sector 4) ends the directory chain (bytes 0 and 1 contain $00 and $FF), notes only seven entries present in that block and a null entry reserved for expansion. Begins the hex dump of track 18 sector 04.",
      "references": [
        {
          "chunk": "sample_directory_sector_raw_dump",
          "topic": "earlier example of directory sectors"
        }
      ]
    },
    {
      "start": 3628,
      "end": 4229,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 4230,
      "end": 4231,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4232,
      "end": 4252,
      "name": "virtual_directory_and_bam_display_utilities",
      "description": "Notes recommending four utilities (in Appendix C): DISPLAY TRACK & SECTOR (hex dump utility), DISPLAY A BLOCK AVAILABILITY MAP (BAM visualizer), VIRTUAL DIRECTORY (displays entire directory including scratched files), and DISPLAY A CHAIN (traces a file's sector chain). Mentions options for sending output to screen or printer and brief usage notes.",
      "references": [
        {
          "chunk": "sample_directory_sector_raw_dump",
          "topic": "hex dumps generated by DISPLAY TRACK & SECTOR"
        },
        {
          "chunk": "directory_block_04_dump_part7_bytes_C0_FF",
          "topic": "example produced by these utilities"
        }
      ]
    },
    {
      "start": 4253,
      "end": 4292,
      "name": "program_file_storage_introduction_4_5",
      "description": "Section 4.5 heading and introduction: explains that PRG (program) files are the most common and designated by $82 in the directory. Diagrammatic description of the first sector in a PRG file: bytes 0-1 are forward pointer to next block, bytes 2-3 are the load address (lo-byte, hi-byte), bytes 4-255 hold the first 252 bytes of program data.",
      "references": [
        {
          "chunk": "file_entry_start_pointer_to_first_sector",
          "topic": "the directory's start pointer directs to this first sector structure"
        }
      ]
    },
    {
      "start": 4293,
      "end": 4336,
      "name": "program_file_load_address_and_load_behavior",
      "description": "Explains the load address in bytes 2-3 of a PRG file's first sector. Example: BASIC programs saved from a C64 have $01/$08 indicating load at $0801 (decimal 2049). Discusses the effect of the optional relocation flag in LOAD commands (LOAD \"name\",8,1 vs LOAD \"name\",8) and how the presence/absence determines whether the load address is respected or the file is loaded at the default BASIC start.",
      "references": [
        {
          "chunk": "program_file_storage_introduction_4_5",
          "topic": "first sector layout"
        }
      ]
    },
    {
      "start": 4337,
      "end": 4374,
      "name": "program_file_following_sectors_and_last_sector_layout",
      "description": "Describes subsequent sectors of a PRG file: for non-final blocks bytes 0-1 are forward pointer to next block and bytes 2-255 contain 254 bytes of program data. For the last block: byte 0 = $00 (indicates last sector), byte 1 = number of bytes to read (N), bytes 2..N-1 are valid program data, remaining bytes are garbage.",
      "references": [
        {
          "chunk": "program_file_load_address_and_load_behavior",
          "topic": "how data is laid out after the load address"
        }
      ]
    },
    {
      "start": 4375,
      "end": 4404,
      "name": "dir_program_directory_entry_example",
      "description": "Directory entry example for the file 'DIR' on 1541TEST/DEMO (track 18 sector 04): shows entry bytes indicating 'DIR' starts at track 16 ($10) sector 01 and is 4 blocks long. Provides the directory entry hex bytes.",
      "references": [
        {
          "chunk": "directory_block_04_dump_part1_bytes_00_1F",
          "topic": "the 'DIR' entry appears in that sector dump"
        },
        {
          "chunk": "program_file_following_sectors_and_last_sector_layout",
          "topic": "how this entry maps to file blocks"
        }
      ]
    },
    {
      "start": 4405,
      "end": 4405,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4406,
      "end": 4445,
      "name": "dir_first_block_hex_dump_intro_header",
      "description": "Introductory text and block header for the hex/ASCII dump of the first data block of the 'DIR' program (Track 16, Sector 01). Covers the human-readable lead-in \"Let's look at the first block in this file.\" and the TRACK 16 - SECTOR 01 header, followed by the initial lines of the hex/ASCII dump (the beginning bytes and early token/ASCII fragments). This chunk provides context and the start of the block data.",
      "references": [
        {
          "chunk": "dir_first_block_hex_dump_bytes_0_31",
          "topic": "continues the dump with the next set of bytes and token/ASCII fragments"
        },
        {
          "chunk": "dir_first_block_hex_dump_bytes_32_63",
          "topic": "subsequent continuation of the block dump"
        },
        {
          "chunk": "dir_first_block_hex_dump_bytes_64_95",
          "topic": "further continuation of the block dump"
        },
        {
          "chunk": "dir_first_block_hex_dump_bytes_96_127",
          "topic": "final portion of this dump segment"
        }
      ]
    },
    {
      "start": 4446,
      "end": 4600,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 4601,
      "end": 4636,
      "name": "dir_block_chain_intro_and_58_block",
      "description": "Beginning of the continued DIR forward-chain hex/ASCII dump. Contains the preamble bytes and the first visible block header '58:' (line 4628) with the bytes and ASCII fragments that follow. Illustrates how a DOS block header appears in the dump and introduces the pattern of forward pointers and embedded C64 BASIC/tokenized data that makes much of the content non-human-readable.",
      "references": [
        {
          "chunk": "dir_block_chain_dump_b2_block",
          "topic": "next chained block in the dump (continues the DIR block chain)"
        },
        {
          "chunk": "dir_block_chain_and_additional_blocks_dump",
          "topic": "original larger dump this sequence continues from"
        }
      ]
    },
    {
      "start": 4637,
      "end": 4926,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 4927,
      "end": 4930,
      "name": "raw_block_dump_d0_d8",
      "description": "Uninterpreted raw block-dump lines for offsets D0: and D8:. Includes labeled D0:/D8: headers and the associated hex bytes and ASCII translations as presented in the DIR program's internal BASIC fragments.",
      "references": [
        {
          "chunk": "raw_block_dump_c0_c8",
          "topic": "C0: and C8: block-dump (previous group)"
        },
        {
          "chunk": "raw_block_dump_e0_e8_f0_f8",
          "topic": "E0:/E8:/F0:/F8: block-dumps (next group)"
        },
        {
          "chunk": "raw_block_dump_b0_b8",
          "topic": "B0: and B8: block-dump (related data)"
        }
      ]
    },
    {
      "start": 4931,
      "end": 4938,
      "name": "raw_block_dump_e0_e8_f0_f8",
      "description": "Uninterpreted raw block-dump lines for offsets E0:, E8:, F0:, and F8:. Contains the labeled headers (E0:/E8:/F0:/F8:), hex byte sequences and ASCII translations extracted from the DIR program's internal BASIC fragments.",
      "references": [
        {
          "chunk": "raw_block_dump_d0_d8",
          "topic": "D0: and D8: block-dump (previous group)"
        },
        {
          "chunk": "raw_block_dump_c0_c8",
          "topic": "C0: and C8: block-dump (related earlier data)"
        },
        {
          "chunk": "raw_block_dump_b0_b8",
          "topic": "B0: and B8: block-dump (related earlier data)"
        }
      ]
    },
    {
      "start": 4939,
      "end": 4952,
      "name": "track_sector_links_and_load_address_explanation",
      "description": "Interpretation and commentary for the preceding dumps: explains that bytes 0 and 1 are the track/sector link to the next block (here pointing to track $10 sector $0B), bytes 2 and 3 are the load address (here $0401), notes about this file being written on a PET, differences in BASIC start addresses on various machines, instructions to LOAD with relocation (LOAD \"DIR\",8), and a note about VERIFY failing because internal BASIC links changed when relocated. Includes the raw two-byte forward-link line that begins the forward chain.",
      "references": [
        {
          "chunk": "raw_internal_basic_block_dumps_offsets_a0_to_f8",
          "topic": "contains the raw internal BASIC byte listings being explained"
        },
        {
          "chunk": "forward_chain_and_track16_sector11_dump",
          "topic": "follows the track/sector forward chain to the next block (track 16, sector 11) and shows that block's contents"
        }
      ]
    },
    {
      "start": 4953,
      "end": 4969,
      "name": "forward_chain_and_track16_sector11_dump",
      "description": "Continuation of the forward-chain traversal: shows the forward-link block (.00: line with the link bytes) and then follows that link to track 16, sector 11. Contains the header 'TRACK 16 - SECTOR 11' and the initial byte/ASCII dump lines for that block (.00:, .08:, .10: lines) and a short remark that nothing of particular interest appears in this block.",
      "references": [
        {
          "chunk": "track_sector_links_and_load_address_explanation",
          "topic": "explains the meaning of the forward-link bytes that point to this block"
        },
        {
          "chunk": "track16_sector02_dump_and_notes",
          "topic": "continues chaining from this block to the next block (track 16, sector 02) and shows its contents"
        }
      ]
    },
    {
      "start": 4970,
      "end": 4985,
      "name": "track16_sector02_dump_and_notes",
      "description": "Shows the decision to chain on from track 16, sector 11 to track 16, sector 02 and provides the 'TRACK 16 - SECTOR 02' header with its byte/ASCII dump lines (.00:, .08:, .10:). Includes brief commentary that again nothing much of interest appears and prepares to chain to the subsequent block (track 16, sector 12).",
      "references": [
        {
          "chunk": "forward_chain_and_track16_sector11_dump",
          "topic": "previous block (track 16, sector 11) from which this block is reached"
        },
        {
          "chunk": "track16_sector12_dump_start",
          "topic": "next block in the chain (track 16, sector 12) whose dump begins immediately after this chunk"
        }
      ]
    },
    {
      "start": 4986,
      "end": 5000,
      "name": "track16_sector12_dump_start",
      "description": "Beginning of the listing for 'TRACK 16 - SECTOR 12': a short lead-in remark ('Again, nothing much of interest.'), the sector header, and the start of the byte dump for this sector (lines labeled 00: and following byte values). This chunk contains the initial fragment of the sector's raw bytes shown at the end of the original oversized chunk.",
      "references": [
        {
          "chunk": "track16_sector02_dump_and_notes",
          "topic": "previous sector (track 16, sector 02) in the chain that led to this sector"
        }
      ]
    },
    {
      "start": 5001,
      "end": 5311,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 5312,
      "end": 5322,
      "name": "last_sector_eof_and_eoi_behavior",
      "description": "Explanation of how to recognize the last sector of a file in Commodore DOS. Describes that a next-block track of $00 marks the final sector, the 'sector link' byte in the last block is actually a byte count (here indicating bytes 2..104 / $68 are valid), how BASIC's EOF is represented by three consecutive zero bytes, the End-or-Identify (EOI) serial signal sent after the indicated byte count, and that the C64 sets status variable ST to 64 on EOI. Also notes the three null bytes at $66/$67/$68 are the last bytes of the program file.",
      "references": [
        {
          "chunk": "dir_block_dump_hex_ascii_middle_blocks",
          "topic": "Shows the bytes that lead into this final-sector explanation"
        },
        {
          "chunk": "dir_block_dump_tail_blocks_00_08_10_18",
          "topic": "Shows the actual tail-end block dumps that contain the final three null bytes"
        }
      ]
    },
    {
      "start": 5323,
      "end": 5582,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 5583,
      "end": 5603,
      "name": "dir_sector_hex_ascii_dump_offset_68",
      "description": "Hex/ASCII dump for the directory sector bytes at offset 0x68 (end of the sector dump). Contains a run of placeholder/unused bytes (00, XX, XX, ...), followed by a final byte (52) and the closing ASCII/rendered line for the sector. This chunk completes the byte-by-byte listing for the example DIR file sector.",
      "references": [
        {
          "chunk": "dir_sector_hex_ascii_dump_offset_60",
          "topic": "previous offset block (0x60)"
        }
      ]
    },
    {
      "start": 5604,
      "end": 5612,
      "name": "last_block_padding_and_exceptions",
      "description": "Explains that the DOS does not zero unused bytes in a data block (they are 'garbage'), and notes two exceptions: partial directory blocks are padded with $00 and always appear as full blocks; bytes 0 and 1 of the last directory block contain $00 and $FF respectively. Mentions that relative file structure is handled differently (see relative_file_overview).",
      "references": [
        {
          "chunk": "sequential_file_sector_format",
          "topic": "standard sequential sector layout"
        },
        {
          "chunk": "relative_file_overview_and_block_format_intro",
          "topic": "relative file differences"
        }
      ]
    },
    {
      "start": 5613,
      "end": 5672,
      "name": "sequential_file_storage_introduction_4_6",
      "description": "Section 4.6 heading and introduction to sequential file storage: explains sector structure for sequential files (bytes 0-1 = forward pointer, bytes 2-255 = 254 bytes of data). Describes the special last block format (byte 0 = $00, byte 1 = position of last byte N, bytes 2..N are valid).",
      "references": [
        {
          "chunk": "program_file_following_sectors_and_last_sector_layout",
          "topic": "contrast between PRG and sequential last-block handling"
        }
      ]
    },
    {
      "start": 5673,
      "end": 5676,
      "name": "sequential_file_sector_format",
      "description": "Format of a standard sequential data block on the 1541/Commodore DOS: bytes 0 = track of next block (link), 1 = sector of next block (link), bytes 2-255 = 254 bytes of user data. For the last sector in a sequential file: byte 0 = $00 (indicates end-of-file), byte 1 = position of the last valid data byte (N); bytes beyond N are garbage.",
      "references": [
        {
          "chunk": "sequential_start_block_dump_part1",
          "topic": "example directory/data block using the above format"
        },
        {
          "chunk": "sequential_last_sector_example_and_padding",
          "topic": "example of a last sector with byte count and padding"
        }
      ]
    },
    {
      "start": 5677,
      "end": 5680,
      "name": "sequential_file_directory_entry_example",
      "description": "Explains that 1541TEST/DEMO contains no sequential files, but the C-64 DISK BONUS PACK contains a sequential file named \"DIRECTORY\". Shows the directory listing location (track 18, sector 01) and presents the directory entry bytes (hex and ASCII) for the file as displayed in the directory. Notes that sequential files are marked with $81, that the first data block for \"DIRECTORY\" is stored on track 17 ($11) sector 1 ($01), and that the file length is two blocks. Prepares to show the starting data block contents.",
      "references": [
        {
          "chunk": "sequential_file_starting_data_block_hex_dump",
          "topic": "hex dump and ASCII translation of the file's starting data block on track 17, sector 01"
        }
      ]
    },
    {
      "start": 5681,
      "end": 5716,
      "name": "sequential_files_demo_and_directory_entry",
      "description": "Notes that example disk images (1541TEST/DEMO) have no sequential files; explains that a sequential file is designated by $81 in the directory. Introduces the 'DIRECTORY' sequential file on the C-64 DISK BONUS PACK and shows its directory entry (track 18 sector 01 and starting block information).",
      "references": [
        {
          "chunk": "sequential_file_sector_format",
          "topic": "sequential block format (bytes 0-255)"
        },
        {
          "chunk": "sequential_start_block_dump_part1",
          "topic": "starting data block contents for the DIRECTORY file"
        }
      ]
    },
    {
      "start": 5717,
      "end": 6004,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 6005,
      "end": 6050,
      "name": "sequential_start_block_dump_part5_and_explanation",
      "description": "Final portion of the TRACK 17 - SECTOR 01 data block dump plus explanatory text: bytes 0 and 1 are the track/sector forward pointer (in this dump pointing to track 17, sector 11), the remaining 254 bytes are data (disk name, ID, file names). Notes that $0D (carriage return) is used as a delimiter between records.",
      "references": [
        {
          "chunk": "sequential_file_sector_format",
          "topic": "interpretation of bytes 0-1 and data area"
        },
        {
          "chunk": "sequential_last_sector_example_and_padding",
          "topic": "next example: a last sector with byte count"
        }
      ]
    },
    {
      "start": 6051,
      "end": 6677,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 6678,
      "end": 6693,
      "name": "last_sector_end_marker_and_padding_explanation",
      "description": "Explanation and interpretation of the preceding sector dump: byte 0 = $00 indicates no forward track (end of chain); byte 1 = $86 (decimal 134) is the byte count N; byte 134 is the last valid data byte in the file. Notes that the C64 status variable (ST) will be set to 64 after byte 134 has been read. Also documents that the remainder of the block (bytes $87–$FF) is padding — here recognizable and partly taken from the C-64 DISK BONUS PACK directory — and includes the printed fragment \". 80: 4E 36 34 2E 56 31 0D xx  N64.V1.\" as an example.",
      "references": [
        {
          "chunk": "track_17_sector_11_hex_ascii_dump",
          "topic": "Full hex/ASCII dump of the sector being interpreted (shows the bytes whose meaning is explained here)"
        }
      ]
    },
    {
      "start": 6694,
      "end": 6998,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 6999,
      "end": 7040,
      "name": "relative_file_overview_and_block_format_intro",
      "description": "Introduction to relative (random-access) files in Commodore DOS: a relative file consists of (1) a sequential data file of fixed-length records and (2) a side-sector file which stores track/sector pointers. Explains record size concept and that the side-sector file size depends on sequential file length (approximately 1/120th of the sequential file, min 1 block, max 6 blocks). Notes that one side-sector read locates the data block for any given record (plus up to two additional reads if the record spans two blocks). Also reiterates the standard sequential data block format (bytes 0-1 forward pointer, bytes 2-255 data).",
      "references": [
        {
          "chunk": "side_sector_block_format",
          "topic": "layout of a side sector block"
        },
        {
          "chunk": "relative_file_directory_entry_dump_part1",
          "topic": "example relative-file directory entry"
        }
      ]
    },
    {
      "start": 7041,
      "end": 7105,
      "name": "side_sector_block_format",
      "description": "Detailed layout of a side-sector block used by relative files: bytes 0-1 = forward pointer to next side sector; byte 2 = side sector number (0-5); byte 3 = record length (bytes per record); bytes 4-15 = track/sector list for up to 6 side sectors (4-5 for side sector #0, 6-7 for #1, ..., 14-15 for #5); bytes 16-255 = track/sector list for up to 120 data blocks (each entry two bytes: track then sector; bytes 16-17 = data block #1, 18-19 = #2, ... 254-255 = data block #120).",
      "references": [
        {
          "chunk": "relative_file_overview_and_block_format_intro",
          "topic": "role of side sectors in random access"
        },
        {
          "chunk": "interpreting_side_sector_first_16_bytes_and_table",
          "topic": "how to read the key header bytes of a side sector"
        }
      ]
    },
    {
      "start": 7106,
      "end": 7113,
      "ignore": true,
      "reason": "Page number and small formatting break (non-technical)"
    },
    {
      "start": 7114,
      "end": 7119,
      "name": "track_18_sector_01_header",
      "description": "Sector header for the directory dump: shows the disk directory location 'TRACK 18' and the sector label '-  SECTOR  01'. This is the header and spacing immediately preceding the raw directory sector data.",
      "references": [
        {
          "chunk": "directory_entry_00-18_first_directory_entry",
          "topic": "first directory entry data (offsets 00: through 18:)"
        }
      ]
    },
    {
      "start": 7120,
      "end": 7434,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 7435,
      "end": 7470,
      "name": "directory_entry_analysis_mag_file",
      "description": "Interpretation of the directory entry for 'MAG FILE': identifies the $84 file type (relative), shows that the sequential data portion starts at track 17 ($11), sector 03 ($03), and that the first side sector begins at track 17, sector 13 ($0D). Also extracts the record length byte ($96 = 150), indicating each record is exactly 150 bytes long.",
      "references": [
        {
          "chunk": "relative_file_overview_and_block_format_intro",
          "topic": "definition and role of record length"
        },
        {
          "chunk": "first_side_sector_raw_dump_part1",
          "topic": "first side sector contents (track/sector lists and pointers)"
        }
      ]
    },
    {
      "start": 7471,
      "end": 7506,
      "name": "relative_file_size_and_record_count_calculation",
      "description": "Calculates space usage for the example 'MAG FILE': the directory indicates a total of 436 blocks (low/high byte); divide by 120 to determine side-sector count (436/120 = 3.633... → 4 side sectors). Subtract side sectors from total blocks (436 - 4 = 432 data blocks). Multiply by 254 (usable bytes per data block) to get total bytes (432 * 254 = 109,728). Divide by record length (150) to get number of records currently in file (109,728 / 150 = 731.52 → 731 records).",
      "references": [
        {
          "chunk": "side_sector_block_format",
          "topic": "each side sector holds pointers for 120 data blocks"
        },
        {
          "chunk": "directory_entry_analysis_mag_file",
          "topic": "source directory values (file length, record length, side sector start)"
        }
      ]
    },
    {
      "start": 7507,
      "end": 7510,
      "name": "side_sector_intro_transition",
      "description": "Transition sentence: 'Let's examine the first side sector.' — introduces the raw dump of side sector #0 (track 17, sector 13) that follows.",
      "references": [
        {
          "chunk": "first_side_sector_raw_dump_part1",
          "topic": "raw listing of side sector #0 begins next"
        }
      ]
    },
    {
      "start": 7511,
      "end": 7554,
      "name": "side_sector_0_header_00_0f",
      "description": "Dump header for Side Sector #0 (TRACK 17 - SECTOR 13). Covers the printable title lines and the raw bytes at offsets $00..$0F (bytes 0–15): next-side-sector pointer (bytes $00-$01), side sector number (byte $02), record length (byte $03), and the side-sector table entries (bytes $04-$0F). This chunk is the header and initial table portion of the raw side-sector dump.",
      "references": [
        {
          "chunk": "data_block_pointers_10_1f",
          "topic": "Continuation: data block pointers starting at offset $10"
        },
        {
          "chunk": "data_block_pointers_20_2f",
          "topic": "Related: subsequent data block pointer ranges"
        }
      ]
    },
    {
      "start": 7555,
      "end": 8095,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 8096,
      "end": 8096,
      "name": "dump_overall_note",
      "description": "Concluding note for the side-sector #0 raw dump: 'Of primary interest are the first 16 bytes.' This single-line remark highlights that the initial 16 bytes of the dump are most relevant for the reader's analysis.",
      "references": [
        {
          "chunk": "label_80_pointers",
          "topic": "start of the pointer listing (80:)"
        },
        {
          "chunk": "label_f8_pointers",
          "topic": "end of the pointer listing (F8:)"
        }
      ]
    },
    {
      "start": 8097,
      "end": 8124,
      "name": "interpreting_side_sector_first_16_bytes_and_table",
      "description": "Explains the primary interest in the first 16 bytes of a side sector: bytes 0-1 = next side-sector (here track $0C sector $13), byte 2 = side sector number (0), byte 3 = record size ($96 = 150). Bytes 5-15 contain track/sector locations of up to six possible side sectors (table provided).",
      "references": [
        {
          "chunk": "side_sector_block_format",
          "topic": "formal layout of the side-sector block"
        },
        {
          "chunk": "first_side_sector_raw_dump_part2",
          "topic": "pointer list where bytes 16.. refer to data block pointers"
        }
      ]
    },
    {
      "start": 8125,
      "end": 8136,
      "name": "side_sector_table_and_remaining_pointers_explanation",
      "description": "Explains that side sectors 4 and 5 are not yet allocated in this example and describes the remaining 240 bytes in the side sector (bytes 16-255) as track/sector pointers for the first 120 data blocks. Notes that bytes 16-17 point to the first data block of the sequential portion (track 17, sector 03), which matches the directory.",
      "references": [
        {
          "chunk": "interpreting_side_sector_first_16_bytes_and_table",
          "topic": "interpretation of header and side-sector list"
        },
        {
          "chunk": "first_side_sector_raw_dump_part2",
          "topic": "the actual list of data block pointers"
        }
      ]
    },
    {
      "start": 8137,
      "end": 8161,
      "name": "side_sector_0_header_and_initial_pointers",
      "description": "Header and the first block of the formatted Side Sector #0 dump for TRACK 17 - SECTOR 13. Contains the title line and the initial columnar pointer entries up through the '.  18' offset marker (first set of pointer slots / track-sector pairs).",
      "references": [
        {
          "chunk": "side_sector_0_pointer_table_18_20",
          "topic": "continues with the next pointer block (offset .18 -> .20)"
        },
        {
          "chunk": "side_sector_0_pointer_table_20_28",
          "topic": "subsequent pointer blocks in the same formatted dump"
        }
      ]
    },
    {
      "start": 8162,
      "end": 8359,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 8360,
      "end": 8360,
      "name": "side_sector_0_trailer",
      "description": "Trailing line after the formatted dump of Side Sector #0 (TRACK 17 - SECTOR 13). This single-line chunk contains the final blank/trailer line terminating the dump block.",
      "references": [
        {
          "chunk": "side_sector_0_pointer_table_68_70",
          "topic": "contains the final pointer entries before this trailing line"
        }
      ]
    },
    {
      "start": 8361,
      "end": 8419,
      "name": "side_sector0_pointer_table_dump_top",
      "description": "Top portion (lines 8361–8419) of the formatted representation of side sector #0. Contains the beginning of the pointer/track-sector mapping dump with repeated two-letter tokens (e.g. OF, Or, Oo), numeric entries (14, 08, 12, 78), single-character glyphs and OCR artifacts, and the opening columnar pattern continued from the previous file chunk.",
      "references": [
        {
          "chunk": "side_sector0_pointer_table_dump_upper_mid",
          "topic": "continues the pointer table dump below this block"
        },
        {
          "chunk": "side_sector0_pointer_table_dump_bottom_and_notes",
          "topic": "follow-up and concluding lines of the formatted dump"
        }
      ]
    },
    {
      "start": 8420,
      "end": 8479,
      "name": "side_sector0_pointer_table_dump_upper_mid",
      "description": "Upper-middle portion (lines 8420–8479) of the formatted side sector #0 dump. Shows further pointer-table tokens (OD, Ot, Ofc, Oo), short numeric values and symbols, fragments of column text such as '. Ofc.' and 'Vu', and additional OCR-style distortions; this block continues the columnar mapping and annotations begun earlier.",
      "references": [
        {
          "chunk": "side_sector0_pointer_table_dump_top",
          "topic": "previous block of the same pointer table dump"
        },
        {
          "chunk": "side_sector0_pointer_table_dump_lower_mid",
          "topic": "continues with the next block of pointer-table entries"
        }
      ]
    },
    {
      "start": 8480,
      "end": 8539,
      "name": "side_sector0_pointer_table_dump_lower_mid",
      "description": "Lower-middle portion (lines 8480–8539) of the formatted representation of side sector #0. Contains more of the repeated two-letter and two-character tokens (Ofc, OC, OV, OD, OB), numeric pairs (10, 01, 00, 03), and dotted/annotated entries ('. Ofc', '. CO', '. OD'), reflecting further rows of the track/sector pointer table and OCR-induced glyphs.",
      "references": [
        {
          "chunk": "side_sector0_pointer_table_dump_upper_mid",
          "topic": "previous contiguous block of the pointer table"
        },
        {
          "chunk": "side_sector0_pointer_table_dump_bottom_and_notes",
          "topic": "final block completing the formatted dump"
        }
      ]
    },
    {
      "start": 8540,
      "end": 8600,
      "name": "side_sector0_pointer_table_dump_bottom_and_notes",
      "description": "Bottom portion (lines 8540–8600) and closing fragment of the formatted side sector #0 dump. Includes final pointer tokens and numeric values (OA, OD, 14, 12, 06, 10, 04, 02, 09, 13, 07), dotted annotations ('. D8.', '. DO:'), and residual OCR artifacts. This block completes the contiguous dump for this chunk and closes the track/sector mapping sequence continued from earlier chunks.",
      "references": [
        {
          "chunk": "side_sector0_pointer_table_dump_lower_mid",
          "topic": "preceding block of the pointer table dump"
        },
        {
          "chunk": "side_sector_formatted_dump_part2_continuation",
          "topic": "original parent chunk that this content continues and completes"
        }
      ]
    },
    {
      "start": 8601,
      "end": 8678,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 8679,
      "end": 8681,
      "name": "trace_side_sectors_intro",
      "description": "Introductory line and nearby blank lines: \"Let's trace the remaining side sectors now.\" Marks the start of the explicit tracing of side sectors.",
      "references": [
        {
          "chunk": "track_12_sector_19_side_sector_1_dump",
          "topic": "first traced side sector"
        }
      ]
    },
    {
      "start": 8682,
      "end": 9295,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 9296,
      "end": 9296,
      "name": "side_sector_1_diagnostic_statement",
      "description": "Capture closing diagnostic statement for Track 12, Sector 19, Side 1: the literal line 'Side  sector  1  looks  OK  on  this  end.' indicating the capture's assessment of the side-sector.",
      "references": [
        {
          "chunk": "track12_sector19_side1_c0_row",
          "topic": "first data row for this capture (C0:)"
        },
        {
          "chunk": "track12_sector19_side1_c8_row",
          "topic": "C8: data row"
        },
        {
          "chunk": "track12_sector19_side1_d0_row",
          "topic": "D0: data row"
        },
        {
          "chunk": "track12_sector19_side1_d8_row",
          "topic": "D8: data row"
        },
        {
          "chunk": "track12_sector19_side1_e0_row",
          "topic": "E0: data row"
        },
        {
          "chunk": "track12_sector19_side1_e8_row",
          "topic": "E8: data row"
        },
        {
          "chunk": "track12_sector19_side1_f0_row",
          "topic": "F0: data row"
        },
        {
          "chunk": "track12_sector19_side1_f8_row",
          "topic": "F8: data row"
        }
      ]
    },
    {
      "start": 9297,
      "end": 9298,
      "name": "post_side1_separator",
      "description": "Short separator / blank lines following the end of the TRACK 12 SECTOR 19 side-sector-1 dump.",
      "references": [
        {
          "chunk": "track_12_sector_19_side_sector_1_dump",
          "topic": "previous block ended"
        },
        {
          "chunk": "track_06_sector_16_dump",
          "topic": "next block begins"
        }
      ]
    },
    {
      "start": 9299,
      "end": 9301,
      "name": "track_06_sector_16_header",
      "description": "Sector header identifying TRACK 06 - SECTOR 16 and the immediate blank/spacing lines that precede the raw dump. This node denotes the start of the dump block and provides the context (track/sector) for the following raw bytes.",
      "references": [
        {
          "chunk": "sector_06_16_offsets_00_07",
          "topic": "first block of raw sector data (offsets 00h–07h)"
        },
        {
          "chunk": "sector_06_16_offsets_08_17",
          "topic": "continuation of the raw sector data (offsets 08h–17h)"
        }
      ]
    },
    {
      "start": 9302,
      "end": 9881,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 9882,
      "end": 9882,
      "name": "pre_side3_blank_line",
      "description": "Blank line separating TRACK 06 - SECTOR 16 dump from the next traced sector (TRACK 19 - SECTOR 15 side sector #3).",
      "references": [
        {
          "chunk": "track_06_sector_16_dump",
          "topic": "previous block"
        },
        {
          "chunk": "track_19_sector_15_side_sector_3_dump",
          "topic": "next block"
        }
      ]
    },
    {
      "start": 9883,
      "end": 9976,
      "name": "track19_sector15_side3_header_ascii_garble",
      "description": "Sector header and the initial ASCII-like/OCR artifact region of TRACK 19, SECTOR 15 (SIDE SECTOR #3). Covers the printed sector title line, several blank lines, and the following block of noisy ASCII characters and OCR-like fragments that precede the formatted hex/byte table.",
      "references": [
        {
          "chunk": "track19_sector15_side3_hex_table_start",
          "topic": "continues into the formatted hex table"
        }
      ]
    },
    {
      "start": 9977,
      "end": 10469,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 10470,
      "end": 10485,
      "name": "side_sector_3_byte_count_and_pointers",
      "description": "Analysis of side sector #3 bytes: Byte 1 shows a byte count of 159 ($9F); bytes 16-255 in a side sector are a list of track/sector pointers for up to 120 data blocks; bytes 158 and 159 (interpreted together) point to the last block of the sequential data file (track 23 / $17, sector 12 / $0C); the remainder of the side sector is padded with nulls until the relative file grows. Explains how bytes 160/161 will point to further track/sector pairs, and that when side sector #3 fills, a new side sector #4 is allocated and bytes 0/1 in side sector #3 will then point to side sector #4; additionally bytes 12/13 in side sectors 0–2 will be updated to reflect creation of side sector #4.",
      "references": [
        {
          "chunk": "track_19_sector_15_side_sector_3_dump",
          "topic": "points being analyzed in the dump"
        },
        {
          "chunk": "sequential_file_example_track_17_sector_03",
          "topic": "sequential file blocks referenced by the pointers"
        }
      ]
    },
    {
      "start": 10486,
      "end": 10497,
      "name": "sequential_file_intro_track_sector",
      "description": "Introductory lines for the sequential file hex dump: brief sentence introducing the dump and the track/sector identification (TRACK 17 - SECTOR 03). Covers the human-readable context before the raw hex/ASCII dump begins.",
      "references": [
        {
          "chunk": "dump_offset_00_ascii_magfile",
          "topic": "starts the raw dump at offset 00 (first data bytes / ASCII fragments)"
        }
      ]
    },
    {
      "start": 10498,
      "end": 11023,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 11024,
      "end": 11031,
      "name": "sequential_file_block_description",
      "description": "Explains the structure of the shown sequential data block: bytes 0/1 are the chain pointer to the next block (here linking to track 17 / $11, sector 14 / $0E); bytes 2–151 (150 bytes) are the first fixed-length record; unused bytes within a record are written as nulls by DOS. Explains that record content is program-dependent and that this example is a management record from a free-form database.",
      "references": [
        {
          "chunk": "sequential_file_example_track_17_sector_03",
          "topic": "the block being described"
        },
        {
          "chunk": "sequential_file_management_info_list",
          "topic": "enumeration of management info fields in this record"
        }
      ]
    },
    {
      "start": 11032,
      "end": 11039,
      "name": "sequential_file_management_info_list",
      "description": "List of the contents of the management record stored in the example sequential block: 1) the relative file name ('MAG FILE'), 2) number of active records (709), 3) number of fields in use (6), 4) field titles (TITLE, COMPUTER, MAGAZINE, ISSUE, PAGE, COMMENT).",
      "references": [
        {
          "chunk": "sequential_file_block_description",
          "topic": "describes what this management record contains"
        },
        {
          "chunk": "track_17_sector_14_continued_record_dump",
          "topic": "continuation of the next record in the following block"
        }
      ]
    },
    {
      "start": 11040,
      "end": 11047,
      "name": "sequential_file_record_length_and_record2_note",
      "description": "Notes on record sizing and record #2: In the sequential portion of a relative file the record length is constant (150 bytes in this example). Record number 2 begins at byte 152 ($98) and extends into the next data block; two reads are required to fetch the entire record. The first 104 bytes are found in the current block; the remaining 46 bytes are in the next block (TRACK 17 - SECTOR 14).",
      "references": [
        {
          "chunk": "sequential_file_management_info_list",
          "topic": "context for record layout"
        },
        {
          "chunk": "track_17_sector_14_continued_record_dump",
          "topic": "contains the remaining 46 bytes of record #2"
        }
      ]
    },
    {
      "start": 11048,
      "end": 11653,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 11654,
      "end": 11671,
      "name": "relative_file_record_notes",
      "description": "Explanation of record number usage in relative files: record 2 is used for management info (record length); blank fields stored as period (0x2E = '.'); record 3 begins at byte 48 and contains the first data (field labels shown).",
      "references": [
        {
          "chunk": "hex_dump_relative_file_example_part1",
          "topic": "hex dump showing the fields referenced"
        },
        {
          "chunk": "hex_dump_relative_file_example_part2",
          "topic": "further sector dumps and record overflow discussion"
        }
      ]
    },
    {
      "start": 11672,
      "end": 11681,
      "name": "track_23_sector_02_header",
      "description": "Dump header for Track 23, Sector 02. Contains the blank-leading lines, the textual header lines 'TRACK', '23', '-  SECTOR', '02' and the label for the first byte-offset '00 :'. Serves as the entry point for the sector hex/ASCII dump.",
      "references": [
        {
          "chunk": "offsets_00_08_10_18_hex_ascii_dump",
          "topic": "first four offset rows (00:, 08:, 10:, 18:)"
        },
        {
          "chunk": "sector_end_marker_block_eo_e8_fo_f8",
          "topic": "sector terminator markers at end of this sector dump"
        }
      ]
    },
    {
      "start": 11682,
      "end": 11969,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 11970,
      "end": 12059,
      "name": "ascii_column_artifacts_for_sector_dump",
      "description": "Right-column ASCII-like artifact view for the sector hex dump. Shows the ASCII (or approximate) interpretations of the byte rows: various symbols, control-character representations, unreadable glyphs, repeated letter groups (UU, OO, KjKJ, etc.), and other textual artifacts aligned with the prior hex rows. This block represents the human-readable column accompanying the earlier offset rows.",
      "references": [
        {
          "chunk": "offsets_60_68_70_78_hex_ascii_dump",
          "topic": "hex rows which these ASCII artifacts annotate"
        },
        {
          "chunk": "sector_end_marker_block_eo_e8_fo_f8",
          "topic": "sector terminator markers that follow the ASCII column block"
        }
      ]
    },
    {
      "start": 12060,
      "end": 12091,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 12092,
      "end": 12172,
      "name": "track_header_and_initial_glyphs",
      "description": "Track dump header and the initial region of the sector dump showing the 'TRACK' label, assorted printable-glyph artifacts (e.g. uu<, uo, y-\\y^, ■, OOi, lO.), isolated byte-offset-like annotations (18:, 4u;, 48:, 50:) and scattered 00 bytes. This chunk establishes the header and the first mixed ASCII/hex artifacts and small padding runs at the start of the track.",
      "references": [
        {
          "chunk": "padding_and_marker_pairs_block1",
          "topic": "continues into more 00/padding and OU/uo patterns"
        },
        {
          "chunk": "marker_sequence_eo_e8_fo_f8",
          "topic": "later contains the EO/E8/FO/F8 marker block"
        }
      ]
    },
    {
      "start": 12173,
      "end": 12376,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 12377,
      "end": 12414,
      "name": "repeated_token_patterns_region1",
      "description": "Begins a long section of tokenized patterns and short two-letter groups: repeated 'r' motifs (r  r, riri, r»ri), UU runs, and combinations of nn, ou, OU, 00. This region shows interleaving of repeated tokens (visual/ASCII stand-ins for byte values) and 00 padding — typical of raw sector dumps with repeated filler and metadata markers.",
      "references": [
        {
          "chunk": "marker_sequence_eo_e8_fo_f8",
          "topic": "previous EO/E8/FO/F8 marker group"
        },
        {
          "chunk": "repeated_token_patterns_region2",
          "topic": "continues into more structured token runs and transitions to final padding"
        }
      ]
    },
    {
      "start": 12415,
      "end": 12515,
      "name": "repeated_token_patterns_region2",
      "description": "Continuation and expansion of the repeated-token patterns: alternating sequences of nn, UU, riri, ou, nri, Ari, KJKJ, and other multi-instance tokens, occasional '00' separators, and mixed-case token clusters. This block demonstrates the bulk of a track's filler/marker repetition prior to the terminal zero padding.",
      "references": [
        {
          "chunk": "repeated_token_patterns_region1",
          "topic": "previous repeated-token region"
        },
        {
          "chunk": "trailing_zero_padding",
          "topic": "followed by an extended run of 00 bytes to end the track"
        }
      ]
    },
    {
      "start": 12516,
      "end": 12902,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 12903,
      "end": 12911,
      "name": "relative_record_overflow_and_empty_record_description",
      "description": "Describes how a relative-file record spans sectors: bytes 2-131 of track 23, sector 2 are overflow from the previous record; bytes 132-255 of that sector and bytes 2-27 of track 23, sector 12 form the next record. Notes that the next record is empty (first byte = 255 / $FF, remaining bytes null), that track 23 sector 12 has no forward chain and has a byte count of 177 ($B1), and that the last record ends at byte 177 (bytes 28–177). Introduces the following illustration of padding beyond this point.",
      "references": [
        {
          "chunk": "sector_padding_hex_dump_example",
          "topic": "visual example of the padding beyond byte 177"
        },
        {
          "chunk": "dos_partial_record_creation_and_padding_calculation",
          "topic": "analysis of why padding appears and how DOS computes remaining nulls"
        }
      ]
    },
    {
      "start": 12912,
      "end": 12931,
      "name": "sector_padding_label_overview",
      "description": "Header and per-sector label rows for a padding hex dump used in the example. Contains the legend line (.  BO:  XX  XM  FF) followed by labeled rows for offsets BO, B8, CO, C8, DO, D8, EO, E8, FO, F8; each row shows three marker slots (values such as 00 or OO) that summarize how padding bytes are classified at those offsets.",
      "references": [
        {
          "chunk": "sector_padding_byte_sequence_dump",
          "topic": "Concrete byte-by-byte padding pattern (the linear listing of 00/OO values that corresponds to these labeled rows)"
        }
      ]
    },
    {
      "start": 12932,
      "end": 13032,
      "ignore": true,
      "reason": "OCR'd hex/sector dump - no technical content"
    },
    {
      "start": 13033,
      "end": 13046,
      "name": "dos_partial_record_creation_and_padding_calculation",
      "description": "Explains the surprising presence of an $FF at byte 178 ($B2) instead of an expected null ($00): DOS pre-creates a partial record to simplify later expansion. Shows the math used by DOS to determine how much null padding remains: first compute bytes already in existence as 255 - byte_count (255 - 177 = 78), then compute nulls to add as Total_Record_Length - Bytes_in_Existence (example: 150 - 78 = 72). Concludes with the practical effect of this pre-creation.",
      "references": [
        {
          "chunk": "relative_record_overflow_and_empty_record_description",
          "topic": "context about the record boundaries and byte counts used in the calculation"
        },
        {
          "chunk": "sector_padding_hex_dump_example",
          "topic": "the actual sector data illustrating the $FF and subsequent padding"
        }
      ]
    },
    {
      "start": 13047,
      "end": 13080,
      "name": "locating_relative_record",
      "description": "Procedure and arithmetic for finding a particular relative record given record number and fixed record length. Example: to find record 4 with 150-byte records: compute previous bytes (3*150 = 450), divide by 254 (sector payload) to get pointer set (1.7716...), INT() handling to index pointer sets and side sectors, compute byte offset within sector using fractional remainder multiplied by 254, and locate track/sector via directory pointer bytes.",
      "references": [
        {
          "chunk": "relative_record_padding_analysis",
          "topic": "example sectors used to validate the location algorithm"
        }
      ]
    },
    {
      "start": 13081,
      "end": 13090,
      "name": "user_file_usr",
      "description": "Description of USR (user) files: designated by file-type byte $83 in the directory. USR is a legal but uncommon file type; DOS may structure a USR file as sequential or program if created by DOS, but arbitrary layouts are possible if created via direct-access. Warning: DOS expects track/sector links in normal places -- if missing the BAM will mark blocks free when validating.",
      "references": [
        {
          "chunk": "locked_files",
          "topic": "file-type byte manipulation (locking/unlocking) mentions USR file type"
        }
      ]
    },
    {
      "start": 13091,
      "end": 13123,
      "name": "deleted_file_del",
      "description": "Deleted files (DEL) explained: file-type byte $80. DEL is an undocumented Commodore type (rare) used for protection tricks. DEL cannot be created via OPEN; must change file-type byte manually. Loading examples provided for PRG-like DEL files: LOAD \"FILENAME,DEL,R\",8 (relocated) and LOAD \"FILENAME,DEL,R\",8,1 (not relocated). Also shows how to OPEN a DEL-structured sequential file for reading: OPEN 2,8,2,\"FILE NAME, DEL, R\".",
      "references": [
        {
          "chunk": "user_file_usr",
          "topic": "other uncommon file types and their directory byte codes"
        }
      ]
    },
    {
      "start": 13124,
      "end": 13151,
      "name": "locked_files",
      "description": "Locked-file mechanism (undocumented): locked files cannot be scratched until unlocked. DOS doesn't provide lock/unlock; you must edit the file-type byte in the directory to set lock bit (bit 6). Table of normal vs locked byte values: DEL $80 -> DEL < $C0, SEQ $81 -> SEQ < $C1, PRG $82 -> PRG < $C2, USR $83 -> USR < $C3, REL $84 -> REL < $C4. DOS checks bit 6 of file-type to determine locked state; files may still be renamed or copied when locked.",
      "references": [
        {
          "chunk": "deleted_file_del",
          "topic": "DEL file type specifics"
        },
        {
          "chunk": "chapter5_intro",
          "topic": "tools for editing track/sector or directory entries (direct-access programming)"
        }
      ]
    },
    {
      "start": 13152,
      "end": 13161,
      "name": "conclusion_chapter4",
      "description": "Conclusion to chapter 4: warns that recovering a damaged file or tampering with directory structure requires full understanding of directory layout and storage mechanisms; advise caution.",
      "references": [
        {
          "chunk": "locked_files",
          "topic": "directory editing and risks"
        }
      ]
    },
    {
      "start": 13162,
      "end": 13169,
      "name": "chapter5_header",
      "description": "Chapter 5 header: DIRECT-ACCESS PROGRAMMING. Introduces next chapter focused on direct-access commands and techniques for interacting with 1541 internals.",
      "references": [
        {
          "chunk": "chapter5_intro",
          "topic": "chapter introduction and overview"
        }
      ]
    },
    {
      "start": 13170,
      "end": 13199,
      "name": "chapter5_intro",
      "description": "Introduction to Direct-Access Programming: motivates direct-access commands (beyond housekeeping commands NEW, SCRATCH, VALIDATE) and lists example utilities one can implement: change disk name/ID, display BAM, display directory, display/edit track&sector, chain through directory, recover scratched files, recover damaged disks, duplicate disks, copy files, catalog a disk library. Explains that direct-access commands allow deeper maintenance and utilities and that basic understanding is necessary to use later routines.",
      "references": [
        {
          "chunk": "direct_access_command_list",
          "topic": "list of direct-access commands and short descriptions"
        }
      ]
    },
    {
      "start": 13200,
      "end": 13207,
      "name": "beginning_direct_access_programming_intro",
      "description": "Beginning section to direct-access programming: transitions from chapter 2 housekeeping to the specialized direct-access commands recognized by the 1541; prepares reader for a list of the commands and their functions.",
      "references": [
        {
          "chunk": "chapter5_intro",
          "topic": "why direct-access commands are useful"
        }
      ]
    },
    {
      "start": 13208,
      "end": 13231,
      "name": "direct_access_command_list",
      "description": "List of nine 1541 direct-access commands and short functions: Block-Read (U1) - read block into 1541 RAM; Buffer-Pointer (B-P) - set pointer to any byte in disk buffer; Block-Write (U2) - write buffer to disk; Memory-Read (M-R) - peek bytes out of 1541 RAM/ROM; Memory-Write (M-W) - poke bytes into 1541 RAM; Block-Allocate (B-A) - set bit in BAM to indicate sector in use; Block-Free (B-F) - clear BAM bit; Memory-Execute (M-E) - execute 6502 routine in 1541 RAM/ROM; Block-Execute (B-E) - load & execute 6502 routine in 1541 RAM.",
      "references": [
        {
          "chunk": "block_read_u1_syntax",
          "topic": "block-read (U1) usage and syntax"
        },
        {
          "chunk": "memory_read_m-r_syntax",
          "topic": "memory-read (M-R) usage and syntax"
        }
      ]
    },
    {
      "start": 13232,
      "end": 13263,
      "name": "direct_access_command_usage",
      "description": "Usage notes: direct-access commands often used together (e.g., U1 read a sector into a buffer, B-P or M-R examine/modify buffer, U2 write buffer back). Block-read (U1), buffer-pointer (B-P), and block-write (U2) are easiest and most used; M-R and M-W are more advanced. B-A/B-F used for random-access file maintenance (rare). M-E and B-E (execute) are advanced and used rarely.",
      "references": [
        {
          "chunk": "block_write_u2_syntax",
          "topic": "block-write (U2) counterpart to block-read"
        },
        {
          "chunk": "memory_read_m-r_syntax",
          "topic": "use of memory commands instead of B-P for sophisticated access"
        }
      ]
    },
    {
      "start": 13264,
      "end": 13301,
      "name": "direct_access_open_syntax",
      "description": "How to open a direct-access data channel: SYNTAX: OPEN file#, device#, channel#, \"#\" (e.g., OPEN 2,8,2,\"#\" or OPEN 1,8,14,\"#\"). file# is logical file number (1-127); device# is 8; channel# is secondary address on 1541 (2-14). Explains that opening establishes communication between C64 and 1541; channel number used in direct-access commands, while logical file number is used for GET#/PRINT# operations.",
      "references": [
        {
          "chunk": "direct_access_command_list",
          "topic": "use channel number in direct-access commands such as Ul, U2, B-P"
        }
      ]
    },
    {
      "start": 13302,
      "end": 13321,
      "name": "open_channel_communication_details",
      "description": "Details about logical file number vs channel number: logical file number (C64 side) passes GET#/PRINT# data to the 1541 channel number; they need not match. The channel number only appears in direct-access commands. Using mnemonic file/channel numbers is optional. Example described for opening logical file 1 to channel 14, etc.",
      "references": [
        {
          "chunk": "direct_access_open_syntax",
          "topic": "examples of OPEN syntax and parameter meanings"
        }
      ]
    },
    {
      "start": 13322,
      "end": 13361,
      "name": "block_read_u1_syntax",
      "description": "Block-Read command (U1): transfers contents of specified track & sector into a DOS buffer (workspace) in the 1541. SYNTAX: PRINT# file#, \"U1\"; channel#; drive#; track; sector (alternate formats include colon/commas). drive# is 0; track 1-35; sector within track range. Example: PRINT#15, \"U1\";2;0;18;0.",
      "references": [
        {
          "chunk": "block_read_get_and_null_handling",
          "topic": "GET# use after U1 and handling null bytes"
        },
        {
          "chunk": "block_read_example_program",
          "topic": "sample BASIC program that reads the BAM using U1 and prints the block"
        }
      ]
    },
    {
      "start": 13362,
      "end": 13412,
      "name": "block_read_example_program",
      "description": "Example BASIC program demonstrating U1: open command channel (15), initialize drive, open direct-access channel (GET#2) letting 1541 assign buffer, PRINT#15 \"U1\";2;0;18;0 to read track 18 sector 0 (BAM) into buffer; use GET#2 to retrieve 256 bytes; convert null strings to CHR$(0) before ASC(); print byte indices and ASCII values and characters within printable range. Illustrates three U1 parameter formats and null handling.",
      "references": [
        {
          "chunk": "block_read_u1_syntax",
          "topic": "U1 syntax used in the example"
        },
        {
          "chunk": "block_read_program_explanation",
          "topic": "line-by-line explanation of the sample program"
        }
      ]
    },
    {
      "start": 13413,
      "end": 13502,
      "name": "block_read_program_explanation",
      "description": "Line-by-line explanation and programming technique notes for the block-read example: opening command channel (15), initializations, opening data channel (2) and buffer assignment, issuing U1 and handling responses via error channel, looping 256 bytes with GET#, converting nulls to CHR$(0), ASC() conversions, printing, closing channels, updating BAM on close, and suppressing the error light via reading the error channel. Notes also mention alternate U1 formats and combined null handling in one statement (A=ASC(B$+CHR$(0))).",
      "references": [
        {
          "chunk": "block_read_example_program",
          "topic": "the BASIC listing the explanations map to"
        },
        {
          "chunk": "buffer_pointer_b-p_syntax",
          "topic": "B-P is often used after U1 to set buffer pointer to specific byte"
        }
      ]
    },
    {
      "start": 13503,
      "end": 13520,
      "name": "memory_and_alternate_command_notes",
      "description": "Additional notes on command ordering and alternate formats: mentions that memory-read/write may be used instead of B-P for some tasks, and that U1/U2 have alternate colon/comma forms. Also notes DOS attempts to rewrite BAM when closing direct-access channels and the error light behavior for write-protected or DOS-protected disks (error light remains until suppressed via reading error channel).",
      "references": [
        {
          "chunk": "block_read_program_explanation",
          "topic": "suppression of the error light and BAM rewrite behavior"
        }
      ]
    },
    {
      "start": 13521,
      "end": 13551,
      "name": "buffer_pointer_b-p_syntax",
      "description": "Buffer-Pointer command (B-P): set pointer to any byte 0-255 in a DOS buffer for subsequent GET# reads or PRINT# writes. SYNTAX: PRINT# file#, \"B-P\"; channel#; byte_position (alternate formats: \"B-P:\" channel#, position). Example: PRINT#15, \"B-P\";2;144.",
      "references": [
        {
          "chunk": "block_read_u1_syntax",
          "topic": "read a block into a buffer with U1 before using B-P"
        },
        {
          "chunk": "buffer_pointer_example_program",
          "topic": "example using B-P to read disk name bytes 144-159"
        }
      ]
    },
    {
      "start": 13552,
      "end": 13595,
      "name": "buffer_pointer_example_program",
      "description": "Buffer-pointer example program (BASIC): opens command channel, reads track 18 sector 0 (BAM) into buffer via U1; issues PRINT#15,\"B-P\";2;144 to set pointer at 144; then loops 16 times GET#2 to read disk name bytes 144-159, converts nulls, adjusts ASCII >127, forces printable range, builds disk-name string (DN$), and prints DISK NAME. Demonstrates how to read only selected bytes from a buffer.",
      "references": [
        {
          "chunk": "buffer_pointer_b-p_syntax",
          "topic": "B-P syntax used in the program"
        }
      ]
    },
    {
      "start": 13596,
      "end": 13614,
      "name": "buffer_pointer_program_explanation_and_alternates",
      "description": "Explanation of the buffer-pointer program: line mappings (B-P sets pointer, loop reads/builds disk name with ASCII adjustments and printable-range enforcement). Also lists alternate B-P formats such as PRINT#15, \"B-P: \"2;144 and PRINT#15, \"B-P: 2, 144\".",
      "references": [
        {
          "chunk": "buffer_pointer_example_program",
          "topic": "line-by-line mapping to the program"
        }
      ]
    },
    {
      "start": 13615,
      "end": 13649,
      "name": "block_write_u2_syntax",
      "description": "Block-Write command (U2): writes entire contents of a DOS buffer to a given track & sector on disk. SYNTAX parallels U1: PRINT# file#, \"U2\"; channel#; drive#; track; sector (alternate colon/comma forms). Example: PRINT#15, \"U2\";2;0;18;0. The position of the buffer-pointer is irrelevant when executing U2; the entire 256-byte buffer is written.",
      "references": [
        {
          "chunk": "edit_disk_name_program",
          "topic": "example that modifies disk name in buffer and writes it with U2"
        }
      ]
    },
    {
      "start": 13650,
      "end": 13663,
      "name": "block_vmte_write_behavior_and_overview",
      "description": "Explains that a block-vmte (U2) command writes the entire buffer to disk regardless of the buffer-pointer position; notes that the buffer-pointer is ignored by DOS during U2. Introduces the two example programs that follow: one to change a disk name using a block-write (U2) and one to edit the cosmetic disk ID in the BAM (not the embedded formatting ID in sector headers). Also shows the U2 command parameter synopsis.",
      "references": [
        {
          "chunk": "edit_disk_name_intro_and_drive_init",
          "topic": "BASIC program that implements the disk-name edit (starts the example programs)"
        },
        {
          "chunk": "edit_disk_name_read_bam_and_modify_disk_name",
          "topic": "Main routine that reads the BAM/disk-name buffer and performs the U2 write"
        }
      ]
    },
    {
      "start": 13664,
      "end": 13699,
      "name": "edit_disk_name_intro_and_drive_init",
      "description": "Beginning of the 'EDIT DISK NAME' BASIC program. Contains the REM header, builds a 16-character padding string, displays UI messages prompting the user to insert a diskette and press RETURN, waits for the key, opens the command channel (OPEN15,8,15), sends the '10' command to the drive to get status, reads the drive response (INPUT#15, EN*, EM*, ET*, ES*), and handles an initialization failure by printing error info, closing the command channel and exiting.",
      "references": [
        {
          "chunk": "block_vmte_write_behavior_and_overview",
          "topic": "Explanation of U2 behavior and overview of example programs"
        },
        {
          "chunk": "edit_disk_name_read_bam_and_modify_disk_name",
          "topic": "Continues the program: opens the data channel, reads the BAM/disk-name buffer and proceeds to edit/write the disk name"
        }
      ]
    },
    {
      "start": 13700,
      "end": 13784,
      "name": "edit_disk_name_read_bam_and_modify_disk_name",
      "description": "Main body of the 'EDIT DISK NAME' BASIC program. Opens the data channel (OPEN2,8,2,\"#\"), sends drive read commands to fetch BAM/ID buffer (PRINT#15,'U1';2;0;18;0 and subsequent 'B-P' pointer commands), reads bytes (GET#2) and reconstructs the current (old) disk name, detects DOS version from the BAM header, prompts the user for a new disk name (NDN$), validates length and gets confirmation, pads/truncates the new name to 16 characters, overwrites the buffer via data channel (PRINT#2,NDN$;), issues a block-write (U2) to write track 18 sector 0 back to disk, checks error/status responses from the drive and prints failure messages when appropriate. Also includes commands to update the BAM via '10' commands and prints completion before END.",
      "references": [
        {
          "chunk": "edit_disk_name_intro_and_drive_init",
          "topic": "Program initialization and drive status check"
        },
        {
          "chunk": "edit_disk_name_close_routine",
          "topic": "Cleanup/close routine used to finalize and close channels after the write"
        }
      ]
    },
    {
      "start": 13785,
      "end": 13792,
      "name": "edit_disk_name_close_routine",
      "description": "Close/cleanup subroutine for the 'EDIT DISK NAME' program. Performs channel closure (CLOSE2), reads the drive command-channel status (INPUT#15, EN*, EM*, ET*, ES*), closes the command channel (CLOSE15) and ends the program. This handles orderly shutdown after attempts to read/write the BAM and disk name.",
      "references": [
        {
          "chunk": "edit_disk_name_read_bam_and_modify_disk_name",
          "topic": "Main routine that calls this cleanup sequence after write attempts and status checks"
        }
      ]
    },
    {
      "start": 13793,
      "end": 13837,
      "name": "edit_disk_id_overview_and_block_write_alternatives_top",
      "description": "Overview and line-range summary for the 'EDIT DISK ID' BASIC program. Lists what key BASIC line ranges do (opening logical file 2, querying DOS version, padding name, resetting channel pointer, overwriting buffer, writing buffer to track/sector, updating the BAM). Also shows alternate formats of the block-write (U2) command referenced earlier in the listing.",
      "references": [
        {
          "chunk": "edit_disk_id_initialization_and_drive_check",
          "topic": "program start, user prompts, and initial DRIVE 0 / channel 15 check"
        },
        {
          "chunk": "edit_disk_id_block_write_alternatives_bottom",
          "topic": "additional alternate U2 command formats shown at the end of the listing"
        }
      ]
    },
    {
      "start": 13838,
      "end": 13874,
      "name": "edit_disk_id_initialization_and_drive_check",
      "description": "Beginning of the BASIC program: program REM/title text and user prompts (insert diskette, press return). Waits for CR, prints 'OK', opens command channel 15 to device 8 (OPEN15,8,15), sends the '10' command to query drive status, reads EN*,EM*,ET*,ES* and checks for EN*='00' before proceeding; if nonzero status it prints the error, closes channel 15 and ends.",
      "references": [
        {
          "chunk": "edit_disk_id_overview_and_block_write_alternatives_top",
          "topic": "summary of what the program does and where the write operation occurs"
        },
        {
          "chunk": "edit_disk_id_buffer_open_and_dos_version_query",
          "topic": "continues by opening logical file 2 and querying DOS version"
        }
      ]
    },
    {
      "start": 13875,
      "end": 13896,
      "name": "edit_disk_id_buffer_open_and_dos_version_query",
      "description": "Opens logical file/channel 2 to device 8 (OPEN2,8,2,\"#\") to let the 1541 assign a buffer. Issues a block-read (U1) via the command channel (PRINT#15,\"U1\",2,0,18,0) and reads the result (INPUT#15,EN*,EM*,ET*,ES*). Then uses PRINT#15,\"B-P\";2;2 and GET#2,B* to read the buffer pointer byte and determines the drive's DOS version by ASC(B*). If DOS is not the expected value (65 = CBM DOS v2.6), it prints a failed message and branches to the close/fail handler.",
      "references": [
        {
          "chunk": "edit_disk_id_initialization_and_drive_check",
          "topic": "required prior drive status check before opening buffers"
        },
        {
          "chunk": "edit_disk_id_read_and_edit_disk_id_bytes",
          "topic": "reads the disk ID bytes from the buffer after the DOS check passes"
        }
      ]
    },
    {
      "start": 13897,
      "end": 13925,
      "name": "edit_disk_id_read_and_edit_disk_id_bytes",
      "description": "Reads the disk ID bytes from the drive buffer: issues PRINT#15,\"B-P\";2;162 to position the channel pointer to the disk ID offset, then loops to GET#2,B* twice to read two ID bytes. Normalizes each byte (map 0/space to CHR$(0), clear high bit, replace non-printable or quotes with '?' (represented as 63) ), builds the old ID string (ODI*), displays it, prompts the user for a new ID (NDI*), verifies length (1..2 characters), asks for confirmation (Y/N), and pads/truncates the new ID to exactly 2 characters for writing.",
      "references": [
        {
          "chunk": "edit_disk_id_buffer_open_and_dos_version_query",
          "topic": "must open the buffer and confirm DOS version before reading the disk ID"
        },
        {
          "chunk": "edit_disk_id_write_and_finish_procedure",
          "topic": "writes the validated/padded new ID back into the buffer and commits the block write"
        }
      ]
    },
    {
      "start": 13926,
      "end": 13966,
      "name": "edit_disk_id_write_and_finish_procedure",
      "description": "Writes the new disk ID and finalizes the operation: repositions the buffer pointer to the disk ID (PRINT#15,\"B-P\";2;162), writes the two-character NDI* into the buffer (PRINT#2,NDI*;), and issues the block-write command (PRINT#15,\"U2\",2,0,18,0) to write track 18 sector 0. Reads the drive's response (INPUT#15,EN*,EM*,ET*,ES*) and checks EN* for success. On error it prints a failed message and branches to cleanup. On success it issues the '10' command to update the BAM, closes channels, prints DONE, and ends. Also contains the close/cleanup routine (CL0SE2, INPUT#15,... CLOSE 15).",
      "references": [
        {
          "chunk": "edit_disk_id_read_and_edit_disk_id_bytes",
          "topic": "takes the padded new ID produced by the edit/validation step and writes it to disk"
        },
        {
          "chunk": "edit_disk_id_block_write_alternatives_bottom",
          "topic": "alternate syntaxes for the U2 block-write command used here"
        }
      ]
    },
    {
      "start": 13967,
      "end": 13975,
      "name": "edit_disk_id_block_write_alternatives_bottom",
      "description": "Additional alternate formats (duplicate listing) of the block-write (U2) command used to write the buffer to the drive. Shows syntaxes like PRINT#15,\"U2: \"2,0,18,0\" and PRINT#15,\"U2:2,0,18,0\" for issuing block-write operations from the command channel.",
      "references": [
        {
          "chunk": "edit_disk_id_write_and_finish_procedure",
          "topic": "shows alternate U2 formats for the block-write issued in the write/finish step"
        },
        {
          "chunk": "edit_disk_id_overview_and_block_write_alternatives_top",
          "topic": "the same alternate formats are referenced in the overview at the top of the listing"
        }
      ]
    },
    {
      "start": 13976,
      "end": 14000,
      "name": "memory_read_overview_and_syntax",
      "description": "Introduces the Memory-Read (M-R) command for the 1541: purpose (read any area of 1541 RAM or ROM), command format and alternate format (PRINT# file#, \"M-R\" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes) and alternate with colon), and a brief example (PRINT#15, \"M-R\" CHR$(0) CHR$(3)).",
      "references": [
        {
          "chunk": "memory_read_parameters_and_defaults",
          "topic": "defines file#, lo-byte, hi-byte and the optional # of bytes parameter (default 1)"
        },
        {
          "chunk": "buffer_selection_and_direct_access_open",
          "topic": "explains typical usage with a preceding block-read (U1) and how to select which buffer the DOS uses"
        }
      ]
    },
    {
      "start": 14001,
      "end": 14029,
      "name": "memory_read_parameters_and_defaults",
      "description": "Explains the parameters used by the M-R command: file# (logical file number of the command channel), lo-byte and hi-byte (low and high bytes of the memory address), and # of bytes (1 to 255). Notes that the third parameter CHR$(# of bytes) is undocumented, optional, and defaults to CHR$(1).",
      "references": [
        {
          "chunk": "memory_read_overview_and_syntax",
          "topic": "shows the syntax and example M-R command usage"
        },
        {
          "chunk": "buffer_selection_and_direct_access_open",
          "topic": "describes why buffer selection matters when issuing a memory-read after a block-read"
        }
      ]
    },
    {
      "start": 14030,
      "end": 14030,
      "ignore": true,
      "reason": "The overlapped content is a blank line only; blank lines are non-technical and safe to ignore."
    },
    {
      "start": 14031,
      "end": 14051,
      "name": "buffer_selection_and_direct_access_open",
      "description": "Describes typical workflow: a block-read (U1) is usually issued before M-R to load disk data into one of four 256-byte RAM pages called buffers. Explains that OPEN 2,8,2,\"#\" lets DOS select a buffer arbitrarily for the channel, and shows how to explicitly select a buffer in the OPEN statement using OPEN file#, device#, channel#, \"#buffer#\" (example: OPEN 2,8,2,\"#0\"). Notes buffer# ranges 0 to 3.",
      "references": [
        {
          "chunk": "buffer_address_map_1541",
          "topic": "gives the actual memory address ranges for each buffer and reserved regions"
        },
        {
          "chunk": "memory_read_parameters_and_defaults",
          "topic": "explains the M-R parameters which are used to read from the selected buffer or other memory areas"
        }
      ]
    },
    {
      "start": 14052,
      "end": 14081,
      "name": "buffer_address_map_1541",
      "description": "Provides the 1541 buffer address organization and unavailable ranges: $0000-$00FF (zero page) not available, $0100-$01FF (stack) not available, $0200-$02FF (command buffer) not available, Buffer 0 = $0300-$03FF (OPEN 2,8,2,\"#0\"), Buffer 1 = $0400-$04FF (OPEN 2,8,2,\"#1\"), Buffer 2 = $0500-$05FF (OPEN 2,8,2,\"#2\"), Buffer 3 = $0600-$06FF (OPEN 2,8,2,\"#3\"), $0700-$07FF (BAM) not available.",
      "references": [
        {
          "chunk": "buffer_selection_and_direct_access_open",
          "topic": "explains how to select one of these buffers with the OPEN statement"
        },
        {
          "chunk": "buffer_sharing_and_get_usage",
          "topic": "describes sharing limitations and how to retrieve buffer contents after M-R"
        }
      ]
    },
    {
      "start": 14082,
      "end": 14096,
      "name": "direct_access_channel_buffer_sharing_and_get_usage",
      "description": "Notes that two or more direct-access channels cannot share the same buffer (attempting to do so yields NO CHANNEL). Describes that GET# is used after an M-R to fetch data from the selected buffer via the command channel; fetched bytes must be tested for \"\" and converted to CHR$(0) if necessary.",
      "references": [
        {
          "chunk": "selecting_dos_buffer_open_syntax_and_buffer_table",
          "topic": "buffer selection with OPEN and how that affects GET# retrieval"
        },
        {
          "chunk": "indexed_memory_read_example_code",
          "topic": "program showing GET# usage to pull a buffer to the C64 side"
        }
      ]
    },
    {
      "start": 14097,
      "end": 14133,
      "name": "example_basic_program_memory_read_buffer0",
      "description": "Explains and provides a BASIC example that selects buffer #0 ($0300-$03FF), does a block-read of track 18 sector 0 into that buffer, then uses memory-read (M-R) and GET# to return bytes from buffer #0 to the C64 and print them. Includes the complete BASIC listing (lines 100-310) demonstrating OPENing the command channel, issuing UI (block-read), M-R with CHR$ parameters, GET#, null-byte handling, ASC conversion, printing character and numeric values, and cleanup.",
      "references": [
        {
          "chunk": "memory_read_overview_and_syntax",
          "topic": "shows the M-R command syntax used in the example"
        },
        {
          "chunk": "buffer_sharing_and_get_usage",
          "topic": "covers the GET# retrieval detail illustrated by the program"
        }
      ]
    },
    {
      "start": 14134,
      "end": 14134,
      "ignore": true,
      "reason": "The overlapped lines are blank/formatting whitespace between chunks and non-technical; safe to ignore."
    },
    {
      "start": 14135,
      "end": 14159,
      "name": "two_parameter_memory_read_example",
      "description": "Two-parameter memory-read example: selects buffer #0 ($0300-$03FF) via OPEN 2,8,2,\"#0\", performs PRINT#15,\"U1\";2;0;18;0 to read track 18 sector 0 into that buffer, then loops 0-255 issuing PRINT#15,\"M-R\" CHR$(i) CHR$(3) to retrieve bytes indexed into the buffer; uses GET#15 to transfer each byte to C64 (command channel), converts nulls to CHR$(0), and prints ASCII values/characters within printable range. Demonstrates indexed memory-read and using GET# on the command channel for memory-read responses.",
      "references": [
        {
          "chunk": "memory_read_m-r_syntax",
          "topic": "buffer selection and addressing for M-R"
        },
        {
          "chunk": "three_parameter_memory_read_example",
          "topic": "example that uses all three M-R parameters to read disk name bytes"
        }
      ]
    },
    {
      "start": 14160,
      "end": 14211,
      "name": "three_parameter_memory_read_example",
      "description": "Three-parameter M-R example: demonstrates the alternate format and an example that reads 16 bytes (disk name) from buffer #1 ($0400-$04FF) using PRINT#15,\"M-R\"CHR$(lo)CHR$(hi)CHR$(#) then looping GET# to pull the specified number of bytes into the C64 and assembling a printable disk name.",
      "references": [
        {
          "chunk": "memory_read_parameters",
          "topic": "the optional third parameter CHR$(# of bytes) and its default behavior"
        }
      ]
    },
    {
      "start": 14212,
      "end": 14213,
      "ignore": true,
      "reason": "No lines — sentinel to ensure JSON validity (no actual content)."
    },
    {
      "start": 14214,
      "end": 14247,
      "name": "three_parameter_memory_read_description",
      "description": "Explains the three-parameter memory-read example: selecting buffer #1, doing block-read into that buffer, using a three-parameter memory-read to request a range ($0490-$049F), using a GET# loop to fetch 16 characters, and how inclusion of the third parameter avoids needing an M-R for each byte.",
      "references": [
        {
          "chunk": "three_parameter_memory_read_example",
          "topic": "example implementation and behavior"
        },
        {
          "chunk": "selecting_dos_buffer_open_syntax_and_buffer_table",
          "topic": "buffer #1 address range $0400-$04FF referenced"
        }
      ]
    },
    {
      "start": 14248,
      "end": 14297,
      "name": "memory_write_command",
      "description": "Defines the memory-write (M-W) command: syntax PRINT# file#, \"M-W\" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes) data (alternate with colon). Example usage and notes: up to 34 data bytes per M-W, data may be a string or CHR$ repetition, typical sizes are 8/16/32 for buffer-aligned writes. Mentions that M-W can be used to poke machine code into 1541 RAM for later execution.",
      "references": [
        {
          "chunk": "memory_execute_command",
          "topic": "M-W can be used to write code that M-E can execute"
        },
        {
          "chunk": "edit_load_address_program",
          "topic": "example that uses M-W to change a file's load address in the directory block"
        }
      ]
    },
    {
      "start": 14298,
      "end": 14346,
      "name": "program_header_and_dos_initialization",
      "description": "Program header and initial UI/DOS handshake. Contains the REM header and H* lookup string, UI prompts asking the user to insert a diskette and press RETURN, waits for the RETURN key, opens IEC channel 15 to the 1541 (OPEN15,8,15), sends the DOS inquiry command (PRINT#15,\"10\"), and reads the initial DOS response (INPUT#15,EN*,EM*,ET*,ES*). Handles an immediate '00' response (no error), prints DOS/version info when present, and contains early CLOSE/END branches for failure or unsupported DOS versions.",
      "references": [
        {
          "chunk": "filename_input_and_file_open",
          "topic": "prompts for filename and opens the file after DOS init"
        }
      ]
    },
    {
      "start": 14347,
      "end": 14358,
      "name": "filename_input_and_file_open",
      "description": "Filename input and validation, and attempt to open the file. Prompts the user for the filename, checks filename length constraints, and (on valid input) issues an OPEN2,8,2 with the DOS 'O:' open-for-read (\"O:<filename>,P,R\"). Waits for the drive response (INPUT#15,EN*,EM*,ET*,ES*) and branches on error codes to appropriate handlers.",
      "references": [
        {
          "chunk": "program_header_and_dos_initialization",
          "topic": "uses the earlier DOS/channel initialization and inquiry"
        },
        {
          "chunk": "read_directory_start_block",
          "topic": "next step: read the file's start track/sector after open"
        }
      ]
    },
    {
      "start": 14359,
      "end": 14373,
      "name": "read_directory_start_block",
      "description": "Issue a DOS memory-read (M-R) to query the device for the file's directory/block information and capture the return bytes T and S. Sends the M-R command (PRINT#15,\"M-R\" + CHR$(...)) on channel 15, reads T* and S* via GET#15, converts them to numeric values with ASC( ... + CHR$(0) ), closes channel 2, reads the command status (INPUT#15,EN*,EM*,ET*,ES*), and branches on success or error to subsequent routines.",
      "references": [
        {
          "chunk": "filename_input_and_file_open",
          "topic": "operates on the file opened in channel 2"
        },
        {
          "chunk": "load_disk_block_into_buffer_and_read_bytes",
          "topic": "uses the returned start track/sector to open a scratch buffer and fetch the disk block"
        }
      ]
    },
    {
      "start": 14374,
      "end": 14395,
      "name": "load_disk_block_into_buffer_and_read_bytes",
      "description": "Open a scratch channel (#2) and use DOS U1 to transfer the starting disk block into the drive buffer. Sends the 'U1' command to load the block, checks the drive's EN*/error response, and (on success) issues a memory-read (M-R) of two specific buffer offsets to read the two bytes that hold the file's load address (LOW and HIGH). Converts the two returned characters into numeric LOW and HIGH values using ASC(...+CHR$(0)).",
      "references": [
        {
          "chunk": "read_directory_start_block",
          "topic": "uses the start track/sector from the directory read to identify the block to U1"
        },
        {
          "chunk": "compute_and_display_old_load_address_and_prompt_new",
          "topic": "passes the LOW and HIGH bytes to construct and display the old load address"
        }
      ]
    },
    {
      "start": 14396,
      "end": 14417,
      "name": "compute_and_display_old_load_address_and_prompt_new",
      "description": "Compute the old two-byte load address from the LOW and HIGH bytes read from the buffer. Calls a conversion subroutine (GOSUB 1010) to turn a byte value into a two-character hex string (HD*), accumulates OLA* (old load address) from HIGH and LOW bytes, prints the old load address, prompts for a new four-character hex load address (NLA*), and validates the entered length (must be 4).",
      "references": [
        {
          "chunk": "load_disk_block_into_buffer_and_read_bytes",
          "topic": "receives LOW and HIGH read from the buffer"
        },
        {
          "chunk": "confirm_and_convert_new_address",
          "topic": "next: confirm and convert the entered new hex address"
        },
        {
          "chunk": "conversion_subroutines_decimal_to_hex_and_hex_to_decimal",
          "topic": "uses the decimal->hex subroutine to format the old load address"
        }
      ]
    },
    {
      "start": 14418,
      "end": 14430,
      "name": "confirm_and_convert_new_address",
      "description": "Ask the user to confirm the new load address, then split the entered 4-character hex string into its high and low two-character halves. For each half (HD*), calls the hex->decimal subroutine (GOSUB 1060) to convert the two-character hex string into a numeric byte (assigning to LOW and HIGH). Checks a TME flag set by the converter to detect invalid hex digits and aborts if necessary.",
      "references": [
        {
          "chunk": "compute_and_display_old_load_address_and_prompt_new",
          "topic": "takes the user-entered hex string and confirms it"
        },
        {
          "chunk": "conversion_subroutines_decimal_to_hex_and_hex_to_decimal",
          "topic": "calls the hex->decimal routine to convert hex pairs to numeric bytes"
        },
        {
          "chunk": "write_modified_bytes_back_and_commit",
          "topic": "on success, proceeds to write the converted bytes back into the buffer"
        }
      ]
    },
    {
      "start": 14431,
      "end": 14441,
      "name": "write_modified_bytes_back_and_commit",
      "description": "Write the modified LOW and HIGH bytes back into the drive buffer with a DOS memory-write (M-W) to the correct buffer offsets, then issue the DOS 'U2' command to write the buffer back to disk. Prints/requests the M-W sequence (including CHR$ wrappers), sends the U2 command, reads the drive status via INPUT#15,EN*,EM*,ET*,ES*, and branches on success or failure.",
      "references": [
        {
          "chunk": "confirm_and_convert_new_address",
          "topic": "uses the LOW and HIGH numeric bytes obtained from conversion"
        },
        {
          "chunk": "finalize_success",
          "topic": "on successful write, closes channels and reports DONE"
        },
        {
          "chunk": "error_and_close_handlers",
          "topic": "on failure, jumps to error/close routines"
        }
      ]
    },
    {
      "start": 14442,
      "end": 14448,
      "name": "finalize_success",
      "description": "Final post-write cleanup on success: reads the final status packet from the drive (INPUT#15,EN*,EM*,ET*,ES*), closes channel 15, prints a DONE message, and exits (END).",
      "references": [
        {
          "chunk": "write_modified_bytes_back_and_commit",
          "topic": "normal continuation after a successful U2 write"
        },
        {
          "chunk": "error_and_close_handlers",
          "topic": "alternate paths for error handling and channel closing"
        }
      ]
    },
    {
      "start": 14449,
      "end": 14464,
      "name": "error_and_close_handlers",
      "description": "Error and close handler routines used by various failure branches. Prints the returned EN*, EM*, ET*, ES* status codes, displays a FAILED message (with visual emphasis markers), closes the appropriate channel (15 or 2), and ends execution. Several labels handle different failure contexts (closing channel 15, closing channel 2, or reading final status and then closing).",
      "references": [
        {
          "chunk": "write_modified_bytes_back_and_commit",
          "topic": "used when the write or device response indicates failure"
        },
        {
          "chunk": "finalize_success",
          "topic": "contrasts the success cleanup path"
        }
      ]
    },
    {
      "start": 14465,
      "end": 14506,
      "name": "conversion_subroutines_decimal_to_hex_and_hex_to_decimal",
      "description": "Two subroutines: decimal-to-hex (REM DECIMAL TO HEXADECIMAL) and hex-to-decimal (REM HEXADECIMAL TO DECIMAL). The decimal->hex routine computes high and low nybbles (H = INT(D/16); L = D - H*16) and assembles a two-character hex string HD* from a lookup (MID$ on the H* string). The hex->decimal routine scans hex characters to find their numeric values, sets a TME error flag on invalid input, computes the numeric byte D = H*16 + L and returns. These routines are called elsewhere to convert between numeric bytes and two-character hex representations for display and disk-writing.",
      "references": [
        {
          "chunk": "compute_and_display_old_load_address_and_prompt_new",
          "topic": "used to format the existing LOW/HIGH bytes as a printable hex address"
        },
        {
          "chunk": "confirm_and_convert_new_address",
          "topic": "used to convert the user's hex input into numeric LOW/HIGH bytes"
        }
      ]
    },
    {
      "start": 14507,
      "end": 14508,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14509,
      "end": 14562,
      "name": "edit_load_address_line_descriptions",
      "description": "Line-range descriptions for the 'edit load address' program: which groups of lines perform DOS version query, filename input, open direct-access channel to buffer #1, block-read of starting block, three-parameter memory-read fetching load address bytes ($0502-$0503), decimal/hex conversions, M-W of new load address, writing the buffer back to disk (U2), and error handling.",
      "references": [
        {
          "chunk": "edit_load_address_program",
          "topic": "maps code segments to functional descriptions"
        }
      ]
    },
    {
      "start": 14563,
      "end": 14563,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14564,
      "end": 14596,
      "name": "block_allocate_command",
      "description": "Describes the block-allocate (B-A) command which marks a sector as 'in use' in the BAM by setting its associated bit low (0) on track 18 sector 0. Syntax: PRINT# file#, \"B-A\"; drive; track; sector (alternate with colon). Example: PRINT#15, \"B-A\";0;1;7. Explains valid ranges and cautions that allocated sectors are prevented from being used by normal DOS writes, but can be overwritten via direct-access block-write (U2).",
      "references": [
        {
          "chunk": "block_allocate_program",
          "topic": "example program that allocates every sector on a diskette"
        },
        {
          "chunk": "bam_and_bam_handling_notes",
          "topic": "why BAM must be handled carefully when allocating blocks, directory caveats"
        }
      ]
    },
    {
      "start": 14597,
      "end": 14597,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14598,
      "end": 14648,
      "name": "block_allocate_program",
      "description": "Program example (BASIC) that opens a direct-access channel and iterates through tracks/sectors issuing B-A commands to allocate sectors. It demonstrates reading the drive's error responses to detect when allocation returns next available track/sector and stops when all sectors are allocated. Shows how to avoid allocating the directory track (track 18).",
      "references": [
        {
          "chunk": "block_allocate_command",
          "topic": "illustrates syntax and error handling of B-A"
        }
      ]
    },
    {
      "start": 14649,
      "end": 14649,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14650,
      "end": 14724,
      "name": "block_allocate_notes_and_bam_update",
      "description": "Explains alternate format for B-A, notes why OPEN/CLOSE of a direct-access channel is important (BAM rewrite to disk on close), and discusses that the BAM is updated on-the-fly but erratically — recommends open/close discipline. Also explains odd behavior of errors when saving to a full disk and how allocated blocks are freed only by validation; allocated directory sectors are never deallocated by DOS automatically.",
      "references": [
        {
          "chunk": "block_allocate_program",
          "topic": "why the program opens/closes the direct-access channel repeatedly"
        },
        {
          "chunk": "bam_and_bam_handling_notes",
          "topic": "further detail about persistence of allocated directory sectors and validation"
        }
      ]
    },
    {
      "start": 14725,
      "end": 14735,
      "name": "certify_program_header_and_variable_initialization",
      "description": "Program header and initial variable/buffer setup for the 'CERTIFY A DISKETTE' routine. Contains the REM title, early garbage-corrected BASIC lines that define and initialize buffers/strings (NULL*, WRITE*, NEXT I), and DIM statements for arrays used later in the certifier.",
      "references": [
        {
          "chunk": "user_prompts_and_drive_check",
          "topic": "continues with user prompts and drive status checking"
        },
        {
          "chunk": "buffer_init_certify_loop_and_restore_bam",
          "topic": "uses the buffers and variables initialized here for writing and certification"
        }
      ]
    },
    {
      "start": 14736,
      "end": 14775,
      "name": "user_prompts_and_drive_check",
      "description": "User interaction and drive initialization sequence for the certifier. Includes warning and confirmation PRINTs, input loop waiting for RETURN, opening the DOS command channel (OPEN 15,8,15), issuing the '10' command to query DOS, and handling the initial response (INPUT#15, EN*, EM*, ET*, ES*). Ends with an early exit if DOS query fails.",
      "references": [
        {
          "chunk": "certify_program_header_and_variable_initialization",
          "topic": "uses variables/buffers set up in the header"
        },
        {
          "chunk": "read_bam_and_dos_check",
          "topic": "follows up with reading BAM and checking DOS version"
        }
      ]
    },
    {
      "start": 14776,
      "end": 14805,
      "name": "read_bam_and_dos_check",
      "description": "Routine to read the BAM (block availability map) from the disk into memory and verify DOS version. Issues a DOS read (M-R) to fetch BAM blocks into a BAM* string, concatenates them, derives DOS version from the BAM contents, and handles failures by printing DOS version or 'failed' and exiting.",
      "references": [
        {
          "chunk": "user_prompts_and_drive_check",
          "topic": "invoked after the initial DOS drive query"
        },
        {
          "chunk": "buffer_init_certify_loop_and_restore_bam",
          "topic": "this stored BAM image is later used/restored to work around a block-allocate bug"
        },
        {
          "chunk": "annotated_line_range_summary",
          "topic": "explains why the BAM is stored (lines 330-380) and restored (800-890)"
        }
      ]
    },
    {
      "start": 14806,
      "end": 14916,
      "name": "buffer_init_certify_loop_and_restore_bam",
      "description": "Main certification logic and buffer management. Writes a worst-case binary pattern into the C64 RAM buffer at $0400 (M-W writes), initializes track/sector/counters (T, S, C, A), issues block-allocate (B-A) commands to write the pattern into unallocated sectors, prints progress/status messages, records bad sectors into an error array, and contains the sequence to restore the original BAM image back to the disk to compensate for a block-allocate command bug. Handles cases where all sectors are allocated, and prints summary messages.",
      "references": [
        {
          "chunk": "read_bam_and_dos_check",
          "topic": "uses the BAM snapshot read earlier to restore after certification"
        },
        {
          "chunk": "job_queue_and_subroutines",
          "topic": "uses disk subroutines (seek/write) and job-queue logic referenced later"
        },
        {
          "chunk": "annotated_line_range_summary",
          "topic": "includes mapping to the program line annotations (e.g., write buffer, block-allocate, error array)"
        }
      ]
    },
    {
      "start": 14917,
      "end": 14972,
      "name": "job_queue_and_subroutines",
      "description": "Post-certification steps, bad-sector allocation routine and low-level disk job support routines. Contains code that allocates any recorded bad sectors from the error array (looping PRINT#15 'B-A' calls), and small subroutines for SEEK and WRITE (JOB values), plus the JOB QUEUE implementation (assembling M-W/M-R job packets, retry logic, reading job results, and returning with error handling).",
      "references": [
        {
          "chunk": "buffer_init_certify_loop_and_restore_bam",
          "topic": "called/used to perform the actual disk write/allocate operations during certification"
        },
        {
          "chunk": "annotated_line_range_summary",
          "topic": "points to where these subroutines are documented for intermediate disk programming (lines 1020-1230)"
        }
      ]
    },
    {
      "start": 14973,
      "end": 15031,
      "name": "annotated_line_range_summary",
      "description": "Annotated mapping and explanatory notes for the CERTIFY program. Lists which program line ranges perform specific tasks (e.g., 330-380 store the BAM, 390-440 query DOS version, 460-500 write worst-case pattern to $0400, 510-540 initialize counters, 550 block-allocate command, 700 write pattern to a deallocated track/sector, 710 query error channel, 720-740 error array, 800-890 restore BAM, 960-980 allocate bad sectors). Also explains that lines 330-380 and 800-890 compensate for a block-allocate bug, and that lines 1020-1230 (job queue) are detailed in Chapter 6.",
      "references": [
        {
          "chunk": "read_bam_and_dos_check",
          "topic": "explains the BAM-store referenced in lines 330-380"
        },
        {
          "chunk": "buffer_init_certify_loop_and_restore_bam",
          "topic": "summarizes the certification and restore behavior described in multiple line ranges"
        },
        {
          "chunk": "job_queue_and_subroutines",
          "topic": "notes that the job-queue logic (lines 1020-1230) is covered in more detail elsewhere"
        }
      ]
    },
    {
      "start": 15032,
      "end": 15082,
      "name": "block_free_command_description",
      "description": "Documentation for the CBM DOS Block-Free command (B-F). Describes purpose (deallocates a sector in the BAM by setting its bit high on track 18 sector 0), provides syntax and alternate syntax (PRINT#file#, \"B-F\"; drive#; track; sector or \"B-F:\"), an example (PRINT#15, \"B-F\";0;1;7), and defines parameters (file#, drive#, track range 1-35, sector range 0.. per-track). Introduces the sample program that follows to deallocate every sector on a diskette.",
      "references": [
        {
          "chunk": "block_free_example_program",
          "topic": "the sample BASIC program that deallocates every sector (follows this description)"
        }
      ]
    },
    {
      "start": 15083,
      "end": 15127,
      "name": "block_free_example_program",
      "description": "Sample BASIC program 'BLOCK-FREE' that deallocates every sector on a diskette. Includes opening the command channel (OPEN 15,8,15), querying DOS (PRINT#15, \"10\" and INPUT#15,EN*,EM*,ET*,ES*), opening a direct-access channel (OPEN 2,8,2,\"#\"), looping tracks 1..35 (skipping track 18 directory), computing per-track sector counts, issuing 'B-F' commands for every sector, counting and printing progress, and closing channels. Also includes a small line-range annotation summarizing key lines (e.g., 150 open direct-access channel; 160 begin track loop; 170 skip directory).",
      "references": [
        {
          "chunk": "block_free_command_description",
          "topic": "implements the described B-F command to deallocate sectors"
        }
      ]
    },
    {
      "start": 15128,
      "end": 15231,
      "name": "certify_program_comments_and_bam_rationale",
      "description": "Line-range descriptions and commentary for the certify program: explains storing the BAM locally (lines that compensate for a B-A bug), writing worst-case patterns to buffers, block-allocating deallocated tracks/sectors, restoring the BAM, and allocating any bad sectors recorded. Notes alternative PRINT# formats and pointers to later chapters for low-level detail.",
      "references": [
        {
          "chunk": "certify_diskette_program",
          "topic": "maps parts of the program to their functions and rationale"
        },
        {
          "chunk": "block_allocate_notes_and_bam_update",
          "topic": "why storing/restoring BAM is necessary"
        }
      ]
    },
    {
      "start": 15232,
      "end": 15299,
      "name": "block_free_command",
      "description": "Describes the block-free (B-F) command, which deallocates a sector in the BAM by setting its associated bit high (1) on track 18 sector 0. Syntax: PRINT# file#, \"B-F\"; drive; track; sector (alternate with colon). Example: PRINT#15, \"B-F\";0;1;7. Includes a BASIC example that iterates tracks/sectors and issues B-F to deallocate every sector on a disk (with the usual caution to skip track 18 directory).",
      "references": [
        {
          "chunk": "block_allocate_command",
          "topic": "inverse operation to B-A; use to free previously allocated sectors"
        }
      ]
    },
    {
      "start": 15300,
      "end": 15323,
      "name": "example_listing_header_and_block_execute_alternates",
      "description": "Program listing header and short summary of the example program lines (150, 160, 190, 200, 210, 220) describing buffer area ($0600-$06FF), plus the alternate PRINT#15 formats for the block-execute (B-E) command shown in the listing.",
      "references": [
        {
          "chunk": "direct_access_entomology_intro_and_block_read_overview",
          "topic": "context: begins the Direct-Access Entomology discussion that follows this example header"
        },
        {
          "chunk": "block_read_demo_program",
          "topic": "the B-R demo program referenced by the header (demonstration code)"
        }
      ]
    },
    {
      "start": 15324,
      "end": 15348,
      "name": "direct_access_entomology_intro_and_block_read_overview",
      "description": "Section 5.12 introduction to 'Direct-Access Entomology' and an overview of Block-Read (B-R) anomalies: why B-R is unreliable, GET# behavior returning a byte count related to the track number, erroneous EOI (End-Or-Identify), ST being set to 64, repeated bytes if further reads attempted, and the need to reset the buffer pointer to access byte 0.",
      "references": [
        {
          "chunk": "example_listing_header_and_block_execute_alternates",
          "topic": "example header that precedes this discussion"
        },
        {
          "chunk": "block_read_demo_program",
          "topic": "contains the BASIC example program to 'See for yourself' demonstrating B-R behavior"
        }
      ]
    },
    {
      "start": 15349,
      "end": 15384,
      "name": "block_read_demo_program",
      "description": "Complete BASIC demonstration program that exercises the B-R (block-read) behavior: OPEN 15, PRINT#15, INPUT#15 for error/status, OPEN channel to buffer, a B-R command (PRINT#15 'B-R';...), status checks, B-P pointer reset, a FOR loop with GET# to read buffer bytes, ASCII/ASC printing and printable-character filtering, and cleanup CLOSE/END.",
      "references": [
        {
          "chunk": "direct_access_entomology_intro_and_block_read_overview",
          "topic": "illustrates the B-R anomalies described in the overview"
        },
        {
          "chunk": "block_read_and_block_write_interaction_and_recommendation",
          "topic": "follow-up discussion: how B-R behaves after a B-W rewrite of a sector"
        }
      ]
    },
    {
      "start": 15385,
      "end": 15405,
      "name": "block_read_and_block_write_interaction_and_recommendation",
      "description": "Explains the interaction when B-R reads a sector previously rewritten by Block-Write (B-W): the EOI is tied to the ASCII value of byte 0 (which B-W overwrites with the buffer-pointer position), destroying the forward-track link and limiting readable characters to that byte's value. Advises changing the track parameter in the demo (line 160) and recommends using the Ul command instead of B-R; notes manuals often ignore Ul or don't explain its use.",
      "references": [
        {
          "chunk": "block_read_demo_program",
          "topic": "indicates which line (line 160) to change in the demo program to observe the effect"
        },
        {
          "chunk": "block_write_behavior_and_demo_program",
          "topic": "explains how B-W writes the buffer-pointer into byte 0 and breaks links"
        }
      ]
    },
    {
      "start": 15406,
      "end": 15449,
      "name": "block_write_behavior_and_demo_program",
      "description": "Block-Write (B-W) explanation and BASIC demo: describes that B-W records bytes 1–255 correctly but writes the buffer-pointer's final position into byte 0 (overwriting the forward-track pointer), preserving data but destroying the forward link. Includes a complete BLOCK-WRITE sample program (OPEN 15, PRINT#15 sequences, PRINT#2 to send buffer data, B-P, B-W invocation, CLOSE/END).",
      "references": [
        {
          "chunk": "block_read_and_block_write_interaction_and_recommendation",
          "topic": "explains the root cause of the B-R EOI behavior previously described"
        },
        {
          "chunk": "effect_of_block_write_on_subsequent_block_read",
          "topic": "shows the practical result when you read the rewritten sector with B-R vs Ul"
        }
      ]
    },
    {
      "start": 15450,
      "end": 15463,
      "name": "effect_of_block_write_on_subsequent_block_read",
      "description": "Procedure and result of running the original block-read/Ul program against a diskette rewritten by the B-W demo: change the Ul to a B-R in line 160 and observe that only a number of bytes equal to the buffer-pointer value (e.g., 5) are accessible before EOI is returned; demonstrates why Ul/U2 are preferable to B-R/B-W.",
      "references": [
        {
          "chunk": "block_write_behavior_and_demo_program",
          "topic": "the B-W program that causes byte 0 to contain the buffer-pointer value"
        },
        {
          "chunk": "block_read_demo_program",
          "topic": "the block-read program you must re-run/modify to observe the effect"
        }
      ]
    },
    {
      "start": 15464,
      "end": 15486,
      "name": "uj_and_ui_warm_reset_quirks_and_recovery",
      "description": "Discussion of UJ and UI- USER commands: UJ is intended as a 1541 warm reset (like SYS 64738 on the C64) but in practice hangs the 1541. Gives recovery advice (press RUN/STOP + RESTORE) and supplies a one-liner (OPEN 15,8,15,\"UJ\":CLOSE15) while recommending using the U: form instead of UJ. Notes that UI- (setting 1541 to VIC-20 speed) also causes issues.",
      "references": [
        {
          "chunk": "effect_of_block_write_on_subsequent_block_read",
          "topic": "previous low-level I/O discussion and examples"
        },
        {
          "chunk": "user_commands_intro_and_u3_example_start",
          "topic": "next: introduction to the USER commands and the U3 example program"
        }
      ]
    },
    {
      "start": 15487,
      "end": 15499,
      "name": "user_commands_intro_and_u3_example_start",
      "description": "Introductory note that the VIC-series User's Manual outlines seven USER commands that jump to locations in RAM and mentions their jump addresses (list omitted here), a comment that these jump locations are simpler than they appear, and the start of a modified memory-execute example (REM U3 and the beginning OPEN 15,8,15) to demonstrate USER commands.",
      "references": [
        {
          "chunk": "uj_and_ui_warm_reset_quirks_and_recovery",
          "topic": "related USER-command discussion (UJ/UI-) and why USER commands are notable"
        },
        {
          "chunk": "block_write_behavior_and_demo_program",
          "topic": "related I/O/memory-execute techniques referenced earlier in the disk-utility command discussion"
        }
      ]
    },
    {
      "start": 15500,
      "end": 15580,
      "name": "uj_ui_and_user_commands_notes",
      "description": "Explains UJ (warm reset) and UI- (VIC-20 speed) anomalies: UJ is intended as a warm reset for the 1541 but may hang the drive; U: can be used instead of UJ. UI- was implemented to set 1541 to VIC-20 speed. Discusses USER commands (U3–U9) which jump to predefined RAM addresses, and notes that U3–U8 jump into $0500 page (buffer #2) and U9 jumps to $FFA (alternate reset bypassing power-on diagnostics).",
      "references": [
        {
          "chunk": "memory_execute_command",
          "topic": "U3-U8 operate similarly to memory-execute by jumping into buffer areas"
        }
      ]
    },
    {
      "start": 15581,
      "end": 15619,
      "name": "chapter6_intro_and_job_queue_overview",
      "description": "Chapter 6 introduction to intermediate direct-access programming: describes passing requests directly to the Floppy Disk Controller (FDC) via the job queue. Explains that the IP parses C64 commands into jobs which are poked into the job queue and are scanned by the FDC every 10 ms. Lists the high-level jobs FDC can perform (read sector, write sector, verify, seek, bump head, jump to routine, execute routine) and introduces that each job has a job code.",
      "references": [
        {
          "chunk": "job_codes_table",
          "topic": "hex and decimal job codes used by the FDC"
        },
        {
          "chunk": "job_queue_read_example",
          "topic": "example showing how to stuff job queue entries directly"
        }
      ]
    },
    {
      "start": 15620,
      "end": 15692,
      "name": "job_codes_table",
      "description": "Mapping of job purpose to FDC job code values: READ $80 (128), WRITE $90 (144), VERIFY $A0 (160), SEEK $B0 (176), BUMP $C0 (192), JUMP $D0 (208), EXECUTE $E0 (224). Also introduces that the FDC replaces job code with an error code when done and that IP error codes map to human-readable errors returned on the error channel.",
      "references": [
        {
          "chunk": "fdc_ip_error_codes_table",
          "topic": "table mapping FDC codes to IP codes and messages"
        }
      ]
    },
    {
      "start": 15693,
      "end": 15776,
      "name": "fdc_ip_error_codes_table",
      "description": "Partial table showing a few FDC-to-IP error code mappings and their English messages (e.g., FDC $01 => IP 0 OK; $02 => IP 20; $03 => IP 21 READ ERROR (non-specific); $04 => IP 22 READ ERROR (data block not present); $07 => IP 25 WRITE ERROR; $08 => IP 26 WRITE PROTECT ON; $09 => IP 27 header checksum error; $0B => IP 29 disk ID mismatch). Points to Chapter 7 for fuller descriptions.",
      "references": [
        {
          "chunk": "job_codes_table",
          "topic": "jobs produce these FDC codes which are mapped to IP errors"
        },
        {
          "chunk": "job_queue_read_example",
          "topic": "example uses reading a sector and checking job result via error channel"
        }
      ]
    },
    {
      "start": 15777,
      "end": 15798,
      "name": "direct_access_intro_and_example_summary",
      "description": "Introduces direct-access programming for the 1541 FDC, explains that a successful job request returns (00, OK, 00, 00) and that the sector contents can be retrieved from buffer $0300-$03FF via GET#. Presents the motivation for bypassing the drive parser to work the FDC directly and describes the example's goal: read track 18 sector 0 into buffer 0 ($0300-$03FF) and print it to the screen (a modification of an earlier example).",
      "references": [
        {
          "chunk": "basic_job_queue_read_program_listing",
          "topic": "BASIC program that implements the described direct-access read"
        },
        {
          "chunk": "job_queue_mechanism_and_job_code_bit7",
          "topic": "How jobs are written to the job/header tables and how completion is detected"
        }
      ]
    },
    {
      "start": 15799,
      "end": 15874,
      "name": "basic_job_queue_read_program_listing",
      "description": "Complete BASIC listing of the example program that works the job queue directly. Includes the main program (open command channel, initialize drive, SEEK and READ job submissions, looping to GET# 256 bytes from buffer $0300-$03FF and printing them) and the JOB QUEUE subroutine (prepare job/header entries, write job code, poll for job completion, and return).",
      "references": [
        {
          "chunk": "direct_access_intro_and_example_summary",
          "topic": "Context and purpose of this BASIC example"
        },
        {
          "chunk": "program_line_by_line_explanation",
          "topic": "Line-range descriptions explaining each portion of this listing"
        },
        {
          "chunk": "job_queue_mechanism_and_job_code_bit7",
          "topic": "Mechanics of stuffing job/header entries and waiting for completion"
        }
      ]
    },
    {
      "start": 15875,
      "end": 15938,
      "name": "program_line_by_line_explanation",
      "description": "Annotated, line-range-by-line-range explanation of the BASIC listing. Explains the function of each labeled line or range: opening/closing the channel, drive initialization, track/sector setup, SEEK and READ job submissions, error queries, the 256-byte loop transferring from buffer 0 via GET#, byte conversion/printing, and the subroutine's TRY counter, header/job table writes, polling loop, and return with the FDC error code.",
      "references": [
        {
          "chunk": "basic_job_queue_read_program_listing",
          "topic": "See the actual BASIC code lines that these descriptions correspond to"
        },
        {
          "chunk": "job_queue_mechanism_and_job_code_bit7",
          "topic": "Details about which buffer/header/job addresses are used and the job-completion bit semantics"
        }
      ]
    },
    {
      "start": 15939,
      "end": 15958,
      "name": "job_queue_mechanism_and_job_code_bit7",
      "description": "Explains the core job-queue mechanism: the subroutine writes track and sector into the buffer's header table and the job code into the job-queue table, then polls the job byte until the FDC clears bit 7. Specifies the example buffer 0 mapping: header addresses $0006 (track) and $0007 (sector) and job code at $0000. Explains convention that job codes have bit 7 set (>127) and completed jobs are replaced by error codes with bit 7 cleared (<128), so waiting checks bit 7 until cleared.",
      "references": [
        {
          "chunk": "basic_job_queue_read_program_listing",
          "topic": "Where the subroutine writes the track/sector and job code"
        },
        {
          "chunk": "fdc_error_handling_and_job_hierarchy",
          "topic": "How to interpret the returned FDC error codes after job completion"
        },
        {
          "chunk": "warning_dangers_of_bypassing_parser_and_alignment_requirements",
          "topic": "Risks when directly manipulating job/header tables and bypassing parser protections"
        }
      ]
    },
    {
      "start": 15959,
      "end": 15968,
      "name": "fdc_error_handling_and_job_hierarchy",
      "description": "Covers FDC error-code semantics and job ordering: an FDC error code of 1 (or 00/OK) indicates successful completion; any other nonzero value indicates an error. Notes the hierarchy used in the program listing: SEEK (find track) must precede READ of a sector. Also states that initialization (drive init) is not strictly necessary when working the job queue directly, though the example includes it as habit; direct access can be used for damaged or DOS-protected disks.",
      "references": [
        {
          "chunk": "job_queue_mechanism_and_job_code_bit7",
          "topic": "How job completion is detected so that these error codes are read"
        },
        {
          "chunk": "warning_dangers_of_bypassing_parser_and_alignment_requirements",
          "topic": "Practical risks and caveats when skipping the parser and handling job/header entries"
        }
      ]
    },
    {
      "start": 15969,
      "end": 15999,
      "name": "warning_dangers_of_bypassing_parser_and_alignment_requirements",
      "description": "Detailed WARNING about the dangers of bypassing the drive parser and working the job queue directly. Explains that bypassing the parser removes built-in protections: issuing out-of-range track numbers (e.g., track 99) can cause the head to step beyond normal boundaries and physically lock; while sectors out of range produce an FDC error, stepper motor movement risks requiring manual repositioning after power-off. Emphasizes the necessity of keeping header-table and job-queue locations correctly aligned with the buffer number being used; mismatches can cause the FDC to attempt nonexistent jobs or seek invalid tracks, potentially leaving the drive in an uncontrolled state requiring power cycle or manual intervention.",
      "references": [
        {
          "chunk": "job_queue_mechanism_and_job_code_bit7",
          "topic": "Why precise header/job table addresses and bit-handling matter"
        },
        {
          "chunk": "fdc_error_handling_and_job_hierarchy",
          "topic": "Consequences for error handling and the importance of proper job ordering"
        }
      ]
    },
    {
      "start": 16000,
      "end": 16100,
      "name": "job_queue_read_disk_name_example",
      "description": "BASIC program example that reads track 18 sector 0 into buffer #1 by direct job-queue operations: SEEK (job 176), then READ (job 128) into buffer #1, then uses three-parameter M-R to read bytes 144-159 ($0490-$049F) and assembles the disk name by fetching 16 bytes, normalizing nonprintable characters and quotes to '?'. Shows the job-queue subroutine that writes track/sector into header table and job code into job queue, with a TRY loop to poll for completion and reading job response via GET#.",
      "references": [
        {
          "chunk": "job_queue_buffer_mapping_and_read_example",
          "topic": "uses buffer #1 mapping ($0400-$04FF => job $0001, header $0008/$0009)"
        }
      ]
    },
    {
      "start": 16101,
      "end": 16201,
      "name": "seek_read_review_and_buffer_addresses",
      "description": "Overview and review of a SEEK/READ example using buffer #1. Covers: initializing track (18) and sector (0); issuing SEEK and READ jobs; checking FDC error code; three-parameter memory-read (M-R) of the directory area; concatenating disk name bytes into a printable ASCII representation; setting up try counter and job queue entries; key memory addresses for working buffer #1 ($0400-$04FF), header table track/sector addresses ($0008-$0009), and job-queue job code location ($0001). Also explains job order (SEEK then READ) and introduces the next program which will use buffer #2 ($0500-$05FF) with header addresses $000A/$000B and job-queue location $0002.",
      "references": [
        {
          "chunk": "basic_ui_and_device_open_error_check",
          "topic": "BASIC program start: UI, opening device, and initial error check"
        },
        {
          "chunk": "job_queue_subroutine_and_error_handler",
          "topic": "Job queue mechanics and error handling used by the examples"
        }
      ]
    },
    {
      "start": 16202,
      "end": 16244,
      "name": "basic_ui_and_device_open_error_check",
      "description": "BASIC program header and user-interface setup. Covers: REM header; building PAD* via a FOR..NEXT loop; printing introductory messages prompting the user to remove/insert diskette and press RETURN; waiting for RETURN (GET C* loop); printing OK; opening device 15 (OPEN 15,8,15); sending command channel '10' to the drive (PRINT#15,\"10\"); reading the drive's initial response (INPUT#15,EN*,EM*,ET*,ES*); checking EN* for \"00\" success and, if an error, printing EN*/EM*/ET*/ES*, closing the channel and ENDing the program.",
      "references": [
        {
          "chunk": "seek_read_and_disk_name_fetch_and_edit_input",
          "topic": "Performs SEEK/READ and retrieves the disk name after device open"
        },
        {
          "chunk": "job_queue_subroutine_and_error_handler",
          "topic": "Uses the job-queue subroutine (GOSUB 660) to perform SEEK/READ"
        }
      ]
    },
    {
      "start": 16245,
      "end": 16299,
      "name": "seek_read_and_disk_name_fetch_and_edit_input",
      "description": "BASIC code that issues SEEK and READ jobs via the job queue and fetches the disk name for editing. Covers: setting T=18 and S=0; setting JOB codes for SEEK (176) and READ (128) and calling the shared job-queue subroutine (GOSUB 660); sending an M-R (memory-read) to the drive to fetch 16 bytes of the disk name; per-byte processing to ensure printable ASCII (strip high bit, replace out-of-range bytes and quotes with '?'); assembling ODN* (old disk name) and printing it; prompting the user for NDN* (new disk name); validating length and, on confirmation, padding/truncating the new name to 16 bytes with PAD* (NDN*=LEFT*(NDN*+PAD*,16)); includes input flow with Y/N confirmation and FALLBACK to close/END if not confirmed.",
      "references": [
        {
          "chunk": "basic_ui_and_device_open_error_check",
          "topic": "Relies on the device being opened and initial status checked"
        },
        {
          "chunk": "write_new_disk_name_and_finalize",
          "topic": "Sends the new name (M-W) into the buffer and issues WRITE via job queue"
        },
        {
          "chunk": "job_queue_subroutine_and_error_handler",
          "topic": "GOSUB 660 handles the low-level M-W/M-R job queue operations used here"
        }
      ]
    },
    {
      "start": 16300,
      "end": 16324,
      "name": "write_new_disk_name_and_finalize",
      "description": "BASIC code that writes the edited disk name back to the buffer and issues a WRITE job to the drive, then finalizes. Covers: sending an M-W (memory-write) to transfer the 16-byte NDN* into the drive buffer; setting JOB=144 (WRITE) and calling the job-queue subroutine (GOSUB 660) to perform the WRITE; polling the drive with command '10' and reading the returned EN*,EM*,ET*,ES* status; closing the command channel; printing a DONE message; and program END/cleanup (including alternative CLOSE/END labels at lines 630/640).",
      "references": [
        {
          "chunk": "seek_read_and_disk_name_fetch_and_edit_input",
          "topic": "Provides NDN* (the new 16-byte disk name) to be sent by M-W"
        },
        {
          "chunk": "job_queue_subroutine_and_error_handler",
          "topic": "Performs the actual SEEK/READ/WRITE job processing and polling"
        }
      ]
    },
    {
      "start": 16325,
      "end": 16374,
      "name": "job_queue_subroutine_and_error_handler",
      "description": "Implementation of the job-queue subroutine (GOSUB 660) and its error handler. Covers: TRY counter initialization; issuing M-W commands to write the header table (track T and sector S) and job-queue entry (JOB) into the drive's memory via PRINT#15 M-W sequences; polling loop that increments TRY, issues an M-R to read status (E*), normalizes empty responses to zero and converts E* to numeric E; timeout handling (TRY=500) and loop continuation while status indicates 'in progress' (E>127 case); detecting successful completion (E=1 then RETURN); and a comprehensive error handler that formats track (ET*) and sector (ES*) strings, maps FDC error codes to EN*/EM* messages (including WRITE/READ errors and timeout), prints a formatted error report, closes the channel and ends the program. This subroutine is used by SEEK, READ and WRITE operations elsewhere in the listing.",
      "references": [
        {
          "chunk": "seek_read_review_and_buffer_addresses",
          "topic": "Explains the job order and memory addresses the subroutine manipulates"
        },
        {
          "chunk": "write_new_disk_name_and_finalize",
          "topic": "Called (GOSUB 660) to perform the WRITE job and poll for completion"
        },
        {
          "chunk": "seek_read_and_disk_name_fetch_and_edit_input",
          "topic": "Called (GOSUB 660) to perform SEEK and READ jobs used to fetch the disk name"
        }
      ]
    },
    {
      "start": 16375,
      "end": 16445,
      "name": "job_queue_examples_error_handling_and_execute_job_behaviour",
      "description": "Covers job-queue example operations and the job-queue error handler: sample job steps (SEEK, READ sector 0 of track 18 into buffer $0500-$05FF, WRITE buffer back to track 18 sector 0, and an error handler). Explains conversion from FDC error codes to IP codes (add 18 to restrict IP errors to 20–29), handling of out-of-range FDC codes (treated as TIME OUT), automatic VERIFY after an FDC WRITE (WRITE $90 is followed by VERIFY $A0; mismatches show FDC error 7 → IP error 25 WRITE ERROR), the pointless BUMP job ($C0), the JUMP job ($D0) behavior (executes a RAM machine-language routine), and detailed EXECUTE job ($E0) behavior: FDC ensures drive up to speed, head on correct track, head settled; EXECUTE is non-interruptible (no BRK debugging), and the programmer must set the job code to $01 at the end of the routine to signal completion or the FDC will re-run it.",
      "references": [
        {
          "chunk": "dos_protection_sector_structure_and_gcr_encoding_intro",
          "topic": "Next chapter starts: DOS protection and data encoding basics (sector layout, sync marks, GCR encoding)"
        }
      ]
    },
    {
      "start": 16446,
      "end": 16546,
      "name": "dos_protection_sector_structure_and_gcr_encoding_intro",
      "description": "Introduces CHAPTER 7: DOS PROTECTION and Commodore's data encoding scheme. Describes how a 1541 sector is divided into a Header Block (16 bytes: sync, header ID $08, header checksum, sector number, track number, ID LO, ID HI, off bytes $0F, header gap $55) and a Data Block (260 bytes: sync, data block ID $07, 256 data bytes, data checksum, off bytes $00, tail gap $55). Explains continuous bitstream writing on a track, purpose of sync marks (DOS 2.6 sync = five $FF bytes) and the two write modes (sync vs normal). Introduces the binary→GCR conversion process: split each 8-bit byte into high and low 4-bit nybbles, example using $12 (%00010010), and prepares for the 16-entry GCR lookup table that follows.",
      "references": [
        {
          "chunk": "job_queue_examples_error_handling_and_execute_job_behaviour",
          "topic": "Previous chapter: job queue examples and EXECUTE job details (error mapping and non-interruptible execution)"
        }
      ]
    },
    {
      "start": 16547,
      "end": 16646,
      "name": "gcr_lookup_table_mapping_nybbles_to_5bit_codes",
      "description": "The 1541's binary-to-GCR lookup table mapping 4-bit nybbles (hex 0–F) to 5-bit GCR codes. Contains the table of hexadecimal, binary, and corresponding 5-bit GCR encodings (including the special mapping for $F).",
      "references": [
        {
          "chunk": "gcr_conversion_example_single_byte_0x12",
          "topic": "Shows how to use this lookup table to convert a byte to GCR"
        },
        {
          "chunk": "gcr_design_constraints_no_sync_confusion_and_max_zero_runs",
          "topic": "Explains reasons behind the table's design constraints"
        }
      ]
    },
    {
      "start": 16647,
      "end": 16666,
      "name": "gcr_conversion_example_single_byte_0x12",
      "description": "Step-by-step conversion of a single byte ($12) into GCR: hexadecimal to binary, high-nybble and low-nybble lookup to 5-bit GCR codes, and concatenation into a 10-bit GCR sequence.",
      "references": [
        {
          "chunk": "gcr_lookup_table_mapping_nybbles_to_5bit_codes",
          "topic": "Lookup table used for the high/low nybble conversions"
        },
        {
          "chunk": "gcr_packing_four_bytes_into_five_gcr_bytes_example",
          "topic": "Shows how multi-byte sequences are grouped and packed after nybble→GCR conversion"
        }
      ]
    },
    {
      "start": 16667,
      "end": 16677,
      "name": "gcr_design_constraints_no_sync_confusion_and_max_zero_runs",
      "description": "Two key properties of the 1541 binary→GCR mapping: (1) no pair of 5-bit GCR codes can produce 10 consecutive '1' bits (preventing data being mistaken for the sync mark), and (2) no more than two consecutive '0' bits appear in any 10-bit GCR byte or combination (helpful for clock recovery when reading).",
      "references": [
        {
          "chunk": "gcr_lookup_table_mapping_nybbles_to_5bit_codes",
          "topic": "The table enforces these constraints"
        },
        {
          "chunk": "gcr_sync_mark_and_ff_write_behavior",
          "topic": "Explains how sync marks are produced and why the constraints matter"
        }
      ]
    },
    {
      "start": 16678,
      "end": 16689,
      "name": "gcr_sync_mark_and_ff_write_behavior",
      "description": "Defines what constitutes a sync mark (10 or more consecutive '1' bits) and why normal data cannot accidentally form one. Describes special-case behavior when writing $FF: in normal mode $FF is converted to GCR, but in sync mode the 1541 writes five consecutive $FF bytes (40 '1' bits) to guarantee a detectable sync mark.",
      "references": [
        {
          "chunk": "gcr_design_constraints_no_sync_confusion_and_max_zero_runs",
          "topic": "Explains the purpose of the mapping constraints relative to sync detection"
        },
        {
          "chunk": "gcr_packing_four_bytes_into_five_gcr_bytes_example",
          "topic": "Shows how bytes are converted/packed during normal (non-sync) writing"
        }
      ]
    },
    {
      "start": 16690,
      "end": 16749,
      "name": "gcr_packing_four_bytes_into_five_gcr_bytes_example",
      "description": "Explains why four 8-bit data bytes are converted together (four 10-bit GCR values = 40 bits) and subdivided into five 8-bit GCR bytes for storage. Provides a detailed worked example converting the four data bytes $08 $10 $00 $12 through binary, nybble separation, nybble→GCR lookup, concatenation of four 10-bit GCR words, subdivision into five 8-bit bytes, and final hexadecimal results ($52 $56 $A5 $29 $72).",
      "references": [
        {
          "chunk": "gcr_lookup_table_mapping_nybbles_to_5bit_codes",
          "topic": "Used for the high/low nybble lookups in the example"
        },
        {
          "chunk": "gcr_sync_mark_and_ff_write_behavior",
          "topic": "Contrasts normal GCR conversion with sync-mode $FF writes"
        },
        {
          "chunk": "gcr_conversion_storage_considerations_and_recorded_byte_formula",
          "topic": "Explains implications for on-disk recorded byte counts"
        }
      ]
    },
    {
      "start": 16750,
      "end": 16766,
      "name": "gcr_conversion_storage_considerations_and_recorded_byte_formula",
      "description": "Notes that the DOS converts five 8-bit GCR bytes back to four 8-bit data bytes on read. Gives the formula for calculating the number of 8-bit GCR bytes recorded: (Number of 8-bit data bytes / 4) * 5, explaining how GCR expansion affects recorded size.",
      "references": [
        {
          "chunk": "gcr_packing_four_bytes_into_five_gcr_bytes_example",
          "topic": "Practical example demonstrating the 4→5 byte packing that leads to the formula"
        },
        {
          "chunk": "sector_byte_expansion_examples_and_block_byte_counts",
          "topic": "Applies the formula to header/data blocks to compute actual on-disk sizes"
        }
      ]
    },
    {
      "start": 16767,
      "end": 16788,
      "name": "sector_byte_expansion_examples_and_block_byte_counts",
      "description": "Applies GCR expansion to sector components: header block (8 data bytes → 10 GCR bytes), data block (260 data bytes → 325 GCR bytes), sync characters (five $FF bytes each), and the constant 8-byte header gap ($55) which is not GCR-converted. Shows that an entire sector is recorded as ~353 bytes (not 256) when excluding the inter-sector tail gap. Includes a small table of Data Bytes→GCR Bytes for sync/header/header gap/data.",
      "references": [
        {
          "chunk": "gcr_conversion_storage_considerations_and_recorded_byte_formula",
          "topic": "Uses the 4→5 conversion formula to compute recorded sizes"
        },
        {
          "chunk": "tail_gap_calculation_and_formatting_algorithm_with_zone_table",
          "topic": "Explains why tail gaps are handled separately and not included in the sector byte counts"
        }
      ]
    },
    {
      "start": 16789,
      "end": 16819,
      "name": "tail_gap_calculation_and_formatting_algorithm_with_zone_table",
      "description": "Describes how the Floppy Disk Controller (FDC) formats tracks by writing overlapping $FFs then a pattern of $FFs and $55s to measure usable space. The FDC subtracts the total expected bytes for the sectors in a zone from what it wrote, and divides the remainder by the number of sectors to determine the variable tail (inter-sector) gap. Explains that the tail gap varies by track, zone, and between drives (motor speed), and includes the algorithm's minimum tail gap check (formatting fails if computed tail gap < 4 bytes). Presents the zone table with typical track ranges, sectors per track, and variable tail gap ranges.",
      "references": [
        {
          "chunk": "sector_byte_expansion_examples_and_block_byte_counts",
          "topic": "Explains why the tail gap is excluded from per-sector recorded byte counts"
        },
        {
          "chunk": "tail_gap_and_header_write_behavior_notes",
          "topic": "Further notes on special-case tail gaps and header write behavior"
        }
      ]
    },
    {
      "start": 16820,
      "end": 16827,
      "name": "tail_gap_and_header_write_behavior_notes",
      "description": "Notes about tail gaps: the gap after the highest-numbered sector to sector 0 is usually much longer (can exceed 100 bytes). Also explains that header blocks are never rewritten after formatting; data blocks (including sync) are rewritten whenever the sector is written. The DOS uses the eight-byte header gap to determine where to start writing the data block.",
      "references": [
        {
          "chunk": "tail_gap_calculation_and_formatting_algorithm_with_zone_table",
          "topic": "Context on the variable tail gap and its exceptional cases"
        },
        {
          "chunk": "sector_byte_expansion_examples_and_block_byte_counts",
          "topic": "Relates header/data rewrite behavior to recorded sector composition"
        }
      ]
    },
    {
      "start": 16828,
      "end": 16832,
      "ignore": true,
      "reason": "The overlap is blank lines and a page number marker ('117') — non-technical formatting/page marker content safe to ignore."
    },
    {
      "start": 16833,
      "end": 16853,
      "name": "checksums_overview",
      "description": "Introduction to DOS checksums: single-byte checksum (hashtotal) computed by XOR (EOR) of bytes to detect read errors for header and data blocks; difference from tape redundancy. Explains the EOR operation and notes that DOS EORs bytes prior to GCR conversion.",
      "references": [
        {
          "chunk": "checksum_example",
          "topic": "worked example of header checksum calculation"
        }
      ]
    },
    {
      "start": 16854,
      "end": 16860,
      "name": "checksum_definitions_for_header_and_data_blocks",
      "description": "Specifies how DOS computes checksums: the header block checksum is the EOR of sector number, track number, ID LO, and ID HI. The data block checksum is the EOR of all 256 data bytes in the sector (typically a forward track/sector pointer plus 254 data bytes). Notes that bytes are EORed before GCR conversion.",
      "references": [
        {
          "chunk": "checksums_intro_and_eor_truth_table",
          "topic": "Fundamental EOR operation used to compute these checksums"
        },
        {
          "chunk": "header_checksum_example_step_by_step",
          "topic": "Step-by-step computation of a header checksum using these rules"
        }
      ]
    },
    {
      "start": 16861,
      "end": 16956,
      "name": "header_checksum_example_step_by_step",
      "description": "Worked example computing a header block checksum: lists the header bytes (Sector $00, Track $12, ID LO $58, ID HI $5A), their binary representations, and shows iterative EOR steps (initialize with sector number, EOR with track, then ID LO, then ID HI) to produce the final checksum $10. Notes that the example corresponds to track 18, sector 0 on an example disk and references the earlier GCR conversion example as part of the same header block.",
      "references": [
        {
          "chunk": "checksum_definitions_for_header_and_data_blocks",
          "topic": "Explains which bytes to include when computing this checksum"
        },
        {
          "chunk": "gcr_packing_four_bytes_into_five_gcr_bytes_example",
          "topic": "The example's first four bytes ($08 $10 $00 $12) were the first bytes of the same header block"
        },
        {
          "chunk": "dos_read_error_evaluation_table_intro",
          "topic": "Checksums are used by DOS when evaluating read errors"
        }
      ]
    },
    {
      "start": 16957,
      "end": 16957,
      "name": "dos_read_error_evaluation_table_intro",
      "description": "Begins section 7.3: Description of DOS error messages. Introduces the order in which errors are evaluated by the DOS during a read (and the subsequent write table): table headers for READ ERRORS including columns for FDC job request, FDC error code, IP error code, and the resulting error message. Starts listing specific seek/read entries and corresponding codes.",
      "references": [
        {
          "chunk": "header_checksum_example_step_by_step",
          "topic": "Checksums are evaluated as part of DOS read error handling"
        },
        {
          "chunk": "checksums_intro_and_eor_truth_table",
          "topic": "EOR-based checksum concept used in DOS error detection"
        }
      ]
    },
    {
      "start": 16958,
      "end": 17062,
      "name": "dos_error_tables",
      "description": "7.3 Description of DOS Error Messages. Includes the order in which the DOS evaluates errors during reads and writes and prints the READ ERRORS and WRITE ERRORS tables (FDC job, FDC error codes, IP error codes, and associated textual messages such as No Sync Character, Header Block Not Found, Checksum Error in Header Block, Disk ID Mismatch, Data Block Not Present, Write Protect On, Write-Verify Error, DOS Mismatch).",
      "references": [
        {
          "chunk": "dos_error_descriptions",
          "topic": "detailed explanations for each error code"
        }
      ]
    },
    {
      "start": 17063,
      "end": 17064,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 17065,
      "end": 17160,
      "name": "dos_error_descriptions",
      "description": "Detailed descriptions of DOS error conditions and causes: read-timeout/no sync ($03), header block not found ($02 after 90 attempts), checksum error in header ($09 returned by FDC when independent checksum doesn't match), disk ID mismatch (header IDs vs. master IDs at $0012/$0013), data block not present (first decoded byte mismatch with preset data block identifier at $0047), checksum error in data block (independent checksum mismatch). Also includes write-side errors: DOS mismatch (writing to incompatible format; DOS version at $0101 check), disk ID mismatch during write, write-protect on, write-verify error (data written did not match RAM on readback), and OK return values.",
      "references": [
        {
          "chunk": "dos_error_tables",
          "topic": "error code table mapping to messages"
        },
        {
          "chunk": "interrogate_track_tools",
          "topic": "how utilities use FDC error codes to analyze protection"
        }
      ]
    },
    {
      "start": 17161,
      "end": 17219,
      "name": "analyzing_protected_diskette_intro",
      "description": "7.4 Analyzing a Protected Diskette: overview of protection by bad sectoring (deliberately corrupted tracks/sectors). Describes that loaders often rely on specific FDC/IP error codes as \"passwords\" and common loader protections (autostart, illegal opcodes, encryption). Introduces four provided utility routines to interrogate diskettes.",
      "references": [
        {
          "chunk": "interrogate_formatting_ids",
          "topic": "one of the four utilities (returns embedded disk ID per track)"
        },
        {
          "chunk": "interrogate_a_track",
          "topic": "scans single track and verifies sectors"
        }
      ]
    },
    {
      "start": 17220,
      "end": 17244,
      "name": "interrogate_track_tools",
      "description": "Descriptions of the interrogation utilities: INTERROGATE FORMATTING ID'S (uses SEEK to read a track's header and prints ID HI/LO from zero page $0016-$0017; may hang if FDC gets 'stuck' on a track — fail-safe mechanism discussed), INTERROGATE A TRACK (scans a single track using the job queue: SEEK then READ of each sector, returns IP error codes to screen; warns about occasional erroneous results), SHAKE, RATTLE, AND ROLL (uses a UI command instead of direct READ from queue; does a SEEK first to avoid 29 errors caused by multiple formatting), INTERROGATE A DISKETTE (runs INTERROGATE A TRACK in a loop; reports only bad sectors).",
      "references": [
        {
          "chunk": "analyzing_protected_diskette_intro",
          "topic": "context and why these utilities are useful"
        }
      ]
    },
    {
      "start": 17245,
      "end": 17245,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 17246,
      "end": 17359,
      "name": "duplicating_protection_scheme_overview",
      "description": "7.5 Duplicating a Protection Scheme: rank order of errors commonly used on copy-protected diskettes (1: 21 full track, 2: 23 single sector, 3: 23 full track, 4: 20 single sector, 5: 27 full track, 6: 29 multiple formatting, 7: 22 single sector, 8: 21 partial track). Historical notes and statement that 21 full-track and 23 single-sector are predominant and easiest to duplicate. Lists 13 supplied programs to create or duplicate specific error types (DESTROY A SECTOR, FULL TRACK 21, 23A/23B/23M, 20/20M, 27M, 22A/22B, FORMAT A DISKETTE 29, BACKUP, COPY), and notes '*' means exact duplicate of a bad sector. Mentions that source listings for machine-code routines are included; BASIC drivers are simple and assumed known.",
      "references": [
        {
          "chunk": "create_21_full_track",
          "topic": "program to create a full-track 21 error"
        },
        {
          "chunk": "create_23_single_sector",
          "topic": "programs to create 23 errors"
        }
      ]
    },
    {
      "start": 17360,
      "end": 17361,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 17362,
      "end": 17478,
      "name": "create_21_full_track",
      "description": "7.6 How to Create 21 Errors on a Full Track: BASIC driver to destroy an entire track (FULL TRACK 21 ERROR). Includes user prompts (track number), validation (track in 1-35), writer setup (OPEN to drive, print commands), job queue interaction (JSUB to machine-code entry points), and limitations/parameters: none; parameter is track number. Driver writes non-sync bytes via machine-code routine to make the FDC time out (full-track 21 error).",
      "references": [
        {
          "chunk": "full_track_21_source",
          "topic": "machine-language source used by the BASIC driver"
        }
      ]
    },
    {
      "start": 17479,
      "end": 17529,
      "name": "basic_listing_and_assembler_origin",
      "description": "Header and BASIC front‑matter for the Full Track 21 error source listing plus assembler origin directive and line‑numbered entries. Covers the title, REM comments, BASIC line numbers (100–190 region), miscellaneous OCR artifacts (e.g. □, ■, @o:), a SYS40960 call, and the assembler origin directive (*=$0500) that sets the code load address.",
      "references": [
        {
          "chunk": "write_sync_and_write_sequence",
          "topic": "continues with the disk write sequence starting at the JSR $FDA3 (write sync marks) and enabling write mode"
        }
      ]
    },
    {
      "start": 17530,
      "end": 17579,
      "name": "write_sync_and_write_sequence",
      "description": "Assembly-level write sequence: calls JSR $FDA3 (write sync marks), enables disk controller write mode, loads a non-sync byte (LDA #$55) and stores it to the disk data register (STA $1C01), sets X (#$FF) and Y (#$48), then calls JSR $FDC9 (WRTNUM) to perform the block write. Includes inline comments explaining each step (e.g. 'ENABLE WRITE', 'NON SYNC BYTE', 'WRITE 18432 ...').",
      "references": [
        {
          "chunk": "basic_listing_and_assembler_origin",
          "topic": "continues from the assembler origin and BASIC wrapper that invoke the machine-code routine"
        },
        {
          "chunk": "restore_read_and_exit",
          "topic": "followed by re‑enabling read mode and exit/handler jump"
        }
      ]
    },
    {
      "start": 17580,
      "end": 17600,
      "name": "restore_read_and_exit",
      "description": "Routine tail: calls JSR $FEOO to re-enable read mode on the floppy controller, sets the FDC/status byte in the accumulator (LDA #$01), and performs a final jump to the error/exit handler at $F969 (JMP $F969). This chunk covers cleanup and transfer to the DOS error handler after the write sequence.",
      "references": [
        {
          "chunk": "write_sync_and_write_sequence",
          "topic": "precedes this cleanup: the write operation is performed before re‑enabling read mode"
        }
      ]
    },
    {
      "start": 17601,
      "end": 17601,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 17602,
      "end": 17611,
      "name": "full_track_21_annotation",
      "description": "Annotation for Full Track 21 Error source: explains intent to trace FORMT ($FAC7), why writes of sync marks and use of WRTNUM ($FDC3) create the desired error condition, and necessity to re-enable read mode via JSR $FEOO to avoid continuous erasure. Mentions final JMP to error handler $F969 with LDA #$01.",
      "references": [
        {
          "chunk": "full_track_21_source",
          "topic": "implementation details and ROM entry points used"
        }
      ]
    },
    {
      "start": 17612,
      "end": 17612,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 17613,
      "end": 17616,
      "name": "single_sector_21_error_overview",
      "description": "Title and brief metadata for the 'DESTROY A SECTOR' routine: states the purpose (how to create a sector 21 error on a single sector), limitations (preceding sector must be intact), and parameters (track and sector number).",
      "references": [
        {
          "chunk": "basic_destroy_a_sector_program",
          "topic": "Contains the BASIC driver listing that implements the described procedure (1541 driver)"
        },
        {
          "chunk": "assembly_source_single_sector_21_error",
          "topic": "Contains the machine-code/assembly routine invoked by the BASIC driver"
        }
      ]
    },
    {
      "start": 17617,
      "end": 17642,
      "name": "program_header_and_input_validation",
      "description": "Program title and initial BASIC front-end: REM and DIM, user prompts and INPUT for the track and sector to destroy, parameter validation (track/sector range checks), calculation of NS (number of sectors per track depending on track), and a confirmation (are you sure?) prompt. This chunk prepares and validates the parameters before any drive access.",
      "references": [
        {
          "chunk": "device_open_and_drive_status_check",
          "topic": "opens the drive and reads status after parameters are entered"
        },
        {
          "chunk": "seek_operation_job_submission",
          "topic": "uses validated track/sector values to perform the seek operation"
        }
      ]
    },
    {
      "start": 17643,
      "end": 17656,
      "name": "device_open_and_drive_status_check",
      "description": "Drive I/O setup and status check: OPEN 15,8,15 to the 1541, send the '10' (status) command with PRINT#15, read the drive response via INPUT#15 into EN*, EM*, ET*, ES*, test for EN* = \"00\" (OK) and handle/report errors, then CLOSE 15 and END if a fatal error occurs. This chunk ensures the drive is ready before destructive actions.",
      "references": [
        {
          "chunk": "program_header_and_input_validation",
          "topic": "uses the track/sector selected by the user"
        },
        {
          "chunk": "seek_operation_job_submission",
          "topic": "next program steps after successful device status check"
        }
      ]
    },
    {
      "start": 17657,
      "end": 17666,
      "name": "seek_operation_job_submission",
      "description": "Seek logic and job dispatch: REM SEEK section that normalizes the sector number (wraps S to NS if zero, decrements S for zero-based indexing), sets JOB to the line number handling the actual seek (JOB=176) and calls the job-queue routine via GOSUB 570. This chunk prepares a drive-side seek job for the selected track/sector.",
      "references": [
        {
          "chunk": "device_open_and_drive_status_check",
          "topic": "should be successful before initiating seek"
        },
        {
          "chunk": "job_queue_handling_subroutine",
          "topic": "submits the JOB and waits for the drive to accept/complete it"
        }
      ]
    },
    {
      "start": 17667,
      "end": 17713,
      "name": "read_buffer_write_and_execute",
      "description": "Read, assemble and transfer buffer to the drive, then execute: REM READ section sets JOB=128 and GOSUB 570 to read the sector(s), nested FOR loops collect bytes into buffer variables (D*(J) ...), then a sequence of PRINT#15 'M-W' commands streams the assembled data to the drive memory (block writes), followed by the execute sequence (M-W to write the execute vector and M-R to request execution), GET#15 to read execution response, checks on response bytes (including ASC/E checks), CLOSE 15, and final program DONE/END. This chunk performs the data upload of the destructive routine and triggers its execution on the drive.",
      "references": [
        {
          "chunk": "seek_operation_job_submission",
          "topic": "the read phase follows a successful seek"
        },
        {
          "chunk": "job_queue_handling_subroutine",
          "topic": "used to submit and poll read/write jobs to the drive"
        },
        {
          "chunk": "embedded_destroy_routine_data",
          "topic": "the machine-code bytes uploaded and executed are defined here"
        }
      ]
    },
    {
      "start": 17714,
      "end": 17748,
      "name": "job_queue_handling_subroutine",
      "description": "Job-queue communication subroutine (GOSUB 570): Implements the protocol for submitting jobs to the 1541's job queue. Initializes TRY counter, issues PRINT#15 'M-W' sequences that write the job descriptor (including track T, sector S and JOB code), increments TRY, polls the drive with PRINT#15 'M-R' and GET#15 to read status bytes, handles retries and failure cases (including close and error display), and returns when the job is accepted (E=1). This chunk encapsulates asynchronous job submission and polling logic used by SEEK/READ/WRITE steps.",
      "references": [
        {
          "chunk": "seek_operation_job_submission",
          "topic": "called to submit seek jobs"
        },
        {
          "chunk": "read_buffer_write_and_execute",
          "topic": "called to submit read and write jobs during data transfer"
        }
      ]
    },
    {
      "start": 17749,
      "end": 17759,
      "name": "embedded_destroy_routine_data",
      "description": "Embedded machine-code bytes (DATA statements) that implement the destructive routine uploaded to the 1541: REM DESTROY A SECTOR followed by a sequence of DATA statements containing the assembled 6502 opcodes/bytes. These bytes are the payload written into the drive memory and executed to overwrite a disk sector. This chunk provides the exact byte sequence used by the BASIC driver.",
      "references": [
        {
          "chunk": "read_buffer_write_and_execute",
          "topic": "these DATA bytes are read/assembled and sent to the drive for execution"
        }
      ]
    },
    {
      "start": 17760,
      "end": 17769,
      "name": "basic_loader_and_sys_entry",
      "description": "BASIC program header and loader interface: title 'SINGLE SECTOR 21 ERROR SOURCE LISTING', REM comments, OPEN2 file/device command, and SYS 40960 call that transfers control from BASIC to the assembled machine code.",
      "references": [
        {
          "chunk": "assembler_directives_and_origin",
          "topic": "assembler options and origin for the machine code invoked by SYS 40960"
        }
      ]
    },
    {
      "start": 17770,
      "end": 17778,
      "name": "assembler_directives_and_origin",
      "description": "Assembler directives and assembly origin: comment/semicolon lines surrounding the .OPT directive (.OPT P,02) and the origin directive that sets the assembly start address (* = $0500).",
      "references": [
        {
          "chunk": "basic_loader_and_sys_entry",
          "topic": "BASIC SYS entry that jumps to this origin"
        },
        {
          "chunk": "find_header_and_wait_loops",
          "topic": "initial JSRs and search routines assembled at the origin"
        }
      ]
    },
    {
      "start": 17779,
      "end": 17807,
      "name": "find_header_and_wait_loops",
      "description": "Initial low-level sequences: JSR *F510 (FIND HEADER) and JSR *F556 (FIND SYNC), followed by 'WAIT OUT DATA' code consisting of two GCR-wait loops (READ1 and READ2) implemented with LDX, BVC loops, CLV, DEX and BNE to time-wait through incoming bytes.",
      "references": [
        {
          "chunk": "assembler_directives_and_origin",
          "topic": "origin and directives used for assembling these routines"
        },
        {
          "chunk": "write_mode_data_and_write_loops",
          "topic": "subsequent code that switches data direction and emits overwrite bytes after the wait loops"
        }
      ]
    },
    {
      "start": 17808,
      "end": 17890,
      "name": "write_mode_data_and_write_loops",
      "description": "Switch to write mode and emit destructive bytes: LDA #$FF to set data direction out, the data/machine-code byte block and textual assembly listing for the destructive write, write loops labeled WRITEL and WRITE2 (CLV, STA to disk output $1C01, DEX/BNE), a JSR to *FE00, LDA #$01, and a JMP to SF969. This section contains the core machine-code bytes and loops that overwrite sync marks on the disk.",
      "references": [
        {
          "chunk": "find_header_and_wait_loops",
          "topic": "wait loops that hand off to this write sequence once sync/header located"
        },
        {
          "chunk": "mode_enable_labels_and_footer",
          "topic": "entry points and labels that mark enabling/disabling of read/write modes referred to here"
        }
      ]
    },
    {
      "start": 17891,
      "end": 17897,
      "name": "mode_enable_labels_and_footer",
      "description": "Footer labels and small entry points: the SF969 target (JMP target in the prior code region) plus textual labels 'ENABLE WRITE MODE' and 'ENABLE READ MODE' used as logical entry points or documentation markers for switching drive modes.",
      "references": [
        {
          "chunk": "write_mode_data_and_write_loops",
          "topic": "JMP SF969 and code that branches to or documents these mode-enable labels"
        }
      ]
    },
    {
      "start": 17898,
      "end": 17918,
      "name": "annotation_single_sector_21_error",
      "description": "Annotated explanation of the single-sector destructive routine: describes how the routine finds the preceding sector and syncs to its data block, waits out ~325 GCR bytes, flips to write and writes 256 non-sync bytes to overwrite both sync marks of the target sector (producing a 20 error normally). Notes a side effect: destroying two consecutive sectors causes 21 errors on both (FDC times out). Provides a recommended destruction sequence (sector 0, then 20,19,18) and a short table mapping sector ranges to observed error numbers, plus the clarification that two consecutive sectors must be destroyed to produce a 21 error in this scheme.",
      "references": [
        {
          "chunk": "basic_destroy_a_sector_program",
          "topic": "Explains how the BASIC driver prepares and executes the destructive routine"
        },
        {
          "chunk": "assembly_source_single_sector_21_error",
          "topic": "Low-level implementation details referenced by the annotation (which lines perform the waits, write flip, and overwrite)"
        }
      ]
    },
    {
      "start": 17919,
      "end": 17919,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 17920,
      "end": 17926,
      "name": "how_to_create_23_error_overview",
      "description": "Section header and brief metadata for the routine: title 'How to Create a 23 Error on a Single Sector', listed limitations (none), and required parameters (track and sector number).",
      "references": [
        {
          "chunk": "single_sector_23_error_basic_program",
          "topic": "BASIC driver and user interaction that invokes the sector-destruction routine"
        },
        {
          "chunk": "single_sector_23_error_source_listing",
          "topic": "Assembly routine that performs the destructive write to create the 23 error"
        }
      ]
    },
    {
      "start": 17927,
      "end": 18028,
      "name": "single_sector_23_error_basic_program",
      "description": "BASIC program front-end and main driver (lines and statements shown as in-source): program title, user prompts to enter track and sector, validation of parameters, OPEN/PRINT/INPUT to the drive, initial SEEK/READ sequences and the high-level control flow up through the main EXECUTE sequence and program END. Includes the program line numbers 100-530 and surrounding brief page markers/whitespace.",
      "references": [
        {
          "chunk": "how_to_create_23_error_overview",
          "topic": "overview and parameters for running the BASIC driver"
        },
        {
          "chunk": "single_sector_23_error_job_queue",
          "topic": "calls a job-queue subroutine (GOSUB 550) used by SEEK/READ operations"
        },
        {
          "chunk": "single_sector_23_error_machine_code_data",
          "topic": "contains DATA statements later in the listing that hold the machine code used by the routine"
        }
      ]
    },
    {
      "start": 18029,
      "end": 18059,
      "name": "single_sector_23_error_job_queue",
      "description": "BASIC subroutine labelled 'JOB QUEUE' (lines beginning at 540): implements drive job submission and polling (PRINT#15 'M-W' / 'M-R' commands), retry logic, GET#15 reading of response bytes, simple error handling and eventual CLOSE/END paths. This routine is the I/O job queue helper invoked by the main BASIC driver.",
      "references": [
        {
          "chunk": "single_sector_23_error_basic_program",
          "topic": "invoked via GOSUB 550 from the main BASIC driver for SEEK/READ operations"
        },
        {
          "chunk": "single_sector_23_error_machine_code_data",
          "topic": "used to transfer the embedded machine code via drive I/O"
        }
      ]
    },
    {
      "start": 18060,
      "end": 18075,
      "name": "single_sector_23_error_machine_code_data",
      "description": "BASIC DATA block labeled 'REM 23 ERROR' containing the embedded 6502 machine-code bytes (multiple DATA statements). These bytes represent the destructive machine-language routine that will be loaded and executed by the BASIC driver to create the single-sector 23 error.",
      "references": [
        {
          "chunk": "single_sector_23_error_basic_program",
          "topic": "BASIC program stores and loads these DATA bytes into a drive buffer for execution"
        },
        {
          "chunk": "single_sector_23_error_source_listing",
          "topic": "assembly source corresponding to the machine-code DATA bytes"
        }
      ]
    },
    {
      "start": 18076,
      "end": 18086,
      "name": "source_listing_header_and_basic_boot",
      "description": "Title and BASIC wrapper for the assembly listing titled 'SINGLE SECTOR 23 ERROR SOURCE LISTING'. Contains the human-readable title, REM lines, the OPEN2 file open string '@0: 23A- B, P, W' and a SYS40960 call to begin execution. This is the non-assembly header that precedes the machine code source.",
      "references": [
        {
          "chunk": "initialization_and_gcr_conversion",
          "topic": "assembly origin and initialization (follows the BASIC bootstrap)"
        }
      ]
    },
    {
      "start": 18087,
      "end": 18126,
      "name": "initialization_and_gcr_conversion",
      "description": "Assembler directives, origin, and initial CPU/register setup. Contains .OPT directive and sets code origin (* = $0500). Initializes drive-related pointer/flag (LDA #*04; STA *31), loads and increments a pointer at *3A (LDA *3A / TAX / INX / TXA / STA *3A) performing a checksum increment, and calls the GCR conversion routines (JSR *F78F and JSR *F510) that prepare data for drive transfer.",
      "references": [
        {
          "chunk": "source_listing_header_and_basic_boot",
          "topic": "BASIC bootstrap that jumps here"
        },
        {
          "chunk": "find_header_and_wait_gap",
          "topic": "next: waits for header/gap after GCR conversion"
        }
      ]
    },
    {
      "start": 18127,
      "end": 18158,
      "name": "find_header_and_wait_gap",
      "description": "Logic to find the drive header/gap and synchronize transfer timing. Loads X with #*08 then loops (WAITGAP) using BVC/CLV/DEX/BNE to time/skip header gap bytes. This sequence clears the overflow status flags as part of finding the correct write window before enabling writes.",
      "references": [
        {
          "chunk": "initialization_and_gcr_conversion",
          "topic": "follows GCR conversion and checksum increment"
        },
        {
          "chunk": "drive_register_setup_and_write_sync",
          "topic": "next: sets drive registers and issues write-sync once header is aligned"
        }
      ]
    },
    {
      "start": 18159,
      "end": 18174,
      "name": "drive_register_setup_and_write_sync",
      "description": "Sets drive/IEC hardware registers and runs the write-sync loop. Loads and stores values to drive registers (*1C03, *1C0C, *1C01), manipulates bits with AND/ORA to set required drive control lines, and executes a WRITESYNC loop (BVC/CLV/DEX/BNE) to synchronize with the drive's write window. After sync is achieved it loads Y with the overflow-area start (LDY «*BB) to prepare for writing the first chunk of GCR data from the overflow buffer.",
      "references": [
        {
          "chunk": "find_header_and_wait_gap",
          "topic": "synchronization follows header/gap detection"
        },
        {
          "chunk": "write_overflow_and_buffer_write_loops",
          "topic": "next: writes overflow-area GCR bytes then the main buffer"
        }
      ]
    },
    {
      "start": 18175,
      "end": 18203,
      "name": "write_overflow_and_buffer_write_loops",
      "description": "The destructive write sequence that writes the sector's GCR bytes to the drive. First writes the overflow-area bytes starting at $0100,Y (label OVERFLOW) with a WAITl loop that polls the drive status (BVC/CLV/STA *1C01/INY/BNE). After the overflow area is exhausted it writes the main 256-byte buffer at $0400,Y (label BUFFER) using WAIT2 and a final WAIT3 synchronization loop. After all bytes are clocked out it calls a drive-routine (JSR *FEOO). This chunk includes the 'ENABLE WRI' heading and the two loops implementing the actual byte-by-byte output to the drive.",
      "references": [
        {
          "chunk": "drive_register_setup_and_write_sync",
          "topic": "uses the registers and sync established there to perform writes"
        },
        {
          "chunk": "finalize_registers_and_jump_to_error_handler",
          "topic": "finalizes registers and then jumps to an error handler"
        }
      ]
    },
    {
      "start": 18204,
      "end": 18211,
      "name": "finalize_registers_and_jump_to_error_handler",
      "description": "Final register updates and termination of the destructive write routine. Loads immediate values into drive control bytes (LDA #*05; STA *31; LDA #*01) then performs a JMP to the error handler at *F969. This finishes the sequence after the write and branches to the routine that handles the 'single sector 23 error' flow.",
      "references": [
        {
          "chunk": "write_overflow_and_buffer_write_loops",
          "topic": "follows the buffer write and drive routine call"
        }
      ]
    },
    {
      "start": 18212,
      "end": 18227,
      "name": "single_sector_23_error_annotation",
      "description": "Annotated explanation of the 'Single Sector 23 Error' routine: notes that the routine borrows from WRIGHT ($F56E) and that the entry point used bypasses the write-protect test and checksum computation. Describes that the driver reads the sector into $0400-$04FF, sets the indirect buffer pointer, increments the checksum at $003A, converts buffer 1 into 325 GCR bytes (first 69 stored in overflow $01BB-$01FF, remaining 256 at $0400-$04FF), syncs to the target sector, counts off the 8-byte header gap, flips to write mode, writes five $FF sync bytes then overflow+regular buffers (overwriting sync marks), restores indirect pointer to $05, and jumps to the error handler with $01 in hand. Also mentions side effects and relation to single-sector 20 vs two-sector 21 behavior and required order to replicate certain protections.",
      "references": [
        {
          "chunk": "single_sector_23_error_source_listing",
          "topic": "detailed mapping between annotated behavior and specific assembly operations"
        },
        {
          "chunk": "single_sector_23_error_machine_code_data",
          "topic": "binary encoding of the assembly routine that performs the described operations"
        },
        {
          "chunk": "single_sector_23_error_basic_program",
          "topic": "BASIC driver that loads and executes the routine and supplies track/sector parameters"
        }
      ]
    },
    {
      "start": 18228,
      "end": 18281,
      "name": "duplicate_23_error_intro_and_input_handling",
      "description": "Section header and the beginning of the BASIC duplicate utility. Covers: section title (How to Duplicate a 23 Error on a Single Sector), limitations and parameters, BASIC program header and variable DIM, user prompts to insert the master disk, INPUT of track and sector (t,s), initial validation of t/s ranges, confirmation prompt, and the initial disk I/O handshake (OPEN 15, PRINT#15 \"10\", INPUT#15 to read EN/EM/ET/ES and branch on EN). Includes early error-printing, CLOSE and early END path.",
      "references": [
        {
          "chunk": "duplicate_23_error_master_read_and_clone_write_sequence",
          "topic": "core seek/read and clone write flow called after initial checks"
        },
        {
          "chunk": "duplicate_23_error_machine_language_data_payload",
          "topic": "machine-language payload invoked/used by the BASIC execute steps"
        }
      ]
    },
    {
      "start": 18282,
      "end": 18358,
      "name": "duplicate_23_error_master_read_and_clone_write_sequence",
      "description": "Core duplication sequence in BASIC. Covers: REM SEEK and REM READ steps (setting JOB, GOSUB 650 to perform drive operations), reading the requested sector(s) from the master disk, CLOSE 15, prompting and waiting for the user to insert the clone disk, reopening the drive for writing (OPEN 15,3,15), seeking again, nested loops that read bytes into the program buffer (FOR J=0 TO 10, FOR I=0 TO 7, READD, assembling D* buffer), preparing and issuing M-W (memory-write) commands to the drive to write the assembled GCR/sector image blocks, incrementing the buffer pointer, issuing M-R and checking drive response (GET#15,E*; defaulting empty response to CHR$(0); converting to ASC and checking ranges), closing the device, and printing the DONE message and END of the operation. This is the main master->clone data transfer path that writes the duplicated sector image to the clone.",
      "references": [
        {
          "chunk": "duplicate_23_error_intro_and_input_handling",
          "topic": "user input and initial disk handshake that precedes this read/write sequence"
        },
        {
          "chunk": "duplicate_23_error_job_queue_polling_and_retries",
          "topic": "job submission and polling logic used when executing drive memory commands (M-W/M-R)"
        },
        {
          "chunk": "duplicate_23_error_machine_language_data_payload",
          "topic": "machine-code DATA block executed/installed by the BASIC M-W/M-R sequence"
        }
      ]
    },
    {
      "start": 18359,
      "end": 18389,
      "name": "duplicate_23_error_job_queue_polling_and_retries",
      "description": "Job-queue and drive-polling helper used by the duplicate routine. Covers: REM JOB QUEUE routine that constructs and sends job packets to the 1541 (M-W with job parameters), TRY counter and retry loop, issuing M-R to read job result, handling empty responses, converting response to numeric (ASC), retry limit and failure handling (jump to failure message), conditional return on success, and cleanup (CLOSE 15 and END on fatal failure). This routine is used to submit low-level commands and poll the drive for completion/error status.",
      "references": [
        {
          "chunk": "duplicate_23_error_master_read_and_clone_write_sequence",
          "topic": "called or relied on by the main read/write sequence to manage drive jobs and check completion"
        },
        {
          "chunk": "duplicate_23_error_machine_language_data_payload",
          "topic": "the job submissions target the machine-code routine/data that performs sector-level operations"
        }
      ]
    },
    {
      "start": 18390,
      "end": 18403,
      "name": "duplicate_23_error_machine_language_data_payload",
      "description": "Machine-language payload for the duplicate routine. Contains: REM DUPLICATE A SECTOR marker and a sequence of DATA statements (the ML bytes: DATA 169,4,133,49,... through the final DATA line). These bytes represent the 6502 machine-code routine (loader/sector-manipulation code) that the BASIC program writes into the 1541 and/or memory and executes to perform the low-level sector duplication and checksum preservation. Also includes the final source-listing header line: 'DUPLICATE A SINGLE SECTOR 23 ERROR SOURCE LISTING'.",
      "references": [
        {
          "chunk": "duplicate_23_error_master_read_and_clone_write_sequence",
          "topic": "BASIC code that writes these DATA bytes to the drive (M-W) and executes them"
        },
        {
          "chunk": "duplicate_23_error_job_queue_polling_and_retries",
          "topic": "job-queue commands used to install/execute this machine-language payload and poll results"
        }
      ]
    },
    {
      "start": 18404,
      "end": 18522,
      "name": "single_sector_23b_assembly_source",
      "description": "Assembly source for 23B.PAL (Single-Sector 23 error, duplicate variant). Contains the machine-code driver entry used to convert data to GCR (JSR *F73F), locate the header (JSR *F510), wait out the header gap, enable WRITE mode (writes to *1C03 and *1C0C), write sync marks, and stream GCR bytes from the overflow buffer and sector buffer to the drive via *1C01. Ends by re-enabling READ mode (JSR *FE00) and returning to DOS with appropriate zero-page values set (STA *31 etc.). Includes the SYS/BASIC invocation lines and assembler directives used when saving the file to disk.",
      "references": [
        {
          "chunk": "duplicate_single_sector_23_annotation",
          "topic": "Notes about the 23B variant leaving checksum intact"
        },
        {
          "chunk": "full_track_23m_assembly_source",
          "topic": "Related full-track assembly driver that uses similar WRITE/READ sequencing"
        }
      ]
    },
    {
      "start": 18523,
      "end": 18529,
      "name": "duplicate_single_sector_23_annotation",
      "description": "Human-readable annotation for the DUPLICATE Single Sector 23 error variant (23B). Explains that this variant is identical to 23A.PAL except the checksum is left intact after reading a corrupted data block from the master. States where the sector and checksum are stored on the zero page/sector buffer: sector at $0400-$04FF, checksum at $003A. Explains that the checksum is not recalculated or incremented; the entire sector and its checksum are rewritten to the clone.",
      "references": [
        {
          "chunk": "single_sector_23b_assembly_source",
          "topic": "Assembly implementation for the variant that leaves checksum intact"
        }
      ]
    },
    {
      "start": 18530,
      "end": 18626,
      "name": "full_track_23_error_basic_main",
      "description": "Documentation and the main BASIC driver (user-facing code) for creating multiple '23' errors across a full track on a 1541. Includes the section header ('How to Create 23 Errors on a Full Track'), limitations and parameters, prompts and confirmations for the user, opening the drive channel, validating responses, seeking and looping logic for processing sectors on a track, and the top-level flow that triggers the destructive WRITE sequence. This chunk covers the BASIC program lines from program start through the main END that completes the high-level driver.",
      "references": [
        {
          "chunk": "full_track_23_error_basic_job_queue_and_data",
          "topic": "JOB QUEUE subroutine and embedded machine-code DATA used by this BASIC driver"
        },
        {
          "chunk": "full_track_23m_assembly_source",
          "topic": "Assembly-level driver that the DATA block encodes and that is ultimately executed"
        }
      ]
    },
    {
      "start": 18627,
      "end": 18656,
      "name": "job_queue_basic_handshake_and_retry",
      "description": "BASIC 'JOB QUEUE' subroutine that implements drive communication and retry logic. Covers the REM header, initialization of TRY, PRINT#15 commands to send M-W and M-R messages (including the job identifier bytes), GET#15 response reading, conversion of the returned character to numeric E, retry/time‑out branching (go-to lines), closing channel 15, and the failure message and END. This chunk contains the full BASIC-level handshake and retry/response handling used to send commands to the drive.",
      "references": [
        {
          "chunk": "track23_error_data_bytes",
          "topic": "6502 machine-code DATA statements that this BASIC job-queue sends/loads into the drive"
        },
        {
          "chunk": "track23_error_source_listing_assembly",
          "topic": "Assembly source (full-track 23 routine) corresponding to the DATA bytes"
        }
      ]
    },
    {
      "start": 18657,
      "end": 18676,
      "name": "track23_error_data_bytes",
      "description": "DATA statements (BASIC DATA) encoding the 6502 machine-code bytes for the 'Full Track 23' destructive error routine. Begins with REM 23 ERROR and contains sequential DATA lines listing opcode and operand byte values (e.g. 169,4,133,49,... up through the final DATA sequence). These bytes are the exact values to POKE or READ into memory to form the machine-code routine that the job-queue sends to the drive.",
      "references": [
        {
          "chunk": "job_queue_basic_handshake_and_retry",
          "topic": "BASIC job-queue routine that transmits and invokes these DATA bytes on the drive"
        },
        {
          "chunk": "track23_error_source_listing_assembly",
          "topic": "Readable assembly source that matches/annotates these DATA bytes"
        }
      ]
    },
    {
      "start": 18677,
      "end": 18777,
      "name": "track23_error_source_listing_assembly",
      "description": "Full Track 23 Error assembly source listing (23M.PAL). Contains the human-readable assembly version of the destructive routine: REM headers, OPEN/SYS line references from the BASIC invocation, assembler directives (.OPT, origin *= *0500), and sequential 6502 assembly instructions and labels (LDA, STA, JSR, LDX, BVC, CLV, DEX, TXA, etc.). This listing provides the commented, symbolic representation of the machine-code DATA block and the drive-side routine logic and flow.",
      "references": [
        {
          "chunk": "track23_error_data_bytes",
          "topic": "Exact machine-code bytes (DATA statements) that correspond to this assembly source"
        },
        {
          "chunk": "job_queue_basic_handshake_and_retry",
          "topic": "BASIC-side code that uploads/invokes the assembly routine on the drive"
        }
      ]
    },
    {
      "start": 18778,
      "end": 18872,
      "name": "full_track_23m_assembly_source",
      "description": "Assembly source for 23M.PAL (Full-Track 23 error). This listing is the assembly equivalent of the machine-code DATA block used by the BASIC driver. It includes initial setup (LDA #$04, STA *31), optional checksum increment (LDA *3A / TAX / INX / TXA / STA *3A), GCR conversion (JSR *F7AF), header location (JSR *F510), waiting out the header gap, enabling WRITE mode (writes to *1C03 and *1C0C), WRITESYNC looping, streaming bytes from the overflow buffer ($0100,Y) and sector buffer ($0400,Y) to *1C01 while checking for the V flag (BVC/CLV loops), re-enabling READ (JSR *FE00), and final DOS return (JMP *F975). Also shows use of LDY #$BB for overflow buffer indexing.",
      "references": [
        {
          "chunk": "full_track_23_error_basic_job_queue_and_data",
          "topic": "The DATA bytes in the BASIC listing correspond to this readable assembly"
        },
        {
          "chunk": "duplicate_single_sector_23_annotation",
          "topic": "Related note on checksum behavior for the single-sector duplicate variant"
        }
      ]
    },
    {
      "start": 18873,
      "end": 18881,
      "name": "full_track_23_error_annotation",
      "description": "Short annotation for the Full Track 23 error. Directs the reader to the annotation for 23A.PAL for more detailed notes and states that the BASIC driver loops to process all sectors on a given track. This final chunk contains the annotation and trailing whitespace.",
      "references": [
        {
          "chunk": "full_track_23m_assembly_source",
          "topic": "Assembly driver used when processing all sectors on the track"
        },
        {
          "chunk": "full_track_23_error_basic_main",
          "topic": "BASIC driver that loops over all sectors on the track"
        }
      ]
    },
    {
      "start": 18882,
      "end": 18891,
      "name": "overview_and_parameters_single_sector_20_error",
      "description": "Title and brief overview for creating a single-sector DOS error (20). Includes limitations (preceding sector must be intact), a cross-reference to the single-sector 21 error annotation, and the parameters expected (track and sector). Also contains the section heading 'SINGLE SECTOR 20 ERROR'.",
      "references": [
        {
          "chunk": "basic_driver_listing_single_sector_20_error",
          "topic": "BASIC driver implementation for creating the 20 error"
        },
        {
          "chunk": "asm_source_listing_single_sector_20_error",
          "topic": "Machine-code source listing that performs the rewrite"
        },
        {
          "chunk": "source_annotation_single_sector_20_error",
          "topic": "Explanatory annotation describing limitations and method"
        }
      ]
    },
    {
      "start": 18892,
      "end": 19038,
      "name": "basic_driver_listing_single_sector_20_error",
      "description": "Complete BASIC driver listing to create a single-sector 20 error on a 1541. Contains program lines for user prompts, validation of track/sector input, drive I/O (OPEN/PRINT#/GET#/CLOSE), seek/read/write routines, job-queue handling, logic to compose and send write commands, data statements (machine-code bytes) used by the program, and termination messages. The DATA statements (lines 720-830) containing the machine-code bytes are included as part of the BASIC listing.",
      "references": [
        {
          "chunk": "overview_and_parameters_single_sector_20_error",
          "topic": "Title, limitations and parameters for the BASIC driver"
        },
        {
          "chunk": "asm_source_listing_single_sector_20_error",
          "topic": "Corresponding assembly source used by the BASIC program (DATA bytes and routines)"
        },
        {
          "chunk": "source_annotation_single_sector_20_error",
          "topic": "Annotation explaining how the BASIC driver and machine routine achieve the 20 error"
        }
      ],
      "no_refine": true
    },
    {
      "start": 19039,
      "end": 19325,
      "name": "asm_source_listing_single_sector_20_error",
      "description": "Assembly source listing for the single-sector 20-error routine. Includes directives (.OPT, *=), JSR calls to DOS/FDC entry points, register setups (LDY, LDA, CMP, DEY), zone/sector calculations, header creation and staging in RAM ($0024-$002C), subroutine calls to DOS routines (JSR *F934, JSR *F556, JSR *FEOO), write mode loop that writes the prepared header image to the disk, and final jumps back to DOS. This block represents the machine-code source that the BASIC program's DATA statements encode.",
      "references": [
        {
          "chunk": "basic_driver_listing_single_sector_20_error",
          "topic": "BASIC program that contains the DATA bytes corresponding to this assembly source"
        },
        {
          "chunk": "source_annotation_single_sector_20_error",
          "topic": "Annotation that explains behavior and timing limitations of this assembly routine"
        },
        {
          "chunk": "overview_and_parameters_single_sector_20_error",
          "topic": "High-level description and parameters relevant to the assembly routine"
        }
      ],
      "no_refine": true
    },
    {
      "start": 19326,
      "end": 19342,
      "name": "source_annotation_single_sector_20_error",
      "description": "Annotated explanation of the single-sector 20-error source. Describes the routine's dependence on an intact preceding sector, synchronization steps to the prior header/data block (lines 200-210), calculation of the next sector in the zone (lines 230-400), creation of a header image in RAM ($0024-$002C), an extra sync to position at the header to be destroyed, and flipping to write mode to intentionally write too slowly and corrupt the header identifier. Notes the difficulty in gauging the tail gap length and why the approach is still sufficient.",
      "references": [
        {
          "chunk": "basic_driver_listing_single_sector_20_error",
          "topic": "BASIC driver that uses the machine routine described here"
        },
        {
          "chunk": "asm_source_listing_single_sector_20_error",
          "topic": "Assembly implementation whose timing and actions are explained in this annotation"
        },
        {
          "chunk": "overview_and_parameters_single_sector_20_error",
          "topic": "Context and limitations noted in the overview"
        }
      ]
    },
    {
      "start": 19343,
      "end": 19343,
      "name": "next_section_heading_ignored",
      "description": "IGNORED: Section heading '7.12 How to Create 20 Errors on a Full Track' — non-technical section header signaling the next chapter.",
      "references": [
        {
          "chunk": "source_annotation_single_sector_20_error",
          "topic": "Follows the annotation for the single-sector 20-error routine"
        }
      ],
      "ignore": true,
      "reason": "IGNORED: Section heading '7.12 How to Create 20 Errors on a Full Track' — non-technical section header signaling the next chapter."
    },
    {
      "start": 19344,
      "end": 19440,
      "name": "basic_driver_user_interface_and_execution_flow",
      "description": "BASIC driver program for generating full-track 20 errors on a 1541. Includes program header and limits, user prompts and input validation (insert clone, select track, confirm), drive open/close and status printout, envelope of the SEEK/READ/WRITE flow (NS calculation, S and JOB setup, calls to subroutines such as GDSUB5a0 and G0SUB580), building the write buffer (M-W writes), main execute sequence, looping over sectors, and final CLOSE/Done/END of the BASIC program.",
      "references": [
        {
          "chunk": "job_queue_and_communication_subroutines",
          "topic": "Job-queue and low-level drive communication routines called by the BASIC program"
        },
        {
          "chunk": "embedded_machine_language_data_blocks_21_and_20m",
          "topic": "Embedded DATA blocks (machine-code) written by this BASIC driver"
        }
      ]
    },
    {
      "start": 19441,
      "end": 19476,
      "name": "job_queue_and_communication_subroutines",
      "description": "JOB QUEUE and I/O helper routines used by the BASIC driver. Contains the 'JOB QUEUE' REM, TRY/retry loop, printing and sending M-W/M-R commands to the drive, GET#/INPUT# handling, ASCII conversion and bounds checking, retry limits and branch-on-failure behaviour, CLOSE and failure message. This block implements the low-level communication and error/retry handling between BASIC and the 1541 drive.",
      "references": [
        {
          "chunk": "basic_driver_user_interface_and_execution_flow",
          "topic": "Called from the BASIC driver to perform reads/writes and handle drive responses"
        },
        {
          "chunk": "embedded_machine_language_data_blocks_21_and_20m",
          "topic": "Sends/loads the embedded machine-code data to the drive via M-W"
        }
      ]
    },
    {
      "start": 19477,
      "end": 19514,
      "name": "embedded_machine_language_data_blocks_21_and_20m",
      "description": "Raw DATA statements containing two machine-language routines embedded in the BASIC program: a 21-error routine (DATA block labeled '21 ERROR') and the 20M full-track error routine (DATA block labeled '20M ERROR'). Lists the byte sequences as BASIC DATA statements used to POKE or write the machine-code into buffers (the bytes include the disk I/O and header-manipulation routines).",
      "references": [
        {
          "chunk": "basic_driver_user_interface_and_execution_flow",
          "topic": "These DATA blocks are written to the drive/buffer by the BASIC program to create the error-producing code"
        },
        {
          "chunk": "assembly_source_listing_initialization_and_header_creation",
          "topic": "Assembly source listing of the routines represented by these DATA byte sequences"
        }
      ]
    },
    {
      "start": 19515,
      "end": 19563,
      "name": "file_header_and_assembler_directives",
      "description": "Document title and top-of-file assembler directives and metadata. Contains the listing title 'FULL TRACK 20 ERROR SOURCE LISTING', REM comments, the source filename '20M.PAL', an OPEN command string (broken across lines), SYS40960 directive, assembler option line (-OPT P,02), and the origin directive setting the assembly origin to *=$0400 plus surrounding small comments/markers.",
      "references": [
        {
          "chunk": "initial_register_and_buffer_initialization",
          "topic": "continues with the initialization sequence (zeroing memory locations and pointer setup)"
        }
      ]
    },
    {
      "start": 19564,
      "end": 19656,
      "name": "initial_register_and_buffer_initialization",
      "description": "Initialization sequence that sets up runtime pointers and buffers. Includes the 'INITIALIZATION' comment, LDA #*00 / STA *7F to clear a location, LDX *0C and storing X to *51 and *80, LDX *0D / INX / STX *43, LDA #*01 / STA *0620 (sector counter initial value), LDA #*08 / STA *0626 (tail gap parameter), and LDA #*00 / STA *0628 (checksum/related byte).",
      "references": [
        {
          "chunk": "file_header_and_assembler_directives",
          "topic": "follows file header and assembler directives"
        },
        {
          "chunk": "sector_counter_jsr_and_led_on_create_headers_label",
          "topic": "next steps include calling a routine (JSR) and toggling the LED, then creating headers"
        }
      ]
    },
    {
      "start": 19657,
      "end": 19687,
      "name": "sector_counter_jsr_and_led_on_create_headers_label",
      "description": "Calls and markers that follow initialization. Contains the 'SECTOR COUNTER' comment, a JSR to *C100 (likely a sector-related routine), the 'LED ON' comment/marker, and the 'CREATE HEADERS' label (setup marker) that begins the header creation section.",
      "references": [
        {
          "chunk": "initial_register_and_buffer_initialization",
          "topic": "is invoked after buffer and parameter initialization"
        },
        {
          "chunk": "header_creation_loop_storing_header_image",
          "topic": "the CREATE HEADERS label leads into the header-creation loop that writes header bytes into $0300"
        }
      ]
    },
    {
      "start": 19688,
      "end": 19800,
      "name": "header_creation_loop_storing_header_image",
      "description": "Assembly code that builds in-memory sector ID/header images at $0300 (indexed by X). Starts with LDX #*00, then a loop labeled HEADER that loads header bytes and stores them to *0300,X: LDA #*09 (HBID) stored to $0300,X, increments of X, loading/storing the checksum byte from *0628, loading the sector number from *51 into $0300,X, loading/storing a zero track byte (#*00) to $0300,X, storing ID low and then ID high (with a subsequent LDA #*0F). The listing ends within/after this header-creation sequence (trailing lines contain the final immediate value and listing terminators).",
      "references": [
        {
          "chunk": "sector_counter_jsr_and_led_on_create_headers_label",
          "topic": "the CREATE HEADERS label at the end of that chunk begins this loop"
        }
      ]
    },
    {
      "start": 19801,
      "end": 19828,
      "name": "write_gap_and_header_table",
      "description": "Writes gap/header table bytes into the buffer at offsets around $0300. Includes STA/INX sequences, references to the '*0300,X' buffer area (gap region), and preparation of a zero value (LDA #*00) before checksum computation. This section is the tail-gap/header area setup used prior to checksum calculation.",
      "references": [
        {
          "chunk": "compute_header_checksum_and_verify",
          "topic": "checksum computation that follows the header writes"
        },
        {
          "chunk": "create_data_block_1541_format",
          "topic": "data block creation that follows the header/sector setup"
        }
      ]
    },
    {
      "start": 19829,
      "end": 19847,
      "name": "compute_header_checksum_and_verify",
      "description": "Computes the header checksum by XOR'ing multiple bytes (EOR *02FA,X; EOR *02FB,X; EOR *02FC,X; EOR *02FD,X) and storing the result (STA *02F9,X). Increments and checks the header index/counter at *0628 and compares it with the stored header index at *43; loops to HEADER if not equal. Preserves A/X (TXA/PHA) for later use.",
      "references": [
        {
          "chunk": "write_gap_and_header_table",
          "topic": "header bytes that are inputs to this checksum"
        },
        {
          "chunk": "create_data_block_1541_format",
          "topic": "data block creation that uses the validated header"
        }
      ]
    },
    {
      "start": 19848,
      "end": 19866,
      "name": "create_data_block_1541_format",
      "description": "Creates the data block for a 1541 formatted disk sector. Loads the data identifier (LDA #*4B) and writes it into the data area (STA *0500). Uses X indexing (LDX/INX/BNE loop) to fill the buffer at *0500,X with the appropriate data pattern for the format.",
      "references": [
        {
          "chunk": "compute_header_checksum_and_verify",
          "topic": "uses the header validation result before creating the data block"
        },
        {
          "chunk": "convert_data_to_gcr_with_rom_routines",
          "topic": "data block is converted to GCR encoding in the next stage"
        }
      ]
    },
    {
      "start": 19867,
      "end": 19885,
      "name": "convert_data_to_gcr_with_rom_routines",
      "description": "Converts the assembled data block into GCR (Group Code Recording) encoding by calling ROM routines. Initializes pointers/zero page ($30/$31), calls JSR *FE30, restores registers (PLA/TAY/DEY) and calls additional ROM routines (*FDE5, *FDF5, *F5E9, *F78F). Stores conversion results into zero-page locations like *3A.",
      "references": [
        {
          "chunk": "create_data_block_1541_format",
          "topic": "provides the data that is converted to GCR"
        },
        {
          "chunk": "build_jump_loader_code_in_buffer",
          "topic": "after GCR conversion, a jump/loader sequence is assembled"
        }
      ]
    },
    {
      "start": 19886,
      "end": 19990,
      "name": "build_jump_loader_code_in_buffer",
      "description": "Assembles a small jump/loader sequence by writing opcode bytes into zero page and the $0600 buffer. Stores values such as LDA immediate (#*23) into *51, then writes a sequence of opcodes/operands (A9, 05, 85, 31, LDA #*31, STA $0603, LDA #*4C, STA $0604, LDA #*AA, STA $0605, LDA #*FC, STA *0606, LDA #*E0, STA *03) to build the runtime jump code and parameters used to transfer control to the routine or ROM entry point.",
      "references": [
        {
          "chunk": "convert_data_to_gcr_with_rom_routines",
          "topic": "conversion completed before building the jump/loader"
        },
        {
          "chunk": "wait_loop_and_jump_to_rom",
          "topic": "final synchronization and jump to ROM after loader is in place"
        }
      ]
    },
    {
      "start": 19991,
      "end": 20029,
      "name": "wait_loop_and_jump_to_rom",
      "description": "Synchronization loop and final transfer of control. Implements a WAIT loop that polls a flag at *03 (LDA *03; BMI WAIT) to delay until ready. After the wait condition clears, execution jumps to the ROM address via JMP *C194 (final transfer to ROM-based routine).",
      "references": [
        {
          "chunk": "build_jump_loader_code_in_buffer",
          "topic": "uses the loader/jump bytes prepared in the buffer"
        },
        {
          "chunk": "compute_header_checksum_and_verify",
          "topic": "overall sequence depends on a valid header/checksum before final jump"
        }
      ]
    },
    {
      "start": 20030,
      "end": 20069,
      "name": "full_track_20_error_source_annotation",
      "description": "Annotated explanation of the Full Track formatting routine (20M): explains initialization (drive number to $007F), reading track/sector from header table ($000C -> $0051, $000D -> $0043), try counter for retries, tail gap length choice, LED cosmetic behavior, creation of header and dummy data block, binary-to-GCR conversion, jump trick to let FDC/ROM complete formatting, and the IP/FDC mode handoff behavior. Mentions ENDCMD ($C194) termination.",
      "references": [
        {
          "chunk": "formatting_initialization_and_header_building",
          "topic": "where the code sets up header and counters"
        },
        {
          "chunk": "jump_instruction_and_ip_fdc_handshake",
          "topic": "why the track number is reset to 35 and how control is passed to ROM"
        }
      ]
    },
    {
      "start": 20070,
      "end": 20169,
      "name": "basic_create_27_errors_full_track",
      "description": "BASIC program to create multiple (27) errors on a full track on the 1541: program structure, user prompts and safety checks (track range), SEEK/READ/WRITE job control via job queue, channel I/O (OPEN/PRINT#15/INPUT#15), buffer building (CHR$ concatenation), and final status messages. Uses job codes and M-R/M-W commands to instruct drive; includes loops to create many malformed sectors.",
      "references": [
        {
          "chunk": "job_queue_and_mrw_protocol",
          "topic": "how the BASIC job queue uses M-R and M-W sequences to communicate with the drive"
        },
        {
          "chunk": "full_track_20_error_source_annotation",
          "topic": "similar strategy used in machine-language formatting routine"
        }
      ]
    },
    {
      "start": 20170,
      "end": 20267,
      "name": "job_queue_and_data_for_27_error",
      "description": "Support routines and data used by the 'create 27 errors' BASIC program: job queue setup (TRY loop, PRINT#15 M-W/M-R sequences), error handling (GET#15/GET/ASCII checks), and embedded DATA records (data bytes forming the injected machine code/data blocks). Shows how BASIC issues disk commands and polls results.",
      "references": [
        {
          "chunk": "basic_create_27_errors_full_track",
          "topic": "main BASIC driver that uses these job-queue patterns"
        },
        {
          "chunk": "m_w_m_r_machine_protocol",
          "topic": "low-level M-W / M-R command formats used on channel 15"
        }
      ]
    },
    {
      "start": 20268,
      "end": 20273,
      "name": "data_blob_machine_code",
      "description": "Two DATA statement lines containing raw machine-code / binary byte literals used by the Full Track 27 routines (assembly byte lists). Includes the blank lines immediately following the DATA statements as part of the blob listing.",
      "references": [
        {
          "chunk": "source_listing_and_basic_bootstrap",
          "topic": "Full source listing and BASIC bootstrap that loads/executes the machine code"
        }
      ]
    },
    {
      "start": 20274,
      "end": 20284,
      "name": "source_listing_and_basic_bootstrap",
      "description": "Header/title of the source listing and the BASIC bootstrap lines: 'FULL TRACK 27 SOURCE LISTING', REM comments, OPEN2,8,2 to write the file, and SYS40960 to jump to assembled code. Provides the user-level entry/installation steps.",
      "references": [
        {
          "chunk": "data_blob_machine_code",
          "topic": "Contains binary DATA lines referenced by the assembled program"
        },
        {
          "chunk": "assembler_directives_and_org",
          "topic": "Followed by assembler directives and the program organization"
        }
      ]
    },
    {
      "start": 20285,
      "end": 20293,
      "name": "assembler_directives_and_org",
      "description": "Assembler directives and program origin: includes assembler options (.OPT P,02), comment markers, and the origin setting (* = *0400). Also contains the comment heading for the initialization section.",
      "references": [
        {
          "chunk": "source_listing_and_basic_bootstrap",
          "topic": "BASIC bootstrap that invokes the assembled code"
        },
        {
          "chunk": "initialization_code_and_zero_page_setup",
          "topic": "Initialization code (zero-page/register setup) begins after these directives"
        }
      ]
    },
    {
      "start": 20294,
      "end": 20351,
      "name": "initialization_code_and_zero_page_setup",
      "description": "Initialization routine: comments and 6502 instructions that set up zero-page variables and registers (LDA/STA/LDX/STX sequences to initialize locations like *7F, *51, *80, *43, etc.). Includes filler/listing-number lines and blank lines from the original listing as part of the block.",
      "references": [
        {
          "chunk": "assembler_directives_and_org",
          "topic": "Assembly origin and options that apply to this initialization code"
        },
        {
          "chunk": "tail_gap_and_sector_variables",
          "topic": "Subsequent sector/tail/gap setup follows the zero-page initialization"
        }
      ]
    },
    {
      "start": 20352,
      "end": 20361,
      "name": "tail_gap_and_sector_variables",
      "description": "Store and initialize drive/track/sector related variables: STA to $0620, LDA immediate and STA $0626, LDA #0 and STA $0628. This section sets up variables used for tail/gap and sector tracking on the disk image.",
      "references": [
        {
          "chunk": "initialization_code_and_zero_page_setup",
          "topic": "Builds on the zero-page and register initialization performed earlier"
        },
        {
          "chunk": "sector_counter_and_headers_intro",
          "topic": "Next: sector counter, LED control, and header creation setup"
        }
      ]
    },
    {
      "start": 20362,
      "end": 20371,
      "name": "sector_counter_and_headers_intro",
      "description": "Labels and short sequence: TAIL GAP label, comment about SECTOR COUNTER, JSR *C100 (turn LED on), and the 'CREATE HEADERS' header comment. Serves as the transition from setup into the header creation routine.",
      "references": [
        {
          "chunk": "tail_gap_and_sector_variables",
          "topic": "Uses variables initialized for tail/gap and sector indices"
        },
        {
          "chunk": "header_creation_routine",
          "topic": "Header creation code begins immediately after these introductory lines"
        }
      ]
    },
    {
      "start": 20372,
      "end": 20411,
      "name": "header_creation_routine",
      "description": "Code that constructs sector headers in memory: LDX #0 and a sequence of LDA/STA/INX operations storing header ID bytes and track/sector/ID values into $0300,X. Includes setting fields (HBID, sector, track, IDL, IDH, GAP), and an XOR/EOR-based checksum accumulation followed by INC to update the computed checksum byte(s). Contains a few listing artifacts ('s' and '?') preserved from the original listing.",
      "references": [
        {
          "chunk": "sector_counter_and_headers_intro",
          "topic": "Introduced by the header-creation comment and the sector-counter setup"
        },
        {
          "chunk": "checksum_comments_and_increment",
          "topic": "High-level checksum comments and final increment of sector index ($0628) follow this routine"
        }
      ]
    },
    {
      "start": 20412,
      "end": 20434,
      "name": "checksum_comments_and_increment",
      "description": "Comments and small control code related to checksum and field descriptions: labeled comments showing where CHECKSUM, SECTOR, TRACK, IDL, IDH, GAP are handled, notes about computing/incrementing the checksum, and the final INC $0628 instruction. This block documents and performs the increment of the sector pointer used across the routine.",
      "references": [
        {
          "chunk": "header_creation_routine",
          "topic": "Contains the checksum computation code that this comment block describes and the increment that advances sector processing"
        },
        {
          "chunk": "tail_gap_and_sector_variables",
          "topic": "INC $0628 updates the sector/tail pointer initialized earlier"
        }
      ]
    },
    {
      "start": 20435,
      "end": 20504,
      "name": "full_track_27_source_listing_header",
      "description": "Header and metadata for the 'Full Track 27' source listing: assembler directives (.OPT, *= $0400), file open/SYS invocation, and comments describing initialization block. Sets up symbolic labels and constants used later in the source (IDL/IDH etc.).",
      "references": [
        {
          "chunk": "full_track_27_machine_code_data_blocks",
          "topic": "DATA blobs used by this source"
        },
        {
          "chunk": "formatting_initialization_and_header_building",
          "topic": "shared formatting/header techniques"
        }
      ]
    },
    {
      "start": 20505,
      "end": 20534,
      "name": "format_routine_setup_and_wait_loop",
      "description": "Assembly/source fragment for the 1541 format routine: STA *03, LDA #*4B -> STA *O500, LDX #$01 and the 1541 FORMAT label(s). Includes a small WAIT loop (LDA $03 / BMI WAIT) and a JMP to *C194. This chunk contains low-level initialization and control-flow (labels FORMAT and WAIT) used by the full-track formatting/attack routine.",
      "references": [
        {
          "chunk": "full_track27_error_annotation_and_single_sector_22_error_listing",
          "topic": "Context and commentary about the Full Track 27 attack and how this setup is used"
        }
      ]
    },
    {
      "start": 20535,
      "end": 20621,
      "name": "full_track27_error_annotation_and_single_sector_22_error_listing",
      "description": "Documentation and BASIC program for 'Full Track 27 Error Source Annotation' and the chapter 7.14 example 'How to Create a 22 Error on a Single Sector'. Contains the annotation note comparing to 20M.PAL, and a complete BASIC listing (lines 100 to 420) implementing the single-sector 22 error creator: prompts, parameter checks (track/sector validation), I/O open/close and the main M-W/M-R commands used to provoke the 22 error, ending with program END.",
      "references": [
        {
          "chunk": "format_routine_setup_and_wait_loop",
          "topic": "Assembly pieces of the formatting/attack routine used earlier in the chapter"
        },
        {
          "chunk": "job_queue_subroutine_listing_and_io_handling",
          "topic": "Subroutine (job queue) called by the BASIC listing for device I/O and retries"
        }
      ]
    },
    {
      "start": 20622,
      "end": 20654,
      "name": "job_queue_subroutine_listing_and_io_handling",
      "description": "BASIC 'JOB QUEUE' subroutine used by the examples: TRY counter and I/O command sequence for the 1541 (PRINT#15 'M-W' and 'M-R' sequences, GET#15 for responses, ASCII handling and retry logic). Includes error handling paths (close, prints on failure) and returns. Covers lines marked REM JOB QUEUE through the subroutine END and related I/O control logic.",
      "references": [
        {
          "chunk": "full_track27_error_annotation_and_single_sector_22_error_listing",
          "topic": "Used by the single-sector 22 error BASIC program to send/receive commands to the drive"
        },
        {
          "chunk": "single_sector_22_error_source_and_duplicate_error_intro",
          "topic": "Applies to the duplicate-22-error procedure which reuses the same I/O/job-queue logic"
        }
      ]
    },
    {
      "start": 20655,
      "end": 20700,
      "name": "single_sector_22_error_source_and_duplicate_error_intro",
      "description": "Notes and the beginning of chapter 7.15 'How to Duplicate a 22 Error on a Single Sector'. Starts with the 'SINGLE SECTOR 22 ERROR SOURCE LISTING' commentary explaining which program lines alter the block ID to create the error, then begins the BASIC program 'DUPLICATE A SINGLE SECTOR 22 ERROR' (program header, prompts to insert master, input of T,S, validation, confirmation prompt and initial OPEN/PRINT/INPUT#15 exchange). This chunk covers the explanatory note plus the program header and initial I/O interaction up through the early command/response handling.",
      "references": [
        {
          "chunk": "full_track27_error_annotation_and_single_sector_22_error_listing",
          "topic": "Related technique: creating a single-sector 22 error (this chunk describes duplicating that error)"
        },
        {
          "chunk": "job_queue_subroutine_listing_and_io_handling",
          "topic": "Shares the same drive I/O/command conventions and will use the job-queue subroutine for communication"
        }
      ]
    },
    {
      "start": 20701,
      "end": 20765,
      "name": "duplicate_single_sector_clone_routine",
      "description": "A short BASIC routine that closes and reopens device 15, performs SEEK and READ operations (J0B values 176 and 128), issues drive commands via PRINT#15 (M-R and M-W sequences), prompts the user to swap the master and clone disks, handles GET#15 responses, writes the sector to the clone (including a final M-W with CHR*(7)), closes the device and prints a completion message. Covers lines implementing the main duplication flow up to the program END.",
      "references": [
        {
          "chunk": "job_queue_error_handling",
          "topic": "Uses the job-queue subroutine for issuing/confirming drive commands"
        },
        {
          "chunk": "duplicate_single_sector_error_source_listing",
          "topic": "Explains the observed error source related to this duplication routine"
        }
      ]
    },
    {
      "start": 20766,
      "end": 20801,
      "name": "job_queue_error_handling",
      "description": "The job-queue implementation used by the duplication routine: initialization (TRY=0), composing and sending job packets (PRINT#15 M-W / M-R sequences), waiting for GET#15 responses, normalizing empty responses to CHR$(0), converting response bytes with ASC, retry counting (TRY increments and IF TRY=500 -> timeout path), conditional branches for response values (>127 and error recovery), CLOSE 15 and final error message on failure. Contains the subroutine's RETURN/END behavior and error-exit printout.",
      "references": [
        {
          "chunk": "duplicate_single_sector_clone_routine",
          "topic": "Called by the duplication main flow to send and confirm drive commands"
        },
        {
          "chunk": "multiple_id_formatting_subroutines_delay_and_job_queue",
          "topic": "Shared job-queue logic and retry behavior used elsewhere in the multiple-ID formatter"
        }
      ]
    },
    {
      "start": 20802,
      "end": 20806,
      "name": "duplicate_single_sector_error_source_listing",
      "description": "Error-source commentary for the duplicate-single-sector example: describes that no additional error sources were found, points out that line 320 reads the data-block identifier from the master, lines 460-490 duplicate the error on the clone, and line 500 restores state. A brief diagnostic explanation associated with the previous duplication routine.",
      "references": [
        {
          "chunk": "duplicate_single_sector_clone_routine",
          "topic": "Explains which lines in that routine relate to the observed error"
        }
      ]
    },
    {
      "start": 20807,
      "end": 20869,
      "name": "multiple_id_formatting_read_master_ids",
      "description": "Start of section 7.16 and the MULTIPLE ID FORMATTING program header and initialization: displays title/prompts, requests the user to insert the master (RVS) disk, opens device 15, initializes arrays (T(), H$(), L$()), loops over tracks (FOR T=1 TO 35) to read embedded ID bytes from the master using drive job (J0B=176) and GET#15 reads, stores primary track mapping T(T) and high/low ID bytes H$(T), L$(T) (normalizing blank reads to CHR$(0)), and then closes the drive after finishing the read pass. Covers setup and the complete ID-collection phase.",
      "references": [
        {
          "chunk": "multiple_id_formatting_write_parameters_and_execute",
          "topic": "Uses the arrays populated here to prepare per-track format parameters and to execute the format"
        },
        {
          "chunk": "multiple_id_formatting_subroutines_delay_and_job_queue",
          "topic": "Calls the common job-queue/GOSUB routines for drive communication and user delays"
        }
      ]
    },
    {
      "start": 20870,
      "end": 20971,
      "name": "multiple_id_formatting_write_parameters_and_execute",
      "description": "Clearing and writing format parameter phase of the MULTIPLE ID FORMATTING program: prompts user to insert a blank disk, reads a data table (READ D) to build D$(J) sequences, composes and sends M-W sector/image parameter packets (including per-track L$() and H$() values), prepares and executes the 1541 FORMAT sequence by sending M-E and M-W drive commands, monitors/inputs the drive's EN, EM, ET, ES status bytes, toggles J0B between 176/128/144 for seek/read/write phases, sends format control packets (including CHR*(18), CHR*(1), CHR*(65) etc), performs multiple passes (S flag changes), closes and reopens device 15 to send the 'NO: 1541 FORMAT' sequence, and prints completion message. This chunk contains the main format-parameter construction and the execute phase up to program END.",
      "references": [
        {
          "chunk": "multiple_id_formatting_read_master_ids",
          "topic": "Source of H$() and L$() per-track IDs used to build the write packets"
        },
        {
          "chunk": "multiple_id_formatting_subroutines_delay_and_job_queue",
          "topic": "Uses the delay prompt and job-queue subroutines for drive command sequencing and retries"
        }
      ]
    },
    {
      "start": 20972,
      "end": 21010,
      "name": "multiple_id_formatting_subroutines_delay_and_job_queue",
      "description": "Utility subroutines used by the formatter: REM DELAY (lines 900-950) which prompts the user to press Return, loops on GETC* to wait for CR, prints OK and returns; and a second REM JOB QUEUE (lines 960 onward) that initializes TRY, composes M-W job packets (CHR$ values including job and track parameters), increments TRY, sends M-R to poll for response, reads GET#15 response E$ (normalizing empty responses), converts to numeric E=ASC(E$), includes retry timeout handling (IF TRY=500 GOTO 1070) and conditional branching on response values. This chunk contains the I/O-wait and job-queue logic used by the multiple-ID formatter; it ends mid-sequence at the document boundary.",
      "references": [
        {
          "chunk": "job_queue_error_handling",
          "topic": "Related job-queue logic used earlier for the single-sector duplication example"
        },
        {
          "chunk": "multiple_id_formatting_write_parameters_and_execute",
          "topic": "Called to perform the SEEK/READ/WRITE job exchanges and to wait for drive responses during formatting"
        }
      ]
    },
    {
      "start": 21011,
      "end": 21027,
      "name": "machine_code_data_and_listing_footer",
      "description": "Trailing BASIC/assembly data block and short listing footer. Contains RETURN and NEW markers followed by DATA statements with machine-code byte values (lines 1090-1150 in the original listing), and a small numeric/footer line ('160'). This block is the tail of a machine-code DATA table used by the surrounding listings.",
      "references": [
        {
          "chunk": "multiple_id_formatting_driver_source_listing",
          "topic": "The driver source uses machine-code DATA tables loaded via BASIC DATA statements"
        }
      ]
    },
    {
      "start": 21028,
      "end": 21072,
      "name": "listing_title_and_basic_line_numbers",
      "description": "Title of the source listing ('MULTIPLE ID FORMATTING SOURCE LISTING') followed by a sequence of BASIC line numbers (100 through 510). Acts as the listing header and line-numbered program skeleton lines.",
      "references": [
        {
          "chunk": "basic_preamble_open_sys",
          "topic": "BASIC preamble, OPEN/SYS calls and REMs that follow the header"
        },
        {
          "chunk": "assembler_directives_origin_equates",
          "topic": "Assembly directive block that establishes origin and equates used by the listing"
        }
      ]
    },
    {
      "start": 21073,
      "end": 21083,
      "name": "basic_preamble_open_sys",
      "description": "BASIC preamble and comments: REM lines, an OPEN (printed as □PEN2) command with device parameters and a SYS call (SYS40960). This is the BASIC-side invocation and descriptive REMs for the driver.",
      "references": [
        {
          "chunk": "listing_title_and_basic_line_numbers",
          "topic": "Listing header and BASIC line numbers"
        },
        {
          "chunk": "assembler_directives_origin_equates",
          "topic": "Assembly directives and equates that follow the BASIC preamble"
        }
      ]
    },
    {
      "start": 21084,
      "end": 21090,
      "name": "assembler_directives_origin_equates",
      "description": "Assembler directives and equates: .OPT P,02 optimization directive, setting assembly origin (* = *0400) and defining IDL = *0431 and IDH = IDL+35 (per-track ID low/high table addresses).",
      "references": [
        {
          "chunk": "basic_preamble_open_sys",
          "topic": "BASIC invocation that calls into the assembled code"
        },
        {
          "chunk": "vector_and_drive_initialization",
          "topic": "Initialization of zero page and vectors that uses the origin and equates"
        }
      ]
    },
    {
      "start": 21091,
      "end": 21116,
      "name": "vector_and_drive_initialization",
      "description": "Initialization sequence: zero-page setup (LDA #*00; STA *7F), a JSR to *C100, and installation of a three-byte JMP vector into *0600..*0602 (values *4C, *C7, *FA) to effect a jump into *FAC7. Also sets up drive/LED via LDA #*E0; STA *03. Includes inline comments indicating DRIVE NUMBER and LED and the jump target.",
      "references": [
        {
          "chunk": "assembler_directives_origin_equates",
          "topic": "Equates and origin used by the code being initialized"
        },
        {
          "chunk": "table_load_id_bytes_loop",
          "topic": "Main TABLE loop that follows initialization and uses initialized state"
        }
      ]
    },
    {
      "start": 21117,
      "end": 21131,
      "name": "table_load_id_bytes_loop",
      "description": "TABLE loop that iterates per-track: LDY *51 (track number), LDA IDL,Y ; STA *13 (store ID low into $13), LDA IDH,Y ; STA *12 (store ID high into $12). Compares Y to #*23 (track 35) with CPY #*23 and BNE TABLE to loop until track 35 is reached. Implements loading of ID low/high bytes from the ID table into device command bytes.",
      "references": [
        {
          "chunk": "vector_and_drive_initialization",
          "topic": "Setup that prepares device and vectors before entering the TABLE loop"
        },
        {
          "chunk": "wait_loop_and_final_jmp",
          "topic": "After TABLE completes, code proceeds to WAIT/poll loop and final JMP"
        },
        {
          "chunk": "inline_comments_id_labels",
          "topic": "Comments and labels describing ID LO / ID HI / TRACK 35 data following the code"
        }
      ]
    },
    {
      "start": 21132,
      "end": 21138,
      "name": "wait_loop_and_final_jmp",
      "description": "WAIT polling loop and final jump: WAIT LDA *03 ; BMI WAIT — repeatedly polls location $03 and loops on negative (BMI) until ready. Afterwards performs JMP *C194 (jump to ENDCMD). This implements a simple busy-wait for drive status before finishing.",
      "references": [
        {
          "chunk": "table_load_id_bytes_loop",
          "topic": "TABLE loop prepares ID bytes prior to entering the WAIT/poll loop"
        },
        {
          "chunk": "inline_comments_id_labels",
          "topic": "Data/labels for ID table entries referred to by the TABLE loop"
        }
      ]
    },
    {
      "start": 21139,
      "end": 21149,
      "name": "inline_comments_id_labels",
      "description": "Trailing inline comments and labels: brief comments marking ';    ID  LO', ';    ID  HI', and ';    TRACK  35' that document the ID table layout and the last track index. These comments annotate the data region referenced earlier in the listing.",
      "references": [
        {
          "chunk": "table_load_id_bytes_loop",
          "topic": "ID low/high table entries (IDL/IDH) referenced and loaded by the TABLE loop"
        },
        {
          "chunk": "wait_loop_and_final_jmp",
          "topic": "Finalization/comments following the polling and ENDCMD jump"
        }
      ]
    },
    {
      "start": 21150,
      "end": 21165,
      "name": "multiple_id_formatting_annotation",
      "description": "Annotated explanation of the Multiple ID Formatting driver and how it operates. Describes that this is a modification of the standard NEW ($EE0D) formatting routine: embedded IDs are read from each master track and tabled in 1541 RAM starting at $0431; the driver stores the appropriate ID for each track into the master disk ID location ($12/$13) before passing control to the FDC to format each track; after formatting the IP regains control to load the next ID and repeat. Notes the limitation (no NO:DISK NAME, ID command in the command buffer) which prevents reuse of the standard routine's later portions for BAM/directory creation, and points to driver cleanup lines (lines 670-780).",
      "references": [
        {
          "chunk": "multiple_id_formatting_driver_source_listing",
          "topic": "Explains the purpose and behavior of the listed driver code"
        },
        {
          "chunk": "how_to_backup_dos_protected_diskette_and_1541_backup_program",
          "topic": "Related disk utility content (backup procedures) in the following section"
        }
      ]
    },
    {
      "start": 21166,
      "end": 21218,
      "name": "backup_overview_and_initialization",
      "description": "Title, limitations and parameters for backing up a DOS‑protected diskette, plus the start of the 1541 BACKUP BASIC listing (lines 100–320). Includes the REM header, initial POKE/CLR setup, FOR loops that dimension and initialize the T() table, a READ of SRW/ERW values, program banner/insert‑master prompt, GOSUB to the user‑prompt routine, OPEN15,8,15 to talk to the 1541, initialization of RW and RAM pointers, a short POKE to set up the buffer (POKE 252,34) and initial C=0 flag. (This chunk prepares the program and user for reading the master disk.)",
      "references": [
        {
          "chunk": "master_disk_seek_and_read_loops",
          "topic": "Follows with the SEEK and READ loops that actually read sectors from the master disk"
        },
        {
          "chunk": "clone_disk_insertion_and_write_seek_setup",
          "topic": "Later switches to the clone disk and begins the write/seek setup"
        }
      ]
    },
    {
      "start": 21219,
      "end": 21285,
      "name": "master_disk_seek_and_read_loops",
      "description": "The SEEK and READ phase for the master disk (BASIC lines ~330–630). Contains FOR T = SRW TO ERW track loop, calculation of NS (number of sectors per track chunk), conditional skips for empty tracks, calls to GOSUB 1190 for seek routines, error handling, adjustments to RW and RAM pointers, the READ loop (FOR S = 0 TO NS) with GOSUB 1300 to perform sector reads, status printing, SYS calls for 1541 operations, setting flags (C=1 and POKE RW,1) and incrementing buffer addresses, followed by NEXT S/NEXT T and CLOSE15. Ends with the branch that decides whether to proceed to cloning.",
      "references": [
        {
          "chunk": "backup_overview_and_initialization",
          "topic": "Built on the earlier initialization (drive open, buffer pointers, T() table)"
        },
        {
          "chunk": "clone_disk_insertion_and_write_seek_setup",
          "topic": "After closing the master, the program prompts for the clone disk and begins the write/seek setup"
        }
      ]
    },
    {
      "start": 21286,
      "end": 21320,
      "name": "clone_disk_insertion_and_write_seek_setup",
      "description": "Switching to the clone disk and beginning the write phase (BASIC lines ~640–800). Tests C and branches if no data was read, prints the prompt to insert the clone disk and calls the user‑prompt subroutine, reopens the drive (OPEN15,8,15), reinitializes RW and RAM and POKE 252,34, then begins the SEEK loop for writing: FOR T = SRW TO ERW, NS calculation, sets JOB=176 and calls GOSUB 1190 (seek), error checks, updates RAM and W (write pointer), and finally GOTO 990 to jump into the write/sector‑write routine (not included in this chunk).",
      "references": [
        {
          "chunk": "backup_overview_and_initialization",
          "topic": "Uses the buffer and table initialization performed at program start"
        },
        {
          "chunk": "master_disk_seek_and_read_loops",
          "topic": "Executes after the master READ phase; mirrors SEEK logic but proceeds to write sectors to the clone disk"
        }
      ]
    },
    {
      "start": 21321,
      "end": 21384,
      "name": "basic_write_loop_and_completion",
      "description": "BASIC program 'WRITE' routine and program termination (lines 810–1090). Updates read/write pointers (RW), 1541 RAM address (RAM), uses POKE to set the 1541 RAM-page, loops over tracks/sectors, calls subroutines (GOSUB 1300/1190), prints progress messages, issues SYS to run machine code, manages job variable (JOB), advances pointers (RW,RAM), closes device (CLOSE 15), prints error summaries and completion messages, POKE to restore I/O flag, CLR, and END.",
      "references": [
        {
          "chunk": "job_queue_and_channel_io",
          "topic": "job-queue command send/receive used by the write loop (PRINT#15 / GET#15)"
        },
        {
          "chunk": "format_two_digit_str_and_c000_marker",
          "topic": "STR$ subroutine (formats track/sector strings) called from the write loop"
        },
        {
          "chunk": "machine_code_data_and_track_skip_table",
          "topic": "machine-code at $C000 executed via SYS from the write loop"
        }
      ]
    },
    {
      "start": 21385,
      "end": 21396,
      "name": "basic_delay_and_user_prompt",
      "description": "BASIC 'DELAY' subroutine (lines 1100–1170). Prompts user to press RETURN to continue, implements key-wait loop (GET and CR/Enter detection), conditional skip behavior depending on flags, prints 'OK' and returns to caller.",
      "references": [
        {
          "chunk": "basic_write_loop_and_completion",
          "topic": "Used by the main program to pause between operations and wait for user to swap disks or confirm"
        }
      ]
    },
    {
      "start": 21397,
      "end": 21419,
      "name": "job_queue_and_channel_io",
      "description": "BASIC job-queue routines for communicating with the 1541 (lines 1180–1280). Initializes TRY counter, sends M-W job packets with PRINT#15 including control bytes and track/sector (T,S), increments TRY, sends M-R request, reads response with GET#15 into E*, converts response to numeric (ASC), handles timeouts (TRY>500) and error codes (E>127), and returns.",
      "references": [
        {
          "chunk": "basic_write_loop_and_completion",
          "topic": "Called by the write loop to queue read/write jobs to the drive"
        },
        {
          "chunk": "disk_commands_and_mr_entry",
          "topic": "Corresponding assembly M-R/M-W command formats and entry points used by the drive-side code"
        }
      ]
    },
    {
      "start": 21420,
      "end": 21432,
      "name": "format_two_digit_str_and_c000_marker",
      "description": "BASIC STR$ helper (lines 1290–1320) and marker for machine-code area. STR$ formats track (T) and sector (S) as two-character strings using RIGHT$ and LEN manipulation, then RETURN. Followed by a REM marker indicating the upcoming machine-code block at $C000.",
      "references": [
        {
          "chunk": "basic_write_loop_and_completion",
          "topic": "STR$ is used by the main program to format track/sector for job packets"
        },
        {
          "chunk": "machine_code_data_and_track_skip_table",
          "topic": "Marker indicates the machine-code DATA block that implements drive-side routines"
        }
      ]
    },
    {
      "start": 21433,
      "end": 21456,
      "name": "machine_code_data_and_track_skip_table",
      "description": "DATA block containing machine-code bytes for the drive/resident routine (labelled *C000) and the track-skip table (lines 1340–1535). A sequence of DATA statements lists byte values (the assembled ML routine to be POKEd or SYSed into $C000), followed by REM TRACK and a DATA table of track numbers to skip or process (e.g., 1,6,7,12,13,17,18,24,25,30,31,35).",
      "references": [
        {
          "chunk": "format_two_digit_str_and_c000_marker",
          "topic": "This DATA block corresponds to the *C000 machine-code marker referenced by the BASIC listing"
        },
        {
          "chunk": "assembly_header_and_system_constants",
          "topic": "Assembly source listing provides the human-readable version of the routines whose bytes appear here"
        }
      ]
    },
    {
      "start": 21457,
      "end": 21512,
      "name": "assembly_header_and_system_constants",
      "description": "Assembly source listing header and constants (lines 1541 BACKUP SOURCE LISTING through basic loader and system constants). Contains the title and BASIC bootstrap lines (e.g., OPEN 2,8,2 and SYS 40960), assembler directives (.OPT P,02), comment describing M-R/M-W routines, origin declaration (*=$C000), RAM location notes (POINT = *00FB pointer to read/write), and system routine addresses used (CHKOUT, CHROUT, CLRCHN, CHKIN, etc.) with explanatory comments.",
      "references": [
        {
          "chunk": "machine_code_data_and_track_skip_table",
          "topic": "The DATA bytes earlier are the binary form of the assembler routines that start at $C000"
        },
        {
          "chunk": "disk_commands_and_mr_entry",
          "topic": "Defines constants and entry origin used by the M-R/M-W command definitions and M-R entry point"
        }
      ]
    },
    {
      "start": 21513,
      "end": 21600,
      "name": "disk_commands_and_mr_entry",
      "description": "Assembly definitions for disk M-R / M-W commands and the M-R entry point (lines 'DISK M-R' through the initial M-R entry code). Defines ASCII command labels for 'M-R' and 'M-W', a TEMP byte sequence, and begins the 'READ FROM DISK ROUTINES' section. Provides the M-R entry code that initializes the POINT pointer (LDA #*00; STA POINT; STA MR+3) and contains the comment 'ASK FOR FIRST HALF' — the listing stops mid-routine at line 21600.",
      "references": [
        {
          "chunk": "assembly_header_and_system_constants",
          "topic": "Uses the assembler origin and system constants defined in the header (e.g., POINT, CHKOUT)"
        },
        {
          "chunk": "job_queue_and_channel_io",
          "topic": "These M-R/M-W command formats are the drive-side counterparts to the BASIC PRINT#15 / GET#15 job-queue communications"
        }
      ]
    },
    {
      "start": 21601,
      "end": 21654,
      "name": "read_two_half_pages_entry",
      "description": "Top-level entry that invokes the READIT subroutine to read a file in two 256-byte halves. Sequence: call READIT to read the first half, set (POINT) to point to the second half (store into POINT and MR+3), then call READIT again to read the second half. Ends with RTS to return control to BASIC.",
      "references": [
        {
          "chunk": "readit_subroutine_half_page",
          "topic": "actual READIT routine that performs the half-page transfer (called twice here)"
        },
        {
          "chunk": "send_to_disk_and_mw_write_entry",
          "topic": "related disk I/O conventions and M-W write routines (complementary send-side code)"
        }
      ]
    },
    {
      "start": 21655,
      "end": 21675,
      "name": "readit_subroutine_header_and_prepare_output",
      "description": "Header and initial setup of the READIT subroutine. Contains the comment header ('SUBROUTINE TO READ IN HALF PAGE'), the READIT label, an LDX initialization (index setup for the forthcoming command transfer — shown as '#*of' in the source), and the JSR CHKOUT call to prepare the device/channel for output.",
      "references": [
        {
          "chunk": "send_m-r_command_loop",
          "topic": "follows: sends the M-R command bytes prepared by this setup"
        }
      ]
    },
    {
      "start": 21676,
      "end": 21722,
      "name": "send_m-r_command_loop",
      "description": "Loop that sends the 'M-R' command bytes to the device. Includes an LDX initialization (shown as '#*00'), the loop label LOOPl, the instruction 'LDA MR,X' with the inline comment '; SEND M-R COMMAND' (reading command bytes from the MR table), and the call to a character-send routine (JSR) to transmit each byte. This region is the command-transmit loop that iterates over MR,X until the command sequence is sent.",
      "references": [
        {
          "chunk": "readit_subroutine_header_and_prepare_output",
          "topic": "preceded by: READIT setup and CHKOUT to prepare for output"
        },
        {
          "chunk": "prepare_channel_15_for_input",
          "topic": "followed by: preparing channel 15 for input (CHIN) to perform the read"
        }
      ]
    },
    {
      "start": 21723,
      "end": 21734,
      "name": "prepare_channel_15_for_input",
      "description": "Prepare the disk/controller channel 15 for input following command transmission. Contains 'LDX #*0F' (set X to $0F, i.e. select channel 15) and 'JSR CHKIN' to switch the channel into input mode.",
      "references": [
        {
          "chunk": "send_m-r_command_loop",
          "topic": "preceded by: command transmit loop that sent the M-R command"
        },
        {
          "chunk": "read_half_page_input_loop",
          "topic": "followed by: the read loop that performs the half-page input from channel 15"
        }
      ]
    },
    {
      "start": 21735,
      "end": 21775,
      "name": "read_half_page_input_loop",
      "description": "The input/read loop that reads a half-page of data from the disk into memory and finishes the subroutine. Contains LDY #*00 to start Y at 0, label L00P2 with 'JSR CHRIN' to read a byte, 'STA (POINT),Y' to store the byte at (POINT),Y, 'INY' to increment the destination index, 'CPY #$81' and 'BNE L00P2' to loop until Y reaches $81 (end of half-page). After the loop it calls 'JSR CLRCHN' to clear the channel and 'RTS' to return from the subroutine.",
      "references": [
        {
          "chunk": "prepare_channel_15_for_input",
          "topic": "preceded by: channel 15 setup for input (LDX #$0F; JSR CHKIN)"
        }
      ]
    },
    {
      "start": 21776,
      "end": 21802,
      "name": "send_to_disk_section_header",
      "description": "Document header and section introduction for the 'SEND TO DISK ROUTINES' area, including page/date markers, block/segment identifiers and the comment marking the start of the FIRST M-W ENTRY POINT. (This chunk contains only the section header, metadata lines, and the comment that introduces the M-W entry.)",
      "references": [
        {
          "chunk": "mw_entry_mrite_and_header_transmit",
          "topic": "Contains the MRITE M-W entry implementation referenced by this header"
        }
      ]
    },
    {
      "start": 21803,
      "end": 21871,
      "name": "mw_entry_mrite_and_header_transmit",
      "description": "The first M-W (memory-to-disk / write) entry routine labeled MRITE. Initializes the PART pointer (TEMP) with LDA #*00 / STA TEMP, then L00P3 loads TEMP, adds #*20 (increments the PART pointer by $20), stores back to TEMP and branches to DONE if it wraps (BEQ DONE). Prepares channel 15 for output (LDX #*0F; JSR CHKOUT) and transmits the \"M-W\" command header and parameters by looping L00P4: LDX #*00; L00P4 LDA MW,X; JSR CHROUT; INX; CPX #*06; BNE L00P4 — sending 6 bytes from the MW table.",
      "references": [
        {
          "chunk": "send_to_disk_section_header",
          "topic": "Provides the section title and comment that introduce this MRITE entry"
        },
        {
          "chunk": "buffer_pointer_setup_and_loop1_start",
          "topic": "Continues with setup of buffer pointers/indices and the LOOP1 processing that follows the header transmit"
        }
      ]
    },
    {
      "start": 21872,
      "end": 21900,
      "name": "buffer_pointer_setup_and_loop1_start",
      "description": "Continuation of the MRITE/send-to-disk sequence showing setup of buffer pointers and indices and the start of the data processing loop. Contains labels and instructions that store and load buffer-related locations (e.g., STA 1, LDY 1) and the declaration of LOOP1 (incomplete in this excerpt). This chunk covers the transition from header transmit to buffer initialization and the top of the per-buffer loop.",
      "references": [
        {
          "chunk": "mw_entry_mrite_and_header_transmit",
          "topic": "Previous chunk sends the M-W header and parameters; this chunk initializes buffer pointers and begins the LOOP1 data handling that follows"
        }
      ]
    },
    {
      "start": 21901,
      "end": 21955,
      "name": "ml_routine_epilogue_and_return",
      "description": "Final fragment of a machine-language routine: assorted labels and instructions (JSR, CPY, BNE, LDA, BEQ, etc.), concluding with the DONE label and an RTS that returns control to BASIC. This section appears as the tail of the low-level code used by the copy/backup utilities.",
      "references": [
        {
          "chunk": "1541_backup_source_annotation",
          "topic": "Explains the high-level backup flow that uses the machine routines described here"
        }
      ]
    },
    {
      "start": 21956,
      "end": 21971,
      "name": "1541_backup_source_annotation",
      "description": "Annotation describing the 1541 backup process: how the BASIC driver reads a sector from the master into 1541 RAM via the job queue, uses machine-language memory-read to transfer bytes into the C64, then inserts the clone and uses memory-write to transfer bytes back into 1541 RAM, and finally writes the buffer out via the job queue. Notes on relative speed (reads slower than writes) and the C64 internal clock unreliability during disk I/O; mentions where to bypass bad tracks and using earlier routines to recreate errors from the master diskette.",
      "references": [
        {
          "chunk": "how_to_copy_a_file_overview",
          "topic": "Gives the higher-level copy procedure context and points to the BASIC COPY program"
        },
        {
          "chunk": "ml_routine_epilogue_and_return",
          "topic": "Contains the low-level machine routines invoked during the described backup flow"
        }
      ]
    },
    {
      "start": 21972,
      "end": 21985,
      "name": "how_to_copy_a_file_overview",
      "description": "Section header and constraints for copying files (7.18 How to Copy a File). Lists limitations (max 125 blocks, will not copy relative files, wildcards not permitted) and required parameters (file name and file type). This is the introduction/requirements portion immediately preceding the '1541 COPY' BASIC program listing.",
      "references": [
        {
          "chunk": "1541_copy_basic_main_program",
          "topic": "Contains the complete BASIC '1541 COPY' program that implements the described copying procedure"
        },
        {
          "chunk": "1541_backup_source_annotation",
          "topic": "Related backup context and rationale for using machine-language transfers"
        }
      ]
    },
    {
      "start": 21986,
      "end": 22103,
      "name": "1541_copy_basic_main_program",
      "description": "Full BASIC '1541 COPY' program main flow (lines 100–690 and surrounding code): initialization POKEs to set up communication parameters, driver/queue initialization, prompts to insert master disk, filename and file-type input and validation, logic to open the source file on the master, directory header reading (EN/EM/ET/ES), block and free-space computation, choosing read/write mode, job-queue setup, issuing SYS (machine-language) calls to perform memory-read and memory-write transfers between the 1541 and the C64, channel closes and final END. Includes messages for user prompts and disk full handling.",
      "references": [
        {
          "chunk": "support_routines_delay_and_return",
          "topic": "Small supporting subroutines (close, delay/press-return) called by the main program"
        },
        {
          "chunk": "initialization_and_error_handling_and_mldata",
          "topic": "Initialization, file-not-found handling, and embedded machine-code DATA bytes used by the SYS routines"
        },
        {
          "chunk": "1541_backup_source_annotation",
          "topic": "Explains the high-level backup flow that this BASIC program implements"
        }
      ]
    },
    {
      "start": 22104,
      "end": 22124,
      "name": "support_routines_delay_and_return",
      "description": "Support subroutines and utility routines for the BASIC COPY program: REM CLOSE and CLOSE15 handling, error/failure messages and branching back to cleanup, a delay/press-return loop (PRINT prompt, GET loop waiting for CR), and a RETURN to resume the main program. These routines handle user interaction and graceful exit after failures or prompts.",
      "references": [
        {
          "chunk": "1541_copy_basic_main_program",
          "topic": "Called by the main BASIC COPY routine for closing channels, pausing for user input, and returning control"
        },
        {
          "chunk": "initialization_and_error_handling_and_mldata",
          "topic": "Error-handling and I/O initialization routines related to these support helpers"
        }
      ]
    },
    {
      "start": 22125,
      "end": 22183,
      "name": "initialization_and_error_handling_and_mldata",
      "description": "Initialization and error-handling routines plus embedded machine-code DATA for load/save. Covers OPEN15 to initialize communications with the 1541, sending the '10' init command and checking EN/EM/ET/ES response, printing drive/version info, handling 'file not found' / 'file exists' conditions via OPEN2/O: and reading the error channel, printing failure messages and closing channels, and finally a block of DATA statements containing machine-code bytes (used by the SYS loader/saver).",
      "references": [
        {
          "chunk": "1541_copy_basic_main_program",
          "topic": "Main program issues SYS calls that rely on the initialization and on the DATA machine code loaded by these routines"
        },
        {
          "chunk": "copy_file_source_listing_assembly_stub",
          "topic": "Assembler source listing and PAL/assembly stub that corresponds to the machine-code bytes embedded here"
        },
        {
          "chunk": "support_routines_delay_and_return",
          "topic": "Error handling and flow control jumps back to the support routines"
        }
      ]
    },
    {
      "start": 22184,
      "end": 22200,
      "name": "copy_file_source_listing_assembly_stub",
      "description": "Assembler/source listing header and small assembly/PAL stub for the COPY utility: title 'COPY A FILE SOURCE LISTING', REM comments, an example OPEN2 command for creating the output file, a SYS40960 invocation, assembler directives (.OPT P,02) and an origin directive (* = *C000). This is the assembler-side companion to the BASIC and DATA machine-code pieces above.",
      "references": [
        {
          "chunk": "initialization_and_error_handling_and_mldata",
          "topic": "Contains or references the machine-code data bytes (DATA statements) that the assembler stub would represent or use"
        },
        {
          "chunk": "1541_copy_basic_main_program",
          "topic": "The BASIC program issues SYS calls into the machine-code routines that this assembly listing implements"
        }
      ]
    },
    {
      "start": 22201,
      "end": 22285,
      "name": "copy_file_machine_code_listing",
      "description": "Complete machine-language listing used by the COPY BASIC program to emulate LOAD and SAVE. Includes the LOAD routine (open channel via JSR $FFC6, read via JSR $FFE4 and JSR $FFB7, store bytes into buffer at $FB, loop and close with JSR $FFCC) and the SAVE routine (open via JSR $FFC9, write loop using CHROUT JSR $FFD2 reading from (*FD),Y, compare and increment counters in $FB/$FC/$FE, close with JSR $FFCC, RTS). All labels, branches, and loop logic for both transfer directions are present.",
      "references": [
        {
          "chunk": "copy_file_source_annotation_and_conclusion",
          "topic": "brief annotation and concluding remarks about this routine"
        },
        {
          "chunk": "getting_out_of_trouble_unscratching_file",
          "topic": "subsequent chapter starts (context in the manual following this listing)"
        }
      ]
    },
    {
      "start": 22286,
      "end": 22299,
      "name": "copy_file_source_annotation_and_conclusion",
      "description": "Annotation and short commentary following the COPY machine-code listing. Contains a one-line annotation: 'This routine emulates a LOAD and SAVE from machine language.' Followed by the 'Conclusion' section opening paragraphs emphasizing studying the listings and noting the sophistication of the DOS protection-related programming techniques. (Narrative commentary; contextualizes the preceding listing.)",
      "references": [
        {
          "chunk": "copy_file_machine_code_listing",
          "topic": "the machine-language routines being annotated"
        },
        {
          "chunk": "getting_out_of_trouble_unscratching_file",
          "topic": "next chapter and troubleshooting content that follows"
        }
      ]
    },
    {
      "start": 22300,
      "end": 22400,
      "name": "getting_out_of_trouble_unscratching_file",
      "description": "Beginning of Chapter 8 'GETTING OUT OF TROUBLE'. Introduction stressing backups and recovery, followed by section 8.1 'Unscratching a File'. Explains what happens when a file is scratched (directory file-type byte set to $00 and sectors freed in the BAM) and the high-level steps to recover: restore file-type byte and VALIDATE the disk to reallocate sectors. Describes using the VIRTUAL DIRECTORY and EDIT TRACK & SECTOR utilities and details STEP 1: running VIRTUAL DIRECTORY to identify which group (sector) the scratched entry is in, how groups map to sectors, and the table mapping directory groups to track 18 sector numbers (partial table as present in this excerpt).",
      "references": [
        {
          "chunk": "copy_file_machine_code_listing",
          "topic": "previous chapter's machine-code examples referenced earlier in the manual"
        },
        {
          "chunk": "copy_file_source_annotation_and_conclusion",
          "topic": "the concluding remarks that directly precede this chapter"
        }
      ]
    },
    {
      "start": 22401,
      "end": 22424,
      "name": "chapter8_getting_out_of_trouble_unscratch_and_recovery_overview",
      "description": "Chapter 8 introduction and practical recovery procedures: stresses backups and introduces tools for recovery. Explains unscratching a file (what changes when scratching occurs: file-type byte set to $00 and sectors freed in BAM), step-by-step recovery using 'VIRTUAL DIRECTORY' and 'EDIT TRACK & SECTOR' (locate half-sector containing directory entry on track 18, edit file-type byte back to correct file type, rewrite sector, and VALIDATE disk with OPEN 15,8,15,\"V0\":CLOSE15). Provides group-to-sector mapping for directory groups to sectors on track 18 and lists file-type hex values for PRG/SEQ/REL/USR/DEL. Begins discussion of soft vs hard read/write errors and points to appendix utilities (RECOVER TRACK & SECTOR, LAZARUS) to attempt sector recovery. Also introduces steps for hard error recovery and relative-file recovery summaries and finally advises running 1541 BACKUP to rescue an entire non-initializable diskette.",
      "references": [
        {
          "chunk": "virtual_directory_and_edit_track_sector_tools",
          "topic": "tools mentioned for unscratching and editing sectors (Appendix C)"
        },
        {
          "chunk": "recover_soft_vs_hard_errors_overview",
          "topic": "classification of read/write errors into soft and hard and recovery suggestions"
        }
      ]
    },
    {
      "start": 22425,
      "end": 22485,
      "name": "recover_scratched_file_edit_sector",
      "description": "Steps for recovering a scratched (scratched file entry in directory) file using the EDIT TRACK & SECTOR utility: load the program, enter track 18 and the sector from the table, choose starting byte 00 (first four files) or 80 (last four), examine the hex dump to find the filename and the file-type byte (00 meaning scratched) and overwrite it with the correct file-type value. Includes the file-type value table listing file types PRG, SEQ, REL, USR, DEL and their corresponding numeric values, plus a recommendation to practice these steps on a test diskette (SAVE, SCRATCH, then recover).",
      "references": [
        {
          "chunk": "track18_directory_sector_table",
          "topic": "Sector lookup table referenced when entering the sector number"
        },
        {
          "chunk": "recovering_unclosed_file",
          "topic": "If recovering a PRG or other file type, follow further link-fixing steps discussed elsewhere"
        }
      ]
    },
    {
      "start": 22486,
      "end": 22518,
      "name": "soft_vs_hard_errors_definition",
      "description": "Definition and differences between soft and hard read/write DOS errors: hard errors occur in header blocks (never rewritten) and are unrecoverable; soft errors occur in data blocks and can sometimes be recovered. Provides a short table indicating which reported error numbers are soft vs hard (examples: 22/20 read errors, 23/21 read errors, other codes listed). Also introduces two recovery utilities in Appendix C (RECOVER TRACK & SECTOR and LAZARUS) and explains their roles: RECOVER TRACK & SECTOR tries to rewrite a damaged sector; LAZARUS attempts to resurrect an entire diskette and reports read/write error counts.",
      "references": [
        {
          "chunk": "recovering_hard_error",
          "topic": "If an error is identified as a hard error, follow the hard-error recovery procedure"
        },
        {
          "chunk": "recovering_soft_error",
          "topic": "If an error is soft, use RECOVER TRACK & SECTOR or LAZARUS (Appendix C) to attempt recovery"
        }
      ]
    },
    {
      "start": 22519,
      "end": 22580,
      "name": "recovering_hard_error",
      "description": "Procedure for attempting to recover from a hard error (section 8.3): preliminary diagnostics (validate diskette, FIND A FILE to get starting track/sector, DISPLAY A CHAIN to identify the last successful sector), then editing the sector just before the error with EDIT TRACK & SECTOR to sever the forward link (write 00,FF at offset 00) so you can manipulate the intact front end of the file. Special instructions for PRG files (restore internal BASIC links with a machine-language monitor or via EDIT TRACK & SECTOR by finding the last 00 byte in the block and setting following bytes and forward pointer accordingly) and for SEQ files (read recovered data into C64 RAM and rewrite to another disk). Warning and troubleshooting guidance (e.g., check whether errors occur on other diskettes—drive misalignment).",
      "references": [
        {
          "chunk": "soft_vs_hard_errors_definition",
          "topic": "Distinguishes hard vs soft errors and when to use this hard-error procedure"
        },
        {
          "chunk": "recovering_relative_file",
          "topic": "Recovering relative (REL) files uses a different method (see section 8.4)"
        }
      ]
    },
    {
      "start": 22581,
      "end": 22593,
      "name": "recovering_relative_file",
      "description": "Short guidance for recovering a relative (REL) file (section 8.4): open the REL file for read and copy record-by-record into a sequential file, skipping records that trigger errors so only intact records are preserved. Advises contacting an experienced programmer if you do not know how to perform record-by-record copying. (This chunk also covers trailing blank/page lines surrounding section 8.4.)",
      "references": [
        {
          "chunk": "recovering_hard_error",
          "topic": "REL files require a different approach than PRG/SEQ files described in the hard-error recovery procedure"
        }
      ]
    },
    {
      "start": 22594,
      "end": 22614,
      "name": "recovering_entire_diskette",
      "description": "Steps for recovering an entire diskette that cannot be initialized (section 8.5): run the 1541 BACKUP program (chapter 7) to make a backup; if the directory appears normal, VALIDATE the backup; if VALIDATE fails, inspect and copy intact files to a new disk. If the backup's directory cannot be fully listed (hard error on track 18 during backup), run DISPLAY A CHAIN on the backup to locate the uncopyable sector, then use EDIT TRACK & SECTOR to relink the directory around the bad sector (consult the table in section 8.1 to determine the normally following sector). Note that relinking may lose up to eight files; then inspect and copy remaining files to a new diskette.",
      "references": [
        {
          "chunk": "track18_directory_sector_table",
          "topic": "Use directory/track/sector tables when reconstructing track 18, sector 1"
        },
        {
          "chunk": "recovering_physically_damaged_diskette",
          "topic": "If diskette damage is physical, consider the physical recovery steps before attempting backup"
        }
      ]
    },
    {
      "start": 22615,
      "end": 22636,
      "name": "recovering_physically_damaged_diskette",
      "description": "Advice for recovering a physically damaged diskette (section 8.6): common problems include warped jacket or contamination. Carefully open the protective jacket with plastic gloves, remove the plastic disk, wash (use photographer's wetting agent to avoid residue) and air-dry if gummy, and insert the plastic disk into a new jacket (note which side faces up; handle by edges/hub). If a reusable jacket from head-cleaners is available it may be used. After re-jacketing, attempt to initialize the disk—if successful, immediately make a backup.",
      "references": [
        {
          "chunk": "recovering_entire_diskette",
          "topic": "After physically recovering the disk, run 1541 BACKUP and VALIDATE as described in the entire-diskette recovery procedure"
        }
      ]
    },
    {
      "start": 22637,
      "end": 22678,
      "name": "recovering_unclosed_file",
      "description": "Recovering an unclosed file (section 8.7): unclosed files are listed with an asterisk prefix in the directory (e.g., *SEQ, *PRG). There is an undocumented disk-drive read mode 'M' (MODIFY) that allows reading unclosed files. Syntax examples: OPEN 2,8,2,\"file name,B,M\" for SEQ and OPEN 2,8,2,\"file name,P,M\" for PRG. When reading in M mode, no EOI is returned so the read program must display incoming bytes and have a breakpoint to stop before reading beyond the actual file contents; the last sector will contain an erroneous forward track/sector pointer. After saving recovered data to another disk, restore internal BASIC links for PRG files using techniques from section 8.3 and VALIDATE the diskette (since scratching an unclosed file poisons the BAM). (Also covers surrounding blank lines and page number markers.)",
      "references": [
        {
          "chunk": "recovering_hard_error",
          "topic": "Use the link-restoration techniques from hard-error recovery to restore internal BASIC links after reading an unclosed PRG"
        }
      ]
    },
    {
      "start": 22679,
      "end": 22732,
      "name": "recovering_from_short_new",
      "description": "Recovering after a short NEW (section 8.8): a short NEW zeros the BAM and sector 1 of track 18. Steps: run EDIT TRACK & SECTOR, call up track 18 sector 1 and change the forward track/sector pointer from 00,FF to 12,04. Then load and list the directory—if disk had more than eight active files, only the first eight are lost and the remaining will display; do not VALIDATE (directory sectors won't be reallocated). Copy remaining files to a new disk. If you need to recover the first eight files, reconstruct starting track/sector locations by making a sector grid, VALIDATE original diskette, run DISPLAY A BLOCK AVAILABILITY MAP (Appendix C) to mark used sectors, then run DISPLAY A CHAIN to find chains beginning near track 17/19 and work outward from track 18; after locating starting locations, use EDIT TRACK & SECTOR to reconstruct track 18 sector 1 using your discovered starting locations, then copy the eight files to another disk.",
      "references": [
        {
          "chunk": "track18_directory_sector_table",
          "topic": "When reconstructing track 18 sector 1, consult the tables and hex dumps (Chapter 4) and substitute found starting locations"
        },
        {
          "chunk": "recovering_entire_diskette",
          "topic": "After reconstructing directory pointers, copy recovered files to a new disk as in entire-diskette recovery"
        }
      ]
    },
    {
      "start": 22733,
      "end": 22756,
      "name": "recovering_from_full_new",
      "description": "Recovering from a full NEW (section 8.9): if you interrupt a full FORMAT in progress, immediately open the drive and try to stop the reformat (one track lost per stepper motor click). Attempt to make a backup with the 1541 BACKUP program; because formatting goes from outer tracks inward, if you stopped in time track 18 may still be intact and many files recoverable. Run VALIDATE A DISKETTE to assess damage; often many files can be recovered. Advice includes remaining calm and acting quickly to minimize track loss.",
      "references": [
        {
          "chunk": "recovering_entire_diskette",
          "topic": "After stopping a format, use 1541 BACKUP and VALIDATE as described in entire-diskette recovery"
        }
      ]
    },
    {
      "start": 22757,
      "end": 22764,
      "name": "conclusion_disk_recovery",
      "description": "Conclusion: recovering a damaged diskette is more art than science. The provided utilities and techniques are useful, but prevention (backups, careful operations) is easier than repair. Final admonition to keep backups and that creating errors is easier than fixing them.",
      "references": [
        {
          "chunk": "recovering_physically_damaged_diskette",
          "topic": "Prevention: handle diskettes carefully to avoid needing these recovery techniques"
        },
        {
          "chunk": "recovering_from_short_new",
          "topic": "Refer to short NEW recovery techniques as part of overall recovery strategy"
        }
      ]
    }
  ],
  "source_md5": "038cc7e5004b8728f63448a55fc18dec"
}
