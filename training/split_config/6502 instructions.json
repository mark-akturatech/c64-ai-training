{
  "source_file": "6502 instructions.txt",
  "context": "6502 Instruction Set",
  "splits": [
    {
      "start": 1,
      "end": 60,
      "name": "title_and_opcode_matrix_overview",
      "description": "Document title, table of contents, and high-level opcode matrix overview: TOC entries, view toggles (standard/illegal/WDC), high-level opcode table (hex rows/columns), and the initial description of addressing mode names (A, abs, abs,X, abs,Y, # immediate, impl, ind, X,ind, ind,Y, rel, zpg, zpg,X, zpg,Y). Mentions little-endian 16-bit word layout and page/carry behavior. Chips referenced: NMOS 6502, WDC 65C02.",
      "references": [
        {
          "chunk": "address_modes_details",
          "topic": "addressing modes in detail and notes on page crossing"
        },
        {
          "chunk": "instructions_by_name",
          "topic": "full instruction name list and mnemonics"
        }
      ]
    },
    {
      "start": 61,
      "end": 120,
      "name": "instructions_by_name_and_registers",
      "description": "List of instruction mnemonics (ADC, AND, ASL, BCC, BCS, BEQ, BIT, BMI, BNE, BPL, BRK, BVC, BVS, CLC, CLD, CLI, CLV, CMP, CPX, CPY, DEC, DEX, DEY, EOR, INC, INX, INY, JMP, JSR, LDA, LDX, LDY, LSR, NOP, ORA, PHA, PHP, PLA, PLP, ROL, ROR, RTI, RTS, SBC, SEC, SED, SEI, STA, STX, STY, TAX, TAY, TSX, TXA, TXS, TYA). Block diagram caption and start of Registers section (PC, AC/Accumulator, X, Y, SR, SP).",
      "references": [
        {
          "chunk": "status_register_and_flags",
          "topic": "status register flags and meanings"
        },
        {
          "chunk": "address_modes_details",
          "topic": "addressing modes referenced by instruction forms"
        }
      ]
    },
    {
      "start": 121,
      "end": 180,
      "name": "registers_accumulator_index_and_program_counter",
      "description": "Detailed register descriptions: PC (16-bit), AC/A (accumulator 8-bit), X and Y index registers (8-bit), SR status register [NV-BDIZC], SP stack pointer (8-bit). Notes on common monitor display formats and register naming. Explanation of the accumulator as ALU primary register and how X and Y are used as index registers for effective addresses. Introduces the concept of effective address, loops, and table lookups.",
      "references": [
        {
          "chunk": "processor_stack_and_bytes_words",
          "topic": "stack location and byte/word formats"
        },
        {
          "chunk": "address_modes_details",
          "topic": "how X/Y influence addressing modes"
        }
      ]
    },
    {
      "start": 181,
      "end": 240,
      "name": "status_register_flags_and_behavior",
      "description": "Status register (SR/P) flags explained (N, V, -, B, D, I, Z, C). How Z and N are updated by transfers and ALU ops; Carry (C) usage as buffer/borrow and used in comparisons and shifts/rotates; arithmetic flags updated (Z, N, C, V); meaning of Overflow (V) with signed arithmetic; Decimal flag (D) for BCD mode; Interrupt Disable (I); Break flag (B) semantics when SR is pushed/pulled and distinction between software (BRK/PHP) and hardware interrupts; how B is set on push and ignored on pull. Mentions instructions that set/clear flags and conditional branches that depend on Z,N,C,V.",
      "references": [
        {
          "chunk": "pragmatics_of_comparisons_and_bit",
          "topic": "how compares set flags and how BIT manipulates flags"
        },
        {
          "chunk": "interrupts_and_vectors",
          "topic": "how interrupts interact with SR and stack"
        }
      ]
    },
    {
      "start": 241,
      "end": 300,
      "name": "processor_stack_bytes_words_and_vectors",
      "description": "Processor stack description: LIFO, top-down at $0100-$01FF; bytes and words (8-bit bytes, 16-bit words little-endian). Signed values are two's complement. System vectors and addresses: $FFFA/$FFFB NMI vector, $FFFC/$FFFD RESET vector, $FFFE/$FFFF IRQ vector (all 16-bit low-high). Start/reset sequence: 7-cycle start-up, PC read from reset vector at $FFFC then JMP. Notes on initialization and that PC is set by reset vector.",
      "references": [
        {
          "chunk": "start_reset_operations",
          "topic": "reset/start sequence details"
        },
        {
          "chunk": "jump_vectors_and_stack_operations",
          "topic": "how interrupts and JSR/RTS push/pull PC and SR"
        }
      ]
    },
    {
      "start": 301,
      "end": 360,
      "name": "start_reset_operations_and_instruction_types",
      "description": "Start/reset operations continued and an introductory categorization 'Instructions by Type': transfer instructions (LDA, LDX, LDY, STA, STX, STY, TAX, TAY, TSX, TXA, TXS, TYA), stack instructions (PHA, PHP, PLA, PLP) with stack behavior details (push decrements SP, pull increments), decrement/increment group (DEC, DEX, DEY, INC, INX, INY), arithmetic operations (ADC, SBC) and logical ops (AND, EOR, ORA). Shift & rotate behavior: ASL, LSR, ROL, ROR (carry preserves bit shifted out).",
      "references": [
        {
          "chunk": "shift_and_rotate_instructions",
          "topic": "details and opcode forms of ASL/LSR/ROL/ROR"
        },
        {
          "chunk": "arithmetic_instructions_primer",
          "topic": "ADC/SBC primer and multi-byte arithmetic"
        }
      ]
    },
    {
      "start": 361,
      "end": 420,
      "name": "flag_instructions_comparisons_and_bit_test",
      "description": "Flag instructions (CLC, CLD, CLI, CLV, SEC, SED, SEI) and comparison instructions (CMP, CPX, CPY) behavior: comparisons subtract operand from register without changing the register, setting Z, C, N appropriately; explanation of test result tables. BIT instruction explained: performs A AND M -> affects Z; transfers operand bit7 -> N and bit6 -> V without changing A. Use-cases for storing flags in memory and using BIT to test multiple bits.",
      "references": [
        {
          "chunk": "pragmatics_of_comparisons_and_bit",
          "topic": "practical examples for compare and BIT use"
        },
        {
          "chunk": "conditional_branching_and_jumps",
          "topic": "branch instructions that use these flags"
        }
      ]
    },
    {
      "start": 421,
      "end": 480,
      "name": "conditional_branching_and_interrupts",
      "description": "Conditional branch instructions overview (relative addressing, signed 8-bit offsets): BCC, BCS, BEQ, BMI, BNE, BPL, BVC, BVS. Branch behavior: 2 bytes, 2 cycles if not taken, 3 cycles if taken, +1 cycle if page crossed. Jumps & Subroutines: JMP, JSR, RTS (JSR pushes return address, RTS pulls). Interrupts: IRQ and NMI behavior (push PC and SR then vector to respective vectors), BRK behaves similar to NMI but pushes PC+2 and sets break flag on pushed SR. RTI restores SR and PC. Notes on interrupt disable flag and BRK interactions.",
      "references": [
        {
          "chunk": "jump_vectors_and_stack_operations",
          "topic": "stack operations during IRQ/NMI/BRK/RTI"
        },
        {
          "chunk": "branch_addressing_modes",
          "topic": "relative addressing details and page crossing penalties"
        }
      ]
    },
    {
      "start": 481,
      "end": 540,
      "name": "6502_address_modes_in_detail",
      "description": "Detailed coverage of 6502 address modes: implied (impl), accumulator (A), immediate (#), absolute (abs), zero-page (zpg), indexed absolute (abs,X and abs,Y) with page crossing note, zero-page indexed (zpg,X and zpg,Y), indirect (JMP (abs)), pre-indexed indirect (X,ind) aka (zeropage,X), post-indexed indirect (ind,Y) aka (zeropage),Y. Also mentions NMOS JMP indirect bug where high byte fetch wraps at page boundary, corrected in CMOS W65C02 with extra cycle. WDC 65C02 extended modes: (zpg) (zeropage indirect) and (abs,X) absolute indexed indirect for JMP.",
      "references": [
        {
          "chunk": "indirect_and_indexed_indirect_examples",
          "topic": "examples of JMP ($FF82), LDA ($70,X), LDA ($70),Y"
        },
        {
          "chunk": "w65c02_extensions_address_modes",
          "topic": "W65C02 extra modes and behavior differences"
        }
      ]
    },
    {
      "start": 541,
      "end": 600,
      "name": "addressing_mode_examples_and_notes",
      "description": "Examples and expanded notes for each address mode: immediate mode examples (LDA #$07 etc.), absolute addressing (3-byte little-endian format), zero-page benefits (faster, smaller), indexed addressing details for absolute,X/Y (page crossing penalty) and zero-page,X/Y (wraparound, no penalty), pre-indexed indirect (LDA (zeropage,X)) and post-indexed indirect (LDA (zeropage),Y) examples and timing, and relative addressing exceptions (branch range -128..+127 and cycle costs on taken branches and page crossing).",
      "references": [
        {
          "chunk": "6502_address_modes_in_detail",
          "topic": "mode summaries and NMOS quirks"
        },
        {
          "chunk": "branch_addressing_modes",
          "topic": "relative branch cycle penalties"
        }
      ]
    },
    {
      "start": 601,
      "end": 660,
      "name": "vendor_and_instruction_detail_introduction",
      "description": "Vendor credit (MOS Technology) and the beginning of '6502 Instructions in Detail' section. Starts ADC instruction detailed opcode table and flags summary (A + M + C -> A, flags N Z C I D V) with addressing forms and opcodes/cycles listing for ADC. Begin AND instruction details following ADC.",
      "references": [
        {
          "chunk": "adc_and_and_instructions",
          "topic": "ADC opcodes and AND opcodes"
        },
        {
          "chunk": "instruction_flag_legends",
          "topic": "flag legend and notes on cycle penalties"
        }
      ]
    },
    {
      "start": 661,
      "end": 720,
      "name": "adc_and_and_asl",
      "description": "Detailed instruction entries: ADC (Add with carry) opcodes by addressing mode and cycle counts; AND (logical AND with accumulator) opcodes by addressing mode; ASL (arithmetic shift left) operation semantics and opcodes for accumulator, zpg, zpg,X, absolute, absolute,X. Flags affected are listed (N Z C etc.) and cycle/byte counts provided.",
      "references": [
        {
          "chunk": "shift_and_rotate_instructions",
          "topic": "ASL relates to other shift/rotate instructions ROL/ROR/LSR"
        },
        {
          "chunk": "adc_and_and_instructions",
          "topic": "ADC/AND further usage in arithmetic/logic"
        }
      ]
    },
    {
      "start": 721,
      "end": 780,
      "name": "branches_bit_test_and_brk",
      "description": "Branch instruction opcodes and details: BCC, BCS, BEQ (opcodes, bytes, cycles). BIT instruction explanation and opcode forms (zeropage and absolute): A AND M -> affects Z and transfer of M7 to N, M6 to V. BRK behavior (software interrupt): pushes PC+2 and SR with break flag set, cycles and opcodes for BRK. Also BMI/BNE/BPL branch entries and their opcodes. Emphasis on flags and conditional branching timing.",
      "references": [
        {
          "chunk": "conditional_branching_and_interrupts",
          "topic": "how these branches interact with flags and cycles"
        },
        {
          "chunk": "bit_test_and_practical_examples",
          "topic": "BIT examples for flag-testing in practice"
        }
      ]
    },
    {
      "start": 781,
      "end": 840,
      "name": "branch_exceptions_flag_ops_and_cmp",
      "description": "Branch on overflow (BVC/BVS) details and opcodes. Flag instructions CLC, CLD, CLI, CLV descriptions with opcodes. CMP instruction (Compare accumulator with memory) opcodes and modes; CPX and CPY opcodes (compare X and Y) and their addressing modes. DEC/DEX/DEY decrement group opcodes and how they affect flags. This section covers a broad set of control/compare instructions and their operational specifics.",
      "references": [
        {
          "chunk": "pragmatics_of_comparisons_and_bit",
          "topic": "how comparisons encode relations via flags"
        },
        {
          "chunk": "status_register_and_flags",
          "topic": "impact of these instructions on SR flags"
        }
      ]
    },
    {
      "start": 841,
      "end": 900,
      "name": "bitwise_eor_inc_inx_jmp_jsr",
      "description": "EOR (exclusive OR) opcode summaries across addressing modes. INC, INX, INY instruction details with opcodes and cycles. JMP absolute and JMP indirect behavior and cycle counts (including NMOS indirect bug note). JSR (Jump to Subroutine) details including stack push sequence and timing. LDA introductory line begins at the end of this chunk.",
      "references": [
        {
          "chunk": "indirect_and_indexed_indirect_examples",
          "topic": "JMP (indirect) special-case behavior"
        },
        {
          "chunk": "literals_and_loads_ldx_ldy",
          "topic": "LDA/LDX/LDY instruction group"
        }
      ]
    },
    {
      "start": 901,
      "end": 960,
      "name": "lda_ldx_ldy_lsr_nop",
      "description": "LDA (load accumulator) opcode table (immediate, zpg, zpg,X, abs, abs,X/Y, (indirect,X), (indirect),Y). LDX and LDY instruction tables and addressing modes. LSR (logical shift right) details for accumulator and memory forms and opcodes. NOP instruction brief with opcode EA. ORA (logical OR with accumulator) entry begins at end of chunk.",
      "references": [
        {
          "chunk": "shift_and_rotate_instructions",
          "topic": "LSR and relation to ASL/ROL/ROR"
        },
        {
          "chunk": "load_store_transfer_instructions",
          "topic": "LDA/LDX/LDY usage patterns"
        }
      ]
    },
    {
      "start": 961,
      "end": 1020,
      "name": "logical_or_and_stack_instructions",
      "description": "ORA (inclusive OR) opcodes across addressing modes. Stack instructions PHA, PHP (push SR has break bit set and bit 5 set to 1), PLA, PLP behaviors (PLP ignores break flag and bit 5). Opcodes and cycle counts for PHA/PHP/PLA/PLP and notes about SR/pushed values. ROL instruction details (rotate left) opcodes and cycle counts begin at end of chunk.",
      "references": [
        {
          "chunk": "pha_php_pla_plp_examples",
          "topic": "example usage patterns for pushing/pulling registers"
        },
        {
          "chunk": "rol_ror_rotate_instructions",
          "topic": "ROL and ROR relation and opcodes"
        }
      ]
    },
    {
      "start": 1021,
      "end": 1080,
      "name": "rol_ror_rti_rts_sbc_sec_sed_sei",
      "description": "ROL (rotate left) and ROR (rotate right) detailed opcodes for accumulator and memory forms. RTI (return from interrupt) and RTS (return from subroutine) semantics and opcodes. SBC (subtract with borrow) opcode table and flags behavior (A - M - C̅ -> A). Flag set instructions SEC, SED, SEI opcodes and semantics. Notes on cycles and a footnote indicating page crossing cycle additions.",
      "references": [
        {
          "chunk": "pragmatics_of_comparisons_and_bit",
          "topic": "how SBC/ADC affect flags and multi-byte arithmetic"
        },
        {
          "chunk": "interrupts_and_vectors",
          "topic": "RTI and interrupt return sequence"
        }
      ]
    },
    {
      "start": 1081,
      "end": 1140,
      "name": "store_instructions_stx_sty_transfers_and_notes",
      "description": "Store instructions STA, STX, STY opcode tables (zeropage, zpg,X/Y, absolute, absolute,X/Y, (indirect,X), (indirect),Y). Transfer instructions TAX, TAY, TSX, TXA, TXS, TYA details (operations, flags, opcodes). Notes and footnotes about page boundary cycle penalties and branch penalties; legend for flags (+ modified, - not modified) and assembler syntax notes (forced zeropage), and a note on NMOS read-modify-write behavior causing two writes (NMOS only) which can affect devices on the bus.",
      "references": [
        {
          "chunk": "note_on_read_modify_write",
          "topic": "NMOS read-modify-write double write caveat"
        },
        {
          "chunk": "w65c02_and_implementation_specifics",
          "topic": "CMOS vs NMOS differences and WDC enhancements"
        }
      ]
    },
    {
      "start": 1141,
      "end": 1200,
      "name": "implementation_specifics_and_illegal_opcodes_intro",
      "description": "Implementation-specific notes: NMOS vs CMOS; introduction to undocumented/illegal opcodes (NMOS) caution; list of common undocumented mnemonics and synonyms as used by ACME/DASM (ALR/ASR, ANC, ANE/XAA, ARR, DCP/DCM, ISC/ISB/INS, LAS/LAR, LAX, LXA, RLA, RRA, SAX/AXS/AAX, SBX/AXS/SAX, SHA/AHX/AXA, SHX, SHY, SLO, SRE (LSE), TAS, USBC, NOP variants, JAM/KIL/HLT). Warning that these apply to NMOS only; CMOS either uses these opcodes for extensions or treats them as NOP.",
      "references": [
        {
          "chunk": "illegal_opcodes_in_detail",
          "topic": "detailed descriptions of many undocumented opcodes"
        },
        {
          "chunk": "revA_ror_bug",
          "topic": "Rev A hardware quirk affecting ROR"
        }
      ]
    },
    {
      "start": 1201,
      "end": 1260,
      "name": "illegal_opcodes_in_detail_part1",
      "description": "Beginning of detailed undocumented opcode descriptions: ALR (ASR) AND+LSR, ANC (AND + set C as ASL), ANC2 variant, ANE (XAA) unstable note and 'magic constant' behavior, ARR (AND + ROR) behavior with V and carry notes. Includes opcode bytes and immediate forms where applicable, and instability markers.",
      "references": [
        {
          "chunk": "illegal_opcodes_in_detail_part2",
          "topic": "continued illegal opcode descriptions (DCP, ISC, etc.)"
        }
      ]
    },
    {
      "start": 1261,
      "end": 1320,
      "name": "illegal_opcodes_in_detail_part2",
      "description": "Continuation of undocumented ops: DCP (decrement memory + CMP), ISC/ISB/INS (INC + SBC), LAS/LAR (LDA/TSX combined), LAX (LDA + LDX combined), LXA immediate (highly unstable), RLA (ROL + AND), RRA (ROR + ADC), SAX (A AND X -> M), SBX (AXS) immediate, SHA/SHX/SHY store-with-high-byte-plus-one behavior and instability notes. Opcode tables included for various addressing modes.",
      "references": [
        {
          "chunk": "illegal_opcodes_in_detail_part3",
          "topic": "remaining undocumented opcodes including SLO/SRE/TAS/USBC/NOPs/JAM"
        }
      ]
    },
    {
      "start": 1321,
      "end": 1380,
      "name": "illegal_opcodes_in_detail_part3",
      "description": "Further undocumented instructions: SLO (ASL then ORA), SRE (LSR then EOR), TAS (puts A AND X into SP and stores A AND X AND (H+1) in memory) and USBC (SBC variant), many NOP variants (various opcodes acting as NOP in different addressing modes and byte sizes), and JAM (KIL/HLT) description (freezes CPU requiring reset) with listing of JAM opcodes. Discussion on how illegal opcodes can be understood as combinations of c=1 and c=2 threads (bit patterns) producing combined behavior.",
      "references": [
        {
          "chunk": "illegal_opcode_timing_and_layout",
          "topic": "how instruction table binary layout explains illegals and JAM behavior"
        }
      ]
    },
    {
      "start": 1381,
      "end": 1440,
      "name": "revA_ror_bug_and_wdc_extensions_intro",
      "description": "Rev. A 6502 'ROR bug' historical note: Rev A chips (Sep 1975–Jun 1976) lacked ROR implementation (not wired) resulting in an ASL-like behavior without carry update, and ROR being undocumented/illegal on Rev A. Introduction to WDC W65C02(S) extensions: CMOS static design, 69 instructions, 16 address modes, new address modes (zeropage indirect ($LL), absolute indexed indirect ($LLHH,X)), and behavioral changes. Mentions G65SC02 similarity but without bit-manipulation instructions.",
      "references": [
        {
          "chunk": "w65c02_additional_address_modes_and_instructions",
          "topic": "W65C02 instruction additions and address mode differences"
        }
      ]
    },
    {
      "start": 1441,
      "end": 1500,
      "name": "w65c02_additional_address_modes_and_opcodes",
      "description": "W65C02 additional address modes and instructions: (zeropage) indirect addressing for accumulator instructions and (absolute,X) for JMP; modified opcode lists for ADC, AND, BIT, CMP, DEC, EOR, INC, JMP (absolute,X) with cycles and opcodes for (zeropage) ind, BIT immediate, etc. Notes that 2004 datasheet had an erroneous cycle count for JMP (oper,X). Also lists additional LDA/ORA/SBC/STA forms for (zeropage) indirect.",
      "references": [
        {
          "chunk": "w65c02_additional_instructions_bit_manipulation",
          "topic": "W65C02 bit-manipulating instructions like BBR/BBS/RMB/SMB"
        }
      ]
    },
    {
      "start": 1501,
      "end": 1560,
      "name": "w65c02_additional_instructions_bit_manipulation",
      "description": "W65C02 added instructions: BBR (Branch on Bit Reset family BBR0..BBR7), BBS (Branch on Bit Set), BRA (Branch Always), PHX/PHY/PLX/PLY (push/pull X and Y registers), RMB (Reset Memory Bit family RMB0..RMB7), SMB (Set Memory Bit family SMB0..SMB7) with opcodes and cycles. STP (Stop mode), STZ (Store Zero) in various modes, TRB (Test and Reset Bits) and TSB (Test and Set Bits) semantics and opcodes. WAI and STP low-power/wait instructions. Notes about G65SC02 omissions and early W65C02 differences.",
      "references": [
        {
          "chunk": "w65c02_nops_and_behavioral_changes",
          "topic": "W65C02 NOP variants, cycle changes, and behavioral differences vs NMOS"
        }
      ]
    },
    {
      "start": 1561,
      "end": 1620,
      "name": "w65c02_nops_and_behavioral_changes",
      "description": "Additional W65C02 NOP opcodes (various sizes/cycles) listed numerically and by opcode values. Modified cycle times and penalties: BCD arithmetic cycle penalty for ADC/SBC (extra cycle in decimal mode), read-modify-write behaviors changed (no initial writeback; dummy read instead) and absolute-indexed RMW instructions may be faster if no page crossing. Indirect JMP page-boundary behavior fixed but adds cycle on boundary. Behavioral changes summary: decimal flag cleared on reset/interrupt, no undefined opcodes (reserved opcodes execute as NOPs), correct N/V/Z flags for decimal math, indexed addressing page behavior changes, read-modify-write timing changes, BRK timing changes, and RDY pin bidirectional WAI behavior.",
      "references": [
        {
          "chunk": "w65c02_additional_instructions_bit_manipulation",
          "topic": "bit-manipulation instruction set and opcodes"
        },
        {
          "chunk": "implementation_specifics_and_illegal_opcodes_intro",
          "topic": "differences between NMOS undocumented opcodes and WDC behavior"
        }
      ]
    },
    {
      "start": 1621,
      "end": 1680,
      "name": "rockwell_r6500_family_extensions",
      "description": "Rockwell R6500 family (R6500/11/12/15) additions: bit-manipulation instructions (BBR/BBS/RMB/SMB) similar to WDC; additional interrupts, registers, and I/O control registers accessed via reserved addresses (not impacting base instruction set). Lists Rockwell-specific BBR/BBS/RMB/SMB opcode tables (same format as W65C02), with notes on operand types and cycle counts.",
      "references": [
        {
          "chunk": "w65c02_additional_instructions_bit_manipulation",
          "topic": "these instructions are the same on Rockwell and WDC processors"
        }
      ]
    },
    {
      "start": 1681,
      "end": 1740,
      "name": "pragmatics_of_comparisons_and_the_bit_instruction",
      "description": "Practical discussion of compare instructions (CMP, CPX, CPY): how flags Z, C, N map to register <, =, > operand relations and using carry as >= test; BIT instruction deep dive: performs A AND M -> Z, transfers M7 -> N and M6 -> V, allowing tests of specific bits without modifying A; examples from MS/Commodore BASIC demonstrating BIT in flag setting and checking sequences (using ROR, BIT, BVS/BMI, BCS) for complex control flows.",
      "references": [
        {
          "chunk": "a_primer_of_6502_arithmetic_operations",
          "topic": "how ADC/SBC use carry and set flags in multi-byte arithmetic"
        }
      ]
    },
    {
      "start": 1741,
      "end": 1800,
      "name": "a_primer_of_6502_arithmetic_operations",
      "description": "Overview of ADC (add with carry) and SBC (subtract with carry), the role of the carry flag for multi-byte arithmetic, and preparation steps (CLC before ADC, SEC before SBC). Example sequences for multi-byte (16-bit) addition and subtraction (load low byte, ADC/SBC low, store; then high byte chain). Note on CLD to force binary mode. Explanation of two's complement representation for signed values, how to form negatives (invert+1) and ranges of signed bytes (-128..+127), plus examples of signed arithmetic and how overflow and carry differ conceptually.",
      "references": [
        {
          "chunk": "decimal_mode_bcd",
          "topic": "BCD mode behavior for ADC/SBC and differences on W65C02"
        },
        {
          "chunk": "flags_with_adc_and_sbc",
          "topic": "how N, V, Z, C flags are affected by ADC/SBC"
        }
      ]
    },
    {
      "start": 1801,
      "end": 1860,
      "name": "two_s_complement_and_signed_arithmetic_examples",
      "description": "Two's complement examples and signed arithmetic breakdown: examples showing how to compute -4 via bitwise complement plus 1, signed value ranges, multi-byte signed values examples (-512, -516), and demonstration of binary addition combining signed and unsigned. Explanation of SBC as adding the operand's one's complement plus carry and how carry acts as borrow indicator. Emphasis on flag behavior during arithmetic.",
      "references": [
        {
          "chunk": "a_primer_of_6502_arithmetic_operations",
          "topic": "multi-byte addition/subtraction examples and carry/borrow semantics"
        }
      ]
    },
    {
      "start": 1861,
      "end": 1920,
      "name": "flags_with_adc_sbc_and_decimal_mode_intro",
      "description": "Which flags ADC and SBC set/clear: zero (Z), negative (N), overflow (V), carry (C). Explanation of overflow flag as signed overflow indicator (when operands same sign but result sign differs). Example showing overflow when adding $40 + $40 -> $80 and how flags NV change. Transition into Decimal Mode (BCD): 6502 supports BCD where each nibble is a decimal digit 0..9. Decimal flag (D) controls BCD; affects ADC and SBC only, not INC/DEC. WDC/65C02 differences noted later.",
      "references": [
        {
          "chunk": "decimal_mode_bcd",
          "topic": "full BCD examples and flag semantics"
        }
      ]
    },
    {
      "start": 1921,
      "end": 1980,
      "name": "decimal_mode_bcd_and_examples",
      "description": "Decimal (BCD) examples: how bytes represent decimal pairs ($14 = 14, $98 = 98). Examples showing ADC under BCD: SED/CLC/LDA/ADC sequences, and that decimal mode is unsigned; example of SBC in decimal yields expected BCD behavior. Notes that carry and zero flags operate as usual, negative flag is set but less meaningful, overflow flag meaningless in decimal. Multi-byte BCD arithmetic chaining and WDC note that 65C02 clears decimal flag on interrupts.",
      "references": [
        {
          "chunk": "a_primer_of_6502_arithmetic_operations",
          "topic": "binary arithmetic primer and multi-byte chaining"
        },
        {
          "chunk": "w65c02_nops_and_behavioral_changes",
          "topic": "W65C02 clears decimal flag on interrupts"
        }
      ]
    },
    {
      "start": 1981,
      "end": 2040,
      "name": "6502_jump_vectors_stack_operations_and_diagrams",
      "description": "Detailed explanation of jump vectors and stack operations: stack layout at $0100-$01FF, NMI/RES/IRQ vectors at $FFFA..$FFFF, and the sequence for handling interrupts (complete current instruction, push PC hi/lo and SR, jump to vector). ASCII-style diagrams showing stack memory layout before/after IRQ/NMI and JSR/RTS examples and how PC and SR are stored. Notes on subtle interrupt timing (branches and extra cycles) and NMOS peculiarities where NMI occurring at BRK may hijack BRK vector. W65C02 clears D flag on interrupts.",
      "references": [
        {
          "chunk": "interrupts_and_vectors",
          "topic": "interrupt vector addresses and hardware semantics"
        },
        {
          "chunk": "break_flag_and_stack_examples",
          "topic": "how break flag behaves in PHP/PLP and BRK/RTI sequences"
        }
      ]
    },
    {
      "start": 2041,
      "end": 2100,
      "name": "break_flag_and_stack_examples_and_instruction_layout_intro",
      "description": "Break flag semantics and examples: how break flag appears only on the stack (set on BRK/PHP pushes, cleared on hardware interrupt pushes), bit 5 set on pushes, ignored when pulled (PLP/RTI). Several examples of PHP/PLP and PHA/PLP/RTI sequences showing resulting SR values and PC example. Note about some emulators showing SR with bits 4 and 5 set virtually. Transition into instruction layout explanation: bit-vector abc (aaabbbcc) mapping for opcode encoding (a,b,c fields), and relationship of rows/columns in opcode table.",
      "references": [
        {
          "chunk": "6502_instruction_layout_and_tables",
          "topic": "how opcode bits map to instruction classes and addressing modes"
        }
      ]
    },
    {
      "start": 2101,
      "end": 2160,
      "name": "instruction_layout_and_opcode_table_views",
      "description": "Details on instruction table layout and mapping bits to groups: explanation of a-b-c (aaabbbcc) mapping to opcode binary, examples (ROR row mapping), and several tabular views showing the opcode map grouped by c then a then b. Table highlights where operations and addressing modes are placed. Notes about empty columns when c=3 and layout exceptions where c=0,2 and b selects groups (branch, set flag).",
      "references": [
        {
          "chunk": "illegal_opcodes_revisited",
          "topic": "how illegal opcodes map into the table and why they arise"
        }
      ]
    },
    {
      "start": 2161,
      "end": 2220,
      "name": "illegal_opcodes_revisited_and_table_views",
      "description": "Revisits illegal opcodes with several rotated table views showing undefined/illegal opcode patterns. Shows how many illegal opcodes are effectively combinations of other instructions (c=3 combining c=1 and c=2 threads), and lists specific illegal opcodes positioned in the opcode table (NOP variations, JAM, SLO, RLA, SRE, RRA, SAX, LAX, DCP, ISC, etc.). Discusses unstable and highly unstable cases (ANE, LXA) and mapping of addressing mode from c=1 entries.",
      "references": [
        {
          "chunk": "illegal_opcode_mechanism_and_race_conditions",
          "topic": "why c=3 results in combined or undefined behaviors including race conditions"
        }
      ]
    },
    {
      "start": 2221,
      "end": 2280,
      "name": "illegal_opcode_mechanism_and_race_conditions",
      "description": "Detailed analysis of how undocumented opcodes arise from executing two instruction micro-threads (c=1 and c=2) concurrently when opcode low bits = 3, leading to combined operations whose outputs are AND-ed on internal data lines. Explains JAM (timing failure), NOPs (non-sensical mode combos), and unstable instructions where contention leads to 'magic constant' behavior depending on chip series/temperature. Specific opcode mappings and examples given (ANE $8B, LXA $AB, TAS $9B and SHA/SHX/SHY 'H+1' behaviors). Concludes illegals are undefined input behavior.",
      "references": [
        {
          "chunk": "revA_ror_bug",
          "topic": "example of implementation-specific missing instruction (Rev A ROR)"
        },
        {
          "chunk": "w65c02_extensions_address_modes",
          "topic": "how WDC treats previously illegal opcodes/extends instruction set"
        }
      ]
    },
    {
      "start": 2281,
      "end": 2340,
      "name": "revA_ror_bug",
      "description": "Rev. A 6502 'ROR bug' detailed: chips made before June 1976 lacked control lines for ROR; ROR behaves like ASL without updating carry; N and Z flags set correctly. Provides opcode/opcycle table for ROR on Rev A and historical note about implementation change in Rev B (reportedly due to user demand).",
      "references": [
        {
          "chunk": "illegal_opcodes_mechanism_and_race_conditions",
          "topic": "context on hardware-specific undocumented behaviors"
        }
      ]
    },
    {
      "start": 2341,
      "end": 2400,
      "name": "pinouts_and_physical_signals",
      "description": "Pinout summaries for various 6502 family variants: NMOS 6502 signals (VCC, VSS, Φ0..2, A0..A15, D0..D7, R/W, RDY, S.O., SYNC, IRQ, NMI, RES, N.C.). WDC 65C02S (40-pin PDIP) pinout including VDD, VSS, Φ1..2, BE, RDY (bidirectional), S.O. (active low), SYNC, VBP (vector pull), and N.C. SALLY 6502C (Atari) notes (no SYNC). References to datasheets and manuals (MCS6502 manual and W65C02S datasheet).",
      "references": [
        {
          "chunk": "65xx_family_overview",
          "topic": "list of 65xx family variants and features"
        }
      ]
    },
    {
      "start": 2401,
      "end": 2460,
      "name": "65xx_family_overview",
      "description": "Overview of 65xx family variants and features: 6502, 6502A, 6502C, 65C02, 6503/5/6 (12-bit address), 6504 (13-bit no NMI), 6507 (13-bit no interrupts), 6509 (20-bit via bankswitch), 6510 (6502 + 6-bit I/O port), 6511 (microcontroller with I/O/serial/RAM - Rockwell), 65F11, 7501, 8500/8502, 65816 (16-bit regs/ALU 24-bit address bus), 65802. Also includes notes about WDC's ongoing support and references to virtual tools.",
      "references": [
        {
          "chunk": "pinouts_and_physical_signals",
          "topic": "physical interface differences across variants"
        },
        {
          "chunk": "external_links_and_tools",
          "topic": "emulators, assemblers, disassemblers and community resources"
        }
      ]
    },
    {
      "start": 2461,
      "end": 2520,
      "name": "site_notes_disclaimer_and_tools",
      "description": "Site notes and disclaimer: mentions a near-text overview link, states information provided 'AS IS' without warranty, and references the 'Virtual 6502' tools - Virtual 6502 emulator, 6502 Assembler, and 6502 Disassembler. Encourages use with caution and acknowledges possible errors.",
      "references": [
        {
          "chunk": "external_links_and_tools",
          "topic": "external resources like 6502.org and visual6502.org"
        }
      ]
    },
    {
      "start": 2521,
      "end": 2580,
      "name": "external_links_and_tools",
      "description": "External links and references: Virtual 6502 tools, 6502.org, visual6502.org transistor-level simulation, Western Design Center Inc. site (WDC), and credits 'mass:werk'. Also file path of original HTML source. Mentions presented by mass:werk and provides further reading suggestions for in-depth study.",
      "references": [
        {
          "chunk": "site_notes_disclaimer_and_tools",
          "topic": "local site notes and virtual tools references"
        },
        {
          "chunk": "pinouts_and_physical_signals",
          "topic": "datasheets referenced for pinouts"
        }
      ]
    },
    {
      "start": 2581,
      "end": 2643,
      "name": "document_footer_and_metadata",
      "description": "Final file footer including file path, page count note, reproduction credits, and closing of the document. Contains last content lines referencing the source file location and page numbering (file:///home/mark/Documents/6502 Instruction Set.html 73/73).",
      "references": [
        {
          "chunk": "external_links_and_tools",
          "topic": "where to find tools and further reading"
        }
      ]
    }
  ],
  "source_md5": "0e1050a5f686796f55d362ceb1994410"
}
