{
  "source_file": "6502 instructions.txt",
  "context": "6502 Instruction Set",
  "splits": [
    {
      "start": 1,
      "end": 5,
      "ignore": true,
      "reason": "Title, TOC, and tool links"
    },
    {
      "start": 6,
      "end": 30,
      "name": "opcode_matrix_overview",
      "description": "Hex opcode matrix overview of the standard NMOS 6502 instruction set, showing opcodes arranged by high/low nibble with mnemonics and addressing modes; includes a 'View' note for standard vs illegal/WDC sets.",
      "references": [
        {
          "chunk": "instruction_layout_and_opcode_tables",
          "topic": "Formal opcode layout patterns (aaabbbcc) and full tables"
        },
        {
          "chunk": "instruction_reference_part1_adc_to_eor",
          "topic": "Detailed semantics and timings for listed opcodes A0–5F range subset"
        },
        {
          "chunk": "instruction_reference_part2_inc_to_tya_and_timing_notes",
          "topic": "Detailed semantics and timings for remainder of matrix"
        }
      ]
    },
    {
      "start": 31,
      "end": 60,
      "name": "addressing_modes_quick_reference",
      "description": "Concise definitions of 6502 addressing modes: A (accumulator), abs ($LLHH), abs,X, abs,Y, immediate (#$BB), implied, indirect (JMP ($LLHH)), X,ind (pre-indexed), ind,Y (post-indexed), relative ($BB), zpg ($LL), zpg,X, zpg,Y. Footnotes: little-endian word layout; page boundary carry rules (extra cycle on boundary cross); branch offsets are signed 8-bit and may cross pages (extra cycle). WDC 65C02 extended modes listed: (zpg) indirect and (abs,X) absolute indexed indirect for JMP.",
      "references": [
        {
          "chunk": "addressing_modes_in_detail",
          "topic": "Step-by-step explanations and examples for each mode"
        },
        {
          "chunk": "instruction_reference_part1_adc_to_eor",
          "topic": "Which instructions support which modes and cycle costs"
        },
        {
          "chunk": "wdc_65c02_extensions_address_modes_instructions_behavior",
          "topic": "Extended addressing modes behavior on 65C02"
        }
      ]
    },
    {
      "start": 61,
      "end": 118,
      "name": "instructions_by_name_list",
      "description": "Alphabetical list of 6502 instructions with brief purpose: ADC, AND, ASL, BCC, BCS, BEQ, BIT, BMI, BNE, BPL, BRK, BVC, BVS, CLC, CLD, CLI, CLV, CMP, CPX, CPY, DEC, DEX, DEY, EOR, INC, INX, INY, JMP, JSR, LDA, LDX, LDY, LSR, NOP, ORA, PHA, PHP, PLA, PLP, ROL, ROR, RTI, RTS, SBC, SEC, SED, SEI, STA, STX, STY, TAX, TAY, TSX, TXA, TXS, TYA.",
      "references": [
        {
          "chunk": "instruction_types_overview",
          "topic": "Grouped by functional categories"
        },
        {
          "chunk": "instruction_reference_part1_adc_to_eor",
          "topic": "Detailed per-instruction effects, flags, opcodes, cycles (first half)"
        },
        {
          "chunk": "instruction_reference_part2_inc_to_tya_and_timing_notes",
          "topic": "Detailed per-instruction effects, flags, opcodes, cycles (second half)"
        }
      ]
    },
    {
      "start": 119,
      "end": 235,
      "name": "registers_and_status_flags",
      "description": "6502 CPU registers and functions: PC (16-bit), A/AC (8-bit accumulator), X (8-bit), Y (8-bit), SR/P (NV-BDIZC flags), SP/S (8-bit stack pointer for page $0100–$01FF). Detailed roles of A, X, Y, PC, SP; explanation of SR flags: N, V, B (pseudo), D, I, Z, C; when Z and N update; C as carry/borrow buffer; V overflow semantics for signed arithmetic; D for BCD mode; I masking IRQ; B flag behavior on stack (set when pushed by BRK/PHP, cleared/ignored on PLP/RTI), and not a real register bit.",
      "references": [
        {
          "chunk": "arithmetic_primer_adc_sbc_and_bcd_mode",
          "topic": "How flags (N, Z, V, C) behave in arithmetic, signed/BCD"
        },
        {
          "chunk": "interrupts_jump_vectors_and_stack_operations",
          "topic": "How SR and PC are pushed/pulled during IRQ/NMI/BRK/RTI and JSR/RTS"
        }
      ]
    },
    {
      "start": 236,
      "end": 258,
      "name": "memory_stack_vectors_reset",
      "description": "Memory model and reset: Processor stack is LIFO on page $0100–$01FF (8-bit SP wraps). Data sizes: 8-bit bytes, 16-bit words (little-endian); signed values two's complement; BCD arithmetic supported. System vectors: $FFFA/$FFFB NMI, $FFFC/$FFFD Reset, $FFFE/$FFFF IRQ. Reset sequence: 7 cycles, then PC fetched from $FFFC/$FFFD and JMP to start address; other init left to code.",
      "references": [
        {
          "chunk": "interrupts_jump_vectors_and_stack_operations",
          "topic": "Operational details for interrupts and JSR/RTS with diagrams"
        }
      ]
    },
    {
      "start": 259,
      "end": 404,
      "name": "instruction_types_overview",
      "description": "Instructions grouped by function with brief notes: Transfer (LDA/LDX/LDY/STA/STX/STY/TAX/TAY/TSX/TXA/TXS/TYA); Stack (PHA/PHP/PLA/PLP) and stack mechanics; Inc/Dec (DEC/DEX/DEY/INC/INX/INY); Arithmetic (ADC, SBC; refer to primer); Logical (AND/EOR/ORA); Shift/Rotate (ASL/LSR/ROL/ROR; carry receives shifted-out bit); Flag ops (CLC/CLD/CLI/CLV/SEC/SED/SEI); Comparisons (CMP/CPX/CPY) with flag table; BIT semantics; Conditional branches (BCC/BCS/BEQ/BMI/BNE/BPL/BVC/BVS) using relative offsets; Jumps/Subroutines (JMP/JSR/RTS) and stack effects; Interrupts (IRQ/NMI/BRK/RTI) and vectors; NOP.",
      "references": [
        {
          "chunk": "addressing_modes_in_detail",
          "topic": "All addressing forms used by these operations"
        },
        {
          "chunk": "instruction_reference_part1_adc_to_eor",
          "topic": "Detailed opcodes and cycles"
        },
        {
          "chunk": "instruction_reference_part2_inc_to_tya_and_timing_notes",
          "topic": "Detailed opcodes and cycles"
        }
      ]
    },
    {
      "start": 405,
      "end": 656,
      "name": "addressing_modes_in_detail",
      "description": "In-depth explanations with examples/diagrams: Implied (including A accumulator special case), Immediate (#), Absolute ($HHLL) and uses in JMP/JSR; Zero-Page ($00LL) benefits and behavior; Indexed Absolute,X and Absolute,Y with page-crossing cycle penalty; Indexed Zero-Page,X and Zero-Page,Y (no page-crossing penalty, wrap within zero-page); Indirect JMP ($HHLL) including NMOS page-boundary wrap bug vs CMOS fix (extra cycle); Pre-indexed indirect (zpg,X) and use cases (pointer tables in zero-page); Post-indexed indirect (zpg),Y with potential page-crossing penalty; Relative branching details, signed offsets, cycle timing, examples.",
      "references": [
        {
          "chunk": "addressing_modes_quick_reference",
          "topic": "Condensed summary with footnotes"
        },
        {
          "chunk": "instruction_layout_and_opcode_tables",
          "topic": "How addressing modes map to opcode columns"
        },
        {
          "chunk": "instruction_reference_part1_adc_to_eor",
          "topic": "Which mnemonics support which modes and timing"
        },
        {
          "chunk": "instruction_reference_part2_inc_to_tya_and_timing_notes",
          "topic": "Which mnemonics support which modes and timing"
        }
      ]
    },
    {
      "start": 657,
      "end": 659,
      "ignore": true,
      "reason": "Vendor attribution and image note"
    },
    {
      "start": 660,
      "end": 840,
      "name": "instruction_reference_part1_adc_to_eor",
      "description": "Formal reference for instructions ADC, AND, ASL, BCC, BCS, BEQ, BIT (with explanatory note), BMI, BNE, BPL, BRK (software interrupt behavior and stack), BVC, BVS, CLC, CLD, CLI, CLV, CMP, CPX, CPY, DEC, DEX, DEY, EOR. For each: operation semantics, affected flags (N Z C I D V legend), addressing modes, opcodes, bytes, cycles, and page-cross/branch timing notes where applicable.",
      "references": [
        {
          "chunk": "instruction_reference_part2_inc_to_tya_and_timing_notes",
          "topic": "Remainder of instruction set, timing footnotes"
        },
        {
          "chunk": "arithmetic_primer_adc_sbc_and_bcd_mode",
          "topic": "Deeper explanation for ADC/SBC flags and BCD"
        },
        {
          "chunk": "addressing_modes_in_detail",
          "topic": "Addressing behaviors referenced in timing notes"
        }
      ]
    },
    {
      "start": 841,
      "end": 1083,
      "name": "instruction_reference_part2_inc_to_tya_and_timing_notes",
      "description": "Formal reference for instructions: INC, INX, INY, JMP (abs/indirect and NMOS page-boundary note), JSR, LDA, LDX, LDY, LSR, NOP, ORA, PHA, PHP (B flag/bit 5 set on push), PLA, PLP (B flag/bit 5 ignored on pull), ROL, ROR, RTI, RTS, SBC, SEC, SED, SEI, STA, STX, STY, TAX, TAY, TSX, TXA, TXS, TYA. Includes timing footnotes: page boundary add 1 cycle; branch timing (+1 same page, +2 cross page); NMOS indirect JMP high-byte fetch quirk and CMOS extra cycle.",
      "references": [
        {
          "chunk": "assembler_syntax_and_nmos_rmw_behavior",
          "topic": "Assembler zeropage forcing and NMOS read-modify-write quirk"
        },
        {
          "chunk": "addressing_modes_in_detail",
          "topic": "Indirect addressing detail and timing behavior"
        }
      ]
    },
    {
      "start": 1084,
      "end": 1098,
      "name": "assembler_syntax_and_nmos_rmw_behavior",
      "description": "Notes: Assembler syntax for forced zeropage (e.g., 'OPC *oper' or '.b'). NMOS 6502 read-modify-write behavior: some R-M-W ops (ASL, ROL, DEC, INC, etc.) perform an immediate write-back of the unmodified value before writing the modified value (double write strobe); can affect memory-mapped I/O. CMOS 65C02 does not exhibit this; uses dummy read instead.",
      "references": [
        {
          "chunk": "instruction_reference_part2_inc_to_tya_and_timing_notes",
          "topic": "RMW instructions timing/behavior context"
        },
        {
          "chunk": "wdc_65c02_extensions_address_modes_instructions_behavior",
          "topic": "CMOS behavioral changes for RMW and timing"
        }
      ]
    },
    {
      "start": 1099,
      "end": 1421,
      "name": "illegal_opcodes_overview_and_details_nmos",
      "description": "Implementation-specific notes and comprehensive catalog of undocumented NMOS 6502 opcodes: stability cautions; list and detailed behavior for ALR/ASR, ANC (two forms), ANE/XAA (highly unstable with 'magic constant'), ARR (adder involvement, V flag), DCP, ISC, LAS, LAX and LXA (immediate, unstable), RLA, RRA, SAX, SBX, SHA/AHX/AXA (unstable address high+1 behavior), SHX, SHY (unstable), SLO, SRE, TAS/XAS/SHS (unstable), USBC (SBC alias), numerous NOPs (DOP/TOP across modes), and JAM/KIL/HLT (CPU lockup). Includes cycle counts, addressing modes, and notes on instability markers (†, ††). Explains how many 'illegals' arise from concurrent execution of paired instructions per opcode slot.",
      "references": [
        {
          "chunk": "illegal_opcodes_revisited_decoding_patterns",
          "topic": "Matrix mapping of illegals into opcode layout and inheritance from legal rows"
        },
        {
          "chunk": "rev_a_ror_bug_behavior",
          "topic": "Special early 6502 ROR anomaly"
        }
      ]
    },
    {
      "start": 1422,
      "end": 1447,
      "name": "rev_a_ror_bug_behavior",
      "description": "Rev. A 6502 (pre–June 1976) 'ROR bug': ROR not implemented; behaves like ASL without affecting carry. Provides flag effects and opcode forms for ROR with ASL-like action.",
      "references": [
        {
          "chunk": "illegal_opcodes_overview_and_details_nmos",
          "topic": "Context of undocumented behaviors on NMOS chips"
        },
        {
          "chunk": "instruction_reference_part2_inc_to_tya_and_timing_notes",
          "topic": "Canonical ROR definition for later revisions"
        }
      ]
    },
    {
      "start": 1448,
      "end": 1776,
      "name": "wdc_65c02_extensions_address_modes_instructions_behavior",
      "description": "WDC W65C02(S) CMOS extensions: 16 address modes including new (zpg) indirect and JMP (abs,X); added addressing for ADC/AND/BIT/CMP/EOR/LDA/ORA/SBC/STA via (zpg) and JMP (abs,X). New instructions: BBR/BBS (bit test + branch families for bits 0–7), BRA (relative always), PHX/PHY, PLX/PLY, RMB/SMB (bit clear/set in zpg), STP (stop), STZ (store zero; zpg/zpg,X/abs/abs,X), TRB/TSB (test and reset/set memory bits with Z set by AND), WAI (wait for IRQ/NMI). Additional NOPs reserved for future use (list by opcode and cycles). Modified timing/behavior: extra cycle for BCD ADC/SBC with correct flags; RMW abs-indexed one cycle less if no page cross; indirect JMP page-boundary fixed (extra cycle); D flag cleared on reset/interrupt; RDY now bidirectional via WAI.",
      "references": [
        {
          "chunk": "addressing_modes_quick_reference",
          "topic": "Mention of extended modes"
        },
        {
          "chunk": "assembler_syntax_and_nmos_rmw_behavior",
          "topic": "Contrast of NMOS vs CMOS RMW and timing changes"
        },
        {
          "chunk": "rockwell_r6500_bit_manipulation_extensions",
          "topic": "Bit-manipulation instruction lineage (BBR/BBS/RMB/SMB)"
        }
      ]
    },
    {
      "start": 1777,
      "end": 1867,
      "name": "rockwell_r6500_bit_manipulation_extensions",
      "description": "Rockwell R6500/11/12/15 extensions: additional interrupts/ports (not instruction-set impacting) and added bit manipulation instructions: BBR (branch on bit reset), BBS (branch on bit set), RMB (reset memory bit), SMB (set memory bit), with opcodes, addressing, and cycles; later included in WDC 65C02S.",
      "references": [
        {
          "chunk": "wdc_65c02_extensions_address_modes_instructions_behavior",
          "topic": "Presence of these bit operations on 65C02S and behavior"
        }
      ]
    },
    {
      "start": 1868,
      "end": 1941,
      "name": "comparisons_and_bit_pragmatics",
      "description": "Pragmatics of comparisons and BIT: CMP/CPX/CPY semantics set Z, C, N as if subtraction without storing result; truth tables and using C for ≥ via BCS. BIT instruction explained as non-destructive AND test that sets Z from A AND M, and transfers operand bits 7→N and 6→V; examples showing flag-setting idioms using ROR and BIT/BVS/BMI for flag latching.",
      "references": [
        {
          "chunk": "instruction_reference_part1_adc_to_eor",
          "topic": "Formal definitions for CMP/CPX/CPY and BIT"
        },
        {
          "chunk": "arithmetic_primer_adc_sbc_and_bcd_mode",
          "topic": "Why subtraction and carry behave as described"
        }
      ]
    },
    {
      "start": 1942,
      "end": 2107,
      "name": "arithmetic_primer_adc_sbc_and_bcd_mode",
      "description": "Primer on 6502 arithmetic: ADC/SBC include carry (A = A + M + C; A = A − M − C̅); preparation with CLC/SEC; multi-byte 16-bit addition/subtraction chaining; two's complement representation and signed range; behavior of flags (Z, N reflect result; V indicates signed overflow only when operands have same sign); worked examples (e.g., $40 + $40 sets V). Decimal mode (BCD) semantics for ADC/SBC, unsigned nature, flag behavior (V meaningless in BCD), and multi-byte operations sequence; note that WDC 65C02 clears D on interrupt.",
      "references": [
        {
          "chunk": "instruction_reference_part1_adc_to_eor",
          "topic": "ADC semantics and flags table"
        },
        {
          "chunk": "instruction_reference_part2_inc_to_tya_and_timing_notes",
          "topic": "SBC semantics and flags table"
        },
        {
          "chunk": "registers_and_status_flags",
          "topic": "Status flag meanings"
        }
      ]
    },
    {
      "start": 2108,
      "end": 2238,
      "name": "interrupts_jump_vectors_and_stack_operations",
      "description": "Detailed mechanics: IRQ/NMI push PC (HB/LB) then SR to stack, then vector fetch ($FFFA NMI, $FFFE IRQ); I flag masks IRQ, not NMI; BRK pushes PC+2 and SR with B=1, vectors to $FFFE on NMOS; SEI behavior; RTI pulls SR (B ignored) then PC. JSR pushes return address bytes (PC+2 H then L) and RTS pulls PC then increments. Diagrams of IRQ/NMI/RTI and JSR/RTS stack sequences. Curious behaviors: branch-taken 3-cycle delay adds an extra cycle before interrupt; NMOS NMI at start of BRK hijacks BRK vector; 65C02 clears D on interrupts/BRK. Break flag on stack behavior with examples (PHP/PLP masking, reading SR via PLA).",
      "references": [
        {
          "chunk": "memory_stack_vectors_reset",
          "topic": "Vector locations and stack page"
        },
        {
          "chunk": "instruction_reference_part1_adc_to_eor",
          "topic": "BRK and RTI definitions"
        }
      ]
    },
    {
      "start": 2239,
      "end": 2364,
      "name": "instruction_layout_and_opcode_tables",
      "description": "Decoding pattern aaabbbcc (bit layout) explaining grouping by operation rows and addressing mode columns; multiple comprehensive opcode tables sorted by c→a and rotated views (rows c,b vs columns a; rows a,c vs columns b), correlating instruction families (e.g., shifts in c=2) and branch/flag groupings (c=0, b=4/6). Notes on 'ASL A' operand notation vs implied accumulator.",
      "references": [
        {
          "chunk": "opcode_matrix_overview",
          "topic": "High-level opcode grid"
        },
        {
          "chunk": "illegal_opcodes_revisited_decoding_patterns",
          "topic": "Where undocumented opcodes fit in the aaabbbcc scheme"
        }
      ]
    },
    {
      "start": 2365,
      "end": 2558,
      "name": "illegal_opcodes_revisited_decoding_patterns",
      "description": "Undocumented opcode placement within aaabbbcc layout: extended tables marking NOPs, JAMs, and composite 'illegal' ops. Observations: c=3 rows inherit/conflate operations from c=1 and c=2 immediate-above rows with addressing of c=1; some become NOP (e.g., $89 'STA #' nonsensical) or JAM (timing failure in certain indirect modes). Discussion of unstable 'ANE'/'LXA' involving 'magic constant' and internal bus contention (active-low logic), TAS/SH* behavior with index/address high+1, and why no c=3 JAM when one thread resolves. Also highlights difference between accumulator (OPC A) vs implied immediate NOP cases ($7A).",
      "references": [
        {
          "chunk": "illegal_opcodes_overview_and_details_nmos",
          "topic": "Per-instruction undocumented behaviors and timings"
        },
        {
          "chunk": "instruction_layout_and_opcode_tables",
          "topic": "Base legal opcode layout used for inheritance reasoning"
        }
      ]
    },
    {
      "start": 2559,
      "end": 2627,
      "name": "pinouts_and_65xx_family_overview",
      "description": "Pinout summaries: 6502 (NMOS) signals (VCC/VSS, Φ0–2, A0–A15, D0–D7, R/W, RDY, S.O., SYNC, IRQ, NMI, RES, N.C.); WDC 65C02S (VDD, Φ1–2, BE, RDY bidirectional, VBP vector pull); Atari 6502C 'SALLY' (HALT input, no SYNC). 65xx-family overview: 6502 variants (A/C), 65C02, reduced address bus parts (6503/5/6/4/7), banked 6509, 6510/8500/8502 with I/O ports, microcontrollers (6511/65F11), HMOS/CMOS variants, and 65816/65802 extended family with 16-bit registers/24-bit address bus.",
      "references": [
        {
          "chunk": "wdc_65c02_extensions_address_modes_instructions_behavior",
          "topic": "CMOS 65C02 behavioral differences tied to pinout (RDY)"
        }
      ]
    },
    {
      "start": 2628,
      "end": 2643,
      "ignore": true,
      "reason": "Site notes, disclaimer, tools, external links, and file path"
    }
  ],
  "source_md5": "0e1050a5f686796f55d362ceb1994410"
}
