{
  "source_file": "6502 ADDRESSING MODES.txt",
  "context": "6502 ADDRESSING MODES",
  "splits": [
    {
      "start": 1,
      "end": 2,
      "name": "document_title_and_intro",
      "description": "Title and brief introduction explaining that the 6502 has multiple addressing modes and that different instructions use different subsets of them.",
      "references": [
        {
          "chunk": "absolute_addressing",
          "topic": "first detailed mode (Absolute)"
        },
        {
          "chunk": "zero_page_addressing",
          "topic": "zero page mode"
        }
      ]
    },
    {
      "start": 3,
      "end": 8,
      "name": "absolute_addressing",
      "description": "Absolute addressing: operand is a 2-byte memory address (format aaaa). Examples: LDA $3491 loads accumulator from memory $3491; LDA num1 uses a labelled absolute address.",
      "references": [
        {
          "chunk": "absolute_indexed_addressing",
          "topic": "indexed variant (absolute + X/Y)"
        },
        {
          "chunk": "summary_absolute_and_intro",
          "topic": "summary example of absolute addressing"
        }
      ]
    },
    {
      "start": 9,
      "end": 17,
      "name": "zero_page_addressing",
      "description": "Zero Page addressing: operand is a 1-byte address (aa) referring to $0000-$00FF. Example: LDA $56 accesses $0056. Notes: instruction is one byte shorter and faster than absolute; assembler auto-generates zero page opcodes for labels in the zero page.",
      "references": [
        {
          "chunk": "zero_page_indexed_addressing",
          "topic": "zero page indexed variants (aa,X / aa,Y)"
        },
        {
          "chunk": "indexed_indirect_x",
          "topic": "zero page used for address tables in indirect modes"
        }
      ]
    },
    {
      "start": 18,
      "end": 23,
      "name": "immediate_addressing",
      "description": "Immediate addressing: operand is 1 byte of data (format #aa) indicated by a leading '#'. Examples: LDA #48 loads literal value $48; LDA #'H' uses a character literal.",
      "references": [
        {
          "chunk": "accumulator_addressing",
          "topic": "contrast with accumulator mode for operations on A"
        }
      ]
    },
    {
      "start": 24,
      "end": 29,
      "name": "implicit_addressing",
      "description": "Implicit addressing: instruction requires no operand because the target is implied by the opcode. Examples: CLC clears the carry flag; TAX transfers accumulator to X. Saves memory by storing only the opcode.",
      "references": [
        {
          "chunk": "accumulator_addressing",
          "topic": "other operand-less form (uses 'A' explicitly)"
        }
      ]
    },
    {
      "start": 30,
      "end": 35,
      "name": "accumulator_addressing",
      "description": "Accumulator addressing: operations apply directly to the accumulator and are indicated by the operand 'A'. Mainly used by shift/rotate instructions. Examples: ASL A (shift A left), ROR A (rotate A right).",
      "references": [
        {
          "chunk": "implicit_addressing",
          "topic": "implicit vs accumulator (implicit requires no operand)"
        }
      ]
    },
    {
      "start": 36,
      "end": 44,
      "name": "absolute_indexed_addressing",
      "description": "Absolute Indexed addressing (aaaa,X or aaaa,Y): operand is a 2-byte base address; add X or Y register to compute final address. Example sequence: LDX #$0A then LDA $2020,X loads from $2020 + $0A = $202A. Typically used for accessing tables where the base is a fixed address and index is an offset.",
      "references": [
        {
          "chunk": "absolute_addressing",
          "topic": "base absolute addressing"
        },
        {
          "chunk": "zero_page_indexed_addressing",
          "topic": "zero-page analogue for shorter opcodes"
        }
      ]
    },
    {
      "start": 45,
      "end": 51,
      "name": "zero_page_indexed_addressing",
      "description": "Zero Page Indexed addressing (aa,X or aa,Y): same concept as absolute indexed but the operand is a 1-byte zero page address. Example: LDY #$4A then LDA $24,Y loads from $24 + $4A = $6E. Uses zero page for smaller, faster instructions.",
      "references": [
        {
          "chunk": "zero_page_addressing",
          "topic": "base zero page addressing"
        },
        {
          "chunk": "indexed_indirect_x",
          "topic": "zero page used as base for indirect address tables"
        }
      ]
    },
    {
      "start": 52,
      "end": 59,
      "name": "indirect_absolute_addressing",
      "description": "Indirect Absolute addressing (format (aaaa)): used only by JMP on the 6502. The operand is a 2-byte address in memory which contains the low byte of the target address; the high byte is in the next memory location. Example: if $3418 contains $55 and $3419 contains $29, then JMP ($3418) transfers to $2955.",
      "references": [
        {
          "chunk": "indexed_indirect_x",
          "topic": "other indirect forms using zero page"
        },
        {
          "chunk": "indirect_indexed_y",
          "topic": "other indirect forms using zero page"
        }
      ]
    },
    {
      "start": 60,
      "end": 71,
      "name": "indexed_indirect_x",
      "description": "Indexed Indirect (format (aa,X)): zero page based indirect mode using X. Operation: take 1-byte zero-page operand aa, add X to it (wraps in zero page), read two bytes at that resulting zero-page location which form a 16-bit effective address, then access data at that address. Example: LDX #$11; LDA ($36,X) -> uses $36+$11 = $47; if $0047 contains $49 and $0048 contains $A3, the effective address is $A349 and its contents load A. Commonly used for tables of addresses stored on the zero page.",
      "references": [
        {
          "chunk": "zero_page_indexed_addressing",
          "topic": "zero page addressing and indexing"
        },
        {
          "chunk": "indirect_indexed_y",
          "topic": "contrast 'add then fetch' vs 'fetch then add' behavior"
        }
      ]
    },
    {
      "start": 72,
      "end": 84,
      "name": "indirect_indexed_y",
      "description": "Indirect Indexed (format (aa),Y): zero page based indirect mode using Y. Operation: read a 16-bit base address from zero page at aa (low byte) and aa+1 (high byte), then add Y to that 16-bit address to form the effective address. Example: if $A5 contains $28 and $A6 contains $77, LDY $08; LDA ($A5),Y adds $08 to $7728 producing $7730 and loads A from $7730. Summarised as 'find the address and then add the offset'.",
      "references": [
        {
          "chunk": "indexed_indirect_x",
          "topic": "contrast 'add then find' (X) vs 'find then add' (Y)"
        },
        {
          "chunk": "zero_page_addressing",
          "topic": "uses zero page address pointers"
        }
      ]
    },
    {
      "start": 85,
      "end": 100,
      "name": "relative_addressing",
      "description": "Relative addressing: used only by branch instructions. Operand is a 1-byte two's complement signed offset (-128 to +127) added to the address of the instruction following the branch to compute the target. Example: BEQ #$F5 ($F5 = -11) branches to PC+1 - 11 if zero flag is set. Assemblers typically let you use labels instead of manually computing offsets. Example loop: LB1: LDA $FA55; INX; BEQ LB1",
      "references": [
        {
          "chunk": "implicit_addressing",
          "topic": "branch instructions are a form of control-flow opcodes with implied behavior"
        }
      ]
    },
    {
      "start": 101,
      "end": 106,
      "name": "summary_intro_and_absolute",
      "description": "SUMMARY: Overview that low-level instructions often contain operands which refer to memory locations (addressing modes). Summary of Absolute (Direct) addressing: operand is the memory address; example LDA $6F55 loads accumulator from $6F55.",
      "references": [
        {
          "chunk": "absolute_addressing",
          "topic": "full absolute mode explanation and examples"
        },
        {
          "chunk": "summary_immediate",
          "topic": "next summary section (immediate)"
        }
      ]
    },
    {
      "start": 107,
      "end": 110,
      "name": "summary_immediate",
      "description": "SUMMARY: Immediate addressing recap — operand is the data item itself. Example: LDA #41 loads the number 41 ($29) into A.",
      "references": [
        {
          "chunk": "immediate_addressing",
          "topic": "detailed immediate addressing"
        },
        {
          "chunk": "summary_indexed",
          "topic": "linked indexed summary"
        }
      ]
    },
    {
      "start": 111,
      "end": 114,
      "name": "summary_indexed",
      "description": "SUMMARY: Indexed addressing recap — operand plus index register gives the memory location. Example: LDA $4F10,X with X making final address $4F10 + $34 = $4F44 (example shows X = $34). Mentions index register X.",
      "references": [
        {
          "chunk": "absolute_indexed_addressing",
          "topic": "detailed absolute indexed mode"
        },
        {
          "chunk": "zero_page_indexed_addressing",
          "topic": "zero page indexed variant"
        }
      ]
    },
    {
      "start": 115,
      "end": 117,
      "name": "summary_indirect",
      "description": "SUMMARY: Indirect addressing recap — operand is an address of a memory location which itself contains the address of the data item (pointer). Example text references loading a data item via an indirect pointer.",
      "references": [
        {
          "chunk": "indirect_absolute_addressing",
          "topic": "JMP (aaaa) indirect variant"
        },
        {
          "chunk": "indexed_indirect_x",
          "topic": "zero page indirect variants"
        }
      ]
    },
    {
      "start": 118,
      "end": 126,
      "name": "summary_relative",
      "description": "SUMMARY: Relative addressing recap for branches: operand is a two's complement offset (-128 to +127) added to the address after the branch to produce the target. Example: 4545 BEQ $13 will branch to $4547 + $13 = $455A if zero flag is set. Example following LDA at $4547.",
      "references": [
        {
          "chunk": "relative_addressing",
          "topic": "detailed relative addressing explanation and examples"
        }
      ]
    }
  ],
  "source_md5": "cdad6b5f35309933d575d33c85f234ed"
}
