{
  "source_file": "KickAssembler v5.25 Manual.txt",
  "context": "Kick Assembler",
  "splits": [
    {
      "start": 1,
      "end": 6,
      "name": "front_matter_title_and_toc_heading_ignored",
      "description": "Front matter: document title and author (Kick Assembler Reference Manual by Mads Nielsen) and the Table of Contents heading/page break marker. Non-technical front-matter; marked ignored.",
      "references": [
        {
          "chunk": "table_of_contents_part_1_ignored",
          "topic": "continues the Table of Contents (chapters 1–9.5)"
        }
      ]
    },
    {
      "start": 7,
      "end": 61,
      "name": "table_of_contents_part_1_ignored",
      "description": "Table of Contents entries listing chapters and subitems from 1 (Introduction) through 9.5 (Escaping the current scope or namespace). Contains section numbers and page references. Non-technical; marked ignored.",
      "references": [
        {
          "chunk": "front_matter_title_and_toc_heading_ignored",
          "topic": "title and TOC heading"
        },
        {
          "chunk": "table_of_contents_part_2_ignored",
          "topic": "continues the Table of Contents (sections 9.6–10.2 and beyond)"
        }
      ]
    },
    {
      "start": 62,
      "end": 76,
      "name": "table_of_contents_part_2_ignored",
      "description": "Table of Contents continuation covering page/footer markers and TOC entries 9.6–10.2 (Label Scopes through Segments introduction). Non-technical; marked ignored.",
      "references": [
        {
          "chunk": "table_of_contents_part_1_ignored",
          "topic": "previous TOC entries (1–9.5)"
        },
        {
          "chunk": "table_of_contents_part_3_ignored",
          "topic": "continues the Table of Contents (sections 10.3–11.6)"
        }
      ]
    },
    {
      "start": 77,
      "end": 96,
      "name": "table_of_contents_part_3_ignored",
      "description": "Table of Contents entries covering sections 10.3–11.6 (Segments details through File/ Disk parameters). Non-technical; marked ignored.",
      "references": [
        {
          "chunk": "table_of_contents_part_2_ignored",
          "topic": "previous TOC entries (9.6–10.2)"
        },
        {
          "chunk": "table_of_contents_part_4_ignored",
          "topic": "continues the Table of Contents (sections 12–15.4.5)"
        }
      ]
    },
    {
      "start": 97,
      "end": 121,
      "name": "table_of_contents_part_4_ignored",
      "description": "Table of Contents entries covering sections 12–15.4.5 (Import/Export through Assemble Information sections and subsections up to 15.4.5). Non-technical; marked ignored.",
      "references": [
        {
          "chunk": "table_of_contents_part_3_ignored",
          "topic": "previous TOC entries (10.3–11.6)"
        },
        {
          "chunk": "table_of_contents_part_5_ignored",
          "topic": "continues the Table of Contents (sections 15.4.6–17.5.6 and appendices)"
        }
      ]
    },
    {
      "start": 122,
      "end": 146,
      "name": "table_of_contents_part_5_ignored",
      "description": "Table of Contents entries covering sections 15.4.6–17.5.6 (remaining Assemble Information subsections through 3rd party plugins and plugin interfaces). Non-technical; marked ignored.",
      "references": [
        {
          "chunk": "table_of_contents_part_4_ignored",
          "topic": "previous TOC entries (12–15.4.5)"
        },
        {
          "chunk": "table_of_contents_part_6_ignored",
          "topic": "continues the Table of Contents (appendices A and B and technical details)"
        }
      ]
    },
    {
      "start": 147,
      "end": 169,
      "name": "table_of_contents_part_6_ignored",
      "description": "Final part of the Table of Contents and front-matter footers covering Appendix A (Quick Reference), Appendix B (Technical Details) and final page markers (iii/iv). Non-technical; marked ignored.",
      "references": [
        {
          "chunk": "table_of_contents_part_5_ignored",
          "topic": "previous TOC entries (15.4.6–17.5.6)"
        }
      ]
    },
    {
      "start": 170,
      "end": 206,
      "name": "introduction_overview",
      "description": "Chapter 1: Overview of Kick Assembler — what it is, main features (script language integration, plugins, SID/graphics import), version history (1.x — 5.x), project background, credits and contact information.",
      "references": [
        {
          "chunk": "getting_started_running_assembler",
          "topic": "practical first steps and examples (Chapter 2 Getting Started)"
        },
        {
          "chunk": "front_matter_and_table_of_contents_ignored",
          "topic": "table of contents and front-matter"
        }
      ]
    },
    {
      "start": 207,
      "end": 224,
      "name": "getting_started_running_assembler",
      "description": "Chapter 2 intro and section 2.1: How to run Kick Assembler on Java 8+, basic command line usage (java -jar kickass.jar myCode.asm) and checking Java installation.",
      "references": [
        {
          "chunk": "getting_started_example_interrupt",
          "topic": "practical example interrupt program demonstrating assembler features"
        },
        {
          "chunk": "getting_started_configuring_assembler",
          "topic": "configuring default options via KickAss.cfg"
        }
      ]
    },
    {
      "start": 225,
      "end": 278,
      "name": "getting_started_example_interrupt",
      "description": "Section 2.2: A small example IRQ program (C64 code) demonstrating comments, macros, includes, BasicUpstart2 use, interrupt setup, importing binary data, and a macro definition (SetBorderColor). Full example code and usage notes.",
      "references": [
        {
          "chunk": "getting_started_running_assembler",
          "topic": "how to run the assembler to assemble the example"
        },
        {
          "chunk": "functions_define",
          "topic": "macros and functions referenced in examples"
        }
      ]
    },
    {
      "start": 279,
      "end": 295,
      "name": "getting_started_configuring_assembler",
      "description": "Section 2.3: Command-line options and config file KickAss.cfg usage, example settings (-showmem, -execute), comment rules in config file and environment/path notes for Java on Windows.",
      "references": [
        {
          "chunk": "basic_assembler_functionality_overview_and_mnemonics",
          "topic": "–showmem and memory map output described later in Basic Assembler Functionality"
        }
      ]
    },
    {
      "start": 296,
      "end": 346,
      "name": "basic_assembler_functionality_overview_and_mnemonics",
      "description": "Chapter 3 intro and 3.1 Mnemonics: Basic assembler usage examples (lda/sta), multiple commands per line, CPU instruction sets supported (.cpu directive), list and description of available CPU sets (standard 6502, illegal opcodes, DTV, 65c02) and reference to Quick Reference appendix.",
      "references": [
        {
          "chunk": "argument_types_and_addressing_modes",
          "topic": "details on argument/addressing modes used by mnemonics"
        },
        {
          "chunk": "preprocessor_directives_reference_table",
          "topic": "appendix and reference tables"
        }
      ]
    },
    {
      "start": 347,
      "end": 422,
      "name": "6502_addressing_modes_overview",
      "description": "Lists the traditional 6502/C64 addressing modes with examples. Covers: no-argument (nop), immediate (lda #$30), zeropage (lda $30), zeropage,X (lda $30,x), zeropage,Y (ldx $30,y), indirect zeropage,X (lda ($30,x)), indirect zeropage,Y (lda ($30),y), absolute (lda $1000), absolute,X/Y (lda $1000,x / lda $1000,y), indirect (jmp ($1000)), relative (bne loop), and 65C02-specific modes such as indirect zeropage (adc ($12)), zeropage-relative (bbr1 $12,label) and indirect with absolute+X (jmp ($1234,x)). Includes short formatting artifacts from the original page.",
      "references": [
        {
          "chunk": "zeropage_conversion_and_explicit_mode_forcing",
          "topic": "automatic zeropage conversion and suffixes to force addressing forms"
        },
        {
          "chunk": "deprecated_mnemonic_extensions",
          "topic": "deprecated mnemonic suffixes that also force addressing modes (kept for backward compatibility)"
        }
      ]
    },
    {
      "start": 423,
      "end": 436,
      "name": "zeropage_conversion_and_explicit_mode_forcing",
      "description": "Explains assembler behavior for choosing zeropage vs absolute addressing: the assembler automatically converts arguments to zeropage mode when possible (e.g., lda $0030 becomes zeropage). Shows how to force a specific addressing form using mnemonic suffixes .a / .abs for absolute and .z / .zp for zeropage, with examples (lda.abs $0040,x, lda.a $0030,x, stx.zp zpLabel,y). Also shows defining a label (.label zpLabel = $10) and notes that forcing a mode on a mnemonic that doesn't support it has no effect (jmp.z $1000).",
      "references": [
        {
          "chunk": "6502_addressing_modes_overview",
          "topic": "full list of addressing modes that may be chosen or forced"
        },
        {
          "chunk": "deprecated_mnemonic_extensions",
          "topic": "alternative (deprecated) mnemonic extensions for forcing modes"
        }
      ]
    },
    {
      "start": 437,
      "end": 492,
      "name": "deprecated_mnemonic_extensions",
      "description": "Documents deprecated mnemonic extensions (kept for backward compatibility) that explicitly indicate addressing modes. Lists the extension tokens and the modes they force, with examples: im/imm (immediate), z/zp (zeropage) e.g. ldx.z $1234, zx/zpx (zeropage,X) e.g. lda.zpx table, zy/zpy (zeropage,Y), izx/izpx (indirect zeropage,X), izy/izpy (indirect zeropage,Y), ax/absx (absolute,X), ay/absy (absolute,Y), I/ind (indirect), r/rel (relative). Includes final example usages such as lda.absx $1234 and jmp.i $1000.",
      "references": [
        {
          "chunk": "6502_addressing_modes_overview",
          "topic": "the canonical addressing modes table and examples"
        },
        {
          "chunk": "zeropage_conversion_and_explicit_mode_forcing",
          "topic": "modern suffixes (.a/.abs/.z/.zp) used to force addressing modes"
        }
      ]
    },
    {
      "start": 493,
      "end": 526,
      "name": "number_formats",
      "description": "Section 3.3: Supported numeric literal formats (decimal, hexadecimal with $, binary with %), notes about unknown/unresolved labels being treated as 16-bit values in early passes, and examples.",
      "references": [
        {
          "chunk": "numeric_values_and_operators",
          "topic": "numeric operators, byte/high/low operators (>,<) and bitwise operations in script expressions"
        }
      ]
    },
    {
      "start": 527,
      "end": 623,
      "name": "labels_argument_labels_and_multi_labels",
      "description": "Section 3.4: Label syntax and usage (labels ending with ':'), label-in-argument usage (self-modifying code), multi-labels (!label with + and - to navigate instances), using '*' for current memory location, the .zp directive to mark labels as zeropage, and caveats regarding macros and pseudocommands within .zp blocks.",
      "references": [
        {
          "chunk": "scopes_and_namespaces_scopes",
          "topic": "label visibility and scope rules described in Chapter 9"
        },
        {
          "chunk": "memory_directives_and_pc_management",
          "topic": "interaction with program counter and memory blocks (*)"
        }
      ]
    },
    {
      "start": 624,
      "end": 697,
      "name": "memory_directives_and_pc_management",
      "description": "Section 3.5: The '*' directive to set the program counter (.pc alias supported), naming memory blocks for -showmem memory map, virtual memory blocks (virtual option), overlapping virtual blocks, .align directive for page-aligning, and .pseudopc to assemble as if code located at a different address.",
      "references": [
        {
          "chunk": "labels_argument_labels_and_multi_labels",
          "topic": "labels, '*' usage and memory positioning"
        },
        {
          "chunk": "prg_files_and_d64_disks_overview",
          "topic": "how memory blocks map to output files and disk images (see Chapter 11 - referenced in TOC)"
        }
      ]
    },
    {
      "start": 698,
      "end": 757,
      "name": "data_directives_and_fill",
      "description": "Section 3.6: Data generation directives (.byte, .word, .dword, .text), aliases (.by, .wo, .dw), .fill and .fillword with examples (including pattern fills), .lohifill for generating interleaved lo/hi tables, and performance note: .fill compiles faster than .for + .byte.",
      "references": [
        {
          "chunk": "encoding_and_charset_options",
          "topic": ".text encoding impact and available encodings"
        },
        {
          "chunk": "functions_define",
          "topic": "recommendations for heavy table generation and define/.lock usage"
        }
      ]
    },
    {
      "start": 758,
      "end": 804,
      "name": "encoding_and_charset_options",
      "description": "Section 3.7: .encoding directive and supported encodings (ascii, petscii_mixed, petscii_upper, screencode_mixed, screencode_upper), how .text and .import text are affected, and examples showing encoding switches.",
      "references": [
        {
          "chunk": "data_directives_and_fill",
          "topic": "how .text interacts with data directives"
        },
        {
          "chunk": "importing_data",
          "topic": ".import text uses the active encoding"
        }
      ]
    },
    {
      "start": 805,
      "end": 831,
      "name": "importing_source_code_preprocessor_usage",
      "description": "Section 3.8: Using the preprocessor (#import, #importif) to include other source files, search path order (current dir then -libdir entries), #importonce usage to prevent multiple inclusion, and note about old .import source directives (v3.x support vs. recommended preprocessor).",
      "references": [
        {
          "chunk": "preprocessor_intro_and_symbol_definitions",
          "topic": "detailed preprocessor directives and symbol handling (Chapter 8)"
        },
        {
          "chunk": "importing_data",
          "topic": "data import (.import) is separate from source import"
        }
      ]
    },
    {
      "start": 832,
      "end": 857,
      "name": "importing_data",
      "description": "Section 3.9: .import directive for binary, c64, and text files with optional offset and length parameters, examples (.import binary, .import c64 skipping the first two address bytes, .import text converting via active encoding), and lookup in -libdir.",
      "references": [
        {
          "chunk": "encoding_and_charset_options",
          "topic": "text import conversion depends on current encoding"
        },
        {
          "chunk": "data_directives_and_fill",
          "topic": "imported bytes used as data in .byte/.text contexts"
        }
      ]
    },
    {
      "start": 858,
      "end": 871,
      "name": "comments_syntax",
      "description": "Section 3.10: Supported comment styles — line comments with // and block comments /* ... */; example placements of comments and note that traditional 65xx semicolon comments (;) are not supported because ';' is used in .for loops.",
      "references": [
        {
          "chunk": "getting_started_example_interrupt",
          "topic": "example code uses comments"
        }
      ]
    },
    {
      "start": 872,
      "end": 922,
      "name": "console_output_and_error_reporting",
      "description": "Section 3.11: .print and .printnow directives for assembler console output (timing differences between passes), examples showing incomplete first-pass output, .error and .errorif directives to abort assembly with messages, and examples checking conditions like page crossing.",
      "references": [
        {
          "chunk": "testing_asserts_and_tools",
          "topic": "testing and assertion features (see Chapter 16 in TOC)"
        }
      ]
    },
    {
      "start": 923,
      "end": 973,
      "name": "breakpoints_and_watches",
      "description": "Section 3.12: Debugger-oriented directives .break and .watch that add debug info for emulators/debuggers (VICE, C64Debugger); examples of placing breakpoints, conditional arguments for breakpoints, macro breakpoint behavior, watch definitions (single address, ranges, optional argument), and argument semantics.",
      "references": [
        {
          "chunk": "prg_files_and_d64_disks_overview",
          "topic": "debug output targets and formats (Appendix/Chapter 11 references)"
        }
      ]
    },
    {
      "start": 974,
      "end": 1004,
      "name": "script_language_introduction_and_expressions",
      "description": "Chapter 4 introduction and Section 4.1: Overview of the integrated script language, expression evaluation mechanism (supports Numbers, Booleans, Strings, Lists, Vectors, Matrices), examples showing expressions used in assembler directives and object-oriented value method calls.",
      "references": [
        {
          "chunk": "variables_constants_and_labels",
          "topic": "variables, constants and user-defined labels in script language (Section 4.2)"
        },
        {
          "chunk": "functions_define",
          "topic": "defining and calling script functions"
        }
      ]
    },
    {
      "start": 1005,
      "end": 1071,
      "name": "variables_constants_and_labels",
      "description": "Section 4.2: Declaring .var variables, using .eval for assignments and compound operators (++, --, += etc.), immutable .const declarations, .enum enumerations, and .label declarations for labels visible across scope; note about assignment rules and locking mutable values.",
      "references": [
        {
          "chunk": "working_with_mutable_values",
          "topic": "locking mutable values and .define directive (Section 6.3)"
        },
        {
          "chunk": "labels_argument_labels_and_multi_labels",
          "topic": "label declarations and usage in assembler code (Section 3.4)"
        }
      ]
    },
    {
      "start": 1072,
      "end": 1123,
      "name": "scoping_blocks_and_local_scopes",
      "description": "Section 4.3: Scoping rules using braces {..} to create local scopes, examples showing nested scopes, variable shadowing and that labels and variables declared inside a scope are not visible outside; demonstration of nested scope behavior and printed results.",
      "references": [
        {
          "chunk": "scopes_and_namespaces_scopes",
          "topic": "detailed scope & namespace resolution rules (Chapter 9)"
        }
      ]
    },
    {
      "start": 1124,
      "end": 1143,
      "name": "numeric_values_and_basic_arithmetic",
      "description": "Overview of numeric values (integers and floats) and standard arithmetic operators (+, -, *, /). Covers operator precedence, short inline examples (25+3, 5+2.5*3-10/2, charmem + y * $100) and a practical assembler example showing .var charmem = $0400 and a small loop that uses arithmetic to compute addresses (sta charmem + n*$100,x).",
      "references": [
        {
          "chunk": "bitwise_operations_example",
          "topic": "Shows how bitwise ops extend numeric expressions"
        },
        {
          "chunk": "high_low_byte_operators",
          "topic": "Related special 65xx high/low byte operators"
        },
        {
          "chunk": "numeric_values_table_and_number_function",
          "topic": "Detailed operator reference and examples"
        }
      ]
    },
    {
      "start": 1144,
      "end": 1147,
      "name": "bitwise_operations_example",
      "description": "Introduces bitwise operators (and, or, exclusive or, bit shifting) for use in numeric expressions. Provides a short example declaring .var x=$12345678 and using .word x & $00ff, [x>>16] & $00ff to extract and mask bytes using bitwise AND and right shift.",
      "references": [
        {
          "chunk": "numeric_values_and_basic_arithmetic",
          "topic": "Basic numeric expressions and arithmetic operators"
        },
        {
          "chunk": "numeric_values_table_and_number_function",
          "topic": "Full list and descriptions of bitwise and shift operators"
        }
      ]
    },
    {
      "start": 1148,
      "end": 1156,
      "name": "high_low_byte_operators",
      "description": "Explains the 65xx-specific high (>) and low (<) byte operators with examples. Shows typical usage with lda #<interrupt1 / sta $0314 and lda #>interrupt1 / sta $0315 and comments indicating these take the low and high byte of a symbol/address respectively.",
      "references": [
        {
          "chunk": "numeric_values_and_basic_arithmetic",
          "topic": "Using numeric expressions in assembler code"
        },
        {
          "chunk": "numeric_values_table_and_number_function",
          "topic": "Formal table entries for 'High byte' and 'Low byte' operators"
        }
      ]
    },
    {
      "start": 1157,
      "end": 1169,
      "name": "numeric_values_table_header",
      "description": "Table heading and column labels for Table 4.1: Numeric Values. Includes page/title lines and the table's column headers (Name, Operator, Examples, Description).",
      "references": [
        {
          "chunk": "numeric_values_operators_table",
          "topic": "Complete operator rows (unary minus through bitwise not) described in the table"
        },
        {
          "chunk": "number_function_description",
          "topic": "Note about the .number() utility referenced after the operator table"
        }
      ]
    },
    {
      "start": 1170,
      "end": 1275,
      "name": "numeric_values_operators_table",
      "description": "All operator entries from Table 4.1. Covers: Unary minus (symbol -, description: inverts sign), binary arithmetic (plus +, minus -, multiply *, divide / with examples and brief descriptions), byte extraction operators (high byte '>' and low byte '<' with examples and descriptions), bit shifts (<<, >> with examples and descriptions), and bitwise operations (and &, or |, exclusive-or ^, not ~ with examples and explanations).",
      "references": [
        {
          "chunk": "numeric_values_table_header",
          "topic": "Table heading and column labels for Table 4.1"
        },
        {
          "chunk": "number_function_description",
          "topic": "Follow-up note on converting arbitrary values to numeric form using .number()"
        }
      ]
    },
    {
      "start": 1276,
      "end": 1279,
      "name": "number_function_description",
      "description": "Documentation note explaining the .number() function: how to obtain the numeric representation of an arbitrary value, with an example (.print 'x'.number()).",
      "references": [
        {
          "chunk": "numeric_values_operators_table",
          "topic": "Operator examples and descriptions in Table 4.1 where numeric conversion may be relevant"
        }
      ]
    },
    {
      "start": 1280,
      "end": 1298,
      "name": "parentheses_and_evaluation_order",
      "description": "Section 4.5: Use of soft parentheses () and hard brackets [] to control order of evaluation; differences between soft parentheses as indirect addressing in 65xx assembly (jmp ($1000)) vs hard brackets for grouping; nesting parentheses examples.",
      "references": [
        {
          "chunk": "argument_types_and_addressing_modes",
          "topic": "indirect addressing syntax and assembly interpretation"
        }
      ]
    },
    {
      "start": 1299,
      "end": 1326,
      "name": "string_literal_syntax_and_escape_prefix",
      "description": "Overview of string literal syntax in KickAssembler: plain string examples, .var/.const usage, difference between plain strings and @-prefixed escape strings, examples showing @\"First line.\\nSecond line.\", escaping quotes inside strings, embedding hex codes with \\$ and the rationale for using @ (so file paths like \"c:\\newstuff\" are not broken).",
      "references": [
        {
          "chunk": "escape_codes_table",
          "topic": "Detailed list of supported escape codes used by @-prefixed strings"
        },
        {
          "chunk": "string_concatenation_printing_and_examples",
          "topic": "How to concatenate and print strings (examples follow this section)"
        }
      ]
    },
    {
      "start": 1327,
      "end": 1383,
      "name": "escape_codes_table",
      "description": "Table of supported escape codes for @-prefixed strings (Table 4.2). Lists escape sequences with examples and short descriptions: \\b (backspace), \\f (form feed), \\n (newline), \\r (carriage return), \\t (tab), \\\\ (backslash), \\\" (double quotes), and \\$ (two-digit hex values inserted into the string).",
      "references": [
        {
          "chunk": "string_literal_syntax_and_escape_prefix",
          "topic": "Context and examples showing how @ enables these escape codes"
        },
        {
          "chunk": "string_methods_overview",
          "topic": "String operations you can perform on strings that may contain escape codes"
        }
      ]
    },
    {
      "start": 1384,
      "end": 1406,
      "name": "string_concatenation_printing_and_examples",
      "description": "Concatenation and printing: using + to append strings and combine with numeric values, examples (.var x=25; .var myString = \"X is \" + x), using .print to output strings during assembly for debugging, printing label values (recommend converting to hex with toHexString), and a short example assembly snippet showing label usage.",
      "references": [
        {
          "chunk": "string_methods_overview",
          "topic": "Functions/operators available for strings (charAt, size, substring, etc.)"
        },
        {
          "chunk": "numeric_to_string_functions",
          "topic": "Helpers like toHexString used when printing numeric/label values"
        }
      ]
    },
    {
      "start": 1407,
      "end": 1456,
      "name": "string_methods_overview",
      "description": "Table of string functions and operators (Table 4.3): + (append), asBoolean(), asNumber(), asNumber(radix) for parsing with a specified base, charAt(n) to get a character, size() to get length, substring(i1,i2), toLowerCase() and toUpperCase(). Examples referenced for conversions are noted (e.g. \"f\".asNumber(16) returns 15).",
      "references": [
        {
          "chunk": "string_concatenation_printing_and_examples",
          "topic": "Using these methods when assembling and printing values"
        },
        {
          "chunk": "generic_stringification_string_function",
          "topic": "Using .string() to obtain a string representation before calling methods like charAt"
        },
        {
          "chunk": "numeric_to_string_functions",
          "topic": "Functions to convert numeric values into formatted strings for concatenation/printing"
        }
      ]
    },
    {
      "start": 1457,
      "end": 1504,
      "name": "numeric_to_string_functions",
      "description": "Table of functions that convert numbers to strings (Table 4.4): toIntString(x) and toIntString(x,minSize) for integer formatting (space-padded), toBinaryString(x) and toBinaryString(x,minSize) (zero-padded), toOctalString(x) and toOctalString(x,minSize), toHexString(x) and toHexString(x,minSize) (hexadecimal, zero-padded). Examples show expected outputs (e.g. toBinaryString(16,8) => \"00010000\").",
      "references": [
        {
          "chunk": "string_methods_overview",
          "topic": "String methods for working with the resulting strings (size, substring, etc.)"
        },
        {
          "chunk": "string_concatenation_printing_and_examples",
          "topic": "Use toHexString when printing labels or numeric values"
        },
        {
          "chunk": "generic_stringification_string_function",
          "topic": "Alternative: using .string() to stringify arbitrary values"
        }
      ]
    },
    {
      "start": 1505,
      "end": 1510,
      "name": "generic_stringification_string_function",
      "description": "The general .string() function to obtain the string representation of any value. Example: .print 1234.string().charAt(2) — demonstrates chaining .string() with string methods (prints '3' for that example).",
      "references": [
        {
          "chunk": "string_methods_overview",
          "topic": "Once you have a string (via .string()), you can use methods like charAt and size"
        },
        {
          "chunk": "numeric_to_string_functions",
          "topic": "Alternate formatting helpers when converting numbers to strings"
        }
      ]
    },
    {
      "start": 1511,
      "end": 1537,
      "name": "char_values",
      "description": "Section 4.7: Character (char) values and usage in assembler (.byte with character literals, .text concatenation), chars as numeric sub-class (arithmetic on chars), and examples showing char arithmetic and char access from strings.",
      "references": [
        {
          "chunk": "string_values_escape_codes_and_string_functions",
          "topic": "string/char interplay and .charAt usage"
        }
      ]
    },
    {
      "start": 1538,
      "end": 1543,
      "name": "math_library_overview",
      "description": "Introduction to Kick Assembler's Math Library: states that it is built on Java's Math library (so nearly all Java math constants and functions are available) and notes that the only non-Java math function provided is mod (modulo).",
      "references": [
        {
          "chunk": "math_constants",
          "topic": "Lists the available math constants (PI, E) with values."
        },
        {
          "chunk": "math_functions_basic",
          "topic": "Begins the list of math functions (abs, acos, asin, atan, atan2, cbrt, ceil, cos, cosh, exp, expm1)."
        },
        {
          "chunk": "math_functions_extended",
          "topic": "Continues the list of math functions (floor, hypot, IEEEremainder, log*, max/min, mod, pow)."
        }
      ]
    },
    {
      "start": 1544,
      "end": 1556,
      "name": "math_constants",
      "description": "Table of math constants available in Kick Assembler: PI (3.141592653589793) and E (2.718281828459045).",
      "references": [
        {
          "chunk": "math_library_overview",
          "topic": "Explains that the math library is built on Java's Math and mentions mod as the only non-Java function."
        },
        {
          "chunk": "math_functions_basic",
          "topic": "Lists the available math functions that operate on these constants or other numeric inputs."
        }
      ]
    },
    {
      "start": 1557,
      "end": 1607,
      "name": "math_functions_basic",
      "description": "Beginning portion of the Math Functions table. Descriptions for: abs(x) (absolute value), acos(x) (arc cosine), asin(x) (arc sine), atan(x) (arc tangent), atan2(y,x) (angle of coordinate), cbrt(x) (cube root), ceil(x) (round up), cos(r) (cosine), cosh(x) (hyperbolic cosine), exp(x) (e^x), and expm1(x) (e^x - 1). (Includes the table header and layout continuation across a page break.)",
      "references": [
        {
          "chunk": "math_library_overview",
          "topic": "Overview of the math library and note about mod."
        },
        {
          "chunk": "math_functions_extended",
          "topic": "Continues the function list: floor, hypot, IEEEremainder, logs, max/min, mod, pow."
        }
      ]
    },
    {
      "start": 1608,
      "end": 1656,
      "name": "math_functions_extended",
      "description": "Middle portion of the Math Functions table. Descriptions for: floor(x) (round down), hypot(a,b) (sqrt(x^2+y^2)), IEEEremainder(x,y) (IEEE 754 remainder), log(x) (natural log), log10(x) (base-10 log), log1p(x) (log(x+1)), max(x,y), min(x,y), mod(a,b) (non-Java modulo: converts inputs to integers and returns remainder), and pow(x,y) (x to the power y).",
      "references": [
        {
          "chunk": "math_functions_basic",
          "topic": "Preceding functions such as exp/expm1 and trig basics."
        },
        {
          "chunk": "math_functions_examples",
          "topic": "Examples showing use of random(), sin(...), rounding and .fill generation."
        }
      ]
    },
    {
      "start": 1657,
      "end": 1703,
      "name": "math_functions_trig_random_examples",
      "description": "Final portion of the Math Functions table plus examples. Descriptions for: random() (returns 0 ≤ x < 1), round(x), signum(x) (sign of x), sin(r), sinh(x), sqrt(x), tan(r), tanh(x), toDegrees(r), toRadians(d). Includes usage examples: loading A with a random number (lda #random()*256) and generating a sine curve using .fill with round(127.5+127.5*sin(toRadians(i*360/256))).",
      "references": [
        {
          "chunk": "math_functions_extended",
          "topic": "Contains related numeric utilities such as mod and pow used alongside random and trig functions."
        },
        {
          "chunk": "math_library_overview",
          "topic": "General description of Kick Assembler's math support and Java-based functions."
        }
      ]
    },
    {
      "start": 1704,
      "end": 1724,
      "name": "branching_and_looping_intro_and_boolean_examples",
      "description": "Chapter 5 header and introduction to Branching and Looping control directives in Kick Assembler; Section 5.1 introduction to Boolean values and examples of boolean variable assignments (.var myBoolean1 = true, .var myBoolean2 = false) and boolean expressions using comparisons (e.g. .var fourHigherThanFive = 4>5, .var aEqualsB = a==b, .var xNot10 = x!=10).",
      "references": [
        {
          "chunk": "boolean_generating_operators",
          "topic": "Table 5.1: standard comparison operators (==, !=, >, <, >=, <=) with examples and descriptions"
        },
        {
          "chunk": "boolean_logical_operators",
          "topic": "Table 5.2: logical boolean operators (!, &&, ||) with examples and descriptions"
        }
      ]
    },
    {
      "start": 1725,
      "end": 1795,
      "name": "boolean_generating_operators",
      "description": "Table 5.1: The standard set of operators that generate Boolean values. Includes operators: Equal (==), Not Equal (!=), Greater (>), Less (<), Greater than or equal (>=), Less than or equal (<=). For each operator the table shows the operator token, an example (e.g. a==b, a!=b, a>b, a<b, a>=b, a<=b) and a short description of when it returns true or false. Also includes notes that these operators are defined for numeric values and examples comparing booleans (e.g. .var b1 = true==true, .var b2 = true!=(10<20)).",
      "references": [
        {
          "chunk": "branching_and_looping_intro_and_boolean_examples",
          "topic": "Introduction and example boolean variable assignments"
        },
        {
          "chunk": "boolean_logical_operators",
          "topic": "Boolean operators for combining or negating generated Boolean values (!, &&, ||)"
        }
      ]
    },
    {
      "start": 1796,
      "end": 1844,
      "name": "boolean_logical_operators",
      "description": "Table 5.2: Boolean operators that operate on Boolean values. Introduces the logical operators Not (!), And (&&), and Or (||). For each operator the table shows the operator token, an example usage (!a, a&&b, A||b) and a short description of when the result is true (e.g. !a returns true if a is false; a&&b returns true if both a and b are true; A||b returns true if a or b are true).",
      "references": [
        {
          "chunk": "branching_and_looping_intro_and_boolean_examples",
          "topic": "Section 5.1 introduction and simple boolean expression examples"
        },
        {
          "chunk": "boolean_generating_operators",
          "topic": "Comparison operators that generate the Boolean values combined by these logical operators"
        }
      ]
    },
    {
      "start": 1845,
      "end": 1885,
      "name": "if_directive",
      "description": "Section 5.2: .if directive behavior — executing a following directive or a block {..} based on a boolean expression, .else blocks, examples for conditional code generation and error handling with .error inside .if/.else.",
      "references": [
        {
          "chunk": "ternary_if_question_mark",
          "topic": "short conditional expression form (condition ? trueExpr : falseExpr)"
        },
        {
          "chunk": "console_output_and_error_reporting",
          "topic": "using .error and .errorif together with conditionals"
        }
      ]
    },
    {
      "start": 1886,
      "end": 1910,
      "name": "ternary_if_question_mark",
      "description": "Section 5.3: Ternary operator usage (condition ? trueExpr : falseExpr) with examples for strings, numbers and conditional assembler arguments.",
      "references": [
        {
          "chunk": "if_directive",
          "topic": "relationship to standard .if/.else control structures"
        }
      ]
    },
    {
      "start": 1911,
      "end": 1931,
      "name": "for_directive",
      "description": "Section 5.4: .for directive syntax and examples (initialization list; boolean condition; iteration list), using multiple expressions in init/iteration, nested .for loops for table generation and loop unrolling, and example blitter/fill usages.",
      "references": [
        {
          "chunk": "data_directives_and_fill",
          "topic": "generating table data with .for vs .fill performance considerations"
        },
        {
          "chunk": "working_with_mutable_values",
          "topic": "recommendation to use .define for heavy .for computations"
        }
      ]
    },
    {
      "start": 1932,
      "end": 1954,
      "name": "while_directive",
      "description": "Section 5.5: .while directive usage — loop while a boolean expression is true, examples printing numbers and manual iteration using .eval inside the loop body.",
      "references": [
        {
          "chunk": "for_directive",
          "topic": "comparison between .for and .while loop constructs"
        }
      ]
    },
    {
      "start": 1955,
      "end": 1968,
      "name": "optimization_considerations_when_using_loops",
      "description": "Section 5.6: Performance tips — Function Mode vs Asm Mode, executing heavy calculations in function mode (inside define or functions) to save memory/time, restrictions of function mode (only script directives allowed), and guidance for unrolling and define usage.",
      "references": [
        {
          "chunk": "working_with_mutable_values",
          "topic": "how .define locks values and runs inner code in function mode"
        }
      ]
    },
    {
      "start": 1969,
      "end": 2066,
      "name": "data_structures_user_defined_structs",
      "description": "Chapter 6 and Section 6.1: Data structures and user-defined .struct types, defining structures (.struct Name {fields}), construction and access of struct instances, methods to introspect and manipulate structs (getStructName, getNoOfFields, getFieldNames, get(index)/get(name), set(index)/set(name)), examples for copying and printing struct contents.",
      "references": [
        {
          "chunk": "list_values",
          "topic": "lists as structured data used in structs fields"
        }
      ]
    },
    {
      "start": 2067,
      "end": 2133,
      "name": "list_values",
      "description": "Section 6.2: List() values — creating lists (List(n) or List()), get/set methods, add, size, remove, shuffle, reverse, sort, addAll; examples of creating lists, populating with greetings, and using myList.get in data directives.",
      "references": [
        {
          "chunk": "hashtable_values",
          "topic": "using lists as values inside hashtables"
        },
        {
          "chunk": "working_with_mutable_values",
          "topic": "lists are mutable and require locking for cross-pass usage"
        }
      ]
    },
    {
      "start": 2134,
      "end": 2165,
      "name": "working_with_mutable_values_and_define",
      "description": "Section 6.3: Mutable vs immutable values, locking mutable values with .lock(), the .define directive to define symbols inside a function-mode scope then lock/insert them as constants outside, usage examples, and explanation of function mode restrictions.",
      "references": [
        {
          "chunk": "optimization_considerations_when_using_loops",
          "topic": "placing heavy loops inside .define for performance (function mode)"
        },
        {
          "chunk": "variables_constants_and_labels",
          "topic": "how .const and .var interact with .define and .lock()"
        }
      ]
    },
    {
      "start": 2166,
      "end": 2239,
      "name": "hashtable_values",
      "description": "Section 6.4: Hashtable() usage — put/get operations, put multiple key/value pairs, keys() to get a list of keys, containsKey, remove, key equality based on string representation (e.g., ht.get(\"1.0\") and ht.get(1) are equivalent), examples and brief API table.",
      "references": [
        {
          "chunk": "list_values",
          "topic": "keys() returns a List value to iterate over"
        }
      ]
    },
    {
      "start": 2240,
      "end": 2274,
      "name": "functions_define",
      "description": "Chapter 7 and Section 7.1: Defining script .function functions (syntax, .return), examples (area, oddEven, clearList), behavior when no .return is reached (null), and function overloading based on argument count.",
      "references": [
        {
          "chunk": "macros",
          "topic": "difference between .function (script functions) and .macro (assembler macros)"
        }
      ]
    },
    {
      "start": 2275,
      "end": 2322,
      "name": "macros",
      "description": "Section 7.2: Defining and invoking .macro macros that generate assembler directives in-place, scope encapsulation of macros (local labels don't collide), examples (SetColor, ClearScreen), macro recursion and usage before declaration allowed, and note about accessing macro-local labels via scope/namespace techniques.",
      "references": [
        {
          "chunk": "pseudo_commands_and_cmdvalue_api",
          "topic": "pseudo commands are like macros but accept mnemonic-style command arguments"
        },
        {
          "chunk": "scopes_and_namespaces_scopes",
          "topic": "label visibility when labeling macro invocations"
        }
      ]
    },
    {
      "start": 2323,
      "end": 2329,
      "name": "macro_label_access_and_recursion",
      "description": "How to access labels of a macro execution by placing a label before the macro call; note that macros may be used before declaration; macros may call other macros or recurse provided there is a termination condition.",
      "references": [
        {
          "chunk": "pseudocommand_intro_and_simple_mov_examples",
          "topic": "Introduces pseudo commands which are a special kind of macro and build on macro behaviour"
        }
      ]
    },
    {
      "start": 2330,
      "end": 2350,
      "name": "pseudocommand_intro_and_simple_mov_examples",
      "description": "Introduction to .pseudocommand: syntax for defining pseudo commands that accept mnemonic-style arguments. Example mov pseudo command definition and usage examples (immediate, label, indexed, and indirect,y forms) with comments illustrating generated mnemonics.",
      "references": [
        {
          "chunk": "macro_label_access_and_recursion",
          "topic": "General macro behavior and label access (relevant to pseudo commands)"
        },
        {
          "chunk": "pseudocommand_adc_example_and_call_syntax",
          "topic": "More examples of pseudo command syntax and calling forms (including optional colon)"
        },
        {
          "chunk": "cmdvalue_getters_and_usage",
          "topic": "Explains how pseudo command arguments are represented as CmdValue objects"
        }
      ]
    },
    {
      "start": 2351,
      "end": 2369,
      "name": "pseudocommand_adc_example_and_call_syntax",
      "description": "Notes on argument separation (colon), backward-compatibility with v3.x (use -pseudoc3x or converter), optional leading colon to call commands with mnemonic names, and an example .pseudocommand adc showing behavior versus the standard mnemonic with example calls.",
      "references": [
        {
          "chunk": "pseudocommand_intro_and_simple_mov_examples",
          "topic": "Basic pseudo command definition and examples (mov)"
        },
        {
          "chunk": "cmdvalue_getters_and_usage",
          "topic": "CmdValue API used to inspect command arguments"
        }
      ]
    },
    {
      "start": 2370,
      "end": 2393,
      "name": "cmdvalue_getters_and_usage",
      "description": "Explanation that pseudo command arguments are passed as CmdValue objects containing a type and numeric value. Table of CmdValue functions: getType() returning an argument type constant and getValue() returning the numeric value, with short examples.",
      "references": [
        {
          "chunk": "argument_type_constants",
          "topic": "Lists the possible argument type constants returned by getType()"
        },
        {
          "chunk": "constructing_cmdargument_and_16bit_next_argument_function",
          "topic": "Shows how to construct new CmdArgument objects programmatically"
        }
      ]
    },
    {
      "start": 2394,
      "end": 2431,
      "name": "argument_type_constants",
      "description": "List of CmdValue argument type constants and examples: AT_ABSOLUTE, AT_ABSOLUTEX, AT_ABSOLUTEY, AT_IMMEDIATE, AT_INDIRECT, AT_IZEROPAGEX, AT_IZEROPAGEY, and AT_NONE. Note that some addressing modes (absolute zeropage and relative) are omitted because the assembler infers them from absolute modes.",
      "references": [
        {
          "chunk": "cmdvalue_getters_and_usage",
          "topic": "CmdValue.getType() returns one of these constants"
        },
        {
          "chunk": "constructing_cmdargument_and_16bit_next_argument_function",
          "topic": "Examples use these type constants when constructing new CmdArgument values"
        }
      ]
    },
    {
      "start": 2432,
      "end": 2448,
      "name": "constructing_cmdargument_and_16bit_next_argument_function",
      "description": "How to construct new command arguments with CmdArgument(type, value). Example creating an immediate CmdArgument. Definition of helper function _16bitnextArgument(arg) that, for a given argument, returns the corresponding next argument for 16-bit operations (preserving type; for immediates returns high byte using >, otherwise increments value by 1).",
      "references": [
        {
          "chunk": "argument_type_constants",
          "topic": "Uses AT_IMMEDIATE and other argument types when constructing CmdArgument"
        },
        {
          "chunk": "defining_inc16_pseudocommand",
          "topic": "Used by inc16 to access the high/next byte"
        },
        {
          "chunk": "mov16_and_add16_pseudocommands",
          "topic": "Used by mov16 and add16 to operate on high/low byte pairs"
        }
      ]
    },
    {
      "start": 2449,
      "end": 2460,
      "name": "defining_inc16_pseudocommand",
      "description": "Defines a 16-bit increment pseudo command .pseudocommand inc16 arg that increments the low byte and, on carry (BNE/over logic), increments the high/next argument using _16bitnextArgument(arg).",
      "references": [
        {
          "chunk": "constructing_cmdargument_and_16bit_next_argument_function",
          "topic": "inc16 relies on _16bitnextArgument to find the high byte argument"
        },
        {
          "chunk": "mov16_and_add16_pseudocommands",
          "topic": "Other 16-bit helpers for move and add operations"
        }
      ]
    },
    {
      "start": 2461,
      "end": 2476,
      "name": "mov16_and_add16_pseudocommands",
      "description": "Definitions of .pseudocommand mov16 src:tar (loads/stores both low and high bytes using _16bitnextArgument) and .pseudocommand add16 arg1 : arg2 : tar (performs 16-bit addition across low and high bytes; if tar omitted and AT_NONE used, the first argument is used as target).",
      "references": [
        {
          "chunk": "constructing_cmdargument_and_16bit_next_argument_function",
          "topic": "Uses _16bitnextArgument to operate on high/low pairs"
        },
        {
          "chunk": "using_16bit_pseudocommands_and_notes",
          "topic": "Examples of how to call these 16-bit pseudo commands and notes on optional target argument"
        }
      ]
    },
    {
      "start": 2477,
      "end": 2490,
      "name": "using_16bit_pseudocommands_and_notes",
      "description": "Usage examples for the 16-bit pseudo commands (inc16, mov16, add16) showing calls with labels, immediate values, and zeropage forms. Note explaining that when the target argument is omitted add16 receives an argument of type AT_NONE and will use the first argument as the target. Concluding remark about using pseudo commands to create extended instruction libraries to simplify common programming tasks.",
      "references": [
        {
          "chunk": "mov16_and_add16_pseudocommands",
          "topic": "Definitions for the 16-bit commands used in these examples"
        },
        {
          "chunk": "defining_inc16_pseudocommand",
          "topic": "inc16 example usage"
        }
      ]
    },
    {
      "start": 2491,
      "end": 2563,
      "name": "preprocessor_intro_and_symbol_definitions",
      "description": "Chapter 8 intro and Section 8.1–8.2: Preprocessor role (runs before main parser), defining preprocessor symbols via command line (-define) or #define/#undef, recognition rules (# at line start), and conditional inclusion with #if/#else/#endif/#elif plus nesting behavior and examples illustrating that untaken #if blocks are not seen by the main parser.",
      "references": [
        {
          "chunk": "importing_source_code_preprocessor_usage",
          "topic": "practical use of #import/#importif/#importonce for source inclusion"
        },
        {
          "chunk": "preprocessor_imports_and_importonce",
          "topic": "import semantics and #importonce usage"
        }
      ]
    },
    {
      "start": 2564,
      "end": 2578,
      "name": "preprocessor_imports_and_importonce",
      "description": "Section 8.3: #import and #importif usage for including other source files, examples, and #importonce usage to ensure a file is only imported once (pattern for library files).",
      "references": [
        {
          "chunk": "preprocessor_intro_and_symbol_definitions",
          "topic": "how symbols control conditional imports (#importif)"
        }
      ]
    },
    {
      "start": 2579,
      "end": 2633,
      "name": "preprocessor_directives_reference_table",
      "description": "Section 8.4: Table of preprocessor directives (concise reference) listing #define, #undef, #import, #importif, #importonce, #if, #endif, #else, #elif and short descriptions for each directive.",
      "references": [
        {
          "chunk": "preprocessor_boolean_operators",
          "topic": "operators available inside preprocessor expressions (#if/#elif/#importif)"
        }
      ]
    },
    {
      "start": 2634,
      "end": 2663,
      "name": "preprocessor_boolean_operators",
      "description": "Section 8.5: Boolean operators available to the preprocessor (#if/#elif/#importif) — !, &&, ||, ==, != and parentheses, examples combining symbols and operators and sample uses with #importif.",
      "references": [
        {
          "chunk": "preprocessor_directives_reference_table",
          "topic": "list of preprocessor directives where these operators appear"
        }
      ]
    },
    {
      "start": 2664,
      "end": 2692,
      "name": "scopes_and_namespaces_scopes",
      "description": "Chapter 9 and Section 9.1: Scopes explained — containers for symbols (variables, constants, labels), creation of automatic scopes (macros) and manual scopes with {}, examples demonstrating variable isolation and scope-based symbol resolution behavior.",
      "references": [
        {
          "chunk": "scopes_and_namespaces_namespaces",
          "topic": "namespaces for functions/macros/pseudocommands described next"
        },
        {
          "chunk": "labels_argument_labels_and_multi_labels",
          "topic": "labels interplay with scopes"
        }
      ]
    },
    {
      "start": 2693,
      "end": 2726,
      "name": "scopes_and_namespaces_namespaces",
      "description": "Section 9.2: Namespaces explained — containers for functions, macros and pseudocommands (each namespace has its own associated scope), .namespace directive usage, examples showing reuse and re-declaration behaviors, and getNamespace() to query current namespace.",
      "references": [
        {
          "chunk": "scopes_and_namespaces_scopes",
          "topic": "how namespaces are tied to scope hierarchy"
        },
        {
          "chunk": "namespace_directives_and_filenamespace",
          "topic": ".filenamespace usage to place file content in a namespace"
        }
      ]
    },
    {
      "start": 2727,
      "end": 2769,
      "name": "scoping_hierarchy",
      "description": "Section 9.3: Detailed scoping and namespace hierarchy (System namespace/scope, Root namespace/scope, user namespaces, user scopes), symbol resolution algorithm walking up parent scopes/namespaces, examples demonstrating nested bracket scopes and how labels are resolved relative to current scope.",
      "references": [
        {
          "chunk": "scopes_and_namespaces_namespaces",
          "topic": "namespace resolution parallels scope resolution"
        },
        {
          "chunk": "labels_argument_labels_and_multi_labels",
          "topic": "examples of label resolution across nested scopes"
        }
      ]
    },
    {
      "start": 2770,
      "end": 2800,
      "name": "namespace_directives_and_filenamespace",
      "description": "Section 9.4: The .namespace directive and how it places symbols/labels inside a named namespace, examples of defining vic.* labels and using them (vic.borderColor), and .filenamespace to place an entire file's content into a namespace — usage example for file partitioning.",
      "references": [
        {
          "chunk": "scopes_and_namespaces_namespaces",
          "topic": "declaration and reuse of namespaces"
        },
        {
          "chunk": "front_matter_and_table_of_contents_ignored",
          "topic": "TOC references to Chapter 9 for namespace directives"
        }
      ]
    },
    {
      "start": 2801,
      "end": 2811,
      "name": "scope_hierarchy_and_symbol_resolution",
      "description": "Explains how Kick Assembler resolves symbols through nested scopes. Shows a small code fragment and states the resulting scope hierarchy (System <- Root <- BracketScope1 <- BracketScope2) and how 'jmp loop' resolves to the innermost label while 'jmp start' resolves to the root scope label.",
      "references": [
        {
          "chunk": "namespace_directive_and_namespace_field_access",
          "topic": "namespaces are related but resolved similarly"
        }
      ]
    },
    {
      "start": 2812,
      "end": 2826,
      "name": "namespace_directive_and_namespace_field_access",
      "description": "Describes the .namespace directive. Example: .namespace vic { .label borderColor = $d020 .label backgroundColor0 = $d021 .label backgroundColor1 = $d022 .label backgroundColor2 = $d023 }. Explains that declaring a namespace places a symbol in the parent scope and labels inside are accessed as fields (vic.borderColor etc).",
      "references": [
        {
          "chunk": "scope_hierarchy_and_symbol_resolution",
          "topic": "scope resolution behavior"
        },
        {
          "chunk": "filenamespace_example_files",
          "topic": "filenamespace for file-level namespaces"
        }
      ]
    },
    {
      "start": 2827,
      "end": 2836,
      "name": "namespace_usage_and_filenamespace_intro",
      "description": "Shows usage of namespace fields (lda #0; sta vic.backgroundColor0; sta vic.borderColor) and introduces the .filenamespace directive for placing everything in a file into a specified namespace.",
      "references": [
        {
          "chunk": "namespace_directive_and_namespace_field_access",
          "topic": "namespace field access examples"
        },
        {
          "chunk": "filenamespace_example_files",
          "topic": "detailed file examples using .filenamespace"
        }
      ]
    },
    {
      "start": 2837,
      "end": 2856,
      "name": "filenamespace_example_files",
      "description": "Demonstrates using .filenamespace to avoid name collisions across files. Example layout: /* FILE 0 */ calls to jsr part1.init etc, /* FILE 1 */ .filenamespace part1 with init/exec labels, and /* FILE 2 */ .filenamespace part2. Shows how placing .filenamespace at top of file scopes its labels.",
      "references": [
        {
          "chunk": "namespace_usage_and_filenamespace_intro",
          "topic": "intro to .filenamespace"
        }
      ]
    },
    {
      "start": 2857,
      "end": 2857,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2858,
      "end": 2866,
      "name": "escape_root_scope_with_at",
      "description": "Explains escaping the current scope using the '@' prefix to reference the root scope. Example: .label myLabel = 1 { .label myLabel = 2 .print \"scoped myLabel=\"+ myLabel (.-> 2) .print \"root myLabel=\"+ @myLabel (.-> 1) }",
      "references": [
        {
          "chunk": "scope_hierarchy_and_symbol_resolution",
          "topic": "scope resolution and escaping"
        }
      ]
    },
    {
      "start": 2867,
      "end": 2867,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2868,
      "end": 2875,
      "name": "escaping_functions_macros_and_pseudocommands_with_at",
      "description": "Shows that @ can be used to call root-scope functions/macros/pseudocommands from inside a namespace. Example: .function myFunction() { .return \"root\" } .namespace mySpace { .function myFunction() { .return \"mySpace\" } .print @myFunction() } — prints 'root'.",
      "references": [
        {
          "chunk": "escape_root_scope_with_at",
          "topic": "using @ to escape scope"
        }
      ]
    },
    {
      "start": 2876,
      "end": 2877,
      "ignore": true,
      "reason": "Standalone page number / blank lines; non-technical pagination artifact."
    },
    {
      "start": 2878,
      "end": 2890,
      "name": "define_root_scope_labels_from_inner_scope",
      "description": "Describes using '@' when defining labels inside a nested scope to place them into the root scope. Examples: jsr outside_label rts { @outside_label: lda #0 sta $d020 rts }",
      "references": [
        {
          "chunk": "escaping_functions_macros_and_pseudocommands_with_at",
          "topic": "using @ for functions/macros"
        }
      ]
    },
    {
      "start": 2891,
      "end": 2891,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2892,
      "end": 2920,
      "name": "placing_variables_and_library_definitions_in_root_scope",
      "description": "Shows more examples of using '@' to place variables and definitions in the root scope from within another scope. Examples: .label @x = 1234, .var @y = \"Hello world\", .const @z = true. Also shows a library file (mylib.lib) using .filenamespace MyLibrary with .function @myFunction(), .macro @MyMacro(), and .macro @MyPseudoCommand to export root-level entities.",
      "references": [
        {
          "chunk": "filenamespace_example_files",
          "topic": "library and filenamespace usage"
        }
      ]
    },
    {
      "start": 2921,
      "end": 2949,
      "name": "label_scopes_for_functions",
      "description": "Explains label scopes when a scope is declared after a label. Labels inside the scope can be accessed as fields of the label (e.g., clearScreen.fillbyte). Example subroutine 'clearScreen:' with inner label 'fillbyte' and use: lda #' ' ; sta clearScreen.fillbyte+1 ; jsr clearScreen ; rts. Demonstrates nesting and access.",
      "references": [
        {
          "chunk": "label_scope_label_directive_example",
          "topic": "alternate label directive example for fillbyte"
        }
      ]
    },
    {
      "start": 2950,
      "end": 2966,
      "name": "label_scope_label_directive_example",
      "description": "Shows using '.label fillbyte = *+1' inside a scoped label (ClearScreen2) so callers can store directly to clearScreen2.fillbyte without adding 1, and gives a full example filling screen memory and returning from subroutine.",
      "references": [
        {
          "chunk": "label_scopes_for_functions",
          "topic": "label-scope usage for function internals"
        }
      ]
    },
    {
      "start": 2967,
      "end": 2967,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2968,
      "end": 2974,
      "name": "nested_label_directive_access",
      "description": "Demonstrates nested label definitions using the label directive: .label mylabel1 = $1000 { .label mylabel2 = $1234 } and prints the nested value via mylabel1.mylabel2.",
      "references": [
        {
          "chunk": "label_scope_label_directive_example",
          "topic": "label directive examples"
        }
      ]
    },
    {
      "start": 2975,
      "end": 2995,
      "name": "access_local_labels_of_macros_and_pseudocommands",
      "description": "Explains how placing a label before executing a macro or pseudocommand creates a label scope array so you can reference inner labels of the executed macro. Example: start: c1: c2: *=$1000 inc c1.color dec c2.color :setColor() :setColor() jmp start and macro .macro setColor() { .label color = *+1 lda #0 sta $d020 } allowing increment/decrement of macro-created labels.",
      "references": [
        {
          "chunk": "label_scopes_for_functions",
          "topic": "label scopes concept"
        }
      ]
    },
    {
      "start": 2996,
      "end": 3001,
      "ignore": true,
      "reason": "Page number / form-feed marker; non-technical."
    },
    {
      "start": 3002,
      "end": 3015,
      "name": "access_local_labels_of_for_while_loops",
      "description": "Explains that placing a label in front of a .for or .while loop creates a label-scope array so inner loop labels are accessible from outside or between loops. Example: .for (var i=0; i<20; i++) { lda #i sta loop2[i].color+1 } loop2: color: and another .for to clear colors.",
      "references": [
        {
          "chunk": "access_local_labels_of_macros_and_pseudocommands",
          "topic": "label scopes for different constructs"
        }
      ]
    },
    {
      "start": 3016,
      "end": 3016,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3017,
      "end": 3032,
      "name": "access_local_labels_of_ifs",
      "description": "Shows label scope behavior for .if directives. Placing a label before an .if creates access to labels defined only in the taken branch. If the condition is false and no else-branch exists, references to symbols in the taken branch raise 'symbol undefined'. Example: jmp myIf.label myIf: .if (true) { label: lda #0 } else { label: nop }",
      "references": [
        {
          "chunk": "access_local_labels_of_for_while_loops",
          "topic": "control-structure label scopes"
        }
      ]
    },
    {
      "start": 3033,
      "end": 3036,
      "ignore": true,
      "reason": "Page number / form-feed marker; non-technical."
    },
    {
      "start": 3037,
      "end": 3058,
      "name": "segments_introduction_and_overview",
      "description": "Chapter 10 introduction to segments. Describes segments as lists of memory blocks used to organize code/data and define ordering. Explains modifiers, combining segments, directing output to files/disks, and backward compatibility (default segment). Shows a simple example writing a section to a separate file: .segment File1 [outPrg=\"MyFile.prg\"] *=$1000 lda #00 ... .segment Default",
      "references": [
        {
          "chunk": "memory_blocks_and_default_block_examples",
          "topic": "memory blocks that compose segments"
        }
      ]
    },
    {
      "start": 3059,
      "end": 3066,
      "name": "segment_patch_example",
      "description": "Example of patching a file by loading it into a Base segment, placing a Patch segment on top, and writing the result: .file [name=\"Out.prg\", segments=\"Base,Patch\", allowOverlap] .segment Base [prgFiles=\"basefile.prg\"] .segment Patch [] *=$8021 \"Insert jump\" jmp $8044",
      "references": [
        {
          "chunk": "overlapping_memory_block",
          "topic": "allowOverlap for patches"
        }
      ]
    },
    {
      "start": 3067,
      "end": 3077,
      "name": "cartridge_banks_example",
      "description": "Example assembling cartridge banks into a single binary. Shows .segment CARTRIDGE_FILE [outBin=\"myfile.bin\"] with .segmentout for BANK1..BANK4 and .segmentdef BANK1..BANK4 [min=$1000, max=$1fff, fill], then code sections for each BANKx restricted to $1000-$1fff.",
      "references": [
        {
          "chunk": "segments_introduction_and_overview",
          "topic": "alternative outputs using segments"
        }
      ]
    },
    {
      "start": 3078,
      "end": 3120,
      "name": "memory_blocks_and_default_block_examples",
      "description": "Describes memory blocks (created when using *=). Memory block properties: start address, optional name, virtual flag. If code added without *= a default block is created. Examples: inc $d020; jmp *-3 (default block), *= $1000 lda #1 ...; *= $4000 \"block3\" lda #2 ...; explanation that, unless a segment is selected, blocks go to 'Default' segment.",
      "references": [
        {
          "chunk": "defining_segments_and_switching",
          "topic": "how blocks are assigned to segments"
        }
      ]
    },
    {
      "start": 3121,
      "end": 3156,
      "name": "defining_segments_and_switching",
      "description": "Shows defining segments with .segmentdef and selecting segments with .segment. Examples: .segmentdef MySegment1 .segmentdef MySegment2 [start=$1000] then .segment MySegment1 *=$4000 ldx #30 ... .segment MySegment2 inc $d021 jmp *-3. Explains you can switch back to a segment anytime and continue adding to its current memory block.",
      "references": [
        {
          "chunk": "memory_blocks_and_default_block_examples",
          "topic": "memory blocks form segments"
        }
      ]
    },
    {
      "start": 3157,
      "end": 3166,
      "name": "segment_definition_shorthand_and_once_only",
      "description": "Explains shorthand of defining a segment and creating a default memory block at the same time by adding parameter block to .segment (e.g., .segment MySegment [start=$1000]) which is equivalent to .segmentdef MySegment [start=$1000] then .segment MySegment. Notes a segment can only be defined once.",
      "references": [
        {
          "chunk": "defining_segments_and_switching",
          "topic": "defining segments versus switching"
        }
      ]
    },
    {
      "start": 3167,
      "end": 3167,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3168,
      "end": 3189,
      "name": "segment_output_and_bytedump_example",
      "description": "Explains that defining segments alone produces no output unless directed. Describes -bytedump command-line option producing ByteDump.txt showing bytes per segment. Example byte dump for Default, MySegment1 and MySegment2 with addresses and opcodes.",
      "references": [
        {
          "chunk": "writing_segments_to_files",
          "topic": "how to write segments to files"
        }
      ]
    },
    {
      "start": 3190,
      "end": 3198,
      "name": "writing_segments_to_files",
      "description": "Explains simplest ways to output segments to files using parameters outPrg (outputs .prg) and outBin (binary). Example: .segment Code [outPrg=\"colors.prg\"] *=$1000 inc $d020 jmp *-3.",
      "references": [
        {
          "chunk": "segment_output_and_bytedump_example",
          "topic": "byte dump vs file output"
        }
      ]
    },
    {
      "start": 3199,
      "end": 3205,
      "name": "default_segment_behavior",
      "description": "Explains the 'Default' segment: if you don't use .segment code is placed on 'Default' segment which is connected to standard output file. To return to Default segment, use .segment Default.",
      "references": [
        {
          "chunk": "segments_introduction_and_overview",
          "topic": "default behavior without segments"
        }
      ]
    },
    {
      "start": 3206,
      "end": 3223,
      "name": "naming_memory_blocks_when_switching_segment",
      "description": "Describes shorthand for naming memory blocks while switching segments by placing a text string after .segment (e.g., .segment Code \"My Code\" is same as .segment Code then .memblock \"My Code\").",
      "references": [
        {
          "chunk": "segment_naming_and_example_project",
          "topic": "example project using named blocks"
        }
      ]
    },
    {
      "start": 3224,
      "end": 3264,
      "name": "segment_naming_and_example_project",
      "description": "Large example showing .segmentdef Code [start=$0900] .segmentdef Data [start=$8000] .file [name=\"segments.prg\", segments=\"Code,Data\", modify=\"BasicUpstart\", marg1=$0900] and multiple named .segment Code \"Main\", .segment Data \"Colors\", .segment Code \"Text Setup\" with text/data separated and memory labels (colors:.byte LIGHT_GRAY,DARK_GRAY; text:.text \"hello world!\" .byte $ff). Demonstrates placing code and data close in source but separated in memory.",
      "references": [
        {
          "chunk": "naming_memory_blocks_when_switching_segment",
          "topic": "using text names for memblocks"
        },
        {
          "chunk": "memory_map_and_scope_segments",
          "topic": "resulting memory map"
        }
      ]
    },
    {
      "start": 3265,
      "end": 3265,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3266,
      "end": 3284,
      "name": "memory_map_and_scope_segments",
      "description": "Example memory map produced by -showmem option for the previous example: Code-segment ranges and Data-segment ranges. Notes that scoping and segments don't affect each other (labels can be local inside different segments).",
      "references": [
        {
          "chunk": "segment_naming_and_example_project",
          "topic": "shows how source separation maps to memory"
        }
      ]
    },
    {
      "start": 3285,
      "end": 3285,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3286,
      "end": 3311,
      "name": "default_memory_block_and_startAfter_usage",
      "description": "Explains the default memory block of a segment and controlling start address via parameters when .segmentdef is used (e.g., .segmentdef MySegment2 [start=$1000]). Describes startAfter parameter to make one segment start after another: .segmentdef Data [startAfter=\"Code\"]. Useful for reusing memory for init code vs buffer.",
      "references": [
        {
          "chunk": "segment_naming_and_example_project",
          "topic": "organizing code/data for memory savings"
        }
      ]
    },
    {
      "start": 3312,
      "end": 3334,
      "name": "align_and_virtual_memory_blocks",
      "description": "Shows using 'align' parameter with startAfter to align default memory block, and 'virtual' flag to make memory blocks virtual (thrown away). Example: .segmentdef Virtual100 [startAfter=\"Code\", align=$100, virtual] and usage with .segment Virtual100 \"Table\" table: .fill $100,0. Memory map shows Virtual100 start aligned to $100 boundary.",
      "references": [
        {
          "chunk": "default_memory_block_and_startAfter_usage",
          "topic": "startAfter and alignment use cases"
        }
      ]
    },
    {
      "start": 3335,
      "end": 3338,
      "ignore": true,
      "reason": "Page number / form-feed; non-technical."
    },
    {
      "start": 3339,
      "end": 3351,
      "name": "segment_after_and_priority_rules",
      "description": "Explains that startAfter uses the last defined memory block (default or user defined via *=). Notes blocks included by other methods (imported, included from files) are not considered when computing startAfter.",
      "references": [
        {
          "chunk": "align_and_virtual_memory_blocks",
          "topic": "alignment and virtual usage details"
        }
      ]
    },
    {
      "start": 3352,
      "end": 3352,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3353,
      "end": 3368,
      "name": "including_other_segments",
      "description": "Shows including memory blocks from other segments via the 'segments' parameter in .segmentdef (e.g., .segmentdef Combi1 [segments=\"Code, Data\"]). A segment can be included in multiple other segments. Can be combined with adding code or commands inside the segment.",
      "references": [
        {
          "chunk": "prg_files_import",
          "topic": "including prg files into segments"
        }
      ]
    },
    {
      "start": 3369,
      "end": 3383,
      "name": "prg_files_import",
      "description": "Explains importing .prg files as memory blocks using prgFiles parameter (e.g., .segmentdef Misc1 [prgFiles=\"data/Music.prg, data/Charset2x2.prg\"]) or using .import c64 to place prg contents after an explicit *= address.",
      "references": [
        {
          "chunk": "including_other_segments",
          "topic": "combining imported blocks with other segments"
        }
      ]
    },
    {
      "start": 3384,
      "end": 3390,
      "name": "sid_files_import",
      "description": "Notes sid files can be imported as memory blocks using 'sidFiles' parameter. Example: .segment Main [sidFiles=\"data/music.sid\", outPrg=\"out.prg\"].",
      "references": [
        {
          "chunk": "sid_example_starter_code",
          "topic": "example usage of sid imports"
        }
      ]
    },
    {
      "start": 3391,
      "end": 3393,
      "ignore": true,
      "reason": "Page number / form-feed; non-technical."
    },
    {
      "start": 3394,
      "end": 3412,
      "name": "basic_upstart2_example_code",
      "description": "Code example labeled BasicUpstart2(start) showing standard start-up: sei, lda #00, tax, tay, jsr $1000; main loop polling $d012 and calling $1003 with inc/dec $d020 etc. Demonstrates embedding code in segments and typical IRQ/loop patterns.",
      "references": [
        {
          "chunk": "sid_files_import",
          "topic": "embedding sid playback or external subroutines"
        }
      ]
    },
    {
      "start": 3413,
      "end": 3440,
      "name": "segment_boundaries_min_max_and_fill",
      "description": "Explains 'min' and 'max' parameters to enforce segment address ranges and that exceeding them raises errors. Demonstrates 'fill' parameter to fill unused bytes in min-max range with a fill byte, and 'fillByte' to specify the byte. Gives example of restricting size e.g. 128 bytes competition entry where .segment Main [min=$0801, max=$0880-2, outPrg=\"out.prg\"] is used.",
      "references": [
        {
          "chunk": "rotated_rom_font_128b_example",
          "topic": "example of enforcing small prg size"
        }
      ]
    },
    {
      "start": 3441,
      "end": 3491,
      "name": "rotated_rom_font_128b_example",
      "description": "A submitted 128-byte font example that rotates the ROM font 90 degrees. Shows .segment Main [min=$0801, max=$0880-2, outPrg=\"out.prg\"] .label SCREEN = $400 .label CHARGEN = $d000 .label CHARSET = $3000 and code with BasicUpstart placements and character/pixel loops. Illustrates tight size constraint and use of labels/constants.",
      "references": [
        {
          "chunk": "segment_boundaries_min_max_and_fill",
          "topic": "constraints and fill options for enforcing sizes"
        }
      ]
    },
    {
      "start": 3492,
      "end": 3492,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3493,
      "end": 3519,
      "name": "overlapping_memory_block",
      "description": "Explains detection of overlaps when assembling segments. By default overlaps give errors; can allow with 'allowOverlap' parameter (useful for patching). Example shows .file [name=\"patched.prg\", segments=\"Base,Patch\", allowOverlap] with .segmentdef Base [prgFiles=\"data/base.prg\"] and .segment Patch [] using *= to insert jumps/ldas. Explains how overlapping blocks are resolved by priority (latest added wins).",
      "references": [
        {
          "chunk": "segment_patch_example",
          "topic": "patch mechanism using allowOverlap"
        }
      ]
    },
    {
      "start": 3520,
      "end": 3538,
      "name": "segment_modifiers_intro",
      "description": "Introduces segment modifiers: functions that take memory blocks and output modified blocks (e.g., packers/crunchers). Explains built-in 'BasicUpstart' modifier that adds a $0801 basic upstart block to jump to a start address, controlled via the 'modify' parameter with modifier arguments prefixed by underscore (e.g., .segment Code [start=$8000, modify=\"BasicUpstart\", _start=$8000]). Users can write modifiers as plug-ins.",
      "references": [
        {
          "chunk": "built_in_modifiers_list",
          "topic": "list of built-in modifiers"
        },
        {
          "chunk": "modify_directives",
          "topic": "using modifiers via .modify and .filemodify"
        }
      ]
    },
    {
      "start": 3539,
      "end": 3554,
      "name": "built_in_modifiers_list",
      "description": "Mentions built-in modifiers; specifically lists BasicUpstart with parameter _start which adds a memory block with a basic upstart program pointing to the specified address.",
      "references": [
        {
          "chunk": "segment_modifiers_intro",
          "topic": "BasicUpstart usage"
        }
      ]
    },
    {
      "start": 3555,
      "end": 3565,
      "name": "intermediate_segments_explained",
      "description": "Explains intermediate segments used when segments are referenced by other directives (e.g., .file). The .file directive uses an implicit intermediate segment so you can pass parameters similar to .segment/.segmentdef. The 'name' parameter is special to the .file directive; other parameters are standard intermediate parameters.",
      "references": [
        {
          "chunk": "segmentout_directive_and_zeropage_example",
          "topic": "using .segmentout with intermediate segments"
        }
      ]
    },
    {
      "start": 3566,
      "end": 3593,
      "name": "segmentout_directive_and_zeropage_example",
      "description": "Explains .segmentout directive which places bytes of an intermediate segment in the current memory block (useful for reallocating code/data and alternate outputs). Example: copying code into zeropage: zpCode: .segmentout [segments=\"ZeroPage_Code\"] .label zpCodeSize = *-zpCode and .segment ZeroPage_Code [start=$10] zpStart: inc $d020 jmp *-3. Code demonstrates copying zeropage code into a main block.",
      "references": [
        {
          "chunk": "intermediate_segments_explained",
          "topic": "segmentout uses intermediate segments"
        }
      ]
    },
    {
      "start": 3594,
      "end": 3612,
      "name": "segmentout_memory_map_and_sid_example",
      "description": "Shows memory map output for .segmentout example: Default segment entries and ZeroPage_Code-segment at $0010-$0015. Shows that intermediate parameters (like sidFiles) can be used with .segmentout to place data at alternative addresses (example: *=$8000 .segmentout [sidFiles=\"data/music.sid\"]).",
      "references": [
        {
          "chunk": "segmentout_directive_and_zeropage_example",
          "topic": "memory map result of .segmentout"
        }
      ]
    },
    {
      "start": 3613,
      "end": 3621,
      "name": "debugger_data_dest_parameter",
      "description": "Describes 'dest' parameter on .segmentdef to mark segments with a destination (e.g., 'DISKDRIVE', 'BANK1') to be used by debuggers for organizing debug data. The parameter is informational and interpreted by debuggers.",
      "references": []
    },
    {
      "start": 3622,
      "end": 3676,
      "name": "segment_parameters_part1",
      "description": "Segment parameter reference (part 1): align (align=$100 aligns default memory block), allowOverlap (allowOverlap allows overlapping blocks), dest (dest=\"1541\" sets destination for debugging), fill (fills unused bytes between min and max), fillByte (fillByte=$88 sets fill byte), hide (hide hides segment in memory dumps), marg1..marg5 (arguments for a modifier).",
      "references": [
        {
          "chunk": "segment_parameters_part2",
          "topic": "continuation of parameter list"
        }
      ]
    },
    {
      "start": 3677,
      "end": 3724,
      "name": "segment_parameters_part2",
      "description": "Segment parameter reference (part 2): max (max=$cfff set max address), min (min=$c000 set min address), modify (modify=\"BasicUpstart\" assigns modifier), outBin (outBin=\"myfile.bin\" outputs binary), outPrg (outPrg=\"myfile.prg\" outputs prg), prgFiles (import PRG files), segments (segments=\"Code, Data\" include other segments).",
      "references": [
        {
          "chunk": "segment_parameters_part3",
          "topic": "remaining parameters"
        }
      ]
    },
    {
      "start": 3725,
      "end": 3806,
      "name": "segment_parameters_part3",
      "description": "Segment parameter reference (part 3): sidFiles (include SID files), start (start=$1000 sets start of default memory block), startAfter (startAfter=\"Code\" makes default memory block start after other segment), virtual (virtual makes memory blocks virtual). Explains parameter semantics and examples.",
      "references": [
        {
          "chunk": "segment_parameters_part1",
          "topic": "see earlier listed segment parameters"
        }
      ]
    },
    {
      "start": 3807,
      "end": 3819,
      "name": "prg_and_d64_intro",
      "description": "Chapter 11 introduction: creating PRG files and D64 disk images using .file and .disk directives. .file saves to file, .disk can create disk images by assembling or selecting hard-disk files. Mentions built-in disk writer based on CC1541 and support for plugin writers.",
      "references": [
        {
          "chunk": "disk_directive_usage",
          "topic": "how to use .disk directive"
        }
      ]
    },
    {
      "start": 3820,
      "end": 3827,
      "name": "parameter_maps_syntax",
      "description": "Explains parameter maps used by .file and .disk: square brackets with comma-separated parameters like [name=\"Bob\", age=27, useGlasses=false, wearsTshirt]. Unassigned trailing parameter (wearsTshirt) is shorthand for boolean true.",
      "references": [
        {
          "chunk": "file_directive_examples",
          "topic": "file directive uses parameter maps"
        }
      ]
    },
    {
      "start": 3828,
      "end": 3856,
      "name": "file_directive_examples",
      "description": "Usage of .file directive with examples: .file [name=\"MyFile.prg\", segments=\"Code\"]; .file [name=\"MyFile.bin\", type=\"bin\", segments=\"Code,Data\"]; .file [name=\"Data.prg\", mbfiles, segments=\"Data\"] demonstrating %o replacement for root filename. Includes example segments Code and Data with BasicUpstart2(start), code/data fills for 'Mul3' and 'Sinus'.",
      "references": [
        {
          "chunk": "file_directive_content_and_params_intro",
          "topic": "file directive parameter details"
        }
      ]
    },
    {
      "start": 3857,
      "end": 3863,
      "name": "file_directive_content_and_params_intro",
      "description": "Explains that .file uses an intermediate segment for content making it flexible; name parameter is mandatory and other parameters optional. Introduces Table 11.1 listing file directive parameters.",
      "references": [
        {
          "chunk": "file_directive_examples",
          "topic": "example usage"
        }
      ]
    },
    {
      "start": 3864,
      "end": 3896,
      "name": "file_directive_parameters_table",
      "description": "Table 11.1: File directive parameters: mbfiles (if true create a file for each memory block), name (filename, %o substitution), type (\"prg\" or \"bin\").",
      "references": []
    },
    {
      "start": 3897,
      "end": 3909,
      "name": "disk_directive_usage",
      "description": "Describes .disk directive format: .disk OPT_WRITERNAME [...DISK PARAMETERS..] { [..FILE1 PARAMETERS..], [..FILE2 PARAMETERS..], ... } The writer name is optional: default writer used otherwise plugin writer looked up. Default writer based on CC1541; plugins can supply other writers.",
      "references": [
        {
          "chunk": "disk_parameters_part1",
          "topic": "disk parameters explained next"
        }
      ]
    },
    {
      "start": 3910,
      "end": 3922,
      "name": "simple_disk_examples",
      "description": "Shows simple disk creation examples: .disk [filename=\"MyDisk.d64\"] {} and .disk [filename=\"MyDisk.d64\", name=\"THE DISK\", id=\"2021!\"] {}. Explains %o substitution for source filename.",
      "references": [
        {
          "chunk": "disk_directive_usage",
          "topic": "basic .disk usage"
        }
      ]
    },
    {
      "start": 3923,
      "end": 3996,
      "name": "disk_parameters_part1",
      "description": "Disk parameters table (part 1): dontSplitFilesOverDir (false), filename (disk image name), format (\"commodore\" default, options: \"commodore\",\"speeddos\",\"dolphindos\"), id (disk id), interleave (default interleave e.g. 10), name (disk name).",
      "references": [
        {
          "chunk": "disk_parameters_part2",
          "topic": "remaining disk parameters"
        }
      ]
    },
    {
      "start": 3997,
      "end": 4016,
      "name": "disk_parameters_part2",
      "description": "Disk parameters table (part 2): showInfo (prints detailed info after creation), storeFilesInDir (allow storing files in directory track sectors).",
      "references": []
    },
    {
      "start": 4017,
      "end": 4056,
      "name": "file_parameters_and_examples",
      "description": "Shows adding files from different sources to a disk with .disk and a list of file parameter maps. Examples include prg files from segments, prg from prgFiles on disk, sid files, hidden files (hide), locked files (type=\"prg<\"). Also shows .segment definitions (BORDER_COLORS, BACK_COLORS, HIDDEN) used as intermediate segments providing file contents.",
      "references": [
        {
          "chunk": "file_directive_examples",
          "topic": "file content comes from intermediate segments"
        }
      ]
    },
    {
      "start": 4057,
      "end": 4120,
      "name": "general_file_parameters_table",
      "description": "Table 11.3 General file parameters: hide (if true file not shown in directory), interleave (file interleave), name (filename), noStartAddr (if true two address bytes are not added to beginning of file), type (file type: \"del\",\"seq\",\"prg\",\"usr\",\"rel\"; append '<' to mark locked).",
      "references": []
    },
    {
      "start": 4121,
      "end": 4131,
      "name": "custom_disk_writers_plugins",
      "description": "Describes custom disk writers implemented as plugins and how to call them: .plugin \"myplugins.Mydiskwriter\" then .disk MyDiskWriter [.. disk params..] { [ ..file params.., segments=\"Code,Data\"], [ ..file params.., prgFiles=\"data/music.prg\"] }.",
      "references": [
        {
          "chunk": "3rd_party_java_plugins_intro",
          "topic": "plugins chapter covers plugin creation"
        }
      ]
    },
    {
      "start": 4132,
      "end": 4134,
      "ignore": true,
      "reason": "Page number / form-feed; non-technical."
    },
    {
      "start": 4135,
      "end": 4138,
      "name": "import_and_export_chapter_intro",
      "description": "Chapter 12 header: introduces methods for importing/exporting data to/from Kick Assembler (command line args, binary files, SID, graphics conversion, file creation, symbol export).",
      "references": []
    },
    {
      "start": 4139,
      "end": 4151,
      "name": "passing_command_line_arguments",
      "description": "Explains passing string values to script via command-line using ':' notation (e.g., java –jar KickAss.jar mySource.asm :x=27 :sound=true :title=\"Beta 2\"). Values are available in cmdLineVars hashtable. Example usage: .print \"version =\" + cmdLineVars.get(\"version\") ; .var x = cmdLineVars.get(\"x\").asNumber(); .var sound = cmdLineVars.get(\"sound\").asBoolean();",
      "references": []
    },
    {
      "start": 4152,
      "end": 4164,
      "name": "import_of_binary_files_loadbinary",
      "description": "Explains LoadBinary function for loading arbitrary files into a variable. Example: .var data = LoadBinary(\"myDataFile\") and then myData: .fill data.getSize(), data.get(i). Notes get returns signed Java bytes and uget returns unsigned bytes. Also getSize and get functions available.",
      "references": [
        {
          "chunk": "binary_file_templates_and_c64file",
          "topic": "using templates and C64FILE tag"
        }
      ]
    },
    {
      "start": 4165,
      "end": 4176,
      "name": "binary_file_templates_and_c64file",
      "description": "Explains providing a template string to LoadBinary to describe memory blocks inside the file so returned value has getXSize/getX functions per block. Example template: \"Xcoord=0,Ycoord=$100, BounceData=$200\" and special template tag 'C64FILE' which tells LoadBinary to ignore the first two address bytes of native C64 files.",
      "references": [
        {
          "chunk": "import_of_binary_files_loadbinary",
          "topic": "LoadBinary usage and templates"
        }
      ]
    },
    {
      "start": 4177,
      "end": 4217,
      "name": "koala_picture_example_and_screen_allocation",
      "description": "Example loading a Koala Paint picture into memory with LoadBinary and placing it on screen: .var picture = LoadBinary(\"picture.prg\", KOALA_TEMPLATE) and code showing BasicUpstart, copying color/bitmap/screenram using .fill picture.getScreenRamSize(), picture.getScreenRam(i) etc. Demonstrates reallocation of screen and color RAM using *= and .fill directives.",
      "references": [
        {
          "chunk": "binary_file_constants",
          "topic": "use constants for formats like BF_KOALA"
        }
      ]
    },
    {
      "start": 4218,
      "end": 4264,
      "name": "binary_file_constants",
      "description": "Lists built-in BinaryFile constants for common formats: BF_C64FILE (C64 file skipping first two bytes), BF_BITMAP_SINGLECOLOR (ScreenRam,Bitmap), BF_KOALA (Bitmap,ScreenRam,ColorRam,BackgroundColor for Koala Paint), BF_FLI, BF_DOODLE, etc. Example: .var fliPicture = LoadBinary(\"GreatPicture\", BF_FLI). Tip: print constants with .print \"Koala format=\"+BF_KOALA.",
      "references": [
        {
          "chunk": "koala_picture_example_and_screen_allocation",
          "topic": "usage with LoadBinary"
        }
      ]
    },
    {
      "start": 4265,
      "end": 4276,
      "name": "import_of_sid_files_intro",
      "description": "Introduces LoadSid function to import SID files (HVSC format). Example: .var music = LoadSid(\".../Closing_In.sid\") to extract init/play addresses and metadata.",
      "references": [
        {
          "chunk": "sid_file_properties_and_usage",
          "topic": "SID properties and how to use them"
        }
      ]
    },
    {
      "start": 4277,
      "end": 4350,
      "name": "sid_file_properties_and_usage",
      "description": "Table ofSIDFileValue properties accessible via LoadSid: header (PSID/RSID), version, location, init, play, songs, startSong, name, author, copyright, speed, flags, startpage, pagelength, size, getData(n) to extract bytes. Explains you can extract and store module binary data with getData and size.",
      "references": [
        {
          "chunk": "sid_player_example",
          "topic": "example player using LoadSid values"
        }
      ]
    },
    {
      "start": 4351,
      "end": 4420,
      "name": "sid_player_example",
      "description": "A complete example building a SID player using .var music = LoadSid(\"Nightshift.sid\"), BasicUpstart2(start), calls to music.init and music.play, setting up IRQ vector to irq1 which calls music.play, and placing SID data with .fill music.size, music.getData(i). Also prints SID metadata while assembling (location, init, play, songs, name, author, flags, etc.).",
      "references": [
        {
          "chunk": "sid_file_properties_and_usage",
          "topic": "properties used in player example"
        }
      ]
    },
    {
      "start": 4421,
      "end": 4453,
      "name": "hvsc_and_libdir_tip",
      "description": "Tip: use -libdir option to point to HVSC main directory to avoid long filenames. Example: .var music = LoadSid(\"Tel_Jeroen/Closing_In.sid\") when libdir is set.",
      "references": [
        {
          "chunk": "sid_player_example",
          "topic": "convenience for LoadSid filenames"
        }
      ]
    },
    {
      "start": 4454,
      "end": 4484,
      "name": "converting_graphics_with_loadpicture",
      "description": "Explains LoadPicture to convert GIF/JPG to C64 formats. Examples: single color logo placement: *=$2000 .var logo = LoadPicture(\"CML_32x8.gif\") .fill $800, logo.getSinglecolorByte((i>>3)&$1f, (i&7) | (i>>8)<<3). Shows alternative loops and using a color table (List().add(RGB values)) for multi-color conversion: .var picture = LoadPicture(\"Picture_16x16.gif\", List().add($444444,$6c6c6c,$959595,$000000)) .fill $800, picture.getMulticolorByte(i>>7,i&$7f). Also mentions picture.getPixel(x,y) for extracting RGB.",
      "references": [
        {
          "chunk": "picturevalue_functions",
          "topic": "functions available on picture values"
        }
      ]
    },
    {
      "start": 4485,
      "end": 4525,
      "name": "picturevalue_functions",
      "description": "Table of PictureValue functions and attributes: width, height, getPixel(x,y) returns RGB, getSinglecolorByte(x,y) converts 8 pixels to a single-color byte using a color table, getMulticolorByte(x,y) converts 4 pixels to a multicolor byte (ignores every second pixel).",
      "references": [
        {
          "chunk": "converting_graphics_with_loadpicture",
          "topic": "practical conversion usage"
        }
      ]
    },
    {
      "start": 4526,
      "end": 4526,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4527,
      "end": 4535,
      "name": "writing_to_user_defined_files_createfile",
      "description": "Explains createFile function to create/overwrite host files from script. Example: .var myFile = createFile(\"breakpoints.txt\") .eval myFile.writeln(\"Hello World\"). Note: for security you must use -afo switch when running Kick Assembler to allow file creation.",
      "references": [
        {
          "chunk": "breakpoints_file_example",
          "topic": "example writing breakpoints file"
        }
      ]
    },
    {
      "start": 4536,
      "end": 4551,
      "name": "breakpoints_file_example",
      "description": "Example generating a breakpoint file for VICE: .var brkFile = createFile(\"breakpoints.txt\") .macro break() { .eval brkFile.writeln(\"break \" + toHexString(*)) } and using break() inside code to emit breakpoint entries. Explains running VICE with breakpoint file via -moncommands to run until break and enter monitor.",
      "references": [
        {
          "chunk": "writing_to_user_defined_files_createfile",
          "topic": "file creation security and usage"
        }
      ]
    },
    {
      "start": 4552,
      "end": 4569,
      "name": "filevalue_functions_writeln",
      "description": "Table of FileValue functions: writeln(text) writes text and newline, writeln() inserts blank line. Used on values returned by createFile.",
      "references": []
    },
    {
      "start": 4570,
      "end": 4596,
      "name": "exporting_labels_to_symbolfile",
      "description": "Explains exporting assembled symbols to a .sym file using –symbolfile option (java –jar KickAss.jar source1.asm –symbolfile) producing source1.sym with namespace and label declarations (e.g. .namespace source1 { .label clearColor = $2000 }). Shows importing the .sym file to refer to labels from another file via .import source \"source1.sym\" and using jsr source1.clearColor.",
      "references": []
    },
    {
      "start": 4597,
      "end": 4600,
      "name": "exporting_labels_to_vice",
      "description": "Explains exporting labels to a VICE-readable .vs file using –vicesymbols option (java –jar KickAss.jar source1.asm –vicesymbols).",
      "references": []
    },
    {
      "start": 4601,
      "end": 4626,
      "name": "modifiers_chapter_and_modify_directives_intro",
      "description": "Chapter 13 intro to Modifiers: plugins that modify assembled bytes before storage (encrypt, pack, crunch). Explains .filemodify MyModifier(25) to modify whole file and .modify MyModifier() { ... } to modify a local block. Gives example using *= and .fill inside .modify block.",
      "references": [
        {
          "chunk": "segment_modifiers_intro",
          "topic": "segment-level modifiers vs .modify for local blocks"
        }
      ]
    },
    {
      "start": 4627,
      "end": 4630,
      "ignore": true,
      "reason": "Page number / form-feed; non-technical."
    },
    {
      "start": 4631,
      "end": 4666,
      "name": "special_features_name_path_and_basic_upstart",
      "description": "Chapter 14 Special Features. Shows getPath() and getFilename() to get source file path and name. Introduces BasicUpstart and BasicUpstart2 macros to create a tiny BASIC stub that SYSs into assembled machine code (examples of *= $0801 BasicUpstart(start) and BasicUpstart2 for simpler use). Mentions autoinclude.asm for macro definitions in KickAss.jar.",
      "references": [
        {
          "chunk": "basic_upstart2_example_code",
          "topic": "BasicUpstart2 example used earlier"
        }
      ]
    },
    {
      "start": 4667,
      "end": 4680,
      "name": "opcode_constants_and_asmcommandsize",
      "description": "Explains opcode constants (mnemonic uppercase with addressing mode suffix) for self-modifying code e.g., RTS, LDA_IMM, LDA_ABS. Use asmCommandSize(RTS) to get size of an opcode (e.g., RTS=1, LDA_IMM=2, LDA_ABS=3).",
      "references": [
        {
          "chunk": "addressing_modes_table",
          "topic": "addressing modes list and examples"
        }
      ]
    },
    {
      "start": 4681,
      "end": 4790,
      "name": "addressing_modes_table",
      "description": "Table of addressing modes and example constants: None (RTS), IMM (LDA_IMM - lda #$30), ZP (LDA_ZP - lda $30), ZPX (LDA_ZPX), ZPY (LDX_ZPY), IZPX (LDA_IZPX - lda ($30,x)), IZPY (LDA_IZPY - lda ($30),y), ABS (LDA_ABS - lda $1000), ABSX (LDA_ABSX), ABSY (LDA_ABSY), IND (JMP_IND - jmp ($1000)), REL (BNE_REL - bne loop).",
      "references": [
        {
          "chunk": "opcode_constants_and_asmcommandsize",
          "topic": "use asmCommandSize with these constants"
        }
      ]
    },
    {
      "start": 4791,
      "end": 4868,
      "name": "colour_constants",
      "description": "C64 colour constants built into Kick Assembler (Table 14.2): BLACK=0, WHITE=1, RED=2, CYAN=3, PURPLE=4, GREEN=5, BLUE=6, YELLOW=7, ORANGE=8, BROWN=9, LIGHT_RED=10, DARK_GRAY/DARK_GREY=11, GRAY/GREY=12, LIGHT_GREEN=13, LIGHT_BLUE=14, LIGHT_GRAY/LIGHT_GREY=15. Example usage: lda #BLACK sta $d020 ; lda #WHITE sta $d021.",
      "references": []
    },
    {
      "start": 4869,
      "end": 4889,
      "name": "making_3d_calculations_intro",
      "description": "Introduces vector and matrix values to help with 3D calculations. Vector created with Vector(x,y,z). Examples: .var v1 = Vector(1,2,3) .var v2 = Vector(0,0,2). Vectors support arithmetic operators and functions (getX,getY,getZ, +, -, scaling, dot product, cross product X()).",
      "references": [
        {
          "chunk": "vector_value_functions",
          "topic": "list of vector functions/operators"
        },
        {
          "chunk": "matrix_value_constructors",
          "topic": "matrix constructors and usage"
        }
      ]
    },
    {
      "start": 4890,
      "end": 4960,
      "name": "vector_value_functions",
      "description": "Table of vector functions/operators: get(n), getX(), getY(), getZ(), + (vector addition), - (subtraction), * Number (scale), * Vector (dot product), / (divide by scalar), X(v) (cross product). Also introduces Matrix() creation and get/set for 4x4 matrices plus further constructors.",
      "references": [
        {
          "chunk": "making_3d_calculations_intro",
          "topic": "vector basics and examples"
        }
      ]
    },
    {
      "start": 4961,
      "end": 5014,
      "name": "matrix_value_constructors_and_usage",
      "description": "Describes Matrix() identity matrix and constructor helpers: RotationMatrix(aX,aY,aZ) (angles in radians), ScaleMatrix(sX,sY,sZ), MoveMatrix(mX,mY,mZ), PerspectiveMatrix(zProj). Explains combining matrices by multiplication (read right to left) and transforming vectors via m*Vector(x,y,z).",
      "references": [
        {
          "chunk": "vector_value_functions",
          "topic": "apply matrices to vectors"
        }
      ]
    },
    {
      "start": 5015,
      "end": 5089,
      "name": "precalculate_cube_animation_with_matrices",
      "description": "A full example using Vector and Matrix utilities to precalculate an animation of a rotating cube and project it to plane z=2.5. Defines Cube list of 8 vectors, macro PrecalcObject(object, animLength, nrOfXrot, nrOfYrot, nrOfZrot) that computes frames by building transformation matrix m=ScaleMatrix*PerspectiveMatrix*MoveMatrix*RotationMatrix and dumps coordinates into memory. Example uses .align $100 and stores cubeCoords: PrecalcObject(Cube,256,2,-1,1).",
      "references": [
        {
          "chunk": "matrix_value_constructors_and_usage",
          "topic": "matrix constructors used in example"
        },
        {
          "chunk": "vector_value_functions",
          "topic": "vector math in example"
        }
      ]
    },
    {
      "start": 5090,
      "end": 5093,
      "ignore": true,
      "reason": "Page number / form-feed; non-technical."
    },
    {
      "start": 5094,
      "end": 5110,
      "name": "assemble_information_intro",
      "description": "Chapter 15 Assemble Information: Kick Assembler exposes build-in features and assembled-source info for editor integration (error/syntax feedback, directive help). Notes interface may change and to contact author if using it. Introduces AsmInfo option.",
      "references": []
    },
    {
      "start": 5111,
      "end": 5143,
      "name": "asminfo_option_and_output_format",
      "description": "Describes -asminfo option: java -jar KickAss.jar mysource.asm -asminfo all (output to asminfo.txt or custom via -asminfofile). Describes example asminfo output sections ([libraries], [directives], [files], [syntax], [errors]) and two categories of asmInfo: predefined (directives/libraries) and source-specific (syntax/errors). Examples of requesting 'allPredefined' or 'allPredefined|errors'.",
      "references": [
        {
          "chunk": "asminfo_sections_details",
          "topic": "details of asminfo sections"
        }
      ]
    },
    {
      "start": 5144,
      "end": 5190,
      "name": "asminfo_selection_options",
      "description": "Lists available asminfo selection options (Table 15.1) such as all, allPredefined, allSourceSpecific, version, libraries, directives, preprocessorDirectives, files, syntax, errors. Explains 'meta' category usage and what each selection returns.",
      "references": [
        {
          "chunk": "asminfo_option_and_output_format",
          "topic": "how to request different sections"
        }
      ]
    },
    {
      "start": 5191,
      "end": 5237,
      "name": "realtime_feedback_replacefile_and_noeval",
      "description": "Explains realtime feedback features for editors: use replaceFile option to substitute unsaved files (java -jar KickAss.jar mysource.asm -replacefile original temp) and use -noeval to parse and do an initial pass without evaluation (quick syntax check, don't overwrite outputs).",
      "references": [
        {
          "chunk": "asminfo_option_and_output_format",
          "topic": "using asminfo in editors"
        }
      ]
    },
    {
      "start": 5238,
      "end": 5268,
      "name": "asminfo_file_format_and_source_ranges",
      "description": "Describes AsmInfo file format: sections start with [name], lines are semicolon-separated fields. Introduces 'source range' special field representing character ranges as five integers: startline, startpos, endline, endpos, fileindex (e.g., 38,8,38,17,1).",
      "references": [
        {
          "chunk": "asminfo_option_and_output_format",
          "topic": "details of asminfo file layout"
        }
      ]
    },
    {
      "start": 5269,
      "end": 5276,
      "name": "asminfo_version_section",
      "description": "Version section of asminfo: contains a single line with assembler version, e.g., [version] 5.12.",
      "references": []
    },
    {
      "start": 5277,
      "end": 5291,
      "name": "asminfo_libraries_section",
      "description": "Libraries section format: libraryname;entrytype;typedata. Entry types: 'function' and 'constant'. Examples: Math;constant;PI, Math;function;abs;1.",
      "references": []
    },
    {
      "start": 5292,
      "end": 5300,
      "name": "asminfo_directives_section",
      "description": "Directives section format: directive;example;description. Example: .text;.text \"hello\";Dumps text bytes to memory.",
      "references": []
    },
    {
      "start": 5301,
      "end": 5313,
      "name": "asminfo_preprocessor_directives_section",
      "description": "Preprocessor directives section format: directive;example;description. Example: #define;#define DEBUG;Defines a preprocessor symbol.",
      "references": []
    },
    {
      "start": 5314,
      "end": 5324,
      "name": "asminfo_files_section",
      "description": "Files section lists involved files with index;filepath fields. Important: filepath may contain semicolons. Example: [files] 0;KickAss.jar:/include/autoinclude.asm 1;test1.asm. Shows included files inside KickAss.jar are indicated.",
      "references": []
    },
    {
      "start": 5325,
      "end": 5334,
      "name": "asminfo_syntax_section",
      "description": "Syntax section format: type;sourcerange, e.g., operator;21,20,21,20,0. Notes plans to add more fields such as where a label is defined if it's a label reference.",
      "references": []
    },
    {
      "start": 5335,
      "end": 5343,
      "name": "asminfo_errors_section",
      "description": "Errors section format: level;sourcerange;message, e.g., Error;41,2,41,7,1;Unknown preprocessor directive #defin. Provides structured error reporting for editors.",
      "references": []
    },
    {
      "start": 5344,
      "end": 5353,
      "name": "testing_chapter_intro",
      "description": "Chapter 16 Testing: Kick Assembler provides .assert directives useful for testing assembler features, macros, pseudo-commands, and functions. Assembling counts assertions and failed assertions and reports at the end.",
      "references": []
    },
    {
      "start": 5354,
      "end": 5366,
      "name": "asserting_expressions",
      "description": "Explains .assert for testing expressions: .assert \"2+5*10/2\", 2+5*10/2, 27. Shows how results and expected values are printed and mismatches flagged as errors. Supports numerical and compound types (e.g., vectors).",
      "references": []
    },
    {
      "start": 5367,
      "end": 5376,
      "name": "asserting_errors_in_expressions",
      "description": "Explains .asserterror to assert that an expression produces an error (useful for testing error handling). Example: .asserterror \"Test1\", 20/10 (will fail) .asserterror \"Test2\", 20/false (expected error due to invalid operand). Output distinguishes OK vs ERROR IN ASSERTION.",
      "references": []
    },
    {
      "start": 5377,
      "end": 5377,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5378,
      "end": 5401,
      "name": "asserting_code_sequences",
      "description": "Shows .assert supporting code blocks to compare assembled byte sequences. Example comparing assembled lda $1000 vs ldx $1000 and unrolled sta $0400+i vs explicit stores. Output shows assembled bytes and whether test passed.",
      "references": []
    },
    {
      "start": 5402,
      "end": 5409,
      "name": "asserting_errors_in_code",
      "description": "Demonstrates .asserterror with code blocks to assert that given code produces an assembler error. Example: .asserterror \"Test\" , { lda #\"This must fail\" } and expected output showing type error message.",
      "references": []
    },
    {
      "start": 5410,
      "end": 5412,
      "ignore": true,
      "reason": "Page number / form-feed; non-technical."
    },
    {
      "start": 5413,
      "end": 5421,
      "name": "3rd_party_java_plugins_intro",
      "description": "Chapter 17 introduction: describes supported plugin types (Macro Plugins, Modify Plugins, SegmentModifier Plugins, Archive Plugins, AutoIncludeFile Plugins, DiskWriter Plugins).",
      "references": [
        {
          "chunk": "test_project_for_plugins",
          "topic": "plugin test project setup"
        }
      ]
    },
    {
      "start": 5422,
      "end": 5422,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5423,
      "end": 5431,
      "name": "test_project_for_plugins",
      "description": "Instructions to use the plugin development test Eclipse project: create workspace, import the provided archive, replace KickAss.jar in jars folder with the latest version, view examples and launch files in src/PluginTest and launch folders.",
      "references": [
        {
          "chunk": "registering_your_plugins",
          "topic": "registering and making plugins visible to Kick Assembler"
        }
      ]
    },
    {
      "start": 5432,
      "end": 5449,
      "name": "registering_your_plugins",
      "description": "Explains registering plugins: ensure compiled Java class is visible on Java classpath. Two ways to tell Kick Assembler about plugin: use .plugin directive (e.g., .plugin \"test.plugins.macros.MyMacro\") for project-specific or add fully qualified class names to KickAss.plugin file for global availability.",
      "references": [
        {
          "chunk": "test_project_for_plugins",
          "topic": "how to run development project and test plugins"
        }
      ]
    },
    {
      "start": 5450,
      "end": 5463,
      "name": "imacro_interface_definition",
      "description": "Shows IMacro interface signature: public interface IMacro extends IPlugin { MacroDefinition getDefinition(); byte[] execute(IValue[] parameters, IEngine engine); } and explains MacroDefinition is simple wrapper (name property).",
      "references": [
        {
          "chunk": "macro_plugin_quick_example",
          "topic": "example implementation of IMacro"
        }
      ]
    },
    {
      "start": 5464,
      "end": 5503,
      "name": "macro_plugin_quick_example",
      "description": "Complete quick example of a macro plugin implementing IMacro: package test.plugins.macros; class MyMacro implements IMacro with MacroDefinition name set to \"MyMacro\" and execute() printing \"Hello world from mymacro!\" and returning zero bytes. Shows usage inside assembly: .plugin \"test.plugins.macros.MyMacro\" MyMacro(). Discusses IValue arguments and IEngine for communication.",
      "references": [
        {
          "chunk": "imacro_interface_definition",
          "topic": "IMacro interface used by example"
        },
        {
          "chunk": "general_communication_interfaces",
          "topic": "IEngine and IValue used by plugins"
        }
      ]
    },
    {
      "start": 5504,
      "end": 5514,
      "name": "general_communication_interfaces",
      "description": "Introduces package 'kickass.plugins.interf.general' and important interfaces IEngine and IValue used for plugin communication. Advises review of these when implementing plugins.",
      "references": [
        {
          "chunk": "iengine_interface",
          "topic": "detailed IEngine methods"
        },
        {
          "chunk": "ivalue_interface",
          "topic": "detailed IValue methods"
        }
      ]
    },
    {
      "start": 5515,
      "end": 5560,
      "name": "iengine_interface",
      "description": "IEngine interface methods (part 1): addError(String message, ISourceRange range) to add errors without stopping, charToByte(char c) to convert to PETSCII byte, IMemoryBlock createMemoryBlock(String name,int startAddr, byte[] bytes) to create blocks, error(String message) to report fatal error (throws AsmException).",
      "references": [
        {
          "chunk": "iengine_interface_part2",
          "topic": "continuation of IEngine methods"
        },
        {
          "chunk": "imemoryblock_interface",
          "topic": "IMemoryBlock returned by createMemoryBlock"
        }
      ]
    },
    {
      "start": 5561,
      "end": 5588,
      "name": "iengine_interface_part2",
      "description": "IEngine interface methods (part 2): error(String message, ISourceRange) with range, getCurrentDirectory(), getFile(String filename) (searches library dirs and returns null if not found), normalizeFileName(String name) to evaluate %o substitutions, openOutputStream(String name) to create outputs (throws Exception), print(String message), printNow(String message), stringToBytes(String str) converting to PETSCII upper case bytes.",
      "references": [
        {
          "chunk": "general_communication_interfaces",
          "topic": "overview of engine interface"
        }
      ]
    },
    {
      "start": 5589,
      "end": 5600,
      "name": "ivalue_interface",
      "description": "IValue interface overview: values represent assembler values (numbers, strings, booleans). Methods include getInt(), getDouble(), getString(), getBoolean(), getList() returning List<IValue>, and predicate methods hasIntRepresentation(), hasDoubleRepresentation(), hasStringRepresentation(), hasBooleanRepresentation(), hasListRepresentation().",
      "references": [
        {
          "chunk": "imacro_interface_definition",
          "topic": "IValue objects passed to macro execute()"
        }
      ]
    },
    {
      "start": 5601,
      "end": 5654,
      "name": "ivalue_interface_methods_and_representations",
      "description": "IValue interface methods: getDouble(), getString(), getBoolean(), getList(); and representation checks hasIntRepresentation(), hasDoubleRepresentation(), hasStringRepresentation(), hasBooleanRepresentation(), hasListRepresentation(). Explains behavior when conversion isn't possible (error message) and lists basic list behaviour (size(), get(i), isEmpty(), iterator()).",
      "references": [
        {
          "chunk": "i_parameter_map_interface",
          "topic": "IParameterMap uses IValue for parameter values"
        },
        {
          "chunk": "macro_plugins_interface",
          "topic": "Macros receive IValue[] parameters"
        }
      ]
    },
    {
      "start": 5655,
      "end": 5662,
      "name": "isourcerange_interface",
      "description": "ISourceRange interface: represents a position in source code (e.g. line/column ranges). Plugins receive source ranges to indicate where parameters or calls originate and can return them when reporting errors. The interface is empty (marker interface).",
      "references": [
        {
          "chunk": "i_parameter_map_interface",
          "topic": "IParameterMap.getSourceRange returns ISourceRange"
        }
      ]
    },
    {
      "start": 5663,
      "end": 5692,
      "name": "imemoryblock_interface",
      "description": "IMemoryBlock interface: represents a memory block with a start address, bytes, and a name. Methods: int getStartAddress(), byte[] getBytes(), String getName(). Example assembler code shows two memory blocks created by the assembler. Memory blocks can be passed to plugins or created via IEngine.createMemoryBlock.",
      "references": [
        {
          "chunk": "modifier_plugins_interface",
          "topic": "Modifiers receive List<IMemoryBlock> to modify output bytes"
        },
        {
          "chunk": "disk_writer_plugins",
          "topic": "Disk writer files refer to IMemoryBlock bytes"
        }
      ]
    },
    {
      "start": 5693,
      "end": 5694,
      "name": "i_parameter_map_interface",
      "description": "IParameterMap interface: collection of name -> IValue pairs (used for source code parameters in square brackets). Main methods: exists(), getValue(), getSourceRange(), getParameterNames(). Convenience getters: getBoolValue(name, default), getEnumValue(...), getIntValue(name, default), getStringValue(name, default), IValue getValue(name), ISourceRange getSourceRange(name), Collection<String> getParameterNames().",
      "references": [
        {
          "chunk": "isourcerange_interface",
          "topic": "getSourceRange returns an ISourceRange"
        },
        {
          "chunk": "ivalue_interface_methods_and_representations",
          "topic": "values are of type IValue"
        }
      ]
    },
    {
      "start": 5695,
      "end": 5738,
      "name": "iparametermap_interface",
      "description": "IParameterMap interface representing name-value parameter collections (values are IValue). Methods include exist(String), getBoolValue(String,paramDefault), getEnumValue(), getIntValue(String,int), getParameterNames(), getSourceRange(String), getStringValue(String,String), getValue(String). Useful for reading directive or plugin parameters parsed from square-bracket maps.",
      "references": []
    },
    {
      "start": 5739,
      "end": 5751,
      "name": "plugins_overview",
      "description": "Overview of plugin pattern in KickAssembler: most plugins provide a definition method (returning a Definition object with name, parameters, etc.) and an execute method. All plugin interfaces extend the marker IPlugin interface. Definition classes expose getters/setters for configuration fields (e.g. setName()).",
      "references": [
        {
          "chunk": "macro_plugins_interface",
          "topic": "Macro plugin example"
        },
        {
          "chunk": "modifier_plugins_interface",
          "topic": "Modifier plugin example"
        }
      ]
    },
    {
      "start": 5752,
      "end": 5752,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5753,
      "end": 5756,
      "name": "macro_plugins_interface",
      "description": "Macro plugin interface: public interface IMacro extends IPlugin { MacroDefinition getDefinition(); byte[] execute(IValue[] parameters, IEngine engine); }. MacroDefinition holds plugin properties such as name (getName()/setName()). Macros return assembled bytes as a byte array. Macro plugins are exemplified in Quick Example section.",
      "references": [
        {
          "chunk": "ivalue_interface_methods_and_representations",
          "topic": "Macros receive parameters as IValue[]"
        },
        {
          "chunk": "plugins_overview",
          "topic": "general plugin pattern and Definition classes"
        }
      ]
    },
    {
      "start": 5757,
      "end": 5771,
      "name": "macro_plugins_details",
      "description": "Macro plugin details: IMacro interface and MacroDefinition class structure reiterated: IMacro has getDefinition() and execute(IValue[] parameters, IEngine engine). MacroDefinition contains name property. Refer to Quick Example for full implementation.",
      "references": [
        {
          "chunk": "imacro_interface_definition",
          "topic": "interface and definition for macros"
        }
      ]
    },
    {
      "start": 5772,
      "end": 5772,
      "name": "modifier_plugins_interface",
      "description": "Modifier plugin details: used to modify output bytes of blocks. Example usage .modify MyModifier(27) { *=$8080 ... }. Interface to implement: public interface IModifier extends IPlugin { ModifierDefinition getDefinition(); byte[] execute(List<IMemoryBlock> memoryBlocks, IValue[] parameters, IEngine engine); } with ModifierDefinition containing name property.",
      "references": [
        {
          "chunk": "segment_modifiers_intro",
          "topic": "segment modifiers and modifiers concept"
        }
      ]
    },
    {
      "start": 5773,
      "end": 5796,
      "name": "modifier_plugins_interface",
      "description": "Modifier plugins modify output bytes of a code block or memory block. Example usage: .modify MyModifier(27) { *=$8080 ... } Interface: public interface IModifier extends IPlugin { ModifierDefinition getDefinition(); byte[] execute(List<IMemoryBlock> memoryBlocks, IValue[] parameters, IEngine engine); } ModifierDefinition holds the 'name' property. Modifiers receive memory blocks to transform and must return replacement byte arrays.",
      "references": [
        {
          "chunk": "imemoryblock_interface",
          "topic": "Modifiers accept List<IMemoryBlock> to modify"
        },
        {
          "chunk": "segment_modifier_plugins",
          "topic": "segment modifiers are similar but operate on segments"
        }
      ]
    },
    {
      "start": 5797,
      "end": 5825,
      "name": "segment_modifier_plugins",
      "description": "Segment modifier plugins: modify memory blocks of a named segment before output (useful for packers, etc.). Example: .file [modify=\"MyPacker\", _start=$2000] A SegmentModifier implements ISegmentModifier with methods: SegmentModifierDefinition getDefinition(); List<IMemoryBlock> execute(List<IMemoryBlock> memoryBlocks, IParameterMap parameters, IEngine engine); SegmentModifierDefinition includes name, allParameters, nonOptionalParameters. Convention: prefix modifier parameters with '_' to avoid collisions (e.g. '_start').",
      "references": [
        {
          "chunk": "modifier_plugins_interface",
          "topic": "modifier vs segment modifier differences"
        },
        {
          "chunk": "imemoryblock_interface",
          "topic": "segment modifiers operate on IMemoryBlock lists"
        }
      ]
    },
    {
      "start": 5826,
      "end": 5866,
      "name": "disk_writer_plugins",
      "description": "DiskWriter plugins: create custom disk image formats. Implement IDiskWriter: DiskWriterDefinition getDefinition(); void execute(IDiskData disk, IEngine engine); DiskWriterDefinition lists disk and file parameter sets (allDiskParameters, nonOptionalDiskParameters, allFileParameters, nonOptionalFileParameters). The .disk directive format is .disk WRITERNAME [..DISK PARAMETERS..] { [..FILE PARAMETERS..], ... }. Interfaces for execute: IDiskData { IParameterMap getParameters(); List<IDiskFileData> getFiles(); } and IDiskFileData { IParameterMap getParameters(); List<IMemoryBlock> getMemoryBlocks(); }. Use IEngine to open output streams.",
      "references": [
        {
          "chunk": "imemoryblock_interface",
          "topic": "Disk files provide IMemoryBlock lists with bytes to store"
        },
        {
          "chunk": "segment_modifier_plugins",
          "topic": "segment modifiers and disk writers both use parameter maps"
        }
      ]
    },
    {
      "start": 5867,
      "end": 5893,
      "name": "archive_plugins_interface",
      "description": "Archive plugins: bundle multiple plugin objects into one archive to register them with a single .plugin directive. Implement IArchive extends IPlugin with List<IPlugin> getPluginObjects(); Example shows returning a list of plugin instances (e.g. new MyMacro(), new MyModifier()). Register archive with: .plugin \"test.plugins.archives.MyArchive\"",
      "references": [
        {
          "chunk": "auto_include_file_plugins",
          "topic": "AutoIncludeFile objects can be included in archives"
        },
        {
          "chunk": "plugins_overview",
          "topic": "plugin registration via .plugin"
        }
      ]
    },
    {
      "start": 5894,
      "end": 5936,
      "name": "auto_include_file_plugins",
      "description": "AutoIncludeFile plugins: include source files (e.g. macros) bundled inside an archive. Typical usage places a source file in the jar (e.g. '/include/MyAutoInclude.asm') and adds an AutoIncludeFile entry to the archive specifying jar-name, a class reference used to open the resource, and the resource path. Example provided: .macro SetColor(color) { ... } and AutoIncludeFile(\"MyArchive.jar\", getClass(), \"/include/MyAutoInclude.asm\"). IAutoIncludeFile interface: AutoIncludeFileDefinition getDefinition(); InputStream openStream(); AutoIncludeFileDefinition contains filePath and jarName.",
      "references": [
        {
          "chunk": "archive_plugins_interface",
          "topic": "AutoIncludeFile entries are added to archives"
        }
      ]
    },
    {
      "start": 5937,
      "end": 6030,
      "name": "cmdline_options_a1_part1",
      "description": "Appendix A.1 — Command line options (part 1). Documents Kick Assembler options including -afo (allow file output outside output dir), -aom (allow overlapping memory blocks), -asminfo / -asminfo all (export assemble info), -asminfofile (specify asminfo output file), -asminfotostdout/-asminfoToStdOut (direct asminfo to stdout), -binfile (output raw bin instead of prg), -bytedump / -bytebump (dump assembled bytes with source to ByteDump.txt), -bytedumpfile (specify name for bytedump).",
      "references": [
        {
          "chunk": "cmdline_options_a1_part2",
          "topic": "continues listing command line options"
        }
      ]
    },
    {
      "start": 6031,
      "end": 6110,
      "name": "cmdline_options_a1_part2",
      "description": "Appendix A.1 — Command line options (part 2). Options include -cfgfile (use additional configuration files), -debug (adds debug info like stacktraces), -debugdump (dump debugging map for c64 debugger mapping bytes to source), -define (define preprocessor symbol), -dtv (enable DTV opcodes), -excludeillegal (exclude illegal opcodes), -execute (run a program with assembled file as argument such as launching an emulator).",
      "references": [
        {
          "chunk": "cmdline_options_a1_part1",
          "topic": "previous command line options"
        },
        {
          "chunk": "cmdline_options_a1_part3",
          "topic": "continues listing command line options"
        }
      ]
    },
    {
      "start": 6111,
      "end": 6200,
      "name": "cmdline_options_a1_part3",
      "description": "Appendix A.1 — Command line options (part 3). Options include -executelog (log output of executed program), -fillbyte (byte used to fill space between memory blocks in PRG), -libdir (add library search path), -log (log assembler output to file), -maxaddr (upper memory limit), -mbfiles (save one file per memory block), -noeval (parse but stop before evaluation), -nooutput (disable file output), -o (set output file), -odir (set output directory), -pseudoc3x (allow semicolon between pseudocommand arguments), -replacefile (replace a sourcefile with another every time it's referred), -showmem (show memory map), -symbolfile (generate .sym file), -symbolfiledir (set folder for symbolfile), -time (display assemble time), -vicesymbols (generate label file for VICE), -warningsoff (turn off warnings). Also documents ':name=' notation for passing string/variables to scripts.",
      "references": [
        {
          "chunk": "preprocessor_directives_a2",
          "topic": "script flags and preprocessor interplay"
        }
      ]
    },
    {
      "start": 6201,
      "end": 6268,
      "name": "preprocessor_directives_a2",
      "description": "Appendix A.2 — Preprocessor directives. Lists preprocessor commands: #define, #elif, #else, #endif, #if, #import, #importif, #importonce, #undef. Examples and descriptions: #define to define symbols, #import to include files, #importif to conditionally import, #importonce to avoid repeated imports, #undef to remove symbol definitions.",
      "references": [
        {
          "chunk": "cmdline_options_a1_part3",
          "topic": "command-line defines and #import usage"
        }
      ]
    },
    {
      "start": 6269,
      "end": 6310,
      "name": "branch_and_basic_flag_instructions",
      "description": "Beginning rows of the standard 6502 mnemonic quick-reference table. Contains opcode bytes and mnemonics for branch instructions (BMI, BNE, BPL, BVC, BVS, BCC, BCS, BEQ) plus basic processor/interrupt flag instructions (BRK, CLC, CLD, CLI). These lines show the opcode hex bytes interleaved with mnemonics as given in the Kick Assembler quick reference.",
      "references": [
        {
          "chunk": "standard_table_header_addressing_modes",
          "topic": "continues into the quick-reference table header and addressing-mode columns"
        },
        {
          "chunk": "arithmetic_and_processor_status_and_transfers",
          "topic": "related processor-status instructions (SEC/SED/SEI) appear later in the table"
        }
      ]
    },
    {
      "start": 6311,
      "end": 6347,
      "name": "standard_table_header_addressing_modes",
      "description": "Quick Reference table header and addressing-mode column labels for the standard 6502 mnemonics table. Includes the 'cmd' / 'noarg' / 'imm' headers and addressing-mode column names (zp, zpx, zpy, izx, izy, abs, abx, aby) and initial opcode bytes (including CLV and its opcode). This chunk sets up the columns used by the subsequent instruction groups.",
      "references": [
        {
          "chunk": "branch_and_basic_flag_instructions",
          "topic": "previous rows of the same quick-reference table (branches & flags)"
        },
        {
          "chunk": "compare_instructions_cmp_cpx_cpy",
          "topic": "next block: compare-family instruction entries in the table"
        }
      ]
    },
    {
      "start": 6348,
      "end": 6369,
      "name": "compare_instructions_cmp_cpx_cpy",
      "description": "Compare-family instructions from the standard 6502 mnemonic table: CMP, CPX, CPY. Lists opcode bytes for the various addressing modes (immediate, zero page, absolute, etc.) as shown in the quick-reference layout.",
      "references": [
        {
          "chunk": "standard_table_header_addressing_modes",
          "topic": "uses the addressing-mode columns defined in the header"
        },
        {
          "chunk": "decrement_instructions",
          "topic": "follows with decrement instructions (DEC/DEX/DEY)"
        }
      ]
    },
    {
      "start": 6370,
      "end": 6378,
      "name": "decrement_instructions",
      "description": "Decrement instructions: DEC, DEX, DEY. Includes the opcode hex bytes for their supported addressing modes (zero page, zero page X, absolute, etc.) as presented in the quick-reference table.",
      "references": [
        {
          "chunk": "compare_instructions_cmp_cpx_cpy",
          "topic": "previous family of comparison instructions"
        },
        {
          "chunk": "eor_inc_and_misc_arithmetic",
          "topic": "next block begins with EOR and related increment/arithmetic opcode listings"
        }
      ]
    },
    {
      "start": 6379,
      "end": 6419,
      "name": "eor_inc_and_misc_arithmetic",
      "description": "EOR (exclusive OR), INC and related arithmetic/logical opcode listings extracted from the standard 6502 quick-reference table. This block contains EOR and the increment family (INC, INX, INY) along with a sequence of opcode bytes for many addressing modes and additional arithmetic-related opcode bytes shown in the table.",
      "references": [
        {
          "chunk": "decrement_instructions",
          "topic": "follows the decrement instructions (DEC/DEX/DEY)"
        },
        {
          "chunk": "jumps_and_load_instructions",
          "topic": "next block begins with JMP/JSR and load instruction entries (LDA/LDX/LDY)"
        }
      ]
    },
    {
      "start": 6420,
      "end": 6455,
      "name": "jumps_and_load_instructions",
      "description": "Jump and load instructions from the standard 6502 quick-reference: JMP, JSR and immediate/zero-page/absolute load instructions (LDA, LDX, LDY). Contains the opcode hex bytes mapped to addressing modes for these control-flow and load operations.",
      "references": [
        {
          "chunk": "eor_inc_and_misc_arithmetic",
          "topic": "preceding arithmetic/opcode entries"
        },
        {
          "chunk": "logical_or_nop_and_related",
          "topic": "next block contains ORA, NOP and related logical/opcode entries"
        }
      ]
    },
    {
      "start": 6456,
      "end": 6494,
      "name": "logical_or_nop_and_related",
      "description": "Logical OR and miscellaneous opcodes including ORA and the single-byte NOP, plus several addressing-mode opcode bytes that appear adjacent in the quick-reference table. This chunk contains ORA and NOP entries and the opcode hex values for their supported addressing modes.",
      "references": [
        {
          "chunk": "jumps_and_load_instructions",
          "topic": "previous jump/load instruction entries"
        },
        {
          "chunk": "loads_shifts_and_stack_ops",
          "topic": "next block lists LDA/LSR and stack/shift operations"
        }
      ]
    },
    {
      "start": 6495,
      "end": 6552,
      "name": "loads_shifts_and_stack_ops",
      "description": "Entries for LDA, LSR and associated opcodes together with stack operations: PHA, PHP, PLA, PLP. Also includes ROL and ROR (rotate operations) and the interrupt/return instructions RTI and RTS as presented in the standard 6502 quick-reference table, with their opcode bytes by addressing mode.",
      "references": [
        {
          "chunk": "logical_or_nop_and_related",
          "topic": "preceding logical and miscellaneous opcodes"
        },
        {
          "chunk": "store_instructions_sta_stx_sty",
          "topic": "following block covers store instructions (STA/STX/STY)"
        }
      ]
    },
    {
      "start": 6553,
      "end": 6590,
      "name": "store_instructions_sta_stx_sty",
      "description": "Store instructions section from the standard 6502 quick-reference table. Contains STA, STX and STY with their opcode hex bytes for supported addressing modes (zero page, zero page X, absolute, absolute X/Y, indirect modes where applicable).",
      "references": [
        {
          "chunk": "loads_shifts_and_stack_ops",
          "topic": "previous block listing loads, shifts and stack instructions"
        },
        {
          "chunk": "arithmetic_and_processor_status_and_transfers",
          "topic": "next block includes SBC and processor-status / register-transfer instructions"
        }
      ]
    },
    {
      "start": 6591,
      "end": 6640,
      "name": "arithmetic_and_processor_status_and_transfers",
      "description": "Arithmetic and processor-status instructions along with register transfers: SBC and the processor flag setters/clears (SEC, SED, SEI) and the transfer instructions (TAX, TAY, TSX, TXA, TXS, TYA). This block lists the opcode bytes for these instructions across addressing modes as given in the quick-reference.",
      "references": [
        {
          "chunk": "store_instructions_sta_stx_sty",
          "topic": "previous store instruction entries"
        },
        {
          "chunk": "addressing_mode_indirect_and_relative",
          "topic": "table's remaining addressing-mode labels (ind, rel) follow"
        }
      ]
    },
    {
      "start": 6641,
      "end": 6644,
      "name": "addressing_mode_indirect_and_relative",
      "description": "Tail of the addressing-mode column labels in the quick-reference table: 'ind' (indirect) and 'rel' (relative). These columns correspond to indirect and relative-mode opcode entries in the table rows.",
      "references": [
        {
          "chunk": "arithmetic_and_processor_status_and_transfers",
          "topic": "continues from the processor-status and transfer instruction entries"
        },
        {
          "chunk": "illegal_mnemonics_intro",
          "topic": "next section introduces illegal 6502 mnemonics (A.3.2)"
        }
      ]
    },
    {
      "start": 6645,
      "end": 6661,
      "name": "illegal_mnemonics_intro",
      "description": "Section A.3.2: introduction to Illegal 6502 Mnemonics. Explains that the illegal instruction set contains the standard 6502 mnemonics plus additional modifications, notes that this is the default instruction set for Kick Assembler, and shows how to enable it ('.cpu _6502'). Also includes the Table A.4 header for the illegal mnemonics table.",
      "references": [
        {
          "chunk": "addressing_mode_indirect_and_relative",
          "topic": "finishes the standard quick-reference table"
        },
        {
          "chunk": "illegal_6502_mnemonics_table",
          "topic": "the following block contains the detailed list of illegal mnemonics and opcodes"
        }
      ]
    },
    {
      "start": 6662,
      "end": 6738,
      "name": "illegal_6502_mnemonics_table",
      "description": "Table A.4: Illegal 6502 mnemonics and their opcode bytes. Lists undocumented/illegal opcodes and mnemonics such as AHX/SHA, ALR/ASR, ANC/ANC2, ARR, AXS/SBX, ISC/INS/ISB, LAS/LAE/LDS and more with opcode hex values for the addressing modes. This is the Kick Assembler default illegal-instruction reference and enumerates the undocumented instruction variants and the opcode bytes shown in the quick-reference format.",
      "references": [
        {
          "chunk": "illegal_mnemonics_intro",
          "topic": "introduction to the illegal instruction table and how to enable the illegal set in Kick Assembler"
        },
        {
          "chunk": "standard_table_header_addressing_modes",
          "topic": "shares the same quick-reference table layout/column conventions for addressing modes"
        }
      ]
    },
    {
      "start": 6739,
      "end": 6746,
      "name": "rla_illegal_mnemonic",
      "description": "Illegal mnemonic RLA and its opcode encodings as listed in Kick Assembler's illegal-6502 table. Contains the opcode bytes: $27, $37, $23 (addressing-mode-specific encodings).",
      "references": [
        {
          "chunk": "rra_illegal_mnemonic",
          "topic": "Related rotate+memory/accumulator illegal op RRA"
        },
        {
          "chunk": "dcp_dcm_and_lax_lxa_group",
          "topic": "Other illegal multi-byte/multi-effect opcodes"
        },
        {
          "chunk": "dtv_instruction_set",
          "topic": "Alternative CPU modes (DTV) and their mnemonics"
        }
      ]
    },
    {
      "start": 6747,
      "end": 6754,
      "name": "rra_illegal_mnemonic",
      "description": "Illegal mnemonic RRA and its opcode encodings in Kick Assembler. Contains the opcode bytes: $67, $77, $63 (addressing-mode-specific encodings).",
      "references": [
        {
          "chunk": "rla_illegal_mnemonic",
          "topic": "Related rotate+memory/accumulator illegal op RLA"
        },
        {
          "chunk": "slo_illegal_mnemonic",
          "topic": "Other shift-and-op illegal instructions (SLO family)"
        }
      ]
    },
    {
      "start": 6755,
      "end": 6758,
      "name": "sax_illegal_mnemonic",
      "description": "Illegal mnemonic SAX (also seen as STA+X-like store) and its opcode encoding: $87. Listed as part of Kick Assembler's illegal-6502 mnemonic set.",
      "references": [
        {
          "chunk": "sre_illegal_mnemonic",
          "topic": "Other store/bitwise illegal opcodes"
        },
        {
          "chunk": "xaa_ane_illegal_mnemonics",
          "topic": "Other accumulator-affecting illegal mnemonics"
        }
      ]
    },
    {
      "start": 6759,
      "end": 6762,
      "name": "nop_standard_nop",
      "description": "Standard NOP opcode as shown in the listing: $EA. Included in the table of mnemonics (appears among illegal mnemonics entries when Kick Assembler's '.cpu' mode is not set to '_6502').",
      "references": [
        {
          "chunk": "dcp_dcm_and_lax_lxa_group",
          "topic": "Context: table contains both official and unofficial opcodes"
        }
      ]
    },
    {
      "start": 6763,
      "end": 6768,
      "name": "sbc2_rel_opcode",
      "description": "Illegal/variant mnemonic SBC2 with the 'rel' addressing-mode mapping shown and opcode $9F in this table. Part of Kick Assembler's illegal 6502 mnemonic listings.",
      "references": [
        {
          "chunk": "dcp_dcm_and_lax_lxa_group",
          "topic": "Other illegal arithmetic and combined-effect opcodes"
        },
        {
          "chunk": "dtv_instruction_set",
          "topic": "Different CPU modes may change available opcode mappings"
        }
      ]
    },
    {
      "start": 6769,
      "end": 6812,
      "name": "dcp_dcm_and_lax_lxa_group",
      "description": "Grouped illegal mnemonics DCP/DCM and LAX/LXA with addressing-mode annotations and a long list of opcode bytes. This block lists the many opcode encodings used by those unofficial instructions: $B7, $97, $A3, $B3, $AF, $BF, $0C, $1C, $33, $2F, $3F, $3B, $73, $6F, $7F, $7B, $83, $8F, $EB (and others as shown). Also includes an 'ind' label indicating indirect addressing forms listed nearby.",
      "references": [
        {
          "chunk": "rla_illegal_mnemonic",
          "topic": "Other rotate/AND/combined-effect illegal opcodes"
        },
        {
          "chunk": "slo_illegal_mnemonic",
          "topic": "Shift-and-op families (SLO)"
        },
        {
          "chunk": "sre_illegal_mnemonic",
          "topic": "Shift-then-EOR family (SRE)"
        }
      ]
    },
    {
      "start": 6813,
      "end": 6820,
      "name": "shx_shy_illegal_mnemonics",
      "description": "Illegal mnemonics SHX and SHY (store high X/Y) and their opcode encodings: SHX -> $9E, SHY -> $9C. These are part of the unofficial opcode list shown by Kick Assembler when using the default 6502 set.",
      "references": [
        {
          "chunk": "sax_illegal_mnemonic",
          "topic": "Other store-related illegal mnemonics (SAX)"
        },
        {
          "chunk": "tas_shs_illegal_mnemonics",
          "topic": "Related store-masked/combined instructions (TAS/SHS)"
        }
      ]
    },
    {
      "start": 6821,
      "end": 6836,
      "name": "slo_illegal_mnemonic",
      "description": "Illegal mnemonic SLO and its opcode encodings across multiple addressing modes: $07, $17, $03, $13, $0F, $1F, $1B. SLO is part of the family that performs a shift then OR/AND/EOR-like combined effect (unofficial opcodes).",
      "references": [
        {
          "chunk": "rra_illegal_mnemonic",
          "topic": "Other rotate/shift combined-effect illegal opcodes (RRA)"
        },
        {
          "chunk": "sre_illegal_mnemonic",
          "topic": "Related SRE (shift then EOR) instructions"
        }
      ]
    },
    {
      "start": 6837,
      "end": 6852,
      "name": "sre_illegal_mnemonic",
      "description": "Illegal mnemonic SRE and its opcode encodings for several addressing modes: $47, $57, $43, $53, $4F, $5F, $5B. SRE performs a shift then EOR effect in unofficial implementations.",
      "references": [
        {
          "chunk": "slo_illegal_mnemonic",
          "topic": "SLO family (shift+OR-like) for comparison"
        },
        {
          "chunk": "dcp_dcm_and_lax_lxa_group",
          "topic": "Other multi-effect unofficial instructions"
        }
      ]
    },
    {
      "start": 6853,
      "end": 6856,
      "name": "tas_shs_illegal_mnemonics",
      "description": "Illegal mnemonics TAS and SHS (store-and-mask variants) with opcode encoding $9B as listed in the illegal opcode table.",
      "references": [
        {
          "chunk": "shx_shy_illegal_mnemonics",
          "topic": "Other store-high/X/Y illegal mnemonics"
        },
        {
          "chunk": "sax_illegal_mnemonic",
          "topic": "Other store-related unofficial opcodes (SAX)"
        }
      ]
    },
    {
      "start": 6857,
      "end": 6860,
      "name": "xaa_ane_illegal_mnemonics",
      "description": "Illegal mnemonics XAA and ANE (accumulator-affecting unofficial ops) with opcode encoding $8B. Shown in the Kick Assembler illegal-6502 mnemonic listing.",
      "references": [
        {
          "chunk": "sax_illegal_mnemonic",
          "topic": "Other accumulator/store combined illegal mnemonics"
        },
        {
          "chunk": "nop_standard_nop",
          "topic": "Context: table mixes standard and unofficial opcodes"
        }
      ]
    },
    {
      "start": 6861,
      "end": 6900,
      "name": "dtv_instruction_set",
      "description": "Appendix A.3.3 — DTV instruction set notes and Table A.5. Describes that the DTV set contains standard + illegal 6502 mnemonics with modifications, selected by '.cpu dtv'. Includes the DTV mnemonic table column headers and listed mnemonics/encodings such as 'rel' -> $12, 'sac' -> $32, and 'sir' -> $42.",
      "references": [
        {
          "chunk": "dcp_dcm_and_lax_lxa_group",
          "topic": "Some illegal opcodes in the DTV set overlap with the default illegal 6502 table"
        },
        {
          "chunk": "65c02_mnemonics_table",
          "topic": "Contrast: 65c02 is another CPU mode with different additions/modifications"
        }
      ]
    },
    {
      "start": 6901,
      "end": 6953,
      "name": "65c02_mnemonics_table",
      "description": "Appendix A.3.4 — 65c02 instruction set notes and Table A.6. States that the 65c02 contains standard 6502 mnemonics plus modifications and three extra addressing modes, selected by '.cpu _65c02'. Includes table entries and example opcode bytes for instructions such as ADC ($69 immediate, $65 zero page, $75 zpx, $61 izx, $71 izy, $6D abs, $7D abx) and AND ($29 immediate, $25 zp, etc.) as shown in the listing.",
      "references": [
        {
          "chunk": "dtv_instruction_set",
          "topic": "Both are alternate CPU modes supported by Kick Assembler with modified mnemonic sets"
        },
        {
          "chunk": "dcp_dcm_and_lax_lxa_group",
          "topic": "Compare unofficial 6502 opcodes to 65c02 official additions/removals"
        }
      ]
    },
    {
      "start": 6954,
      "end": 6993,
      "name": "dtv_mnemonics_a3_3",
      "description": "Appendix A.3.3 — DTV Mnemonics. Lists instruction set extensions for the DTV CPU (use '.cpu dtv'). Adds new mnemonics and opcodes such as 'bra' (branch always) and others with specified opcode hex values, plus small changes to addressing support.",
      "references": [
        {
          "chunk": "mnemonics_6502_illegal_a3_2",
          "topic": "DTV contains standard + illegal 6502 mnemonics plus DTV-specific ones"
        }
      ]
    },
    {
      "start": 6994,
      "end": 7037,
      "name": "bbr_bbs_branch_on_bit_reset_set",
      "description": "Defines the 65c02 BBR (branch if bit reset) and BBS (branch if bit set) family of instructions: bbr5..bbr7 and bbs0..bbs7 with their opcode byte values ($5f..$ff). Includes the trailing blank line after the opcode list.",
      "references": [
        {
          "chunk": "bit_instruction_65c02",
          "topic": "bit instruction and related opcodes (test bit)"
        },
        {
          "chunk": "smb_instructions",
          "topic": "complementary single-bit memory set operations (SMB family)"
        }
      ]
    },
    {
      "start": 7038,
      "end": 7049,
      "name": "bit_instruction_65c02",
      "description": "Lists the 65c02 BIT instruction and its opcode encodings for various addressing modes ($89, $24, $34, $2c, $3c). Includes the blank line following the opcodes.",
      "references": [
        {
          "chunk": "bbr_bbs_branch_on_bit_reset_set",
          "topic": "branch-on-bit instructions (BBR/BBS) that rely on tested bit results"
        },
        {
          "chunk": "cmp_eor_inc_dec_group",
          "topic": "other logical and arithmetic instructions that interact with flags set by BIT"
        }
      ]
    },
    {
      "start": 7050,
      "end": 7053,
      "name": "bra_instruction",
      "description": "Single-entry for the BRA (branch always) instruction and its opcode ($80). Includes adjacent blank lines.",
      "references": [
        {
          "chunk": "bbr_bbs_branch_on_bit_reset_set",
          "topic": "other branch families (BBR/BBS) and how branch opcodes are arranged"
        }
      ]
    },
    {
      "start": 7054,
      "end": 7087,
      "name": "cmp_eor_inc_dec_instructions",
      "description": "Grouped opcodes for several arithmetic/logical instructions: CMP, DEC, EOR, and INC. Contains opcode bytes for different addressing modes and indirect-index variants ($c9, $3a, $49, $1a, $c5, $d5, $c6, $d6, $45, $55, $e6, $f6, $c1, $41, $d1, $51). Includes surrounding blank lines.",
      "references": [
        {
          "chunk": "bit_instruction_65c02",
          "topic": "BIT affects flags that CMP/EOR/CMP-like instructions use"
        },
        {
          "chunk": "sbc_instruction",
          "topic": "related arithmetic instruction SBC"
        }
      ]
    },
    {
      "start": 7088,
      "end": 7119,
      "name": "jmp_instruction_variants",
      "description": "JMP instruction encodings for various addressing modes and extended opcodes ($cd, $dd, $ce, $de, $4d, $5d, $ee, $fe, $d9, $d2, $59, $52, $4c, $6c, $7c). Lists multiple opcode bytes used by JMP across addressing modes.",
      "references": [
        {
          "chunk": "lda_instruction",
          "topic": "load instructions often used before or after control-flow changes (JMP targets)"
        }
      ]
    },
    {
      "start": 7120,
      "end": 7139,
      "name": "lda_instruction_encodings",
      "description": "LDA (load accumulator) instruction and its opcode encodings for immediate, zero page, zero page,X, absolute, absolute,X, absolute,Y, indirect indexed, indexed indirect and other modes ($a9, $a5, $b5, $a1, $b1, $ad, $bd, $b9, $b2).",
      "references": [
        {
          "chunk": "ora_instruction_encodings",
          "topic": "ORA is another accumulator-targeting instruction with similar addressing modes"
        },
        {
          "chunk": "jmp_instruction_variants",
          "topic": "control-flow interactions where values loaded by LDA are used"
        }
      ]
    },
    {
      "start": 7140,
      "end": 7173,
      "name": "ora_instruction_encodings",
      "description": "ORA (logical inclusive OR) instruction opcodes across addressing modes. Includes many encodings ($09, $05, $15, $01, $11, $0d, $1d, $19, $12, $f5, $e1, $f1, $ed, $fd, $f9, $f2) and surrounding spacing.",
      "references": [
        {
          "chunk": "lda_instruction_encodings",
          "topic": "LDA/ORA both target the accumulator and share addressing-mode patterns"
        },
        {
          "chunk": "phx_phy_plx_ply",
          "topic": "stack operations (PHX/PHY/PLX/PLY) used around accumulator/X/Y manipulation"
        }
      ]
    },
    {
      "start": 7174,
      "end": 7189,
      "name": "phx_phy_plx_ply",
      "description": "Stack and index push/pop instructions added on 65c02: PHX, PHY, PLX, PLY with their opcodes ($da, $5a, $fa, $7a). Includes trailing blank line.",
      "references": [
        {
          "chunk": "ora_instruction_encodings",
          "topic": "instructions that manipulate accumulator/index registers in code sequences"
        },
        {
          "chunk": "rmb_instructions",
          "topic": "stack usage patterns when manipulating memory bits or handling interrupts"
        }
      ]
    },
    {
      "start": 7190,
      "end": 7221,
      "name": "rmb_reset_memory_bit_instructions",
      "description": "RMB (Reset Memory Bit) family: rmb0..rmb7 with opcode bytes ($07, $17, $27, $37, $47, $57, $67, $77). Includes the blank line following the list.",
      "references": [
        {
          "chunk": "smb_instructions",
          "topic": "SMB (Set Memory Bit) family is the complementary operation to RMB"
        },
        {
          "chunk": "trb_tsb_instructions",
          "topic": "TRB/TSB also operate on memory bits at byte granularity"
        }
      ]
    },
    {
      "start": 7222,
      "end": 7229,
      "name": "sbc_instruction_encodings",
      "description": "SBC (subtract with carry) instruction opcodes for some addressing modes shown here ($e9, $e5 and an adjacent value '90' as listed). Includes the trailing blank line before the Quick Reference header.",
      "references": [
        {
          "chunk": "cmp_eor_inc_dec_instructions",
          "topic": "other arithmetic/logic operations that interact with status flags"
        }
      ]
    },
    {
      "start": 7230,
      "end": 7261,
      "name": "quick_reference_addressing_mode_opcodes",
      "description": "Start of the Quick Reference table mapping addressing mode columns (cmd noarg imm zp zpx zpy izx izy abs abx aby) to opcode bytes for indexed/indirect encodings. Lists opcodes such as $81, $91, $8d, $9d, $99, $9c, $9e for the shown column pattern.",
      "references": [
        {
          "chunk": "lda_instruction_encodings",
          "topic": "examples of how addressing-mode opcodes are arranged for load/store instructions"
        },
        {
          "chunk": "smb_instructions",
          "topic": "other opcode families shown later in the Quick Reference"
        }
      ]
    },
    {
      "start": 7262,
      "end": 7293,
      "name": "smb_set_memory_bit_instructions",
      "description": "SMB (Set Memory Bit) family: smb0..smb7 and their opcode bytes ($87, $97, $a7, $b7, $c7, $d7, $e7, $f7). Includes the blank line after the list.",
      "references": [
        {
          "chunk": "rmb_reset_memory_bit_instructions",
          "topic": "RMB family (reset bit) is the counterpart to SMB"
        },
        {
          "chunk": "sta_stz_trb_tsb_special_ops",
          "topic": "other store/bit-manipulation instructions shown next in the Quick Reference"
        }
      ]
    },
    {
      "start": 7294,
      "end": 7335,
      "name": "sta_stz_trb_tsb_stp_wai_and_special_addressing",
      "description": "Covers STA (store accumulator) opcode encodings ($85, $95, ...), STZ (store zero) opcodes ($64, $74), TRB (test and reset bit) opcodes ($14, $1c), TSB (test and set bit) opcodes ($04, $0c), STP and WAI entry (stp / wai), and special addressing-mode/opcode entries (ind, rel, izp, zprel, indx) with opcodes such as $92, $db, $cb. This section corresponds to entries in the Quick Reference and includes surrounding blank lines.",
      "references": [
        {
          "chunk": "smb_set_memory_bit_instructions",
          "topic": "single-bit set/reset instructions (SMB/RMB) are related to TRB/TSB's byte-level bit operations"
        },
        {
          "chunk": "jmp_instruction_variants",
          "topic": "special addressing modes like rel/ind used by control-flow instructions"
        }
      ]
    },
    {
      "start": 7336,
      "end": 7430,
      "name": "appendix_a4_assembler_directives",
      "description": "Appendix A.4 — Assembler Directives (Table A.7). Lists directives, examples, and descriptions for many assembler directives: '* = (origin)', .align, .assert, .asserterror, .break, .by (alias for .byte), .byte, .const, .cpu (e.g. .cpu _65c02), .define, .disk (create d64 image), .dw (alias for .dword), and .dword, along with their usage examples and brief explanations. Includes the trailing lines up to the chunk end.",
      "references": [
        {
          "chunk": "quick_reference_addressing_mode_opcodes",
          "topic": "use .cpu to change instruction set (e.g. to _65c02) which affects Quick Reference opcodes"
        },
        {
          "chunk": "appendix_a4_assembler_directives",
          "topic": "this chunk is the top-level list of assembler directives — see specific directive entries here"
        }
      ]
    },
    {
      "start": 7431,
      "end": 7520,
      "name": "assembler_directives_a4_part1",
      "description": "Appendix A.4 — Assembler directives (part 1). Lists directives and examples: setting origin (*) with '*=$1000', .align, .assert, .asserterror, .break (breakpoint), .by (alias for .byte), .byte (output bytes), .const (define constant), .cpu (change CPU instruction set), .define (execute block in function mode), .disk (create d64 image), .dw/.dword (output 4-byte values).",
      "references": [
        {
          "chunk": "assembler_directives_a4_part2",
          "topic": "continues directive list"
        },
        {
          "chunk": "mnemonics_65c02_a3_4",
          "topic": ".cpu directive selects CPU set"
        }
      ]
    },
    {
      "start": 7521,
      "end": 7620,
      "name": "assembler_directives_a4_part2",
      "description": "Appendix A.4 — Assembler directives (part 2). Directives covered include .encoding (character encoding), .enum (define constants), .error/.errorif (user errors), .eval (evaluate expressions), .file (create prg/bin from segments), .filemodify (modify output of current source file), .filenamespace (create namespace for file), .fill/.fillword (fill bytes/words with expressions), .for (for loops), .function (define function), .if (conditional execution).",
      "references": [
        {
          "chunk": "preprocessor_directives_a2",
          "topic": "preprocessor directives and conditional compile relate to .if / .eval"
        }
      ]
    },
    {
      "start": 7621,
      "end": 7720,
      "name": "assembler_directives_a4_part3",
      "description": "Appendix A.4 — Assembler directives (part 3). Directives include .import (binary/c64/source/text), .importonce, .label (assign expression to a label), .lohifill (fill hi/lo tables), .macro (define macro), .memblock (define memory block), .modify (apply modifier to codeblock), .namespace (create local namespace), .pc (set program counter), .plugin (register java plugin), .print/.printnow, .pseudocommand, .pseudopc (set program counter for pseudo-ops).",
      "references": [
        {
          "chunk": "auto_include_file_plugins",
          "topic": ".plugin and AutoIncludeFile usage"
        },
        {
          "chunk": "macro_plugins_interface",
          "topic": ".macro directive defines macros"
        }
      ]
    },
    {
      "start": 7721,
      "end": 7809,
      "name": "assembler_directives_a4_part4",
      "description": "Appendix A.4 — Assembler directives (part 4). Continues directives: .return (used in functions), .segment / .segmentdef (segments and definitions), .segmentout (output intermediate segment bytes), .struct (user-defined structures), .te/.text (text bytes), .var (variables), .while loops, .wo/.word (word output), .zp (mark unresolved labels as zeropage). Also documents types of values accepted by directives and pseudocommands.",
      "references": [
        {
          "chunk": "assembler_directives_a4_part3",
          "topic": "function, macro, and segment directives"
        },
        {
          "chunk": "value_types_a5",
          "topic": "value types accepted by directives"
        }
      ]
    },
    {
      "start": 7810,
      "end": 7923,
      "name": "value_types_a5",
      "description": "Appendix A.5 — Value types. Lists types recognizable by Kick Assembler scripting: 65xxArgument (mnemonic argument like ($10),y), BinaryFile (LoadBinary), Boolean, Char, Hashtable, List, Matrix (4x4), Null, Number (floating point), OutputFile (createFile), Picture (LoadPicture), SidFile (LoadSid), String, Struct (user-defined), Vector (3D vector). Examples provided for each type.",
      "references": [
        {
          "chunk": "ivalue_interface_methods_and_representations",
          "topic": "IValue represents many of these script-level types"
        },
        {
          "chunk": "assembler_directives_a4_part4",
          "topic": "directives accept these types as arguments"
        }
      ]
    },
    {
      "start": 7924,
      "end": 7970,
      "name": "appendix_b_technical_details",
      "description": "Appendix B — Technical details. Describes internal assembler techniques: B.1 Flexible pass algorithm (parses as much as possible each pass and repeats until stable), B.2 Recording of side effects (record and replay directive side effects to speed scripting), B.3 Function Mode vs Asm Mode (fast 'Function Mode' for script-only execution vs full 'Asm Mode' which records side effects), B.4 Invalid value calculations (how invalid/unresolved values propagate through arithmetic/operations and rules for resulting invalid types with examples).",
      "references": [
        {
          "chunk": "preprocessor_directives_a2",
          "topic": "preprocessor evaluation is affected by Function/Asm modes"
        },
        {
          "chunk": "ivalue_interface_methods_and_representations",
          "topic": "Invalid values are represented by IValue variants"
        }
      ]
    }
  ],
  "source_md5": "88edc56aa4e9a7267c42c32e7742a9e0"
}
