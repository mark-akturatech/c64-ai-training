{
  "source_file": "porgrammers referencel.txt",
  "context": "COMMODORE 64",
  "splits": [
    {
      "start": 1,
      "end": 345,
      "ignore": true,
      "reason": "Front matter: title page, publisher, copyright notice, table of contents and other non-technical front material"
    },
    {
      "start": 346,
      "end": 372,
      "name": "introduction_purpose",
      "description": "Overview of the Programmer's Reference Guide purpose and intended audience; scope of material (BASIC and 6502 machine language not taught in depth).",
      "references": [
        {
          "chunk": "introduction_whats_included",
          "topic": "what's included in the book"
        }
      ]
    },
    {
      "start": 373,
      "end": 421,
      "name": "introduction_whats_included",
      "description": "List of what's included in the manual: BASIC dictionary, machine language overview, KERNAL, I/O programming (peripherals, disk/cassette/printer/modem), graphics (sprites, characters, bitmaps), sound (SID), languages (CP/M), and other features.",
      "references": [
        {
          "chunk": "kernal_overview",
          "topic": "KERNAL routines and use"
        },
        {
          "chunk": "graphics_overview",
          "topic": "sprites, character and bitmap graphics"
        },
        {
          "chunk": "sound_overview",
          "topic": "SID sound and music section"
        }
      ]
    },
    {
      "start": 422,
      "end": 466,
      "name": "how_to_use_syntax_conventions",
      "description": "Rules for interpreting BASIC statement syntax in the manual: keywords in caps, quoted items, optional parameters in [ ], underlined items inside [ ], angle-bracket variables <>, slash for choice, ellipses for repetition; example OPEN syntax and concrete OPEN examples.",
      "references": [
        {
          "chunk": "basic_keywords_table",
          "topic": "BASIC keywords and abbreviations"
        }
      ]
    },
    {
      "start": 467,
      "end": 499,
      "name": "syntax_examples_and_parameter_symbols",
      "description": "Further examples of syntax application, examples of actual statements (OPEN examples), and a table of commonly used symbol names such as <file-num>, <device>, <address>, <drive>, <file-name>, <constant>, <variable>, <string>, <number>, <line-number>, <numeric>.",
      "references": [
        {
          "chunk": "io_overview",
          "topic": "I/O device numbering and OPEN/CLOSE usage"
        }
      ]
    },
    {
      "start": 500,
      "end": 524,
      "name": "intro_overview",
      "description": "Title and introductory paragraphs describing the broad capabilities and value of the Commodore 64, including encouragement that the system can be used for many tasks and a pointer to user clubs, magazines, and the Commodore Information Network (CompuServe) for additional ideas and resources.",
      "references": [
        {
          "chunk": "applications_table_header_and_games",
          "topic": "begins the tabular list of example applications"
        },
        {
          "chunk": "communication_and_online_services",
          "topic": "mentions the Commodore Information Network and CompuServe"
        }
      ]
    },
    {
      "start": 525,
      "end": 531,
      "name": "applications_table_header_and_games",
      "description": "Table header ('APPLICATION   COMMENTS/REQUIREMENTS') and the 'ACTION PACKED GAMES' entry describing availability of arcade-style games (Omega Race, Gorf, Wizard of War) and educational 'play and learn' titles.",
      "references": [
        {
          "chunk": "animation_sprites",
          "topic": "related entertainment/graphics capabilities (sprites)"
        },
        {
          "chunk": "dexterity_training_games",
          "topic": "other game categories that improve hand/eye coordination"
        }
      ],
      "ignore": true,
      "reason": "audit: Only a list of game titles/metadata; contains no technical C64 programming or hardware information."
    },
    {
      "start": 532,
      "end": 536,
      "name": "advertising_merchandising",
      "description": "ADVERTISING & MERCHANDISING entry explaining hooking the C64 to a TV for animated, flashing, musical point-of-purchase store displays.",
      "references": [
        {
          "chunk": "printing_support_printers_plotters",
          "topic": "other output devices and display options"
        },
        {
          "chunk": "graphics_and_art_modes",
          "topic": "graphics modes useful for merchandising displays"
        }
      ],
      "ignore": true,
      "reason": "audit: High-level marketing note; contains no technical C64 programming or hardware details."
    },
    {
      "start": 537,
      "end": 541,
      "name": "animation_sprites",
      "description": "ANIMATION entry describing Commodore's Sprite Graphics: creating cartoons with multiple levels allowing shapes to move in front of or behind each other.",
      "references": [
        {
          "chunk": "graphics_and_art_modes",
          "topic": "high-resolution and multi-color graphics modes"
        },
        {
          "chunk": "machine_code_programming_resources",
          "topic": "machine code techniques often used for sprite animation"
        }
      ]
    },
    {
      "start": 542,
      "end": 547,
      "name": "babysitting_and_learning_cartridge",
      "description": "BABYSITTING entry describing the COMMODORE 64 HOME BABYSITTER cartridge: occupation and teaching for young children (alphabet/keyboard recognition and learning concepts).",
      "references": [
        {
          "chunk": "education_learning_cartridges",
          "topic": "other educational cartridges and teaching resources"
        },
        {
          "chunk": "basic_programming_resources",
          "topic": "introductory learning resources for users"
        }
      ],
      "ignore": true,
      "reason": "audit: Only a marketing/description of an educational cartridge; contains no technical C64 programming or hardware information."
    },
    {
      "start": 548,
      "end": 551,
      "name": "basic_programming_resources",
      "description": "BASIC PROGRAMMING entry pointing to the COMMODORE 64 USER'S GUIDE and the TEACH YOURSELF PROGRAMMING series (books and tapes) as starting points for learning BASIC on the C64.",
      "references": [
        {
          "chunk": "machine_code_programming_resources",
          "topic": "advanced programming beyond BASIC"
        },
        {
          "chunk": "education_learning_cartridges",
          "topic": "learning resources and educational materials"
        }
      ],
      "ignore": true,
      "reason": "audit: Only generic beginner resource pointers; no technical details, code, registers, or standalone programming content."
    },
    {
      "start": 552,
      "end": 556,
      "name": "business_spreadsheet_wordprocessing",
      "description": "BUSINESS / SPREADSHEET entry describing the 'Easy' series of business aids, and claims about powerful word processing and large spreadsheets available for the C64.",
      "references": [
        {
          "chunk": "printing_support_printers_plotters",
          "topic": "printing output for business documents"
        },
        {
          "chunk": "payroll_and_forms_printout",
          "topic": "business forms and payroll applications"
        }
      ],
      "ignore": true,
      "reason": "audit: Pure marketing/product summary with no technical C64 programming details or actionable information."
    },
    {
      "start": 557,
      "end": 574,
      "name": "communication_and_online_services",
      "description": "COMMUNICATION entry describing connecting a VICMODEM to the C64 to communicate with other computer owners worldwide, and extended notes about joining the COMMODORE INFORMATION NETWORK on CompuServe for news, updates, shopping, and online games.",
      "references": [
        {
          "chunk": "intro_overview",
          "topic": "the intro's mention of CompuServe and user groups"
        },
        {
          "chunk": "printing_support_printers_plotters",
          "topic": "printing or saving communications output"
        }
      ]
    },
    {
      "start": 575,
      "end": 583,
      "name": "composing_music_sid_features",
      "description": "COMPOSING SONGS entry summarizing the built-in SID music synthesizer: three programmable voices, nine octaves, four waveforms, and references to Commodore music cartridges and books for composition and sound effects.",
      "references": [
        {
          "chunk": "machine_code_programming_resources",
          "topic": "using machine code to drive advanced sound routines"
        },
        {
          "chunk": "animation_sprites",
          "topic": "sound effects used with animations and games"
        }
      ]
    },
    {
      "start": 584,
      "end": 586,
      "name": "cp_m_support_note",
      "description": "CP/M entry noting that Commodore offers a CP/M add-on and access to CP/M software through an easy-to-load cartridge.",
      "references": [
        {
          "chunk": "machine_code_programming_resources",
          "topic": "low-level software and cross-platform tools"
        },
        {
          "chunk": "journals_creative_writing_and_storage",
          "topic": "using CP/M software for business or writing tasks"
        }
      ]
    },
    {
      "start": 587,
      "end": 591,
      "name": "dexterity_training_games",
      "description": "DEXTERITY TRAINING entry describing games that aid hand/eye coordination and manual dexterity, including titles like 'Jupiter Lander' and night driving simulations.",
      "references": [
        {
          "chunk": "applications_table_header_and_games",
          "topic": "other arcade-style game recommendations"
        },
        {
          "chunk": "animation_sprites",
          "topic": "graphics techniques used in games"
        }
      ]
    },
    {
      "start": 592,
      "end": 598,
      "name": "education_learning_cartridges",
      "description": "EDUCATION entry describing the educational value of working with a computer, mentioning the COMMODORE Educational Resource Book and a variety of learning cartridges covering topics from music and math to art and astronomy.",
      "references": [
        {
          "chunk": "babysitting_and_learning_cartridge",
          "topic": "cartridges designed for young children"
        },
        {
          "chunk": "basic_programming_resources",
          "topic": "resources for learning programming"
        }
      ],
      "ignore": true,
      "reason": "audit: Non-technical marketing/summary about educational cartridges; contains no C64 programming or hardware details."
    },
    {
      "start": 599,
      "end": 602,
      "name": "foreign_language_support",
      "description": "FOREIGN LANGUAGE entry describing the C64's programmable character set that lets users replace the standard character set with user-defined foreign language characters.",
      "references": [
        {
          "chunk": "graphics_and_art_modes",
          "topic": "character graphics and custom character usage"
        },
        {
          "chunk": "journals_creative_writing_and_storage",
          "topic": "writing and printing documents in other languages"
        }
      ]
    },
    {
      "start": 603,
      "end": 616,
      "name": "graphics_and_art_modes",
      "description": "GRAPHICS AND ART entry expanding on Sprite Graphics and describing high-resolution, multi-color graphics plotting, programmable characters, and combinations of graphics and character display modes (includes page separators/footnote lines present in the source).",
      "references": [
        {
          "chunk": "animation_sprites",
          "topic": "sprite-based animation details"
        },
        {
          "chunk": "lightpen_control",
          "topic": "interactive graphics input methods"
        }
      ]
    },
    {
      "start": 617,
      "end": 621,
      "name": "instrument_control_interfaces",
      "description": "INSTRUMENT CONTROL entry listing available ports for control and industrial applications: serial port, RS-232 port, user port, and optional IEEE/488 cartridge.",
      "references": [
        {
          "chunk": "printing_support_printers_plotters",
          "topic": "interfaces used for printers and plotters"
        },
        {
          "chunk": "machine_code_programming_resources",
          "topic": "low-level interfacing for instrument control"
        }
      ]
    },
    {
      "start": 622,
      "end": 629,
      "name": "journals_creative_writing_and_storage",
      "description": "JOURNALS AND CREATIVE WRITING entry describing upcoming/existing word processing systems, saving documents to 1541 Disk Drive or Datassette, and printing via VIC-PRINTER or PLOTTER.",
      "references": [
        {
          "chunk": "business_spreadsheet_wordprocessing",
          "topic": "business-oriented word processing and spreadsheets"
        },
        {
          "chunk": "printing_support_printers_plotters",
          "topic": "printer and plotter options for document output"
        }
      ]
    },
    {
      "start": 630,
      "end": 633,
      "name": "lightpen_control",
      "description": "LIGHTPEN CONTROL entry explaining that lightpen applications can be performed with any lightpen that fits the C64 game port connector.",
      "references": [
        {
          "chunk": "graphics_and_art_modes",
          "topic": "graphics modes used with lightpen input"
        },
        {
          "chunk": "instrument_control_interfaces",
          "topic": "physical ports and connectors for peripherals"
        }
      ]
    },
    {
      "start": 634,
      "end": 639,
      "name": "machine_code_programming_resources",
      "description": "MACHINE CODE PROGRAMMING entry referencing the COMMODORE 64 PROGRAMMER'S REFERENCE GUIDE, which includes machine language coverage, a BASIC-to-machine-code interface, and bibliography for deeper study.",
      "references": [
        {
          "chunk": "basic_programming_resources",
          "topic": "progression from BASIC to machine code"
        },
        {
          "chunk": "animation_sprites",
          "topic": "use of machine code for efficient graphics/sprite routines"
        }
      ],
      "ignore": true,
      "reason": "audit: No technical details\u2014only bibliographic/pointer metadata, source and code omitted."
    },
    {
      "start": 640,
      "end": 646,
      "name": "payroll_and_forms_printout",
      "description": "PAYROLL & FORMS / PRINTOUT entry describing the C64's ability to handle entry-type business applications, use of upper/lower case and 'business form' graphics for designing printable forms.",
      "references": [
        {
          "chunk": "printing_support_printers_plotters",
          "topic": "printing the designed forms"
        },
        {
          "chunk": "journals_creative_writing_and_storage",
          "topic": "saving and printing business documents"
        }
      ],
      "ignore": true,
      "reason": "audit: No technical details, code, or register info\u2014only high-level description and pointers."
    },
    {
      "start": 647,
      "end": 650,
      "name": "printing_support_printers_plotters",
      "description": "PRINTING entry describing C64 interfacing with various dot matrix and letter-quality printers as well as plotters (includes the blank/source spacing lines contiguous in the source).",
      "references": [
        {
          "chunk": "journals_creative_writing_and_storage",
          "topic": "printing word-processed documents"
        },
        {
          "chunk": "payroll_and_forms_printout",
          "topic": "printing business forms and payroll reports"
        }
      ]
    },
    {
      "start": 651,
      "end": 656,
      "name": "recipes_storage_usage",
      "description": "RECIPES entry describing storing favorite recipes on the C64 and its disk/cassette storage units as a replacement for physical recipe cards.",
      "references": [
        {
          "chunk": "journals_creative_writing_and_storage",
          "topic": "general storage and retrieval of user data"
        },
        {
          "chunk": "printing_support_printers_plotters",
          "topic": "printing stored recipes for use"
        }
      ],
      "ignore": true,
      "reason": "audit: No technical C64 programming content\u2014only a generic suggestion to store recipes; lacks addresses, formats, code, or procedures."
    },
    {
      "start": 657,
      "end": 701,
      "name": "commodore_support_publications",
      "description": "Information on Commodore publications and support: POWER/PLAY magazine (consumer/entertainment), COMMODORE magazine (technical), subscription info and how to get more resources and user club support.",
      "references": [
        {
          "chunk": "commodore_information_network",
          "topic": "paperless magazine and online support"
        }
      ]
    },
    {
      "start": 702,
      "end": 769,
      "name": "commodore_information_network",
      "description": "Description of the Commodore Information Network (paperless magazine) available via CompuServe: features, how to connect using a modem, G CBM command, departments and menu table (Main Menu, Dealers, User Questions, Magazines, etc.).",
      "references": [
        {
          "chunk": "commodore_support_publications",
          "topic": "magazines and subscriptions"
        }
      ]
    },
    {
      "start": 770,
      "end": 848,
      "name": "chapter1_header_and_overview",
      "description": "Chapter 1 heading and overview: 'BASIC PROGRAMMING RULES' with listed subtopics including Screen Display Codes, Programming Numbers and Variables, Expressions and Operators, and Programming Techniques.",
      "references": [
        {
          "chunk": "screen_display_codes",
          "topic": "character set and operating system overview"
        }
      ],
      "ignore": true,
      "reason": "audit: Front-matter TOC only; no technical details, examples, registers, or usable C64 programming content."
    },
    {
      "start": 849,
      "end": 892,
      "name": "chapter1_introduction_and_os_overview",
      "description": "Introduction to Chapter 1: what the chapter covers (how BASIC stores/manipulates data), and a short description of the Commodore 64 Operating System components: BASIC interpreter, KERNAL, Screen Editor and their responsibilities (keyword vocabulary, I/O handling, editing/keyboard interception).",
      "references": [
        {
          "chunk": "basic_keywords_table",
          "topic": "Interpreter's vocabulary of BASIC keywords"
        },
        {
          "chunk": "kernal_overview",
          "topic": "KERNAL routines and usage (Chapter 5)"
        }
      ]
    },
    {
      "start": 893,
      "end": 925,
      "name": "screen_display_codes_table",
      "description": "Table 1-1: CBM BASIC character set summary and special characters with descriptions: BLANK, ; = + - * / ^ ( ) % # $ , . \" : ? < > and the PI constant (numeric 3.141592654).",
      "references": [
        {
          "chunk": "string_comparisons_and_results",
          "topic": "string comparison uses the character set codes"
        }
      ]
    },
    {
      "start": 926,
      "end": 972,
      "name": "operating_system_modes_and_character_sets",
      "description": "Description of DIRECT vs PROGRAM modes of BASIC, and the two internal character sets (SET 1 and SET 2) behavior: SHIFT and C= keys usage to access graphics and upper/lower case; how to switch sets (C= + SHIFT).",
      "references": [
        {
          "chunk": "screen_display_codes_table",
          "topic": "character set symbols and special characters"
        }
      ]
    },
    {
      "start": 973,
      "end": 1004,
      "name": "constants_types_and_integer_constants",
      "description": "Introduction to constants and the three recognized types in CBM BASIC: integer, floating-point and strings. Integer constants details: whole numbers, valid range (-32768..+32767), storage as two-byte binary, examples and note not to use commas inside numbers.",
      "references": [
        {
          "chunk": "floating_point_constants_and_storage",
          "topic": "floating-point representation and precision"
        }
      ]
    },
    {
      "start": 1005,
      "end": 1032,
      "name": "floating_point_constants_and_storage",
      "description": "Floating-point constant format and rules: simple numbers and scientific notation, display of up to nine digits, rounding at tenth digit, storage uses five bytes, calculations have ten places of accuracy but print rounded to nine digits, valid display range (-999999999..+999999999 shown simply), and behavior when exceeding range.",
      "references": [
        {
          "chunk": "scientific_notation_and_limits",
          "topic": "scientific notation form and exponent limits"
        }
      ]
    },
    {
      "start": 1033,
      "end": 1074,
      "name": "scientific_notation_and_limits",
      "description": "Details of floating-point scientific notation: mantissa, 'E' and exponent; exponent range (-39..+38), conversion meaning (move decimal), maximum/minimum representable values (+1.70141183E+38 max, +2.93873588E-39 min), overflow behavior, and examples converting exponential to decimal.",
      "references": [
        {
          "chunk": "floating_point_constants_and_storage",
          "topic": "floating-point storage formats"
        }
      ]
    },
    {
      "start": 1075,
      "end": 1104,
      "name": "string_constants_and_rules",
      "description": "String constant rules: any alphanumeric and symbols up to available 80-character line space (subject to program syntax), can include blanks, commas, punctuation and control characters except double-quote (\") which delimits strings; null strings allowed; note to use CHR$(34) to include quotes within strings; examples.",
      "references": [
        {
          "chunk": "chr$_function",
          "topic": "CHR$ function to create characters by code (e.g., CHR$(34) for \")"
        }
      ]
    },
    {
      "start": 1105,
      "end": 1144,
      "name": "variables_types_and_naming",
      "description": "Variables: names representing data values; default creation behavior (auto-created as zero or null if referenced before assignment); only first two characters significant in CBM BASIC; rules forbidding keywords inside names; allowed characters (letters and digits), first character must be a letter; type suffixes: '%' for integer, '$' for string, none implies floating-point; examples.",
      "references": [
        {
          "chunk": "arrays_overview_and_dimensions",
          "topic": "array naming and element types"
        }
      ]
    },
    {
      "start": 1145,
      "end": 1199,
      "name": "arrays_overview_and_dimensions",
      "description": "Arrays: definition and conceptual description (tables of related elements referenced by a single name and subscripts). Supported types (integer, floating-point, string); dimensions and theoretical limits (up to 255 dimensions, 32767 elements per dimension), auto-creation rule for small one-dimensional arrays (<=10 elements) and memory calculation formula (5 bytes for array name + 2 bytes per dimension + per-element storage depending on type: 2 bytes int, 5 bytes float, 3+len string).",
      "references": [
        {
          "chunk": "dim_statement_and_memory_calculation",
          "topic": "DIM statement syntax and memory calculation examples"
        }
      ]
    },
    {
      "start": 1200,
      "end": 1215,
      "name": "array_examples_and_subscripts",
      "description": "Examples of array declarations and element assignments showing string, integer and floating-point arrays and multiple dimensions; subscript rules (integer constants, variables or expressions yielding integers), allowed subscript ranges and BAD SUBSCRIPT error; examples A(5)=0, B(5,6)=0, C(1,2,3)=0.",
      "references": [
        {
          "chunk": "arrays_overview_and_dimensions",
          "topic": "array dimension limits and storage calculation"
        }
      ]
    },
    {
      "start": 1216,
      "end": 1250,
      "name": "expressions_and_operators_overview",
      "description": "Expressions defined (constants, variables, arrays, and combinations using operators). Classification into arithmetic and string expressions. Definition of operands and operators; BASIC recognizes arithmetic, relational and logical operators.",
      "references": [
        {
          "chunk": "arithmetic_operations",
          "topic": "arithmetic operators (+,-,*,/,^)"
        },
        {
          "chunk": "string_operations_and_concatenation",
          "topic": "string concatenation using +"
        }
      ]
    },
    {
      "start": 1251,
      "end": 1268,
      "name": "arithmetic_operations",
      "description": "Arithmetic expressions produce integer or floating-point results. Operators: + (addition), - (subtraction and unary minus), * (multiplication), / (division), ^ (exponentiation). Integers converted to floating-point during operations; results converted back to integers if assigned to integer variables.",
      "references": [
        {
          "chunk": "operator_precedence_hierarchy",
          "topic": "order of operations among arithmetic operators"
        }
      ]
    },
    {
      "start": 1269,
      "end": 1332,
      "name": "arithmetic_examples",
      "description": "Examples of arithmetic operator usage: addition examples (2+2, A+B+C), subtraction (4-1, 4-(-2)), unary minus examples (-5, -9E4), multiplication examples (100*2, A*X1), division examples (10/2, A/B), and exponentiation examples (2^2, 3^-2, AB^CD).",
      "references": [
        {
          "chunk": "arithmetic_operations",
          "topic": "operator definitions and conversion rules"
        }
      ]
    },
    {
      "start": 1333,
      "end": 1392,
      "name": "relational_operators_and_string_comparison",
      "description": "Relational operators (<, =, >, <=, >=, <>) used to compare operands; when used produce integer true/false (-1 for true, 0 for false). Examples of numeric and string comparisons; strings compared character-by-character using PET/CBM character codes; comparing mismatched types causes ?TYPE MISMATCH. Comparisons always yield integer results and can be used within expressions except as divisors.",
      "references": [
        {
          "chunk": "string_comparisons_and_results",
          "topic": "detailed string comparison behavior"
        }
      ]
    },
    {
      "start": 1393,
      "end": 1411,
      "name": "logical_operators_overview",
      "description": "Logical operators AND, OR, NOT: used to combine relational expressions and perform bitwise operations when operands are integers in range -32768..+32767. Details on conversion from floating point to integer for logical operations and that NOT operates only on its right operand. Nonzero results considered true; exclusive OR (XOR) used by WAIT statement.",
      "references": [
        {
          "chunk": "boolean_truth_table",
          "topic": "truth table for AND/OR/NOT/XOR"
        }
      ]
    },
    {
      "start": 1412,
      "end": 1440,
      "name": "boolean_truth_table",
      "description": "Table 1-2: Boolean truth table showing results of AND, OR, NOT and XOR operations with bit-level examples and summary of their behavior.",
      "references": [
        {
          "chunk": "logical_operators_overview",
          "topic": "logical operator definitions and integer operand requirements"
        }
      ]
    },
    {
      "start": 1441,
      "end": 1468,
      "name": "logical_operator_examples",
      "description": "Examples showing how logical operators evaluate in BASIC: IF A=100 AND B=100 THEN, bitwise AND/OR usage like A=96 AND 32, use of NOT (IF NOT X<Y THEN), and how NOT produces two's complement results.",
      "references": [
        {
          "chunk": "logical_operators_overview",
          "topic": "bitwise and logical operator examples"
        }
      ]
    },
    {
      "start": 1469,
      "end": 1539,
      "name": "operator_precedence_hierarchy",
      "description": "Hierarchy of operations when evaluating expressions: precedence from highest to lowest: ^ (exponentiation), unary - (negation), * and /, + and -, relational operators (> = <), NOT, AND, OR. Parentheses may override order; parentheses may be nested up to ten levels. Table 1-3 lists operators with examples.",
      "references": [
        {
          "chunk": "arithmetic_operations",
          "topic": "arithmetic operator precedence examples"
        },
        {
          "chunk": "string_operations_and_concatenation",
          "topic": "how concatenation interacts with expression evaluation"
        }
      ]
    },
    {
      "start": 1540,
      "end": 1563,
      "name": "string_comparisons_and_results",
      "description": "How strings are compared using relational operators: left-to-right character code comparison using PET/CBM character set, shorter string considered less if prefix equal, leading/trailing blanks significant. Comparisons always produce an integer result (-1 or 0) usable in calculations except as divisor.",
      "references": [
        {
          "chunk": "screen_display_codes_table",
          "topic": "character codes used for string comparison (Appendix C referenced)"
        }
      ]
    },
    {
      "start": 1564,
      "end": 1578,
      "name": "string_expressions_and_concatenation",
      "description": "String expressions and concatenation: only '+' is defined for string concatenation in CBM BASIC; concatenation appends the right string to the left; results can be printed, compared, or assigned; mixing string and numeric types in comparisons or assignments causes ?TYPE MISMATCH. Examples showing concatenation and explicit spacing.",
      "references": [
        {
          "chunk": "chr$_function",
          "topic": "use CHR$ to insert control characters inside strings"
        }
      ]
    },
    {
      "start": 1579,
      "end": 1619,
      "name": "programming_techniques_and_data_conversions",
      "description": "Programming techniques: Data conversion rules used by the CBM BASIC interpreter: arithmetic and relational ops done in floating-point (integers converted temporarily), logical ops convert to integers, assignment converts to declared variable type, floating->integer truncates fractional part, and range checks cause ?ILLEGAL QUANTITY.",
      "references": [
        {
          "chunk": "variables_types_and_naming",
          "topic": "type declaration characters % and $"
        },
        {
          "chunk": "arithmetic_operations",
          "topic": "floating-point conversion behavior during arithmetic"
        }
      ]
    },
    {
      "start": 1620,
      "end": 1694,
      "name": "using_input_statement",
      "description": "Using the INPUT statement: explanation of variables as storage compartments for user input, difference between numeric and string variables (suffixes), examples demonstrating INPUT into variables and using them in calculations or PRINT statements, including prompts and concatenated print output; notes on message formatting and example programs.",
      "references": [
        {
          "chunk": "string_expressions_and_concatenation",
          "topic": "printing strings and variables together"
        }
      ]
    },
    {
      "start": 1695,
      "end": 1734,
      "name": "income_expense_budget_example",
      "description": "Income/Expense BASIC example program and its listing: interactive INPUT of income and three expense categories/amounts, calculations of totals and percentages, screen clearing, delay loop and repeat prompt. Includes a note about constraints (IN cannot be 0 and not all E1..E3 can be 0).",
      "references": [
        {
          "chunk": "using_input_statement",
          "topic": "INPUT usage in a practical example"
        }
      ]
    },
    {
      "start": 1735,
      "end": 1785,
      "name": "income_expense_line_by_line_explanation",
      "description": "Line-by-line explanation table for the Income/Expense example: meaning of each key line (clearing screen, prompting, accumulating totals, printing formatted output, delay loop) and further examples showing basic arithmetic usage (C=A*B, PRINT usage).",
      "references": [
        {
          "chunk": "income_expense_budget_example",
          "topic": "program listing"
        }
      ]
    },
    {
      "start": 1786,
      "end": 1820,
      "name": "printing_dollar_sign_and_string_variable_trick",
      "description": "How to PRINT symbols like $ next to numeric values: put $ inside quotes or store it in a string variable (Z$=\"$\") and PRINT Z$A. Explanation why $ must be printed as a string, not directly attached to numeric variable names.",
      "references": [
        {
          "chunk": "string_constants_and_rules",
          "topic": "string constant quoting rules"
        }
      ]
    },
    {
      "start": 1821,
      "end": 1905,
      "name": "using_get_statement_and_screen_edit_examples",
      "description": "GET statement: keyboard buffer behavior (10 chars), polling loop examples (GET A$: IF A$ = \"\" THEN 10), example screen-editor behaviors (no cursor printed, capturing typed characters), use of CHR$ codes for function keys (example lines mapping CHR$(133..136) to actions), and notes about buffer overflow and GET in loops.",
      "references": [
        {
          "chunk": "chr$_function",
          "topic": "CHR$ codes and use in GET-based editors"
        }
      ]
    },
    {
      "start": 1906,
      "end": 1940,
      "name": "how_to_crunch_basic_programs_overview",
      "description": "Introduction to program 'crunching' techniques to shorten BASIC programs: motivations (save memory, leave more RAM for data), and general approaches overview (abbreviations, line number shortening, multiple statements per line, REM removal).",
      "references": [
        {
          "chunk": "abbreviating_keywords_and_tokenization",
          "topic": "BASIC keyword abbreviations and tokenization"
        }
      ]
    },
    {
      "start": 1941,
      "end": 1980,
      "name": "abbreviating_keywords_and_shortening_techniques",
      "description": "Specific crunching techniques: use of keyword abbreviations (Appendix A) and how abbreviations are tokenized and don't save memory in saved programs, shortening line numbers to reduce memory for GOTO/GOSUB references, and putting multiple instructions on a line separated by colons.",
      "references": [
        {
          "chunk": "rem_statements_removal",
          "topic": "removing REM statements after development"
        }
      ]
    },
    {
      "start": 1981,
      "end": 2013,
      "name": "rem_statements_and_using_variables",
      "description": "Advice to remove REM statements to save space when finalizing programs; using variables to shorten repeated values or addresses (examples replacing POKE addresses with variables like V=54296), and general tip to use arrays/READ DATA for large data sets.",
      "references": [
        {
          "chunk": "using_arrays_and_data_statements",
          "topic": "using DIM/READ/DATA to manage large datasets"
        }
      ]
    },
    {
      "start": 2014,
      "end": 2038,
      "name": "using_arrays_read_data_and_eliminating_spaces",
      "description": "Using READ/DATA and arrays/matrices to pack large amounts of data efficiently; eliminating unnecessary spaces in BASIC for memory savings; using GOSUB routines and TAB/SPC for formatting.",
      "references": [
        {
          "chunk": "data_statement",
          "topic": "DATA statements and READ usage"
        },
        {
          "chunk": "dim_statement_and_memory_calculation",
          "topic": "DIM and array memory calculation"
        }
      ]
    },
    {
      "start": 2039,
      "end": 2067,
      "name": "gosub_tab_spc_and_general_crunching_tips",
      "description": "Additional crunching tips: use GOSUB to reuse code, use TAB and SPC for screen positioning instead of many cursor commands, and other small optimizations.",
      "references": [
        {
          "chunk": "for_loop_statement",
          "topic": "use loops effectively to reduce repeated code"
        }
      ]
    },
    {
      "start": 2068,
      "end": 2115,
      "name": "chapter2_header_and_overview",
      "description": "Chapter 2 heading: 'BASIC LANGUAGE VOCABULARY' with topics listed: Introduction, BASIC keywords/abbreviations/function types, description of keywords (alphabetical), Commodore 64 keyboard/features, and Screen Editor. Intro about abbreviations and built-in functions types (numeric/string) and argument conventions.",
      "references": [
        {
          "chunk": "basic_keywords_table",
          "topic": "table of BASIC keywords, abbreviations and function types"
        }
      ]
    },
    {
      "start": 2116,
      "end": 2172,
      "name": "chapter2_introduction_functions_and_abbreviations",
      "description": "Explanation of CBM BASIC keywords: how abbreviations work (type enough letters then SHIFT on last letter), that abbreviations are tokenized (do not save memory in saved programs), built-in function argument rules (parentheses directly after keyword, no space), and that string-returning functions end with '$'.",
      "references": [
        {
          "chunk": "how_to_use_syntax_conventions",
          "topic": "syntax rules for parentheses and spacing"
        }
      ]
    },
    {
      "start": 2173,
      "end": 2175,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2176,
      "end": 2206,
      "name": "basic_keywords_abs_to_dim",
      "description": "Table header and BASIC keyword entries for ABS, AND, ASC, ATN, CHR$, CLOSE, CLR, CMD, CONT, COS, DATA, DEF, DIM \u2014 showing each command's keyboard abbreviation (SHIFT key sequences), how it appears on the screen (token label where present), and the function type (numeric, string, special, or blank).",
      "references": [
        {
          "chunk": "ignored_page_header_vocabulary_31",
          "topic": "page header / non-technical separator that follows this table segment"
        },
        {
          "chunk": "basic_keywords_end_to_log",
          "topic": "next block of BASIC keywords (END through LOG)"
        }
      ]
    },
    {
      "start": 2207,
      "end": 2211,
      "name": "ignored_page_header_vocabulary_31",
      "description": "Non-technical page header and separator lines: contains the center page heading 'BASIC LANGUAGE VOCABULARY   31' and decorative tilde/spacing. Marked as ignored (non-technical).",
      "references": [
        {
          "chunk": "basic_keywords_abs_to_dim",
          "topic": "previous block of BASIC keywords (ABS\u2013DIM)"
        },
        {
          "chunk": "basic_keywords_end_to_log",
          "topic": "next block of BASIC keywords (END\u2013LOG)"
        }
      ],
      "ignore": true,
      "reason": "Non-technical page header and separator lines: contains the center page heading 'BASIC LANGUAGE VOCABULARY   31' and decorative tilde/spacing. Marked as ignored (non-technical)."
    },
    {
      "start": 2212,
      "end": 2251,
      "name": "basic_keywords_end_to_log",
      "description": "Table header repeated and BASIC keyword entries for END, EXP, FN, FOR, FRE, GET#, GOSUB, GOTO, IF, INPUT, INPUT#, INT, LEFT$, LEN, LET, LIST, LOAD, LOG \u2014 including keyboard abbreviations, screen tokens (where applicable), and function type classification.",
      "references": [
        {
          "chunk": "basic_keywords_abs_to_dim",
          "topic": "previous block of BASIC keywords (ABS\u2013DIM)"
        },
        {
          "chunk": "ignored_page_footer_vocabulary_32",
          "topic": "page footer / non-technical separator that follows this table segment"
        },
        {
          "chunk": "basic_keywords_mid_to_run",
          "topic": "next block of BASIC keywords (MID$ through RUN)"
        }
      ]
    },
    {
      "start": 2252,
      "end": 2258,
      "name": "ignored_page_footer_vocabulary_32",
      "description": "Non-technical page footer and separator lines including the page number '32   BASIC LANGUAGE VOCABULARY' and decorative tilde. Marked as ignored (non-technical).",
      "references": [
        {
          "chunk": "basic_keywords_end_to_log",
          "topic": "previous block of BASIC keywords (END\u2013LOG)"
        },
        {
          "chunk": "basic_keywords_mid_to_run",
          "topic": "next block of BASIC keywords (MID$\u2013RUN)"
        }
      ],
      "ignore": true,
      "reason": "Non-technical page footer and separator lines including the page number '32   BASIC LANGUAGE VOCABULARY' and decorative tilde. Marked as ignored (non-technical)."
    },
    {
      "start": 2259,
      "end": 2300,
      "name": "basic_keywords_mid_to_run",
      "description": "Table header repeated and BASIC keyword entries for MID$, NEW, NEXT, NOT, ON, OPEN, OR, PEEK, POKE, POS, PRINT, PRINT#, READ, REM, RESTORE, RETURN, RIGHT$, RND, RUN \u2014 showing abbreviations, screen tokens, and function type where indicated.",
      "references": [
        {
          "chunk": "ignored_page_footer_vocabulary_32",
          "topic": "page footer / non-technical separator that precedes this block"
        },
        {
          "chunk": "ignored_page_header_vocabulary_33",
          "topic": "page header / non-technical separator inside the following pages"
        },
        {
          "chunk": "basic_keywords_save_to_wait",
          "topic": "subsequent block of BASIC keywords (SAVE through WAIT)"
        }
      ]
    },
    {
      "start": 2301,
      "end": 2304,
      "name": "ignored_page_header_vocabulary_33",
      "description": "Non-technical page header and separator lines including the center heading 'BASIC LANGUAGE VOCABULARY   33' and decorative tilde. Marked as ignored (non-technical).",
      "references": [
        {
          "chunk": "basic_keywords_mid_to_run",
          "topic": "previous block of BASIC keywords (MID$\u2013RUN)"
        },
        {
          "chunk": "basic_keywords_save_to_wait",
          "topic": "next block of BASIC keywords (SAVE\u2013WAIT)"
        }
      ],
      "ignore": true,
      "reason": "Non-technical page header and separator lines including the center heading 'BASIC LANGUAGE VOCABULARY   33' and decorative tilde. Marked as ignored (non-technical)."
    },
    {
      "start": 2305,
      "end": 2346,
      "name": "basic_keywords_save_to_wait",
      "description": "Continuation of the BASIC keywords table with entries for SAVE, SGN, SIN, SPC(, SQR, STATUS, STEP, STOP, STR$, SYS, TAB(, TAN, THEN, TIME/TI/TI$, TO, USR, VAL, VERIFY, WAIT and the table closing border \u2014 includes keyboard abbreviations, displayed screen tokens, and function type classification (numeric, string, special, etc.).",
      "references": [
        {
          "chunk": "basic_keywords_mid_to_run",
          "topic": "previous block of BASIC keywords (MID$\u2013RUN)"
        },
        {
          "chunk": "ignored_page_header_vocabulary_33",
          "topic": "page header / non-technical separator that precedes this block"
        }
      ]
    },
    {
      "start": 2347,
      "end": 2369,
      "name": "description_of_basic_keywords_start",
      "description": "Start of 'Description of BASIC Keywords' section; first keyword entry ABS: ABS(<expression>) returns absolute value; examples showing usage in assignments and tests.",
      "references": [
        {
          "chunk": "abs_function",
          "topic": "ABS examples and use"
        }
      ]
    },
    {
      "start": 2370,
      "end": 2460,
      "name": "and_operator_description",
      "description": "AND operator: format <expression> AND <expression>; used both for Boolean (bitwise) testing and to check truth of both operands in logical expressions. Describes 1-bit and 16-bit AND examples, allowed numeric range (-32768..+32767), conversion of true/false to -1/0, and examples combining AND with truth tests.",
      "references": [
        {
          "chunk": "boolean_truth_table",
          "topic": "AND truth behaviors"
        }
      ]
    },
    {
      "start": 2461,
      "end": 2486,
      "name": "asc_function",
      "description": "ASC(<string>): returns numeric Commodore ASCII code (0..255) for first character of string. Appendix C maps codes. Notes ILLEGAL QUANTITY error if string empty, and suggested workaround using CHR$(0) appended to string.",
      "references": [
        {
          "chunk": "chr$_function",
          "topic": "use CHR$ to create characters by code (e.g., CHR$(0))"
        }
      ]
    },
    {
      "start": 2487,
      "end": 2508,
      "name": "atn_function",
      "description": "ATN(<number>): returns arctangent of number (angle in radians whose tangent is the number). Result in range -pi/2..+pi/2. Example converting to degrees: ATN(J)*180/{pi}.",
      "references": [
        {
          "chunk": "abs_function",
          "topic": "other numeric math functions (ABS, EXP, etc.)"
        }
      ]
    },
    {
      "start": 2509,
      "end": 2524,
      "name": "chr$_function",
      "description": "CHR$(<number>): returns string containing the PET/CBM character corresponding to a numeric code (0..255). Examples: CHR$(65) = 'A', CHR$(13) = RETURN. Using ASC and CHR$ to convert back and forth between codes and characters.",
      "references": [
        {
          "chunk": "asc_function",
          "topic": "ASC returns numeric codes used by CHR$"
        }
      ]
    },
    {
      "start": 2525,
      "end": 2554,
      "name": "close_statement",
      "description": "CLOSE <file number>: shuts off data file/channel opened to a device. For disk/cassette it flushes incomplete buffers and finalizes files; for other devices it frees resources. Examples of CLOSE usage.",
      "references": [
        {
          "chunk": "cmd_statement_and_usage",
          "topic": "CMD and PRINT# interactions with OPEN/CLOSE"
        }
      ]
    },
    {
      "start": 2555,
      "end": 2604,
      "name": "clr_statement_and_effects",
      "description": "CLR: makes available RAM used by variables, arrays, GOSUB addresses, FOR..NEXT loops, user-defined functions and files; BASIC program itself remains. Notes that CLR does not properly close disk/tape files (information lost to computer and drive may still think file is open). Example illustrating variables cleared by CLR.",
      "references": [
        {
          "chunk": "close_statement",
          "topic": "proper file close vs CLR behavior for disks/tape"
        }
      ]
    },
    {
      "start": 2605,
      "end": 2652,
      "name": "cmd_statement_and_usage",
      "description": "CMD <file number>[,string]: redirect primary output device from TV screen to OPENed file/device (printer, tape, disk, modem). When in effect, PRINT and LIST output to device. Advice to send a blank line with PRINT# before CLOSE to unlisten device and bring output back; examples for listing to printer and writing to tape file buffers.",
      "references": [
        {
          "chunk": "close_statement",
          "topic": "how to finalize file output properly (PRINT# then CLOSE)"
        }
      ]
    },
    {
      "start": 2653,
      "end": 2691,
      "name": "cont_command_usage",
      "description": "CONT: resumes execution of a program halted by STOP, END or RUN/STOP key at the place it left off. Notes about 'CAN'T CONTINUE' error after editing program or when halted by certain errors; example using a PI approximation loop to demonstrate BREAK and CONT.",
      "references": [
        {
          "chunk": "stop_and_end_statements",
          "topic": "difference between STOP and END"
        }
      ]
    },
    {
      "start": 2692,
      "end": 2704,
      "name": "cos_function",
      "description": "COS(<number>): returns cosine of number (angle in radians). Example converting degrees to radians COS(Y*{pi}/180).",
      "references": [
        {
          "chunk": "sin_and_trig_functions",
          "topic": "other trig functions such as SIN, TAN"
        }
      ]
    },
    {
      "start": 2705,
      "end": 2739,
      "name": "data_statement",
      "description": "DATA <list of constants>: stores literal data in program lines for later consumption by READ statements. DATA lines are not executed; treated as continuous list from lowest to highest line number. Strings containing commas, colons, blanks must be quoted. Examples given for numeric and string DATA entries.",
      "references": [
        {
          "chunk": "using_arrays_and_data_statements",
          "topic": "use READ to pull data into arrays or variables"
        }
      ]
    },
    {
      "start": 2740,
      "end": 2788,
      "name": "def_fn_user_defined_functions",
      "description": "DEF FN <name>(<variable>) = <expression>: defines a user function (FN prefix + name) that can be used later; saves space by defining a formula once. Function name is FN plus a 1-2 character identifier. DEF must be executed once; using FN before DEF causes UNDEF'D FUNCTION error. Examples of DEF FN and usage.",
      "references": [
        {
          "chunk": "fn_function_reference",
          "topic": "calling a user-defined FN after DEF"
        }
      ]
    },
    {
      "start": 2789,
      "end": 2861,
      "name": "dim_statement_and_memory_calculation",
      "description": "DIM <variable>(<subscripts>): declares arrays and sizes. Lowest element index is zero; highest is number given (max 32767). DIM must be executed once per array (re-DIM causes REDIM'D ARRAY error). Automatic dimensioning to 11 elements occurs if first reference uses subscripts without a DIM. Examples of DIM usage and a football scoreboard example. Memory calculation rules: 5 bytes for array name, 2 bytes per dimension, and per-element bytes depending on type (2 bytes int, 5 bytes float, 3 bytes per string element plus 1 byte per character).",
      "references": [
        {
          "chunk": "arrays_overview_and_dimensions",
          "topic": "array structure and implicit DIM behavior"
        }
      ]
    },
    {
      "start": 2862,
      "end": 2863,
      "ignore": true,
      "reason": "Lines are blank/page formatting between chunks (non-technical), safe to ignore."
    },
    {
      "start": 2864,
      "end": 2869,
      "ignore": true,
      "reason": "Page footer / formatting"
    },
    {
      "start": 2870,
      "end": 2894,
      "name": "end_statement_and_exp_function",
      "description": "END: terminates program execution and shows READY (vs STOP which shows BREAK IN LINE). Recommended to end programs with END. EXP(<number>): numeric function returning e^number where e = 2.71828183; values > 88.0296919 cause overflow. Examples for both END and EXP included.",
      "references": [
        {
          "chunk": "cont_command_usage",
          "topic": "CONT behavior after END or STOP"
        }
      ]
    },
    {
      "start": 2895,
      "end": 2908,
      "name": "exp_function",
      "description": "EXP(number) function: returns e^number (e \u2248 2.71828183). Notes: overflow for arguments > 88.0296919. Examples of usage.",
      "references": [
        {
          "chunk": "log_function",
          "topic": "LOG is inverse of EXP (natural logs)"
        }
      ]
    },
    {
      "start": 2909,
      "end": 2912,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 2913,
      "end": 2934,
      "name": "fn_function_reference",
      "description": "FN <name>(<number>): calls a previously DEFined function; substitutes arguments into the function definition and returns numeric value. DEF FN must have been executed previously or UNDEF'D FUNCTION error results. Examples of FN usage in expressions and control flow.",
      "references": [
        {
          "chunk": "def_fn_user_defined_functions",
          "topic": "DEF FN to create user-defined functions"
        }
      ]
    },
    {
      "start": 2935,
      "end": 2936,
      "name": "fn_user_defined_function",
      "description": "FN name(number) user-defined function: references a previously DEFined formula, substitution of the numeric argument, errors if used before definition (UNDEF'D FUNCTION). Examples of calling FN functions.",
      "references": [
        {
          "chunk": "def_statement",
          "topic": "DEF to define FN functions"
        }
      ]
    },
    {
      "start": 2937,
      "end": 3000,
      "name": "for_loop_statement",
      "description": "FOR <variable> = <start> TO <limit> [STEP <increment>]: loop counter construct. Explains behavior: initialization, NEXT increments (default STEP +1), comparison to limit to decide continuation (exceeding limit ends loop; if step negative, test reversed), loop executes at least once. Example program counting with FOR/NEXT and a note that a loop always executes at least once. Example start: 'FOR L = 100 TO 0 STEP -1'.",
      "references": [
        {
          "chunk": "operator_precedence_hierarchy",
          "topic": "expressions used for start/limit/step can include arithmetic expressions"
        },
        {
          "chunk": "next_and_for_structure",
          "topic": "use of NEXT to close FOR loops"
        }
      ]
    },
    {
      "start": 3001,
      "end": 3008,
      "name": "for_to_step_statement",
      "description": "FOR <var>=<start> TO <limit> [STEP <inc>]: describes loop initialization, how NEXT increments the loop variable, default STEP of +1, behavior when limit exceeded, positive/negative step semantics, note that loop executes at least once, and examples including negative and fractional STEP values.",
      "references": [
        {
          "chunk": "next_statement",
          "topic": "NEXT pairs with FOR and handling nested loops"
        },
        {
          "chunk": "step_statement",
          "topic": "details about STEP usage and constraints"
        }
      ]
    },
    {
      "start": 3009,
      "end": 3036,
      "name": "fre_function",
      "description": "FRE(variable) function: returns a number indicating how much RAM is available for programs/variables. Notes: argument not used; if FRE result negative add 65536 to get bytes available; recommended expression to always get correct available RAM: PRINT FRE(0) - (FRE(0) < 0)*65536. Examples.",
      "references": [
        {
          "chunk": "memory_map_and_limits",
          "topic": "how available RAM relates to BASIC memory layout"
        }
      ]
    },
    {
      "start": 3037,
      "end": 3038,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3039,
      "end": 3068,
      "name": "get_statement",
      "description": "GET <variable list>: reads single keystrokes from keyboard buffer (up to 10 in buffer). Behavior: reading numeric variable with non-digit causes ?SYNTAX ERROR; recommended to read as strings and convert later. Example usage including looping until a key is hit.",
      "references": [
        {
          "chunk": "keyboard_buffer_and_peek",
          "topic": "keyboard buffer behavior and using PEEK to read key state"
        },
        {
          "chunk": "input_statement",
          "topic": "difference between GET and INPUT"
        }
      ]
    },
    {
      "start": 3069,
      "end": 3070,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3071,
      "end": 3096,
      "name": "get_hash_device_get",
      "description": "GET# file_number, variable_list: reads characters one-at-a-time from an open device/file. Returns empty string or 0 if no character received. Special handling of separators (comma, CR). When used with device #3 (screen) reads characters from screen and moves cursor one position; logical line end is CHR$(13). Examples of GET# use with device/file numbers.",
      "references": [
        {
          "chunk": "open_statement",
          "topic": "must OPEN a file/device before using GET#"
        },
        {
          "chunk": "print_hash",
          "topic": "related I/O PRINT# and INPUT#"
        }
      ]
    },
    {
      "start": 3097,
      "end": 3100,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3101,
      "end": 3158,
      "name": "gosub_and_stack_usage",
      "description": "GOSUB <line number>: calls a subroutine and saves return location on the stack; RETURN returns to the statement following GOSUB. Explains benefits of subroutines, example showing replacing repeated code with a GOSUB, and stack usage details (256-byte stack limits for storing return addresses; caution to ensure each GOSUB reaches a corresponding RETURN).",
      "references": [
        {
          "chunk": "return_statement",
          "topic": "RETURN behavior and usage"
        },
        {
          "chunk": "stack_overflow_and_limits",
          "topic": "stack limitations and effects on program"
        }
      ]
    },
    {
      "start": 3159,
      "end": 3160,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3161,
      "end": 3180,
      "name": "goto_statement",
      "description": "GOTO <line number> (or GO TO): unconditional jump to specified program line. Notes: GOTO without a number equals GOTO 0; possible to create infinite loops (e.g., 10 GOTO 10); example usages.",
      "references": [
        {
          "chunk": "if_statement",
          "topic": "conditional branching alternatives (IF...THEN... GOTO)"
        }
      ]
    },
    {
      "start": 3181,
      "end": 3181,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3182,
      "end": 3245,
      "name": "if_then_statement",
      "description": "IF <expression> THEN <line number> | IF <expression> GOTO <line number> | IF <expression> THEN <statements>: conditional evaluation semantics\u2014WHEN false, part after THEN ignored; WHEN true either branches to line or executes statements. Examples: IF used for validation and conditional inline statements; THEN GOTO shorthand explanation; example demonstrating multiple statements after THEN separated by colons.",
      "references": [
        {
          "chunk": "on_statement",
          "topic": "ON statement as an alternative to multiple IFs"
        }
      ]
    },
    {
      "start": 3246,
      "end": 3301,
      "name": "input_statement",
      "description": "INPUT [\"prompt\";] <variable list>: prompts user with ? (and optional quoted prompt), waits for input terminated by RETURN. Behavior: semicolon required between prompt and variables; entering blank RETURN leaves variable unchanged; extra input triggers ?EXTRA IGNORED; INPUT can't be used outside a program (needs buffer). Examples.",
      "references": [
        {
          "chunk": "get_statement",
          "topic": "GET vs INPUT for keystroke reading"
        }
      ]
    },
    {
      "start": 3302,
      "end": 3303,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3304,
      "end": 3339,
      "name": "input_hash_statement",
      "description": "INPUT# <file number>, <variable list>: reads variables from an open device/file as whole variables (up to 80 chars). Terminators: CR (CHR$(13)), comma, semicolon, colon. Behavior: non-numeric data into numeric variables causes BAD DATA; strings >80 cause STRING TOO LONG; with device #3 reads an entire logical line and moves cursor. Examples of reading from file numbers.",
      "references": [
        {
          "chunk": "open_statement",
          "topic": "must OPEN a file/device before using INPUT#"
        }
      ]
    },
    {
      "start": 3340,
      "end": 3355,
      "name": "int_function",
      "description": "INT(numeric): returns integer part of expression. For positive values truncates fractional part; for negative values returns next lower integer (floor). Example showing INT(99.4343) and INT(-12.34).",
      "references": []
    },
    {
      "start": 3356,
      "end": 3375,
      "name": "left_string_function_left$",
      "description": "LEFT$(string, integer): returns leftmost 'integer' characters of string. Integer range 0\u2013255. If integer > length returns whole string. If integer=0 returns null string. Example using LEFT$ to extract 'COMMODORE'.",
      "references": [
        {
          "chunk": "right_string_function_right$",
          "topic": "complementary RIGHT$ function"
        },
        {
          "chunk": "mid_string_function_mid$",
          "topic": "MID$ for extracting substrings from the middle"
        }
      ]
    },
    {
      "start": 3376,
      "end": 3400,
      "name": "len_function",
      "description": "LEN(string): returns number of characters in the string, counting blanks and non-printed characters. Example showing LEN on 'COMMODORE COMPUTER' returning 18.",
      "references": []
    },
    {
      "start": 3401,
      "end": 3402,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3403,
      "end": 3420,
      "name": "let_statement",
      "description": "LET <variable> = <expression> (LET optional): assigns value to variable; LET keyword is optional and often omitted to save memory. Examples showing LET with numeric and string assignments and concatenation.",
      "references": []
    },
    {
      "start": 3421,
      "end": 3423,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3424,
      "end": 3480,
      "name": "list_command",
      "description": "LIST [[first-line]-[last-line]]: displays lines of BASIC program currently in memory using screen editor. Behavior: defaults to entire program, can specify ranges with hyphen and single endpoint formats. Control keys: CTRL slows scrolling; RUN/STOP aborts LIST. LIST returns to READY; examples of LIST usage including using LIST in program.",
      "references": [
        {
          "chunk": "screen_editor",
          "topic": "editing lines after LIST using screen editor"
        }
      ]
    },
    {
      "start": 3481,
      "end": 3573,
      "name": "load_command",
      "description": "LOAD [\"file-name\"][,device][,address]: reads program from tape/disk into memory. Defaults: device 1 (cassette) if omitted; disk usually device 8. LOAD closes open files; in direct mode does CLR before reading; in-program LOAD executes new program (chain) without clearing variables. Tape/disk file name matching and behavior, default load address 2048 unless secondary address 1 used to load to original save location. Examples for tape and disk, including LOAD\"*\",8, and LOAD with address 1 to restore original memory location.",
      "references": [
        {
          "chunk": "save_command",
          "topic": "SAVE to store programs with optional address"
        },
        {
          "chunk": "verify_command",
          "topic": "VERIFY to compare saved program with memory"
        }
      ]
    },
    {
      "start": 3574,
      "end": 3590,
      "name": "log_function",
      "description": "LOG(numeric): returns natural logarithm (base e) of argument. Error if argument <= 0 (ILLEGAL QUANTITY). Example of computing base-10 log via change of base using LOG(ARG)/LOG(10).",
      "references": [
        {
          "chunk": "exp_function",
          "topic": "EXP and LOG inverse relationship"
        }
      ]
    },
    {
      "start": 3591,
      "end": 3591,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3592,
      "end": 3621,
      "name": "mid_string_function_mid$",
      "description": "MID$(string, numeric-1 [, numeric-2]): returns substring starting at numeric-1 position (1-based) for length numeric-2. numeric arguments 0\u2013255. If start > length or length=0 returns null string. If numeric-2 omitted returns substring to end. Example assembling 'GOOD EVENING' using MID$.",
      "references": [
        {
          "chunk": "left_string_function_left$",
          "topic": "LEFT$ for leftmost extraction"
        },
        {
          "chunk": "right_string_function_right$",
          "topic": "RIGHT$ for rightmost extraction"
        }
      ]
    },
    {
      "start": 3622,
      "end": 3644,
      "name": "new_command",
      "description": "NEW: deletes program in memory and clears all variables. Advises using NEW in direct mode before typing a new program. Warns of trouble debugging if NEW used inside program (erases everything). Examples.",
      "references": []
    },
    {
      "start": 3645,
      "end": 3645,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3646,
      "end": 3692,
      "name": "next_statement_and_nested_loops",
      "description": "NEXT [counter][,counter]...: ends a FOR...NEXT loop; may specify counters to end multiple nested loops (order: inner-most first). If omitted increments the current loop's counter. Loops can be nested to 9 levels. Explains incrementing by STEP and loop termination. Examples showing nested loops and use of omitted variable names.",
      "references": [
        {
          "chunk": "for_to_step_statement",
          "topic": "FOR statement details and interaction with NEXT"
        }
      ]
    },
    {
      "start": 3693,
      "end": 3694,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3695,
      "end": 3729,
      "name": "not_logical_operator",
      "description": "NOT <expression>: logical operator that complements bits of its operand (bitwise NOT) producing two's-complement integer result; operands converted to 16-bit signed integers (fractions lost). Also used to reverse boolean comparisons. Example of numeric NOT and relation to two's-complement: note showing X = (-(X+1)) to compute NOT.",
      "references": [
        {
          "chunk": "or_logical_operator",
          "topic": "OR and other logical operators operate on same integer domain"
        }
      ]
    },
    {
      "start": 3730,
      "end": 3762,
      "name": "on_statement",
      "description": "ON <variable> GOTO/GOSUB line1,line2,...: jumps to one of listed lines depending on integer value of variable (fraction truncated). If value zero or out of range, statement ignored. Negative variable yields ?ILLEGAL QUANTITY. Shows examples where ON replaces multiple IF...THENs.",
      "references": [
        {
          "chunk": "if_then_statement",
          "topic": "ON as alternative to multiple conditional IF statements"
        }
      ]
    },
    {
      "start": 3763,
      "end": 3775,
      "name": "open_statement_overview_and_format",
      "description": "Defines the OPEN statement: its TYPE (I/O), FORMAT (OPEN <file-num>,[<device>][,<address>][,\"<File-name> [,<type>] [,<mode>] \"]), and the action (opens a channel for I/O). Notes that not all parts are required for every OPEN and that some OPENs require only two codes: logical file number and device number.",
      "references": [
        {
          "chunk": "logical_file_number",
          "topic": "details about <file-num> range and use"
        },
        {
          "chunk": "device_number_and_defaults",
          "topic": "details about <device>, secondary addresses and defaults"
        }
      ]
    },
    {
      "start": 3776,
      "end": 3786,
      "name": "logical_file_number",
      "description": "Explains the <file-num> (logical file number) and how it relates OPEN, CLOSE, CMD, GET#, INPUT#, and PRINT# statements to each other and to the filename and device. Specifies range (1\u2013255) and that any number in that range may be assigned. Includes the NOTE advising conventionally to use file numbers below 127 (avoid >128).",
      "references": [
        {
          "chunk": "open_statement_overview_and_format",
          "topic": "format and where <file-num> appears"
        },
        {
          "chunk": "open_examples",
          "topic": "example uses of logical file numbers"
        }
      ]
    },
    {
      "start": 3787,
      "end": 3803,
      "name": "device_number_and_defaults",
      "description": "Describes the <device> number for each peripheral (printer, disk drive, cassette) and the concept of secondary addresses (codes telling devices what operation to perform). States that the device logical file number is used with GET#, INPUT#, and PRINT#. Explains default behavior: if <device> is omitted it defaults to Datassette (device 1); filename can be omitted but then cannot be referenced by name later; omitting secondary address for cassette defaults to 0 (READ).",
      "references": [
        {
          "chunk": "logical_file_number",
          "topic": "relation between logical file numbers and devices"
        },
        {
          "chunk": "cassette_and_disk_secondary_addresses",
          "topic": "specific secondary address meanings for cassette and disk"
        }
      ]
    },
    {
      "start": 3804,
      "end": 3809,
      "name": "page_header_and_artifact_ignored",
      "description": "Ignored non-technical page header/artifact from the original manual (page title/footer and formatting artifacts). This section is non-technical and marked ignored.",
      "references": [
        {
          "chunk": "cassette_and_disk_secondary_addresses",
          "topic": "continues technical content following header"
        }
      ],
      "ignore": true,
      "reason": "Ignored non-technical page header/artifact from the original manual (page title/footer and formatting artifacts). This section is non-technical and marked ignored."
    },
    {
      "start": 3810,
      "end": 3818,
      "name": "cassette_and_disk_secondary_addresses",
      "description": "Details secondary-address meanings: for cassette, secondary=1 opens for writing; secondary=2 writes an end-of-tape marker on close (prevents reading past data and getting ?DEVICE NOT PRESENT). For disk files, secondary addresses 2\u201314 are available for data files and other numbers have special meanings in DOS commands. States that a secondary address must be used for disk drives and refers to the disk drive manual for DOS command details.",
      "references": [
        {
          "chunk": "device_number_and_defaults",
          "topic": "introduces secondary addresses and default cassette secondary address"
        },
        {
          "chunk": "file_name_type_and_modes",
          "topic": "how file type/mode interact with disk usage"
        }
      ]
    },
    {
      "start": 3819,
      "end": 3826,
      "name": "file_name_type_and_modes",
      "description": "Explains the <file-name> (1\u201316 characters) and when it is optional (cassette or printer). Describes default file type (Program) if <type> is omitted unless <mode> is given. Describes modes: sequential files default to read (<mode>=R) unless <mode>=W for writing. States that <type>=REL is used for Relative files; Relative and Sequential files are disk-only.",
      "references": [
        {
          "chunk": "cassette_and_disk_secondary_addresses",
          "topic": "disk-specific address and file-type notes"
        },
        {
          "chunk": "errors_when_opening_files",
          "topic": "error conditions when opening files with types/modes"
        },
        {
          "chunk": "open_examples",
          "topic": "examples demonstrating file-name, type, and mode usage"
        }
      ]
    },
    {
      "start": 3827,
      "end": 3835,
      "name": "errors_when_opening_files",
      "description": "Lists BASIC/DOS error conditions related to OPEN: ?FILE NOT OPEN if accessing before OPEN; ?FILE NOT FOUND if opening for reading a non-existent file; FILE EXISTS (DOS) if opening for writing and the filename already exists (disk only); warns that tape has no such check (risk overwriting); FILE OPEN occurs if attempting to OPEN a file already open. Notes to consult Printer Manual for printer-specific details.",
      "references": [
        {
          "chunk": "file_name_type_and_modes",
          "topic": "causes related to mode/type selection"
        },
        {
          "chunk": "open_examples",
          "topic": "examples that may trigger or avoid these errors"
        }
      ]
    },
    {
      "start": 3836,
      "end": 3854,
      "name": "footer_and_layout_ignored",
      "description": "Ignored non-technical page footer, whitespace, and layout artifacts (page number/title). Marked ignored as non-technical material.",
      "references": [
        {
          "chunk": "errors_when_opening_files",
          "topic": "technical content preceding footer"
        },
        {
          "chunk": "open_examples",
          "topic": "technical content following footer"
        }
      ],
      "ignore": true,
      "reason": "Ignored non-technical page footer, whitespace, and layout artifacts (page number/title). Marked ignored as non-technical material."
    },
    {
      "start": 3855,
      "end": 3886,
      "name": "open_statement_examples",
      "description": "Concrete examples of OPEN statements demonstrating a variety of devices, addresses, file-names, types, and modes: opening a sequential disk file; tape write with end-of-file marker; keyboard input; screen output; printer output (different device numbers); reading and writing cassette; RS-232 channel; printer uppercase/graphics vs upper/lower case; sending commands to disk. Shows use of file numbers, device numbers, secondary addresses, file-name/type/mode strings, and CHR$(10) for RS-232.",
      "references": [
        {
          "chunk": "open_statement_overview_and_format",
          "topic": "uses of syntax shown in examples"
        },
        {
          "chunk": "cassette_and_disk_secondary_addresses",
          "topic": "examples using cassette and disk secondary addresses"
        },
        {
          "chunk": "file_name_type_and_modes",
          "topic": "examples showing filename, type, and mode usage"
        }
      ]
    },
    {
      "start": 3887,
      "end": 3888,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3889,
      "end": 3903,
      "ignore": true,
      "reason": "Page footer / formatting"
    },
    {
      "start": 3904,
      "end": 3950,
      "name": "or_logical_operator",
      "description": "OR operator: performs bitwise OR when used in calculations (operands converted to 16-bit signed two's-complement) and acts as logical OR in comparisons (compound Boolean expression true if either operand true). Example showing bitwise OR on integers and explanation of resulting bit patterns.",
      "references": [
        {
          "chunk": "not_logical_operator",
          "topic": "NOT operator and two's-complement behavior"
        }
      ]
    },
    {
      "start": 3951,
      "end": 3966,
      "name": "peek_function",
      "description": "PEEK(location): returns integer 0\u2013255 read from memory location (0\u201365535). Error ?ILLEGAL QUANTITY if out of range. Examples: reading border color at 53280 and reading BASIC variable table address using PEEK(45)+PEEK(46)*256.",
      "references": [
        {
          "chunk": "poke_statement",
          "topic": "POKE writes to memory addresses read by PEEK"
        }
      ]
    },
    {
      "start": 3967,
      "end": 3967,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 3968,
      "end": 4005,
      "name": "poke_statement",
      "description": "POKE <location>,<value>: writes a one-byte (0\u2013255) value to a memory location or I/O register (location 0\u201365535). Usage for data storage, graphics, sound, loading assembly, and changing OS parameters. References mention full memory map in an appendix. Examples include POKE 1024,1 to display an 'A', updating sprite pointer with POKE 2040, and other generic examples.",
      "references": [
        {
          "chunk": "peek_function",
          "topic": "reading memory locations with PEEK"
        },
        {
          "chunk": "sprites_registers_and_pointers",
          "topic": "POKEs used to update sprite pointers and VIC-II registers"
        }
      ]
    },
    {
      "start": 4006,
      "end": 4006,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4007,
      "end": 4021,
      "name": "pos_function",
      "description": "POS(dummy): returns current cursor position (0\u201379 logical columns; 0 leftmost). On 40-column screen positions 40\u201379 refer to second screen line. Argument ignored. Example showing conditional CR when near end of line.",
      "references": [
        {
          "chunk": "print_statement",
          "topic": "POS usage in arranging printed output"
        }
      ]
    },
    {
      "start": 4022,
      "end": 4022,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4023,
      "end": 4040,
      "name": "print_statement_overview_part1",
      "description": "PRINT statement introduction: type, format, action, output-list basics, punctuation roles (blanks, commas, semicolons), 80-character logical line divided into eight 10-character zones, and how commas/semicolons position the next printed item (ends with the note that two exceptions follow).",
      "references": [
        {
          "chunk": "print_statement_exceptions_and_output_rules",
          "topic": "continues with the two exceptions and further punctuation rules"
        },
        {
          "chunk": "print_statement_examples",
          "topic": "examples showing PRINT behavior and punctuation effects"
        }
      ]
    },
    {
      "start": 4041,
      "end": 4042,
      "name": "ignored_page_header_70",
      "description": "Non-technical page header/footer lines (page title and separator) \u2014 ignored for semantic indexing.",
      "references": [
        {
          "chunk": "print_statement_overview_part1",
          "topic": "preceding PRINT overview"
        },
        {
          "chunk": "print_statement_exceptions_and_output_rules",
          "topic": "following PRINT exceptions and rules"
        }
      ],
      "ignore": true,
      "reason": "Non-technical page header/footer lines (page title and separator) \u2014 ignored for semantic indexing."
    },
    {
      "start": 4043,
      "end": 4063,
      "name": "print_statement_exceptions_and_output_rules",
      "description": "Continuation of PRINT behavior: the two exceptions (numeric items followed by an added space; positive numbers prefixed by a space), behavior of blanks between strings and numbers, effect of trailing commas/semicolons (continuing on same line) vs. no trailing punctuation (carriage-return/line-feed), and behavior when output exceeds 40 columns. Also commentary on the variety and complexity of PRINT.",
      "references": [
        {
          "chunk": "print_statement_overview_part1",
          "topic": "introductory PRINT semantics"
        },
        {
          "chunk": "print_statement_examples",
          "topic": "example prints demonstrating these rules"
        }
      ]
    },
    {
      "start": 4064,
      "end": 4087,
      "name": "print_statement_examples",
      "description": "Three concrete PRINT examples showing numeric and string printing, punctuation effects, concatenation/spacing, and resulting screen output examples.",
      "references": [
        {
          "chunk": "print_statement_exceptions_and_output_rules",
          "topic": "applies the punctuation and spacing rules described"
        }
      ]
    },
    {
      "start": 4088,
      "end": 4089,
      "name": "ignored_page_footer_71",
      "description": "Non-technical page footer lines (page title and separator) \u2014 ignored for semantic indexing.",
      "references": [
        {
          "chunk": "print_statement_examples",
          "topic": "preceding examples"
        },
        {
          "chunk": "quote_mode_overview_and_cursor_movement",
          "topic": "next technical section (Quote Mode)"
        }
      ],
      "ignore": true,
      "reason": "Non-technical page footer lines (page title and separator) \u2014 ignored for semantic indexing."
    },
    {
      "start": 4090,
      "end": 4119,
      "name": "quote_mode_overview_and_cursor_movement",
      "description": "Quote Mode introduction: how entering a quote makes cursor controls display as reversed characters so they can be programmed in strings. Description of affected keys (all cursor controls except INST/DEL) and the list of cursor control types. Example showing how to PRINT the word HELLO diagonally using <HOME> and <DOWN> encoded inside a quoted string.",
      "references": [
        {
          "chunk": "print_statement_examples",
          "topic": "PRINT examples using strings"
        },
        {
          "chunk": "quote_mode_reverse_characters",
          "topic": "how to enable reverse video via control characters"
        },
        {
          "chunk": "quote_mode_insert_mode_part1",
          "topic": "insert mode differences within quote mode"
        }
      ]
    },
    {
      "start": 4120,
      "end": 4127,
      "name": "quote_mode_reverse_characters",
      "description": "Reverse characters: how holding CTRL+9 produces a reversed-character <R> inside quotes to start reverse-video (negative display), how to end reverse printing via CTRL+0 or by printing a RETURN (CHR$(13)), and the note that ending the PRINT without trailing punctuation also ends the condition.",
      "references": [
        {
          "chunk": "quote_mode_overview_and_cursor_movement",
          "topic": "related quote-mode cursor-control programming"
        },
        {
          "chunk": "quote_mode_color_controls_intro",
          "topic": "color controls are another reversed-character technique used in quote mode"
        }
      ]
    },
    {
      "start": 4128,
      "end": 4134,
      "name": "quote_mode_color_controls_intro",
      "description": "Introduction to color controls in quote mode: holding CTRL (or C=) with color keys produces reversed characters that, when PRINTed, change text color. Introductory explanation and lead-in to the full key-to-color mapping.",
      "references": [
        {
          "chunk": "quote_mode_color_controls_list_and_example",
          "topic": "complete key-to-color mapping and example usage"
        }
      ]
    },
    {
      "start": 4135,
      "end": 4136,
      "name": "ignored_page_header_72",
      "description": "Non-technical page header/footer lines (page title and separator) \u2014 ignored for semantic indexing.",
      "references": [
        {
          "chunk": "quote_mode_color_controls_intro",
          "topic": "previous color-controls introduction"
        },
        {
          "chunk": "quote_mode_color_controls_list_and_example",
          "topic": "continued color-controls list"
        }
      ],
      "ignore": true,
      "reason": "Non-technical page header/footer lines (page title and separator) \u2014 ignored for semantic indexing."
    },
    {
      "start": 4137,
      "end": 4165,
      "name": "quote_mode_color_controls_list_and_example",
      "description": "Detailed key-to-color mapping for quote-mode color control (CTRL+1..8 for primary colors and C=+1..+8 for alternate color palette), plus an example showing how to PRINT 'HELLO' in cyan then 'THERE' in white using embedded control characters.",
      "references": [
        {
          "chunk": "quote_mode_reverse_characters",
          "topic": "reverse-character technique related to color control encoding"
        },
        {
          "chunk": "quote_mode_insert_mode_part1",
          "topic": "insert mode interactions with reversed characters inside quotes"
        }
      ]
    },
    {
      "start": 4166,
      "end": 4181,
      "name": "quote_mode_insert_mode_part1",
      "description": "Insert Mode (part 1): explanation that spaces created by INST/DEL share characteristics with quote mode (cursor and color controls show as reversed characters) and that INST and DEL behave differently \u2014 INST performs normal insertion while DEL may create a special character in quote mode. Leads into examples of DEL/INST interactions.",
      "references": [
        {
          "chunk": "quote_mode_color_controls_list_and_example",
          "topic": "color and cursor controls also appear reversed inside insert-mode spaces"
        },
        {
          "chunk": "quote_mode_insert_mode_part2_and_warning",
          "topic": "continued behavior, example using DEL/INST, and the warning about editing lines containing these characters"
        }
      ]
    },
    {
      "start": 4182,
      "end": 4183,
      "name": "ignored_page_header_73",
      "description": "Non-technical page header/footer lines (page title and separator) \u2014 ignored for semantic indexing.",
      "references": [
        {
          "chunk": "quote_mode_insert_mode_part1",
          "topic": "preceding insert-mode discussion"
        },
        {
          "chunk": "quote_mode_insert_mode_part2_and_warning",
          "topic": "continued insert-mode examples and warning"
        }
      ],
      "ignore": true,
      "reason": "Non-technical page header/footer lines (page title and separator) \u2014 ignored for semantic indexing."
    },
    {
      "start": 4184,
      "end": 4208,
      "name": "quote_mode_insert_mode_part2_and_warning",
      "description": "Insert Mode (part 2) and DEL/INST example: continuation describing the special characters produced by DEL/INST, an example PRINT that produces deletions and insertions (resulting in 'HELP'), boxed WARNING about difficulty editing lines containing DEL/INST characters (they affect LIST output as well), and the condition that insert mode ends on RETURN/SHIFT+RETURN or after typing as many characters as were inserted.",
      "references": [
        {
          "chunk": "quote_mode_insert_mode_part1",
          "topic": "previous insert-mode mechanics and differences from quote mode"
        },
        {
          "chunk": "quote_mode_other_special_characters",
          "topic": "other reversible special characters that can be embedded in quotes"
        }
      ]
    },
    {
      "start": 4209,
      "end": 4226,
      "name": "quote_mode_other_special_characters",
      "description": "Other special reversed characters usable inside quotes: how to embed less-easily-typed special characters by leaving spaces, entering reversed-mode, and typing the keys. Lists specific functions and the reversed-character keys that represent them (SHIFT+RETURN, switch lower/upper case, disable/enable case-switching keys).",
      "references": [
        {
          "chunk": "quote_mode_insert_mode_part2_and_warning",
          "topic": "practical considerations and warnings when embedding special control characters"
        },
        {
          "chunk": "quote_mode_color_controls_list_and_example",
          "topic": "other quote-mode control sequences (color and video) described earlier"
        }
      ]
    },
    {
      "start": 4227,
      "end": 4227,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4228,
      "end": 4306,
      "name": "print_hash",
      "description": "PRINT# file-number, items: writes data items to a logical file opened by OPEN. Output punctuation rules differ for tape files (comma behaves like semicolon); numeric items have leading and trailing spaces as on screen. Default termination behavior: if no punctuation ends list, CR+LF written; terminating comma/semicolon suppresses CR+LF. Examples include writing variables with CHR$(13) separators and constructing tape/disk output lines; demonstrates interplay with INPUT# for reading back.",
      "references": [
        {
          "chunk": "open_statement_and_file_device_management",
          "topic": "OPEN is required before PRINT#"
        },
        {
          "chunk": "input_hash_statement",
          "topic": "INPUT# reads data written by PRINT#"
        }
      ]
    },
    {
      "start": 4307,
      "end": 4308,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4309,
      "end": 4351,
      "name": "read_statement_and_data_interaction",
      "description": "READ <variables>: reads values from DATA statements into variables. Types must match or ?SYNTAX ERROR (reported at DATA line). READs traverse DATA list in order; exceeding DATA elements yields ?OUT OF DATA. If fewer variables specified than DATA elements, next READ resumes at following element. Example usages and relationship to RESTORE.",
      "references": [
        {
          "chunk": "data_statement",
          "topic": "DATA statements providing constants for READ"
        },
        {
          "chunk": "restore_statement",
          "topic": "RESET READ pointer back to start of DATA"
        }
      ]
    },
    {
      "start": 4352,
      "end": 4352,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4353,
      "end": 4370,
      "name": "rem_statement",
      "description": "REM [remark]: remark/comment statement ignored by BASIC during execution; used to document programs and appears when program is LISTed. REM can include any characters including BASIC keywords and colons. REM lines are executable targets for GOTO/GOSUB but are non-executed comments. Examples.",
      "references": []
    },
    {
      "start": 4371,
      "end": 4420,
      "name": "restore_statement",
      "description": "RESTORE: resets BASIC internal pointer for DATA to the first DATA constant so subsequent READs re-read DATA from beginning. Examples showing using RESTORE to fill two arrays with identical data.",
      "references": [
        {
          "chunk": "read_statement_and_data_interaction",
          "topic": "READ/RESTORE usage"
        }
      ]
    },
    {
      "start": 4421,
      "end": 4441,
      "name": "return_statement",
      "description": "RETURN: used to exit a subroutine entered with GOSUB. Execution resumes at the next executable statement after the corresponding GOSUB. Notes on nesting: each GOSUB must match at least one RETURN. Example showing GOSUB/RETURN usage.",
      "references": [
        {
          "chunk": "gosub_and_stack_usage",
          "topic": "GOSUB pushes return address onto stack; RETURN pops it"
        }
      ]
    },
    {
      "start": 4442,
      "end": 4443,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4444,
      "end": 4467,
      "name": "right_string_function_right$",
      "description": "RIGHT$(string, numeric): returns rightmost 'numeric' characters of string. numeric range 0\u2013255; zero length returns null string; numeric greater than string length returns entire string. Example printing RIGHT$(MSG$,9) to get 'COMPUTERS'.",
      "references": [
        {
          "chunk": "left_string_function_left$",
          "topic": "LEFT$ complementary function"
        },
        {
          "chunk": "mid_string_function_mid$",
          "topic": "MID$ for middle substrings"
        }
      ]
    },
    {
      "start": 4468,
      "end": 4514,
      "name": "rnd_function",
      "description": "RND(numeric): returns pseudorandom floating number in range 0.0 to 1.0. Behavior depends on sign of numeric argument: positive returns repeatable pseudorandom sequence seeded on power-up; zero reads from hardware 'jiffy' clock; negative re-seeds the generator each call. Examples showing how to scale to integer ranges and simulate dice.",
      "references": [
        {
          "chunk": "time_and_timers",
          "topic": "interaction with jiffy clock (RND(0) uses clock)"
        }
      ]
    },
    {
      "start": 4515,
      "end": 4538,
      "name": "run_command",
      "description": "RUN [<line-number>]: starts program in memory. In direct mode, RUN implies CLR (clears variables) unless using CONT or GOTO. If line-number specified starts at that line. RUN within a program resumes and may produce UNDEF'D STATEMENT if specified line doesn't exist. Program stops on END, STOP, last line executed, or BASIC error. Examples.",
      "references": [
        {
          "chunk": "cont_command",
          "topic": "CONT as alternative to RUN to resume without CLR"
        }
      ]
    },
    {
      "start": 4539,
      "end": 4540,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4541,
      "end": 4608,
      "name": "save_command",
      "description": "SAVE [\"file-name\"][,device][,address]: stores current program in memory to tape or disk (file type 'prg'). Defaults: cassette device 1 if omitted. SAVEs to tape are stored twice for error checking; optional secondary address controls loading behavior and end-of-tape markers: address 1 causes KERNAL to LOAD tape at original address later; 2 writes end-of-tape marker; 3 combines both. Disk saves require filename. Examples of various SAVE forms.",
      "references": [
        {
          "chunk": "load_command",
          "topic": "LOAD complementary behavior and addresses"
        },
        {
          "chunk": "verify_command",
          "topic": "VERIFY to check saved file"
        }
      ]
    },
    {
      "start": 4609,
      "end": 4621,
      "name": "sgn_function",
      "description": "SGN(numeric): returns integer sign of argument: 1 if positive, 0 if zero, -1 if negative. Example using ON SGN(DV)+2 to branch based on sign.",
      "references": []
    },
    {
      "start": 4622,
      "end": 4623,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4624,
      "end": 4636,
      "name": "sin_function",
      "description": "SIN(numeric): returns sine of numeric argument in radians. Relationship note: COS(x) = SIN(x + \u03c0/2). Example printing SIN(1.5).",
      "references": [
        {
          "chunk": "tan_function",
          "topic": "TAN relates to SIN/COS"
        }
      ]
    },
    {
      "start": 4637,
      "end": 4637,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4638,
      "end": 4663,
      "name": "spc_function",
      "description": "SPC(numeric): returns string of spaces used for formatting output (used with PRINT). For screen/tape numeric range 0\u2013255; for disk up to 254; for printer, printing a space in last character position may cause auto CR+LF. Example demonstrating spacing with SPC in output.",
      "references": [
        {
          "chunk": "tab_function",
          "topic": "TAB also used for formatting output"
        }
      ]
    },
    {
      "start": 4664,
      "end": 4664,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4665,
      "end": 4684,
      "name": "sqr_function",
      "description": "SQR(numeric): returns square root of numeric argument. Argument must be non-negative or ?ILLEGAL QUANTITY occurs. Example loop printing J*S and SQR(J*5).",
      "references": []
    },
    {
      "start": 4685,
      "end": 4686,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4687,
      "end": 4749,
      "name": "status_function_for_io",
      "description": "STATUS (or ST): returns completion/status code for last I/O operation on an open file. STATUS codes are bit positions with numeric values, table showing meanings for cassette read errors, serial bus R/W conditions, tape verify/load, end-of-file, end-of-tape, device not present, checksum errors etc. Examples show checking STATUS with bitwise AND to handle end-of-file and other errors.",
      "references": [
        {
          "chunk": "open_statement_and_file_device_management",
          "topic": "STATUS relevant to file/device operations after OPEN/INPUT#/PRINT#"
        }
      ]
    },
    {
      "start": 4750,
      "end": 4769,
      "name": "step_statement",
      "description": "[STEP <expression>] in FOR statement: defines increment (STEP) for the loop. Default is +1. Any value allowed (STEP 0 loops forever). STEP value cannot be changed once in loop. Examples showing positive and negative STEP values and iteration counts.",
      "references": [
        {
          "chunk": "for_to_step_statement",
          "topic": "FOR uses STEP when looping"
        }
      ]
    },
    {
      "start": 4770,
      "end": 4770,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4771,
      "end": 4796,
      "name": "stop_statement",
      "description": "STOP: halts program execution and returns to direct mode showing ?BREAK IN LINE nnnnn where nnnnn is line number of STOP. Variables and open files preserved. Program can be restarted via CONT or GOTO. Example showing STOP used conditionally.",
      "references": [
        {
          "chunk": "end_statement",
          "topic": "END vs STOP behavior"
        },
        {
          "chunk": "cont_command",
          "topic": "CONT to resume after STOP"
        }
      ]
    },
    {
      "start": 4797,
      "end": 4813,
      "name": "str$_function",
      "description": "STR$(numeric): returns string representation of numeric argument. Notes about spacing: numbers converted to strings have trailing space and positive numbers have leading space. Example converting a floating-point to a string and printing both.",
      "references": []
    },
    {
      "start": 4814,
      "end": 4815,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4816,
      "end": 4843,
      "name": "sys_statement",
      "description": "SYS <memory-location>: jumps to machine language routine beginning at specified memory location (used in direct or program mode). Machine code should end with RTS so BASIC resumes after SYS call. Example: SYS 64738 (jump to system cold start in ROM) and example of POKE then SYS to call short machine routine.",
      "references": [
        {
          "chunk": "usr_function",
          "topic": "USR uses a pointer in RAM to call a machine routine and return a floating result"
        }
      ]
    },
    {
      "start": 4844,
      "end": 4867,
      "name": "tab_function",
      "description": "TAB(numeric): moves the cursor to relative position 'numeric' on the current logical line (starting at leftmost position). Range 0\u2013255. TAB only works with PRINT (no effect with PRINT#). Example formatting columns using TAB.",
      "references": [
        {
          "chunk": "spc_function",
          "topic": "SPC vs TAB spacing functions"
        }
      ]
    },
    {
      "start": 4868,
      "end": 4890,
      "name": "tan_function",
      "description": "TAN(numeric): returns tangent of numeric argument in radians. On overflow returns ?DIVISION BY ZERO. Example computing TAN(.785398163) which returns 1.",
      "references": [
        {
          "chunk": "sin_function",
          "topic": "SIN and COS related trigonometric functions"
        }
      ]
    },
    {
      "start": 4891,
      "end": 4904,
      "name": "time_function",
      "description": "TI (TIME) function: reads the interval timer (jiffy clock) which increments at 1/60 second and is initialized to zero at power-up. Note: timer turned off during tape I/O. Example showing seconds since power-up via TI/60.",
      "references": [
        {
          "chunk": "rnd_function",
          "topic": "RND(0) uses free-running jiffy clock"
        }
      ]
    },
    {
      "start": 4905,
      "end": 4905,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4906,
      "end": 4937,
      "name": "time$_function",
      "description": "TI$ (TIME$) string: returns a 6-character HHMMSS string representing time while system powered on. Can be assigned an arbitrary starting point. Not accurate after tape I/O. Example showing manual initialization and increment loop printing TI$.",
      "references": [
        {
          "chunk": "time_function",
          "topic": "TI provides numeric jiffy clock; TI$ provides formatted time"
        }
      ]
    },
    {
      "start": 4938,
      "end": 4958,
      "name": "usr_function",
      "description": "USR(numeric): calls user machine-language subroutine pointed to by two-byte address stored at memory locations 785-786. Caller must POKE the address into 785-786 first. The numeric argument is passed via floating-point accumulator area starting at location 97 for assembler access; when subroutine returns its result should be in the same accumulator area and USR returns that floating result. Example usage showing C=USR(B/2).",
      "references": [
        {
          "chunk": "sys_statement",
          "topic": "SYS for direct jumps to machine code vs USR which uses pointer at 785-786"
        }
      ]
    },
    {
      "start": 4959,
      "end": 4960,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 4961,
      "end": 4985,
      "name": "val_function",
      "description": "VAL(string): converts numeric text in string to numeric value. If first non-blank char is not + - or digit returns 0. Parsing stops at first non-digit (except decimal point and exponent e). Example validating ZIP$ ranges using VAL(ZIP$).",
      "references": []
    },
    {
      "start": 4986,
      "end": 5031,
      "name": "verify_command",
      "description": "VERIFY [\"file-name\"][,device]: compares contents of BASIC program file on tape or disk with program currently in memory (often used after SAVE). Default device 1 (cassette) if omitted. For tape if filename omitted compares next program found. For disk device 8 filename must be present. On mismatch ?VERIFY ERROR. Also used to position tape past last program. Examples of VERIFY operation and prompting (PRESS PLAY ON TAPE, FOUND, VERIFYING).",
      "references": [
        {
          "chunk": "save_command",
          "topic": "VERIFY typically used right after SAVE to confirm written program"
        }
      ]
    },
    {
      "start": 5032,
      "end": 5078,
      "name": "wait_statement",
      "description": "WAIT <location>,<mask-1>[,<mask-2>]: suspends program until a memory location matches a specified bit pattern. Mechanism: performs (MEMLOC AND mask-1) then XOR with mask-2 (if provided) to test result; mask-1 filters bits to test, mask-2 flips bits to test for 'off' conditions as well. WARNING: can create infinite pause; recover with RUN/STOP + RESTORE. Examples include waiting on tape key press and waiting for sprite-background collision registers (addresses shown).",
      "references": [
        {
          "chunk": "peek_function",
          "topic": "PEEK can be used to read monitored memory locations directly"
        },
        {
          "chunk": "sprites_registers_and_pointers",
          "topic": "example WAIT on VIC-II sprite collision register"
        }
      ]
    },
    {
      "start": 5079,
      "end": 5156,
      "name": "keyboard_buffer_and_basic_key_handling",
      "description": "Description of the 10-character keyboard buffer and 'type-ahead' behavior. How to empty the buffer in a loop (GET JUNK$). Reading keyboard via PEEK(197) to get numeric key value (returns 64 if no key pressed). Explain keyboard matrix scanning performed by CIA #1 (MOS 6526) using registers 56320 ($DC00) for columns and 56321 ($DC01) for rows; bits correspond to columns/rows. Control keys (<RVS ON>, <CTRL>, <C=>, <SHIFT>) decoded separately and influence result placed in location 197. Also describes POKEing locations 631-640 to insert characters into buffer and setting count in 198 to cause automatic execution of direct-mode commands; example given to print to printer and resume program.",
      "references": [
        {
          "chunk": "cia_registers_and_ports",
          "topic": "CIA #1 and CIA #2 I/O registers used for keyboard and bank selection"
        },
        {
          "chunk": "peek_function",
          "topic": "reading key state via PEEK(197)"
        }
      ]
    },
    {
      "start": 5157,
      "end": 5157,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5158,
      "end": 5266,
      "name": "screen_editor_and_quote_insert_modes",
      "description": "Screen editor behavior: edit program lines after LIST; cursor keys move within 80-character logical line; hitting RETURN tokenizes and stores edited line. Limitations: editor reads only two physical lines -> 80 character effective limit. Explanation of QUOTE MODE (cursor controls and color controls produce reversed characters inside quotes), and INSERT MODE (SHIFT+INST shifts subsequent characters). Details of which cursor controls are available in quote mode and how DEL/INST behave differently in quote vs insert modes. Examples of embedding cursor moves and DEL/INST sequences within PRINT strings and warnings about difficulty of editing lines containing such control characters.",
      "references": [
        {
          "chunk": "print_statement_and_quote_mode",
          "topic": "how quote-mode control characters behave when printed"
        },
        {
          "chunk": "keyboard_buffer_and_basic_key_handling",
          "topic": "interaction with control keys (RVS, CTRL)"
        }
      ]
    },
    {
      "start": 5267,
      "end": 5310,
      "name": "other_quote_mode_special_characters_and_reverse_video",
      "description": "Additional quote-mode special characters not readily available from keyboard: SHIFT+RETURN (<SHIFT+M>) (causes a CR without ending string), switches for case and case-switching enable/disable (letters N, SHIFT+N, H, I in reversed form). How to insert by editing, using RVS ON/OFF for reverse video (CTRL+RVS), terminating reverse video with CHR$(146) or CR. Notes about printer character set switching when sending reversed 'N' to printer, and that LIST editing becomes near-impossible when these special characters are embedded.",
      "references": [
        {
          "chunk": "screen_editor_and_quote_insert_modes",
          "topic": "editing implications of embedding special characters in program lines"
        },
        {
          "chunk": "print_statement_and_quote_mode",
          "topic": "using reverse video and special sequences in PRINT strings"
        }
      ]
    },
    {
      "start": 5311,
      "end": 5311,
      "ignore": true,
      "reason": "Page separator / marker"
    },
    {
      "start": 5312,
      "end": 5321,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5322,
      "end": 5360,
      "name": "chapter_3_heading_and_graphics_toc",
      "description": "Chapter 3 heading and table of contents listing topics for 'Programming Graphics on the Commodore 64' including Graphics Overview, Graphics Locations, Character Modes, Bit Map Modes, Sprites, Smooth Scrolling and related topics. This is the section header and mini-TOC for the graphics chapter.",
      "references": [
        {
          "chunk": "graphics_overview",
          "topic": "start of graphics discussion"
        }
      ],
      "ignore": true,
      "reason": "audit: Chapter header/mini-TOC only; contains no technical details, code, registers, or actionable C64 content."
    },
    {
      "start": 5361,
      "end": 5372,
      "name": "graphics_overview",
      "description": "Overview of VIC-II (MOS 6567) graphics capabilities: provides 40x25 text display, 320x200 high-resolution bitmap, and sprites (movable objects). Notes mixing modes on same screen and overall VIC-II role as source of all graphics modes.",
      "references": [
        {
          "chunk": "graphics_modes_list",
          "topic": "list of character, bitmap and sprite modes"
        }
      ]
    },
    {
      "start": 5373,
      "end": 5407,
      "name": "graphics_modes_list",
      "description": "Enumeration of VIC-II graphics display modes: A) Character display modes (Standard Character Mode with ROM/RAM programmable chars; Multi-Color Character Mode ROM/RAM; Extended Background Color Mode ROM/RAM), B) Bit Map Modes (Standard Bit Map, Multi-Color Bit Map), C) Sprites (Standard, Multi-Color).",
      "references": [
        {
          "chunk": "standard_character_mode",
          "topic": "details on standard character mode"
        },
        {
          "chunk": "bit_map_modes",
          "topic": "bitmap modes description"
        },
        {
          "chunk": "sprites_overview",
          "topic": "sprites section"
        }
      ]
    },
    {
      "start": 5408,
      "end": 5429,
      "name": "graphics_locations_overview",
      "description": "General info on screen memory and color memory: 1000 screen locations normally start at 1024 ($0400) to 2023; each is 8 bits. Color RAM 'COLOR MEMORY' runs 55296 ($D800) to 56295; each is 4 bits (0\u201315) corresponding to 16 colors. Screen memory holds character codes which VIC-II translates to character patterns.",
      "references": [
        {
          "chunk": "screen_memory",
          "topic": "how to relocate screen memory and related control register"
        },
        {
          "chunk": "color_memory",
          "topic": "details and fixed location of color RAM at $D800"
        }
      ]
    },
    {
      "start": 5430,
      "end": 5454,
      "name": "video_bank_selection_cia2_ports",
      "description": "VIC-II accesses 16K at a time; four 16K banks exist to cover 64K memory. Bank select bits (bits 0-1 of PORT A of CIA #2 at location 56576 / $DD00) control which bank VIC-II sees. To change bank, set those bits as outputs by setting bits 0-1 of location 56578 / $DD02 to outputs, then write bank bits into 56576. Example POKEs show turning bits to outputs and selecting bank. 'A' value selects bank 0..3.",
      "references": [
        {
          "chunk": "character_memory",
          "topic": "bank choice affects character set images and where VIC-II reads patterns"
        },
        {
          "chunk": "screen_memory",
          "topic": "bank selection affects where screen lives in physical memory"
        }
      ]
    },
    {
      "start": 5455,
      "end": 5463,
      "name": "video_bank_value_table",
      "description": "Table of A values (0..3) mapping to bit patterns and banks: A=0 -> bits 00 Bank 3 start 49152 ($C000-$FFFF), A=1 -> bits 01 Bank 2 start 32768 ($8000-$BFFF), A=2 -> bits 10 Bank 1 start 16384 ($4000-$7FFF), A=3 -> bits 11 Bank 0 start 0 ($0000-$3FFF) default. Note: character set availability depends on bank selection.",
      "references": [
        {
          "chunk": "video_bank_selection_cia2_ports",
          "topic": "how to set these values via CIA2 POKEs"
        }
      ]
    },
    {
      "start": 5464,
      "end": 5466,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5467,
      "end": 5480,
      "ignore": true,
      "reason": "Footnote / NOTE formatting and page layout"
    },
    {
      "start": 5481,
      "end": 5483,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5484,
      "end": 5519,
      "name": "screen_memory_and_register_d018",
      "description": "Screen memory relocation via VIC-II control register $D018 (53272). Upper 4 bits of register select screen memory page. POKE example: POKE 53272,(PEEK(53272) AND 15) OR A to change screen page without disturbing lower bits. Table mapping A values (0,16,32,...240) to page starting addresses (0,$0000; 16->$0400 default; up to 240->$3C00) with reminders to add VIC-II bank base and to inform KERNAL screen editor via POKE 648,page.",
      "references": [
        {
          "chunk": "video_bank_selection_cia2_ports",
          "topic": "need to add bank base when relocating screen memory"
        }
      ]
    },
    {
      "start": 5520,
      "end": 5539,
      "name": "color_memory",
      "description": "Color RAM (color memory) fixed at 55296 ($D800) through 56295 ($DBE7). Cannot be moved. Notes that screen memory and color memory are used differently between graphics modes and switching modes changes picture appearance.",
      "references": [
        {
          "chunk": "screen_memory_and_register_d018",
          "topic": "interaction with screen memory placement"
        }
      ]
    },
    {
      "start": 5540,
      "end": 5590,
      "name": "character_memory_overview",
      "description": "Character memory: VIC-II gets character shapes either from Character Generator ROM or from RAM (programmable). Normal character set: 256 characters, 8 bytes per character = 2K. VIC-II views 16K at a time so character sets must start at one of eight 2K-aligned locations. Character memory location controlled by bits 3,2,1 of VIC-II register $D018 (53272). POKE example to change character memory: POKE 53272,(PEEK(53272) AND 240) OR A. Table of A values showing possible character memory starting addresses (0,$0000; 2->$0800; 4->$1000 ROM image in BANK 0&2 default; etc) and note to add bank address.",
      "references": [
        {
          "chunk": "video_bank_value_table",
          "topic": "bank base addition needed when computing full character addresses"
        },
        {
          "chunk": "switching_io_and_character_rom_access",
          "topic": "how to access and copy character ROM (switch out I/O), including interrupt handling"
        }
      ]
    },
    {
      "start": 5591,
      "end": 5591,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5592,
      "end": 5616,
      "name": "character_rom_image_locations_table",
      "description": "Describes ROM IMAGE locations (how character ROM appears to VIC-II depending on bank): lists specific VIC-II 'images' mapping to ranges containing upper case, graphics, reversed characters, and lower-case sets depending on block. Shows that character ROM and VIC-II control registers occupy same addresses but are switched in/out depending on access. Emphasizes that ROM image 'appears' only in the 16K bank currently seen by VIC-II.",
      "references": [
        {
          "chunk": "character_memory_overview",
          "topic": "character memory selection and ROM imaging"
        }
      ]
    },
    {
      "start": 5617,
      "end": 5632,
      "name": "vic_character_rom_imaging_and_bank_mapping",
      "description": "Explains how the VIC-II 'sees' character ROM as images in the 16K video bank (maps ROM to $1000-$1FFF when bank 0, $9000-$9FFF when bank 2) even though ROM physically resides at $D000-$DFFF. Includes table of ROM character blocks and their VIC-II image addresses and contents (upper/lower case, graphics, reversed variants).",
      "references": [
        {
          "chunk": "switching_io_and_interrupts_for_copying_char_rom",
          "topic": "how to access/copy the character ROM"
        },
        {
          "chunk": "character_definitions_storage_and_ROM_locations",
          "topic": "where characters are stored and how they are structured"
        }
      ]
    },
    {
      "start": 5633,
      "end": 5679,
      "name": "switching_io_and_interrupts_for_copying_char_rom",
      "description": "Procedure for switching out I/O and switching in the character ROM so the CPU can copy or inspect the character ROM: warns that interrupts must be disabled because I/O registers service interrupts. Shows POKEs to disable keyboard scan interrupts (POKE 56334,PEEK(56334)AND254), to switch in character ROM (POKE 1,PEEK(1)AND251), and to restore I/O (POKE 1,PEEK(1)OR 4) and to re-enable keyboard scan interrupts (POKE 56334,PEEK(56334)OR1).",
      "references": [
        {
          "chunk": "vic_character_rom_imaging_and_bank_mapping",
          "topic": "VIC-II ROM imaging and bank notes"
        },
        {
          "chunk": "copy_characters_from_ROM_to_RAM_example_program",
          "topic": "example that uses these steps"
        }
      ]
    },
    {
      "start": 5680,
      "end": 5686,
      "ignore": true,
      "reason": "Spacing and small formatting lines; continuation of previous discussion handled in adjacent chunks"
    },
    {
      "start": 5687,
      "end": 5688,
      "ignore": true,
      "reason": "Page footer/formatting"
    },
    {
      "start": 5689,
      "end": 5715,
      "name": "standard_character_mode_and_character_definitions",
      "description": "Standard Character Mode: default mode on power-up. Characters sourced from ROM or RAM (programmable). VIC-II uses screen memory to determine character code and color memory for color per character. Character address calculation formula: CHARACTER ADDRESS = SCREEN CODE*8 + (CHARACTER SET*2048) + (BANK*16384). Each character is 8x8 dots, stored as 8 bytes (one byte per row; each bit is a dot). Example shows binary rows and corresponding decimal PEEK values (e.g., A pattern rows such as 00011000 -> 24). Notes that full char set is 2K and char ROM total 4K for both upper/lower sets.",
      "references": [
        {
          "chunk": "character_memory_overview",
          "topic": "where character patterns are stored and how VIC-II computes addresses"
        }
      ]
    },
    {
      "start": 5716,
      "end": 5754,
      "name": "character_definitions_storage_and_ROM_locations",
      "description": "Describes character definition format: each character is an 8x8 dot matrix stored as 8 bytes (one byte per row, bits represent dots). The Character Generator ROM location starts at 53248 ($D000) when I/O is switched out; character code 0 (@) is at $D000-$D007, 'A' at $D008-$D00F. Notes two character sets (upper/graphics and upper+lower) totaling 4K ROM.",
      "references": [
        {
          "chunk": "programmable_characters_overview_and_considerations",
          "topic": "how to point VIC-II to RAM for custom character sets"
        }
      ]
    },
    {
      "start": 5755,
      "end": 5756,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5757,
      "end": 5793,
      "name": "programmable_characters_and_memory_constraints",
      "description": "Programmable characters: how to point VIC-II to RAM character set by changing character memory pointer in register $D018. Important notes: when using RAM character set, original Commodore characters are unavailable unless copied into RAM (all-or-nothing), and character RAM consumes memory from BASIC program space (approx 38K available to BASIC). Warning to protect character RAM from being overwritten by BASIC; advice about safe starting pages (do not use locations 0 or 2048 because system uses page 0 and BASIC starts at 2048); mentions there are six other safe 2K starting positions and that best place to put character set for BASIC is described next (continues beyond provided excerpt).",
      "references": [
        {
          "chunk": "switching_io_and_character_rom_access",
          "topic": "copying ROM images into RAM requires switching I/O and disabling interrupts"
        },
        {
          "chunk": "screen_memory_and_register_d018",
          "topic": "how to set character memory pointer bits in $D018"
        }
      ]
    },
    {
      "start": 5794,
      "end": 5821,
      "name": "choosing_ram_location_for_character_set_and_protecting_from_BASIC",
      "description": "Gives safe starting positions for RAM-based character sets: avoid $0000 and $0800 (0 and 2048). Recommends $3000 (12288) for experiments and shows how to set the low 4 bits of 53272 to 12: POKE 53272,(PEEK(53272)AND240)+12. Shows how to reduce BASIC's available memory (POKE 52148:POKE56,48:CLR) so BASIC won't overwrite the character RAM, and how to check free memory with PRINT FRE(0)-(SGN(FRE(0))<0)*65535.",
      "references": [
        {
          "chunk": "programmable_characters_overview_and_considerations",
          "topic": "ram tradeoffs and precautions"
        },
        {
          "chunk": "copy_characters_from_ROM_to_RAM_example_program",
          "topic": "example using these steps"
        }
      ]
    },
    {
      "start": 5822,
      "end": 5850,
      "name": "copy_characters_from_ROM_to_RAM_example_program",
      "description": "BASIC example program (tok64 page110.prg) that: switches to upper case, reserves memory for characters (POKE 52,48:POKE 56,48:CLR), disables keyboard interrupt, switches in character ROM, copies 64 characters (512 bytes) from ROM ($D000) to RAM at 12288 ($3000), then restores I/O and re-enables interrupts, and sets the character pointer to 12288. Uses POKE 56334 operations and POKE 1 to switch ROM/I/O.",
      "references": [
        {
          "chunk": "switching_io_and_interrupts_for_copying_char_rom",
          "topic": "must disable interrupts and switch ROM/I/O while copying"
        },
        {
          "chunk": "standard_character_mode_and_address_formula",
          "topic": "setting the character pointer to RAM via 53272"
        }
      ]
    },
    {
      "start": 5851,
      "end": 5851,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 5852,
      "end": 5886,
      "name": "using_ram_characters_and_examples",
      "description": "After copying ROM to RAM and setting the character pointer (POKE 53272,(PEEK(53272)AND240)+12), characters on screen come from RAM. Shows how to reverse characters (FOR I=12288 TO 12288+7:POKE I,255-PEEK(I):NEXT) and gives a small table mapping character display codes to their starting locations in RAM when using the 12288 base (e.g., '@' code 0 -> 12288). Notes only first 64 characters were copied in example.",
      "references": [
        {
          "chunk": "creating_character_patterns_and_worksheet",
          "topic": "how to create custom character patterns in RAM"
        }
      ]
    },
    {
      "start": 5887,
      "end": 5923,
      "name": "selecting_and_replacing_individual_characters",
      "description": "Explains copying or creating individual characters from ROM into RAM to replace unwanted ones. Example shows copying a reversed 'Z' into location of '>' via FOR I=0 TO 7:POKE 12784+I,255-PEEK(I+12496):NEXT. Notes that visual replacement doesn't change the logical character code behavior (the character still acts like its original code). Introduces creating custom characters using DATA and POKE sequences.",
      "references": [
        {
          "chunk": "creating_character_patterns_and_worksheet",
          "topic": "creating characters with DATA statements and the 8-row encoding"
        }
      ]
    },
    {
      "start": 5924,
      "end": 5951,
      "name": "example_smiley_character_and_program",
      "description": "BASIC example that stores 8-byte character data to replace 'T' with a smiley face: lines 10 FOR I=12448 TO 12455:READ A:POKE I,A:NEXT and DATA 60,66,165,129,165,153,66,60. Shows the 8-row matrix for the smile face, with binary and decimal values per row.",
      "references": [
        {
          "chunk": "creating_character_patterns_and_worksheet",
          "topic": "worksheet for designing custom characters"
        }
      ]
    },
    {
      "start": 5952,
      "end": 6018,
      "name": "creating_character_patterns_and_worksheet",
      "description": "Describes the Programmable Character Worksheet: an 8x8 grid where each column value is a power of two (128..1). Explains how to mark dots, compute the decimal value for each row (sum of marked column values), produce 8 numbers (0-255) for a character, and place them into DATA statements. Includes hint: vertical lines should be at least 2 dots wide to reduce CHROMA noise on TV.",
      "references": [
        {
          "chunk": "example_smiley_character_and_program",
          "topic": "sample DATA values for a smiley"
        }
      ]
    },
    {
      "start": 6019,
      "end": 6065,
      "name": "example_program_standard_programmable_characters",
      "description": "BASIC example (page114.prg) demonstrating copying 64 characters from ROM to RAM (with interrupts and I/O disabled), setting the character pointer to 12288, programming a few characters using DATA and POKE, and restoring defaults. Shows use of POKE 56334, POKE 1, and POKE 53272, and demonstrates printing newly defined characters using chr$ values.",
      "references": [
        {
          "chunk": "copy_characters_from_ROM_to_RAM_example_program",
          "topic": "copy routine and interrupt handling"
        },
        {
          "chunk": "creating_character_patterns_and_worksheet",
          "topic": "DATA-driven character programming"
        }
      ]
    },
    {
      "start": 6066,
      "end": 6117,
      "name": "multi_color_character_mode_intro_and_enable_disable",
      "description": "Introduces multi-color character mode: trades horizontal resolution for 4 color choices per dot (background #0, bg #1, bg #2, or character color). To enable multi-color character mode set bit 4 of VIC-II control register at 53270 ($D016) (POKE 53270,PEEK(53270)OR 16); to disable clear bit 4 (POKE 53270,PEEK(53270)AND239). Color memory bit 3 controls whether each character cell is multi-color (>=8) or high-resolution (<8).",
      "references": [
        {
          "chunk": "multi_color_mode_bit_pairs_and_color_registers",
          "topic": "how bit pairs map to colors"
        },
        {
          "chunk": "multicolor_bitmap_enable_disable",
          "topic": "multi-color bitmapped mode uses similar registers"
        }
      ]
    },
    {
      "start": 6118,
      "end": 6168,
      "name": "multi_color_mode_bit_pairs_and_color_registers",
      "description": "Explains how character bits are read in multi-color mode: bits are paired horizontally and mapped to four colors. Shows example with letter 'A' and how AA/BB/CC areas map to Background #1, Background #2, and character color respectively. Provides lookup: bit pair 00 -> Background #0 ($D021 53281), 01 -> Background #1 ($D022 53282), 10 -> Background #2 ($D023 53283), 11 -> color from lower 3 bits of color RAM.",
      "references": [
        {
          "chunk": "multi_color_character_mode_intro_and_enable_disable",
          "topic": "how to enable/disable mode"
        },
        {
          "chunk": "multicolor_bitmap_color_sources",
          "topic": "similar bit-pair rules apply to multicolor bitmaps"
        }
      ]
    },
    {
      "start": 6169,
      "end": 6188,
      "name": "multi_color_demo_program",
      "description": "Short BASIC demo to set background colors and enable multicolor mode: POKE 53281,1 (bg0 white), POKE 53282,3 (bg1 cyan), POKE 53282,8 (bg2 orange) [note: second POKE 53282,8 may be intended for 53283], then POKE 53270,PEEK(53270)OR16 to turn on multicolor. Prints characters and POKEs into color RAM to set multi-color flags.",
      "references": [
        {
          "chunk": "multi_color_mode_bit_pairs_and_color_registers",
          "topic": "background registers usage"
        }
      ]
    },
    {
      "start": 6189,
      "end": 6224,
      "name": "using_color_registers_and_dynamic_changes_example",
      "description": "Explains that color registers are indirect references used by many screen positions. Changing a background or indirect color register changes all dots using that register. Includes BASIC example (page118.prg) that alternates colors by poking 53282 with random values and demonstrates user control via color keys.",
      "references": [
        {
          "chunk": "multi_color_demo_program",
          "topic": "example background register settings"
        }
      ]
    },
    {
      "start": 6225,
      "end": 6240,
      "name": "keyboard_color_control_and_POKE_examples",
      "description": "Shows how to enter multi-color display of typed text using POKE 53270 to set multicolor mode and printing a CTRL+3 sequence (PRINT\"<CTRL+3>\") to set a color. Also notes that COLOR keys can change characters to any color including multicolor.",
      "references": [
        {
          "chunk": "multi_color_character_mode_intro_and_enable_disable",
          "topic": "enabling multicolor before printing"
        }
      ]
    },
    {
      "start": 6241,
      "end": 6286,
      "name": "example_multicolor_programmable_characters",
      "description": "BASIC program (page119.prg) to copy character ROM to RAM, set character pointer to 12288, enable multicolor with POKE 53270 OR 16, set background color registers (53281..53283), define data for characters 60-63 with multicolor encoding, then restore normal characters and modes. Demonstrates multicolor programmable characters implementation.",
      "references": [
        {
          "chunk": "copy_characters_from_ROM_to_RAM_example_program",
          "topic": "copying characters into RAM"
        },
        {
          "chunk": "multi_color_mode_bit_pairs_and_color_registers",
          "topic": "multicolor bit pairing for characters"
        }
      ]
    },
    {
      "start": 6287,
      "end": 6335,
      "name": "extended_background_color_mode_description_and_limits",
      "description": "Describes Extended Background Color Mode: provides four background registers each set to any of 16 colors. Color memory holds foreground color as usual. Limits: only first 64 character codes can be used (2 bits of character code pick background register). Chart maps character code ranges 0-63 -> register 0 ($D021 53281), 64-127 -> reg1 ($D022), 128-191 -> reg2 ($D023), 192-255 -> reg3 ($D024 53284).",
      "references": [
        {
          "chunk": "enabling_disabling_extended_color_mode",
          "topic": "how to toggle mode"
        }
      ]
    },
    {
      "start": 6336,
      "end": 6353,
      "name": "enabling_disabling_extended_color_mode",
      "description": "How to turn Extended Color Mode ON and OFF by toggling bit 6 of VIC-II register at 53265 ($D011): ON with POKE 53265,PEEK(53265)OR 64; OFF with POKE 53265,PEEK(53265)AND 191.",
      "references": [
        {
          "chunk": "extended_background_color_mode_description_and_limits",
          "topic": "registers and code ranges used in extended color mode"
        }
      ]
    },
    {
      "start": 6354,
      "end": 6354,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6355,
      "end": 6393,
      "name": "bit_mapped_graphics_intro_and_drawbacks",
      "description": "Introduction to bit mapping (high-resolution graphics): assigns one bit per pixel for 320x200 resolution (8K bytes for full bitmap: 320*200/8 = 8000 bytes). Notes drawbacks: memory use and slower BASIC performance; recommends machine language or VSP cartridge for speed. Introduces standard and multi-color bit map modes.",
      "references": [
        {
          "chunk": "standard_bitmap_mode_enable_disable_and_types",
          "topic": "enabling standard bitmap mode"
        }
      ]
    },
    {
      "start": 6394,
      "end": 6424,
      "name": "standard_bitmap_mode_enable_disable_and_types",
      "description": "Standard (hi-res) bitmap mode provides 320x200 resolution with 2 colors per 8x8 cell. Bitmap mode is enabled by setting bit 5 of VIC-II control register at 53265 ($D011): POKE 53265,PEEK(53265)OR 32; disable with POKE 53265,PEEK(53265)AND 223. Also discusses selecting the bitmap area (BASE).",
      "references": [
        {
          "chunk": "bit_mapped_graphics_intro_and_drawbacks",
          "topic": "bitmap tradeoffs"
        },
        {
          "chunk": "bitmap_mode_how_it_works_and_color_memory_usage",
          "topic": "how colors are sourced in bitmap mode"
        }
      ]
    },
    {
      "start": 6425,
      "end": 6456,
      "name": "bitmap_mode_how_it_works_and_color_memory_usage",
      "description": "Explains how programmable characters are repurposed in bitmap mode: character memory holds bitmap bytes and screen memory holds color/nybble data. The upper 4 bits of screen memory specify color for bits set to 1 in the 8x8 area; lower 4 bits specify color for bits set to 0. Demonstrates setting BASE and entering bitmap mode and that clearing must be done by zeroing the bitmap RAM area (not CLR).",
      "references": [
        {
          "chunk": "standard_bitmap_mode_enable_disable_and_types",
          "topic": "turning bitmap on/off and choosing base"
        }
      ]
    },
    {
      "start": 6457,
      "end": 6476,
      "name": "bitmap_example_and_clearing_screen",
      "description": "Example BASIC lines to set BASE and enable bitmap (BASE=2*4096; POKE 53272,PEEK(53272)OR8; POKE 53265,PEEK(53265)OR32). Shows how to clear the bitmap memory region with FOR I=BASE TO BASE+7999:POKE I,0:NEXT and set colors for screen memory (FOR I=1024 TO 2023:POKE I,3:NEXT).",
      "references": [
        {
          "chunk": "bitmap_mode_how_it_works_and_color_memory_usage",
          "topic": "clearing bitmap area and initializing screen colors"
        }
      ]
    },
    {
      "start": 6477,
      "end": 6596,
      "name": "bitmap_addressing_and_bit_manipulation_formulas",
      "description": "Explains per-pixel address calculation in bitmap mode using coordinates (X,Y). Defines ROW = INT(Y/8), CHAR = INT(X/8), LINE = Y AND 7, BIT = 7-(X AND 7). Gives formula BYTE = BASE + ROW*320 + CHAR*8 + LINE. To set a pixel: POKE BYTE, PEEK(BYTE) OR 2^BIT. Also explains organization of bytes in memory for the 25x40 character grid used as bitmap blocks.",
      "references": [
        {
          "chunk": "bitmap_example_and_clearing_screen",
          "topic": "BASE and clearing before plotting"
        },
        {
          "chunk": "sine_curve_bitmap_example",
          "topic": "example plotting using these formulas"
        }
      ]
    },
    {
      "start": 6597,
      "end": 6598,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6599,
      "end": 6612,
      "name": "sine_curve_bitmap_example",
      "description": "BASIC example that uses the bitmap addressing formula to plot a sine curve across the screen: FOR X=0 TO 319 STEP .5 with Y=INT(90+80*SIN(X/10)), computes CH, RO, LN, BY, BI and POKEs the byte to set the bit: POKEBY,PEEK(BY)OR(2^BI). Sets a flag POKE 1024,16 and enters infinite loop afterwards.",
      "references": [
        {
          "chunk": "bitmap_addressing_and_bit_manipulation_formulas",
          "topic": "addresses and bit calculations used in the example"
        }
      ]
    },
    {
      "start": 6613,
      "end": 6613,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6614,
      "end": 6646,
      "name": "semicircle_bitmap_example_and_notes",
      "description": "Shows a modification to the sine example to draw a semicircle by computing Y1 and Y2 using square root and plotting vertical columns between them. Contains pseudocode lines illustrating FOR loops and uses the same BYTE/BIT calculations. Note: original text has some typographical errors \u2014 algorithm outline is to compute upper/lower Y for each X and set bits across the vertical span.",
      "references": [
        {
          "chunk": "bitmap_addressing_and_bit_manipulation_formulas",
          "topic": "same plotting math and addressing"
        }
      ]
    },
    {
      "start": 6647,
      "end": 6647,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6648,
      "end": 6654,
      "name": "basic_overlay_warning_for_bitmap_in_BASIC",
      "description": "Warning that BASIC variables can overlay the high-resolution screen memory; if more memory is needed, move BASIC's top down or move the bitmap area. This issue applies to BASIC only, not machine language.",
      "references": [
        {
          "chunk": "bitmap_example_and_clearing_screen",
          "topic": "allocating and clearing bitmap region within memory"
        }
      ]
    },
    {
      "start": 6655,
      "end": 6655,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6656,
      "end": 6675,
      "name": "multicolor_bitmap_enable_disable",
      "description": "Explains multi-color bitmap mode: select colors from background color register #0 (screen color), the video matrix (upper/lower nybbles of screen memory), and color memory. Enable multi-color bitmap by setting bit 5 of 53265 ($D011) and bit 4 of 53270 ($D016): example POKEs given (original text contains a typo PEEK(53625)). Disable by clearing those bits with AND masks.",
      "references": [
        {
          "chunk": "multicolor_bitmap_color_sources",
          "topic": "bit codes for which source supplies color"
        }
      ]
    },
    {
      "start": 6676,
      "end": 6699,
      "name": "multicolor_bitmap_color_sources",
      "description": "Describes how 2-bit values in multicolor bitmap map to color sources: 00 -> Background color #0, 01 -> upper 4 bits of screen memory, 10 -> lower 4 bits of screen memory, 11 -> color nybble (4-bit value).",
      "references": [
        {
          "chunk": "multicolor_bitmap_enable_disable",
          "topic": "how to enable/disable the mode"
        }
      ]
    },
    {
      "start": 6700,
      "end": 6700,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6701,
      "end": 6732,
      "name": "smooth_scrolling_overview_and_steps",
      "description": "Overview of VIC-II smooth scrolling (pixel-by-pixel) support in X and Y. Lists the six-step process for smooth scrolling: shrink screen, set scroll register to extreme, place new data in covered portion, increment/decrement scroll register, shift entire screen one character via machine language, repeat. Notes 38-column and 24-row modes are used to provide covered areas for incoming data.",
      "references": [
        {
          "chunk": "screen_size_modes_and_pokes",
          "topic": "how to switch 38/40 columns and 24/25 rows"
        }
      ]
    },
    {
      "start": 6733,
      "end": 6733,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6734,
      "end": 6752,
      "name": "screen_size_modes_and_pokes",
      "description": "How to enter 38-column mode: clear bit 3 of 53270 ($D016) via POKE 53270,PEEK(53270)AND247; return to 40-column with POKE 53270,PEEK(53270)OR8. For 24-row mode clear bit 3 of 53265 ($D011) with POKE 53265,PEEK(53265)AND247; return to 25-row with POKE 53265,PEEK(53265)OR8.",
      "references": [
        {
          "chunk": "smooth_scrolling_overview_and_steps",
          "topic": "modes used to provide covered areas for smooth scrolling"
        }
      ]
    },
    {
      "start": 6753,
      "end": 6753,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6754,
      "end": 6788,
      "name": "scrolling_registers_and_poking_values",
      "description": "Explains scroll registers: X scroll is bits 2-0 of VIC-II control at 53270 ($D016); set via POKE 53270,(PEEK(53270)AND248)+X where X is 0..7. Y scroll is bits 2-0 of VIC-II control at 53265 ($D011); set via POKE 53265,(PEEK(53265)AND248)+Y. Explains covered-area placement for scrolling directions and stepping registers up/down to scroll text on/off screen.",
      "references": [
        {
          "chunk": "smooth_scrolling_overview_and_steps",
          "topic": "full smooth scrolling procedure"
        }
      ]
    },
    {
      "start": 6789,
      "end": 6810,
      "name": "text_scrolling_example_bottom_of_screen",
      "description": "BASIC example (page130.prg) demonstrating scrolling text onto the bottom of the screen: go to 24-row mode, clear screen, position cursor to bottom, set Y scroll to 7 (POKE 53265,(PEEK(53265)AND248)+7), print text and loop decrementing scroll position with delays to animate scrolling.",
      "references": [
        {
          "chunk": "scrolling_registers_and_poking_values",
          "topic": "manipulating scroll bits to animate text"
        }
      ]
    },
    {
      "start": 6811,
      "end": 6811,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6812,
      "end": 6847,
      "name": "sprites_overview_and_features",
      "description": "Introduces sprites: hardware-defined user-definable 24x21 dot graphics with independent color, mode (hi-res or multicolor), magnification, priorities, and collision detection. VIC-II supports up to 8 sprites natively (0..7). Lists features including size, color control, multicolor, magnification, priorities, and collision detection.",
      "references": [
        {
          "chunk": "defining_sprite_size_and_layout",
          "topic": "how sprites are stored (63 bytes)"
        },
        {
          "chunk": "sprite_pointers_and_memory_location_formula",
          "topic": "how sprite pointers reference sprite data"
        }
      ]
    },
    {
      "start": 6848,
      "end": 6937,
      "name": "defining_sprite_size_and_layout",
      "description": "Explains sprite definition format: sprite is 24x21 dots (504 dots) requiring 63 bytes arranged as 21 rows of 3 bytes per row. Standard (hi-res) sprites use bit=1 for foreground color and 0 transparent. Multicolor sprites trade horizontal resolution (12 columns of bit-pairs) for up to 4 colors.",
      "references": [
        {
          "chunk": "sprite_multicolor_mode_bit_pairs",
          "topic": "how sprite multicolor bit pairs map to colors"
        },
        {
          "chunk": "sprite_pointers_and_memory_location_formula",
          "topic": "where sprite definition blocks can be located"
        }
      ]
    },
    {
      "start": 6938,
      "end": 6975,
      "name": "sprite_pointers_and_memory_location_formula",
      "description": "Explains SPRITE POINTER bytes: one pointer per sprite (8 total) stored as last 8 bytes of the 1K screen memory chunk (usually at 2040..2047). Each pointer (0..255) refers to a 64-byte block (each sprite uses 63 bytes + placeholder) so LOCATION = (BANK * 16384) + (SPRITE_POINTER_VALUE * 64). Notes that ROM image areas in BANK 0 & 2 cannot host sprite definitions; use BANK 1 or 3 if you need >128 definitions.",
      "references": [
        {
          "chunk": "defining_sprite_size_and_layout",
          "topic": "sprite definition size (63 bytes) and 64-byte alignment"
        }
      ]
    },
    {
      "start": 6976,
      "end": 6976,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 6977,
      "end": 7005,
      "name": "turning_sprites_on_register",
      "description": "How to enable sprites: use SPRITE ENABLE register at 53269 ($D015). Each bit corresponds to a sprite (bit 0 = sprite 0, bit 1 = sprite 1, etc.). Example: to turn on sprite N use POKE 53269,PEEK(53269)OR(2^SN). Notes: sprite must be turned ON to be visible.",
      "references": [
        {
          "chunk": "turning_sprites_off",
          "topic": "how to turn sprites off using same register"
        },
        {
          "chunk": "sprite_position_registers_and_addresses",
          "topic": "position registers used once sprite is enabled"
        }
      ]
    },
    {
      "start": 7006,
      "end": 7015,
      "name": "turning_sprites_off",
      "description": "How to disable a sprite: clear its bit in VIC-II register 53269 ($D015) with POKE 53269,PEEK(53269)AND(255-2^SN) where SN is sprite number 0..7.",
      "references": [
        {
          "chunk": "turning_sprites_on_register",
          "topic": "turn on using OR (2^SN)"
        }
      ]
    },
    {
      "start": 7016,
      "end": 7036,
      "name": "sprite_color_registers_locations_and_usage",
      "description": "Lists sprite color register addresses: $D027..$D02E (decimal 53287..53294) for sprite 0..7 respectively. Each sprite's foreground pixels display in the value in its color register (0..15). The rest of the sprite is transparent showing background.",
      "references": [
        {
          "chunk": "sprite_multicolor_mode_bit_pairs",
          "topic": "multicolor mode uses extra multicolor registers $D025/$D026"
        }
      ]
    },
    {
      "start": 7037,
      "end": 7037,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 7038,
      "end": 7064,
      "name": "sprite_multicolor_mode_bit_pairs",
      "description": "Explains sprite multi-color mode mapping of bit pairs to color sources: 00 = transparent/screen color, 01 = sprite multicolor register #0 ($D025 53285), 10 = sprite's own color register (foreground), 11 = sprite multicolor register #1 ($D026 53286). To turn on multicolor for sprite N set bit N in control register 53276 ($D01C) via POKE 53276,PEEK(53276)OR(2^SN); clear to disable.",
      "references": [
        {
          "chunk": "set_sprite_multicolor_mode",
          "topic": "register to toggle multi-color mode bits"
        },
        {
          "chunk": "defining_sprite_size_and_layout",
          "topic": "multicolor sprites halve horizontal resolution"
        }
      ]
    },
    {
      "start": 7065,
      "end": 7065,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 7066,
      "end": 7080,
      "name": "set_sprite_multicolor_mode",
      "description": "How to set/unset multi-color mode per sprite using VIC-II control register at 53276 ($D01C): enable with POKE 53276,PEEK(53276)OR(2^SN), disable with POKE 53276,PEEK(53276)AND(255-2^SN). SN is sprite number (0..7).",
      "references": [
        {
          "chunk": "sprite_multicolor_mode_bit_pairs",
          "topic": "color mapping for bit pairs when multicolor is enabled"
        }
      ]
    },
    {
      "start": 7081,
      "end": 7124,
      "name": "sprite_expansion_horizontal_vertical",
      "description": "Describes sprite expansion (magnification) in X and Y. To expand horizontally set bit N in register 53277 ($D01D) with POKE 53277,PEEK(53277)OR(2^SN); to clear use AND (255-2^SN). To expand vertically set bit N in register 53271 ($D017) with POKE 53271,PEEK(53271)OR(2^SN); to clear use AND (255-2^SN). Expanded sprites double dot width/height but don't change resolution \u2014 sprite simply appears larger.",
      "references": [
        {
          "chunk": "sprite_position_registers_and_addresses",
          "topic": "positioning expanded sprites requires same X/Y regs and MSB handling"
        }
      ]
    },
    {
      "start": 7125,
      "end": 7125,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 7126,
      "end": 7176,
      "name": "sprite_position_registers_and_addresses",
      "description": "Lists sprite X/Y position register addresses: $D000..$D00F (decimal 53248..53263) hold X and Y registers interleaved: X0 ($D000 53248), Y0 ($D001 53249), X1 ($D002), Y1 ($D003), ... up to X7 ($D00E) and Y7 ($D00F). X MSB register at $D010 (53264) stores the most significant X bit for sprites 0..7 (bit 0 for sprite0 etc) allowing 9-bit X positions (0..511). Positioning is referenced to the top-left corner of the 24x21 sprite box.",
      "references": [
        {
          "chunk": "sprite_vertical_positioning_limits_and_example",
          "topic": "Y ranges and on-screen values"
        },
        {
          "chunk": "horizontal_movement_examples",
          "topic": "X movement uses X MSB register for >255 positions"
        }
      ]
    },
    {
      "start": 7177,
      "end": 7223,
      "name": "sprite_vertical_positioning_limits_and_example",
      "description": "Vertical (Y) positioning: 200 visible dot positions (0..199) exist. Sprite Y registers can hold 0..255 to allow smooth on/off-screen movement. First on-screen Y for unexpanded sprite is 30 (for expanded it is 9). Sprite is fully on-screen (all 21 lines) starting at Y=50; last fully-on for unexpanded is 229; expanded last fully-on is 208. Fully off occurs at Y=250. Includes simple BASIC example showing enabling sprite, setting pointer, sprite data and X/Y positions.",
      "references": [
        {
          "chunk": "sprite_position_registers_and_addresses",
          "topic": "register addresses for sprite X/Y"
        }
      ]
    },
    {
      "start": 7224,
      "end": 7224,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 7225,
      "end": 7336,
      "name": "sprite_horizontal_positioning_and_X_MSB_explanation",
      "description": "Horizontal (X) positioning explanation: sprites can be placed in 512 X positions (0..511) using an 8-bit position register plus one MSB bit in register $D010 (53264). Visible X ranges on screen depend on modes; typically only values 24..343 are visible for standard 40x25 mode. If X>255, set the corresponding bit in X MSB (bits 0..7 correspond to sprites 0..7) to 1. Discusses interactions with 38-column/24-row modes and shows diagrams (textual) illustrating limits.",
      "references": [
        {
          "chunk": "sprite_positioning_summary",
          "topic": "summary of visible ranges"
        },
        {
          "chunk": "horizontal_movement_examples",
          "topic": "example code moving a sprite across X positions using MSB handling"
        }
      ]
    },
    {
      "start": 7337,
      "end": 7376,
      "name": "horizontal_movement_examples",
      "description": "Two BASIC examples demonstrating horizontal movement of a sprite across the screen. Example 1 (p142_1.prg) loops J from 0..347 computing HX=INT(J/256) and LX = J-256*HX then POKE V,LX and POKE V+16,HX to move sprite across the full 0..347 range. Example 2 shows handling expanded sprites starting offscreen and wrapping values, toggling MSB when crossing 255.",
      "references": [
        {
          "chunk": "sprite_horizontal_positioning_and_X_MSB_explanation",
          "topic": "how examples use MSB and low byte poke sequence"
        }
      ]
    },
    {
      "start": 7377,
      "end": 7427,
      "name": "sprite_positioning_summary",
      "description": "Summarizes visible ranges: Unexpanded sprites visible in 40x25 mode for 24 < X < 343 and 30 < Y < 249. In 38-column mode X range becomes 8 <= X <= 334. In 24-row mode Y range becomes 34 <= Y <= 245. For expanded sprites, different ranges listed (e.g., 9 <= Y <= 249). Provides numeric constraints to help ensure sprites are visible.",
      "references": [
        {
          "chunk": "sprite_vertical_positioning_limits_and_example",
          "topic": "Y range values for expanded/unexpanded sprites"
        },
        {
          "chunk": "sprite_horizontal_positioning_and_X_MSB_explanation",
          "topic": "X range constraints and MSB handling"
        }
      ]
    },
    {
      "start": 7428,
      "end": 7460,
      "name": "sprite_display_priorities_and_sprite-background_priority",
      "description": "Explains sprite priorities: sprite-to-sprite priority is fixed by sprite number (lower-numbered sprite drawn in front). Sprite-to-background priority is controlled by SPRITE-BACKGROUND PRIORITY register at 53275 ($D01B): each sprite has a bit; 0 -> sprite in front of background, 1 -> sprite behind background. Note that 'window' effects can occur when higher priority sprites have transparent 'holes' showing lower-priority sprites or background.",
      "references": [
        {
          "chunk": "sprite_multicolor_mode_bit_pairs",
          "topic": "transparent areas in sprites affect priority blending"
        }
      ]
    },
    {
      "start": 7461,
      "end": 7490,
      "name": "sprite_to_sprite_collision_register_and_behavior",
      "description": "Sprite-to-sprite collisions are flagged in VIC-II register 53278 ($D01E). Each sprite has a bit that gets set to 1 if that sprite is involved in any sprite-sprite collision. Bits remain set until read (PEEK), after which the register is auto-cleared. Note: collisions can occur even when sprites are off-screen.",
      "references": [
        {
          "chunk": "sprite_to_data_collision_register_and_notes",
          "topic": "sprite-to-data collisions and read/clearing behavior"
        }
      ]
    },
    {
      "start": 7491,
      "end": 7522,
      "name": "sprite_to_data_collision_register_and_notes",
      "description": "Sprite-to-data (sprite-to-background) collisions are detected in register 53279 ($D01F). Each sprite has a bit set to 1 if it collides with non-zero background data. Bits are latched until read (PEEK) which clears them. Note: multi-color data '01' is considered transparent for collisions even though it displays; when designing backgrounds make non-collision areas '01' in multicolor mode if needed.",
      "references": [
        {
          "chunk": "sprite_to_sprite_collision_register_and_behavior",
          "topic": "both collision registers are latched and cleared on read"
        }
      ]
    },
    {
      "start": 7523,
      "end": 7568,
      "name": "sprite_example_hot_air_balloon_program",
      "description": "BASIC sprite example (page146.prg) implementing a bouncing/expanding hot-air-balloon sprite. Uses vic=13*4096 (VIC base), enables sprite 0 via POKE vic+21,1, sets sprite pointer at 2040, loads sprite data into memory area (192*64+y), sets colors and expansion bits, then uses a loop to move and bounce the sprite via reads/writes to VIC position registers. Contains DATA for sprite.",
      "references": [
        {
          "chunk": "sprite_pointers_and_memory_location_formula",
          "topic": "uses POKE 2040 to point sprite 0 to a sprite data block"
        },
        {
          "chunk": "sprite_expansion_horizontal_vertical",
          "topic": "examples set expand bits via vic+23 and vic+29"
        }
      ]
    },
    {
      "start": 7569,
      "end": 7642,
      "name": "sprite_example_multiple_hot_air_balloons_program",
      "description": "BASIC example (page147.prg) demonstrating multiple sprites (0..5) enabled and expanded, setting pointers 2040..2045, setting positions and colors for several sprites, loading sprite data from DATA into sprite memory regions, and moving sprites with shared logic including X MSB usage. Contains DATA blocks for multiple sprites.",
      "references": [
        {
          "chunk": "sprite_example_hot_air_balloon_program",
          "topic": "single-sprite example and data format"
        },
        {
          "chunk": "sprite_pointers_and_memory_location_formula",
          "topic": "multiple sprite pointers 2040..2047 region"
        }
      ]
    },
    {
      "start": 7643,
      "end": 7650,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 7651,
      "end": 7710,
      "name": "sprite_example_multicolor_toggle_program",
      "description": "BASIC example (page148.prg) showing a sprite that can be toggled between high resolution and multicolor at runtime. Sets POKE vic+28,1 to enable multicolor globally for sprites, sets sprite multicolor registers via vic+37 and vic+38, loads sprite data at 12288, and reads keyboard to toggle POKE vic+28 between 1 (multicolor) and 0 (hi-res).",
      "references": [
        {
          "chunk": "sprite_multicolor_mode_bit_pairs",
          "topic": "explains sprite multicolor behavior and registers"
        }
      ]
    },
    {
      "start": 7711,
      "end": 7732,
      "name": "screen_blanking_control",
      "description": "Controls screen blanking via bit 4 of VIC-II control register at 53265 ($D011). When bit 4 is 1 the screen is normal; when 0 the entire screen shows the border color. Blank screen with POKE 53265,PEEK(53265)AND239; restore screen with POKE 53265,PEEK(53265)OR16. Note: turning off the screen slightly speeds the CPU (programs run faster).",
      "references": [
        {
          "chunk": "raster_register_usage_and_raster_compare",
          "topic": "screen blanking can be useful when changing display during raster operations"
        }
      ]
    },
    {
      "start": 7733,
      "end": 7757,
      "name": "raster_register_usage_and_raster_compare",
      "description": "Describes raster register at 53266 ($D012): reading returns the lower 8 bits of current raster line; the MSB of raster is in 53265 ($D011). Writing raster register stores a compare value for raster-compare interrupts: when current raster equals stored value an interrupt bit is set in interrupt status register 53273 ($D019). Use raster compare to time screen changes (split-screen effects).",
      "references": [
        {
          "chunk": "interrupt_status_and_enable_registers_and_usage",
          "topic": "raster-compare sets a bit in the interrupt status register"
        }
      ]
    },
    {
      "start": 7758,
      "end": 7804,
      "name": "interrupt_status_and_enable_registers_and_usage",
      "description": "Explains interrupt status register at 53273 ($D019) and interrupt enable register at 53274 ($D01A). Status bits: bit0=IRQ on raster compare, bit1=sprite-data collision, bit2=sprite-sprite collision, bit3=light-pen, bit7=global IRQ latch. Bits are latched when set and must be cleared by writing a 1 to that bit. To actually get an IRQ the corresponding bit in the enable register must be set. Describes using interrupts for split-screen modes and dynamic display changes and notes BASIC is usually too slow \u2014 use machine language for display interrupts.",
      "references": [
        {
          "chunk": "raster_register_usage_and_raster_compare",
          "topic": "setting raster compare to generate interrupts"
        },
        {
          "chunk": "sprite_to_sprite_collision_register_and_behavior",
          "topic": "sprite collision bits are latched in status register"
        }
      ]
    },
    {
      "start": 7805,
      "end": 7851,
      "name": "suggested_color_combinations_chart",
      "description": "Provides a chart recommending which screen/background color combinations work well on a TV and which to avoid. The table cross-tabulates screen colors (rows) vs character colors (columns) with ratings: o = excellent, / = fair, x = poor. Useful guidance to avoid chroma bleed/TV artifacts when choosing character/screen color pairs.",
      "references": [
        {
          "chunk": "multi_color_character_mode_intro_and_enable_disable",
          "topic": "color considerations when using character color and background color registers"
        }
      ]
    },
    {
      "start": 7852,
      "end": 7876,
      "name": "making_sprites_short_program",
      "description": "Very short BASIC sprite creation program (page153.prg) demonstrating minimum steps: POKE sprite pointer 2040, fill 63 bytes from 832..894 with 255 to make a solid square, set VIC base v=53248, enable sprite 0 with POKE v+21,1, set sprite color POKE v+39,1, and position with POKE v,24:Poke v+1,100. Explains each line briefly.",
      "references": [
        {
          "chunk": "sprite_pointers_and_memory_location_formula",
          "topic": "POKE 2040 sets sprite pointer to block containing sprite data"
        },
        {
          "chunk": "sprite_color_registers_locations_and_usage",
          "topic": "POKE v+39 sets sprite 0 color"
        }
      ]
    },
    {
      "start": 7877,
      "end": 7891,
      "name": "sprite_program_overview_and_pointer_setup",
      "description": "Introduces the minimal sprite program and its 'ingredients'. Explains that POKE numbers come from the SPRITEMAKING CHART, identifies the program as defining sprite 0 (a solid square), and gives line-by-line start: LINE 10 clears the screen; LINE 20 sets the sprite pointer (sprite 0 at 2040 ... sprite 7 at 2047) and provides an alternate single-line FOR loop (20 FOR SP=2040TO2047:POKE SP,13:NEXT SP) to set all pointers.",
      "references": [
        {
          "chunk": "sprite_memory_allocation_and_video_register",
          "topic": "where each sprite's data is stored (832..894) and V register use"
        },
        {
          "chunk": "sprite_enable_bitmask_table",
          "topic": "how to actually enable sprites after pointers are set"
        }
      ]
    },
    {
      "start": 7892,
      "end": 7908,
      "name": "sprite_memory_allocation_and_video_register",
      "description": "Explains LINE 30: placing sprite 0 data into 63 bytes of RAM starting at location 832 (sprite occupies 832..894). Explains LINE 40: setting variable V=53248 (base address of the video chip) so code can use POKE V+offset, conserving program text and making addresses easier to remember.",
      "references": [
        {
          "chunk": "sprite_program_overview_and_pointer_setup",
          "topic": "sprite pointers that reference these memory locations"
        },
        {
          "chunk": "sprite_bitmap_memory_blocks_and_manual_editing",
          "topic": "how the 63 bytes (832..894) map to 8-pixel blocks and how to POKE them"
        }
      ]
    },
    {
      "start": 7909,
      "end": 7923,
      "name": "sprite_enable_bitmask_table",
      "description": "Explains LINE 50: enabling/turning on sprites by POKEing V+21 with a bitmask from 0 (all off) to 255 (all on). Provides the numerical bit values for individual sprites (1,2,4,8,16,32,64,128) and how to combine them (e.g., 129 = sprite 0 + sprite 7). References SPRITEMAKING CHART for more details.",
      "references": [
        {
          "chunk": "sprite_program_overview_and_pointer_setup",
          "topic": "setting the sprite pointers before enabling sprites"
        },
        {
          "chunk": "sprite_colors_and_direct_mode_editing",
          "topic": "after enabling sprites, how to set sprite colors (V+39..V+46)"
        }
      ]
    },
    {
      "start": 7924,
      "end": 7947,
      "name": "sprite_colors_and_direct_mode_editing",
      "description": "Explains LINE 60: setting sprite color registers (V+39 through V+46) with 16 possible colors (0 black to 15 gray); example POKE V+39,1 to make sprite 0 white. Notes that sprite data remains in memory until explicitly changed, allowing immediate/direct-mode editing; demonstrates using DIRECT mode to change color (example: POKE V+39,8 to make the sprite orange) and explains that running the program again restores the original color defined in the program.",
      "references": [
        {
          "chunk": "sprite_enable_bitmask_table",
          "topic": "you usually enable sprites before changing their colors"
        },
        {
          "chunk": "sprite_bitmap_memory_blocks_and_manual_editing",
          "topic": "editing sprite shape/bitmap in memory while color registers control appearance"
        }
      ]
    },
    {
      "start": 7948,
      "end": 7966,
      "name": "sprite_positioning_x_and_y_registers",
      "description": "Explains LINE 70 and LINE 80: X (horizontal) and Y (vertical) positioning of the sprite using the video chip registers (POKE V for X and POKE V+1 for Y). Defines the X number as the upper-left corner of the sprite. Notes the farthest left visible X position is 24 (you can POKE values down to 0 to move it off-screen). Gives direct-mode examples: POKE V,24:POKE V+1,50 to place the sprite at the upper-left; POKE V,24:POKE V+1,229 to place it at the lower-left corner.",
      "references": [
        {
          "chunk": "sprite_memory_allocation_and_video_register",
          "topic": "V holds the base video-chip address used to POKE X and Y (V and V+1)"
        },
        {
          "chunk": "tv_screen_coordinate_figure_and_caption",
          "topic": "visual depiction of X and Y coordinates on the TV screen"
        }
      ]
    },
    {
      "start": 7967,
      "end": 7976,
      "name": "sprite_bitmap_memory_blocks_and_manual_editing",
      "description": "Describes how the 63 bytes at addresses 832..894 map to the sprite bitmap: each address represents an 8-pixel block, with three 8-pixel blocks per horizontal row (three bytes per row). Explains the loop (from the example program) that POKEs 255 into each block to make pixels solid, and demonstrates manual editing in DIRECT mode (POKE 833,0 erases the second 8-pixel group; POKE 833,255 or RUN restores it).",
      "references": [
        {
          "chunk": "sprite_program_overview_and_pointer_setup",
          "topic": "the program writes these 63 bytes to define sprite 0"
        },
        {
          "chunk": "sprite_block_erasing_loop_and_examples",
          "topic": "examples of program loops to clear specific blocks in the sprite"
        }
      ]
    },
    {
      "start": 7977,
      "end": 7987,
      "name": "sprite_block_erasing_loop_and_examples",
      "description": "Shows a sample loop to erase blocks inside a sprite: LINE 90 example '90 FOR A=836 TO 891 STEP 3:POKE A,0:NEXT A'. Explains grouping: pixels are in 8-pixel blocks and this loop erases the 5th group (block 836) and every third block up to 890. Suggests experimenting by POKEing any addresses from 832 to 894 with 255 (solid) or 0 (blank) to change sprite shape.",
      "references": [
        {
          "chunk": "sprite_bitmap_memory_blocks_and_manual_editing",
          "topic": "explains which byte addresses correspond to 8-pixel blocks being modified"
        },
        {
          "chunk": "crunched_sprite_program_and_optimization_tip",
          "topic": "how the same POKE operations can be combined when shrinking the program"
        }
      ]
    },
    {
      "start": 7988,
      "end": 8008,
      "name": "crunched_sprite_program_and_optimization_tip",
      "description": "Provides a 'crunching' tip to shorten the sprite program by combining settings onto fewer lines. Shows the crunched two-line version of the example program: line 10 uses PRINTCHR$(147), V=53248, POKE V+21,1, POKE 2040,13, POKE V+39,1; line 20 uses FOR S=832 TO 894: POKE S,255 : NEXT and POKE V,24 : POKE V+1,100. Suggests the 'crunching guide' on Page 24 for additional tips to save memory and improve efficiency.",
      "references": [
        {
          "chunk": "sprite_program_overview_and_pointer_setup",
          "topic": "the original multi-line program that is being crunched"
        },
        {
          "chunk": "sprite_bitmap_memory_blocks_and_manual_editing",
          "topic": "the FOR loop in the crunched program fills the sprite's 832..894 bytes"
        }
      ]
    },
    {
      "start": 8009,
      "end": 8034,
      "name": "tv_screen_coordinate_figure_and_caption",
      "description": "Includes the ASCII TV SCREEN figure showing the coordinate axes and a sprite's location relative to the X (horizontal) and Y (vertical) positions. States that a sprite located in the diagram must have both X and Y set to be displayed, and captioned as Figure 3-4 explaining the display is divided into an X/Y coordinate grid.",
      "references": [
        {
          "chunk": "sprite_positioning_x_and_y_registers",
          "topic": "visual aid corresponding to explanations of POKE V (X) and POKE V+1 (Y)"
        },
        {
          "chunk": "sprite_bitmap_memory_blocks_and_manual_editing",
          "topic": "positioning interacts with the sprite bitmap stored at 832..894"
        }
      ]
    },
    {
      "start": 8035,
      "end": 8101,
      "name": "positioning_sprites_on_screen_and_xy_poke_chart",
      "description": "Explains X-Y coordinate system for sprites and provides a chart of which VIC registers to poke for each sprite position: Set X for sprite N at V+(N*2) and Set Y at V+(N*2)+1. Also lists the MSB POKE V+16 mapping for sprites 0..7 where bits 0..7 correspond to sprites 0..7 (values 1,2,4,8,16,32,64,128). Explains the effect of X values (0..255) and MSB register to access positions beyond 255.",
      "references": [
        {
          "chunk": "sprite_position_registers_and_addresses",
          "topic": "register addresses $D000..$D010"
        },
        {
          "chunk": "sprite_horizontal_positioning_and_X_MSB_explanation",
          "topic": "handling positions beyond 255 with MSB register"
        }
      ]
    },
    {
      "start": 8102,
      "end": 8176,
      "name": "x_y_positioning_details_and_example",
      "description": "Detailed instructions and examples for POKEing X and Y positions for a given sprite including how values less than 24 place sprite partly off left screen and Y 50..229 are visible. Shows example BASIC program (page159.prg) that defines sprite 1 as a solid box and positions it at X=24 Y=50 and demonstrates right-side MSB handling via POKE V+16,PEEK(V+16)OR 2 then POKE V+2,0 to start counting at 256th pixel. Shows how to clear MSB via AND masks.",
      "references": [
        {
          "chunk": "positioning_sprites_on_screen_and_xy_poke_chart",
          "topic": "how to use V+16 MSB pokes in practice"
        }
      ]
    },
    {
      "start": 8177,
      "end": 8239,
      "name": "positioning_multiple_sprites_and_right_side_handling",
      "description": "Demonstrates positioning multiple sprites (0,1,2) with different colors and pointers, using POKE loops to fill sprite data and POKE V+21 to enable multiple sprites. Discusses showing sprites beyond the 255th X position by setting appropriate bit in V+16 for the sprite (see RIGHT X row in chart) and then assigning new X (starting at 0 as 256th). Example shows POKE V+16,1:POKE V,24:POKE V+1,75 to place sprite 0 on the right side area.",
      "references": [
        {
          "chunk": "sprite_pointers_and_memory_location_formula",
          "topic": "setting multiple sprite pointers 2040..2047"
        }
      ]
    },
    {
      "start": 8240,
      "end": 8273,
      "name": "sprite_priorities_examples",
      "description": "Discusses sprite priorities with examples: lower-numbered sprites (e.g., sprite 0) appear in front of higher-numbered sprites. Example changes POKE settings to show sprite 0 in front of sprite 1 in front of sprite 2. Explains how to take advantage of priorities when animating multiple sprites.",
      "references": [
        {
          "chunk": "sprite_display_priorities_and_sprite-background_priority",
          "topic": "sprite-to-background priority and register $D01B"
        }
      ]
    },
    {
      "start": 8274,
      "end": 8321,
      "name": "drawing_sprite_overview_and_spritemaking_grid",
      "description": "Explains the spritemaking grid (24x21) and how each of the 504 pixels is grouped into 63 bytes (3 groups of 8 columns per row). Describes the 'coloring book' analogy for drawing sprites and references the spritemaking grid figure (blank sprite grid).",
      "references": [
        {
          "chunk": "creating_sprite_step_by_step_instructions",
          "topic": "step-by-step process for turning a drawn grid into DATA bytes"
        }
      ]
    },
    {
      "start": 8322,
      "end": 8410,
      "name": "creating_sprite_step_by_step_instructions",
      "description": "Step-by-step guide to create a sprite: draw on the 24x21 grid, take groups of 8 horizontal pixels and compute decimal values with bit weights (128..1), enter those values as DATA for each group (3 numbers per row, 21 rows -> 63 values). Shows example of fully solid first three groups as 255 and explains filling DATA statements line-by-line and compressing them into a crunched DATA block.",
      "references": [
        {
          "chunk": "sprite_example_hot_air_balloon_program",
          "topic": "example uses DATA to define sprite bytes"
        },
        {
          "chunk": "sprite_program_crunched_example",
          "topic": "how to crunch DATA statements for a sprite"
        }
      ]
    },
    {
      "start": 8411,
      "end": 8412,
      "ignore": true,
      "reason": "Single blank line and a page header line \u2014 non-technical formatting, ignore."
    },
    {
      "start": 8413,
      "end": 8435,
      "name": "crunched_data_statements_and_sample_basic_program",
      "description": "STEP 8 \u2014 How to compress BASIC programs by running DATA statements together (crunching). Includes a crunched sample BASIC listing that sets VIC base and sprite pointers, pokes control registers, uses a FOR...READ...POKE loop to transfer 63 DATA bytes into RAM (POKE 832+n), and positions the sprite. Contains the program lines 10\u201340 (setup and load loop), crunched DATA lines 100\u2013102, and placement line 200. Key addresses shown: VIC base at 53248, sprite control at 53269 and 53252/53253, and example uses memory starting at 832.",
      "references": [
        {
          "chunk": "smooth_and_reverse_sprite_movement_plus_vertical_scrolling",
          "topic": "Techniques to move the sprite after loading (wrap-around, right/left X settings, and vertical scroll)."
        },
        {
          "chunk": "michael_s_dancing_mouse_example_program",
          "topic": "Full example animation that demonstrates loading multiple sprites and movement techniques described earlier."
        }
      ]
    },
    {
      "start": 8436,
      "end": 8494,
      "name": "smooth_and_reverse_sprite_movement_plus_vertical_scrolling",
      "description": "Techniques for moving a sprite on the screen. Shows a smooth horizontal sweep (sample lines 50 and 55) that POKEs Y position (V+5), iterates X positions (V+4) across 0\u2013255 and uses POKE V+16 to set the RIGHT X position for wrap-around. Explains looping behavior and how to remove GOTO to make the sprite move only once. Includes a back-and-forth example (FOR with STEP -1 and reversal using POKE V+16) and a single-line vertical scrolling example (POKE V+4,24:FOR Y=0TO255:POKE V+5,Y:NEXT). Also documents erasing prior lines (erasing earlier numbered BASIC lines) to replace movement code.",
      "references": [
        {
          "chunk": "crunched_data_statements_and_sample_basic_program",
          "topic": "The crunched DATA program provides the sprite bitmap that these movement routines manipulate."
        },
        {
          "chunk": "michael_s_dancing_mouse_example_program",
          "topic": "The 'Dancing Mouse' example applies these movement patterns (horizontal, reverse, and vertical) in a multi-sprite animation."
        }
      ]
    },
    {
      "start": 8495,
      "end": 8510,
      "name": "michael_s_dancing_mouse_example_program",
      "description": "Full 'Michael's Dancing Mouse' example with explanation and a complete BASIC program that uses three sprites for animation and sound. Covers setup POKEs to sprite pointers and hardware ($D400-style pokes shown as POKES+ offsets and base addresses like 54272 and 53248), loops that move sprites across the screen (including high/low X byte management), conditional calls to sound subroutines, timing delays (POKE 2040,p), and DATA blocks (lines 100\u2013109) that hold sprite bitmaps. Also includes subroutines at lines 200 and 300 that toggle sprite pointer bytes. The listing shows how to load sprites into memory ranges (e.g., 12288\u201312478) and how the animation main loop is structured.",
      "references": [
        {
          "chunk": "crunched_data_statements_and_sample_basic_program",
          "topic": "Both examples demonstrate compact DATA usage and POKE-based sprite loading; the Dancing Mouse expands to multiple sprites and DATA blocks."
        },
        {
          "chunk": "smooth_and_reverse_sprite_movement_plus_vertical_scrolling",
          "topic": "The Dancing Mouse program implements the horizontal sweep, wrap-around, and timing techniques described in the movement chunk."
        }
      ]
    },
    {
      "start": 8511,
      "end": 8541,
      "name": "dancing_mouse_program_source",
      "description": "Complete 'Michael's Dancing Mouse' BASIC program (start tok64 page167.prg). Sets up SID sound registers (voice parameters), clears screen, sets VIC base and sprite enable, POKEs sprite data into three regions of memory (12288..12478), sets colors, prints text, loops over X positions updating sprite X and MSB, and calls subroutines to animate. Contains large DATA blocks for sprite frames and two subroutines to toggle bytes for animation.",
      "references": [
        {
          "chunk": "dancing_mouse_program_explanation",
          "topic": "line-by-line explanation of the program and SID pokes"
        },
        {
          "chunk": "sprite_example_multiple_hot_air_balloons_program",
          "topic": "similar techniques for loading sprite byte blocks and moving sprites"
        }
      ]
    },
    {
      "start": 8542,
      "end": 8556,
      "ignore": true,
      "reason": "Contains page footer, blank lines and formatting markers (non-technical)."
    },
    {
      "start": 8557,
      "end": 8600,
      "name": "dancing_mouse_program_explanation",
      "description": "Line-by-line explanation of the Dancing Mouse program: explains SID register base S=54272 and individual POKEs that set volume, frequency, ADSR (attack/decay and sustain/release) for voices 1 and 2. Explains VIC base V=53248 and related POKEs: POKE V+21 to enable sprites and other lines used to move/animate sprites and load sprite data. Helps decode how sound and sprite data are coordinated.",
      "references": [
        {
          "chunk": "dancing_mouse_program_source",
          "topic": "the actual program source and DATA blocks"
        },
        {
          "chunk": "sprite_color_registers_locations_and_usage",
          "topic": "POKE V+39 etc sets sprite color used in the program"
        }
      ]
    },
    {
      "start": 8601,
      "end": 8646,
      "name": "sprite_shape1_load_loop",
      "description": "Explains LINE 20 which initializes the first 63 bytes of sprite-shape data into memory addresses 12288\u201312350. Covers the concept of using one sprite (sprite 0) with multiple shapes by switching pointers, the FOR S1=12288 TO 12350 loop, READ Q1, POKE S1,Q1 (equivalent to POKE 12288,30 for the first value), and how NEXT advances S1 and reads the next DATA value until POKE 12350,0.",
      "references": [
        {
          "chunk": "sprite_shape2_load_loop",
          "topic": "Subsequent shape data stored immediately after this block (second shape)"
        },
        {
          "chunk": "sprite_shape3_load_loop",
          "topic": "Third sprite shape stored after the second group"
        },
        {
          "chunk": "sprite_pointer_setting_p_equals_192",
          "topic": "How pointers are used to rotate these shapes through sprite 0"
        }
      ]
    },
    {
      "start": 8647,
      "end": 8672,
      "name": "sprite_shape2_load_loop",
      "description": "Explains LINE 25 which defines the second sprite shape by POKEing 63 DATA values into memory 12352\u201312414. Notes that address 12351 is skipped (the 64th slot of the first block) and emphasizes that sprite shapes take 64 locations but only 63 contain sprite data. Covers FOR S2=12352 TO 12414, READ Q2, POKE S2,Q2 and NEXT behavior.",
      "references": [
        {
          "chunk": "sprite_shape1_load_loop",
          "topic": "First sprite shape stored immediately before this block"
        },
        {
          "chunk": "sprite_shape3_load_loop",
          "topic": "Third sprite shape stored immediately after this block"
        },
        {
          "chunk": "sprite_pointer_setting_p_equals_192",
          "topic": "Pointer values that select which of these stored shapes sprite 0 uses"
        }
      ]
    },
    {
      "start": 8673,
      "end": 8681,
      "name": "sprite_shape3_load_loop",
      "description": "Explains LINE 30 which loads the third sprite shape from DATA into memory 12416\u201312478. Covers FOR S3=12416 TO 12478, READ Q3, POKE S3,Q3 and the NEXT that completes the third block of 63 sprite-data bytes.",
      "references": [
        {
          "chunk": "sprite_shape1_load_loop",
          "topic": "First shape block for rotating shapes through sprite 0"
        },
        {
          "chunk": "sprite_shape2_load_loop",
          "topic": "Second shape block for rotating shapes through sprite 0"
        },
        {
          "chunk": "sprite_pointer_setting_p_equals_192",
          "topic": "Pointer P values used to point sprite 0 at any of these three blocks"
        }
      ]
    },
    {
      "start": 8682,
      "end": 8691,
      "name": "sprite_color_and_y_position",
      "description": "Explains LINE 35 showing how to set sprite 0's color and vertical position via VIC register pokes: POKE V+39,15 sets sprite 0 color to light grey, and POKE V+1,68 sets the sprite's Y coordinate (upper-right corner of the sprite square) to 68. Notes screen coordinate reference (position 50 is the top-left Y).",
      "references": [
        {
          "chunk": "sprite_shape1_load_loop",
          "topic": "Color and position apply to the sprite shapes loaded into memory"
        },
        {
          "chunk": "sprite_pointer_setting_p_equals_192",
          "topic": "Pointer-swapping combined with position and color animates the sprite"
        }
      ]
    },
    {
      "start": 8692,
      "end": 8717,
      "name": "print_intro_message_and_color_codes",
      "description": "Explains LINE 40 which prints a title message on the screen. Covers PRINT TAB(160) to position text at the sixth line down, embedding C64 color codes within quoted strings ({white} and {light blue}) by holding <CTRL>+<WHT> and <C=>+<7> respectively, and how those codes change the color of subsequent printed text. Shows the multi-line PRINT output: \"I AM THE DANCING MOUSE!\"",
      "references": [
        {
          "chunk": "sprite_color_and_y_position",
          "topic": "Printed color codes correspond to sprite/text color settings"
        },
        {
          "chunk": "sprite_pointer_setting_p_equals_192",
          "topic": "Printout appears while sprite pointer animation runs"
        }
      ]
    },
    {
      "start": 8718,
      "end": 8728,
      "name": "sprite_pointer_setting_p_equals_192",
      "description": "Explains LINE 45 where P=192 is set. Describes P as the SPRITE POINTER value used to make sprite 0 point to the memory block beginning at 12288 (pointer 192). Explains that changing P to the other pointer values swaps which stored shape sprite 0 displays, enabling the animation by rotating pointers among the three shape blocks.",
      "references": [
        {
          "chunk": "sprite_shape1_load_loop",
          "topic": "Pointer value 192 selects the first shape block at 12288"
        },
        {
          "chunk": "sprite_shape2_load_loop",
          "topic": "Other pointer values can select the second block"
        },
        {
          "chunk": "sprite_shape3_load_loop",
          "topic": "Other pointer values can select the third block"
        },
        {
          "chunk": "sprite_horizontal_movement_loop",
          "topic": "Pointer switching is used together with X movement to animate the sprite"
        }
      ]
    },
    {
      "start": 8729,
      "end": 8744,
      "name": "sprite_horizontal_movement_loop",
      "description": "Explains LINE 50 which defines the horizontal movement loop FOR X=0 TO 347 STEP 3 that moves the sprite across the screen by stepping X in increments of 3 (for faster movement) from 0 to 347. Includes surrounding whitespace and page footer context for the block.",
      "references": [
        {
          "chunk": "sprite_pointer_setting_p_equals_192",
          "topic": "Pointer changes within the X loop create the animation frames"
        },
        {
          "chunk": "sprite_screen_side_split_rx_lx_calculation",
          "topic": "Converts the 0\u2013347 X position into the VIC's high-bit (RX) and low-byte (LX) for screen sides"
        }
      ]
    },
    {
      "start": 8745,
      "end": 8760,
      "name": "sprite_screen_side_split_rx_lx_calculation",
      "description": "Explains LINE 55 computations used inside the movement loop. RX = INT(X/256) produces 0 for X<256 and 1 for X\u2265256; RX is used to POKE V+16 with 0 or 1 to indicate the right side of the screen. LX = X - RX*256 computes the low 8 bits (0\u2013255) used for the VIC X-position register, resetting to 0 when crossing from the left to the right side so POKE V+16,1 can be used properly.",
      "references": [
        {
          "chunk": "sprite_horizontal_movement_loop",
          "topic": "These formulas are evaluated each loop iteration to position the sprite horizontally"
        },
        {
          "chunk": "sprite_color_and_y_position",
          "topic": "Y is handled separately; RX/LX handle X positioning across screen halves"
        },
        {
          "chunk": "sprite_pointer_setting_p_equals_192",
          "topic": "Pointer changes combined with RX/LX create the full animated movement"
        }
      ]
    },
    {
      "start": 8761,
      "end": 8761,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 8762,
      "end": 8777,
      "name": "sprite_horizontal_position_and_wrapping",
      "description": "Explains LINE 60: how POKEV,LX sets the horizontal (X) position of sprite 0 (LX 0\u2013255), how LX wraps from 255 back to 0 due to the LX equation, and how POKEV+16,RX sets the 'right side' carry bit for positions beyond 256 (RX = 0 or 1). Covers usage of V and V+16 sprite position registers for horizontal placement and wrap behavior.",
      "references": [
        {
          "chunk": "poke_sprite_pointer_poke2040_and_delay_loop",
          "topic": "where P (the pointer) is later applied to the sprite pointer (POKE2040,P)"
        },
        {
          "chunk": "increment_pointer_and_wrap_three_sprite_shapes",
          "topic": "how pointer-wrapping logic (P reset) interacts with horizontal positioning and RX/LX sequencing"
        }
      ]
    },
    {
      "start": 8778,
      "end": 8797,
      "name": "sprite_pointer_sound_triggers_gosub200_and_gosub300",
      "description": "Explains LINE 70 and LINE 75: conditional checks of the sprite pointer P (IF P=192 THEN GOSUB200 and IF P=193 THEN GOSUB300). Describes that when the pointer points at 192 it triggers the first sound-effect waveform subroutine (line 200), and when it points at 193 it triggers the second voice waveform subroutine (line 300).",
      "references": [
        {
          "chunk": "waveform_control_subroutine_line_200",
          "topic": "details of the first waveform control subroutine called by GOSUB200"
        },
        {
          "chunk": "waveform_control_subroutine_line_300",
          "topic": "details of the second waveform control subroutine called by GOSUB300"
        },
        {
          "chunk": "increment_pointer_and_wrap_three_sprite_shapes",
          "topic": "how pointer values cycle through 192/193/194 to select the different shapes that trigger these subroutines"
        }
      ]
    },
    {
      "start": 8798,
      "end": 8807,
      "name": "poke_sprite_pointer_poke2040_and_delay_loop",
      "description": "Explains LINE 80: POKE2040,P sets the sprite pointer to the base location indicated by P (e.g., 192). Also explains the simple timing loop (FOR T=1 TO 60 : NEXT) used as a delay to control the dancing speed of the mouse sprite; suggests changing the loop count to alter animation speed.",
      "references": [
        {
          "chunk": "increment_pointer_and_wrap_three_sprite_shapes",
          "topic": "how P is incremented later (P=P+1) to point POKE2040 at successive sprite shape data blocks"
        },
        {
          "chunk": "sprite_data_blocks_and_animation_via_pointers",
          "topic": "the DATA blocks that POKE2040 points to for the three sprite shapes"
        }
      ]
    },
    {
      "start": 8808,
      "end": 8825,
      "name": "increment_pointer_and_wrap_three_sprite_shapes",
      "description": "Explains LINE 85: P=P+1 increments the sprite pointer so the sprite cycles through multiple shapes. Describes the wrap test (IF P>194 THEN P=192) that keeps P cycling through 192, 193, 194 (three 64-byte sprite shape blocks located at the specified memory ranges). Explains how this makes the pointer point consecutively to three shape blocks for animation.",
      "references": [
        {
          "chunk": "sprite_pointer_sound_triggers_gosub200_and_gosub300",
          "topic": "which pointer values (192,193) invoke the waveform subroutines"
        },
        {
          "chunk": "sprite_data_blocks_and_animation_via_pointers",
          "topic": "the exact DATA blocks pointed to by P (memory ranges and how they map to sprite shapes)"
        }
      ]
    },
    {
      "start": 8826,
      "end": 8849,
      "name": "movement_nextx_and_for_loop_matching",
      "description": "Explains LINE 90: NEXT X \u2014 how the program moves the sprite across the screen only after changing its shape. Describes stepping the sprite 3 X positions at a time (instead of 1) to create faster, more 'dancelike' motion, and notes that NEXT X matches the FOR... X loop defined earlier (line 50).",
      "references": [
        {
          "chunk": "sprite_horizontal_position_and_wrapping",
          "topic": "how X position changes interact with LX/RX and wrapping"
        },
        {
          "chunk": "poke_sprite_pointer_poke2040_and_delay_loop",
          "topic": "how the delay loop sets the speed while the FOR X/NEXT X movement controls horizontal stepping"
        }
      ]
    },
    {
      "start": 8850,
      "end": 8853,
      "name": "program_end_line_95",
      "description": "Explains LINE 95: END \u2014marks the termination of the program when the sprite moves off the screen.",
      "references": [
        {
          "chunk": "movement_nextx_and_for_loop_matching",
          "topic": "the movement loop that eventually causes the sprite to move off-screen and trigger program END"
        }
      ]
    },
    {
      "start": 8854,
      "end": 8871,
      "name": "sprite_data_blocks_and_animation_via_pointers",
      "description": "Explains LINES 100\u2013109: DATA entries contain the 63-byte definitions for each sprite shape. Describes the sequence: first 63 numbers for sprite shape 1, next 63 for shape 2, then 63 for shape 3. Explains how the program reads these DATA values into memory and then simply points sprite 0 at the appropriate 64-byte blocks to animate by swapping pointers. Suggests experimenting with changing DATA numbers to see shape effects.",
      "references": [
        {
          "chunk": "increment_pointer_and_wrap_three_sprite_shapes",
          "topic": "how P cycles through three pointers to reference these DATA blocks"
        },
        {
          "chunk": "poke_sprite_pointer_poke2040_and_delay_loop",
          "topic": "where P is written into the VIC sprite pointer register (POKE2040,P) to select a shape"
        }
      ]
    },
    {
      "start": 8872,
      "end": 8894,
      "name": "waveform_control_subroutine_line_200",
      "description": "Explains LINE 200: the subroutine that controls the first sound effect. Shows POKES+4,129 to turn on the waveform control (enable sound) and POKES+4,128 to turn it off, and RETURN to go back to the caller (end of line 70) so execution resumes after changing waveform control bytes.",
      "references": [
        {
          "chunk": "sprite_pointer_sound_triggers_gosub200_and_gosub300",
          "topic": "this subroutine is invoked when P=192 (IF P=192 THEN GOSUB200)"
        },
        {
          "chunk": "waveform_control_subroutine_line_300",
          "topic": "the analogous second voice/subroutine used for P=193"
        }
      ]
    },
    {
      "start": 8895,
      "end": 8902,
      "name": "waveform_control_subroutine_line_300",
      "description": "Explains LINE 300: the subroutine that controls the second sound effect (Voice 2). Shows POKES+11,129 to turn the waveform control on and POKES+11,128 to turn it off, with RETURN to resume execution at the caller (end of line 75).",
      "references": [
        {
          "chunk": "sprite_pointer_sound_triggers_gosub200_and_gosub300",
          "topic": "this subroutine is invoked when P=193 (IF P=193 THEN GOSUB300)"
        },
        {
          "chunk": "waveform_control_subroutine_line_200",
          "topic": "the first voice/subroutine which uses POKES+4 to control its waveform"
        }
      ]
    },
    {
      "start": 8903,
      "end": 8928,
      "ignore": true,
      "reason": "Page footers, spacing and non-technical layout lines between sections"
    },
    {
      "start": 8929,
      "end": 8975,
      "name": "spritemaking_chart",
      "description": "Easy Sprite-Making Chart: VIC register offsets and how to control sprites 0\u20137. Contains: V+21 enable bits for individual sprites, sprite pointer registers (2040\u20132047) and their pointer values (192\u2013199) corresponding to sprite memory blocks (12288..12798), color registers (V+39..V+46), left X regs (V+0,V+2,...), right-side X control (V+16 bits), Y position regs (V+1,V+3,...), expansion controls (V+23, V+29), multicolor mode (V+28) and multicolor registers (V+37,V+38). Also shows sprite-sprite collision (V+30) and sprite-background collision (V+31) usage: IF PEEK(V+30) AND X = X THEN action.",
      "references": [
        {
          "chunk": "spritemaking_notes",
          "topic": "alternative pointer locations and more on memory reservation"
        },
        {
          "chunk": "dancing_mouse_line_explanations",
          "topic": "practical example using pointers V+21, 2040, V+39, V+16"
        }
      ]
    },
    {
      "start": 8976,
      "end": 8979,
      "ignore": true,
      "reason": "Page header/footer or spacing"
    },
    {
      "start": 8980,
      "end": 9066,
      "name": "spritemaking_notes",
      "description": "Notes on sprite memory allocation, alternative pointer locations (cassette buffer: 832..1023 for blocks 13\u201315), turning on/off sprites via POKE V+21 and using bitwise operations (PEEK V+21 AND (255-<bit>) to turn off a sprite without affecting others; PEEK(V+21) OR <bit> to re-enable), X position behavior beyond 255 requiring POKE V+16 then new X 0\u201363, Y position ranges (0\u2013255 with 50\u2013229 visible area), sprite color codes (0\u201315 mapping to colors), recommendation to reserve separate 64-byte block per sprite (63 bytes used), and advice on pointer placement to avoid overwriting by BASIC program.",
      "references": [
        {
          "chunk": "spritemaking_chart",
          "topic": "which VIC registers to POKE for colors, pointers and positioning"
        }
      ]
    },
    {
      "start": 9067,
      "end": 9073,
      "ignore": true,
      "reason": "Small non-technical break/spacing between sections"
    },
    {
      "start": 9074,
      "end": 9160,
      "name": "sprite_priority_multicolor_and_collision",
      "description": "Sprite display priority, multi-color mode, pixel-pair color mapping, and collision detection. Priority: lower numbered sprites (0 is highest) appear in front of higher-numbered sprites. Multi-color mode uses pixel pairs to select among Background, Multi-Color 1, Sprite Color, Multi-Color 2 depending on which of the two bits in the pair are set; explains how to compute DATA byte for an 8-pixel block (bit weights 128..1). Collision detection: PEEK(V+30) for S-S collisions and PEEK(V+31) for S-B (sprite/background) collisions; test with IF PEEK(V+30) AND X = X THEN action where X is bitmask 1,2,4,...,128 for sprite 0..7.",
      "references": [
        {
          "chunk": "spritemaking_chart",
          "topic": "registers for multicolor mode (V+28) and multi-color registers (V+37,V+38)"
        }
      ]
    },
    {
      "start": 9161,
      "end": 9167,
      "ignore": true,
      "reason": "Spacing between examples"
    },
    {
      "start": 9168,
      "end": 9207,
      "name": "graphic_characters_data_program",
      "description": "Example program demonstrating using printable characters (e.g., space and 'Q') in DATA statements to design a sprite visually. Loads character-based strings from DATA into memory, converts 'Q' to solid pixels by assembling 8-pixel blocks (computes value t using bit weights 2^(7-j)), pokes into sprite memory (832+i*3+k), and displays the numeric POKE values. Uses VIC base V=53248, enables sprite (V+21), sets color (V+39), and uses sprite pointer 2040,13 for block placement.",
      "references": [
        {
          "chunk": "sprite_data_encoding_groups_of_eight",
          "topic": "how the conversion from 'Q' characters to numeric DATA determines pixel bytes"
        },
        {
          "chunk": "spritemaking_chart",
          "topic": "where to POKE sprite pointer values (2040) and sprite memory (832)"
        }
      ]
    },
    {
      "start": 9208,
      "end": 9222,
      "ignore": true,
      "reason": "Spacing and section divider before Chapter 4"
    },
    {
      "start": 9223,
      "end": 9303,
      "name": "chapter4_intro_and_sid_register_overview",
      "description": "Chapter 4 introduction to sound/music and the 6581 SID chip: overview of SID capabilities (three voices, ADSR envelope, filtering, modulation, noise), accessing SID via POKE to memory locations starting at 54272 ($D400) through 54296 inclusive. Explains using a base address S=54272 and adding offsets 0..24 to access registers; PEEK usage also noted.",
      "references": [
        {
          "chunk": "sid_registers_and_examples_index",
          "topic": "appendix reference for full SID register map"
        },
        {
          "chunk": "example_program_1_code_and_explanation",
          "topic": "first SID example showing basic sound programming"
        }
      ]
    },
    {
      "start": 9304,
      "end": 9323,
      "ignore": true,
      "reason": "Layout/page spacing before Example Program 1"
    },
    {
      "start": 9324,
      "end": 9376,
      "name": "example_program_1_code_and_explanation",
      "description": "EXAMPLE PROGRAM 1: Single-voice BASIC demonstration. Code (lines 5\u2013100) sets S=54272, clears SID registers, sets Attack/Decay and Sustain/Release, sets volume (register 24), reads DATA triplets (hf,lf,dr) to play notes. Includes line-by-line summary describing clearing chip (forl=stos+24 POKEl,0), setting ADSR and volume, writing frequency high and low bytes to registers, gating waveform (POKE S+4), timing loop for duration and release. DATA lines included for song notes.",
      "references": [
        {
          "chunk": "volume_and_frequencies",
          "topic": "how frequency registers map to pitch and the Fn formula"
        },
        {
          "chunk": "adsr_registers_and_examples",
          "topic": "how registers 5 and 6 control ADSR"
        }
      ]
    },
    {
      "start": 9377,
      "end": 9377,
      "ignore": true,
      "reason": "Single-line spacing / page marker"
    },
    {
      "start": 9378,
      "end": 9421,
      "name": "volume_and_frequencies",
      "description": "Volume and frequency basics for the SID: register 24 (overall volume, 0\u201315) and how frequency uses two registers (high and low bytes). Frequency formula Fn = Fout / 0.06097; splitting Fn into high and low bytes: Fhi = INT(Fn/256), Flo = Fn - (256*Fhi). Notes on cycles per second and pitch; Appendix E referenced for frequency table across octaves.",
      "references": [
        {
          "chunk": "example_program_1_code_and_explanation",
          "topic": "example that sets volume and writes high/low frequency bytes per note"
        }
      ]
    },
    {
      "start": 9422,
      "end": 9490,
      "name": "using_multiple_voices_and_example_program_2",
      "description": "EXAMPLE PROGRAM 2: multi-voice music playback. Sets up three voices, dimensions arrays for timing (1/16th of measure), loads base note frequencies, decodes compact encoded notes into duration/octave/note, fills activity arrays for each 1/16th measure, and then loops through measures to POKE low/high freq and waveform control for each voice. Shows use of registers for waveform control per voice (V(0..2) values), setting pulse width and filter parameters via POKEs. DATA tables hold base frequencies and score data for voices 1\u20133.",
      "references": [
        {
          "chunk": "note_duration_encoding",
          "topic": "how durations are encoded and decoded (((D*8)+O)*16)+N"
        },
        {
          "chunk": "sid_registers_and_examples_index",
          "topic": "which SID registers correspond to waveform control and filter"
        }
      ]
    },
    {
      "start": 9491,
      "end": 9495,
      "ignore": true,
      "reason": "Small spacing between examples"
    },
    {
      "start": 9496,
      "end": 9609,
      "name": "example2_explanation_and_note_duration_encoding",
      "description": "Line-by-line explanation of EXAMPLE PROGRAM 2 (control of three voices): describes clearing registers, dimensioning arrays, storing waveform control bytes for each voice, reading base frequencies, decoding encoded note numbers (duration, octave, note), dividing base frequencies for octaves, populating activity arrays (high/low freq and control bytes), and finally POKE loop to play each 1/16th measure. Includes note duration table mapping durations to 1/16th counts and the encoding formula ((((D*8)+O)*16)+N). Negative durations used for silences.",
      "references": [
        {
          "chunk": "using_multiple_voices_and_example_program_2",
          "topic": "the full program listing that this explanation decodes"
        }
      ]
    },
    {
      "start": 9610,
      "end": 9610,
      "ignore": true,
      "reason": "Single-line spacing"
    },
    {
      "start": 9611,
      "end": 9630,
      "name": "controlling_multiple_voices_timing_and_arrays",
      "description": "Techniques for coordinating multiple voices: divide measures into 16 parts, store events per 1/16th in separate arrays for each voice, compute high and low frequency bytes, and use waveform control bytes to gate notes on/off. Explains how activity arrays allow synchronized playback of multiple voices and how to reuse base frequencies and division by 2 for octaves.",
      "references": [
        {
          "chunk": "example2_explanation_and_note_duration_encoding",
          "topic": "practical decoding of notes into per-1/16th array entries"
        }
      ]
    },
    {
      "start": 9631,
      "end": 9637,
      "ignore": true,
      "reason": "Spacing between sections"
    },
    {
      "start": 9638,
      "end": 9656,
      "name": "waveforms_and_sine_wave_intro",
      "description": "Introduces the concept of timbre and waveforms, explains that timbre is determined primarily by waveform, and shows a conceptual ASCII illustration of a sinusoidal (sine) wave.",
      "references": [
        {
          "chunk": "sawtooth_program_intro",
          "topic": "Shows how to hear and compare other waveforms (sawtooth) using the example program"
        }
      ]
    },
    {
      "start": 9657,
      "end": 9688,
      "name": "sawtooth_program_intro",
      "description": "Explains how to re-run the first music example to hear different waveforms, identifies the first program as using the 6581 SID sawtooth waveform (with ASCII illustration), and instructs changing the note start/stop numbers (line 70 and line 90) so the program will be modified \u2014 concludes with the 'Your program should now look like this:' lead-in and the Example Program 3 title.",
      "references": [
        {
          "chunk": "example_program_3_listing",
          "topic": "Contains the full modified program listing you should load/run"
        },
        {
          "chunk": "waveforms_and_sine_wave_intro",
          "topic": "Conceptual background on waveforms and the sine wave"
        }
      ]
    },
    {
      "start": 9689,
      "end": 9710,
      "name": "example_program_3_listing",
      "description": "Complete listing for EXAMPLE PROGRAM 3 (EXAMPLE 1 MODIFIED) including token directives (start/stop tok64) and all BASIC lines and DATA statements; the listing reflects the earlier instruction to change the note start/stop numbers.",
      "references": [
        {
          "chunk": "sawtooth_program_intro",
          "topic": "Explains why and how this listing was produced from Example 1"
        },
        {
          "chunk": "run_results_triangle_and_pulse",
          "topic": "Describes the audible results when this program is run and compares triangular and pulse waveforms"
        }
      ]
    },
    {
      "start": 9711,
      "end": 9731,
      "name": "run_results_triangle_and_pulse",
      "description": "Instructions to RUN the modified program and observations about how the sound quality changes (sawtooth -> triangle), includes ASCII illustrations of the triangular waveform and the variable pulse (rectangular) waveform and labels showing pulse width.",
      "references": [
        {
          "chunk": "example_program_3_listing",
          "topic": "The program you run to hear the triangular and pulse waveforms"
        },
        {
          "chunk": "pulse_width_registers_and_square_wave",
          "topic": "Explains how pulse width is controlled (registers, formula) and how to make a square wave"
        }
      ]
    },
    {
      "start": 9732,
      "end": 9755,
      "name": "pulse_width_registers_and_square_wave",
      "description": "Explains pulse (rectangular) waveform width control for voice 1 via SID registers 2 (low byte Lpw) and 3 (high 4 bits Hpw), defines the 12-bit PWn value (PWn = Hpw*256 + Lpw), gives the pulse output percentage formula (PWout = (PWn/40.95) %), shows that PWn = 2048 (Hpw=8, Lpw=0) produces a square wave, and instructs adding the POKES+3,8:POKES+2,0 line to the program and altering start/stop numbers to hear changes.",
      "references": [
        {
          "chunk": "run_results_triangle_and_pulse",
          "topic": "Context for why you would change pulse width in the running program"
        },
        {
          "chunk": "white_noise_selection",
          "topic": "Other available waveform (white noise) and how to select it"
        }
      ]
    },
    {
      "start": 9756,
      "end": 9768,
      "name": "white_noise_selection",
      "description": "Describes the white noise waveform (ASCII illustration) as useful for sound effects and gives the BASIC change to hear it by setting the program's start number in line 70 to 129 and the stop number in line 90 to 128.",
      "references": [
        {
          "chunk": "pulse_width_registers_and_square_wave",
          "topic": "Alternative waveform options and program adjustments after learning pulse width control"
        }
      ]
    },
    {
      "start": 9769,
      "end": 9769,
      "ignore": true,
      "reason": "Small spacing line"
    },
    {
      "start": 9770,
      "end": 9830,
      "name": "understanding_waveforms_and_harmonics",
      "description": "Technical explanation of harmonic content for common waveforms: triangle (odd harmonics, amplitude \u221d 1/(harmonic^2)), sawtooth (all harmonics, amplitude \u221d 1/harmonic), square (odd harmonics, amplitude \u221d 1/harmonic), and how pulse width affects harmonic content. Discusses fundamental frequency and harmonics (integer multiples). Recommends choosing waveform to approximate desired timbre before applying filtering.",
      "references": [
        {
          "chunk": "filtering_and_example5",
          "topic": "filter usage to further shape harmonic content"
        },
        {
          "chunk": "pulse_width_and_pulse_wave",
          "topic": "how rectangular/pulse waves vary timbre"
        }
      ]
    },
    {
      "start": 9831,
      "end": 9831,
      "ignore": true,
      "reason": "Spacing before envelope section"
    },
    {
      "start": 9832,
      "end": 9896,
      "name": "envelope_generator_and_example_program_4",
      "description": "The ADSR envelope generator: definitions of Attack, Decay, Sustain, Release phases and how they shape amplitude over time. Shows example modifications (EXAMPLE PROGRAM 4) to set SDSR via registers 5 and 6 for voice 1. Explains that register 5 high nibble = ATTACK (0\u201315), low nibble = DECAY (0\u201315); register 6 high nibble = SUSTAIN (0\u201315), low nibble = RELEASE (0\u201315). Includes example program lines setting POKES+5,88:POKES+6,195 and modified waveform control.",
      "references": [
        {
          "chunk": "adsr_table_and_examples",
          "topic": "attack/decay/release numeric table and example settings"
        },
        {
          "chunk": "example_program_1_code_and_explanation",
          "topic": "base program where ADSR changes are applied"
        }
      ]
    },
    {
      "start": 9897,
      "end": 9901,
      "ignore": true,
      "reason": "Small spacing"
    },
    {
      "start": 9902,
      "end": 9974,
      "name": "adsr_table_and_examples",
      "description": "ATTACK/DECAY/RELEASE rate table: numeric values 0\u201315 with corresponding approximate time constants (e.g., 0: A=2ms / D=6ms ... 15: A=8s / D=24s). Shows how to compose register values by (ATTACK*16 + DECAY) and (SUSTAIN*16 + RELEASE). Provides sample settings for violin, xylophone, piano-like and experimental (synth) sounds with suggested POKE values and suggested waveform choices (triangle, square, sawtooth) and pulse-width register settings.",
      "references": [
        {
          "chunk": "envelope_generator_and_example_program_4",
          "topic": "register encoding and example program that sets ADSR"
        }
      ]
    },
    {
      "start": 9975,
      "end": 9990,
      "ignore": true,
      "reason": "Spacing before filtering section"
    },
    {
      "start": 9991,
      "end": 10038,
      "name": "filtering_and_example_program_5",
      "description": "FILTERING overview and EXAMPLE PROGRAM 5: demonstrates setting filter cutoff and enabling filter for voice 1. Shows POKES+22 (Hcf) and POKES+21 (Lcf) for cutoff frequency and POKES+23 to turn filter ON. Demonstrates high-pass filter effect (attenuates frequencies below cutoff), and provides example code that alters register 24 for volume+filter settings. Contains high-level diagrams of filter frequency response types (high-pass, low-pass, band-pass, notch).",
      "references": [
        {
          "chunk": "filter_types_and_registers",
          "topic": "which bits in register 24 control filter types and how Lcf/Hcf encode cutoff"
        },
        {
          "chunk": "advanced_techniques_and_example_6",
          "topic": "using oscillator outputs for modulation with filters"
        }
      ]
    },
    {
      "start": 10039,
      "end": 10039,
      "ignore": true,
      "reason": "Single-line spacing"
    },
    {
      "start": 10040,
      "end": 10119,
      "name": "filter_types_and_registers",
      "description": "Detailed SID filter control: Register 24 also contains filter enable bits in addition to volume. Bit 6 = high-pass (0=off/1=on), bit 5 = bandpass, bit 4 = low-pass. Low 3 bits of cutoff frequency are in register 21 (Lcf, 0\u20137), and high 8 bits in register 22 (Hcf, 0\u2013255). Combining high- and low-pass yields notch filters; explains dynamic filtering during ADSR phases to create evolving timbres.",
      "references": [
        {
          "chunk": "filtering_and_example_program_5",
          "topic": "example demonstrating use of registers 21,22,23 and 24 for filter effects"
        }
      ]
    },
    {
      "start": 10120,
      "end": 10120,
      "ignore": true,
      "reason": "Spacing before Advanced Techniques"
    },
    {
      "start": 10121,
      "end": 10193,
      "name": "advanced_techniques_and_example_6",
      "description": "Advanced SID techniques: using oscillator 3 and envelope 3 outputs for dynamic modulation. Register 27 exposes oscillator 3 digital output (0\u2013255) reflecting waveform (saw increments 0..255 etc.); register 25 gives envelope generator 3 output. Bit 7 of register 24 mutes audio output of voice 3 while still allowing its digital output to be read. Demonstrates vibrato/modulation by adding oscillator 3 output to another oscillator's frequency. Includes EXAMPLE PROGRAM 6 that uses peek(S+27) to modulate voice 1 frequency and example data.",
      "references": [
        {
          "chunk": "example_program_7_code_and_explanation",
          "topic": "siren example using oscillator 3 output for modulation"
        },
        {
          "chunk": "example_program_6_code_and_explanation",
          "topic": "detailed explanation of Example 6"
        }
      ]
    },
    {
      "start": 10194,
      "end": 10201,
      "ignore": true,
      "reason": "Spacing before example explanation block"
    },
    {
      "start": 10202,
      "end": 10267,
      "name": "example6_explanation_and_example7",
      "description": "Line-by-line explanation of EXAMPLE PROGRAM 6 followed by EXAMPLE PROGRAM 7 code: explains clearing registers, setting pulse width, ADSR, waveform choice for oscillator 3, muting voice 3 audio but using its output for modulation, timing loop, and computing HF/LF to POKE into voice 1. Example 7 (siren) demonstrates similar modulation technique using peek(S+27) * 3.5 for wider frequency sweep.",
      "references": [
        {
          "chunk": "advanced_techniques_and_example_6",
          "topic": "discussion of oscillator 3 output usage and muting with bit 7"
        }
      ]
    },
    {
      "start": 10268,
      "end": 10269,
      "ignore": true,
      "reason": "Spacing between examples"
    },
    {
      "start": 10270,
      "end": 10314,
      "name": "example7_code_and_example8_code",
      "description": "EXAMPLE PROGRAM 7 (siren) code: sets oscillator 3 to triangle, uses peek(S+27) to modulate voice 1 frequency, shows timing loop and gating. EXAMPLE PROGRAM 8 (hand clap imitation using filtered noise) code: sets noise waveform for voice 1, ADSR for percussion-like envelope, sets filter cutoff and type, uses repeated gated bursts (start/stop noise waveform control) to create clap effect, includes POKE register settings.",
      "references": [
        {
          "chunk": "example6_explanation_and_example7",
          "topic": "relationship between Examples 6 and 7 (modulation)"
        },
        {
          "chunk": "example8_explanation",
          "topic": "explanation of clap program and why filter + noise produce the effect"
        }
      ]
    },
    {
      "start": 10315,
      "end": 10317,
      "ignore": true,
      "reason": "Small spacing"
    },
    {
      "start": 10318,
      "end": 10335,
      "name": "example8_explanation",
      "description": "Line-by-line explanation of the filtered-noise 'hand clap' program (EXAMPLE 8): clearing SID registers, setting voice frequencies, ADSR for a fast attack and short decay, selecting noise waveform, setting high cutoff frequency and enabling the filter, setting overall volume and filter type (high-pass), and looping to create multiple claps.",
      "references": [
        {
          "chunk": "example7_code_and_example8_code",
          "topic": "Example 8 code that produces the clap sound"
        }
      ]
    },
    {
      "start": 10336,
      "end": 10342,
      "ignore": true,
      "reason": "Spacing before synchronization section"
    },
    {
      "start": 10343,
      "end": 10364,
      "name": "synchronization_and_ring_modulation_overview",
      "description": "Synchronization and ring modulation overview: explains syncing of two oscillators (logical AND-like behavior) to lock waveforms (used to create 'mosquito' imitation). Ring modulation replaces output of oscillator 1 with a modulated combination of oscillator 1 and 3 to create non-harmonic overtones for sounds like bells/gongs. Shows which bits in register 4 control sync and ring-mod (bit 1 enables sync between voice 1 and 3; bit 3 enables ring modulation).",
      "references": [
        {
          "chunk": "example9_code_and_explanation",
          "topic": "example program showing synchronization"
        },
        {
          "chunk": "example10_code_and_explanation",
          "topic": "ring modulation example (clock chime imitation)"
        }
      ]
    },
    {
      "start": 10365,
      "end": 10365,
      "ignore": true,
      "reason": "Spacing"
    },
    {
      "start": 10366,
      "end": 10407,
      "name": "example9_code_and_example10_code",
      "description": "EXAMPLE PROGRAM 9 (synchronization 'mosquito'): sets up voices, ADSR, sets voice 1 to triangle waveform with sync enabled (bits 0,1,4 set in register 4), plays for a duration and stops. EXAMPLE PROGRAM 10 (ring modulation clock chime): demonstrates ring modulation by setting bit 3 in register 4 for voice 1; loops to create multiple 'chimes' with gating and timing loops. Both examples include POKEs that set frequencies, ADSR values, and waveform-control sequences.",
      "references": [
        {
          "chunk": "synchronization_and_ring_modulation_overview",
          "topic": "which control bits enable sync/ring-mod and how they are used"
        }
      ]
    },
    {
      "start": 10408,
      "end": 10408,
      "ignore": true,
      "reason": "Single-line spacing"
    },
    {
      "start": 10409,
      "end": 10431,
      "name": "examples_9_10_line_by_line_explanations_and_conclusion",
      "description": "Line-by-line explanations for EXAMPLE PROGRAM 9 and 10: details of instructions and timing loops, clarifies how bits in register 4 enable sync/ring-mod and how waveforms/gating/timing produce the intended effects. Concludes Chapter 4 with encouragement for experimentation and reference to further resources (e.g., 'Making Music on Your Commodore Computer').",
      "references": [
        {
          "chunk": "example9_code_and_example10_code",
          "topic": "the code these explanations correspond to"
        }
      ]
    },
    {
      "start": 10432,
      "end": 10444,
      "ignore": true,
      "reason": "End-of-chapter footers and spacing"
    },
    {
      "start": 10445,
      "end": 10474,
      "ignore": true,
      "reason": "Chapter 5 table of contents (non-technical index/listing)"
    },
    {
      "start": 10475,
      "end": 10499,
      "ignore": true,
      "reason": "Spacing and header lines preceding Chapter 5 text"
    },
    {
      "start": 10500,
      "end": 10559,
      "name": "what_is_machine_language_and_operating_system_role",
      "description": "Introduction to machine language and the Commodore 64 operating system: defines machine language as the native instruction set of the microprocessor, explains the role of the built-in OS and BASIC interpreter (both machine language programs stored in ROM), and how BASIC commands are interpreted by machine language routines. Discusses READY prompt and that the operating system organizes memory and provides system services.",
      "references": [
        {
          "chunk": "memory_map_and_machine_code_overview",
          "topic": "where the operating system and BASIC interpreter reside in memory"
        },
        {
          "chunk": "writing_your_first_machine_language_instruction",
          "topic": "how machine instructions are represented in memory"
        }
      ]
    },
    {
      "start": 10560,
      "end": 10611,
      "name": "simple_memory_map_overview",
      "description": "Introduction to what machine code looks like and a simple memory map of the Commodore 64: roles and address ranges for 6510 registers, system start, OS memory, screen memory, sprite pointers, user RAM, BASIC interpreter, special RAM area, VIC-II, SID registers, color RAM, I/O registers, and KERNAL.",
      "references": [
        {
          "chunk": "machine_code_and_registers_overview",
          "topic": "Explanation of machine-language instructions and internal registers"
        },
        {
          "chunk": "writing_machine_language_and_assemblers",
          "topic": "Tools used to write programs that occupy memory described here"
        }
      ]
    },
    {
      "start": 10612,
      "end": 10709,
      "name": "machine_code_and_registers_overview",
      "description": "How machine language programs are stored as instructions and operands (bytes), tokens vs BASIC keywords, and the role of the 6510 internal registers: Accumulator (A), X and Y index registers, Status register (flags), Program Counter, Stack Pointer, and the I/O port at memory locations 0 and 1 used for memory management.",
      "references": [
        {
          "chunk": "simple_memory_map_overview",
          "topic": "Where registers and memory areas are mapped"
        },
        {
          "chunk": "lda_immediate_absolute_and_address_representation",
          "topic": "Example of an instruction that uses the accumulator and addressing modes"
        },
        {
          "chunk": "the_stack",
          "topic": "Stack pointer and stack usage"
        }
      ]
    },
    {
      "start": 10710,
      "end": 10751,
      "name": "writing_machine_language_and_assemblers",
      "description": "Methods for creating machine language programs: assemblers vs manual POKEing; explanation of assembler and disassembler, and the 64MON monitor cartridge (features: register display, memory editor, assembler/disassembler). Recommendation to use an assembler and note that examples use 64MON conventions.",
      "references": [
        {
          "chunk": "simple_memory_map_overview",
          "topic": "Memory areas where assembled programs live"
        },
        {
          "chunk": "hex_notation_and_64mon_examples",
          "topic": "Hexadecimal notation used in assemblers and 64MON examples"
        }
      ]
    },
    {
      "start": 10752,
      "end": 10865,
      "name": "hex_notation_and_64mon_examples",
      "description": "Hexadecimal (base 16) primer: digit symbols 0\u2013F, conversion examples between decimal/hex/binary, positional notation, addresses up to $FFFF, use of $ prefix for hex, and examples of viewing memory and registers using 64MON (SYS, B*, .M and memory dump format). Encouragement to learn to think in hex.",
      "references": [
        {
          "chunk": "writing_machine_language_and_assemblers",
          "topic": "Assemblers display and accept hex addresses and values"
        },
        {
          "chunk": "lda_immediate_absolute_and_address_representation",
          "topic": "How hex is used to represent instruction tokens and operands"
        }
      ]
    },
    {
      "start": 10866,
      "end": 10963,
      "name": "lda_immediate_absolute_and_address_representation",
      "description": "First instruction example: LDA (load accumulator). Explanation of assembler mnemonics, immediate mode (LDA #$05 with token $A9), absolute mode (LDA $102E with token $AD), how operands are encoded as bytes (low byte first, then high byte), example $AD $2E $10, and brief introduction to BRK as an end/return instruction to a monitor.",
      "references": [
        {
          "chunk": "hex_notation_and_64mon_examples",
          "topic": "Hex tokens and values used in instruction encoding"
        },
        {
          "chunk": "writing_machine_language_and_assemblers",
          "topic": "Using 64MON to assemble and observe tokens/bytes"
        },
        {
          "chunk": "writing_your_first_program_example",
          "topic": "Using these instructions in a simple program example"
        }
      ]
    },
    {
      "start": 10964,
      "end": 11033,
      "name": "writing_your_first_program_example",
      "description": "Practical contrast of BASIC POKE vs machine language: CBM ASCII vs screen codes, POKE example to place 'A' on screen, then a step-by-step enter-and-assemble example using 64MON (.A assembly commands) building a tiny machine-language program (LDA #$01; STA $0400; LDA #$0E; STA $D800; BRK) and executing it with G command to display the result.",
      "references": [
        {
          "chunk": "lda_immediate_absolute_and_address_representation",
          "topic": "Uses LDA/STA and BRK explained earlier"
        },
        {
          "chunk": "hex_notation_and_64mon_examples",
          "topic": "64MON usage and hex values in the example"
        }
      ]
    },
    {
      "start": 11034,
      "end": 11057,
      "name": "addressing_mode_zero_page",
      "description": "Zero page addressing mode: concept of pages (high-order byte), zero page is page $00 so addresses are $0000\u2013$00FF, zero page uses a single-byte address in instructions (implied high byte = 0) and is a special, faster addressing mode.",
      "references": [
        {
          "chunk": "machine_code_and_registers_overview",
          "topic": "Zero page is part of the memory map and interacts with registers"
        },
        {
          "chunk": "indexed_addressing_and_indexing",
          "topic": "Zero page also has indexed variants"
        }
      ]
    },
    {
      "start": 11058,
      "end": 11094,
      "name": "the_stack",
      "description": "The 6510 stack: purpose as temporary storage and return addresses (similar to BASIC GOSUB/RETURN), stack operations (PHA, PLA, PHP, PLP), stack location in page one ($0100\u2013$01FF), stack grows downward (first free position is $01FF), and behavior of the stack pointer (S) when pushing/popping.",
      "references": [
        {
          "chunk": "machine_code_and_registers_overview",
          "topic": "Stack pointer (S) described among internal registers"
        },
        {
          "chunk": "implied_mode_and_register_notation",
          "topic": "PHA/PLA/PHP/PLP are implied-mode instructions discussed later"
        }
      ]
    },
    {
      "start": 11095,
      "end": 11108,
      "name": "implied_mode_and_register_notation",
      "description": "Implied addressing mode: instructions that act on implied registers or operations without explicit operands (e.g., PHA, PLA, PHP, PLP). Also establishes shorthand notation for registers used from here on: A (Accumulator), X (X register), Y (Y register), S (Stack pointer), P (Processor status).",
      "references": [
        {
          "chunk": "the_stack",
          "topic": "Stack-related implied instructions (PHA/PLA/PHP/PLP)"
        },
        {
          "chunk": "lda_immediate_absolute_and_address_representation",
          "topic": "Contrasts implied mode with immediate/absolute examples"
        }
      ]
    },
    {
      "start": 11109,
      "end": 11129,
      "name": "indexed_addressing_and_indexing",
      "description": "Indexing concept: creating an actual address by adding an index register (X or Y) to a base address (e.g., LDA $9000,X yields $9000 + X). Describes absolute indexed, zero page indexed, indirect indexed and indexed indirect variants and general mnemonic syntax with ,X or ,Y.",
      "references": [
        {
          "chunk": "addressing_mode_zero_page",
          "topic": "Zero page is relevant to zero-page indexed modes"
        },
        {
          "chunk": "indirect_indexed_mode",
          "topic": "Detailed indirect-indexed (Y) example"
        },
        {
          "chunk": "indexed_indirect_mode",
          "topic": "Detailed indexed-indirect (X) example"
        }
      ]
    },
    {
      "start": 11130,
      "end": 11168,
      "name": "indirect_indexed_mode",
      "description": "Indirect indexed addressing (also called (zp),Y): uses a zero-page pointer whose low and high bytes (in consecutive zero-page locations) form the base address; the Y register is then added to that address. Example: if $02 contains low byte $45 and $03 contains high byte $1E, LDA ($02),Y with Y=$00 accesses $1E45. Includes short code example showing how to set up the pointer and use LDA ($02),Y.",
      "references": [
        {
          "chunk": "indexed_addressing_and_indexing",
          "topic": "Explains how Y is used as the index in indirect indexed mode"
        },
        {
          "chunk": "indexed_indirect_mode",
          "topic": "Compare with indexed indirect where X indexes the pointer"
        }
      ]
    },
    {
      "start": 11169,
      "end": 11235,
      "name": "indexed_indirect_mode",
      "description": "Indexed indirect addressing (also called (zp,X)): X is added to a zero-page pointer address; the zero-page location plus X gives the pointer whose two bytes hold the actual target address. Example: with $02/$03 containing pointer bytes and X=$00, LDA ($02,X) loads the indirectly pointed-to address; includes code setup and explanation. A note emphasizes that indirect-indexed (Y) is more widely used.",
      "references": [
        {
          "chunk": "indirect_indexed_mode",
          "topic": "Contrast with indirect indexed (Y) which is more common"
        },
        {
          "chunk": "indexed_addressing_and_indexing",
          "topic": "Overview of indexed addressing variants"
        }
      ]
    },
    {
      "start": 11236,
      "end": 11329,
      "name": "branches_and_testing",
      "description": "Branching and testing fundamentals: status register flags (e.g., Zero flag Z), using instructions that set/test flags (LDA #$00 sets Z), branch instructions like BEQ (branch if equal/zero) and BNE (branch if not equal), index register increment/decrement (INX/DEX, INY/DEY) behavior with wrap-around, compare instructions (CPX/CPY) to test registers/memory, and branch offset limitations (signed one-byte offset: -128..+127; assembler (64MON) helps compute offsets and warns about out-of-range branches).",
      "references": [
        {
          "chunk": "machine_code_and_registers_overview",
          "topic": "Status register and flags described among internal registers"
        },
        {
          "chunk": "subroutines_and_kernal_print",
          "topic": "Branches commonly used in control flow for subroutines and loops"
        },
        {
          "chunk": "alphabet_program_example",
          "topic": "Example loop using CPX/INX/BNE to print letters"
        }
      ]
    },
    {
      "start": 11330,
      "end": 11376,
      "name": "subroutines_and_kernal_print",
      "description": "Subroutine calls in machine language: JSR (jump to subroutine) and JMP (jump absolute). Introduction to the KERNAL jump table and the built-in KERNAL routine at $FFD2 for printing a character (expects CBM ASCII code in A). Example machine-code sequence to print \"Hi\" using LDA #$48 / JSR $FFD2 / LDA #$49 / JSR $FFD2 / LDA #$0D / JSR $FFD2 / BRK. Notes on KERNAL jump table addresses and purpose.",
      "references": [
        {
          "chunk": "branches_and_testing",
          "topic": "Subroutines are used in program control flow; branches lead to subroutine calls or loops"
        },
        {
          "chunk": "alphabet_program_example",
          "topic": "Uses the KERNAL print routine inside a loop to print the alphabet"
        }
      ]
    },
    {
      "start": 11377,
      "end": 11400,
      "name": "alphabet_program_example",
      "description": "Worked example: a small machine-language program that prints the alphabet using KERNAL print routine. Introduces TXA (transfer X to A) and shows program listing (LDX #$41; TXA; JSR $FFD2; INX; CPX #$5B; BNE $1402; BRK) and how to run it (.G 1400). Advice to write and test programs in small parts and comment code.",
      "references": [
        {
          "chunk": "subroutines_and_kernal_print",
          "topic": "Uses the KERNAL character-print routine ($FFD2) demonstrated earlier"
        },
        {
          "chunk": "branches_and_testing",
          "topic": "Uses INX, CPX, and BNE to loop until 'Z' is passed"
        },
        {
          "chunk": "writing_your_first_program_example",
          "topic": "Practical assembly and execution examples using 64MON"
        }
      ]
    },
    {
      "start": 11401,
      "end": 11500,
      "name": "indirect_indexing_branches_subroutines_and_beginner_tips",
      "description": "Explains indirect-indexed addressing with an example (LDA ($02,X)), includes a NOTE about relative usefulness of indirect addressing methods; 'BRANCHES AND TESTING' overview (status flags, BEQ/BNE, BNE loop examples), index register increment/decrement instructions (INX/DEX/INY/DEY), comparisons (CPX/CPY) and branch range/offset limits including assembler (64MON) behavior; 'SUBROUTINES' section introducing JSR, JMP and the KERNAL print-character routine at $FFD2 with example (printing 'Hi'); example program to print the alphabet using TXA, JSR $FFD2, INX, CPX, BNE; beginner tips on studying other 6510/6502 code, using utilities and the KERNAL, advantages of machine language, and advice on approaching large programming tasks with decomposition (block diagrams, module breakdown, example roulette game flow).",
      "references": [
        {
          "chunk": "mcs6510_instruction_set_part1",
          "topic": "instruction names and opcodes referenced for branching and register operations"
        },
        {
          "chunk": "kernal_routines_overview_and_list",
          "topic": "KERNAL subroutine table and detailed descriptions (CALL addresses like $FFD2)"
        }
      ]
    },
    {
      "start": 11501,
      "end": 11558,
      "name": "alphabetic_instruction_list_a_to_jmp",
      "description": "Front matter and the first half of the MCS6510 alphabetic instruction summary (mnemonics and short English descriptions) covering ADC through JMP as presented in the two-column summary list and decorative header/footer.",
      "references": [
        {
          "chunk": "alphabetic_instruction_list_jsr_to_tya",
          "topic": "continuation of the alphabetic instruction summary (JSR..TYA)"
        },
        {
          "chunk": "instruction_table_notation_and_references",
          "topic": "notation used in the instruction tables (flags, symbols, immediates)"
        }
      ]
    },
    {
      "start": 11559,
      "end": 11606,
      "name": "alphabetic_instruction_list_jsr_to_tya",
      "description": "Continuation and completion of the MCS6510 alphabetic instruction summary listing JSR, LDA, LDX, LDY, LSR, NOP, ORA, stack operations (PHA/PHP/PLA/PLP), rotates (ROL/ROR), RTI/RTS, SBC, flag set instructions (SEC/SED/SEI), store/transfer instructions (STA/STX/STY/TAX/TAY/TSX/TXA/TXS/TYA). Includes decorative borders and page header/footer.",
      "references": [
        {
          "chunk": "alphabetic_instruction_list_a_to_jmp",
          "topic": "previous part of the alphabetic instruction summary (ADC..JMP)"
        },
        {
          "chunk": "instruction_table_notation_and_references",
          "topic": "notation used in the detailed instruction tables"
        }
      ]
    },
    {
      "start": 11607,
      "end": 11658,
      "name": "instruction_table_notation_and_references",
      "description": "Notation and symbol key used throughout the instruction tables: register symbols (A, X, Y, M, P, S), transfer arrows, flag change notation (/, +, - , _, /\\, V), IMMEDIATE mode indicator (#), and the note describing the 'Ref: XX' references to the MCS6500 Programming Manual sections.",
      "references": [
        {
          "chunk": "alphabetic_instruction_list_jsr_to_tya",
          "topic": "alphabetic mnemonic summary that uses this notation"
        },
        {
          "chunk": "adc_add_with_carry_instruction",
          "topic": "first detailed instruction table that follows the notation (ADC)"
        }
      ]
    },
    {
      "start": 11659,
      "end": 11678,
      "name": "adc_add_with_carry_instruction",
      "description": "ADC \u2014 Add memory to accumulator with carry. Shows operation (A + M + C -> A, C), affected flags (N Z C I D V), reference to manual (Ref: 2.2.1), and a full addressing-mode table with opcodes, byte counts and cycle counts (Immediate, Zero Page, Zero Page,X, Absolute, Absolute,X, Absolute,Y, (Indirect,X), (Indirect),Y). Notes cycle page-boundary extra timing.",
      "references": [
        {
          "chunk": "instruction_table_notation_and_references",
          "topic": "notation used for flags and addressing modes in this table"
        },
        {
          "chunk": "and_logical_and_instruction",
          "topic": "next logical/bitwise operation instruction (AND)"
        }
      ]
    },
    {
      "start": 11679,
      "end": 11705,
      "name": "and_logical_and_instruction",
      "description": "AND \u2014 Logical AND memory with accumulator. Shows operation (A /\\ M -> A), affected flags (N Z C I D V), manual reference (Ref: 2.2.3.0), and the addressing-mode table with opcodes, byte counts and cycle counts (Immediate, Zero Page, Zero Page,X, Absolute, Absolute,X, Absolute,Y, (Indirect,X), (Indirect),Y). Includes page-boundary timing note.",
      "references": [
        {
          "chunk": "adc_add_with_carry_instruction",
          "topic": "previous arithmetic instruction (ADC)"
        },
        {
          "chunk": "asl_arithmetic_shift_left_instruction",
          "topic": "next instruction in the document (ASL)"
        }
      ]
    },
    {
      "start": 11706,
      "end": 11722,
      "name": "asl_arithmetic_shift_left_instruction",
      "description": "ASL \u2014 Arithmetic Shift Left (memory or accumulator). Shows bit diagram and operation (C <- bit7..bit0 <- 0), affected flags (N Z C I D V), manual reference (Ref: 10.2), and the addressing-mode table with opcodes, byte counts and cycles for Accumulator, Zero Page, Zero Page,X, Absolute, Absolute,X.",
      "references": [
        {
          "chunk": "and_logical_and_instruction",
          "topic": "previous logical instruction (AND)"
        },
        {
          "chunk": "bcc_branch_on_carry_clear",
          "topic": "next instruction (BCC) \u2014 start of branch instruction group"
        }
      ]
    },
    {
      "start": 11723,
      "end": 11735,
      "name": "bcc_branch_on_carry_clear",
      "description": "BCC \u2014 Branch on Carry Clear. States operation (branch on C = 0), affected flags (none changed), manual reference (Ref: 4.1.1.3), and the Relative addressing form with opcode, byte count and cycle counts. Includes timing notes for same-page and page-crossing branches.",
      "references": [
        {
          "chunk": "asl_arithmetic_shift_left_instruction",
          "topic": "preceding instruction (ASL)"
        },
        {
          "chunk": "bcs_branch_on_carry_set",
          "topic": "paired carry branch (BCS)"
        }
      ]
    },
    {
      "start": 11736,
      "end": 11752,
      "name": "bcs_branch_on_carry_set",
      "description": "BCS \u2014 Branch on Carry Set. Describes operation (branch on C = 1), flags (no change), manual reference (Ref: 4.1.1.4), and the Relative addressing form with opcode, bytes and cycle counts including timing adjustments for same-page or next-page branches.",
      "references": [
        {
          "chunk": "bcc_branch_on_carry_clear",
          "topic": "paired carry branch (BCC)"
        },
        {
          "chunk": "beq_branch_on_result_zero",
          "topic": "next branch instruction (BEQ)"
        }
      ]
    },
    {
      "start": 11753,
      "end": 11765,
      "name": "beq_branch_on_result_zero",
      "description": "BEQ \u2014 Branch on Result Zero. Describes operation (branch on Z = 1), flags (no change), manual reference (Ref: 4.1.1.5), and the Relative addressing form with opcode, bytes and cycle timing notes (same-page and page-crossing adjustments).",
      "references": [
        {
          "chunk": "bcs_branch_on_carry_set",
          "topic": "previous branch instruction (BCS)"
        },
        {
          "chunk": "bit_test_bits_instruction",
          "topic": "next table entry (BIT)"
        }
      ]
    },
    {
      "start": 11766,
      "end": 11781,
      "name": "bit_test_bits_instruction",
      "description": "BIT \u2014 Test bits in memory with accumulator. Shows operation (A /\\ M, M7 -> N, M6 -> V), describes transfer of bits 6 and 7 into N and V, effect on Z flag, manual reference (Ref: 4.2.1.1), and addressing-mode table entries for Zero Page and Absolute with opcodes, bytes and cycles.",
      "references": [
        {
          "chunk": "beq_branch_on_result_zero",
          "topic": "previous branch instruction (BEQ)"
        },
        {
          "chunk": "bmi_branch_on_result_minus",
          "topic": "next branch instruction (BMI)"
        }
      ]
    },
    {
      "start": 11782,
      "end": 11799,
      "name": "bmi_branch_on_result_minus",
      "description": "BMI \u2014 Branch on Result Minus. Describes operation (branch on N = 1), flags unchanged, manual reference (Ref: 4.1.1.1), and the Relative addressing form with opcode, bytes and cycle timing notes. Includes branch timing notes (same-page and different-page penalties).",
      "references": [
        {
          "chunk": "bit_test_bits_instruction",
          "topic": "previous table entry (BIT)"
        },
        {
          "chunk": "bne_branch_on_result_not_zero",
          "topic": "next branch instruction (BNE)"
        }
      ]
    },
    {
      "start": 11800,
      "end": 11813,
      "name": "bne_branch_on_result_not_zero",
      "description": "BNE \u2014 Branch on Result Not Zero. Describes operation (branch on Z = 0), flags unchanged, manual reference (Ref: 4.1.1.6), and the Relative addressing form with opcode, byte count and cycles; includes timing notes for same-page and page-crossing branches.",
      "references": [
        {
          "chunk": "bmi_branch_on_result_minus",
          "topic": "previous branch instruction (BMI)"
        },
        {
          "chunk": "bpl_branch_on_result_plus",
          "topic": "next branch instruction (BPL)"
        }
      ]
    },
    {
      "start": 11814,
      "end": 11827,
      "name": "bpl_branch_on_result_plus",
      "description": "BPL \u2014 Branch on Result Plus. Describes operation (branch on N = 0), flags unchanged, manual reference (Ref: 4.1.1.2), and the Relative addressing form with opcode, bytes and cycles and the usual same-page / page-crossing timing notes.",
      "references": [
        {
          "chunk": "bne_branch_on_result_not_zero",
          "topic": "previous branch instruction (BNE)"
        },
        {
          "chunk": "brk_force_break",
          "topic": "next instruction (BRK)"
        }
      ]
    },
    {
      "start": 11828,
      "end": 11846,
      "name": "brk_force_break",
      "description": "BRK \u2014 Force Break (software interrupt). Shows operation (forced interrupt, PC + 2 and processor status pushed to stack), indicates P flag bit 4 behavior, affected flags in the status mask, manual reference (Ref: 9.11), the Implied addressing form with opcode, bytes and cycle count, and the note that BRK cannot be masked by setting I.",
      "references": [
        {
          "chunk": "bpl_branch_on_result_plus",
          "topic": "previous branch instruction (BPL)"
        },
        {
          "chunk": "bvc_branch_on_overflow_clear",
          "topic": "next branch instruction (BVC)"
        }
      ]
    },
    {
      "start": 11847,
      "end": 11860,
      "name": "bvc_branch_on_overflow_clear",
      "description": "BVC \u2014 Branch on Overflow Clear. Describes operation (branch on V = 0), flags unchanged, manual reference (Ref: 4.1.1.8), and the Relative addressing form with opcode, bytes and cycle timing notes for same-page and page-crossing branches.",
      "references": [
        {
          "chunk": "brk_force_break",
          "topic": "previous instruction (BRK)"
        },
        {
          "chunk": "bvs_branch_on_overflow_set",
          "topic": "paired overflow branch (BVS)"
        }
      ]
    },
    {
      "start": 11861,
      "end": 11874,
      "name": "bvs_branch_on_overflow_set",
      "description": "BVS \u2014 Branch on Overflow Set. Describes operation (branch on V = 1), flags unchanged, manual reference (Ref: 4.1.1.7), and the Relative addressing form with opcode, byte count and cycles, including same-page and page-crossing timing notes.",
      "references": [
        {
          "chunk": "bvc_branch_on_overflow_clear",
          "topic": "paired overflow branch (BVC)"
        },
        {
          "chunk": "clc_clear_carry_flag",
          "topic": "next instruction (CLC)"
        }
      ]
    },
    {
      "start": 11875,
      "end": 11893,
      "name": "clc_clear_carry_flag",
      "description": "CLC \u2014 Clear Carry Flag. Shows operation (0 -> C), the effect on status flags (N Z C I D V), manual reference (Ref: 3.0.2), and the Implied addressing form with opcode, byte count and cycle count.",
      "references": [
        {
          "chunk": "bvs_branch_on_overflow_set",
          "topic": "previous branch instruction (BVS)"
        },
        {
          "chunk": "cld_clear_decimal_mode",
          "topic": "next flag-clear instruction (CLD)"
        }
      ]
    },
    {
      "start": 11894,
      "end": 11905,
      "name": "cld_clear_decimal_mode",
      "description": "CLD \u2014 Clear Decimal Mode. Shows operation (0 -> D), flags affected notation and manual reference (Ref: 3.3.2). Includes the Implied addressing form with opcode, bytes and cycles.",
      "references": [
        {
          "chunk": "clc_clear_carry_flag",
          "topic": "previous flag-clearing instruction (CLC)"
        },
        {
          "chunk": "cli_clear_interrupt_disable",
          "topic": "next flag-clearing instruction (CLI)"
        }
      ]
    },
    {
      "start": 11906,
      "end": 11917,
      "name": "cli_clear_interrupt_disable",
      "description": "CLI \u2014 Clear Interrupt Disable Bit. Shows operation (0 -> I), flags notation and manual reference (Ref: 3.2.2). Includes the Implied addressing form with opcode, byte count and cycles.",
      "references": [
        {
          "chunk": "cld_clear_decimal_mode",
          "topic": "previous flag-clearing instruction (CLD)"
        },
        {
          "chunk": "clv_clear_overflow_flag",
          "topic": "next flag-clearing instruction (CLV)"
        }
      ]
    },
    {
      "start": 11918,
      "end": 11940,
      "name": "clv_clear_overflow_flag",
      "description": "CLV \u2014 Clear Overflow Flag. Shows operation (0 -> V), status effect notation and manual reference (Ref: 3.6.1). Includes the Implied addressing form with opcode, bytes and cycles. This chunk also contains the following page spacing/footers before the compare instructions begin.",
      "references": [
        {
          "chunk": "cli_clear_interrupt_disable",
          "topic": "previous flag-clearing instruction (CLI)"
        },
        {
          "chunk": "cmp_compare_accumulator",
          "topic": "next group: comparison instructions (CMP)"
        }
      ]
    },
    {
      "start": 11941,
      "end": 11959,
      "name": "cmp_compare_accumulator",
      "description": "CMP \u2014 Compare Memory and Accumulator. Shows operation (A - M), affected flags (N Z C I D V), manual reference (Ref: 4.2.1), and full addressing-mode table entries with opcodes, bytes and cycle counts for Immediate, Zero Page, Zero Page,X, Absolute, Absolute,X, Absolute,Y, (Indirect,X), (Indirect),Y. Includes page-boundary timing note.",
      "references": [
        {
          "chunk": "clv_clear_overflow_flag",
          "topic": "previous flag instruction (CLV)"
        },
        {
          "chunk": "cpx_compare_index_x",
          "topic": "related compare instruction for X (CPX)"
        }
      ]
    },
    {
      "start": 11960,
      "end": 11971,
      "name": "cpx_compare_index_x",
      "description": "CPX \u2014 Compare Memory and Index X. Shows operation (X - M), flags affected (N Z C I D V), manual reference (Ref: 7.8), and addressing-mode table (Immediate, Zero Page, Absolute) with opcodes, bytes and cycle counts.",
      "references": [
        {
          "chunk": "cmp_compare_accumulator",
          "topic": "related compare instruction (CMP)"
        },
        {
          "chunk": "cpy_compare_index_y",
          "topic": "related compare instruction for Y (CPY)"
        }
      ]
    },
    {
      "start": 11972,
      "end": 11987,
      "name": "cpy_compare_index_y",
      "description": "CPY \u2014 Compare Memory and Index Y. Shows operation (Y - M), flags affected (N Z C I D V), manual reference (Ref: 7.9), and addressing-mode table (Immediate, Zero Page, Absolute) with opcodes, byte counts and cycle counts.",
      "references": [
        {
          "chunk": "cpx_compare_index_x",
          "topic": "related compare instruction (CPX)"
        },
        {
          "chunk": "dec_decrement_memory",
          "topic": "next data-modifying instruction (DEC)"
        }
      ]
    },
    {
      "start": 11988,
      "end": 12000,
      "name": "dec_decrement_memory",
      "description": "DEC \u2014 Decrement Memory by One. Shows operation (M - 1 -> M), affected flags (N Z C I D V), manual reference (Ref: 10.7), and the addressing-mode table with opcodes, bytes and cycles for Zero Page, Zero Page,X, Absolute, Absolute,X.",
      "references": [
        {
          "chunk": "cpy_compare_index_y",
          "topic": "previous compare instruction (CPY)"
        },
        {
          "chunk": "mcs6510_instruction_set_part1",
          "topic": "original larger chunk this split was created from (overview reference)"
        }
      ]
    },
    {
      "start": 12001,
      "end": 12012,
      "name": "dex_decrement_x",
      "description": "DEX \u2014 Decrement index X by one. Shows operation (X - 1 -> X), flags affected (N, Z), reference (7.6), addressing mode (Implied), opcode CA, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "dey_decrement_y",
          "topic": "decrement Y instruction (related index operation)"
        },
        {
          "chunk": "inx_increment_x",
          "topic": "increment X instruction (inverse operation)"
        },
        {
          "chunk": "ldx_load_x",
          "topic": "loading X from memory"
        },
        {
          "chunk": "tax_transfer_a_to_x",
          "topic": "transfer A to X (register transfer affecting X)"
        }
      ]
    },
    {
      "start": 12013,
      "end": 12024,
      "name": "dey_decrement_y",
      "description": "DEY \u2014 Decrement index Y by one. Shows operation (Y - 1 -> Y), flags affected (N, Z), reference (7.7), addressing mode (Implied), opcode 88, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "dex_decrement_x",
          "topic": "decrement X instruction (related index operation)"
        },
        {
          "chunk": "iny_increment_y",
          "topic": "increment Y instruction (inverse operation)"
        },
        {
          "chunk": "ldy_load_y",
          "topic": "loading Y from memory"
        },
        {
          "chunk": "tay_transfer_a_to_y",
          "topic": "transfer A to Y (register transfer affecting Y)"
        }
      ]
    },
    {
      "start": 12025,
      "end": 12052,
      "name": "eor_exclusive_or",
      "description": "EOR \u2014 Exclusive-OR memory with accumulator. Operation: A EOR M -> A. Flags affected: N, Z. Reference (2.2.3.2). Lists addressing modes (Immediate, Zero Page, Zero Page,X, Absolute, Absolute,X, Absolute,Y, (Indirect,X), (Indirect),Y) with opcodes (49,45,55,4D,5D,59,41,51), bytes and cycles; note: add 1 cycle if page boundary crossed for modes marked with *.",
      "references": [
        {
          "chunk": "ora_or_accumulator",
          "topic": "ORA (OR with accumulator), another accumulator logical operation"
        },
        {
          "chunk": "lda_load_accumulator",
          "topic": "loading accumulator (operand source/target relation)"
        },
        {
          "chunk": "sbc_subtract_with_borrow",
          "topic": "arithmetic instruction affecting accumulator and flags"
        }
      ]
    },
    {
      "start": 12053,
      "end": 12065,
      "name": "inc_increment_memory",
      "description": "INC \u2014 Increment memory by one. Operation: M + 1 -> M. Flags affected: N, Z. Reference (10.6). Addressing modes listed: Zero Page (E6, 2 bytes, 5 cycles), Zero Page,X (F6, 2 bytes, 6 cycles), Absolute (EE, 3 bytes, 6 cycles), Absolute,X (FE, 3 bytes, 7 cycles).",
      "references": [
        {
          "chunk": "inx_increment_x",
          "topic": "increment X (register increment counterpart)"
        },
        {
          "chunk": "iny_increment_y",
          "topic": "increment Y (register increment counterpart)"
        },
        {
          "chunk": "lda_load_accumulator",
          "topic": "load instructions for memory/accumulator relations"
        }
      ]
    },
    {
      "start": 12066,
      "end": 12075,
      "name": "inx_increment_x",
      "description": "INX \u2014 Increment index X by one. Operation: X + 1 -> X. Flags affected: N, Z. Reference (7.4). Addressing mode: Implied. Opcode E8, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "dex_decrement_x",
          "topic": "DEX (decrement X)"
        },
        {
          "chunk": "tax_transfer_a_to_x",
          "topic": "transfer A to X (register assignment to X)"
        },
        {
          "chunk": "ldx_load_x",
          "topic": "loading X from memory"
        }
      ]
    },
    {
      "start": 12076,
      "end": 12091,
      "name": "iny_increment_y",
      "description": "INY \u2014 Increment index Y by one. Operation: Y + 1 -> Y. Flags affected: N, Z. Reference (7.5). Addressing mode: Implied. Opcode C8, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "dey_decrement_y",
          "topic": "DEY (decrement Y)"
        },
        {
          "chunk": "tay_transfer_a_to_y",
          "topic": "transfer A to Y (register assignment to Y)"
        },
        {
          "chunk": "ldy_load_y",
          "topic": "loading Y from memory"
        }
      ]
    },
    {
      "start": 12092,
      "end": 12104,
      "name": "jmp_jump",
      "description": "JMP \u2014 Jump to new location. Operation: (PC + 1) -> PCL, (PC + 2) -> PCH. References (4.0.2) and (9.8.1). Addressing modes: Absolute (JMP Oper, opcode 4C, 3 bytes, 3 cycles) and Indirect (JMP (Oper), opcode 6C, 3 bytes, 5 cycles).",
      "references": [
        {
          "chunk": "jsr_jump_save_return",
          "topic": "JSR (call subroutine) \u2014 related control-flow instruction"
        },
        {
          "chunk": "rts_return_subroutine",
          "topic": "RTS (return from subroutine) \u2014 return counterpart"
        },
        {
          "chunk": "rti_return_interrupt",
          "topic": "RTI (return from interrupt) \u2014 related control flow for interrupts"
        }
      ]
    },
    {
      "start": 12105,
      "end": 12116,
      "name": "jsr_jump_save_return",
      "description": "JSR \u2014 Jump to new location saving return address. Operation: PC + 2 to stack, (PC + 1) -> PCL, (PC + 2) -> PCH. Reference (8.1). Addressing mode: Absolute. Opcode 20, size 3 bytes, 6 cycles.",
      "references": [
        {
          "chunk": "jmp_jump",
          "topic": "JMP (unconditional jump without saving return address)"
        },
        {
          "chunk": "rts_return_subroutine",
          "topic": "RTS (return from subroutine) \u2014 returns from JSR"
        }
      ]
    },
    {
      "start": 12117,
      "end": 12146,
      "name": "lda_load_accumulator",
      "description": "LDA \u2014 Load accumulator with memory. Operation: M -> A. Flags affected: N, Z. Reference (2.1.1). Addressing modes and opcodes: Immediate A9 (2 bytes, 2 cycles), Zero Page A5 (2 bytes, 3 cycles), Zero Page,X B5 (2,4), Absolute AD (3,4), Absolute,X BD (3,4*), Absolute,Y B9 (3,4*), (Indirect,X) A1 (2,6), (Indirect),Y B1 (2,5*). Note: add 1 cycle if page boundary crossed for modes marked *.",
      "references": [
        {
          "chunk": "ora_or_accumulator",
          "topic": "ORA (logical OR with accumulator) \u2014 logical operation set"
        },
        {
          "chunk": "eor_exclusive_or",
          "topic": "EOR (exclusive OR) \u2014 logical operation with accumulator"
        },
        {
          "chunk": "sta_store_accumulator",
          "topic": "STA (store accumulator) \u2014 writes A to memory"
        }
      ]
    },
    {
      "start": 12147,
      "end": 12163,
      "name": "ldx_load_x",
      "description": "LDX \u2014 Load index X with memory. Operation: M -> X. Flags affected: N, Z. Reference (7.0). Addressing modes and opcodes: Immediate A2 (2 bytes, 2 cycles), Zero Page A6 (2,3), Zero Page,Y B6 (2,4), Absolute AE (3,4), Absolute,Y BE (3,4*). Note: add 1 when page boundary is crossed for marked modes.",
      "references": [
        {
          "chunk": "ldy_load_y",
          "topic": "LDY (load Y) \u2014 companion index load"
        },
        {
          "chunk": "stx_store_x",
          "topic": "STX (store X) \u2014 stores X to memory"
        },
        {
          "chunk": "tax_transfer_a_to_x",
          "topic": "TAX (transfer A to X) \u2014 register transfer affecting X"
        }
      ]
    },
    {
      "start": 12164,
      "end": 12189,
      "name": "ldy_load_y",
      "description": "LDY \u2014 Load index Y with memory. Operation: M -> Y. Flags affected: N, Z. Reference (7.1). Addressing modes and opcodes: Immediate A0 (2 bytes, 2 cycles), Zero Page A4 (2,3), Zero Page,X B4 (2,4), Absolute AC (3,4), Absolute,X BC (3,4*). Note: add 1 when page boundary is crossed for marked modes.",
      "references": [
        {
          "chunk": "ldx_load_x",
          "topic": "LDX (load X) \u2014 companion index load"
        },
        {
          "chunk": "sty_store_y",
          "topic": "STY (store Y) \u2014 stores Y to memory"
        },
        {
          "chunk": "tay_transfer_a_to_y",
          "topic": "TAY (transfer A to Y) \u2014 register transfer affecting Y"
        }
      ]
    },
    {
      "start": 12190,
      "end": 12206,
      "name": "lsr_logical_shift_right",
      "description": "LSR \u2014 Logical shift right one bit (memory or accumulator). Operation: 0 -> bit7..bit0 -> C. Flags affected: N (cleared), Z, C. Reference (10.1). Addressing modes: Accumulator (LSR A, opcode 4A, 1 byte, 2 cycles), Zero Page 46 (2 bytes, 5 cycles), Zero Page,X 56 (2,6), Absolute 4E (3,6), Absolute,X 5E (3,7).",
      "references": [
        {
          "chunk": "rol_rotate_left",
          "topic": "ROL (rotate left) \u2014 related bit-rotation instruction"
        },
        {
          "chunk": "ror_rotate_right",
          "topic": "ROR (rotate right) \u2014 related bit-rotation instruction"
        }
      ]
    },
    {
      "start": 12207,
      "end": 12217,
      "name": "nop_no_operation",
      "description": "NOP \u2014 No operation (2 cycles). No flags affected. Addressing mode: Implied. Opcode EA, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "rti_return_interrupt",
          "topic": "RTI (interrupt return) \u2014 control flow/interrupt related"
        },
        {
          "chunk": "jsr_jump_save_return",
          "topic": "JSR (subroutine call) \u2014 related control-flow instruction"
        }
      ]
    },
    {
      "start": 12218,
      "end": 12240,
      "name": "ora_or_accumulator",
      "description": "ORA \u2014 OR memory with accumulator. Operation: A OR M -> A. Flags affected: N, Z. Reference (2.2.3.1). Addressing modes and opcodes: Immediate 09 (2 bytes, 2 cycles), Zero Page 05 (2,3), Zero Page,X 15 (2,4), Absolute 0D (3,4), Absolute,X 1D (3,4*), Absolute,Y 19 (3,4*), (Indirect,X) 01 (2,6), (Indirect),Y 11 (2,5). Note: add 1 cycle on page crossing where marked.",
      "references": [
        {
          "chunk": "eor_exclusive_or",
          "topic": "EOR (exclusive OR) \u2014 another accumulator logical op"
        },
        {
          "chunk": "lda_load_accumulator",
          "topic": "LDA (load accumulator) \u2014 accumulator load/store relations"
        },
        {
          "chunk": "sta_store_accumulator",
          "topic": "STA (store accumulator) \u2014 storing A to memory"
        }
      ]
    },
    {
      "start": 12241,
      "end": 12252,
      "name": "pha_push_accumulator",
      "description": "PHA \u2014 Push accumulator on stack. Operation: A to Stack. No flags affected. Reference (8.5). Addressing mode: Implied. Opcode 48, size 1 byte, 3 cycles.",
      "references": [
        {
          "chunk": "pla_pull_accumulator",
          "topic": "PLA (pull accumulator) \u2014 counterpart that pops A from stack"
        },
        {
          "chunk": "php_push_processor_status",
          "topic": "PHP (push processor status) \u2014 other stack push"
        },
        {
          "chunk": "plp_pull_processor_status",
          "topic": "PLP (pull processor status) \u2014 stack status pull"
        }
      ]
    },
    {
      "start": 12253,
      "end": 12264,
      "name": "php_push_processor_status",
      "description": "PHP \u2014 Push processor status on stack. Operation: P to Stack. No flags affected. Reference (8.11). Addressing mode: Implied. Opcode 08, size 1 byte, 3 cycles.",
      "references": [
        {
          "chunk": "plp_pull_processor_status",
          "topic": "PLP (pull processor status) \u2014 restores status from stack"
        },
        {
          "chunk": "pha_push_accumulator",
          "topic": "PHA (push accumulator) \u2014 other stack operation"
        }
      ]
    },
    {
      "start": 12265,
      "end": 12278,
      "name": "pla_pull_accumulator",
      "description": "PLA \u2014 Pull accumulator from stack. Operation: A from Stack. Flags affected: N, Z (set based on result). Reference (8.6). Addressing mode: Implied. Opcode 68, size 1 byte, 4 cycles.",
      "references": [
        {
          "chunk": "pha_push_accumulator",
          "topic": "PHA (push accumulator) \u2014 counterpart that pushed A"
        },
        {
          "chunk": "plp_pull_processor_status",
          "topic": "PLP (pull processor status) \u2014 related stack pull"
        }
      ]
    },
    {
      "start": 12279,
      "end": 12290,
      "name": "plp_pull_processor_status",
      "description": "PLP \u2014 Pull processor status from stack. Operation: P from Stack. Flags restored from stack. Reference (8.12). Addressing mode: Implied. Opcode 28, size 1 byte, 4 cycles.",
      "references": [
        {
          "chunk": "php_push_processor_status",
          "topic": "PHP (push processor status) \u2014 counterpart that pushed P"
        },
        {
          "chunk": "rti_return_interrupt",
          "topic": "RTI (return from interrupt) \u2014 also restores P from stack during interrupt return"
        }
      ]
    },
    {
      "start": 12291,
      "end": 12310,
      "name": "rol_rotate_left",
      "description": "ROL \u2014 Rotate one bit left (memory or accumulator). Operation: M or A rotated left through Carry (bit7 -> Carry, Carry -> bit0). Flags affected: N, Z, C. Reference (10.3). Addressing modes: Accumulator 2A (1 byte, 2 cycles), Zero Page 26 (2 bytes, 5 cycles), Zero Page,X 36 (2,6), Absolute 2E (3,6), Absolute,X 3E (3,7).",
      "references": [
        {
          "chunk": "ror_rotate_right",
          "topic": "ROR (rotate right) \u2014 related rotate instruction"
        },
        {
          "chunk": "lsr_logical_shift_right",
          "topic": "LSR (logical shift right) \u2014 related bit shift/rotation ops"
        }
      ]
    },
    {
      "start": 12311,
      "end": 12336,
      "name": "ror_rotate_right",
      "description": "ROR \u2014 Rotate one bit right (memory or accumulator). Operation: Rotate right through Carry (Carry -> bit7, bit0 -> Carry). Flags affected: N, Z, C. Reference (10.4). Addressing modes: Accumulator 6A (1 byte, 2 cycles), Zero Page 66 (2 bytes, 5 cycles), Zero Page,X 76 (2,6), Absolute 6E (3,6), Absolute,X 7E (3,7). Note: ROR instruction available on MCS650X microprocessors after June 1976.",
      "references": [
        {
          "chunk": "rol_rotate_left",
          "topic": "ROL (rotate left) \u2014 complementary rotate operation"
        },
        {
          "chunk": "lsr_logical_shift_right",
          "topic": "LSR (logical shift right) \u2014 related bit-manipulation"
        }
      ]
    },
    {
      "start": 12337,
      "end": 12347,
      "name": "rti_return_interrupt",
      "description": "RTI \u2014 Return from interrupt. Operation: Pull processor status P from stack and PC from stack. Flags and PC restored from stack. Reference (9.6). Addressing mode: Implied. Opcode 40, size 1 byte, 6 cycles (note: opcode shown as 4D in source but documented behavior is RTI).",
      "references": [
        {
          "chunk": "plp_pull_processor_status",
          "topic": "PLP \u2014 also pulls status from stack"
        },
        {
          "chunk": "sei_set_interrupt_disable",
          "topic": "SEI \u2014 sets I flag affecting interrupts"
        },
        {
          "chunk": "rts_return_subroutine",
          "topic": "RTS \u2014 return from subroutine (control-flow return)"
        }
      ]
    },
    {
      "start": 12348,
      "end": 12358,
      "name": "rts_return_subroutine",
      "description": "RTS \u2014 Return from subroutine. Operation: Pull PC from stack, then PC + 1 -> PC. Addressing mode: Implied. Opcode 60, size 1 byte, 6 cycles. Reference (8.2).",
      "references": [
        {
          "chunk": "jsr_jump_save_return",
          "topic": "JSR \u2014 the call instruction that pairs with RTS"
        },
        {
          "chunk": "jmp_jump",
          "topic": "JMP \u2014 unconditional jump (control-flow relation)"
        }
      ]
    },
    {
      "start": 12359,
      "end": 12381,
      "name": "sbc_subtract_with_borrow",
      "description": "SBC \u2014 Subtract memory from accumulator with borrow. Operation: A - M - C -> A. Flags affected: N, Z, C, V. Note: C is borrow (see 2.2.2). Addressing modes: Immediate E9 (2 bytes, 2 cycles), Zero Page E5 (2,3), Zero Page,X F5 (2,4), Absolute ED (3,4), Absolute,X FD (3,4*), Absolute,Y F9 (3,4*), (Indirect,X) E1 (2,6), (Indirect),Y F1 (2,5). Note: add 1 cycle when page boundary is crossed for marked modes.",
      "references": [
        {
          "chunk": "sec_set_carry",
          "topic": "SEC \u2014 sets carry flag used by SBC (borrow semantics)"
        },
        {
          "chunk": "lda_load_accumulator",
          "topic": "LDA \u2014 accumulator load operations"
        }
      ]
    },
    {
      "start": 12382,
      "end": 12393,
      "name": "sec_set_carry",
      "description": "SEC \u2014 Set carry flag. Operation: 1 -> C. Flags updated: Carry set. Reference (3.0.1). Addressing mode: Implied. Opcode 38, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "sbc_subtract_with_borrow",
          "topic": "SBC \u2014 carry/borrow interaction"
        },
        {
          "chunk": "sed_set_decimal",
          "topic": "SED \u2014 other status flag setting instruction"
        },
        {
          "chunk": "sei_set_interrupt_disable",
          "topic": "SEI \u2014 related flag-set instruction"
        }
      ]
    },
    {
      "start": 12394,
      "end": 12404,
      "name": "sed_set_decimal",
      "description": "SED \u2014 Set decimal mode. Operation: 1 -> D. Flags affected: Decimal flag set. Reference (3.3.1). Addressing mode: Implied. Opcode F8, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "sec_set_carry",
          "topic": "SEC \u2014 another single-flag set instruction"
        },
        {
          "chunk": "sei_set_interrupt_disable",
          "topic": "SEI \u2014 related status modification instruction"
        }
      ]
    },
    {
      "start": 12405,
      "end": 12419,
      "name": "sei_set_interrupt_disable",
      "description": "SEI \u2014 Set interrupt disable status. Operation: 1 -> I. Flags affected: Interrupt Disable set. Reference (3.2.1). Addressing mode: Implied. Opcode 78, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "rti_return_interrupt",
          "topic": "RTI \u2014 return from interrupt behavior interacts with I flag"
        },
        {
          "chunk": "sed_set_decimal",
          "topic": "SED \u2014 other flag-setting instruction"
        }
      ]
    },
    {
      "start": 12420,
      "end": 12437,
      "name": "sta_store_accumulator",
      "description": "STA \u2014 Store accumulator in memory. Operation: A -> M. No flags affected. Reference (2.1.2). Addressing modes and opcodes: Zero Page 85 (2 bytes, 3 cycles), Zero Page,X 95 (2,4), Absolute 8D (3,4), Absolute,X 9D (3,5), Absolute,Y 99 (3,5), (Indirect,X) 81 (2,6), (Indirect),Y 91 (2,6).",
      "references": [
        {
          "chunk": "lda_load_accumulator",
          "topic": "LDA \u2014 loading A (complementary to storing A)"
        },
        {
          "chunk": "stx_store_x",
          "topic": "STX \u2014 storing X (related store operations)"
        },
        {
          "chunk": "sty_store_y",
          "topic": "STY \u2014 storing Y (related store operations)"
        }
      ]
    },
    {
      "start": 12438,
      "end": 12451,
      "name": "stx_store_x",
      "description": "STX \u2014 Store index X in memory. Operation: X -> M. No flags affected. Reference (7.2). Addressing modes: Zero Page 86 (2 bytes, 3 cycles), Zero Page,Y 96 (2,4), Absolute 8E (3,4).",
      "references": [
        {
          "chunk": "sty_store_y",
          "topic": "STY (store Y) \u2014 related store operation"
        },
        {
          "chunk": "sta_store_accumulator",
          "topic": "STA (store A) \u2014 related store operation"
        },
        {
          "chunk": "ldx_load_x",
          "topic": "LDX (load X) \u2014 load/store relation for X"
        }
      ]
    },
    {
      "start": 12452,
      "end": 12469,
      "name": "sty_store_y",
      "description": "STY \u2014 Store index Y in memory. Operation: Y -> M. No flags affected. Reference (7.3). Addressing modes: Zero Page 84 (2 bytes, 3 cycles), Zero Page,X 94 (2,4), Absolute 8C (3,4).",
      "references": [
        {
          "chunk": "stx_store_x",
          "topic": "STX (store X) \u2014 related store operation"
        },
        {
          "chunk": "sta_store_accumulator",
          "topic": "STA (store A) \u2014 related store operation"
        },
        {
          "chunk": "ldy_load_y",
          "topic": "LDY (load Y) \u2014 load/store relation for Y"
        }
      ]
    },
    {
      "start": 12470,
      "end": 12481,
      "name": "tax_transfer_a_to_x",
      "description": "TAX \u2014 Transfer accumulator to index X. Operation: A -> X. Flags affected: N, Z. Reference (7.11). Addressing mode: Implied. Opcode AA, size 1 byte, 2 cycles.",
      "references": [
        {
          "chunk": "tay_transfer_a_to_y",
          "topic": "TAY (transfer A to Y) \u2014 similar register transfer"
        },
        {
          "chunk": "ldx_load_x",
          "topic": "LDX (load X) \u2014 X register source/target relations"
        },
        {
          "chunk": "dex_decrement_x",
          "topic": "DEX (decrement X) \u2014 operations affecting X register"
        }
      ]
    },
    {
      "start": 12482,
      "end": 12500,
      "name": "tay_transfer_a_to_y",
      "description": "TAY \u2014 Transfer accumulator to index Y. Operation: A -> Y. Flags affected: N, Z. Reference (7.13). Addressing mode: Implied. Opcode A8, size 1 byte, 2 cycles. (Includes trailing blank lines from source.)",
      "references": [
        {
          "chunk": "tax_transfer_a_to_x",
          "topic": "TAX (transfer A to X) \u2014 similar register transfer"
        },
        {
          "chunk": "ldy_load_y",
          "topic": "LDY (load Y) \u2014 Y register load relation"
        },
        {
          "chunk": "dey_decrement_y",
          "topic": "DEY (decrement Y) \u2014 operations affecting Y register"
        }
      ]
    },
    {
      "start": 12501,
      "end": 12545,
      "name": "transfer_instructions_tsx_txa_txs_tya",
      "description": "Documentation for the four 6502 transfer instructions TSX, TXA, TXS and TYA: operation (source -> destination), affected flags, reference numbers, assembly syntax, opcode bytes, instruction lengths and cycle counts.",
      "references": [
        {
          "chunk": "instruction_addressing_modes_and_timing_table",
          "topic": "timing conventions and addressing-mode cycle additions (page-cross/branch penalties) that apply to these and other instructions"
        },
        {
          "chunk": "opcode_hex_maps_00_to_FF",
          "topic": "opcode lookup (hex-to-mnemonic) showing the opcode bytes for these instructions"
        }
      ]
    },
    {
      "start": 12546,
      "end": 12641,
      "name": "instruction_addressing_modes_and_timing_table",
      "description": "Comprehensive instruction addressing-modes table and related execution times (clock cycles) for the 6502: lists accumulator, immediate, zero page, zero page,X/Y, absolute, absolute,X/Y, implied, relative, (indirect,X), (indirect),Y and absolute-indirect timings for many instruction classes, with footnotes explaining page-cross and branch-taken penalties.",
      "references": [
        {
          "chunk": "transfer_instructions_tsx_txa_txs_tya",
          "topic": "examples of implied-mode transfers whose timings are listed in the table"
        },
        {
          "chunk": "opcode_hex_maps_00_to_FF",
          "topic": "use the opcode map to find concrete opcodes for the instruction classes shown in the timing table"
        }
      ]
    },
    {
      "start": 12642,
      "end": 12680,
      "name": "opcode_map_00_1f_and_20_3f",
      "description": "Hex opcode map for 6502 ranges $00-$1F and $20-$3F. Lists each opcode in these ranges with its mnemonic and addressing mode, including BRK, JSR, ORA/AND variants (Indirect,X and Immediate), BIT (Zero Page/Absolute), ASL/ROL (Zero Page/Absolute/Accumulator), branch BPL/BMI, stack ops PHP/PLP, flag ops CLC/SEC, and placeholders marked 'Future Expansion' for unused opcodes.",
      "references": [
        {
          "chunk": "opcode_map_40_5f_and_60_7f",
          "topic": "Next paired opcode ranges $40-$5F and $60-$7F (EOR/ADC/LSR/ROR/JMP/branch and related instructions)"
        },
        {
          "chunk": "opcode_map_80_9f_and_a0_bf",
          "topic": "Later opcode pairs $80-$9F and $A0-$BF (store/load/index/transfer and branch groups)"
        },
        {
          "chunk": "opcode_map_c0_df_and_e0_ff",
          "topic": "Remaining opcode pairs $C0-$DF and $E0-$FF (compare, increment/decrement, SBC, CPX/CPY, and branches)"
        }
      ]
    },
    {
      "start": 12681,
      "end": 12727,
      "name": "opcode_map_40_5f_and_60_7f",
      "description": "Hex opcode map for 6502 ranges $40-$5F and $60-$7F. Covers RTI/RTS, EOR/ADC variants with (Indirect,X)/(Indirect),Y addressing, EOR/ADC immediate/absolute/zero-page forms, LSR/ROR (Zero Page/Absolute/Accumulator), stack ops PHA/PLA, JMP absolute/indirect, branch BVC/BVS and BCC/BCS groups, interrupt/flag ops CLI/SEI, and 'Future Expansion' placeholders where opcodes are unused.",
      "references": [
        {
          "chunk": "opcode_map_00_1f_and_20_3f",
          "topic": "Previous opcode pairs $00-$1F and $20-$3F (BRK/JSR, ORA/AND, ASL/ROL, BIT, branches)"
        },
        {
          "chunk": "opcode_map_80_9f_and_a0_bf",
          "topic": "Subsequent opcode pairs $80-$9F and $A0-$BF (store/load/index/transfer and branch groups)"
        },
        {
          "chunk": "opcode_map_c0_df_and_e0_ff",
          "topic": "Remaining opcode pairs $C0-$DF and $E0-$FF (compare, inc/dec, SBC, CPX/CPY, branches)"
        }
      ]
    },
    {
      "start": 12728,
      "end": 12774,
      "name": "opcode_map_80_9f_and_a0_bf",
      "description": "Hex opcode map for 6502 ranges $80-$9F and $A0-$BF. Shows store/load instructions (STA/STY/STX) for Zero Page and Absolute addressing, LDY/LDA/LDX immediate and indexed forms, transfer ops (TAX/TA X/TYA/T XS), stack/index flag ops (DEY/TAY/TXA/TAX/TXS/TSX), branch BCC/BCS, zero-page,X and absolute,X/Y variants, and 'Future Expansion' placeholders for unused opcodes.",
      "references": [
        {
          "chunk": "opcode_map_00_1f_and_20_3f",
          "topic": "Earlier opcode pairs $00-$1F and $20-$3F (BRK/JSR, ORA/AND, ASL/ROL, BIT, branches)"
        },
        {
          "chunk": "opcode_map_40_5f_and_60_7f",
          "topic": "Prior opcode pairs $40-$5F and $60-$7F (EOR/ADC, LSR/ROR, JMP, stack ops, branches)"
        },
        {
          "chunk": "opcode_map_c0_df_and_e0_ff",
          "topic": "Following opcode pairs $C0-$DF and $E0-$FF (CMP/CPY/INC/DEC/SBC and branch groups)"
        }
      ]
    },
    {
      "start": 12775,
      "end": 12821,
      "name": "opcode_map_c0_df_and_e0_ff",
      "description": "Hex opcode map for 6502 ranges $C0-$DF and $E0-$FF. Lists compare and arithmetic-related opcodes: CPY/CPX/CMP (Immediate/Zero Page/Absolute), DEC/INC (Zero Page/Absolute and indexed variants), INX/INY/DEX, SBC (Immediate/Zero Page/Absolute and indexed), branch BNE/BEQ and other branch forms, flag ops CLD/SED, NOP, and 'Future Expansion' placeholders where opcodes are unused.",
      "references": [
        {
          "chunk": "opcode_map_00_1f_and_20_3f",
          "topic": "Complementary opcode map $00-$1F and $20-$3F (control, logical, shift, branch instructions)"
        },
        {
          "chunk": "opcode_map_40_5f_and_60_7f",
          "topic": "Complementary opcode map $40-$5F and $60-$7F (EOR/ADC families, shifts, JMP, stack ops)"
        },
        {
          "chunk": "opcode_map_80_9f_and_a0_bf",
          "topic": "Complementary opcode map $80-$9F and $A0-$BF (loads/stores, transfers, branch groups)"
        }
      ]
    },
    {
      "start": 12822,
      "end": 12919,
      "name": "6510_io_port_control_and_memory_banking",
      "description": "Explanation of the Commodore 64 6510 CPU I/O port used for memory configuration: location of the port and data-direction register, bit-by-bit definitions (LORAM, HIRAM, CHAREN, cassette lines), recommended data-direction register value (bits 5..0 = 1 0 1 1 1 1 = decimal 47), and descriptions of how LORAM/HIRAM/CHAREN bank BASIC, KERNAL, character ROM and I/O in and out. Includes the note about writes to ROM locations storing data in underlying RAM.",
      "references": [
        {
          "chunk": "fundamental_memory_map_io_breakdown_and_cartridge_autostart_and_memory_maps_intro",
          "topic": "shows the physical memory regions and the I/O area whose appearance is controlled by the 6510 port"
        }
      ]
    },
    {
      "start": 12920,
      "end": 13000,
      "name": "fundamental_memory_map_io_breakdown_and_cartridge_autostart_and_memory_maps_intro",
      "description": "Commodore 64 fundamental memory map (ASCII diagram of RAM/ROM/I/O regions), I/O area breakdown (addresses and devices: VIC, SID, Color RAM, CIA1/2, open I/O slots), notes on expansion cartridge auto-start signature (required vectors and 'CBM' signature bytes), and the introduction to the various C64 memory configurations and control-line columns (leads into the memory-maps table).",
      "references": [
        {
          "chunk": "6510_io_port_control_and_memory_banking",
          "topic": "describes the port bits (/LORAM, /HIRAM, /CHAREN) whose states select the memory configurations listed here"
        }
      ]
    },
    {
      "start": 13001,
      "end": 13063,
      "name": "memory_map_table_and_ultimax_behavior",
      "description": "Shows the Commodore 64 memory map table (address ranges F000..0000) with configuration columns and the Ultimax note. Includes the statement that /LORAM and /HIRAM have no effect in Ultimax mode, the layout of ROM/BASIC/IO/ RAM per bank configuration, and the note that internal memory does not respond to write accesses in certain ROM areas.",
      "references": [
        {
          "chunk": "memory_map_legend_and_address_space_definitions",
          "topic": "Legend and definitions for the symbols used in the memory map"
        },
        {
          "chunk": "memory_map_configuration_explanations",
          "topic": "Explanations of the numbered memory maps (1)-(9) referenced in the table"
        }
      ]
    },
    {
      "start": 13064,
      "end": 13103,
      "name": "memory_map_legend_and_address_space_definitions",
      "description": "Legend entries that explain shorthand used in the memory map: definitions of Kernal (E000-FFFF), IO/C, IO/RAM, I/O, BASIC (A000-BFFF), ROMH (A000-BFFF or E000-FFFF), ROML (8000-9FFF), RAM, and '-' open address space behavior (1000-7FFF and A000-CFFF where internal memory does not detect accesses except VIC-II DMA/refresh).",
      "references": [
        {
          "chunk": "memory_map_table_and_ultimax_behavior",
          "topic": "Memory map table that uses these legend terms"
        },
        {
          "chunk": "memory_map_configuration_explanations",
          "topic": "Detailed descriptions of each memory configuration (1)-(9)"
        }
      ]
    },
    {
      "start": 13104,
      "end": 13153,
      "name": "memory_map_configuration_explanations",
      "description": "Detailed explanations of the numbered memory maps (1) through (9): what each configuration provides (default BASIC map, 60K RAM map, character ROM accessibility, softload languages map, full 64K RAM map, BASIC expansion ROM map, ROM-based app maps, and ULTIMAX video game memory map with note about expansion RAM access).",
      "references": [
        {
          "chunk": "memory_map_table_and_ultimax_behavior",
          "topic": "The table that the numbers annotate"
        },
        {
          "chunk": "memory_map_legend_and_address_space_definitions",
          "topic": "Definitions used in the explanations"
        }
      ]
    },
    {
      "start": 13154,
      "end": 13264,
      "name": "kernal_overview_and_jump_table_purpose",
      "description": "Introduction to the KERNAL: rationale for a jump-table based OS interface to insulate machine language programs from ROM changes, definition of the KERNAL as the Commodore 64 operating system controlling I/O and memory management, and explanation of the KERNAL jump table's role and general use (setting parameters, JSR to table entry, returning control).",
      "references": [
        {
          "chunk": "kernal_power_up_initialization_steps",
          "topic": "What the KERNAL does on power-up (initialization steps)"
        },
        {
          "chunk": "using_kernal_routines_and_calling_conventions",
          "topic": "How to prepare for and call KERNAL routines"
        }
      ]
    },
    {
      "start": 13265,
      "end": 13290,
      "name": "kernal_power_up_initialization_steps",
      "description": "Lists the KERNAL power-up activities: reset stack pointer and clear decimal mode; check for autostart ROM at $8000 and transfer control if present; initialize I/O devices (serial bus, CIAs, 60-Hz timer, SID, select BASIC map, switch off cassette motor); perform non-destructive RAM test to set top/bottom of memory and initialize page zero/tape buffer; set I/O vectors, establish indirect jump table, clear screen, reset screen editor variables and start BASIC via indirect at $A000.",
      "references": [
        {
          "chunk": "kernal_overview_and_jump_table_purpose",
          "topic": "Overall KERNAL purpose and how the jump table is used after initialization"
        },
        {
          "chunk": "using_kernal_routines_and_calling_conventions",
          "topic": "How to call KERNAL routines after system initialization"
        }
      ]
    },
    {
      "start": 13291,
      "end": 13336,
      "name": "using_kernal_routines_and_calling_conventions",
      "description": "Guidance on using KERNAL routines in machine language programs: prepare parameters as required, call routines via JSR (they are SUBROUTINES ending with RTS), handle returned values and error codes (carry flag and accumulator), and a summary three-step process: 1) Set up, 2) Call the routine, 3) Error handling.",
      "references": [
        {
          "chunk": "kernal_overview_and_jump_table_purpose",
          "topic": "Why use the KERNAL jump table instead of JSRing directly to ROM routines"
        },
        {
          "chunk": "kernal_routine_documentation_conventions_and_routine_list_intro",
          "topic": "Conventions used to document each KERNAL routine and the routine list"
        }
      ]
    },
    {
      "start": 13337,
      "end": 13383,
      "name": "kernal_routine_documentation_conventions_and_routine_list_intro",
      "description": "Documentation conventions for KERNAL routines: entries include FUNCTION NAME, CALL ADDRESS (hex), COMMUNICATION REGISTERS, PREPARATORY ROUTINES, ERROR RETURNS (carry set and accumulator contains error number), STACK REQUIREMENTS, REGISTERS AFFECTED, and DESCRIPTION. Ends with a lead-in sentence: 'The list of the KERNAL routines follows.'",
      "references": [
        {
          "chunk": "using_kernal_routines_and_calling_conventions",
          "topic": "How the documented conventions map to practical use when calling routines"
        },
        {
          "chunk": "user_callable_kernal_routines_table_part1",
          "topic": "Start of the user-callable KERNAL routine table that follows these conventions"
        }
      ]
    },
    {
      "start": 13384,
      "end": 13424,
      "name": "user_callable_kernal_routines_table_part1",
      "description": "First part of the 'USER CALLABLE KERNAL ROUTINES' table, listing routine names, their HEX and decimal addresses, and brief functions: ACPTR ($FFA5), CHKIN ($FFC6), CHKOUT ($FFC9), CHRIN ($FFCF), CHROUT ($FFD2), CIOUT ($FFA8), CINT ($FF81), CLALL ($FFE7), CLOSE ($FFC3), CLRCHN ($FFCC), GETIN ($FFE4), IOBASE ($FFF3), IOINIT ($FF84), LISTEN ($FFB1), LOAD ($FFD5), MEMBOT ($FF9C), MEMTOP ($FF99), OPEN ($FFC0).",
      "references": [
        {
          "chunk": "kernal_routine_documentation_conventions_and_routine_list_intro",
          "topic": "Conventions that describe how each of these table entries will be documented"
        },
        {
          "chunk": "user_callable_kernal_routines_table_part2",
          "topic": "Continuation of the routine table with additional KERNAL functions"
        },
        {
          "chunk": "kernal_routine_acptr_entry",
          "topic": "Detailed entry for the ACPTR routine listed here"
        }
      ]
    },
    {
      "start": 13425,
      "end": 13472,
      "name": "user_callable_kernal_routines_table_part2",
      "description": "Second part of the 'USER CALLABLE KERNAL ROUTINES' table continuing the list of routines with addresses and short functions: PLOT ($FFF0), RAMTAS ($FF87), RDTIM ($FFDE), READST ($FFB7), RESTOR ($FF8A), SAVE ($FFD8), SCNKEY ($FF9F), SCREEN ($FFED), SECOND ($FF93), SETLFS ($FFBA), SETMSG ($FF90), SETNAM ($FFBD), SETTIM ($FFDB), SETTMO ($FFA2), STOP ($FFE1), TALK ($FFB4), TKSA ($FF96), UDTIM ($FFEA), UNLSN ($FFAE), UNTLK ($FFAB), VECTOR ($FF8D).",
      "references": [
        {
          "chunk": "user_callable_kernal_routines_table_part1",
          "topic": "Preceding portion of the KERNAL routine table"
        },
        {
          "chunk": "kernal_routine_documentation_conventions_and_routine_list_intro",
          "topic": "Conventions describing the fuller routine entries"
        }
      ]
    },
    {
      "start": 13473,
      "end": 13500,
      "name": "kernal_routine_acptr_entry",
      "description": "Detailed KERNAL routine entry B-1: ACPTR. Purpose: get data from the serial bus. Call address $FFA5 (hex) / 65445 (decimal). Communication register: A. Preparatory routines: TALK, TKSA. Error returns: see READST. Stack requirements: 13. Registers affected: A, X.",
      "references": [
        {
          "chunk": "user_callable_kernal_routines_table_part1",
          "topic": "ACPTR is the first routine listed in the user-callable KERNAL routines table"
        },
        {
          "chunk": "kernal_routine_documentation_conventions_and_routine_list_intro",
          "topic": "Conventions that define the fields present in this routine's entry (FUNCTION NAME, CALL ADDRESS, etc.)"
        },
        {
          "chunk": "user_callable_kernal_routines_table_part2",
          "topic": "Other user-callable KERNAL routines for serial, I/O and timing"
        }
      ]
    },
    {
      "start": 13501,
      "end": 13538,
      "name": "acptr_get_byte_from_serial_bus_full_handshake",
      "description": "Describes the ACPTR routine to read one byte from a device on the serial bus using full handshaking. Covers behavior (returns byte in A), preparatory calls required (TALK, TKSA if a secondary address is needed), error reporting via the status word (READST used to read status), a short usage sequence, and a short example showing JSR ACPTR and STA DATA.",
      "references": [
        {
          "chunk": "chkin_open_input_channel",
          "topic": "input-channel setup for devices that can later send data (uses TALK/TKSA when used on serial bus)"
        },
        {
          "chunk": "ciout_transmit_byte_over_serial_bus",
          "topic": "complementary routine for sending bytes to serial devices (LISTEN/SECOND preparatory calls)"
        }
      ]
    },
    {
      "start": 13539,
      "end": 13585,
      "name": "chkin_open_input_channel",
      "description": "CHKin: open a logical file as an input channel. Includes purpose, call address ($FFC6 / 65478), communication register (X), preparatory OPEN requirement (unless reading keyboard only), possible errors (#3 file not open, #5 device not present, #6 file not an input file), how the routine auto-sends TALK (and secondary address from OPEN) for serial devices, a usage sequence (load X with logical file number, JSR CHKIN), and a brief example (LDX #2; JSR CHKIN).",
      "references": [
        {
          "chunk": "acptr_get_byte_from_serial_bus_full_handshake",
          "topic": "how a device commanded to TALK can later be read with ACPTR/CHRIN"
        },
        {
          "chunk": "chkin_chkin_to_chkin_relationship_chkout",
          "topic": "paired I/O concept: opening input (CHKIN) vs output (CHKOUT) channels"
        }
      ]
    },
    {
      "start": 13586,
      "end": 13632,
      "name": "chkout_open_output_channel",
      "description": "CHKOUT: define a previously opened logical file as an output channel. Includes purpose, call address ($FFC9 / 65481), communication register (X), preparatory OPEN, possible error returns (0,3,5,7 via READST), stack/register notes, behavior when used with serial devices (auto-sends LISTEN and secondary address), usage steps (load X with logical file number, JSR CHKOUT), example (LDX #3; JSR CHKOUT), and cautions about when it's not needed (screen is default output).",
      "references": [
        {
          "chunk": "chkin_open_input_channel",
          "topic": "paired I/O concept: opening input (CHKIN) vs output (CHKOUT) channels"
        },
        {
          "chunk": "ciout_transmit_byte_over_serial_bus",
          "topic": "after LISTEN (sent by OPEN+CHKOUT) use CIOUT to transmit bytes"
        }
      ]
    },
    {
      "start": 13633,
      "end": 13696,
      "name": "chrin_get_character_from_input_channel",
      "description": "CHRIN: retrieve a character from the current input channel. Covers purpose, call address ($FFCF / 65487), preparatory routines (OPEN, CHKIN), registers affected (A, X), stack requirements, detailed description of keyboard handling (cursor blinking, line buffered into BASIC input buffer up to 88 characters, CR detection), behavior when reading from other devices, usage flows for keyboard and other devices, and examples showing looping until CR and simple JSR/STA usage.",
      "references": [
        {
          "chunk": "chkin_open_input_channel",
          "topic": "defines which logical file is the input channel used by CHRIN"
        },
        {
          "chunk": "getin_get_a_character",
          "topic": "alternative low-level character retrieval (GETIN) and keyboard buffering differences"
        }
      ]
    },
    {
      "start": 13697,
      "end": 13741,
      "name": "chrout_output_a_character",
      "description": "CHROUT: output a character to an opened output channel. Contains purpose, call address ($FFD2 / 65490), preparatory routines (CHKOUT, OPEN), error returns (via READST), stack/register notes, behavior (loads A with byte to send; channel left open), usage steps, example (open logical file and JSR CHROUT), and an important NOTE: when using serial devices, data will be sent to all open output channels on the bus unless other channels are closed with CLRCHN.",
      "references": [
        {
          "chunk": "chkout_open_output_channel",
          "topic": "use OPEN+CHKOUT to set up the destination for CHROUT"
        },
        {
          "chunk": "clrchn_clear_io_channels",
          "topic": "use CLRCHN to close other open channels so only intended serial device receives data"
        }
      ]
    },
    {
      "start": 13742,
      "end": 13786,
      "name": "ciout_transmit_byte_over_serial_bus",
      "description": "CIOUT: low-level transmit of one byte over the serial bus using full handshaking. Includes purpose, call address ($FFA8 / 65448), preparatory routines (LISTEN and SECOND if needed), communication register (A), stack/register notes, detailed behavior (puts byte on bus using handshaking, device must be listening or a timeout status results, routine buffers one character which is sent with EOI on UNLSN), usage steps, and a short example (LDA #'X' ; JSR CIOUT).",
      "references": [
        {
          "chunk": "chkout_open_output_channel",
          "topic": "higher-level channel setup that causes the device to LISTEN before using CIOUT"
        },
        {
          "chunk": "acptr_get_byte_from_serial_bus_full_handshake",
          "topic": "complementary serial read routine that uses full handshaking to receive bytes"
        }
      ]
    },
    {
      "start": 13787,
      "end": 13820,
      "name": "cint_initialize_screen_editor_and_video",
      "description": "CINT: initialize the 6567 video chip and the KERNAL screen editor. Includes purpose, call address ($FF81 / 65409), no preparatory routines required, registers affected (A, X, Y), stack requirement, explanation that it sets up the 6567 for normal operation and initializes the KERNAL screen editor (intended for cartridges), simple usage (JSR CINT; JMP RUN).",
      "references": [
        {
          "chunk": "iobase_define_io_memory_page",
          "topic": "after initializing video you may use IOBASE to locate memory-mapped I/O like VIC registers"
        },
        {
          "chunk": "chrout_output_a_character",
          "topic": "screen output and KERNAL editor are part of the console I/O environment CHROUT can target"
        }
      ]
    },
    {
      "start": 13821,
      "end": 13845,
      "name": "clall_close_all_files",
      "description": "CLALL: close all open files and restore default I/O channels. Includes purpose, call address ($FFE7 / 65511), behavior (resets pointers into open file table, automatically calls CLRCHN to reset I/O channels), stack/register notes, usage (JSR CLALL; JMP RUN example).",
      "references": [
        {
          "chunk": "clrchn_clear_io_channels",
          "topic": "CLALL automatically calls CLRCHN to restore default I/O channels"
        },
        {
          "chunk": "close_close_a_logical_file",
          "topic": "CLALL is the bulk operation counterpart to closing individual files with CLOSE"
        }
      ]
    },
    {
      "start": 13846,
      "end": 13879,
      "name": "close_close_a_logical_file",
      "description": "CLOSE: close a single logical file when I/O operations on it are complete. Contains purpose, call address ($FFC3 / 65475), communication register (A\u2014file number), preparatory notes, possible error returns (0,240 via READST), stack/register remarks, usage steps (load A with logical file number, JSR CLOSE) and example (LDA #15; JSR CLOSE).",
      "references": [
        {
          "chunk": "clall_close_all_files",
          "topic": "CLALL closes all files at once, while CLOSE closes a single logical file"
        },
        {
          "chunk": "clrchn_clear_io_channels",
          "topic": "after closing files, CLRCHN can be used to restore default I/O channels"
        }
      ]
    },
    {
      "start": 13880,
      "end": 13914,
      "name": "clrchn_clear_io_channels",
      "description": "CLRCHN: clear all open I/O channels and restore defaults. Includes purpose, call address ($FFCC / 65484), behavior (resets input to keyboard (device 0) and output to screen (device 3)), how it handles serial channels (sends UNTALK or UNLISTEN as needed), reasons to call it (avoid unintended multiple recipients on serial bus), automatic invocation by CLALL, usage example (JSR CLRCHN), and stack/register notes.",
      "references": [
        {
          "chunk": "chro ut_output_a_character",
          "topic": "use CLRCHN to close other channels so CHROUT only reaches intended device"
        },
        {
          "chunk": "clall_close_all_files",
          "topic": "CLALL automatically calls CLRCHN as part of closing all files"
        }
      ]
    },
    {
      "start": 13915,
      "end": 13961,
      "name": "getin_get_a_character",
      "description": "GETIN: low-level get-a-character routine. Includes purpose, call address ($FFE4 / 65508), communication register (A), preparatory routines (CHKIN, OPEN), stack/register requirements, behavior for keyboard channel (removes one char from keyboard queue, returns ASCII in A, returns zero if queue empty, keyboard queue fed by interrupt-driven scan up to 10 characters), behavior for RS-232 (single character in A), and usage example showing a loop waiting until a non-zero character is returned.",
      "references": [
        {
          "chunk": "chrin_get_character_from_input_channel",
          "topic": "CHRIN retrieves characters from the current input channel (higher-level handling of keyboard lines) whereas GETIN directly reads the keyboard queue"
        },
        {
          "chunk": "iobase_define_io_memory_page",
          "topic": "IOBASE can be used to find RS-232 and other I/O page locations referenced by GETIN"
        }
      ]
    },
    {
      "start": 13962,
      "end": 14000,
      "name": "iobase_define_io_memory_page",
      "description": "IOBASE: set up base pointers (X=low byte, Y=high byte) to the memory page where memory-mapped I/O devices are located. Includes purpose, call address ($FFF3 / 65523), registers returned (X,Y), no preparatory routines, compatibility rationale (keeps code portable across C64, VIC-20, future models), usage steps (JSR IOBASE; STX/STY to store base; then load Y with offset to access specific I/O register), and example showing storing base registers and preparing to access the User Port data direction register (JSR IOBASE; STX POINT; STY POINT+1; LDY #2).",
      "references": [
        {
          "chunk": "cint_initialize_screen_editor_and_video",
          "topic": "after initializing video hardware, use IOBASE to locate video-related I/O registers"
        },
        {
          "chunk": "ciout_transmit_byte_over_serial_bus",
          "topic": "IOBASE helps locate memory-mapped I/O pages (complementary to KERNAL bus routines which operate via calls)"
        }
      ]
    },
    {
      "start": 14001,
      "end": 14004,
      "name": "user_port_ddr_example_and_page_heading",
      "description": "Assembly example showing how to set the Data Direction Register (DDR) of the user port to 0 (LDA #0; STA (POINT),Y). Includes the page heading/footer marker for the 'BASIC TO MACHINE LANGUAGE' section.",
      "references": [
        {
          "chunk": "ioinit",
          "topic": "subsequent KERNAL routine listings and examples"
        }
      ]
    },
    {
      "start": 14005,
      "end": 14008,
      "ignore": true,
      "reason": "Page header/footer and formatting markers (non-technical), safe to ignore."
    },
    {
      "start": 14009,
      "end": 14025,
      "name": "ioinit_kernal_routine",
      "description": "KERNAL routine IOINIT: purpose (initialize I/O devices), call address ($FF84), registers affected (A, X, Y), brief description and example usage (JSR IOINIT). Notes that it's normally called during Commodore 64 cartridge initialization.",
      "references": [
        {
          "chunk": "user_port_ddr_example_and_page_heading",
          "topic": "preceding assembly example and section heading"
        },
        {
          "chunk": "listen",
          "topic": "other serial/I/O KERNAL routines"
        }
      ]
    },
    {
      "start": 14026,
      "end": 14052,
      "name": "listen_kernal_routine",
      "description": "KERNAL routine LISTEN: purpose (command a device on the serial bus to listen), call address ($FFB1), communication register (A), description of operation (accumulator contains device number 0\u201331, converts to listen address and transmits on serial bus), step-by-step usage and a short example commanding device #8 to listen.",
      "references": [
        {
          "chunk": "ioinit_kernal_routine",
          "topic": "I/O initialization and related routines"
        },
        {
          "chunk": "load_kernal_routine",
          "topic": "other serial/file access KERNAL routines"
        }
      ]
    },
    {
      "start": 14053,
      "end": 14053,
      "ignore": true,
      "reason": "Single page/format marker (~) only \u2014 non-technical."
    },
    {
      "start": 14054,
      "end": 14054,
      "ignore": true,
      "reason": "Blank/page marker line between sections; non-technical, ignore."
    },
    {
      "start": 14055,
      "end": 14055,
      "name": "load_kernal_routine",
      "description": "KERNAL routine LOAD: purpose (load RAM from device or verify), call address ($FFD5), communication registers (A, X, Y), preparatory routines (SETLFS, SETNAM), error returns, detailed description of LOAD vs VERIFY modes, behavior when device is opened with secondary address 0 or 1, note listing devices you cannot LOAD from (keyboard 0, RS-232 2, screen 3), how-to steps, and a complete example that demonstrates loading a file from tape using SETLFS, SETNAM and LOAD (including storing returned end addresses).",
      "references": [
        {
          "chunk": "listen_kernal_routine",
          "topic": "serial device addressing and listening"
        },
        {
          "chunk": "memtop_kernal_routine",
          "topic": "handling memory top after loads"
        },
        {
          "chunk": "membot_kernal_routine",
          "topic": "memory bottom adjustments related to relocations"
        }
      ]
    },
    {
      "start": 14056,
      "end": 14126,
      "name": "load_kernal_routine",
      "description": "KERNAL LOAD (call $FFD5 / 65493): load RAM from an input device or verify device data against memory. Uses A (0=LOAD, 1=VERIFY), X,Y for start/end addresses when secondary address=0 (relocated loads). Requires SETLFS and SETNAM preparatory calls. Returns highest RAM location loaded. Error returns: 0,4,5,8,9 and READST. Example demonstrates loading from tape with SETLFS/SETNAM and JSR LOAD.",
      "references": [
        {
          "chunk": "setlfs_kernal_routine",
          "topic": "SETLFS required before LOAD"
        },
        {
          "chunk": "setnam_kernal_routine",
          "topic": "SETNAM required before LOAD"
        },
        {
          "chunk": "readst_kernal_routine",
          "topic": "Check device errors with READST"
        }
      ]
    },
    {
      "start": 14127,
      "end": 14167,
      "name": "membot_kernal_routine",
      "description": "KERNAL routine MEMBOT: purpose (set or read bottom of memory), call address ($FF9C), communication registers (X, Y), behavior when carry set (returns pointer to lowest byte of RAM in X/Y) and when carry clear (sets low/high bytes of bottom-of-RAM pointer from X/Y). Notes default bottom on unexpanded C64 is $0800. Includes usage instructions for reading and setting memory bottom and an example that moves the bottom of memory up one page.",
      "references": [
        {
          "chunk": "memtop_kernal_routine",
          "topic": "complementary routine for top-of-RAM management"
        },
        {
          "chunk": "load_kernal_routine",
          "topic": "impact of memory bounds when loading/relocating data"
        }
      ]
    },
    {
      "start": 14168,
      "end": 14191,
      "name": "memtop_kernal_routine",
      "description": "KERNAL routine MEMTOP: purpose (set or read top of RAM), call address ($FF99), communication registers (X, Y), behavior when carry set (loads pointer to top of RAM into X/Y) and when carry clear (stores X/Y into top-of-memory pointer). Lists stack requirement (2) and includes example showing how to deallocate the RS-232 buffer by reading, adjusting, and writing the top-of-memory pointer.",
      "references": [
        {
          "chunk": "membot_kernal_routine",
          "topic": "complementary routine for bottom-of-RAM management"
        },
        {
          "chunk": "load_kernal_routine",
          "topic": "memory top effects on loaded data and buffers"
        }
      ]
    },
    {
      "start": 14192,
      "end": 14194,
      "ignore": true,
      "reason": "Page header/footer and formatting markers only (non-technical)."
    },
    {
      "start": 14195,
      "end": 14196,
      "ignore": true,
      "reason": "Blank lines/page markers between sections \u2014 non-technical, ignore."
    },
    {
      "start": 14197,
      "end": 14236,
      "name": "open_kernal_routine",
      "description": "KERNAL OPEN (call $FFC0 / 65472): open a logical file. Preparatory routines required: SETLFS, SETNAM. Error returns: 1,2,4,5,6,240 and READST. A,X,Y registers affected. Example implements BASIC 'OPEN 15,8,15,\"I/O\"' by calling SETNAM, SETLFS, then JSR OPEN.",
      "references": [
        {
          "chunk": "setlfs_kernal_routine",
          "topic": "SETLFS usage to set logical file, device, secondary address"
        },
        {
          "chunk": "setnam_kernal_routine",
          "topic": "SETNAM usage to provide filename to OPEN"
        },
        {
          "chunk": "readst_kernal_routine",
          "topic": "Check error status after OPEN"
        }
      ]
    },
    {
      "start": 14237,
      "end": 14241,
      "ignore": true,
      "reason": "Page header/footer and formatting markers"
    },
    {
      "start": 14242,
      "end": 14242,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14243,
      "end": 14284,
      "name": "plot_kernal_routine",
      "description": "KERNAL PLOT (call $FFF0 / 65520): set or read cursor location on screen. Uses A,X,Y. With carry set (SEC) reads current cursor location: Y=column (6-39), X=row (0-24). With carry clear (CLC) moves cursor to X,Y using Y as column and X as row. Stack requirement: 2. Example shows moving cursor to row 10, column 5 with LDX #10 ; LDY #5 ; CLC ; JSR PLOT.",
      "references": [
        {
          "chunk": "screen_kernal_routine",
          "topic": "Screen dimensions returned by SCREEN routine"
        }
      ]
    },
    {
      "start": 14285,
      "end": 14288,
      "ignore": true,
      "reason": "Page header/footer and formatting markers"
    },
    {
      "start": 14289,
      "end": 14290,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14291,
      "end": 14308,
      "name": "ramtas_kernal_routine",
      "description": "KERNAL RAMTAS (call $FF87 / 65415): performs RAM test, sets top and bottom memory pointers accordingly, clears page 0 ranges $0000-$0101 and $0200-$03FF, allocates cassette buffer, and sets screen base to $0400. Typically used during cartridge initialization. Example: JSR RAMTAS.",
      "references": [
        {
          "chunk": "memtop_kernal_routine",
          "topic": "RAMTAS sets top-of-memory pointer"
        },
        {
          "chunk": "membot_kernal_routine",
          "topic": "RAMTAS sets bottom-of-memory pointer"
        }
      ]
    },
    {
      "start": 14309,
      "end": 14337,
      "name": "rdtim_kernal_routine",
      "description": "KERNAL RDTIM (call $FFDE / 65502): Read system clock (jiffies, 1/60s resolution). Returns three bytes: A = MSB, X = middle byte, Y = LSB (least significant). Stack requirement: 2. Example shows storing TIME in memory via STY/ STX/ STA of returned values.",
      "references": [
        {
          "chunk": "settim_kernal_routine",
          "topic": "Setting system clock with SETTIM"
        }
      ]
    },
    {
      "start": 14338,
      "end": 14397,
      "name": "readst_kernal_routine",
      "description": "KERNAL READST (call $FFB7 / 65463): Read status word of I/O devices returned in A. Bits indicate specific conditions/errors (table). Bit definitions include cassette read/write timeouts, tape verify/short/long block, checksum, EOF, end-of-tape, serial bus timeouts, device not present. Use READST after device I/O to detect device status and error conditions.",
      "references": [
        {
          "chunk": "listen_kernal_routine",
          "topic": "LISTEN uses READST for error returns"
        },
        {
          "chunk": "talk_kernal_routine",
          "topic": "TALK uses READST for error returns"
        }
      ]
    },
    {
      "start": 14398,
      "end": 14416,
      "name": "restor_kernal_routine",
      "description": "KERNAL RESTOR (call $FF8A / 65418): restore default system and interrupt vectors in RAM used by KERNAL and BASIC. No preparatory routines required. Use KERNAL VECTOR to read/alter individual vectors before restoring. Example: JSR RESTOR.",
      "references": [
        {
          "chunk": "vector_kernal_routine",
          "topic": "Use VECTOR to read/alter vectors before calling RESTOR"
        }
      ]
    },
    {
      "start": 14417,
      "end": 14417,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14418,
      "end": 14472,
      "name": "save_kernal_routine",
      "description": "KERNAL SAVE (call $FFD8 / 65496): Save a section of memory to an output device. Uses A,X,Y and a pointer on page 0 (pointed to by accumulator offset) for start/end of memory to save. Requires SETLFS and SETNAM except when saving to device 1 (cassette) with no filename. Error returns: 5,8,9 and READST. Example shows SAVE to cassette with no filename (device 1).",
      "references": [
        {
          "chunk": "setlfs_kernal_routine",
          "topic": "SETLFS required for SAVE"
        },
        {
          "chunk": "setnam_kernal_routine",
          "topic": "SETNAM required for SAVE (except cassette without filename)"
        },
        {
          "chunk": "readst_kernal_routine",
          "topic": "Check device status after SAVE"
        }
      ]
    },
    {
      "start": 14473,
      "end": 14476,
      "ignore": true,
      "reason": "Page header/footer and formatting markers"
    },
    {
      "start": 14477,
      "end": 14478,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14479,
      "end": 14505,
      "name": "scnkey_kernal_routine",
      "description": "KERNAL SCNKEY (call $FF9F / 65439): Scan keyboard for pressed keys. Same routine used by IRQ handler; puts ASCII of pressed key into keyboard queue. Called if normal IRQ is bypassed. Requires IOINIT as preparatory routine. Example includes loop calling SCNKEY, GETIN, CHROUT etc.",
      "references": [
        {
          "chunk": "ioinit_kernal_routine",
          "topic": "SCNKEY requires IOINIT"
        }
      ]
    },
    {
      "start": 14506,
      "end": 14506,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14507,
      "end": 14535,
      "name": "screen_kernal_routine",
      "description": "KERNAL SCREEN (call $FFED / 65517): Returns screen format: X (columns) and Y (rows) in X and Y registers respectively. Use to detect hardware (for compatibility). Example: JSR SCREEN ; STX MAXCOL ; STY MAXROW.",
      "references": [
        {
          "chunk": "plot_kernal_routine",
          "topic": "PLOT uses screen dimensions"
        }
      ]
    },
    {
      "start": 14536,
      "end": 14536,
      "ignore": true,
      "reason": "Page formatting marker"
    },
    {
      "start": 14537,
      "end": 14572,
      "name": "second_kernal_routine",
      "description": "KERNAL SECOND (call $FF93 / 65427): Send secondary address to an I/O device after LISTEN has been called. Uses A (secondary address). Cannot be used after TALK. Secondary address must be ORed with $60 on serial bus. Stack requirements: 8. Example: LDA #8 ; JSR LISTEN ; LDA #15 ; JSR SECOND.",
      "references": [
        {
          "chunk": "listen_kernal_routine",
          "topic": "SECOND must be used after LISTEN"
        }
      ]
    },
    {
      "start": 14573,
      "end": 14626,
      "name": "setlfs_kernal_routine",
      "description": "KERNAL SETLFS (call $FFBA / 65466): Set logical file number, device number, and secondary address for subsequent KERNAL I/O routines. A = logical file number, X = device number (0-31), Y = command (secondary address). If no secondary address, set Y = 255. Device number codes: 0 keyboard, 1 datassette, 2 RS-232, 3 CRT, 4 printer, 8 disk drive. Device numbers >=4 refer to serial bus devices.",
      "references": [
        {
          "chunk": "open_kernal_routine",
          "topic": "SETLFS must be called before OPEN"
        },
        {
          "chunk": "load_kernal_routine",
          "topic": "SETLFS required before LOAD"
        },
        {
          "chunk": "save_kernal_routine",
          "topic": "SETLFS required before SAVE"
        }
      ]
    },
    {
      "start": 14627,
      "end": 14628,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14629,
      "end": 14661,
      "name": "setmsg_kernal_routine",
      "description": "KERNAL SETMSG (call $FF90 / 65424): Control KERNAL message output (error and control messages). Use accumulator bits 6 and 7 to control message printing: bit7=1 prints an error message; bit6=1 prints control messages. Example: LDA #$40 ; JSR SETMSG (turn on control messages); LDA #$80 ; JSR SETMSG (turn on error messages); LDA #0 ; JSR SETMSG (turn off messages).",
      "references": [
        {
          "chunk": "readst_kernal_routine",
          "topic": "Use READST to interpret device status rather than relying on printed messages"
        }
      ]
    },
    {
      "start": 14662,
      "end": 14666,
      "ignore": true,
      "reason": "Page break/formatting markers"
    },
    {
      "start": 14667,
      "end": 14698,
      "name": "setnam_kernal_routine",
      "description": "KERNAL SETNAM (call $FFBD / 65469): Set file name for OPEN, SAVE, or LOAD. A = length of file name (0 for no name). X = low byte of filename address, Y = high byte (standard 6502 low-byte/high-byte). If no filename, X/Y can be any address. Example: LDA #NAME2-NAME ; LDX #<NAME ; LDY #>NAME ; JSR SETNAM.",
      "references": [
        {
          "chunk": "setlfs_kernal_routine",
          "topic": "SETLFS is used with SETNAM to open files"
        }
      ]
    },
    {
      "start": 14699,
      "end": 14699,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14700,
      "end": 14735,
      "name": "settim_kernal_routine",
      "description": "KERNAL SETTIM (call $FFDB / 65499): Set the 3-byte system clock (jiffies, 1/60 sec). A = MSB, X = middle byte, Y = LSB for the 3-byte time value. No registers affected on return. Example sets clock to 3600 jiffies (10 minutes): LDA #0 ; LDX #>3600 ; LDY #<3600 ; JSR SETTIM.",
      "references": [
        {
          "chunk": "rdtim_kernal_routine",
          "topic": "RDTIM reads the clock set by SETTIM"
        }
      ]
    },
    {
      "start": 14736,
      "end": 14736,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14737,
      "end": 14782,
      "name": "settmo_kernal_routine",
      "description": "KERNAL SETTMO (call $FFA2 / 65442): Set IEEE bus card timeout flag (only for IEEE add-on card). A bit 7 = 0 enables timeouts (wait 64 ms for DAV), bit 7 = 1 disables timeouts. Use only with IEEE card. Note: Commodore 64 uses timeout to signal file-not-found on IEEE.",
      "references": [
        {
          "chunk": "open_kernal_routine",
          "topic": "Timeouts can affect OPEN behavior with IEEE devices"
        }
      ]
    },
    {
      "start": 14783,
      "end": 14814,
      "name": "stop_kernal_routine",
      "description": "KERNAL STOP (call $FFE1 / 65505): Check if the <STOP> key was pressed during UDTIM. If <STOP> pressed, Z flag is set and channels reset to default. Otherwise accumulator contains byte representing lost row of keyboard scan. UDTIM should be called before STOP. Example uses JSR UDTIM ; JSR STOP ; BNE *+5 ; JMP READY.",
      "references": [
        {
          "chunk": "udtim_kernal_routine",
          "topic": "Call UDTIM before STOP to scan for <STOP> key"
        }
      ]
    },
    {
      "start": 14815,
      "end": 14839,
      "name": "talk_kernal_routine",
      "description": "KERNAL TALK (call $FFB4 / 65460): Command a serial-bus device to TALK. A must hold device number 0-31; routine ORs bits to form talk address and sends command on serial bus. Error returns via READST. Example: LDA #4 ; JSR TALK.",
      "references": [
        {
          "chunk": "tksa_kernal_routine",
          "topic": "Send secondary address for TALK devices using TKSA"
        },
        {
          "chunk": "readst_kernal_routine",
          "topic": "Check TALK status via READST"
        }
      ]
    },
    {
      "start": 14840,
      "end": 14840,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14841,
      "end": 14873,
      "name": "tksa_kernal_routine",
      "description": "KERNAL TKSA (call $FF96 / 65430): Send secondary address to a device previously commanded to TALK. A contains secondary address (0-31). Must be called after TALK (not LISTEN). Error returns via READST. Example: LDA #4 ; JSR TALK ; LDA #7 ; JSR TKSA.",
      "references": [
        {
          "chunk": "talk_kernal_routine",
          "topic": "TKSA must follow TALK"
        }
      ]
    },
    {
      "start": 14874,
      "end": 14875,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14876,
      "end": 14901,
      "name": "udtim_kernal_routine",
      "description": "KERNAL UDTIM (call $FFEA / 65514): Update the system clock. Normally called by IRQ every 1/60s. If user programs handle IRQs, they must call UDTIM to update time and maintain STOP key functionality. A,X not used; stack requirement: 2. Example: JSR UDTIM.",
      "references": [
        {
          "chunk": "stop_kernal_routine",
          "topic": "Call STOP after UDTIM to check for <STOP> key"
        }
      ]
    },
    {
      "start": 14902,
      "end": 14924,
      "name": "unlsn_kernal_routine",
      "description": "KERNAL UNLSN (call $FFAE / 65454): Send UNLISTEN command on serial bus, commanding all previously listening devices to stop receiving data. Error returns via READST. Stack requirements: 8. Example: JSR UNLSN.",
      "references": [
        {
          "chunk": "listen_kernal_routine",
          "topic": "UNLSN complements LISTEN to stop devices from listening"
        }
      ]
    },
    {
      "start": 14925,
      "end": 14925,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14926,
      "end": 14951,
      "name": "untlk_kernal_routine",
      "description": "KERNAL UNTLK/UNTALK (call $FFAB / 65451): Transmit an UNTALK command on the serial bus to stop devices previously set to TALK from sending data. Error returns via READST. Stack requirements: 8. Example: JSR UNTALK.",
      "references": [
        {
          "chunk": "talk_kernal_routine",
          "topic": "UNTALK complements TALK to stop devices talking"
        }
      ]
    },
    {
      "start": 14952,
      "end": 14952,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 14953,
      "end": 15012,
      "name": "vector_kernal_routine",
      "description": "KERNAL VECTOR (call $FF8D / 65421): Manage RAM system vectors. With carry set (SEC) reads current RAM vectors into list pointed by X/Y. With carry clear (CLC) writes vectors from list at X/Y into system RAM vectors. Use caution: recommended workflow is read vectors, modify desired vectors in user area, then write back. Example modifies input routine by changing vector entries.",
      "references": [
        {
          "chunk": "restor_kernal_routine",
          "topic": "RESTOR restores default system vectors"
        }
      ]
    },
    {
      "start": 15013,
      "end": 15038,
      "name": "kernal_error_codes",
      "description": "List of KERNAL error codes returned in A with carry set when errors occur. Codes include 0 STOP pressed, 1 too many open files, 2 file already open, 3 file not open, 4 file not found, 5 device not present, 6 file not input, 7 file not output, 8 file name missing, 9 illegal device number, 240 top-of-memory change RS-232 buffer allocation/deallocation. Note: some KERNAL I/O routines use READST instead of these codes.",
      "references": [
        {
          "chunk": "readst_kernal_routine",
          "topic": "Some I/O routines use READST rather than KERNAL error return codes"
        }
      ]
    },
    {
      "start": 15039,
      "end": 15042,
      "ignore": true,
      "reason": "Page header/footer and formatting markers"
    },
    {
      "start": 15043,
      "end": 15056,
      "name": "ml_from_basic_overview",
      "description": "Overview of five main ways to use machine language from BASIC: 1) BASIC SYS statement, 2) BASIC USR function, 3) changing RAM I/O vectors, 4) changing RAM interrupt vectors (IRQ), 5) changing CHRGET routine (wedge). Explains purpose and when each technique is used.",
      "references": [
        {
          "chunk": "sys_and_usr_methods",
          "topic": "SYS and USR method details"
        },
        {
          "chunk": "vector_kernal_routine",
          "topic": "Changing RAM vectors via VECTOR routine (related to method 3)"
        }
      ]
    },
    {
      "start": 15057,
      "end": 15057,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 15058,
      "end": 15069,
      "name": "sys_statement_method",
      "description": "Method 1: BASIC SYS X \u2014 causes a jump to machine language subroutine at address X. Routine must end with RTS to return to BASIC. Parameter passing typically via PEEK/POKE. SYS is most straightforward for combining BASIC and machine language.",
      "references": [
        {
          "chunk": "where_to_put_ml_routines",
          "topic": "Recommended addresses for placing SYS-able machine language routines"
        }
      ]
    },
    {
      "start": 15070,
      "end": 15083,
      "name": "usr_function_method",
      "description": "Method 2: BASIC USR(X) \u2014 transfers control to machine routine pointed by low/high bytes at locations 785-786 ($0311-$0312). The BASIC numeric value X is passed via floating point accumulator #1 (at $61). Routine returns a value by placing it into floating point accumulator. Routine must end with RTS. Indirect vector must be changed if using multiple routines.",
      "references": [
        {
          "chunk": "memory_map_zero_page_part1",
          "topic": "Floating point accumulator and USR vector addresses in zero page"
        }
      ]
    },
    {
      "start": 15084,
      "end": 15089,
      "ignore": true,
      "reason": "Formatting / small blank area between method descriptions"
    },
    {
      "start": 15090,
      "end": 15103,
      "name": "replace_vector_method",
      "description": "Method 3: Replace or augment system input/output or BASIC internal routines via the RAM vector table on page 3 (zero-page vectors). Each vector is a 2-byte low/high address. Use KERNAL VECTOR routine or POKEs to adjust individual vectors. New routines can call the original routine (JMP to old vector) or end with RTS to return to BASIC.",
      "references": [
        {
          "chunk": "vector_kernal_routine",
          "topic": "VECTOR routine used to read/alter vector table safely"
        }
      ]
    },
    {
      "start": 15104,
      "end": 15104,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 15105,
      "end": 15118,
      "name": "irq_vector_method",
      "description": "Method 4: Change hardware IRQ vector to run custom interrupt handler every 1/60s. Useful for concurrent tasks; must usually chain to normal IRQ handler unless handling CIA. Replacement interrupt must end with RTI. WARNING: Always disable interrupts before changing IRQ vector.",
      "references": [
        {
          "chunk": "vector_kernal_routine",
          "topic": "VECTOR routine can be used to manage IRQ vector entries"
        }
      ]
    },
    {
      "start": 15119,
      "end": 15119,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 15120,
      "end": 15131,
      "name": "chrget_wedge_method",
      "description": "Method 5: Replace CHRGET routine (used by BASIC to fetch characters/tokens) to implement new BASIC commands (a 'wedge'). New CHRGET examines text for special command prefix (e.g., '@'), handles user commands, otherwise passes control to normal CHRGET. Allows adding BASIC keywords with minimal performance penalty.",
      "references": [
        {
          "chunk": "vector_kernal_routine",
          "topic": "CHRGET vector is one of the zero-page vectors that can be changed"
        }
      ]
    },
    {
      "start": 15132,
      "end": 15136,
      "ignore": true,
      "reason": "Small formatting / page separation area"
    },
    {
      "start": 15137,
      "end": 15156,
      "name": "where_to_put_ml_routines",
      "description": "Guidance for where to place machine language routines: recommended $C000-$CFFF for routines <4K (not disturbed by BASIC). For larger routines, reserve area at top of memory (default top $9FFF) using MEMTOP or POKE trick to reserve top-of-memory from BASIC. Example POKE sequence provided to reserve $9000-$9FFF region.",
      "references": [
        {
          "chunk": "memtop_kernal_routine",
          "topic": "Use MEMTOP KERNAL routine to change top of memory"
        }
      ]
    },
    {
      "start": 15157,
      "end": 15157,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 15158,
      "end": 15171,
      "name": "how_to_enter_ml_overview",
      "description": "Three common methods to add machine language programs to BASIC: 1) DATA statements (READ/POKE), 2) Machine language monitor (e.g., 64MON) entry and save, 3) Editor/assembler package. Pros/cons of each discussed.",
      "references": [
        {
          "chunk": "data_statements_method",
          "topic": "DATA/READ/POKE entry method"
        },
        {
          "chunk": "machine_monitor_method",
          "topic": "64MON and monitor-based entry method"
        }
      ]
    },
    {
      "start": 15172,
      "end": 15183,
      "name": "data_statements_method",
      "description": "Method: Enter machine code via BASIC DATA statements, READ into variables and POKE into memory. Easiest method but uses more memory and is slow to load, suitable for small routines. Example shows BASIC loop reading DATA and POKEing bytes into memory with a DATA line containing bytes.",
      "references": [
        {
          "chunk": "where_to_put_ml_routines",
          "topic": "Choose memory area to POKE in when using DATA method"
        }
      ]
    },
    {
      "start": 15184,
      "end": 15205,
      "name": "machine_monitor_method",
      "description": "Method: Use a machine language monitor (64MON) to enter programs in hex or symbolic form, with debugging aids and save/load. Generally requires BASIC to load machine code from tape/disk at program start. Example usage shown where BASIC loads the machine language routine if flag not set.",
      "references": [
        {
          "chunk": "data_statements_method",
          "topic": "Alternate entry method comparison"
        }
      ]
    },
    {
      "start": 15206,
      "end": 15206,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 15207,
      "end": 15211,
      "name": "editor_assembler_method",
      "description": "Method: Use an editor/assembler package to assemble machine code; advantages similar to monitor but with easier entry and debugging. Disadvantages similar to monitor (load machine code from tape/disk when starting BASIC).",
      "references": [
        {
          "chunk": "machine_monitor_method",
          "topic": "Both provide better entry/debugging than DATA statements"
        }
      ]
    },
    {
      "start": 15212,
      "end": 15213,
      "ignore": true,
      "reason": "Blank lines"
    },
    {
      "start": 15214,
      "end": 15321,
      "name": "memory_map_part1_zero_page_start",
      "description": "COMMODORE 64 Memory Map (part 1): Table header and the beginning of the memory map including zero page addresses $0000-$0030 and key zero-page variables (e.g., D6510 $0000 data-direction register, R6510 $0001 on-chip I/O port), floating/integer convert vectors at $0003-$0006, CHRGET entry and early zero-page workspace. Lists labels and brief descriptions covering addresses through INDEX, TXTTAB, VARTAB and other early zero-page pointers.",
      "references": [
        {
          "chunk": "memory_map_part2_zero_page_continued",
          "topic": "Continues zero-page variable listings and floating point workspace"
        }
      ]
    },
    {
      "start": 15322,
      "end": 15429,
      "name": "memory_map_part2_zero_page_and_vectors",
      "description": "COMMODORE 64 Memory Map (part 2): Continued zero page variables and floating point accumulator storage (FACEXP, FACHO, FACSGN), temp storage, keyboard buffers, tape I/O pointers, KERNAL I/O status ST, time, tape buffer, variables relating to file handling (LA, SA, FA) and more. Also includes BASIC vectors on page 3 (0x0300 area) and USR vector locations USRPOK/USRADD and interrupt vectors (CINV, CBINV, NMINV), and various KERNAL vectors (IOPEN, ICLOSE, etc.).",
      "references": [
        {
          "chunk": "memory_map_part3_video_and_rom",
          "topic": "Continues into screen memory and ROM/RAM areas"
        },
        {
          "chunk": "vector_kernal_routine",
          "topic": "KERNAL vectors described here are managed by VECTOR routine"
        }
      ]
    },
    {
      "start": 15430,
      "end": 15508,
      "name": "memory_map_part3_screen_video_rom_ram",
      "description": "COMMODORE 64 Memory Map (part 3): Stack area at $0100-$01FF, system input buffer at $0200, various KERNAL tables, top-of-screen memory VICSCN at $0400-$07FF, BASIC program area $0800-$9FFF, Cartridge ROM $8000-$9FFF, BASIC ROM $A000-$BFFF, RAM $C000-$CFFF, I/O and Color RAM/Char ROM $D000-$DFFF, KERNAL ROM $E000-$FFFF. Provides the overall high-level memory segmentation.",
      "references": [
        {
          "chunk": "vic_registers_overview",
          "topic": "VIC screen memory area and registers are mapped into $D000-$D02E and VICSCN region"
        }
      ]
    },
    {
      "start": 15509,
      "end": 15512,
      "ignore": true,
      "reason": "Page header/footer markers"
    },
    {
      "start": 15513,
      "end": 15534,
      "name": "io_assignments_header",
      "description": "COMMODORE 64 Input/Output Assignments: header for mapping I/O registers and their addresses and bit definitions. Introduces the table of device registers including MOS 6510, VIC, SID, CIA, etc.",
      "references": [
        {
          "chunk": "memory_map_part3_screen_video_rom_ram",
          "topic": "I/O registers reside in $D000-$DFFF region referenced in memory map"
        }
      ]
    },
    {
      "start": 15535,
      "end": 15633,
      "name": "vic_registers_overview",
      "description": "VIC-II (MOS 6566/6567) register map: D000-D02E (sprite X/Y positions D000-D00F, D010 sprites MSB X positions and VIC control registers). D010-D01E cover raster compare, control, sprite enable ($D015), multi-color mode, screen/bitmap modes, X/Y smooth scrolling bits, sprite expand, memory control. D019 = interrupt flag bits for raster/sprite/background/light-pen collisions. D01A IRQ mask register, D01B sprite/background priority, D01C multi-color mode, D01D/D01E sprite expansion and collision registers, D020-D024 border/background colors, D025-D026 sprite multicolor registers, D027-D02E sprite color registers.",
      "references": [
        {
          "chunk": "memory_map_part3_screen_video_rom_ram",
          "topic": "VIC registers map to $D000-$D02E region in memory map"
        },
        {
          "chunk": "light_pen_description",
          "topic": "Light-pen latches and IRQ bits referenced in VIC registers (D013/D014 & D019)"
        }
      ]
    },
    {
      "start": 15634,
      "end": 15673,
      "name": "sid_overview_and_voice1_registers",
      "description": "MOS 6581 SID overall address range and Voice 1 register map (D400-D406). Includes the SID device range header (D400-D7FF) and detailed Voice 1 registers: D400/D401 frequency low/high, D402/D403 pulse waveform width (low byte and high nybble), D404 control register waveform enable bits (triangle/saw/pulse/noise), control bits (test, ring modulation, sync, gate), and envelope generator 1 controls D405 (attack/decay) and D406 (sustain/release). Table headings and bit descriptions for Voice 1 are included.",
      "references": [
        {
          "chunk": "voice2_registers_and_envelopes",
          "topic": "Voice 2 registers (D407-D40D) and envelopes"
        },
        {
          "chunk": "voice3_registers_and_envelopes",
          "topic": "Voice 3 registers (D40E-D414) and envelopes"
        },
        {
          "chunk": "sid_filter_and_misc_registers",
          "topic": "Filter, A/D, RNG and other SID registers (D415-D41C)"
        }
      ]
    },
    {
      "start": 15674,
      "end": 15712,
      "name": "voice2_registers_and_envelopes",
      "description": "Voice 2 register map and envelope controls (D407-D40D). Covers D407/D408 frequency low/high, D409/D40A pulse waveform width (low byte and high nybble), D40B control register bits (waveform enables, test, ring modulation, sync, gate) and envelope generator registers D40C (attack/decay) and D40D (sustain/release). Includes table headers and bit descriptions relevant to Voice 2.",
      "references": [
        {
          "chunk": "sid_overview_and_voice1_registers",
          "topic": "Voice 1 registers and SID overview (D400-D406)"
        },
        {
          "chunk": "voice3_registers_and_envelopes",
          "topic": "Voice 3 registers (D40E-D414) and envelopes"
        },
        {
          "chunk": "sid_filter_and_misc_registers",
          "topic": "Filter and miscellaneous SID registers (D415-D41C)"
        }
      ]
    },
    {
      "start": 15713,
      "end": 15742,
      "name": "voice3_registers_and_envelopes",
      "description": "Voice 3 register map and envelope controls (D40E-D414). Covers D40E/D40F frequency low/high, D410/D411 pulse waveform width (low byte and high nybble), D412 control register bits (waveform enables, test, ring modulation, sync, gate) and envelope generator registers D413 (attack/decay) and D414 (sustain/release). Includes associated table headings and bit descriptions for Voice 3.",
      "references": [
        {
          "chunk": "sid_overview_and_voice1_registers",
          "topic": "Voice 1 registers (D400-D406) and SID overview"
        },
        {
          "chunk": "voice2_registers_and_envelopes",
          "topic": "Voice 2 registers (D407-D40D) and envelopes"
        },
        {
          "chunk": "sid_filter_and_misc_registers",
          "topic": "SID filter, A/D and RNG registers (D415-D41C)"
        }
      ]
    },
    {
      "start": 15743,
      "end": 15774,
      "name": "sid_filter_and_misc_registers",
      "description": "SID filter, A/D converters, RNG and miscellaneous outputs (D415-D41C). Details D415 (filter cutoff low-nybble), D416 (cutoff high byte), D417 (filter resonance and voice input routing with bit assignments), D418 (filter mode bits: high/band/low-pass and output volume), D419/D41A (analog/digital converters for game paddles 1 and 2), D41B (Oscillator 3 random number generator) and D41C (envelope generator 3 output). Includes preceding table headings and bit descriptions for these registers.",
      "references": [
        {
          "chunk": "sid_overview_and_voice1_registers",
          "topic": "SID device overview and Voice 1 (D400-D406)"
        },
        {
          "chunk": "voice2_registers_and_envelopes",
          "topic": "Voice 2 registers and envelopes (D407-D40D)"
        },
        {
          "chunk": "voice3_registers_and_envelopes",
          "topic": "Voice 3 registers and envelopes (D40E-D414)"
        }
      ]
    },
    {
      "start": 15775,
      "end": 15790,
      "name": "color_ram_and_cia1_dc00_port_a",
      "description": "Memory map entries for SID images ($D500-$D7FF) and Color RAM nybbles ($D800-$DBFF), plus CIA #1 (MOS 6526) header ($DC00-$DCFF) and Data Port A (DC00/$56320) \u2014 usage for keyboard column writes, paddle selection bits, joystick A direction (bits 3-0) and fire/paddle fire bits.",
      "references": [
        {
          "chunk": "cia1_dc01_ddr_timers_table",
          "topic": "continues CIA #1 register listings (Port B, DDRs, Timer A/B)"
        },
        {
          "chunk": "cia1_control_registers_dc0e_dc0f",
          "topic": "control register functionality for timers and TOD clock"
        }
      ]
    },
    {
      "start": 15791,
      "end": 15794,
      "name": "page_header_322_ignored",
      "description": "IGNORED (non-technical): page header/footer and small formatting lines for the printed manual (\"322 BASIC TO MACHINE LANGUAGE\").",
      "references": [
        {
          "chunk": "color_ram_and_cia1_dc00_port_a",
          "topic": "previous content on this page"
        },
        {
          "chunk": "cia1_dc01_ddr_timers_table",
          "topic": "continued technical table on following lines"
        }
      ],
      "ignore": true,
      "reason": "IGNORED (non-technical): page header/footer and small formatting lines for the printed manual (\"322 BASIC TO MACHINE LANGUAGE\")."
    },
    {
      "start": 15795,
      "end": 15814,
      "name": "cia1_dc01_ddr_timers_table",
      "description": "CIA #1 register table header and Data Port B (DC01/$56321) description \u2014 keyboard row reads, joystick 1 bits and timer outputs; Data Direction Registers DC02/DC03 (Port A/B); Timer A low/high (DC04/DC05) and Timer B low/high (DC06/DC07). (Includes the intervening blank line after DC07.)",
      "references": [
        {
          "chunk": "color_ram_and_cia1_dc00_port_a",
          "topic": "Port A and general CIA #1 mapping"
        },
        {
          "chunk": "cia1_time_of_day_and_interrupts",
          "topic": "time-of-day, serial buffer and interrupt control registers"
        }
      ]
    },
    {
      "start": 15815,
      "end": 15831,
      "name": "cia1_time_of_day_and_interrupts",
      "description": "CIA #1 Time-of-Day clock registers DC08-DC0B (1/10 seconds, seconds, minutes, hours+AM/PM) and DC0C synchronous serial I/O data buffer; DC0D Interrupt Control Register (read IRQs / write mask) with bit definitions: bit 7 IRQ flag and bits 4..0 for FLAG1, Serial, TOD alarm, Timer B, Timer A interrupts.",
      "references": [
        {
          "chunk": "cia1_dc01_ddr_timers_table",
          "topic": "uses Timer A/B and DDRs described earlier"
        },
        {
          "chunk": "cia1_control_registers_dc0e_dc0f",
          "topic": "control registers that start/stop timers and select modes"
        }
      ]
    },
    {
      "start": 15832,
      "end": 15841,
      "name": "page_footer_323_ignored",
      "description": "IGNORED (non-technical): page footer/header and spacing lines (\"BASIC TO MACHINE LANGUAGE   323\" and surrounding formatting).",
      "references": [
        {
          "chunk": "cia1_time_of_day_and_interrupts",
          "topic": "previous CIA #1 IRQ/TOD content"
        },
        {
          "chunk": "cia1_control_registers_dc0e_dc0f",
          "topic": "technical continuation of CIA #1 control registers"
        }
      ],
      "ignore": true,
      "reason": "IGNORED (non-technical): page footer/header and spacing lines (\"BASIC TO MACHINE LANGUAGE   323\" and surrounding formatting)."
    },
    {
      "start": 15842,
      "end": 15870,
      "name": "cia1_control_registers_dc0e_dc0f",
      "description": "CIA #1 Control Register A (DC0E/$56334) and Control Register B (DC0F/$56335) definitions: DC0E bits for TOD frequency (50/60Hz), serial I/O direction, Timer A count source, force-load, one-shot vs continuous, output mode to PB6 (toggle/pulse), PB6 enable, and start/stop; DC0F bits for setting alarm/TOD behavior, Timer B mode select (count source options), and bits 4-0 mirroring DC0E functionality for Timer B. (Includes table header and a trailing blank line.)",
      "references": [
        {
          "chunk": "cia1_time_of_day_and_interrupts",
          "topic": "interrupts and TOD registers that these controls affect"
        },
        {
          "chunk": "cia2_overview_and_dd00_port_a",
          "topic": "next CIA (CIA #2) mapping in the memory map"
        }
      ]
    },
    {
      "start": 15871,
      "end": 15883,
      "name": "cia2_overview_and_dd00_port_a",
      "description": "MOS 6526 CIA #2 mapping (DD00-DDFF $56576-$56831) header and Data Port A (DD00/$56576) \u2014 serial bus and RS-232 signals, VIC memory bank select bits (bits 1-0 default = 11). Covers bits for serial bus data/clock/ATN signals and RS-232 data output.",
      "references": [
        {
          "chunk": "cia1_control_registers_dc0e_dc0f",
          "topic": "CIA #1 control registers preceding CIA #2"
        },
        {
          "chunk": "cia2_dd01_port_b",
          "topic": "CIA #2 Data Port B (user port/RS-232) bit definitions"
        }
      ]
    },
    {
      "start": 15884,
      "end": 15890,
      "name": "page_header_324_ignored",
      "description": "IGNORED (non-technical): page header/footer and spacing lines for the printed manual (\"324 BASIC TO MACHINE LANGUAGE\" and surrounding formatting).",
      "references": [
        {
          "chunk": "cia2_overview_and_dd00_port_a",
          "topic": "previous CIA #2 Port A content"
        },
        {
          "chunk": "cia2_dd01_port_b",
          "topic": "continued CIA #2 register descriptions"
        }
      ],
      "ignore": true,
      "reason": "IGNORED (non-technical): page header/footer and spacing lines for the printed manual (\"324 BASIC TO MACHINE LANGUAGE\" and surrounding formatting)."
    },
    {
      "start": 15891,
      "end": 15901,
      "name": "cia2_dd01_port_b",
      "description": "CIA #2 Data Port B (DD01/$56577) \u2014 User Port / RS-232 status and control bits: bit 7 Data Set Ready, bit 6 Clear to Send, bit 5 user-defined, bit 4 Carrier Detect, bit 3 Ring Indicator, bit 2 Data Terminal Ready, bit 1 Request to Send, bit 0 Received Data. (Includes the table header and underline for this register block.)",
      "references": [
        {
          "chunk": "cia2_overview_and_dd00_port_a",
          "topic": "CIA #2 Data Port A and VIC memory bank select"
        }
      ]
    },
    {
      "start": 15902,
      "end": 16000,
      "name": "cia2_registers_and_reserved_ios",
      "description": "CIA #2 (MOS 6526) mapping at $DD00-$DDFF: DD00 data port A for serial bus/RS-232/VIC memory control (bits include serial bus data/clock inputs/outputs, ATN), DD01 data port B shows user port/RS-232 lines (DTR, RTS, CTS, DSR, RI, etc). DD02/DD03 data direction registers; DD04-DD07 timers; DD08-DD0B TOD clock; DD0C serial I/O buffer; DD0D-DD0F interrupt/control registers (NMI flags and mask). DE00-DEFF and DF00-DFFF reserved for future I/O expansion. Followed by formatting markers.",
      "references": [
        {
          "chunk": "user_port_table",
          "topic": "User-port lines and RS-232 signals described later"
        }
      ]
    },
    {
      "start": 16001,
      "end": 16028,
      "ignore": true,
      "reason": "Page header, chapter break and formatting"
    },
    {
      "start": 16029,
      "end": 16030,
      "ignore": true,
      "reason": "Formatting/two-line break"
    },
    {
      "start": 16031,
      "end": 16075,
      "name": "input_output_guide_chapter_header",
      "description": "Chapter 6: Input/Output Guide \u2014 lists chapter contents: Introduction, Output to TV, Output to other devices, Game Ports, RS-232, User Port, Serial Bus, Expansion Port, Z-80 Microprocessor Cartridge.",
      "references": [
        {
          "chunk": "output_to_tv_section",
          "topic": "Output to TV (chapter content)"
        },
        {
          "chunk": "rs232_interface_description",
          "topic": "RS-232 interface (later in chapter)"
        }
      ]
    },
    {
      "start": 16076,
      "end": 16080,
      "ignore": true,
      "reason": "Formatting/section spacing"
    },
    {
      "start": 16081,
      "end": 16103,
      "name": "introduction_io_guide",
      "description": "Introduction to I/O: discussion of computers' abilities (calculate, decide, communicate), focusing on communication complexity and formatting of output for human-readable display. Leads into TV output section.",
      "references": [
        {
          "chunk": "output_to_tv_section",
          "topic": "Output to the TV"
        }
      ]
    },
    {
      "start": 16104,
      "end": 16163,
      "name": "output_to_tv_section",
      "description": "Output to the TV: Using BASIC PRINT statement to display on screen. Discusses cursor control codes and special functions (TAB, SPC). Mentions character code for RETURN (CHR$ 13) and that control codes affect cursor and screen formatting. Refers to VIC chip and graphics chapter for colors and screen manipulation, and sound chapter for audio.",
      "references": [
        {
          "chunk": "vic_registers_overview",
          "topic": "VIC chip controls colors and screen modes"
        }
      ]
    },
    {
      "start": 16164,
      "end": 16199,
      "name": "print_formatting_and_punctuation",
      "description": "How PRINT punctuation affects output: semicolon suppresses RETURN and no space; comma separates into columns (4 columns of 10 chars each on C64) and can suppress RETURN if last; quote marks delimit literal text; RETURN code moves to next logical line; logical lines may span screen lines and link via line link table.",
      "references": [
        {
          "chunk": "memory_map_part3_screen_video_rom_ram",
          "topic": "Screen memory and line link table location"
        }
      ]
    },
    {
      "start": 16200,
      "end": 16277,
      "name": "output_to_other_devices_overview",
      "description": "Output to other devices (cassette, printer, disk, modem): use OPEN to create channel, then PRINT# to send characters. The OPEN parameters differ by device. Discusses formatting implications when sending to non-screen devices (e.g., TAB doesn't behave same for printers).",
      "references": [
        {
          "chunk": "open_kernal_routine",
          "topic": "OPEN implementation for BASIC via KERNAL OPEN"
        }
      ]
    },
    {
      "start": 16278,
      "end": 16317,
      "name": "open_statement_parameters_table",
      "description": "Table of OPEN statement parameters format: OPEN file#, device#, number, string. Lists device numbers and meanings for cassette(1), modem(2), screen(3), printer(4/5), disk(8-11). Explains number field variations and string usage.",
      "references": [
        {
          "chunk": "save_kernal_routine",
          "topic": "Saving to device via SAVE requires SETLFS/SETNAM"
        }
      ]
    },
    {
      "start": 16318,
      "end": 16399,
      "name": "output_to_printer_details",
      "description": "Output to printer: formatting concerns, SPC works but TAB doesn't, OPEN statement selects character set for printer (upper/graphics or upper/lower). Provides control character codes for printer (CHR$ codes like 10 LF, 13 RETURN, 14 begin double-width, 15 end double-width, 18 begin reverse, 146 end reverse, 17/145 switch sets, 16 tab positions, 27 move to dot position, 8 begin dot graphics, 26 repeat graphics). Recommends consulting printer manual for details.",
      "references": [
        {
          "chunk": "open_statement_parameters_table",
          "topic": "OPEN parameters for printer device numbers and modes"
        }
      ]
    },
    {
      "start": 16400,
      "end": 16505,
      "name": "output_to_modem_and_ascii_notes",
      "description": "Output to modem: OPEN parameters set baud and format via two characters at end of OPEN. Discusses control/command register usage and ASCII translation between Commodore character set and ASCII when communicating with other computers. Examples of OPEN for modems provided. Advises on careful character counting for automated terminal interactions.",
      "references": [
        {
          "chunk": "rs232_interface_description",
          "topic": "RS-232 modem connection and settings"
        }
      ]
    },
    {
      "start": 16506,
      "end": 16616,
      "name": "working_with_cassette_tape",
      "description": "Cassette tape storage: characteristics and programming considerations. Advises reading an entire cassette file into RAM for editing if possible, otherwise use disk for large files. Discusses PRINT# formatting pitfalls (commas create variable-width spacing on tape) and suggests using explicit separators (commas or CHR$(13)) between data items on tape to ensure INPUT# works correctly. Shows examples of correct and incorrect tape data layout.",
      "references": [
        {
          "chunk": "save_kernal_routine",
          "topic": "KERNAL SAVE used to write memory sections to cassette"
        }
      ]
    },
    {
      "start": 16617,
      "end": 16722,
      "name": "data_formatting_on_tape_and_get_function",
      "description": "Explains GET# behavior: GET# returns characters including RETURN and punctuation. CHR$(0) is received as empty string; ASC on empty string causes error. Suggests technique GET#1,A$: A=ASC(A$+CHR$(0)) to avoid error on empty strings. Also discussed that PRINT# places RETURN at end of a PRINT#, and strategy for inserting separators between items.",
      "references": [
        {
          "chunk": "working_with_cassette_tape",
          "topic": "Tape formatting details and separators"
        }
      ]
    },
    {
      "start": 16723,
      "end": 16812,
      "name": "disk_file_storage_overview",
      "description": "Diskette data storage types: Sequential, Relative, and Random. Discusses characteristics of each and notes printing/formatting limitations similar to tape (need separators). Relative and random files use separate data and command channels. Recommends relative files for large datasets. Suggests consulting disk drive manual for detailed programming guidance.",
      "references": [
        {
          "chunk": "open_statement_parameters_table",
          "topic": "OPEN parameters for disk devices (device 8..11)"
        }
      ]
    },
    {
      "start": 16813,
      "end": 16916,
      "name": "rs232_receive_transmit_overview_and_kernal_entries",
      "description": "RS-232 receive/transmit behavior: receive buffer overflow behavior and advice to use machine language for high-speed data; BASIC syntax recommendations (GET# preferred, INPUT# not recommended); KERNAL entry points for RS-232 I/O: CHKIN ($FFC6), GETIN ($FFE4), CHRIN ($FFCF), CHKOUT ($FFC9), CHROUT ($FFD2), CLOSE ($FFC3). Notes about buffer sizes (receive buffer behavior, output buffer 255 chars) and system recovery (<RUN/STOP> + <RESTORE> warm start).",
      "references": [
        {
          "chunk": "rs232_user_port_and_status_examples",
          "topic": "RS-232 status register and sample BASIC programs that use GET#/PRINT#"
        },
        {
          "chunk": "rs232_buffer_and_memory_locations",
          "topic": "Receiver/Transmitter buffer base pointers ($00F7/$00F9) and zero/nonzero page locations"
        }
      ]
    },
    {
      "start": 16917,
      "end": 16926,
      "name": "joystick_switch_mapping_and_basic_example",
      "description": "Joystick switch mapping diagram and explanation: five switches (up, down, left, right, fire) map to lower 5 bits of CIA port A/B ($DC00/$DC01). Bits are 1 when open, 0 when closed. Provides BASIC subroutine that reads joystick via PEEK(56320) and decodes direction and fire button. Notes how to use PEEK(56321) for second joystick.",
      "references": [
        {
          "chunk": "joystick_examples_basic_and_assembly",
          "topic": "Includes BASIC and assembly examples for joystick handling"
        }
      ]
    },
    {
      "start": 16927,
      "end": 16950,
      "name": "user_port_rs232_pin_assignments",
      "description": "User-port / RS-232 pin assignments for CIA #2 (6526, $DD00-$DD0F). Lists connector pin IDs, 6526 port bits (PB0-PB7, PA2, FLAG2), EIA signal names and abbreviations (Sin/Sout, RTS, DTR, RI, DCD, CTS, DSR), input/output direction, and which interface modes (3-line, X-line, user-available) each pin supports. Also defines the interface modes and notes lines held high during 3-line mode.",
      "references": [
        {
          "chunk": "rs232_status_register_bits_and_usage",
          "topic": "RS-232 status bits and how to read/clear them (ST)"
        },
        {
          "chunk": "rs232_buffer_base_pointers",
          "topic": "Receiver/Transmitter buffer base pointers used by OPEN/CLOSE"
        },
        {
          "chunk": "sample_basic_program_pet_ascii",
          "topic": "Example BASIC program that uses the 3-line RS-232 interface"
        }
      ]
    },
    {
      "start": 16951,
      "end": 16984,
      "name": "rs232_status_register_bits_and_usage",
      "description": "RS-232 Status Register layout and usage. Bit-by-bit definitions: parity error, framing error, receiver buffer overrun, receiver buffer-empty (use after GET#), CTS signal missing, unused bit, DSR signal missing, and BREAK detected. Notes: BIT=0 means no error; how BASIC reads the status using the ST variable; reading ST (or KERNAL READST) clears the status word when you exit; advice to assign ST to another variable (e.g., SR=ST) if multiple uses of the status word are needed; the RS-232 status is read/cleared only when the RS-232 channel was the last external I/O used.",
      "references": [
        {
          "chunk": "user_port_rs232_pin_assignments",
          "topic": "Which hardware signals correspond to the status conditions"
        },
        {
          "chunk": "sample_basic_program_pet_ascii",
          "topic": "Example showing SR=ST and status bit testing"
        },
        {
          "chunk": "rs232_nonzero_page_control_and_fifos",
          "topic": "RSSTAT nonzero-page location that holds the status register"
        }
      ]
    },
    {
      "start": 16985,
      "end": 17010,
      "name": "sample_basic_program_pet_ascii",
      "description": "Sample BASIC program (tok64 page356.prg) demonstrating sending/receiving data to/from a modified Silent 700 terminal (PET ASCII). Includes OPEN of channel 2, enabling receiver (GET#), main loop reading keyboard and terminal (GET, GET#), sending with PRINT#2, reading and saving status with SR=ST, testing status bits and reporting parity/frame/receiver buffer full/break errors, waiting for transmission completion (PEEK 673), and CLOSE.",
      "references": [
        {
          "chunk": "rs232_status_register_bits_and_usage",
          "topic": "Uses SR=ST to test parity, framing, overrun and break bits"
        },
        {
          "chunk": "user_port_rs232_pin_assignments",
          "topic": "Hardware modes used for 3-line RS-232 interface in the example"
        },
        {
          "chunk": "rs232_buffer_base_pointers",
          "topic": "OPEN/CLOSE interactions with receiver/transmitter buffer base pointers"
        }
      ]
    },
    {
      "start": 17011,
      "end": 17042,
      "name": "sample_basic_program_true_ascii",
      "description": "Sample BASIC program (tok64 page357.prg) for sending/receiving true ASCII data. Shows OPEN 5,2,3,chr$(6), creation of mapping tables (f% and t%) to translate between terminal and computer character sets (including mappings for ASCII ranges and special translations), main input loop using GET# and ST checks, printing translated characters to the screen or sending to RS-232, and control variables for display/translation behavior.",
      "references": [
        {
          "chunk": "rs232_status_register_bits_and_usage",
          "topic": "Checks ST (status) to determine when input is available and valid"
        },
        {
          "chunk": "rs232_nonzero_page_control_and_fifos",
          "topic": "Nonzero page control words (baud, bit count, RSSTAT) used by the system routines the program relies on"
        }
      ]
    },
    {
      "start": 17043,
      "end": 17059,
      "name": "rs232_buffer_base_pointers",
      "description": "Receiver/Transmitter buffer base location pointers used by the KERNAL RS-232 open/close. $00F7-REBUF: two-byte pointer to Receiver Buffer base. $00F9-ROBUF: two-byte pointer to Transmitter Buffer base. These pointers are set by the OPEN KERNAL routine (each pointing to a different 256-byte buffer) and de-allocated by writing zero into the high-order bytes ($00F8 and $00FA) by CLOSE. Notes on manual allocation/de-allocation by machine-language programs and caution about keeping top-of-memory pointers correct when BASIC and ML programs coexist.",
      "references": [
        {
          "chunk": "rs232_zero_page_variables",
          "topic": "Zero-page variables are used by the routines that operate on these buffers"
        },
        {
          "chunk": "sample_basic_program_pet_ascii",
          "topic": "OPEN/CLOSE in the sample program sets/clears these buffer pointers"
        }
      ]
    },
    {
      "start": 17060,
      "end": 17080,
      "name": "receiver_transmitter_buffer_pointers_and_zero_page_rs232_locations",
      "description": "Documentation of the KERNAL-managed receiver/transmitter buffer base pointers and zero-page temporaries used by the RS-232 system interface. Covers: the two-byte base pointers $00F7 (REBUF) and $00F9 (ROBUF), how OPEN sets them and CLOSE deallocates them (by zeroing the high-order bytes $00F8/$00FA), warning about manual allocation and top-of-memory pointer correctness. Also lists zero-page locations $00A7-$00B6 used locally by the RS-232 routines: INBIT, BITCI, RINONE, RIDATA, RIPRTY, BITTS, NXTBIT, RODATA and notes that these are internal temporaries for the system routines and not directly usable by BASIC/KERNAL-level programmers.",
      "references": [
        {
          "chunk": "rs232_simple_bidi_basic_echo_program",
          "topic": "Programs that make use of the OPEN/CLOSE behavior described here"
        },
        {
          "chunk": "rs232_true_ascii_send_receive_basic",
          "topic": "Example BASIC program that depends on proper buffer allocation"
        },
        {
          "chunk": "nonzero_page_rs232_memory_locations_and_fifo_status",
          "topic": "Nonzero-page RS-232 storage complements the zero-page temporaries described here"
        }
      ]
    },
    {
      "start": 17081,
      "end": 17123,
      "name": "rs232_nonzero_page_control_and_fifos",
      "description": "Nonzero-page memory locations and usage for the RS-232 system interface and FIFO indices. Includes: $0293 M51CTR (pseudo 6551 control register), $0294 M51COR (pseudo 6551 command register), $0295 M51AJB (two bytes following the control/command registers used to contain baud-rate timing info), $0297 RSSTAT (RS-232 status register), $0298 BITNUM (number of bits to send/receive), $0299 BAUDOF (two bytes equal to time of one bit cell based on system clock/baud rate). Also lists FIFO indices: $029B RIDBE (receiver FIFO end index), $029C RIDBS (receiver FIFO start), $029D RODBS (transmitter FIFO start), $029E RODBE (transmitter FIFO end), and $02A1 ENABL (holds current active interrupts in CIA #2 ICR) with notes: bit 4 = waiting for Receiver Edge, bit 1 = receiving data, bit 0 = transmitting data. (Includes trailing page/footer lines.)",
      "references": [
        {
          "chunk": "rs232_zero_page_variables",
          "topic": "Zero-page bit/byte handlers work with these nonzero-page control words"
        },
        {
          "chunk": "rs232_status_register_bits_and_usage",
          "topic": "RSSTAT ($0297) is the nonzero-page location for status described earlier"
        },
        {
          "chunk": "sample_basic_program_true_ascii",
          "topic": "Programs using RS-232 depend on these control/FIFO locations indirectly via system routines"
        }
      ]
    },
    {
      "start": 17124,
      "end": 17132,
      "name": "user_port_overview",
      "description": "Introductory overview of the Commodore 64 USER port: purpose (connecting C64 to external devices like printers, modem, another computer), and note that the port is directly connected to a 6526 CIA chip which enables programmable I/O.",
      "references": [
        {
          "chunk": "user_port_connector_and_pin_descriptions",
          "topic": "connector diagram and detailed pin descriptions"
        },
        {
          "chunk": "user_port_data_direction_register_ddr_usage",
          "topic": "how the CIA programs port lines as inputs/outputs"
        }
      ]
    },
    {
      "start": 17133,
      "end": 17198,
      "name": "user_port_connector_and_pin_descriptions",
      "description": "ASCII connector diagram and complete top-side (pins 1-12) and bottom-side (pins A-N) pin descriptions for the USER port. Covers GND, +5V, RESET (cold start behavior), CNT1/SP1/CNT2/SP2/PC2 (CIA serial/handshaking lines), SERIAL ATN, 9VAC phases, and PORT B / PORT A signals (PB0-PB7, FLAG2, PA2) including mention of the PORT B register address at 56577 ($DD01) and that data direction controls whether each PB line is input or output.",
      "references": [
        {
          "chunk": "user_port_overview",
          "topic": "general purpose and CIA connection"
        },
        {
          "chunk": "user_port_data_direction_register_ddr_usage",
          "topic": "how to set PB lines as input or output via the DDR"
        },
        {
          "chunk": "user_port_flag1_and_pa2_handshaking",
          "topic": "special handling of FLAG1/FLAG2 and PA2 signals"
        }
      ]
    },
    {
      "start": 17199,
      "end": 17231,
      "name": "user_port_data_direction_register_ddr_usage",
      "description": "Explanation of the DATA DIRECTION REGISTER (DDR) for the USER port at location 56579 ($DD03). Describes that each of the eight PORT lines has a corresponding DDR bit: 1 = output, 0 = input. Includes a bit-number/value example (bits 7..0 with VALUE: 0 0 1 1 1 0 0 0) and shows converting the bit pattern into a decimal value for use with PEEK/POKE (2^5 + 2^4 + 2^3 = 56). Notes that PEEK/POKE require 0-255 decimal values.",
      "references": [
        {
          "chunk": "user_port_connector_and_pin_descriptions",
          "topic": "which physical pins correspond to PORT bits (PB0-PB7)"
        },
        {
          "chunk": "user_port_flag1_and_pa2_handshaking",
          "topic": "how FLAG1 and PA2 differ from normal port lines and are used for handshaking"
        }
      ]
    },
    {
      "start": 17232,
      "end": 17260,
      "name": "user_port_flag1_and_pa2_handshaking",
      "description": "Details on the special USER PORT lines FLAG1 (negative-edge sensitive input) and PA2 (bit 2 of PORT A). Explains that FLAG1 is well suited for handshaking and can generate an interrupt request on any negative transition if the FLAG interrupt is enabled (otherwise it may be polled). PA2 is a normal port bit (bit 2 of PORT A) located at 56576 ($DD00) with its data direction register at 56578 ($DD02). Reference to 6526 CIA chip specifications in Appendix M is provided.",
      "references": [
        {
          "chunk": "user_port_data_direction_register_ddr_usage",
          "topic": "DDR addresses and how PA2/flag interact with port configuration"
        },
        {
          "chunk": "user_port_connector_and_pin_descriptions",
          "topic": "physical pin locations for FLAG lines and PA2"
        }
      ]
    },
    {
      "start": 17261,
      "end": 17298,
      "name": "serial_bus_overview",
      "description": "Overview of the Commodore 64 serial bus: daisy-chain arrangement used to connect devices (e.g., VIC-1541 disk drive, VIC-1525 printer), supports up to 5 devices, and provides three operation roles (CONTROLLER, TALKER, LISTENER). Describes the C64 as the controller (and optionally talker/listener), explains device addressing on the bus (addresses 4\u201331), and the concepts of commanding devices to TALK or LISTEN to route data to an intended destination without collisions.",
      "references": [
        {
          "chunk": "serial_bus_common_addresses",
          "topic": "common device addresses used on the serial bus"
        },
        {
          "chunk": "serial_bus_secondary_address_and_open_syntax",
          "topic": "how to OPEN a connection and use secondary addresses for device setup"
        },
        {
          "chunk": "serial_bus_signal_lines_and_pinout",
          "topic": "the physical serial I/O lines used and their pin mapping"
        }
      ]
    },
    {
      "start": 17299,
      "end": 17306,
      "name": "serial_bus_common_addresses",
      "description": "Table of common serial bus device addresses: examples include 4 or 5 for the VIC-1525 graphic printer and 8 for the VIC-1541 disk drive. Notes that other addresses are possible and some devices offer a choice between addresses.",
      "references": [
        {
          "chunk": "serial_bus_overview",
          "topic": "context for address ranges and bus roles"
        },
        {
          "chunk": "serial_bus_secondary_address_and_open_syntax",
          "topic": "secondary address usage for device configuration (OPEN command example)"
        }
      ]
    },
    {
      "start": 17307,
      "end": 17321,
      "name": "serial_bus_secondary_address_and_open_syntax",
      "description": "Explanation of the SECONDARY ADDRESS concept on the serial bus for transmitting setup information to a device. Includes example OPEN 1,4,7 and explains the meaning of the three fields: logical file number (1), device address (4), and secondary address (7) to set device mode (e.g., printer upper/lower case).",
      "references": [
        {
          "chunk": "serial_bus_common_addresses",
          "topic": "which primary addresses correspond to common devices"
        },
        {
          "chunk": "serial_bus_signal_lines_and_pinout",
          "topic": "how serial commands are transported over the physical serial lines"
        }
      ]
    },
    {
      "start": 17322,
      "end": 17338,
      "name": "serial_bus_signal_lines_and_pinout",
      "description": "Lists the six serial bus signal lines (3 inputs and 3 outputs) used for data, control, and timing between the Commodore 64 and external serial devices. Includes an ASCII serial I/O pin mapping table: pin 1 /SERIAL SRQ IN, pin 2 GND, pin 3 SERIAL ATN OUT, pin 4 SERIAL CLK IN/OUT, pin 5 SERIAL DATA IN/OUT, pin 6 /RESET, with an accompanying connector diagram.",
      "references": [
        {
          "chunk": "serial_bus_overview",
          "topic": "overview of serial bus roles and addressing"
        },
        {
          "chunk": "serial_bus_common_addresses",
          "topic": "examples of device addresses used on the bus"
        }
      ]
    },
    {
      "start": 17339,
      "end": 17385,
      "name": "serial_service_request_srq_in_and_figure_reference",
      "description": "Describes the SERIAL SRQ IN (Serial Service Request In) line: any device on the serial bus can pull this signal low to request attention from the Commodore 64; the C64 then services the device. Includes the Figure 6-4 placeholder and caption indicating 'Serial Bus Timing' (picture missing in source).",
      "references": [
        {
          "chunk": "serial_atn_out_and_timing_table",
          "topic": "ATN signal and full serial bus timing table"
        },
        {
          "chunk": "serial_clock_data_and_expansion_port_pinout",
          "topic": "Serial clock/data signals and expansion port that follow"
        }
      ]
    },
    {
      "start": 17386,
      "end": 17436,
      "name": "serial_atn_out_and_timing_table",
      "description": "Covers SERIAL ATN OUT (Serial Attention Out): how the C64 initiates command sequences by pulling ATN low, causing all devices to listen for an address; devices must respond within a preset time or the C64 returns a device-not-present error. Includes the SERIAL BUS TIMING table with timing symbols (Tat, Th, Tne, Ts, Tv, Tf, Tr, Tbb, Tye, Tei, Try, Tpr, Ttk, Tdc, Tda, Tfr) and the notes specifying error conditions and minimum timing requirements for external talkers/listeners.",
      "references": [
        {
          "chunk": "serial_service_request_srq_in_and_figure_reference",
          "topic": "SRQ behavior and Figure 6-4 reference"
        },
        {
          "chunk": "serial_clock_data_and_expansion_port_pinout",
          "topic": "Physical serial clock/data lines and the expansion port that follows"
        }
      ]
    },
    {
      "start": 17437,
      "end": 17528,
      "name": "serial_clock_data_lines_and_expansion_port_pinout",
      "description": "Describes SERIAL CLK IN/OUT (serial clock) and SERIAL DATA IN/OUT (bit-serial data line) used for timing and data transfer on the serial bus. Then documents THE EXPANSION PORT: location and connector type (44-pin female edge connector), usage caution, pin diagram/layout, and a complete pin signal table listing pin numbers, signal names and detailed descriptions for all 44 pins (ground, +5V, /IRQ, R/W, DOT CLOCK, /I/O1, /GAME, /EXROM, /I/O2, /ROML, BA, /DMA, data bus D7-D0, grounds, /ROMH, /RESET, /NMI, 02, address bus lines A15-A0, and others), including notes about buffering and load limits.",
      "references": [
        {
          "chunk": "serial_atn_out_and_timing_table",
          "topic": "Serial bus timing constraints and ATN-driven command sequences"
        },
        {
          "chunk": "serial_service_request_srq_in_and_figure_reference",
          "topic": "SRQ signaling and Figure 6-4 reference"
        }
      ]
    },
    {
      "start": 17529,
      "end": 17553,
      "name": "expansion_port_signal_descriptions",
      "description": "Descriptions of important signals on the C64 expansion port: system ground pins (1, 22, A, Z); Pin 6 DOT CLOCK (8.18 MHz) as the master video dot clock and system timing source; Pin 12 BA (BUS AVAILABLE) from the VIC-II, which goes low 3 cycles before the VIC-II takes over the system buses and stays low while display fetches occur; Pin 13 DMA behavior \u2014 when low the 6510 address/data/RW lines enter high-impedance to allow an external processor to take over buses, timing cautions (must be pulled low only when \u03c62 clock is low), VIC-II DMA implications, and that the DMA line is pulled up on the C64.",
      "references": [
        {
          "chunk": "z80_cartridge_and_cpm_overview",
          "topic": "Z-80 cartridge plugs into expansion port and relies on expansion bus signals"
        },
        {
          "chunk": "z80_enable_basic_program",
          "topic": "Program uses bus-control signals (enabling Z-80 and disabling 6510 IRQs) described here"
        }
      ]
    },
    {
      "start": 17554,
      "end": 17611,
      "name": "z80_cartridge_and_cpm_overview",
      "description": "Overview of the Z-80 microprocessor cartridge for the Commodore 64: motivation for using the cartridge to run CP/M software, tradeoffs of CP/M on the C64 (uses part of memory, shorter programs, no native screen editing but portability to other Z-80/CP/M systems), advantages of the external cartridge (no internal installation required), and that the cartridge is supplied with a diskette containing the Commodore CP/M operating system.",
      "references": [
        {
          "chunk": "expansion_port_signal_descriptions",
          "topic": "Physical cartridge interfaces with expansion port signals"
        },
        {
          "chunk": "running_commodore_cpm_steps",
          "topic": "How to start the CP/M operating system provided on the cartridge/disk"
        }
      ]
    },
    {
      "start": 17612,
      "end": 17619,
      "name": "running_commodore_cpm_steps",
      "description": "Simple step-by-step instructions to run the Commodore CP/M provided with the Z-80 cartridge: (1) LOAD the CP/M program from disk, (2) type RUN, (3) press RETURN.",
      "references": [
        {
          "chunk": "z80_cartridge_and_cpm_overview",
          "topic": "Background on the cartridge and CP/M disk supplied"
        },
        {
          "chunk": "z80_memory_address_translation",
          "topic": "Memory layout and address translation used once CP/M/Z-80 runs"
        }
      ]
    },
    {
      "start": 17620,
      "end": 17663,
      "name": "z80_memory_address_translation",
      "description": "Explanation and full mapping table translating Z-80 memory addresses to the 6510 (Commodore 64) address space. Notes that the Z-80 sees 48K of RAM and that adding 4096 (0x1000) to Z-80 addresses corresponds to the 6510 OS addresses; includes the full decimal and hex ranges for each mapped block.",
      "references": [
        {
          "chunk": "running_commodore_cpm_steps",
          "topic": "How to start CP/M which then runs using the memory mapping described"
        },
        {
          "chunk": "z80_enable_basic_program",
          "topic": "Program stores Z-80 code at $1000 (Z-80 $0000) which relates to the address translation table"
        }
      ]
    },
    {
      "start": 17664,
      "end": 17706,
      "name": "z80_enable_basic_program",
      "description": "BASIC program listing (tok64) used to turn ON the Z-80 and TURN OFF the 6510: program logic and remarks showing storing Z-80 code at $1000 (Z-80 $0000), poking locations to disable 6510 IRQs (POKE 56333,127), enable the Z-80 card (POKE 56832,00), re-enable 6510 IRQs when done (POKE 56333,129), data blocks containing Z-80 machine code and turn-on/turn-off sequences, and an example data section with Z-80 opcodes and a jump to $0000.",
      "references": [
        {
          "chunk": "expansion_port_signal_descriptions",
          "topic": "Relies on bus control and DMA/IRQ behavior of the expansion bus"
        },
        {
          "chunk": "z80_memory_address_translation",
          "topic": "The program stores Z-80 code at C64 address $1000 which maps to Z-80 $0000 per the translation table"
        }
      ]
    },
    {
      "start": 17707,
      "end": 17711,
      "name": "cp_m_and_z80_cartridge_note",
      "description": "Closing note directing the reader to look for the Commodore CP/M cartridge and the Z-80 Reference Guide at local Commodore dealers for more details about CP/M and the Z-80 microprocessor.",
      "references": [
        {
          "chunk": "appendices_page_header_ignored",
          "topic": "follows into the appendices section"
        }
      ],
      "ignore": true,
      "reason": "audit: No technical information\u2014only a dealer notice directing readers to obtain CP/M cartridge and Z-80 guide."
    },
    {
      "start": 17712,
      "end": 17766,
      "name": "appendices_page_header_ignored",
      "description": "Non-technical page layout, spacing, and header information introducing the appendices section (page headers, blank space, and decorative elements). This section is marked as ignored for technical indexing.",
      "references": [
        {
          "chunk": "appendix_a_intro_abbreviations",
          "topic": "leads into APPENDIX A"
        }
      ],
      "ignore": true,
      "reason": "Non-technical page layout, spacing, and header information introducing the appendices section (page headers, blank space, and decorative elements). This section is marked as ignored for technical indexing."
    },
    {
      "start": 17767,
      "end": 17778,
      "name": "appendix_a_intro_abbreviations",
      "description": "APPENDIX A title and introductory explanation of Commodore 64 BASIC keyword abbreviations: how abbreviations are formed (first one or two letters plus the shifted next letter), the special case of PRINT as '?', and the note that abbreviations used in program lines will LIST in full form.",
      "references": [
        {
          "chunk": "basic_abbreviations_table_part1",
          "topic": "contains the first portion of the keyword abbreviation table (ABS through RND)"
        },
        {
          "chunk": "basic_abbreviations_table_part2",
          "topic": "contains the continuation of the abbreviation table (LET through WAIT)"
        }
      ]
    },
    {
      "start": 17779,
      "end": 17811,
      "name": "basic_abbreviations_table_part1",
      "description": "First part of the Commodore 64 BASIC keyword abbreviation table. Shows how abbreviations 'look on screen' beside full commands; covers commands from ABS, AND, ASC, ATN, CHR$, CLOSE, CLR, CMD, CONT, COS, DATA, DEF, DIM, LEFT$, LEN, LET?, (up through RND). Includes the table column headers and formatting for the first page of the list.",
      "references": [
        {
          "chunk": "appendix_a_intro_abbreviations",
          "topic": "explains how these abbreviations are formed and used"
        },
        {
          "chunk": "basic_abbreviations_table_part2",
          "topic": "continues the table with the remaining commands"
        }
      ]
    },
    {
      "start": 17812,
      "end": 17862,
      "name": "basic_abbreviations_table_part2",
      "description": "Continuation and completion of the Commodore 64 BASIC keyword abbreviation table (page continuation). Covers commands from LET, LIST, LOAD, LOG, MID$, NEW, NEXT, NOT, ON, OPEN, OR, PEEK, POKE, POS, PRINT, PRINT#, READ, REM, RESTORE, RETURN, END, EXP, FN, FOR, FRE, GET, GET#, GOSUB, GOTO, IF, INPUT, INPUT#, INT, LEFT$/RIGHT$/LEN/RND entries as they appear across the page break, and finishes with commands like RUN, SAVE, SGN, SIN, SPC(, SQR, STATUS, STEP, STOP, STR$, SYS, TAB(, TAN, THEN, TIME, TIME$, USR, VAL, VERIFY, WAIT. Also includes page headers/footers on the continuation page.",
      "references": [
        {
          "chunk": "basic_abbreviations_table_part1",
          "topic": "previous page of the abbreviation table"
        },
        {
          "chunk": "appendix_a_intro_abbreviations",
          "topic": "describes abbreviation formation and behavior"
        }
      ]
    },
    {
      "start": 17863,
      "end": 17886,
      "name": "screen_display_codes_overview",
      "description": "Overview of the Commodore 64 screen display codes: explains that screen memory (locations 1024-2023) is filled by POKEing numeric character codes, that two mutually exclusive character sets exist (switched by <SHIFT>+<C=>), how to switch case from BASIC using POKE 53272,21 and POKE 53272,23, how to obtain reversed characters by adding 128, an example showing POKE 1504,81 to draw a solid circle, and the corresponding color memory range (55296-56295) with an example POKE 55776,7 to set color. Also notes to refer to Appendix D for complete screen and color memory maps and color codes.",
      "references": [
        {
          "chunk": "screen_display_codes_table",
          "topic": "Complete mapping table of SET 1/SET 2 POKE values (codes 0\u2013127) and note about reversed images (128\u2013255)"
        }
      ]
    },
    {
      "start": 17887,
      "end": 18003,
      "name": "screen_display_codes_table",
      "description": "The full SCREEN CODES table and related notes: includes a boxed NOTE listing POKE values that display the same symbol in set 1 and set 2, the three-column table mapping SET 1 and SET 2 characters to POKE codes (covering codes 0 through 127 across the printed page break), and the final note that codes 128\u2013255 are reversed images of codes 0\u2013127.",
      "references": [
        {
          "chunk": "screen_display_codes_overview",
          "topic": "Overview and usage examples (how to POKE codes into screen memory, switching character sets, reversing characters, and color memory references)"
        }
      ]
    },
    {
      "start": 18004,
      "end": 18050,
      "name": "appendix_c_intro_and_ascii_chr_codes_0_63",
      "description": "Appendix C title and introduction explaining PRINT CHR$(X) and PRINT ASC(\"x\") usage; table showing what PRINT CHR$(X) produces for character codes 0\u201363 (control characters, cursor/color keys, punctuation, digits, basic symbols). Includes the page footer and nearby spacing from the original layout.",
      "references": [
        {
          "chunk": "ascii_chr_codes_68_183",
          "topic": "Continued CHR$ table covering codes 68\u2013183 (letters, function keys, extended graphics/colors)"
        },
        {
          "chunk": "ascii_chr_codes_184_191_and_extended_mappings",
          "topic": "Remaining CHR$ values and extended-code mapping notes (184\u2013255)"
        }
      ]
    },
    {
      "start": 18051,
      "end": 18097,
      "name": "ascii_chr_codes_68_183",
      "description": "Continuation of the CHR$ tables showing what PRINT CHR$(X) produces for codes roughly 68\u2013183. Contains mappings for uppercase letters A\u2013Z (65\u201390 region), bracket/arrow/pound symbols, function-key and special-key glyphs (f1\u2013f8, shift/return, upper/lower case indicators), and the color/graphics character codes in the 129\u2013159 and 144\u2013158 ranges. Includes the page footer and surrounding spacing from the scanned layout.",
      "references": [
        {
          "chunk": "appendix_c_intro_and_ascii_chr_codes_0_63",
          "topic": "Initial CHR$ table and introduction covering codes 0\u201363"
        },
        {
          "chunk": "ascii_chr_codes_184_191_and_extended_mappings",
          "topic": "Final CHR$ entries (184\u2013191) and notes about how codes 192\u2013255 map to earlier ranges"
        }
      ]
    },
    {
      "start": 18098,
      "end": 18143,
      "name": "ascii_chr_codes_184_191_and_extended_mappings",
      "description": "Final CHR$ table fragment showing codes in the 184\u2013191 range and the summary notes for extended codes: 'CODES 192-223 SAME AS 96-127', 'CODES 224-254 SAME AS 160-190', and 'CODE 255 SAME AS 126'. Includes trailing page footer/spacing from the original document.",
      "references": [
        {
          "chunk": "appendix_c_intro_and_ascii_chr_codes_0_63",
          "topic": "Intro and first CHR$ table covering codes 0\u201363"
        },
        {
          "chunk": "ascii_chr_codes_68_183",
          "topic": "Middle CHR$ table covering codes 68\u2013183 (letters, function keys, colors)"
        }
      ]
    },
    {
      "start": 18144,
      "end": 18238,
      "name": "appendix_d_screen_and_color_memory_maps",
      "description": "APPENDIX D: Screen and color memory maps: locations for character screen memory (1024-2023) and color memory (55296-56295). Shows layout of rows/columns and example POKE (e.g., POKE 55296,2 to make upper-left character red). Color codes listed (0-15) with names: 0 BLACK, 1 WHITE, 2 RED, 3 CYAN, 4 PURPLE, 5 GREEN, 6 BLUE, 7 YELLOW, 8 ORANGE, 9 BROWN, 10 LIGHT RED, 11 GRAY1, 12 GRAY2, 13 LIGHT GREEN, 14 LIGHT BLUE, 15 GRAY3. Note: Only colors 0-7 usable in multicolor character mode.",
      "references": [
        {
          "chunk": "appendix_b_screen_display_codes",
          "topic": "Where to POKE character codes to display specific characters"
        }
      ]
    },
    {
      "start": 18239,
      "end": 18278,
      "name": "music_note_values_intro_and_low_octaves",
      "description": "Appendix E introduction to MUSIC NOTE VALUES and the start of the oscillator frequency table. Includes the table header and entries for Note# 0 through 32 (octaves C-0 through C-2 start), showing decimal oscillator frequency and the high/low SID register bytes to POKE for each note.",
      "references": [
        {
          "chunk": "music_note_values_mid_octaves",
          "topic": "Continuation of the oscillator frequency table (next note ranges)"
        }
      ]
    },
    {
      "start": 18279,
      "end": 18327,
      "name": "music_note_values_mid_octaves",
      "description": "Continuation of the MUSIC NOTE VALUES oscillator frequency table. Contains Note# 33 through 81 (approx. octaves C#-2 through C#-5), listing decimal oscillator frequencies and the HI/LOW SID register bytes for each note. Includes repeated page/table header fragments as found in the source.",
      "references": [
        {
          "chunk": "music_note_values_intro_and_low_octaves",
          "topic": "Previous page: table header and lower notes (Note# 0-32)"
        },
        {
          "chunk": "music_note_values_high_octaves",
          "topic": "Next page: higher notes and table completion (Note# 82-123)"
        }
      ]
    },
    {
      "start": 18328,
      "end": 18372,
      "name": "music_note_values_high_octaves",
      "description": "Completion of the MUSIC NOTE VALUES oscillator frequency table. Contains Note# 82 through 123 (approx. octaves D-5 through B-7), listing decimal oscillator frequencies and the HI/LOW SID register bytes for each note. Includes the table closing row/lines.",
      "references": [
        {
          "chunk": "music_note_values_mid_octaves",
          "topic": "Earlier portion of the oscillator frequency table (Note# 33-81)"
        },
        {
          "chunk": "sid_filter_settings_register_map",
          "topic": "Related SID control info: filter register mappings"
        }
      ]
    },
    {
      "start": 18373,
      "end": 18426,
      "name": "sid_filter_settings_register_map",
      "description": "SID FILTER SETTINGS table mapping the memory locations used for SID filter configuration: locations 54293-54296 ($D41D-$D420). Specifies the contents of each location: low cutoff (54293), high cutoff (54294), resonance and per-voice filter enable bits (54295), and filter type bits plus global volume (54296). Includes surrounding spacing and footer lines from the source.",
      "references": [
        {
          "chunk": "music_note_values_high_octaves",
          "topic": "Preceding appendix content: oscillator frequency table for notes"
        }
      ]
    },
    {
      "start": 18427,
      "end": 18667,
      "ignore": true,
      "reason": "Bibliography \u2014 non-technical content (book and magazine references)."
    },
    {
      "start": 18668,
      "end": 18708,
      "name": "appendix_g_vic_chip_register_map_overview",
      "description": "APPENDIX G: VIC-II (video chip) register map starting at $D000 (53248). Lists VIC registers 0-$.. with bit fields and meanings: sprite X/Y components for sprites 0-7, MSB X (register $D010), Y scroll and control bits ($D011), raster counter ($D012), light-pen registers ($D013-$D014), sprite enable ($D015), X-scroll and control ($D016), sprite expand Y ($D017), screen and character memory base address bits ($D018), interrupt request bits and masks ($D019-$D01A), background-sprite priority ($D01B), multiclor sprite select ($D01C), sprite expand X ($D01D), sprite-sprite and sprite-background collision registers ($D01E-$D01F), color registers (border, background colors, sprite colors), and color code legend (0-15).",
      "references": [
        {
          "chunk": "appendix_d_screen_and_color_memory_maps",
          "topic": "How VIC register base addresses interact with screen/color memory maps"
        },
        {
          "chunk": "appendix_l_6510_specifications",
          "topic": "Timing and bus control interactions between CPU and VIC-II when accessing these registers"
        }
      ]
    },
    {
      "start": 18709,
      "end": 18754,
      "name": "appendix_h_derived_mathematical_functions",
      "description": "APPENDIX H: Deriving mathematical functions in Commodore BASIC. Formulas to compute functions not intrinsic to BASIC: secant, cosecant, cotangent, inverse sine/cosine (arcsin/arccos), inverse secant/cosecant/cotangent, hyperbolic functions (sinh, cosh, tanh, sech, csch, coth), and their inverses using BASIC primitives (ATN, EXP, LOG, SQR, SGN). Example BASIC equivalents provided (e.g., ARCSIN(X)=ATN(X/SQR(-X*X+1))).",
      "references": [
        {
          "chunk": "appendix_a_basic_abbreviations",
          "topic": "Using abbreviated BASIC keywords when typing the formula implementations"
        }
      ]
    },
    {
      "start": 18755,
      "end": 18769,
      "name": "appendix_i_pinouts_intro",
      "description": "Appendix I title and brief introduction to the C64 pinout appendix; lists the categories of connectors covered (Game I/O, Cartridge Slot, Audio/Video, Serial I/O, Modulator Output, Cassette, User Port).",
      "references": [
        {
          "chunk": "control_ports_joystick_paddle_pinouts",
          "topic": "Joystick/paddle Control Port pinouts (Control Port 1 & 2)"
        },
        {
          "chunk": "cartridge_expansion_slot_pinout",
          "topic": "Cartridge expansion slot full pinout"
        },
        {
          "chunk": "audio_video_and_serial_io_connectors",
          "topic": "Audio/Video and Serial I/O connector pinouts"
        },
        {
          "chunk": "cassette_connector_pinout",
          "topic": "Cassette connector pinout"
        },
        {
          "chunk": "user_port_pinout_and_connector_diagram",
          "topic": "User Port pinout"
        }
      ]
    },
    {
      "start": 18770,
      "end": 18796,
      "name": "control_ports_joystick_paddle_pinouts",
      "description": "Control Port 1 and Control Port 2 pinouts for game I/O. Lists each pin (1\u20139) with signal names: JOYA0\u20133, POT AX/AY, BUTTON A/LP, +5V (max 50mA), GND for Control Port 1; JOYB0\u20133, POT BX/BY, BUTTON B, +5V (max 50mA), GND for Control Port 2.",
      "references": [
        {
          "chunk": "appendix_i_pinouts_intro",
          "topic": "Overview of pinout categories in Appendix I"
        },
        {
          "chunk": "user_port_pinout_and_connector_diagram",
          "topic": "Other I/O port (User Port) pinouts and signals"
        }
      ]
    },
    {
      "start": 18797,
      "end": 18824,
      "name": "cartridge_expansion_slot_pinout",
      "description": "Cartridge expansion slot full pinout. Covers pins 1\u201322 (power, control, data D0\u2013D7, R/W, /IRQ, /NMI, /RESET, /ROML, /ROMH, /EXROM, /DMA, Dot Clock, I/O1/I/O2) and the A\u2013Z labeled edge connector mapping to address lines A0\u2013A15, GND and other signals, plus the printed pin-order diagram.",
      "references": [
        {
          "chunk": "appendix_i_pinouts_intro",
          "topic": "Appendix overview"
        },
        {
          "chunk": "audio_video_and_serial_io_connectors",
          "topic": "Nearby connector pinouts (Audio/Video, Serial) shown on same appendix pages"
        }
      ]
    },
    {
      "start": 18825,
      "end": 18845,
      "name": "audio_video_and_serial_io_connectors",
      "description": "Audio/Video and Serial I/O connector pinouts. Audio/Video pins 1\u20136: Luminance, GND, Audio Out, Video Out, Audio In, Chrominance. Serial I/O pins 1\u20136: /SERIAL SRQ IN, GND, SERIAL ATN OUT, SERIAL CLK IN/OUT, SERIAL DATA IN/OUT, /RESET. Includes simple connector illustrations.",
      "references": [
        {
          "chunk": "cartridge_expansion_slot_pinout",
          "topic": "Cartridge slot pinout located nearby in the appendix"
        },
        {
          "chunk": "cassette_connector_pinout",
          "topic": "Cassette connector pinout (other peripheral connector)"
        }
      ]
    },
    {
      "start": 18846,
      "end": 18862,
      "name": "cassette_connector_pinout",
      "description": "Cassette connector (6-pin) pinout. Lists connector pins A\u2013F (A-1 through F-6) with signal meanings: GND, +5V, CASSETTE MOTOR, CASSETTE READ, CASSETTE WRITE, CASSETTE SENSE. Includes small connector diagram.",
      "references": [
        {
          "chunk": "audio_video_and_serial_io_connectors",
          "topic": "Audio/Video & Serial connectors covered adjacent to cassette connector"
        },
        {
          "chunk": "user_port_pinout_and_connector_diagram",
          "topic": "User Port connector \u2014 another peripheral interface"
        }
      ]
    },
    {
      "start": 18863,
      "end": 18896,
      "name": "user_port_pinout_and_connector_diagram",
      "description": "User I/O (User Port) pinout and connector diagram. Covers pins 1\u201312 and lettered pins A\u2013N with signal names and notes (GND, +5V max 100mA, /RESET, CNT1, SP1, CNT2, SP2, /PC2, SERIAL ATN OUT, 9VAC pins, /FLAG2, PB0\u2013PB7, PA2, GND). Includes the printed connector pin-order diagram for the 24-pin user port.",
      "references": [
        {
          "chunk": "control_ports_joystick_paddle_pinouts",
          "topic": "Control ports (game I/O) for joystick and paddles"
        },
        {
          "chunk": "cassette_connector_pinout",
          "topic": "Cassette connector \u2014 another peripheral port shown nearby"
        }
      ]
    },
    {
      "start": 18897,
      "end": 18942,
      "name": "appendix_j_converting_standard_basic_to_commodore_basic",
      "description": "APPENDIX J: Converting BASIC programs from other BASIC dialects to Commodore 64 BASIC. Guidelines: remove explicit string length DIMs (use DIM A$(J) rather than DIM A$(I,J)), use '+' for string concatenation, convert string substring forms (A$(I) or A$(I,J)) to LEFT$/MID$ forms (examples provided), convert multiple assignment forms (LET B=C=0 -> C=0:B=0), replace backslash statement separators with colon (:), and rewrite MAT functions using FOR...NEXT loops.",
      "references": [
        {
          "chunk": "appendix_a_basic_abbreviations",
          "topic": "Use of abbreviated BASIC keywords when editing converted programs"
        }
      ]
    },
    {
      "start": 18943,
      "end": 18957,
      "name": "basic_syntax_differences_and_examples",
      "description": "Notes on Commodore 64 BASIC syntax differences and examples: explains that a second equal sign can be interpreted as a logical operator (with example), shows correct assignment example (10 C=0:B=0), explains how to separate multiple statements on one line using a colon (:), and advises rewriting MAT function usage with FOR...NEXT loops.",
      "references": [
        {
          "chunk": "ignored_page_footer_before_appendix_k",
          "topic": "page break/footer preceding Appendix K"
        },
        {
          "chunk": "appendix_k_intro_and_errors_part1",
          "topic": "begins the Appendix K error-message list"
        }
      ]
    },
    {
      "start": 18958,
      "end": 18990,
      "name": "ignored_page_footer_before_appendix_k",
      "description": "IGNORED: non-technical page break/footer and whitespace preceding APPENDIX K (blank lines, page footer 'APPENDIX J 399' and separator). Marked as non-technical and not a knowledge node.",
      "references": [
        {
          "chunk": "basic_syntax_differences_and_examples",
          "topic": "previous content about BASIC syntax differences"
        },
        {
          "chunk": "appendix_k_intro_and_errors_part1",
          "topic": "start of Appendix K (Error Messages)"
        }
      ],
      "ignore": true,
      "reason": "IGNORED: non-technical page break/footer and whitespace preceding APPENDIX K (blank lines, page footer 'APPENDIX J 399' and separator). Marked as non-technical and not a knowledge node."
    },
    {
      "start": 18991,
      "end": 19031,
      "name": "appendix_k_intro_and_errors_part1",
      "description": "Appendix K title and introduction plus the first portion of the Commodore-64 BASIC error-message list with causes: includes the appendix title, purpose statement, and error messages BAD DATA, BAD SUBSCRIPT, BREAK, CAN'T CONTINUE, DEVICE NOT PRESENT, DIVISION BY ZERO, EXTRA IGNORED, FILE NOT FOUND, FILE NOT OPEN, FILE OPEN, FORMULA TOO COMPLEX, ILLEGAL DIRECT, and ILLEGAL QUANTITY with explanations of typical causes and checks.",
      "references": [
        {
          "chunk": "basic_syntax_differences_and_examples",
          "topic": "prior notes on BASIC syntax differences"
        },
        {
          "chunk": "ignored_page_header",
          "topic": "page/header break within Appendix K"
        },
        {
          "chunk": "appendix_k_errors_part2",
          "topic": "continuation of the error-message list (LOAD through VERIFY)"
        }
      ]
    },
    {
      "start": 19032,
      "end": 19037,
      "name": "ignored_page_header",
      "description": "IGNORED: non-technical page header/footer markers within Appendix K (page number '400 APPENDIX K' and separator). Marked as non-technical and not a knowledge node.",
      "references": [
        {
          "chunk": "appendix_k_intro_and_errors_part1",
          "topic": "previous portion of Appendix K error list"
        },
        {
          "chunk": "appendix_k_errors_part2",
          "topic": "next portion of Appendix K error list"
        }
      ],
      "ignore": true,
      "reason": "IGNORED: non-technical page header/footer markers within Appendix K (page number '400 APPENDIX K' and separator). Marked as non-technical and not a knowledge node."
    },
    {
      "start": 19038,
      "end": 19076,
      "name": "appendix_k_errors_part2",
      "description": "Continuation of the Commodore-64 BASIC error-message list with causes: covers LOAD, NEXT WITHOUT FOR, NOT INPUT FILE, NOT OUTPUT FILE, OUT OF DATA, OUT OF MEMORY, OVERFLOW, REDIM'D ARRAY, REDO FROM START, RETURN WITHOUT GOSUB, STRING TOO LONG, ?SYNTAX ERROR, TYPE MISMATCH, UNDEF'D FUNCTION, UNDEF'D STATEMENT, and VERIFY; explains typical reasons each error appears and suggested checks or corrections.",
      "references": [
        {
          "chunk": "appendix_k_intro_and_errors_part1",
          "topic": "first portion of the error-message list"
        },
        {
          "chunk": "ignored_page_footer_after_appendix_k",
          "topic": "trailing page footer following Appendix K content"
        }
      ]
    },
    {
      "start": 19077,
      "end": 19084,
      "name": "ignored_page_footer_after_appendix_k",
      "description": "IGNORED: trailing non-technical page footer and whitespace after Appendix K (blank lines, page footer 'APPENDIX K 401' and separator). Marked as non-technical and not a knowledge node.",
      "references": [
        {
          "chunk": "appendix_k_errors_part2",
          "topic": "end of the Appendix K error-message list"
        }
      ],
      "ignore": true,
      "reason": "IGNORED: trailing non-technical page footer and whitespace after Appendix K (blank lines, page footer 'APPENDIX K 401' and separator). Marked as non-technical and not a knowledge node."
    },
    {
      "start": 19085,
      "end": 19127,
      "name": "6510_description_and_features",
      "description": "Appendix heading and overview of the MOS 6510 microprocessor: general description, on-chip 8-bit bidirectional I/O port (output register at $0000, data-direction at $0001), three-state 16-bit address bus, compatibility with MOS 6502, and a bulleted FEATURES list (single +5V, 8-bit data path, 56 instructions, decimal/binary arithmetic, 13 addressing modes, indexing, stack characteristics, interrupts, DMA support, pipeline, 1/2 MHz operation, etc.).",
      "references": [
        {
          "chunk": "pin_configuration_and_pinout",
          "topic": "ASCII pinout diagram and pin labels (P0-P7, A0-A15, D0-D7, control pins)"
        },
        {
          "chunk": "6510_characteristics_maximum_ratings",
          "topic": "Electrical and timing characteristics following the functional description"
        }
      ]
    },
    {
      "start": 19128,
      "end": 19218,
      "name": "pin_configuration_and_pinout",
      "description": "Pin configuration section with the 40-pin layout / ASCII-art pinout of the 6510: pin numbers and signal names including RDY, /IRQ, /NMI, AEC, VCC, A0-A15, D0-D7, P0-P7, /RES, R/W and GND. Contains the '[THE PICTURE IS MISSING!]' placeholder for the graphical pinout where present.",
      "references": [
        {
          "chunk": "6510_block_diagram_placeholder",
          "topic": "Block diagram header and missing image that complements the pinout"
        },
        {
          "chunk": "6510_description_and_features",
          "topic": "Functional features summarized in the description (I/O port, address bus, compatibility)"
        }
      ]
    },
    {
      "start": 19219,
      "end": 19225,
      "name": "6510_block_diagram_placeholder",
      "description": "Header for the '6510 BLOCK DIAGRAM' and surrounding page elements. The actual block diagram graphic is missing in the original; this node documents the presence of the block diagram section (placeholder) that normally illustrates internal functional blocks and interconnections.",
      "references": [
        {
          "chunk": "pin_configuration_and_pinout",
          "topic": "Pin labels and physical connections referenced by the block diagram"
        },
        {
          "chunk": "6510_characteristics_maximum_ratings",
          "topic": "Electrical characteristics that apply to the blocks referenced in the diagram"
        }
      ]
    },
    {
      "start": 19226,
      "end": 19290,
      "name": "6510_characteristics_maximum_ratings",
      "description": "6510 characteristics: MAXIMUM RATINGS (supply voltage, input voltage, operating and storage temperature ranges and a note about input protection) and the start of ELECTRICAL CHARACTERISTICS table (conditions: VCC=5.0V \u00b15%, VSS=0, Ta 0\u201370\u00b0C). Includes input high/low thresholds for various pins, input leakage currents, three-state input current, output high/low voltages, power supply current, and capacitance entries (Cin/Cout and pin capacitances C01/C02).",
      "references": [
        {
          "chunk": "clock_timing_and_timing_diagrams",
          "topic": "Clock timing section and data/transfer timing diagrams that depend on the electrical characteristics"
        },
        {
          "chunk": "ac_characteristics_and_read_write_timing_tables",
          "topic": "Detailed AC timing values (1 MHz and 2 MHz) that supplement the DC electrical characteristics"
        }
      ]
    },
    {
      "start": 19291,
      "end": 19366,
      "name": "clock_timing_and_timing_diagrams",
      "description": "Clock timing section and timing diagram placeholders: 'CLOCK TIMING' headers, missing graphical timing diagrams, and headings for 'TIMING FOR READING DATA FROM MEMORY OR PERIPHERALS' and 'TIMING FOR WRITING DATA TO MEMORY OR PERIPHERALS'. This node documents the expected content and indicates where diagrams are missing in the source.",
      "references": [
        {
          "chunk": "6510_characteristics_maximum_ratings",
          "topic": "DC electrical characteristics and capacitances referenced by timing specs"
        },
        {
          "chunk": "ac_characteristics_and_read_write_timing_tables",
          "topic": "AC tables that give numeric timing values corresponding to the timing diagrams"
        }
      ]
    },
    {
      "start": 19367,
      "end": 19460,
      "name": "ac_characteristics_and_read_write_timing_tables",
      "description": "AC characteristics and read/write timing tables (specified for 1 MHz and 2 MHz operation): cycle times, clock pulse widths (\u03c61, \u03c62), rise/fall times, delays between clocks, and detailed READ/WRITE TIMING and DATA/ADDRESS hold/setup times (Trws, Tads, Tacc, Tdsu, Thr, Thw, Tmds, Tha, Thrw). Also includes delay times related to \u03c62 transitions (Taew, Tedr, Tdsu, Twe, Tpdw), peripheral data setup (Tpdsu), and Address Enable setup time (Taes). Values and units are tabulated and the operating conditions are indicated (Vcc=5V \u00b15%, Ta 0\u201370\u00b0C).",
      "references": [
        {
          "chunk": "clock_timing_and_timing_diagrams",
          "topic": "Graphical timing waveforms that correspond to these numeric AC timing values"
        },
        {
          "chunk": "signal_descriptions",
          "topic": "Signal roles (\u03c61/\u03c62, R/W, \u03c62 transitions) that interact with the timing constraints"
        }
      ]
    },
    {
      "start": 19461,
      "end": 19533,
      "name": "signal_descriptions",
      "description": "Detailed signal descriptions: Clocks (\u03c61, \u03c62) requirements (two-phase non-overlapping clocks), Address Bus (A0\u2013A15 TTL outputs, loading and capacitance), Data Bus (D0\u2013D7 bidirectional, tri-stated outputs and drive capability), Reset behavior (timing for start, inhibit of bus access while low, reset sequence on rising edge, vector fetch from $FFFC/$FFFD, power-up requirements), Interrupt Request (/IRQ) behavior (completion of current instruction, mask flag check, push PC and P on stack, vector fetch from $FFFE/$FFFF), Address Enable Control (AEC) for DMA and tri-stating address bus, I/O Port (P0\u2013P7 usage, output register and data-direction locations $0001/$0000 and drive capability), and Read/Write (R/W) signal semantics.",
      "references": [
        {
          "chunk": "ac_characteristics_and_read_write_timing_tables",
          "topic": "Timing values for R/W, \u03c62 transitions, and bus setup/hold intervals"
        },
        {
          "chunk": "addressing_modes",
          "topic": "How addressing modes interact with bus and data signals (memory accesses, page-zero accesses)"
        }
      ]
    },
    {
      "start": 19534,
      "end": 19619,
      "name": "addressing_modes",
      "description": "Descriptions of the 6510/6502 addressing modes: Accumulator, Immediate, Absolute (low/high byte order, access to full 64K), Zero Page (shorter fetch and execution, implied high byte zero), Indexed Zero Page (Zero Page,X/Y \u2014 no page crossing), Indexed Absolute (Absolute,X/Y \u2014 adds index to full 16-bit base, may cross pages), Implied, Relative (branch offset +/-128 from next instruction), Indexed Indirect ([Indirect, X]) where ZP pointer is computed by second byte + X (wrap in page zero) to fetch low/high address bytes, Indirect Indexed ([Indirect], Y) where ZP pointer contents + Y produce effective address with carry into high byte, and Absolute Indirect (JMP indirect: two-byte pointer supplied by instruction yields low/high effective PC).",
      "references": [
        {
          "chunk": "signal_descriptions",
          "topic": "Bus and timing behavior for memory accesses performed by these addressing modes"
        },
        {
          "chunk": "instruction_mnemonics_alphabetic_list",
          "topic": "Instructions that use each addressing mode (e.g., LDA, STA, JMP, branches)"
        }
      ]
    },
    {
      "start": 19620,
      "end": 19703,
      "name": "instruction_mnemonics_alphabetic_list",
      "description": "Alphabetical list of 6510/6502 instruction mnemonics with short descriptions: ADC, AND, ASL; BCC/BCS/BEQ/BIT/BMI/BNE/BPL/BRK/BVC/BVS; CLC/CLD/CLI/CLV/CMP/CPX/CPY; DEC/DEX/DEY; EOR; INC/INX/INY; JMP/JSR; LDA/LDX/LDY/LSR; NOP; ORA; stack operations PHA/PHP/PLA/PLP; ROL/ROR/RTI/RTS; SBC/SEC/SED/SEI/STA/STX/STY; and the transfer group TAX/TAY/TSX/TXA/TXS/TYA. This node lists mnemonic names and concise operation summaries as presented.",
      "references": [
        {
          "chunk": "addressing_modes",
          "topic": "Addressing modes used with many of these instructions"
        },
        {
          "chunk": "programming_model_registers_and_flags",
          "topic": "Registers and flags manipulated by the listed instructions (A, X, Y, P, S, PC)"
        }
      ]
    },
    {
      "start": 19704,
      "end": 19742,
      "name": "programming_model_registers_and_flags",
      "description": "Programming model: register descriptions and layouts \u2014 Accumulator (A), Index registers (X and Y), 16-bit Program Counter (PCH/PCL), Stack Pointer (S) representation, and Processor Status register (P) bitfield with flag meanings (N negative, V overflow, B BRK, D decimal mode, I IRQ disable, Z zero, C carry). ASCII-art register diagrams and bit positions are included.",
      "references": [
        {
          "chunk": "instruction_mnemonics_alphabetic_list",
          "topic": "Which instructions read/write the A, X, Y, S,P,PC registers and set/clear flags"
        },
        {
          "chunk": "instruction_set_opcodes_and_notes",
          "topic": "Opcode tables and execution timing that apply to instructions operating on these registers"
        }
      ]
    },
    {
      "start": 19743,
      "end": 19800,
      "name": "instruction_set_opcodes_and_notes",
      "description": "Instruction set: header for 'INSTRUCTION SET - OP CODES, EXECUTION TIME, MEMORY REQUIREMENTS' including missing opcode table graphics/placeholders and a vendor note cautioning about the use of undefined op codes. The section continues with the instruction set heading present and reserves space for opcode, timing and memory-requirement tables (graphics missing in the original scan).",
      "references": [
        {
          "chunk": "instruction_mnemonics_alphabetic_list",
          "topic": "Alphabetic mnemonic list corresponding to the opcode tables"
        },
        {
          "chunk": "programming_model_registers_and_flags",
          "topic": "Register and flag effects documented for each opcode in the (missing) tables"
        }
      ]
    },
    {
      "start": 19801,
      "end": 19880,
      "name": "6510_memory_map_and_application_notes",
      "description": "6510 internal memory map and zero page I/O placement: ASCII memory map diagram, stack/page-zero layout, application notes describing the benefits of locating the Output Register at page zero (address $0001) and use of the Data Direction Register, plus Commodore Semiconductor Group legal notice.",
      "references": [
        {
          "chunk": "6526_cia_overview_and_pin_configuration",
          "topic": "follows in the document (6526 CIA Appendix M)"
        }
      ]
    },
    {
      "start": 19881,
      "end": 19973,
      "name": "6526_cia_overview_and_pin_configuration",
      "description": "Introductory material for the 6526 Complex Interface Adapter (CIA): device description and feature list, followed by the 40-pin pin configuration diagram and pin assignments (PA0-PA7, PB0-PB7, /PC, /FLAG, /CS, R/W, D0-D7, /IRQ, TOD, CNT, /RES, RS lines, SP).",
      "references": [
        {
          "chunk": "6526_block_diagram_and_maximum_ratings",
          "topic": "block diagram (missing) and maximum ratings / electrical characteristics"
        },
        {
          "chunk": "6510_memory_map_and_application_notes",
          "topic": "context: 6510 page-zero I/O interacts with CIA I/O"
        }
      ]
    },
    {
      "start": 19974,
      "end": 19998,
      "name": "6526_block_diagram_placeholder",
      "description": "Header and placeholder for the 6526 block diagram. Includes APPENDIX M page header, the '6526 BLOCK DIAGRAM' title and the note '[THE PICTURE IS MISSING!]' plus the surrounding blank/formatting lines on the page.",
      "references": [
        {
          "chunk": "6526_maximum_ratings_and_protection_comment",
          "topic": "Follows this page: contains the device maximum ratings and input protection note"
        },
        {
          "chunk": "6526_electrical_characteristics_table_vcc_pm5_ta0_70c",
          "topic": "Related: electrical characteristics table for Vcc \u00b15%, Ta=0\u201370\u00b0C"
        }
      ]
    },
    {
      "start": 19999,
      "end": 20044,
      "name": "6526_maximum_ratings_and_protection_comment",
      "description": "Maximum Ratings for the 6526 device and device protection note. Covers Supply Voltage, Input/Output Voltage, Operating and Storage Temperature limits, a note about input protection circuitry, and the 'COMMENT' section warning about absolute maximum ratings and potential device damage or reliability impact.",
      "references": [
        {
          "chunk": "6526_block_diagram_placeholder",
          "topic": "Preceding page: block diagram placeholder"
        },
        {
          "chunk": "6526_electrical_characteristics_table_vcc_pm5_ta0_70c",
          "topic": "Followed by: detailed electrical characteristics table (Vcc \u00b15%, Ta=0\u201370\u00b0C)"
        }
      ]
    },
    {
      "start": 20045,
      "end": 20104,
      "name": "6526_electrical_characteristics_table_vcc_pm5_ta0_70c",
      "description": "Electrical Characteristics for the 6526 (Vcc \u00b15%, Vss=0V, Ta=0\u201370\u00b0C). Complete tabular listings including Input High/Low voltages (Vih, Vil), Input Leakage Current (Iin) and enumerated pins, Port Input Pull-up Resistance (Rpi), Output Leakage in High-Z (Itsi), Output High/Low voltages (Voh, Vol) with test conditions and affected pins, Output High/Low currents (Ioh, Iol), Input and Output Capacitances (Cin, Cout), and Power Supply Current (Icc). Includes table headers, units, typical/min/max values, and continuation across the page break.",
      "references": [
        {
          "chunk": "6526_maximum_ratings_and_protection_comment",
          "topic": "Preceding: maximum ratings and comment about absolute maximums"
        },
        {
          "chunk": "6526_block_diagram_placeholder",
          "topic": "Related: block diagram placeholder for overall device context"
        }
      ]
    },
    {
      "start": 20105,
      "end": 20212,
      "name": "6526_timing_diagrams_and_interface_overview",
      "description": "6526 read and write timing section: placeholders for the WRITE TIMING DIAGRAM and READ TIMING DIAGRAM (pictures missing) and surrounding explanatory text introducing timing diagrams for interfacing the CIA to the system bus.",
      "references": [
        {
          "chunk": "6526_block_diagram_and_maximum_ratings",
          "topic": "electrical characteristics and maximum ratings"
        },
        {
          "chunk": "6526_interface_signals_and_timing_characteristics",
          "topic": "detailed interface signal descriptions and timing tables"
        }
      ]
    },
    {
      "start": 20213,
      "end": 20326,
      "name": "6526_interface_signals_and_timing_characteristics",
      "description": "6526 interface signals and timing characteristics: descriptions of important pins (/CS, R/W, RS3-RS0, DB7-DB0, IRQ, /RES, CNT, SP, TOD) and a comprehensive timing-characteristics table for 1MHz and 2MHz operation (02 clock cycle times, write/read cycle timing parameters, data access and release times) with measurement notes.",
      "references": [
        {
          "chunk": "6526_timing_diagrams_and_interface_overview",
          "topic": "timing diagram placeholders related to these timing parameters"
        },
        {
          "chunk": "6526_register_map_and_functional_description",
          "topic": "register map and functional descriptions that are addressed by these signals"
        }
      ]
    },
    {
      "start": 20327,
      "end": 20348,
      "name": "6526_register_map",
      "description": "Register map for the 6526 chip showing RS3-RS0 addressing and register assignments: PRA, PRB, DDRA, DDRB, Timer A/B low/high, Time-of-Day registers (10ths, seconds, minutes, hours AM/PM), SDR, ICR, CRA, and CRB.",
      "references": [
        {
          "chunk": "6526_io_ports_overview",
          "topic": "Functional descriptions of the I/O registers (PRA/PRB/DDRA/DDRB) referenced by this map"
        },
        {
          "chunk": "6526_timers_overview",
          "topic": "Timer register addresses (TA/TB LO/HI) shown in this map"
        }
      ]
    },
    {
      "start": 20349,
      "end": 20366,
      "name": "6526_io_ports_overview",
      "description": "Introduction to the 6526 I/O ports (PRA, PRB, DDRA, DDRB). Explains that each port has an 8-bit Peripheral Data Register and Data Direction Register; DDR bits set output vs input; reads reflect port pin states; passive and active pull-ups for CMOS/TTL compatibility; two TTL load drive; PB6 and PB7 provide timer output functions in addition to normal I/O.",
      "references": [
        {
          "chunk": "6526_register_map",
          "topic": "Register addresses for PRA/PRB/DDRA/DDRB"
        },
        {
          "chunk": "6526_handshaking_and_port_bit_map",
          "topic": "Handshaking signals (/PC, /FLAG) and the per-bit layout of PRA/PRB/DDRA/DDRB"
        },
        {
          "chunk": "6526_timers_overview",
          "topic": "Relation of PB6/PB7 to timer outputs"
        }
      ]
    },
    {
      "start": 20367,
      "end": 20386,
      "name": "6526_handshaking_and_port_bit_map",
      "description": "Handshaking behavior for PORT B: /PC output goes low for one cycle after a read/write of PORT B (data-ready/data-accepted indication). 16-bit transfers use PORT A then PORT B for handshaking. /FLAG is a negative-edge-sensitive input (can receive another 6526's /PC or act as interrupt input); negative transitions set the /FLAG interrupt bit. Includes the per-bit register layouts for PRA, PRB, DDRA and DDRB showing PA0-PA7, PB0-PB7, and data direction bits DPAx/DPBx.",
      "references": [
        {
          "chunk": "6526_io_ports_overview",
          "topic": "General I/O port behavior and PB6/PB7 timer outputs"
        },
        {
          "chunk": "6526_timers_overview",
          "topic": "Use of PB6/PB7 for timer outputs which override DDRB"
        }
      ]
    },
    {
      "start": 20387,
      "end": 20404,
      "name": "6526_timers_overview",
      "description": "Overview of the 6526 interval timers (Timer A and Timer B). Each timer has a 16-bit read-only Timer Counter and a 16-bit write-only Timer Latch: writes go to the latch, reads return the counter. Timers can be used independently or linked; used to generate delays, pulses, pulse trains, and waveforms. Timers can count internal clock pulses or external pulses via the CNT input, allowing frequency, pulse width and delay measurements. Each timer has an associated control register for configuration.",
      "references": [
        {
          "chunk": "6526_register_map",
          "topic": "Register addresses for TA/TB LO/HI"
        },
        {
          "chunk": "6526_timer_control_functions",
          "topic": "Detailed control bits and modes for the timers"
        },
        {
          "chunk": "6526_timer_registers_and_load_behavior",
          "topic": "How timer latch/counter interact and the read/write register formats"
        }
      ]
    },
    {
      "start": 20405,
      "end": 20442,
      "name": "6526_timer_control_functions",
      "description": "Detailed description of timer control register functions: Start/Stop (software start/stop), PB On/Off (force timer output onto PB6 for Timer A and PB7 for Timer B overriding DDRB), Toggle/Pulse (output toggles on underflow or generates a one-cycle positive pulse; toggle is set high on timer start and cleared by /RES), One-Shot/Continuous (one-shot counts to zero, interrupts, reloads latch and stops; continuous reloads and repeats), Force Load (strobe to load latch into counter immediately), and Input Mode selections (clock sources: 02 clock, external CNT pulses; Timer B can count 02 pulses, external CNT, Timer A underflow pulses, and variants with CNT held high).",
      "references": [
        {
          "chunk": "6526_timers_overview",
          "topic": "General purpose and capabilities of the timers"
        },
        {
          "chunk": "6526_timer_registers_and_load_behavior",
          "topic": "When latch loads occur and register formats for reads/writes"
        }
      ]
    },
    {
      "start": 20443,
      "end": 20468,
      "name": "6526_timer_registers_and_load_behavior",
      "description": "Timer latch/counter load behavior and the register formats. Explains that the timer latch loads into the counter on timer underflow, on a force load, or after writing the high byte of the prescaler when the timer is stopped; writing the prescaler high byte while running loads the latch but not the counter. Includes the read register layouts for Timer A/B low/high (TA LO/HI, TB LO/HI) showing TALx/TAHx and TBLx/TBHx bits, and the write (prescaler) register layouts for TA/TB LO/HI (PALx/PAHx and PBLx/PBHx).",
      "references": [
        {
          "chunk": "6526_timers_overview",
          "topic": "Purpose of the timer counter and latch and general behavior"
        },
        {
          "chunk": "6526_timer_control_functions",
          "topic": "Control bits that affect load and operation (Force Load, Input Mode, etc.)"
        }
      ]
    },
    {
      "start": 20469,
      "end": 20518,
      "name": "time_of_day_tod_clock",
      "description": "Time Of Day (TOD) clock: 24-hour (AM/PM) BCD clock with 1/10s resolution; register organization (10ths, seconds, minutes, hours) and AM/PM flag in Hours MSB; external 60/50 Hz TOD pin requirement; ALARM functionality with ALARM registers sharing TOD addresses and ALARM being write-only; CRB7 selects TOD vs ALARM access on write; required read/write sequence and latching behavior (writing Hours stops clock, writing 10ths restarts; latched on read of Hours until read of 10ths so reads remain consistent). Includes TOD read register format table.",
      "references": [
        {
          "chunk": "control_registers_cra_crb",
          "topic": "CRB7 selects whether TOD register writes set ALARM or TOD clock"
        },
        {
          "chunk": "interrupt_control_icr",
          "topic": "TOD ALARM is one of the interrupt sources masked/reported by the ICR"
        }
      ]
    },
    {
      "start": 20519,
      "end": 20562,
      "name": "serial_port_sdr",
      "description": "Serial Data Register (SDR) and serial port operation: buffered 8-bit synchronous shift register, input and output modes, CNT-driven shifting on rising CNT edges, interrupt generated after 8 CNT pulses when input is complete; output mode uses TIMER A as baud-rate generator (data shifted out on SP at half the underflow rate of TIMER A), transmission start on write to SDR (when TIMER A running in continuous mode), timing details (data valid on CNT falling edge, MSB-first shifting), continuous transmit behavior when CPU keeps SDR ahead, bidirectional master/slave bus capability using open-drain CNT and SP lines for multi-6526 arrangements, and SDR register format table.",
      "references": [
        {
          "chunk": "control_registers_cra_crb",
          "topic": "CRA SPMODE selects serial port input vs output and ties to TIMER A"
        },
        {
          "chunk": "interrupt_control_icr",
          "topic": "Serial port full/empty is an interrupt source reported by the ICR"
        }
      ]
    },
    {
      "start": 20563,
      "end": 20607,
      "name": "interrupt_control_icr",
      "description": "Interrupt Control Register (ICR): five interrupt sources (TIMER A underflow, TIMER B underflow, TOD ALARM, Serial Port full/empty, /FLAG); single-register mechanism with write-only MASK and read-only DATA; DATA bits set by any interrupt, IR (MSB) set when any enabled interrupt occurs and pulls /IRQ low; reading DATA clears the interrupt DATA register and releases /IRQ; details on mixing polled and masked interrupts and the need to preserve DATA if polled; MASK register semantics (bit 7 as SET/CLEAR control): when bit7=0, ones in written data clear corresponding mask bits; when bit7=1, ones set mask bits; an interrupt flag must have its mask bit set to assert IR and generate a CPU interrupt. Includes INT DATA (read) and INT MASK (write) register tables.",
      "references": [
        {
          "chunk": "time_of_day_tod_clock",
          "topic": "TOD ALARM is an interrupt source reported by the ICR"
        },
        {
          "chunk": "serial_port_sdr",
          "topic": "Serial port completion generates an interrupt bit in the ICR"
        },
        {
          "chunk": "control_registers_cra_crb",
          "topic": "Control bits in CRA/CRB affect timers which generate timer underflow interrupts"
        }
      ]
    },
    {
      "start": 20608,
      "end": 20670,
      "name": "control_registers_cra_crb",
      "description": "6526 control registers CRA (for TIMER A) and CRB (for TIMER B): detailed bit-by-bit definitions. CRA bits: START (bit0), PBON (bit1), OUTMODE (bit2 toggle/pulse), RUNMODE (bit3 one-shot/continuous), LOAD (bit4 force load strobe), INMODE (bit5 select CNT or T2 pulses), SPMODE (bit6 serial port output/input), TODIN (bit7 select 50/60 Hz TOD input). CRB: bits 0-4 mirror CRA0-4 (bit1 controls PB7 output for TIMER B); CRB5-6 form a two-bit INMODE selecting one of four input sources (02 pulses, CNT transitions, TIMER A underflows, TIMER A underflows gated by CNT); CRB7 is ALARM bit selecting writes to TOD registers as ALARM vs TOD clock. Includes compact bit-mapping tables showing control-bit meanings for TA and TB operation. Also notes that unused register bits are unaffected by writes and read back as zero.",
      "references": [
        {
          "chunk": "time_of_day_tod_clock",
          "topic": "CRA/CRB contain bits (TODIN, CRB7/ALARM) that affect TOD operation and ALARM selection"
        },
        {
          "chunk": "serial_port_sdr",
          "topic": "CRA SPMODE selects serial port direction and CNT clock source tied to TIMER A"
        },
        {
          "chunk": "interrupt_control_icr",
          "topic": "TIMER A and TIMER B underflows governed by CRA/CRB can generate ICR interrupts"
        }
      ]
    },
    {
      "start": 20671,
      "end": 20676,
      "name": "legal_notice_ignored",
      "description": "IGNORED: Commodore Semiconductor Group legal/disclaimer block and formatting box (non-technical).",
      "references": [
        {
          "chunk": "control_registers_cra_crb",
          "topic": "preceding technical register information"
        }
      ],
      "ignore": true,
      "reason": "IGNORED: Commodore Semiconductor Group legal/disclaimer block and formatting box (non-technical)."
    },
    {
      "start": 20677,
      "end": 20698,
      "name": "vicii_overview_and_spec_intro",
      "description": "Introduction and high-level overview of the MOS 6566/6567 (VIC-II) video controller: appendix header, purpose, register count, memory access capability (up to 16K), and that various operating modes and options are described in the following sections.",
      "references": [
        {
          "chunk": "character_display_mode_and_addressing",
          "topic": "Character display mode, video matrix and character base addressing"
        },
        {
          "chunk": "bitmap_mode_and_display_base_addressing",
          "topic": "Bit map mode and display base addressing"
        }
      ]
    },
    {
      "start": 20699,
      "end": 20751,
      "name": "character_display_mode_and_addressing",
      "description": "Character display mode operation: how the VIC-II fetches CHARACTER POINTERs from the VIDEO MATRIX and translates them to addresses in the 2048-byte CHARACTER BASE. Includes VIDEO MATRIX addressing (VM13-VM10 + VC9-VC0) and the CHARACTER POINTER ADDRESS map, description of the 8-bit character pointer selecting up to 256 characters, CHARACTER BASE location (CB13-CB11), use of 3-bit raster counter (RC2-RC0), and the CHARACTER DATA ADDRESS map.",
      "references": [
        {
          "chunk": "vicii_overview_and_spec_intro",
          "topic": "General VIC-II overview and device purpose"
        },
        {
          "chunk": "standard_character_mode_behavior",
          "topic": "How character dot data are displayed in standard mode"
        },
        {
          "chunk": "extended_color_mode_and_constraints",
          "topic": "How character pointer bits are re-used for background selection in ECM"
        }
      ]
    },
    {
      "start": 20752,
      "end": 20775,
      "name": "standard_character_mode_behavior",
      "description": "Standard character mode (MCM = BMM = ECM = 0): interpretation of 8 sequential bytes from the character base as 8 raster lines; bit-to-color mapping where a '0' bit selects the global background (#0 from register 33 ($21)) and a '1' bit selects the character's foreground color from the 4-bit color nybble stored in the video matrix. Explains that each character has a unique foreground color (4-bit nybble) while all characters share the common background color.",
      "references": [
        {
          "chunk": "character_display_mode_and_addressing",
          "topic": "Character pointers and character base addressing used by standard mode"
        },
        {
          "chunk": "multi_color_character_mode",
          "topic": "Contrast with multi-color character mode interpretation"
        },
        {
          "chunk": "extended_color_mode_and_constraints",
          "topic": "Contrast with extended color mode per-character backgrounds"
        }
      ]
    },
    {
      "start": 20776,
      "end": 20808,
      "name": "multi_color_character_mode",
      "description": "Multi-color character mode (MCM = 1, BMM = ECM = 0): how enabling MCM changes interpretation of character dot data to use 2-bit color pairs, allowing up to four colors per character with halved horizontal resolution. Describes conditional behavior when the MSB of the color nybble = 0 (character behaves as in standard mode, lower 8 colors only) and when MSB = 1 (MCM interpretation). Includes the CHARACTER BIT-PAIR to COLOR mapping: 00 = Background #0, 01 = Background #1 (register 34), 10 = Background #2 (register 35), 11 = color from 3 LSBs of color nybble. Notes that dots are doubled horizontally producing a 4*8 matrix and mentions MOB priority implication.",
      "references": [
        {
          "chunk": "standard_character_mode_behavior",
          "topic": "Standard mode behavior for comparison and mixed-mode cases"
        },
        {
          "chunk": "extended_color_mode_and_constraints",
          "topic": "Note that ECM and MCM should not be enabled simultaneously"
        }
      ]
    },
    {
      "start": 20809,
      "end": 20848,
      "name": "extended_color_mode_and_constraints",
      "description": "Extended color mode (ECM = 1, BMM = MCM = 0): selecting ECM via register 17 ($11) and how it allows per-character background selection while keeping 8x8 resolution. Explains that character dot data is displayed as in standard mode for bit values, but the two MSB of the character pointer are repurposed to select one of four background colors (mapping of CHAR POINTER MSB pair to background registers 33-36). Notes that only 64 character definitions remain available because the VIC-II forces CB10 and CB9 to 0, and states that each character has one of 16 foregrounds and one of 4 backgrounds. Includes the explicit NOTE that ECM and MCM should not be enabled simultaneously.",
      "references": [
        {
          "chunk": "multi_color_character_mode",
          "topic": "Contrast with multi-color character mode and the caution about enabling both"
        },
        {
          "chunk": "character_display_mode_and_addressing",
          "topic": "Character pointer/character base addressing constraints when ECM uses MSBs"
        }
      ]
    },
    {
      "start": 20849,
      "end": 20879,
      "name": "bitmap_mode_and_display_base_addressing",
      "description": "Bit map mode overview and addressing (BMM = 1): explanation that bitmap mode creates a one-to-one mapping between memory bits and displayed dots for a 320\u00d7200 resolution. Describes that the VIDEO MATRIX is still accessed but interpreted as color data and that the VIDEO MATRIX COUNTER is used to fetch dot data from an 8000-byte DISPLAY BASE. Includes the DISPLAY BASE address formation: A13 = CB13, A12-A04 = VC9..VC0, A03-A01 = RC2..RC0 (raster counter), and notes that VCx and RCx behavior formats memory as 8\u00d78 dot blocks.",
      "references": [
        {
          "chunk": "character_display_mode_and_addressing",
          "topic": "How the video matrix counter is re-used in bitmap mode vs character mode"
        },
        {
          "chunk": "standard_bitmap_mode_behavior",
          "topic": "Standard bitmap color selection rules"
        },
        {
          "chunk": "multi_color_bitmap_mode",
          "topic": "Multi-color bitmap interpretation and nybble usage"
        }
      ]
    },
    {
      "start": 20880,
      "end": 20895,
      "name": "standard_bitmap_mode_behavior",
      "description": "Standard bit map mode (BMM = 1, MCM = 0): color is determined solely by the video matrix nybble (DB11-DB8 ignored). Each display byte (8 bits) is split into two 4-bit nybbles, permitting two independently selected colors within each 8\u00d78 block. A display memory bit of '0' selects the lower (least significant) nybble color; a '1' selects the upper (most significant) nybble color.",
      "references": [
        {
          "chunk": "bitmap_mode_and_display_base_addressing",
          "topic": "Bitmap addressing and block formatting (8\u00d78 blocks)"
        },
        {
          "chunk": "multi_color_bitmap_mode",
          "topic": "How MCM alters bitmap interpretation to use 2-bit pairs"
        }
      ]
    },
    {
      "start": 20896,
      "end": 20922,
      "name": "multi_color_bitmap_mode",
      "description": "Multi-color bit map mode (BMM = 1, MCM = 1): selected by setting MCM along with BMM. Uses same memory access as standard bitmap mode but interprets dot data as 2-bit pairs mapping to colors: 00 = Background #0 (register 33), 01 = upper nybble of video matrix pointer, 10 = lower nybble of video matrix pointer, 11 = video matrix color nybble (DB11-DB8). Notes that the color nybble is used in this mode, horizontal dot size is doubled resulting in 160\u00d7200 resolution, and up to three independently selected colors plus the background can appear in each 8\u00d78 block.",
      "references": [
        {
          "chunk": "standard_bitmap_mode_behavior",
          "topic": "Comparison of bit-to-color selection when MCM is off"
        },
        {
          "chunk": "bitmap_mode_and_display_base_addressing",
          "topic": "Bitmap memory layout and display base addressing used by both bitmap modes"
        }
      ]
    },
    {
      "start": 20923,
      "end": 20947,
      "name": "movable_object_block_overview_and_layout",
      "description": "Defines the Movable Object Block (MOB): purpose, count (up to 8), memory size (63 bytes each), displayed dot array size (24x21), and the MOB display block layout (byte indexing 00\u201362). Explains why MOBs are useful for smooth onscreen movement and gaming graphics.",
      "references": [
        {
          "chunk": "mob_enable_and_positioning",
          "topic": "How to enable MOBs and set their X/Y position"
        },
        {
          "chunk": "mob_memory_access_and_pointers",
          "topic": "Where the 63 bytes per MOB are stored and how MOB pointers locate them"
        }
      ]
    },
    {
      "start": 20948,
      "end": 20969,
      "name": "mob_enable_and_positioning",
      "description": "Explains MOB enable control (MnE bits in register 21 ($15)) and behavior when disabled. Describes MOB positioning using X and Y position registers with a resolution of 512 horizontal \u00d7 256 vertical positions, the reference corner (upper-left of the array), and the visible coordinate ranges (X: 23\u2013347 / $17\u2013$157; Y: 50\u2013249 / $32\u2013$F9). Notes smooth on/off-screen movement.",
      "references": [
        {
          "chunk": "movable_object_block_overview_and_layout",
          "topic": "MOB basic definition and display block layout"
        },
        {
          "chunk": "mob_memory_access_and_pointers",
          "topic": "How raster line matching triggers MOB data fetches"
        }
      ]
    },
    {
      "start": 20970,
      "end": 21011,
      "name": "mob_color_modes_and_multicolor_interpretation",
      "description": "Covers MOB color registers (per-MOB 4-bit color) and the two MOB color modes: Standard MOB (MnMC=0) where '1' bits show the MOB color and '0' bits are transparent, and Multi-color MOB (MnMC=1) where data is interpreted in bit pairs. Provides the multi-color bit-pair table showing interpretation: 00=Transparent, 01=MOB Multi-color #0 (register 37 $25), 10=MOB Color (registers 39\u201346 $27\u2013$2E), 11=MOB Multi-color #1 (register 38 $26). Explains that multi-color mode reduces horizontal resolution to 12\u00d721 (each horizontal dot expanded 2\u00d7) and that up to three colors (plus transparency) are available, with two multi-colors shared among all MOBs.",
      "references": [
        {
          "chunk": "mob_magnification_controls",
          "topic": "How magnification interacts with multi-color resolution"
        },
        {
          "chunk": "mob_priority_and_foreground_behavior",
          "topic": "How MOB color data interacts with background/foreground priority"
        }
      ]
    },
    {
      "start": 21012,
      "end": 21030,
      "name": "mob_magnification_controls",
      "description": "Describes per-MOB magnification (2\u00d7 expansion) in horizontal and vertical directions using MnXE and MnYE control bits. Specifies registers: 23 ($17) controls horizontal expand (MnXE), 29 ($1D) controls vertical expand (MnYE). Notes that expansion doubles overall MOB dimensions without increasing resolution (24\u00d721 array or 12\u00d721 in multi-color), and that combination of multi-color and expansion can yield dot sizes up to 4\u00d7 standard.",
      "references": [
        {
          "chunk": "mob_color_modes_and_multicolor_interpretation",
          "topic": "Multi-color MOB resolution and how expansion affects dot size"
        },
        {
          "chunk": "mob_memory_access_and_pointers",
          "topic": "Fetch timing remains per raster line regardless of magnification"
        }
      ]
    },
    {
      "start": 21031,
      "end": 21067,
      "name": "mob_priority_and_foreground_behavior",
      "description": "Explains per-MOB priority control relative to character and bitmap display data using MnDP bits in register 27 ($1B). Shows priority meanings: MnDP=0 \u2014 non-transparent MOB data displayed in front of character/bitmap (MOB in front); MnDP=1 \u2014 non-transparent MOB data displayed only instead of Background #0 or multi-color bit pair 01 (MOB behind). Includes a small priority matrix and notes that MOB data bits of '0' (or '00' in multi-color) are transparent. Describes fixed MOB-to-MOB priority (MOB 0 highest, MOB 7 lowest) and that MOB-vs-MOB priority is resolved before MOB vs. character/bitmap priority.",
      "references": [
        {
          "chunk": "mob_color_modes_and_multicolor_interpretation",
          "topic": "Which MOB bit patterns are transparent and how multi-color pairs map to colors"
        },
        {
          "chunk": "mob_collision_detection_and_interrupts",
          "topic": "How displayed (non-transparent) MOB pixels relate to collision detection"
        }
      ]
    },
    {
      "start": 21068,
      "end": 21110,
      "name": "mob_collision_detection_and_interrupts",
      "description": "Details the two collision detection types and their registers: 1) MOB-to-MOB collisions set bits MnM in MOB-MOB COLLISION register 30 ($1E) when non-transparent pixels from two MOBs coincide. Collision bits for all collided MOBs are set and remain until the register is read (read clears them). MOB collisions are detected even off-screen. 2) MOB-to-display (MOB-DATA) collisions set bits MnD in MOB-DATA COLLISION register 31 ($1F) when a MOB and non-background display data from character/bitmap modes coincide; transparent data does not cause collisions. The 0-1 multi-color bit pair can be excluded from causing MOB-DATA collisions for background purposes. MOB-DATA collisions can occur off-screen horizontally if display data is scrolled off-screen. Also explains collision interrupt latches: once the first bit in either collision register is set, the corresponding interrupt latch is set and won't be set again until the collision register is cleared to all zeros by a read.",
      "references": [
        {
          "chunk": "mob_priority_and_foreground_behavior",
          "topic": "Which MOB pixels are considered non-transparent and how priorities affect visible pixels"
        },
        {
          "chunk": "mob_memory_access_and_pointers",
          "topic": "Collision detection is independent of MOB pointer fetching and can detect off-screen collisions"
        }
      ]
    },
    {
      "start": 21111,
      "end": 21134,
      "name": "mob_memory_access_and_pointers",
      "description": "Explains MOB data storage (63 consecutive bytes per MOB) and MOB pointer placement at the end of the video matrix. Notes that normal video matrix uses 1000 bytes, leaving locations 1016\u20131023 (VM base + $3F8 to +$3FF) for MOB pointers 0\u20137. Describes how the 8-bit MOB pointer (MP7\u2013MP0 from the video matrix) combined with 6 internally generated MOB counter bits (MC5\u2013MC0) form a 14-bit address (A13\u2013A00) to access the 63 bytes. Explains that MOB pointers are read at the end of each raster line; when a MOB's Y position matches the raster line, MOB data fetches begin and internal counters step through 63 bytes, displaying three bytes per raster line.",
      "references": [
        {
          "chunk": "movable_object_block_overview_and_layout",
          "topic": "The 63-byte MOB block layout and how it maps to on-screen 24\u00d721 pixels"
        },
        {
          "chunk": "mob_enable_and_positioning",
          "topic": "Y position matching to start MOB data fetches on the raster"
        }
      ]
    },
    {
      "start": 21135,
      "end": 21145,
      "name": "screen_blanking_and_den_register",
      "description": "Describes screen blanking via the DEN bit in register 17 ($11): setting DEN to '0' blanks the display and fills the screen with the exterior color from register 32 ($20). While blanked, only transparent (Phase 1) memory accesses are required, allowing full CPU use of the system bus; MOB data will still be accessed unless MOBs are disabled. Notes that DEN must be '1' for normal video display.",
      "references": [
        {
          "chunk": "mob_memory_access_and_pointers",
          "topic": "Blanking effects on memory access and MOB fetches"
        },
        {
          "chunk": "mob_enable_and_positioning",
          "topic": "To avoid MOB fetches while blanked, MOBs must be disabled via enable bits"
        }
      ]
    },
    {
      "start": 21146,
      "end": 21258,
      "name": "6566_vicii_scrolling_lightpen_raster_and_interrupts",
      "description": "VIC-II display window and interaction features: screen blanking (DEN), row/column select (RSEL/CSEL) for 24/25 rows and 38/40 columns, horizontal and vertical fine scrolling bits (X2..X0, Y2..Y0), light-pen latch behavior and registers (LPX, LPY), raster register and raster interrupt compare behavior and visible raster window, interrupt register and enable bits (latches and enable bits for raster, MOB-DATA and MOB-MOB collisions, light-pen), and details on interrupt latching/clearing.",
      "references": [
        {
          "chunk": "6566_vicii_bitmap_and_mob_overview",
          "topic": "MOB collision information and MOB-related interrupt behavior"
        },
        {
          "chunk": "6566_vicii_theory_of_operation_and_memory_interface",
          "topic": "how these features are implemented via bus/memory timing and refresh"
        }
      ]
    },
    {
      "start": 21259,
      "end": 21267,
      "name": "reset_header_ignored",
      "description": "Non-technical header area containing the 'RESET' section title and surrounding blank lines. This is treated as an ignored/documentation header fragment and contains no operational detail.",
      "references": [
        {
          "chunk": "vicii_system_interface_bus_sharing_and_phases",
          "topic": "continues with Theory of Operation / System Interface"
        }
      ],
      "ignore": true,
      "reason": "Non-technical header area containing the 'RESET' section title and surrounding blank lines. This is treated as an ignored/documentation header fragment and contains no operational detail."
    },
    {
      "start": 21268,
      "end": 21330,
      "name": "vicii_system_interface_bus_sharing_and_phases",
      "description": "System interface and Theory of Operation for the 6566/6567 VIC-II: explains that the video chip normally accesses system memory during Phase 1 (clock low) so processor Phase 2 accesses remain free; describes AEC (Address Enable Control) active-low behavior and how it disables the processor address drivers; defines the effective 500 ns memory cycle tied to the 1 MHz Phase 2 clock; explains BA/RDY bus arbitration for required Phase-2 accesses, the three-phase allowance before takeover, and character pointer fetch timing (every 8th raster during display window requiring 40 consecutive Phase-2 accesses). Also introduces MOB (sprite) fetches and lists the 4-phase MOB fetch sequence (table of PHASE vs DATA and condition).",
      "references": [
        {
          "chunk": "vicii_memory_interface_address_output_6566_6567",
          "topic": "memory access details and differences between 6566/6567 (addresses, RAS/CAS) referenced by system interface"
        },
        {
          "chunk": "vicii_bus_activity_summary_table",
          "topic": "quick reference of AEC/PH0/CS/RW actions summarized in a table"
        },
        {
          "chunk": "vicii_processor_interface_register_access",
          "topic": "how the processor accesses VIC registers when AEC and PH0 permit"
        }
      ]
    },
    {
      "start": 21331,
      "end": 21349,
      "name": "vicii_memory_interface_address_output_6566_6567",
      "description": "Memory interface differences between the two VIC-II versions: the 6566 provides thirteen fully decoded address outputs for direct system bus connection; the 6567 uses multiplexed addresses for direct connection to 64K DRAMs, presenting A06-A00 with /RAS low and A13-A08 on A05-A00 with /CAS low; notes that A11-A07 are static outputs on the 6567 to support ROM connection and that lower-order address latching is required for multiplexed outputs.",
      "references": [
        {
          "chunk": "vicii_system_interface_bus_sharing_and_phases",
          "topic": "describes when the VIC takes control of the address bus (AEC, Phase 1/2 accesses)"
        },
        {
          "chunk": "vicii_processor_interface_register_access",
          "topic": "register access timing and address pins (A5-A0) behavior"
        }
      ]
    },
    {
      "start": 21350,
      "end": 21387,
      "name": "vicii_processor_interface_register_access",
      "description": "Processor interface and register access rules: lists processor-facing signals and behavior for register access. Covers DATA BUS (DB7-DB0) as bidirectional and only accessible while AEC and Phase 0 are high and /CS is low; CHIP SELECT (/CS) which is recognized only while AEC and Phase 0 are high; READ/WRITE (R/W) direction semantics; ADDRESS BUS (A5-A0) as bidirectional low-order address pins used to select registers during processor reads/writes. Includes surrounding pagination and spacing from the original document.",
      "references": [
        {
          "chunk": "vicii_system_interface_bus_sharing_and_phases",
          "topic": "explains bus sharing and when processor accesses are permitted (AEC/PH0)"
        },
        {
          "chunk": "vicii_bus_activity_summary_table",
          "topic": "table that summarizes allowed actions for combinations of AEC, PH0, /CS and R/W"
        },
        {
          "chunk": "vicii_clock_out_ph0",
          "topic": "PH0 (Phase 0) timing and generation referenced for register access"
        }
      ]
    },
    {
      "start": 21388,
      "end": 21394,
      "name": "vicii_clock_out_ph0",
      "description": "CLOCK OUT (PH0): describes the Phase 0 1-MHz clock output provided by the VIC-II for use as the 65XX processor Phase 0. Explains that system bus activity is referenced to this clock and that it is generated by dividing the 8-MHz video input clock by eight.",
      "references": [
        {
          "chunk": "vicii_processor_interface_register_access",
          "topic": "processor register access requires PH0 high along with AEC"
        },
        {
          "chunk": "vicii_system_interface_bus_sharing_and_phases",
          "topic": "system timing and memory-cycle relationship to the 1 MHz system Phase 2"
        }
      ]
    },
    {
      "start": 21395,
      "end": 21401,
      "name": "vicii_interrupts_irq",
      "description": "INTERRUPTS (/IRQ): explains the VIC-II interrupt output behavior. The /IRQ line is driven low when an enabled internal source triggers an interrupt. The /IRQ output is open-drain and requires an external pull-up resistor. (Includes adjacent blank lines from source for continuity.)",
      "references": [
        {
          "chunk": "vicii_processor_interface_register_access",
          "topic": "processor must monitor /IRQ and use register access rules to acknowledge or inspect interrupt sources"
        }
      ]
    },
    {
      "start": 21402,
      "end": 21415,
      "name": "vicii_video_interface_outputs_sync_lum_and_color",
      "description": "VIDEO INTERFACE: describes the two separate video output signals from the 6566/6567 \u2014 SYNC/LUM and COLOR. SYNC/LUM carries horizontal/vertical sync and luminance, is open-drain and requires a 500 ohm pull-up. COLOR carries chrominance including color burst and pixel color, is open-source and should be terminated with 1000 ohms to ground. Explains that these two signals must be externally mixed and can then drive a monitor or be sent to an RF modulator.",
      "references": [
        {
          "chunk": "vicii_system_interface_bus_sharing_and_phases",
          "topic": "video timing and raster activity affect when memory accesses occur"
        },
        {
          "chunk": "vicii_bus_activity_summary_table",
          "topic": "summarizes PHASE/CS/RW interaction which determines when video fetches happen"
        }
      ]
    },
    {
      "start": 21416,
      "end": 21426,
      "name": "vicii_bus_activity_summary_table",
      "description": "SUMMARY TABLE mapping AEC, PH0, /CS and R/W combinations to device actions: rows indicate PHASE 1 fetch/refresh when AEC=0 PH0=0; PHASE 2 fetch (processor off) when AEC=0 PH0=1; no action when AEC=1 PH0=0; register WRITE when AEC=1 PH0=1 /CS=0 R/W=0; register READ when AEC=1 PH0=1 /CS=0 R/W=1; no action when AEC=1 PH0=1 /CS=1. This provides a concise reference for bus arbitration and permitted operations.",
      "references": [
        {
          "chunk": "vicii_system_interface_bus_sharing_and_phases",
          "topic": "detailed explanation of Phase-1/Phase-2 fetches, AEC, and BA behavior"
        },
        {
          "chunk": "vicii_processor_interface_register_access",
          "topic": "conditions required for processor register reads/writes (/CS, R/W, AEC, PH0)"
        }
      ]
    },
    {
      "start": 21427,
      "end": 21478,
      "name": "vic-ii_pin_configuration_6567_variant_with_multiplexed_addresses",
      "description": "APPENDIX header and the first VIC-II (6567) PIN CONFIGURATION diagram (pins 1\u201340). Shows data lines D0\u2013D11, control signals (/IRQ, LP, /CS, R/W, BA, Vdd, COLOR, S/LUM, AEC, PH0, /RAS, /CAS, PHIN, PHCL, Vss, Vcc) and address pin assignments with several multiplexed address labels shown in parentheses on the right side of the diagram. Includes the page note that multiplexed addresses are shown in parentheses.",
      "references": [
        {
          "chunk": "vic-ii_pin_configuration_6567_alternate_address_mapping",
          "topic": "alternative 6567 pinout / second diagram (different address labeling)"
        },
        {
          "chunk": "vic-ii_register_map_00_2e",
          "topic": "VIC-II register map referenced elsewhere in the same appendix"
        }
      ]
    },
    {
      "start": 21479,
      "end": 21525,
      "name": "vic-ii_pin_configuration_6567_alternate_address_mapping",
      "description": "Second VIC-II (6567) PIN CONFIGURATION diagram (pins 1\u201340) showing an alternate address labeling (A13..A0) on the right-side pins. Lists the same data and control pins (D0\u2013D11, /IRQ, LP, /CS, R/W, BA, Vdd, COLOR, S/LUM, AEC, PH0, PHIN, PHCOL, PHCL, Vss, Vcc) but with the address lines arranged/multiplexed differently compared to the first diagram. Includes associated page header/footer text.",
      "references": [
        {
          "chunk": "vic-ii_pin_configuration_6567_variant_with_multiplexed_addresses",
          "topic": "first 6567 pinout variant (multiplexed-address annotation)"
        },
        {
          "chunk": "vic-ii_register_map_00_2e",
          "topic": "VIC-II register map (useful when mapping signals to registers)"
        }
      ]
    },
    {
      "start": 21526,
      "end": 21600,
      "name": "vic-ii_register_map_00_2e",
      "description": "VIC-II register map for addresses $00\u2013$2E. Presents each register address with DB7..DB0 bit names and short descriptions: MOB (sprite) X/Y positions ($00\u2013$0F), MSB of X-positions ($10), control register flags ($11: RC8, ECM, BMM, DEN, RSEL, Y2..Y0), raster register ($12), light-pen X/Y ($13\u2013$14), MOB enable ($15), control/reserved bits and color/graphics mode bits ($16), MOB Y-expand ($17), memory pointers ($18), interrupt register ($19), interrupt enable ($1A), MOB-DATA priority ($1B), MOB multicolor select ($1C), MOB X-expand ($1D), collision registers ($1E\u2013$1F), exterior/background and MOB multicolor color registers ($20\u2013$26), and per-MOB color registers ($27\u2013$2E). The table lists bit fields such as MxXn, MxYn, MxE, MxDP, MxMC, MxXE, MxM, MxD, color bits (ECx, BxCx, MMxx, MxCx) and typical short descriptions for each register entry.",
      "references": [
        {
          "chunk": "vic-ii_pin_configuration_6567_variant_with_multiplexed_addresses",
          "topic": "first 6567 pinout (relates pins/signals to register functions)"
        },
        {
          "chunk": "vic-ii_pin_configuration_6567_alternate_address_mapping",
          "topic": "second 6567 pinout (alternate pin/address mapping)"
        }
      ]
    },
    {
      "start": 21601,
      "end": 21666,
      "name": "color_codes_table_vicii",
      "description": "VIC-II color code table: 4-bit color codes (D3..D0), corresponding hex/decimal values and human-readable color names for all 16 colors (black, white, red, cyan, purple, green, blue, yellow, orange, brown, light red, dark grey, medium grey, light green, light blue, light grey).",
      "references": [
        {
          "chunk": "6566_vicii_pin_configuration_and_register_map",
          "topic": "register fields that store color nybbles use these codes"
        },
        {
          "chunk": "6566_vicii_character_display_and_color_modes",
          "topic": "how these codes are used in character/bitmap/multi-color modes"
        }
      ]
    },
    {
      "start": 21667,
      "end": 21756,
      "name": "6581_sid_overview_and_pin_configuration",
      "description": "6581 SID (Sound Interface Device) overview and features: conceptual description of the 3-voice synthesizer, list of SID features (3 oscillators, 4 waveforms, envelope generators, filter, master volume, A/D pots, random generator, external audio), followed by the 28-pin SID pin configuration diagram and pin list (CAP pins, /RES, 02, R/W, /CS, A0-A4, GND, D0-D7, POTX/POTY, EXT IN, AUDIO OUT, Vcc, Vdd).",
      "references": [
        {
          "chunk": "6581_sid_block_diagram_and_description",
          "topic": "block diagram (missing) and full SID functional description follow"
        },
        {
          "chunk": "6566_vicii_pin_configuration_and_register_map",
          "topic": "adjacent appendix in the document covering video; both are system peripherals"
        }
      ]
    },
    {
      "start": 21757,
      "end": 21810,
      "name": "sid_block_diagram_placeholder",
      "description": "Non-technical page header/footer and block-diagram placeholder for the 6581 SID. Covers page header lines (APPENDIX O, page numbers), filler/tilde lines, many blank lines and the note '[THE PICTURE IS MISSING!]', plus the block diagram title line '6581 BLOCK DIAGRAM'. This is a non-technical/artifact section of the original page and is recorded here for completeness (ignored as a non-technical element).",
      "references": [
        {
          "chunk": "sid_chip_overview",
          "topic": "high-level textual description of the 6581 SID"
        },
        {
          "chunk": "sid_control_registers_and_map",
          "topic": "detailed SID register map and control register table"
        }
      ],
      "ignore": true,
      "reason": "audit: Non-technical artifact noting a missing SID block diagram; contains no usable technical information."
    },
    {
      "start": 21811,
      "end": 21835,
      "name": "sid_chip_overview",
      "description": "High-level description of the MOS 6581 SID synthesizer. Explains that the 6581 has three synth 'voices' (each with a Tone Oscillator/Waveform Generator, Envelope Generator, and Amplitude Modulator), the oscillator's role in pitch and waveform generation (four waveforms), envelope-driven amplitude modulation with programmable attack/decay/sustain/release, the programmable filter for subtractive synthesis, the ability to read the third oscillator and envelope for modulation or RNG use, two A/D converters for paddles/potentiometers, and support for external audio chaining/mixing.",
      "references": [
        {
          "chunk": "sid_block_diagram_placeholder",
          "topic": "visual block diagram placeholder and page header/footer"
        },
        {
          "chunk": "sid_control_registers_and_map",
          "topic": "register-level control (addresses and bit fields) for the described features"
        }
      ]
    },
    {
      "start": 21836,
      "end": 21900,
      "name": "sid_control_registers_and_map",
      "description": "SID control registers: introduction and full Table 1 register map for the 6581. States that there are 29 eight-bit registers (either WRITE-only or READ-only). Includes the complete register map ($00\u2013$1C) with register numbers, bit assignments (D7..D0), register names and functions grouped by Voice 1\u20133, Filter, and Miscellaneous read registers. Explicit entries include FREQ LO/HI, PW LO/HI, CONTROL REG (wave/noise/pulse/saw/tri/test/ring/sync/gate), ATTACK/DECAY, SUSTAIN/RELEASE for each voice, filter cutoff (FC LO/HI), RES/FILT and MODE/VOL register bits (HP/BP/LP/volume/mode), and read-only POT X, POT Y, OSC3/RANDOM, ENV3 registers with their bit labels and read/write types (WO/RO).",
      "references": [
        {
          "chunk": "sid_chip_overview",
          "topic": "high-level behavior explained by these control registers (voices, envelope, filter, A/D, oscillator readouts)"
        },
        {
          "chunk": "sid_block_diagram_placeholder",
          "topic": "visual block diagram placeholder for the 6581"
        }
      ]
    },
    {
      "start": 21901,
      "end": 21909,
      "name": "sid_voice1_header",
      "description": "Section header and introductory lines for SID Register Description \u2014 Voice 1. Contains the APPENDIX header, the 'SID REGISTER DESCRIPTION' title, the 'VOICE 1' subheading, and the heading for the next subsection 'FREQ LO/FREQ HI (Registers 00,01)'.",
      "references": [
        {
          "chunk": "freq_lo_hi_registers",
          "topic": "16-bit frequency control (Registers 00,01)"
        }
      ]
    },
    {
      "start": 21910,
      "end": 21927,
      "name": "freq_lo_hi_registers",
      "description": "FREQ LO / FREQ HI (Registers 00,01): Explanation that the two registers form a 16-bit linear frequency control for Oscillator 1; the frequency formula Fout = (Fn * Fclk / 16777216) Hz; example numeric factor for a 1.0 MHz clock (Fout = Fn * 0.059604645 Hz); note on resolution, suitability for musical tuning, portamento, and reference to Appendix E for a complete table.",
      "references": [
        {
          "chunk": "pw_lo_hi_registers",
          "topic": "Pulse width registers (Registers 02,03) and pulse interaction"
        },
        {
          "chunk": "control_register_header",
          "topic": "Control register (Register 04) \u2014 gating and waveform selection"
        }
      ]
    },
    {
      "start": 21928,
      "end": 21944,
      "name": "pw_lo_hi_registers",
      "description": "PW LO / PW HI (Registers 02,03): Description of the 12-bit Pulse Width control for Oscillator 1 (bits 4-7 of PW HI unused); formula PWout = (PWn / 40.95) %; notes on smooth pulse-width sweeping, requirement that the Pulse waveform be selected for audible effect, extreme values (0 or 4095 produce DC, 2048 produces square wave).",
      "references": [
        {
          "chunk": "freq_lo_hi_registers",
          "topic": "Oscillator frequency control (Registers 00,01) used to modulate Noise and other effects"
        },
        {
          "chunk": "waveform_selection_bits_and_output_behavior",
          "topic": "Pulse waveform must be selected (Bit 6) for PW registers to take effect"
        }
      ]
    },
    {
      "start": 21945,
      "end": 21952,
      "name": "control_register_header",
      "description": "Control register heading and spacing: placement of 'CONTROL REGISTER (Register 04)' heading introducing the eight control bits for Oscillator 1.",
      "references": [
        {
          "chunk": "control_register_overview_and_gate",
          "topic": "Overview and GATE (Bit 0) description"
        }
      ]
    },
    {
      "start": 21953,
      "end": 21964,
      "name": "control_register_overview_and_gate",
      "description": "CONTROL REGISTER (Register 04) overview and GATE (Bit 0): States that the register contains eight control bits selecting options for Oscillator 1. GATE (Bit 0) controls the Voice 1 Envelope Generator: setting starts the ATTACK/DECAY/SUSTAIN cycle, clearing starts RELEASE; envelope controls oscillator amplitude so GATE must be set (with envelope parameters) for audible output. Notes that a detailed Envelope Generator discussion appears later in the appendix.",
      "references": [
        {
          "chunk": "control_register_header",
          "topic": "Control register heading"
        },
        {
          "chunk": "sync_bit",
          "topic": "SYNC (Bit 1) \u2014 oscillator synchronization"
        },
        {
          "chunk": "waveform_selection_bits_and_output_behavior",
          "topic": "Waveform selection and final output amplitude behavior"
        }
      ]
    },
    {
      "start": 21965,
      "end": 21973,
      "name": "sync_bit",
      "description": "SYNC (Bit 1): When set, synchronizes the fundamental frequency of Oscillator 1 to Oscillator 3 (Hard Sync). Explains sonic effect \u2014 Oscillator 1 produces harmonic structures at Oscillator 3's frequency when varied relative to Oscillator 3. Requirements: Oscillator 3 must have a non-zero frequency (preferably lower than Oscillator 1); other Voice 3 parameters do not affect sync.",
      "references": [
        {
          "chunk": "control_register_overview_and_gate",
          "topic": "Control register and gating (Bit 0)"
        },
        {
          "chunk": "ring_mod_bit",
          "topic": "RING MOD (Bit 2) \u2014 interaction between Oscillators 1 and 3 for different effects"
        }
      ]
    },
    {
      "start": 21974,
      "end": 21982,
      "name": "ring_mod_bit",
      "description": "RING MOD (Bit 2): When set, replaces Oscillator 1's Triangle output with a ring-modulated combination of Oscillators 1 and 3. Describes resulting non-harmonic overtone structures useful for bell/gong sounds and special effects. Notes that the Triangle waveform must be selected and Oscillator 3 must have a non-zero frequency; other Voice 3 parameters do not affect ring modulation audibility.",
      "references": [
        {
          "chunk": "sync_bit",
          "topic": "SYNC (Bit 1) \u2014 another form of interaction with Oscillator 3"
        },
        {
          "chunk": "test_bit",
          "topic": "TEST (Bit 3) \u2014 oscillator reset/lock behavior that affects outputs"
        }
      ]
    },
    {
      "start": 21983,
      "end": 21988,
      "name": "test_bit",
      "description": "TEST (Bit 3): When set, resets and locks Oscillator 1 at zero until cleared. Also resets Noise output and holds Pulse output at a DC level. Primarily used for testing, but can synchronize Oscillator 1 to external events to allow generation of complex waveforms under real-time software control.",
      "references": [
        {
          "chunk": "ring_mod_bit",
          "topic": "RING MOD (Bit 2) \u2014 requires Triangle waveform selection affected by TEST"
        },
        {
          "chunk": "waveform_selection_bits_and_output_behavior",
          "topic": "Waveform outputs (Bits 4-7) and how TEST affects them"
        }
      ]
    },
    {
      "start": 21989,
      "end": 22024,
      "name": "waveform_selection_bits_and_output_behavior",
      "description": "Waveform select bits (Bits 4-7) and final output notes: Bit 4 selects Triangle waveform (low harmonics, mellow), Bit 5 selects Sawtooth (rich harmonics, bright), Bit 6 selects Pulse (harmonic content adjustable by Pulse Width registers; sweeping pulse width creates phasing/motion), Bit 7 selects Noise (random signal changing at Oscillator 1 frequency; useful for unpitched sounds and effects). Concludes that one output waveform must be selected for audibility but de-selecting is unnecessary to silence \u2014 final output amplitude is controlled by the Envelope Generator.",
      "references": [
        {
          "chunk": "pw_lo_hi_registers",
          "topic": "Pulse Width registers affecting Pulse waveform (Bit 6)"
        },
        {
          "chunk": "control_register_overview_and_gate",
          "topic": "Envelope Generator control via GATE (Bit 0) which determines final output amplitude"
        }
      ]
    },
    {
      "start": 22025,
      "end": 22045,
      "name": "oscillator_waveform_selection_and_noise_lock",
      "description": "Behavior of SID oscillator waveform selection: waveform outputs are not additive but logically ANDed when multiple waveforms are selected; this can produce additional waveforms but must be used with care. Interaction with Noise: selecting other waveforms with Noise on can cause the Noise output to 'lock up' (remain silent) until reset by the TEST bit or by bringing RES (pin 5) low. Includes surrounding appendix header/spacing lines for context.",
      "references": [
        {
          "chunk": "envelope_generator_attack_decay_sustain_release_and_rates",
          "topic": "Envelope generator registers and behavior (ATTACK/DECAY, SUSTAIN/RELEASE, rate table)"
        },
        {
          "chunk": "voice2_sync_and_ring_mod",
          "topic": "Voice-specific waveform and modulation features (SYNC/RING MOD)"
        },
        {
          "chunk": "filter_cutoff_resonance_and_routing",
          "topic": "How waveform outputs may be routed through the filter (FILT bits)"
        }
      ]
    },
    {
      "start": 22046,
      "end": 22124,
      "name": "envelope_generator_attack_decay_sustain_release_and_rates",
      "description": "SID Envelope Generator (Voice 1) controls and rates: ATTACK/DECAY (register $05) \u2014 bits 4-7 select 16 ATTACK rates; bits 0-3 select 16 DECAY rates. SUSTAIN/RELEASE (register $06) \u2014 bits 4-7 select 16 linear SUSTAIN levels (0\u201315), bits 0-3 select 16 RELEASE rates (identical to DECAY rates). NOTE on gating: Gate bit can alter cycling at any point (gated/released mid-cycle) enabling complex amplitude envelopes via real-time control. Table 2: list of ATTACK and DECAY/RELEASE times for values 0\u2013F (times shown are per cycle). NOTE on scaling: envelope rates are based on a 1.0 MHz 6502 clock; for other clocks multiply given rate by (1 MHz / clock). Examples of how to interpret times are included.",
      "references": [
        {
          "chunk": "oscillator_waveform_selection_and_noise_lock",
          "topic": "Waveform selection and potential interactions (e.g., noise) that affect perceived envelopes"
        },
        {
          "chunk": "voice2_sync_and_ring_mod",
          "topic": "Voice 2 uses the same envelope controls but has SYNC/RING MOD exceptions"
        },
        {
          "chunk": "filter_cutoff_resonance_and_routing",
          "topic": "How envelopes combine with filtering when voices are routed through the filter"
        }
      ]
    },
    {
      "start": 22125,
      "end": 22136,
      "name": "voice2_sync_and_ring_mod",
      "description": "Voice 2 control overview (registers $07\u2013$0D): functionally identical to Voice 1 controls except for two features \u2014 SYNC (when selected, synchronizes Oscillator 2 with Oscillator 1) and RING MOD (when selected, replaces Oscillator 2's Triangle output with the ring-modulated combination of Oscillators 2 and 1). Includes surrounding spacing and page footer lines for context.",
      "references": [
        {
          "chunk": "envelope_generator_attack_decay_sustain_release_and_rates",
          "topic": "Voice envelopes (ATTACK/DECAY and SUSTAIN/RELEASE) are controlled the same way as Voice 1"
        },
        {
          "chunk": "voice3_sync_ring_mod_and_voice_usage",
          "topic": "Voice 3 has analogous SYNC/RING MOD behavior with different oscillator relationships"
        },
        {
          "chunk": "filter_cutoff_resonance_and_routing",
          "topic": "Voice 2 can be routed through the filter (FILT 2 bit)"
        }
      ]
    },
    {
      "start": 22137,
      "end": 22156,
      "name": "voice3_sync_ring_mod_and_voice_usage",
      "description": "Voice 3 control overview (registers $0E\u2013$14): functionally identical to Voice 1 controls except SYNC synchronizes Oscillator 3 with Oscillator 2 and RING MOD replaces Oscillator 3's Triangle output with the ring-modulated combination of Oscillators 3 and 2. Typical voice operation: set frequency, waveform, effects (SYNC, RING MOD), and envelope rates; gate the voice to produce sound, sustain by holding the Gate bit, and stop by clearing it. Voices may be used independently or in unison (detuning and musical intervals create richer sounds).",
      "references": [
        {
          "chunk": "voice2_sync_and_ring_mod",
          "topic": "Voice 2 and Voice 3 have analogous SYNC/RING MOD relationships but synchronize to different oscillators"
        },
        {
          "chunk": "envelope_generator_attack_decay_sustain_release_and_rates",
          "topic": "Envelopes (ATTACK/DECAY, SUSTAIN/RELEASE) control each voice's amplitude over time"
        },
        {
          "chunk": "filter_cutoff_resonance_and_routing",
          "topic": "Voices can be routed through the filter to alter harmonic content"
        }
      ]
    },
    {
      "start": 22157,
      "end": 22181,
      "name": "filter_cutoff_resonance_and_routing",
      "description": "SID Filter controls: FC LO/FC HI (registers $15,$16) together form an 11-bit value (bits 3\u20137 of FC LO unused) that linearly controls the filter Cutoff/Center Frequency (approx. 30 Hz to 12 kHz). RES/FILT (register $17): bits 4\u20137 (RES0\u2013RES3) select one of 16 resonance settings (linear from 0 = no resonance to 15 = maximum resonance), which emphasize frequencies at the cutoff. Bits 0\u20133 (FILT1, FILT2, FILT3, FILTEX) determine routing \u2014 when a FILT bit is zero the respective signal bypasses the filter and appears directly on the audio output; when one, that signal is processed through the filter (applies to Voice 1, 2, 3, and External input on pin 26).",
      "references": [
        {
          "chunk": "voice3_sync_ring_mod_and_voice_usage",
          "topic": "Voices' outputs can be routed through this filter to shape harmonic content"
        },
        {
          "chunk": "voice2_sync_and_ring_mod",
          "topic": "Voice 2 routing (FILT 2) and how its modulated outputs interact with the filter"
        },
        {
          "chunk": "envelope_generator_attack_decay_sustain_release_and_rates",
          "topic": "Filter settings interact with voice envelopes to shape the final sound"
        }
      ]
    },
    {
      "start": 22182,
      "end": 22300,
      "name": "6581_sid_mode_volume_misc_and_io",
      "description": "SID MODE/VOL register and miscellaneous read registers: MODE/VOL bit definitions (LP, BP, HP filter outputs, 3OFF, volume nibble), how filter outputs are additive, volume control behavior; POTX and POTY A/D converter read registers (update timing and recommended pot/cap values), OSC3/RANDOM and ENV3 read registers (usage as modulation/random sources), and how OSC3/ENV3 can be used for modulation or random number generation.",
      "references": [
        {
          "chunk": "6581_sid_envelopes_and_voice2_voice3_filter",
          "topic": "filter routing and voice routing bits described earlier"
        },
        {
          "chunk": "6581_sid_pin_descriptions_part1",
          "topic": "hardware pins (POTX/POTY, EXT IN, AUDIO OUT) for these functions"
        }
      ]
    },
    {
      "start": 22301,
      "end": 22371,
      "name": "6581_sid_pin_descriptions_part1",
      "description": "SID pin descriptions: CAP1/CAP2 pins (CAP1A/CAP1B, CAP2A/CAP2B) for filter integrator capacitors (recommended values and formula FCmax = 2.6E-5/C), RES pin reset behavior, 02 (clock) behavior and its role as data-transfer gating, R/W pin for data direction, CS (/CS) chip select timing and address decode conditions, A0-A4 address inputs and addressing limitations, and GND grounding recommendations.",
      "references": [
        {
          "chunk": "6581_sid_mode_volume_misc_and_io",
          "topic": "POTX/POTY and EXT IN interactions described in later pin descriptions"
        },
        {
          "chunk": "6581_sid_pin_descriptions_part2",
          "topic": "continuation: data bus, POT interface, EXT IN and AUDIO OUT pin details"
        }
      ]
    },
    {
      "start": 22372,
      "end": 22446,
      "name": "6581_sid_pin_descriptions_part2",
      "description": "SID pin descriptions continued: D0-D7 bidirectional data bus behavior and drive capability, POTX/POTY A/D converter timing and recommended R/C values (recommended R=470k\u03a9, C=1000 pF), VCC and bypass recommendations, EXT IN analog input guidance (impedance ~100k\u03a9, recommended AC coupling and acceptable signal levels), AUDIO OUT (open-source buffer, typical levels, DC level 6V, recommended source resistor and AC coupling), and VDD (+12V) power recommendations.",
      "references": [
        {
          "chunk": "6581_sid_pin_descriptions_part1",
          "topic": "complements pin descriptions (CAP, RES, 02, address pins)"
        },
        {
          "chunk": "6581_sid_characteristics_and_electrical_tables",
          "topic": "absolute maximum ratings and electrical characteristics for these pins"
        }
      ]
    },
    {
      "start": 22447,
      "end": 22447,
      "name": "6581_sid_characteristics_and_electrical_tables",
      "description": "SID absolute maximum ratings and electrical characteristics: absolute maximum ratings for VDD, VCC, analog/digital input voltages and temperature ranges; electrical characteristics table (Vdd=12V, Vcc=5V, Ta 0\u201370\u00b0C) including logic voltage thresholds, leakage and three-state currents, output voltages and currents, input capacitances, POT trigger voltage/current, EXT IN input impedance, audio input/output voltage levels, and power supply currents/power dissipation typical values.",
      "references": [
        {
          "chunk": "6581_sid_pin_descriptions_part2",
          "topic": "electrical characteristics for pins like AUDIO OUT, EXT IN, POTX/POTY"
        },
        {
          "chunk": "6581_sid_timing_and_read_cycle",
          "topic": "timing characteristics and read-cycle timing"
        }
      ]
    },
    {
      "start": 22448,
      "end": 22463,
      "name": "6581_absolute_maximum_ratings",
      "description": "Absolute maximum ratings table for the 6581 SID: Supply Voltage VDD (-0.3 to +17 VDC), Supply Voltage VCC (-0.3 to +7 VDC), Analog Input Voltage Vina (-0.3 to +17 VDC), Digital Input Voltage Vind (-0.3 to +7 VDC), Operating Temperature Ta (0 to +70 \u00b0C), Storage Temperature Tstg (-55 to +150 \u00b0C).",
      "references": [
        {
          "chunk": "sid_pin_descriptions_pins_25_28",
          "topic": "Supply pin recommendations and DC levels"
        },
        {
          "chunk": "6581_electrical_characteristics",
          "topic": "Normal operating electrical characteristics"
        }
      ]
    },
    {
      "start": 22464,
      "end": 22527,
      "name": "6581_electrical_characteristics",
      "description": "Electrical characteristics for the 6581 SID (Vdd=12V\u00b15%, Vcc=5V\u00b15%, Ta=0\u201370 \u00b0C). Tables and typical/min/max values for: input thresholds (Vih, Vil), input leakage currents and three-state leakage (Iin, Itsi), output voltages and currents (Voh, Vol, Ioh, Iol), input capacitance (Cin), POT trigger voltage and sink current (Vpot, Ipot), EXT IN input impedance (~100\u2013150 kohm) and audio input voltage DC bias (~6 VDC) and AC amplitude limits (up to 3 VAC), AUDIO OUT DC level (~6 VDC) and AC levels (one voice ~0.5 VAC, all voices ~1.5 VAC typical), power supply currents (Idd for VDD ~20 mA typ, Icc for VCC ~70 mA typ), and total power dissipation (Pd ~600 mW typ).",
      "references": [
        {
          "chunk": "sid_pin_descriptions_pins_25_28",
          "topic": "Pin-level usage (EXT IN, AUDIO OUT) and recommended coupling/resistors"
        },
        {
          "chunk": "6581_absolute_maximum_ratings",
          "topic": "Absolute maximum voltages and temperatures"
        }
      ]
    },
    {
      "start": 22528,
      "end": 22528,
      "name": "6581_timing_read_cycle",
      "description": "6581 SID timing: READ CYCLE timing parameters (clock-related): Tcyc (clock cycle time), Tc (clock high pulse width), Tr/Tf (clock rise/fall time), Trs (read set-up time), Trh (read hold time), Tacc (access time up to 300 ns), Tah (address hold time), Tch (chip select hold time), Tdh (data hold time). The section includes a missing clock/timing diagram placeholder followed by the read-cycle table and units.",
      "references": [
        {
          "chunk": "6581_timing_write_cycle",
          "topic": "Write-cycle timing parameters"
        },
        {
          "chunk": "6581_electrical_characteristics",
          "topic": "Electrical conditions under which timing is specified"
        }
      ]
    },
    {
      "start": 22529,
      "end": 22601,
      "name": "6581_sid_timing_and_read_cycle",
      "description": "SID timing and read-cycle parameters: placeholder for SID timing diagrams (picture missing) and a read-cycle timing table listing clock cycle time (Tcyc), clock high pulse width (Tc), clock rise/fall times (Tr, Tf), read setup/hold times (Trs, Trh), access time (Tacc), address hold time (Tah), chip select hold (Tch) and data hold time (Tdh) with minimum/typical/maximum values and units.",
      "references": [
        {
          "chunk": "6581_sid_characteristics_and_electrical_tables",
          "topic": "electrical specs that complement timing specs"
        },
        {
          "chunk": "6581_sid_block_diagram_and_register_map",
          "topic": "register accesses and timing for reads/writes described there"
        }
      ]
    },
    {
      "start": 22602,
      "end": 22648,
      "name": "6581_timing_write_cycle",
      "description": "6581 SID timing: WRITE CYCLE timing parameters: Tw (write pulse width, min 300 ns), Twh (write hold time), Taws (address set-up time), Tah (address hold time), Tch (chip select hold time), Tvd (valid data, min 80 ns), Tdh (data hold time). Includes a missing timing diagram placeholder and the write-cycle table.",
      "references": [
        {
          "chunk": "6581_timing_read_cycle",
          "topic": "Read-cycle timing parameters"
        }
      ]
    },
    {
      "start": 22649,
      "end": 22691,
      "name": "equal_tempered_musical_scale_values",
      "description": "Discussion of equal-tempered musical scale values for the SID oscillator frequency registers. Explains the 12 semitones per octave relationship (each semitone = 12th root of 2 times previous), table based on a 1.02 MHz clock, concert pitch A4 = 440 Hz. Describes memory-efficient generation: store 12 semitone 16-bit values for the 8th octave (C-7..B-7) in a 24-byte table, then derive lower octaves by right-shifting (divide by two per octave). Notes special handling for B-7 MSB when shifting and packing semitone (lower nibble) and octave (upper nibble) into one byte for lookup/divide routine.",
      "references": [
        {
          "chunk": "sid_envelope_generators_adsr",
          "topic": "Envelope use with oscillator notes"
        }
      ]
    },
    {
      "start": 22692,
      "end": 22811,
      "name": "sid_envelope_generators_adsr",
      "description": "SID ADSR envelope generators: explanation of the four-part ADSR (Attack, Decay, Sustain, Release) envelope for amplitude control. Describes how ADSR models sustained instruments (example: violin), percussion (instant attack with rapid decay), piano/harpsichord behaviors (complex release behavior), organ (instant attack and sustain), and exotic envelopes (e.g., 'backwards' envelope: slow attack, rapid decay). Contains typical rate examples with numerical ADSR settings and approximate times (e.g., Attack 10 \u2248 500 ms; Decay/Release values and times listed for examples). Emphasizes creative sound design by combining envelopes and harmonic content.",
      "references": [
        {
          "chunk": "equal_tempered_musical_scale_values",
          "topic": "Oscillator frequency values and note generation"
        },
        {
          "chunk": "sid_pin_descriptions_pins_25_28",
          "topic": "Volume control and audio output considerations"
        }
      ]
    },
    {
      "start": 22812,
      "end": 22841,
      "name": "typical_6581_sid_application",
      "description": "Heading and placeholder for a 'Typical 6581/SID application' diagram. This region in the source contains a missing-picture placeholder and the title for a typical application schematic illustrating how the SID might be connected in a system. (No detailed schematic text present in the extracted lines.)",
      "references": [
        {
          "chunk": "sid_pin_descriptions_pins_25_28",
          "topic": "Pin-level considerations that would appear on typical application schematics (power, AUDIO OUT, EXT IN)"
        }
      ]
    },
    {
      "start": 22842,
      "end": 22891,
      "name": "glossary_appendix_p",
      "description": "Appendix P: Glossary of terms and abbreviations used in the manual. Defines terms relevant to the C64 and SID such as ADSR, attack, decay, sustain, release, CIA, DDR, FIFO, jiffy clock, NMI, POT/POKE/PEEK related terms, SID (Sound Interface Device), VIC-II, ROM, RAM, and others. Provides short definitions useful for quick reference.",
      "references": [
        {
          "chunk": "sid_envelope_generators_adsr",
          "topic": "ADSR/Attack/Decay/Sustain/Release definitions"
        },
        {
          "chunk": "commodore64_quick_reference_card",
          "topic": "Short definitions also relevant to quick reference"
        }
      ]
    },
    {
      "start": 22892,
      "end": 23358,
      "ignore": true,
      "reason": "Index \u2014 non-technical navigational material (to be ignored for semantic node extraction)"
    },
    {
      "start": 23359,
      "end": 23375,
      "name": "quick_reference_header_and_simple_variables",
      "description": "Header and SIMPLE VARIABLES: Commodore 64 Quick Reference Card title and concise description of simple variable types including Real, Integer (%) and String ($), their numeric/character ranges, and variable-naming rules (X = letter, Y = letter/number; only first two characters are significant).",
      "references": [
        {
          "chunk": "array_variables",
          "topic": "covers array variables and DIM requirements"
        },
        {
          "chunk": "operators_relational_and_logical",
          "topic": "covers arithmetic, relational and logical operators used with variables"
        }
      ]
    },
    {
      "start": 23376,
      "end": 23387,
      "name": "array_variables",
      "description": "ARRAY VARIABLES: Single-, two- and three-dimensional array notation (e.g., XY(5), XY(5,5), XY(5,5,5)), mention that arrays may use subscripts 0-10 without DIM, and note that arrays with more than eleven elements must be DIMensioned.",
      "references": [
        {
          "chunk": "quick_reference_header_and_simple_variables",
          "topic": "basic variable naming and types"
        },
        {
          "chunk": "arrays_and_string_functions",
          "topic": "detailed DIM usage and string/array helper functions"
        }
      ]
    },
    {
      "start": 23388,
      "end": 23400,
      "name": "operators_relational_and_logical",
      "description": "ALGEBRAIC, RELATIONAL AND LOGICAL OPERATORS: Lists BASIC arithmetic operators (= assignment, -, ^, *, /, +, -), relational operators (=, <>, <, >, <=, >=), and logical operators (NOT, AND, OR). Notes that expressions evaluate to 1 if true and 0 if false.",
      "references": [
        {
          "chunk": "quick_reference_header_and_simple_variables",
          "topic": "variables used with operators"
        },
        {
          "chunk": "system_commands",
          "topic": "system-level commands where operators may be used in expressions"
        }
      ]
    },
    {
      "start": 23401,
      "end": 23429,
      "name": "system_commands",
      "description": "SYSTEM COMMANDS: Concise list of BASIC system-level and I/O related commands for loading/saving and program control: LOAD/SAVE (tape and disk usage with ,8), VERIFY, RUN (and RUN with a line number), STOP, END, CONT, PEEK(X), POKE X,Y, SYS xxxxx (jump to machine code), WAIT X,Y,Z (polling with EOR and AND), USR(X) for passing values to machine language subroutines.",
      "references": [
        {
          "chunk": "operators_relational_and_logical",
          "topic": "operators used in expressions and conditions"
        },
        {
          "chunk": "editing_and_formatting_commands",
          "topic": "commands for editing and formatting program listings"
        }
      ]
    },
    {
      "start": 23430,
      "end": 23450,
      "name": "editing_and_formatting_commands",
      "description": "EDITING AND FORMATTING COMMANDS: Commands for listing and editing program text (LIST, LIST A-B, REM comments), PRINT formatting helpers (TAB(X), SPC(X), POS(X)), screen and cursor control (CLR/HOME, SHIFT+CLR/HOME to clear, SHIFT+INST/DEL to insert, INST/DEL to delete), special-key behaviors (CTRL with numeric color key to select text color, CRSR keys to move cursor, Commodore key for upper/lower/graphics and alternate text colors).",
      "references": [
        {
          "chunk": "system_commands",
          "topic": "system-level execution and file commands"
        },
        {
          "chunk": "arrays_and_string_functions",
          "topic": "string and array manipulation functions used in programs"
        }
      ]
    },
    {
      "start": 23451,
      "end": 23469,
      "name": "arrays_and_string_functions",
      "description": "ARRAYS AND STRINGS: DIM A(X,Y,Z) semantics (reserves (X+1)*(Y+1)*(Z+1) elements starting at A(0,...)), string/array helper functions: LEN(X$), STR$(X), VAL(X$), CHR$(X), ASC(X$), LEFT$(A$,X), RIGHT$(A$,X), MID$(A$,X,Y). Explains what each function returns (length, conversion, ASCII code/char, substring extraction).",
      "references": [
        {
          "chunk": "array_variables",
          "topic": "array DIM and sizing rules"
        },
        {
          "chunk": "input_output_commands",
          "topic": "functions often used with PRINT/INPUT and I/O operations"
        }
      ]
    },
    {
      "start": 23470,
      "end": 23483,
      "name": "input_output_commands",
      "description": "INPUT/OUTPUT COMMANDS: User I/O statements and DATA handling: INPUT (prompts with ? and waits for input), INPUT with prompt string, GET (single character input without RETURN), DATA/READ/RESTORE for storing and retrieving data constants, PRINT formatting conventions (PRINT \"A= \";A \u2014 use of ; to suppress spaces and , to tab to next field).",
      "references": [
        {
          "chunk": "arrays_and_string_functions",
          "topic": "string functions used when processing user input and printing"
        },
        {
          "chunk": "program_flow_statements",
          "topic": "control-flow constructs that use input/output in program logic"
        }
      ]
    },
    {
      "start": 23484,
      "end": 23500,
      "name": "program_flow_statements",
      "description": "PROGRAM FLOW: Control-flow statements in BASIC: GOTO (branch to line), IF ... THEN (conditional execution), FOR ... TO ... STEP ... / NEXT (loops and step size; NEXT A optional), GOSUB/RETURN (subroutines and returning), ON X GOTO A,B (computed GOTO), ON X GOSUB A,B (computed GOSUB). Examples include FOR A=1 TO 10 STEP 2 and GOSUB 2000/RETURN behavior.",
      "references": [
        {
          "chunk": "input_output_commands",
          "topic": "I/O often used within control flow (INPUT/PRINT/DATA)"
        },
        {
          "chunk": "system_commands",
          "topic": "program execution commands like RUN, STOP, CONT that interact with program flow"
        }
      ]
    },
    {
      "start": 23501,
      "end": 23594,
      "ignore": true,
      "reason": "Marketing/credits and etext footer \u2014 non-technical material (publisher blurb, credits, and Project Gutenberg/etext end material)"
    }
  ],
  "source_md5": "52f9cd7067c5c147fc6bf1149fd44ce4"
}
