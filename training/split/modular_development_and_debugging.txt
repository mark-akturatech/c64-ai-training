# Contents - Guidance on modular development: build small routines, individually test and save reusable segments, keep subroutines at end to allow unused ones to be removed, chain modules if assembler supports it, and benefits of partitioning on slow disk systems.

When you are starting any program, especial- 
ly one in assembly language, it is important to break 
the program into a number of smaller routines. 
Quite often, the small routines can be individually 
tested and later merged to form a complete program. 
Also, small segments can be saved for use later in 
other similar programs so that you won't have to 
start from scratch every time. Unless you write 
perfect programs every time, small program 
segments will be much easier to debug. If you write 
an entire program and then try to make it run, it 
can become quite difficult to determine where in the 
program the problem is. On the other hand, if you 
had tested all the small program segments before 
merging them into a complete program, the only 
problems that you might encounter should be in the 
interconnections between the program segments. 
Since you already know that all of the pieces of the 
program work, you should not have any difficulty 
finding the bugs. 



As you are writing your program, do not be 
alarmed if you realize that you have not defined 
something you need to use. Simply write what you 
have forgotten on paper and use it in the code as 
if it had been defined. Then, when you feel like tak- 
ing a break from the creative process, go back and 
insert your addition into the proper definition file. 
Until you try to assemble your program, the com- 
puter does not know or care what has or has not 
been defined. 

You may have been wondering why the 
subroutines should be placed at the end of your pro- 
gram. Unlike the macro library, any subroutine in 
your program will use a certain amount of memory, 
whether it is used or not. Because of this, any 
subroutine that is not used should be deleted so as 
not to waste memory space or the time that it takes 
the assembler to assemble the subroutine. 

By following this general outline, you will have 
a manageable and modular way with which to ap- 
proach the design of your program. Most 
assemblers have a command that allows you to chain 
together different parts of your program. If your 
assembler has the ability, you may find it desirable 
to write all of the different modules of your program 
as separate files, and then let the assembler link 
them together as it assembles the program. This 
has some advantages over creating one massive file. 
For instance, if you need to add a definition to your 
RAM definitions, you only need to load the file with 
your other definitions. If your disk drive is par- 
ticularly slow (as all Commodore 64 drives are), you 
will find a partitioning of your program quite a time 
saver. As your program progresses, the definitions 
and data areas will rarely need modifying. Keep- 
ing all of the parts of the program separate allows 
you to edit or print the part of the program that you 
are currently working on without having to deal 
with those parts of the program that have been 
tested and debugged. 



18 




---
Additional information can be found by searching:
- "what_an_assembler_can_do" which expands on creating libraries of subroutines and macros
