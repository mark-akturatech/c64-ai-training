# C64 KERNAL ROM Disassembly $E700-$E7FF - Keyboard Decode

.,E700 60       RTS             

                                *** back onto the previous line if possible
.,E701 A6 D6    LDX $D6         get the cursor row
.,E703 D0 06    BNE $E70B       branch if not top row
.,E705 86 D3    STX $D3         clear cursor column
.,E707 68       PLA             dump return address low byte
.,E708 68       PLA             dump return address high byte
.,E709 D0 9D    BNE $E6A8       restore registers, set quote flag and exit, branch always
.,E70B CA       DEX             decrement the cursor row
.,E70C 86 D6    STX $D6         save the cursor row
.,E70E 20 6C E5 JSR $E56C       set the screen pointers for cursor row, column
.,E711 A4 D5    LDY $D5         get current screen line length
.,E713 84 D3    STY $D3         save the cursor column
.,E715 60       RTS             

                                *** output a character to the screen
.,E716 48       PHA             save character
.,E717 85 D7    STA $D7         save temporary last character
.,E719 8A       TXA             copy X
.,E71A 48       PHA             save X
.,E71B 98       TYA             copy Y
.,E71C 48       PHA             save Y
.,E71D A9 00    LDA #$00        clear A
.,E71F 85 D0    STA $D0         clear input from keyboard or screen, $xx = screen,
                                $00 = keyboard
.,E721 A4 D3    LDY $D3         get cursor column
.,E723 A5 D7    LDA $D7         restore last character
.,E725 10 03    BPL $E72A       branch if unshifted
.,E727 4C D4 E7 JMP $E7D4       do shifted characters and return
.,E72A C9 0D    CMP #$0D        compare with [CR]
.,E72C D0 03    BNE $E731       branch if not [CR]
.,E72E 4C 91 E8 JMP $E891       else output [CR] and return
.,E731 C9 20    CMP #$20        compare with [SPACE]
.,E733 90 10    BCC $E745       branch if < [SPACE]
.,E735 C9 60    CMP #$60        
.,E737 90 04    BCC $E73D       branch if $20 to $5F
                                character is $60 or greater
.,E739 29 DF    AND #$DF        
.,E73B D0 02    BNE $E73F       
.,E73D 29 3F    AND #$3F        
.,E73F 20 84 E6 JSR $E684       if open quote toggle cursor direct/programmed flag
.,E742 4C 93 E6 JMP $E693       
                                character was < [SPACE] so is a control character
                                of some sort
.,E745 A6 D8    LDX $D8         get the insert count
.,E747 F0 03    BEQ $E74C       if no characters to insert continue
.,E749 4C 97 E6 JMP $E697       insert reversed character
.,E74C C9 14    CMP #$14        compare the character with [INSERT]/[DELETE]
.,E74E D0 2E    BNE $E77E       if not [INSERT]/[DELETE] go ??
.,E750 98       TYA             
.,E751 D0 06    BNE $E759       
.,E753 20 01 E7 JSR $E701       back onto the previous line if possible
.,E756 4C 73 E7 JMP $E773       
.,E759 20 A1 E8 JSR $E8A1       test for line decrement
                                now close up the line
.,E75C 88       DEY             decrement index to previous character
.,E75D 84 D3    STY $D3         save the cursor column
.,E75F 20 24 EA JSR $EA24       calculate the pointer to colour RAM
.,E762 C8       INY             increment index to next character
.,E763 B1 D1    LDA ($D1),Y     get character from current screen line
.,E765 88       DEY             decrement index to previous character
.,E766 91 D1    STA ($D1),Y     save character to current screen line
.,E768 C8       INY             increment index to next character
.,E769 B1 F3    LDA ($F3),Y     get colour RAM byte
.,E76B 88       DEY             decrement index to previous character
.,E76C 91 F3    STA ($F3),Y     save colour RAM byte
.,E76E C8       INY             increment index to next character
.,E76F C4 D5    CPY $D5         compare with current screen line length
.,E771 D0 EF    BNE $E762       loop if not there yet
.,E773 A9 20    LDA #$20        set [SPACE]
.,E775 91 D1    STA ($D1),Y     clear last character on current screen line
.,E777 AD 86 02 LDA $0286       get the current colour code
.,E77A 91 F3    STA ($F3),Y     save to colour RAM
.,E77C 10 4D    BPL $E7CB       branch always
.,E77E A6 D4    LDX $D4         get cursor quote flag, $xx = quote, $00 = no quote
.,E780 F0 03    BEQ $E785       branch if not quote mode
.,E782 4C 97 E6 JMP $E697       insert reversed character
.,E785 C9 12    CMP #$12        compare with [RVS ON]
.,E787 D0 02    BNE $E78B       if not [RVS ON] skip setting the reverse flag
.,E789 85 C7    STA $C7         else set the reverse flag
.,E78B C9 13    CMP #$13        compare with [CLR HOME]
.,E78D D0 03    BNE $E792       if not [CLR HOME] continue
.,E78F 20 66 E5 JSR $E566       home the cursor
.,E792 C9 1D    CMP #$1D        compare with [CURSOR RIGHT]
.,E794 D0 17    BNE $E7AD       if not [CURSOR RIGHT] go ??
.,E796 C8       INY             increment the cursor column
.,E797 20 B3 E8 JSR $E8B3       test for line increment
.,E79A 84 D3    STY $D3         save the cursor column
.,E79C 88       DEY             decrement the cursor column
.,E79D C4 D5    CPY $D5         compare cursor column with current screen line length
.,E79F 90 09    BCC $E7AA       exit if less
                                else the cursor column is >= the current screen line
                                length so back onto the current line and do a newline
.,E7A1 C6 D6    DEC $D6         decrement the cursor row
.,E7A3 20 7C E8 JSR $E87C       do newline
.,E7A6 A0 00    LDY #$00        clear cursor column
.,E7A8 84 D3    STY $D3         save the cursor column
.,E7AA 4C A8 E6 JMP $E6A8       restore the registers, set the quote flag and exit
.,E7AD C9 11    CMP #$11        compare with [CURSOR DOWN]
.,E7AF D0 1D    BNE $E7CE       if not [CURSOR DOWN] go ??
.,E7B1 18       CLC             clear carry for add
.,E7B2 98       TYA             copy the cursor column
.,E7B3 69 28    ADC #$28        add one line
.,E7B5 A8       TAY             copy back to Y
.,E7B6 E6 D6    INC $D6         increment the cursor row
.,E7B8 C5 D5    CMP $D5         compare cursor column with current screen line length
.,E7BA 90 EC    BCC $E7A8       if less go save cursor column and exit
.,E7BC F0 EA    BEQ $E7A8       if equal go save cursor column and exit
                                else the cursor has moved beyond the end of this line
                                so back it up until it's on the start of the logical line
.,E7BE C6 D6    DEC $D6         decrement the cursor row
.,E7C0 E9 28    SBC #$28        subtract one line
.,E7C2 90 04    BCC $E7C8       if on previous line exit the loop
.,E7C4 85 D3    STA $D3         else save the cursor column
.,E7C6 D0 F8    BNE $E7C0       loop if not at the start of the line
.,E7C8 20 7C E8 JSR $E87C       do newline
.,E7CB 4C A8 E6 JMP $E6A8       restore the registers, set the quote flag and exit
.,E7CE 20 CB E8 JSR $E8CB       set the colour code
.,E7D1 4C 44 EC JMP $EC44       go check for special character codes
.,E7D4 29 7F    AND #$7F        mask 0xxx xxxx, clear b7
.,E7D6 C9 7F    CMP #$7F        was it $FF before the mask
.,E7D8 D0 02    BNE $E7DC       branch if not
.,E7DA A9 5E    LDA #$5E        else make it $5E
.,E7DC C9 20    CMP #$20        compare the character with [SPACE]
.,E7DE 90 03    BCC $E7E3       if < [SPACE] go ??
.,E7E0 4C 91 E6 JMP $E691       insert uppercase/graphic character and return
                                character was $80 to $9F and is now $00 to $1F
.,E7E3 C9 0D    CMP #$0D        compare with [CR]
.,E7E5 D0 03    BNE $E7EA       if not [CR] continue
.,E7E7 4C 91 E8 JMP $E891       else output [CR] and return
                                was not [CR]
.,E7EA A6 D4    LDX $D4         get the cursor quote flag, $xx = quote, $00 = no quote
.,E7EC D0 3F    BNE $E82D       branch if quote mode
.,E7EE C9 14    CMP #$14        compare with [INSERT DELETE]
.,E7F0 D0 37    BNE $E829       if not [INSERT DELETE] go ??
.,E7F2 A4 D5    LDY $D5         get current screen line length
.,E7F4 B1 D1    LDA ($D1),Y     get character from current screen line
.,E7F6 C9 20    CMP #$20        compare the character with [SPACE]
.,E7F8 D0 04    BNE $E7FE       if not [SPACE] continue
.,E7FA C4 D3    CPY $D3         compare the current column with the cursor column
.,E7FC D0 07    BNE $E805       if not cursor column go open up space on line
.,E7FE C0 4F    CPY #$4F        compare current column with max line length
