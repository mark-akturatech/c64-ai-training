# Kick Assembler - Section 3.6: Data generation directives (.byte, .word, .dword, .text), aliases (.by, .wo, .dw), .fill and .fillword with examples (including pattern fills), .lohifill for generating interleaved lo/hi tables, and performance note: .fill compiles faster than .for + .byte.

3.6. Data Directives
The .byte, .word, .dword and .text directives are used to generate byte, word (one word= two bytes), dword
(double word = 4 bytes) and text data as in standard 65xx assemblers.
.byte 1,2,3,4
// Generates the bytes 1,2,3,4
.word $2000,$1234 // Generates the bytes $00,$20,$34,$12
.dword $12341234
// Generates the bytes $34,$12,$34,$12
.text "Hello World"

You can use .by, .wo and .dw as aliases for .byte, .word and .dword, so '.by $10' is the same as '.byte $10'.
With the .fill directive you can fill a section of the memory with bytes. It works like a loop and automatically
sets the variable i to the iteration number.

8

Basic Assembler Functionality

// Nomal filling
.fill 5, 0 // Generates byte 0,0,0,0,0
.fill 5, i // Generates byte 0,1,2,3,4
.fill 256, 127.5 + 127.5*sin(toRadians(i*360/256)) // Generates a sine curve
// Use [,,] to fill with a repeat pattern
.fill 4, [$10,$20]
// Generates .byte $10,$20,$10,$20,$10,$20,$10,$20
.fill 3, ['D','E','M','O','!'] // Generates the same bytes as .text "DEMO!DEMO!
DEMO!"
.fill 3, [i,i*$10]
// Generates .byte 0,0,1,$10,2,$20
// .fillword is like .fill but with .word directives
.fillword 5,i*$80
// Generates .word $0000,$0080,$0100,$0180,$0200
.fillword 2,[$100,0]
// Generates .word $0100,$0000,$0100,$0000

In most cases it is more desirable to have two lists, one with low byte and one with high byte, than a word list.
To generate this you can use the .lohifill directive. It generates the two list right after each each other and lets your
access them using a hi/lo field on a connected label like this:
ldx #20
// ychar coord
ldy #15
// xchar coord
clc
lda mul40.lo,x // Access lo byte table
sta $fe
lda mul40.hi,x // Access hi byte table
ora #$04
sta $ff
lda #'x'
sta ($fe),y
// Draws 'x' at screenpos x,y
rts

mul40: .lohifill $100, 40*i

// Generates lo/hi table:
// .byte <0, <40, <80, <120, ....
// .byte >0, >40, >80, >120, ....

Generating bytes using the fill directive will compile faster than generating byte using the .for and .byte directives. (The .for directive will be explained later.)

---
Additional information can be found by searching:
- "encoding_and_charset_options" which expands on .text encoding impact and available encodings
- "functions_define" which expands on recommendations for heavy table generation and define/.lock usage
