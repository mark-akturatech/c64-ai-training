# CA65 Assembler - Cheap Local Labels, Unnamed Labels, Macros for Labels

6.5 Cheap local labels
Cheap local labels are defined like standard labels, but the name of the label must begin with a special symbol (usually '@', but this can be changed by the .LOCALCHAR directive).

Cheap local labels are visible only between two non cheap labels. As soon as a standard symbol is encountered (this may also be a local symbol if inside a region defined with the .PROC directive), the cheap local symbol goes out of scope.

You may use cheap local labels as an easy way to reuse common label names like "Loop". Here is an example:


        Clear:  lda    #$00             ; Global label
                ldy    #$20
        @Loop:  sta    Mem,y            ; Local label
                dey
                bne    @Loop            ; Ok
                rts
        Sub:    ...                     ; New global label
                bne    @Loop            ; ERROR: Unknown identifier!
6.6 Unnamed labels
If you really want to write messy code, there are also unnamed labels. To define an unnamed label, use sole :.

To reference an unnamed label, use : with several - or + characters. The - characters will create a back reference (n'th label backwards), the + will create a forward reference (n'th label in forward direction). As an alternative, angle brackets < and > may be used instead of - and + with the same meaning.

Example:


        cpy #0
        beq :++
    :
        sta $2007
        dey
        bne :-
    :
        rts
Unnamed labels may make even short sections of code hard to understand, because you have to count labels to find branch targets. It's better to prefer the "cheap" local labels. Nevertheless, unnamed labels are convenient in some situations, so it's up to your discretion.

Note: Scopes organize named symbols, not unnamed ones, so scopes don't have an effect on unnamed labels.

6.7 Using macros to define labels and constants
While there are drawbacks with this approach, it may be handy in a few rare situations. Using .DEFINE, it is possible to define symbols or constants that may be used elsewhere. One of the advantages is that you can use it to define string constants (this is not possible with the other symbol types).

Please note: .DEFINE style macros do token replacements on a low level, so the names do not adhere to scoping, diagnostics may be misleading, there are no symbols to look up in the map file, and there is no debug info. Especially the first problem in the list can lead to very nasty programming errors. Because of these problems, the general advice is, NOT do use .DEFINE if you don't have to.

Example:


        .DEFINE two     2
        .DEFINE version "SOS V2.3"

        four = two * two        ; Ok
        .byte   version         ; Ok

        .PROC                   ; Start local scope
        two = 3                 ; Will give "2 = 3" - invalid!
        .ENDPROC
6.8 Symbols and .DEBUGINFO
If .DEBUGINFO is enabled (or -g is given on the command line), global, local and cheap local labels are written to the object file and will be available in the symbol file via the linker. Unnamed labels are not written to the object file, because they don't have a name which would allow to access them.

