# - Fully Commented Commodore 64 ROM Disassembly (English) - PEEK/POKE/WAIT parameter extraction and integer conversion: evaluate address expression, convert FAC1 into a temporary integer, handle syntax for additional parameters (e.g., POKE value, WAIT mask), perform memory read/write for PEEK/POKE, and implement WAIT polling loop with optional mask/eor argument. Performs numeric checks and raises errors for illegal quantities or range problems.

                                *** get parameters for POKE/WAIT
.,B7EB 20 8A AD JSR $AD8A       evaluate expression and check is numeric, else do
                                type mismatch
.,B7EE 20 F7 B7 JSR $B7F7       convert FAC_1 to integer in temporary integer
.,B7F1 20 FD AE JSR $AEFD       scan for ",", else do syntax error then warm start
.,B7F4 4C 9E B7 JMP $B79E       get byte parameter and return

                                *** convert FAC_1 to integer in temporary integer
.,B7F7 A5 66    LDA $66         get FAC1 sign
.,B7F9 30 9D    BMI $B798       if -ve do illegal quantity error then warm start
.,B7FB A5 61    LDA $61         get FAC1 exponent
.,B7FD C9 91    CMP #$91        compare with exponent = 2^16
.,B7FF B0 97    BCS $B798       if >= do illegal quantity error then warm start
.,B801 20 9B BC JSR $BC9B       convert FAC1 floating to fixed
.,B804 A5 64    LDA $64         get FAC1 mantissa 3
.,B806 A4 65    LDY $65         get FAC1 mantissa 4
.,B808 84 14    STY $14         save temporary integer low byte
.,B80A 85 15    STA $15         save temporary integer high byte
.,B80C 60       RTS             

                                *** perform PEEK()
.,B80D A5 15    LDA $15         get line number high byte
.,B80F 48       PHA             save line number high byte
.,B810 A5 14    LDA $14         get line number low byte
.,B812 48       PHA             save line number low byte
.,B813 20 F7 B7 JSR $B7F7       convert FAC_1 to integer in temporary integer
.,B816 A0 00    LDY #$00        clear index
.,B818 B1 14    LDA ($14),Y     read byte
.,B81A A8       TAY             copy byte to A
.,B81B 68       PLA             pull byte
.,B81C 85 14    STA $14         restore line number low byte
.,B81E 68       PLA             pull byte
.,B81F 85 15    STA $15         restore line number high byte
.,B821 4C A2 B3 JMP $B3A2       convert Y to byte in FAC_1 and return

                                *** perform POKE
.,B824 20 EB B7 JSR $B7EB       get parameters for POKE/WAIT
.,B827 8A       TXA             copy byte to A
.,B828 A0 00    LDY #$00        clear index
.,B82A 91 14    STA ($14),Y     write byte
.,B82C 60       RTS             

                                *** perform WAIT
.,B82D 20 EB B7 JSR $B7EB       get parameters for POKE/WAIT
.,B830 86 49    STX $49         save byte
.,B832 A2 00    LDX #$00        clear mask
.,B834 20 79 00 JSR $0079       scan memory
.,B837 F0 03    BEQ $B83C       skip if no third argument
.,B839 20 F1 B7 JSR $B7F1       scan for "," and get byte, else syntax error then
                                warm start
.,B83C 86 4A    STX $4A         save EOR argument
.,B83E A0 00    LDY #$00        clear index
.,B840 B1 14    LDA ($14),Y     get byte via temporary integer (address)
.,B842 45 4A    EOR $4A         EOR with second argument       (mask)
.,B844 25 49    AND $49         AND with first argument        (byte)
.,B846 F0 F8    BEQ $B840       loop if result is zero
.,B848 60       RTS             


---
Additional information can be found by searching:
- "val_string_to_fac_and_restore_exec" which expands on FAC1-to-integer conversion helper used for address parameters
