# - Commented Commodore 64 KERNAL Disassembly (Magnus Nyman) - Main IRQ entry routine invoked via hardware vector $FF48 -> CINV. Updates the realtime clock (JSR $FFEA -> UDTIM), handles cursor blinking (BLNSW at $00CC, BLNCT at $00CD, BLNON/BLNON toggling, inverts character under cursor at $00CE), synchronises colour pointer and GDCOL ($0287/$0286), prints the toggled cursor glyph via a screen-print routine, processes processor port flags in $01 (STOP key handling), calls the keyboard scanner (JSR $EA87), clears CIA#1 interrupt control register ($DC0D), restores registers from stack (PLA/TAY/PLA/TAX/PLA) and returns from interrupt (RTI).

                                *** MAIN IRQ ENTRY POINT
                                This routine services the normal IRQ that jumps through
                                the hardware vector to $ff48, and then continues to the
                                CINV vector at $0314. First it checks if the <STOP> key
                                was pressed and updates the realtime clock. Next, the
                                cursor is updated (if it is enabled, BLNSW). The blink
                                counter, BLNCT, is decremented. When this reaches zero,
                                the cursor is toggled (blink on/off). Finally it scans
                                the keyboard. The processor registers are then restored
                                on exit.
.,EA31 20 EA FF JSR $FFEA       update realtime clock, routine UDTIM
.,EA34 A5 CC    LDA $CC         read BLNSW to see if cursor is enabled
.,EA36 D0 29    BNE $EA61       nope
.,EA38 C6 CD    DEC $CD         read BLNCT
.,EA3A D0 25    BNE $EA61       if zero, toggle cursor - else jump
.,EA3C A9 14    LDA #$14        blink speed
.,EA3E 85 CD    STA $CD         restore BLCNT
.,EA40 A4 D3    LDY $D3         get PNTR, cursor column
.,EA42 46 CF    LSR $CF         BLNON, flag last cursor blink on/off
.,EA44 AE 87 02 LDX $0287       get background colour under cursor, GDCOL
.,EA47 B1 D1    LDA ($D1),Y     get screen character
.,EA49 B0 11    BCS $EA5C       ?
.,EA4B E6 CF    INC $CF         increment BLNON
.,EA4D 85 CE    STA $CE         temporary store character under cursor
.,EA4F 20 24 EA JSR $EA24       synchronise colour pointer
.,EA52 B1 F3    LDA ($F3),Y     get colour under character
.,EA54 8D 87 02 STA $0287       store in GDCOL
.,EA57 AE 86 02 LDX $0286       get current COLOR
.,EA5A A5 CE    LDA $CE         retrieve character under cursor
.,EA5C 49 80    EOR #$80        toggle cursor by inverting character
.,EA5E 20 1C EA JSR $EA1C       print to screen by using part of 'print to screen'
.,EA61 A5 01    LDA $01
.,EA63 29 10    AND #$10
.,EA65 F0 0A    BEQ $EA71
.,EA67 A0 00    LDY #$00
.,EA69 84 C0    STY $C0
.,EA6B A5 01    LDA $01
.,EA6D 09 20    ORA #$20
.,EA6F D0 08    BNE $EA79
.,EA71 A5 C0    LDA $C0
.,EA73 D0 06    BNE $EA7B
.,EA75 A5 01    LDA $01
.,EA77 29 1F    AND #$1F
.,EA79 85 01    STA $01
.,EA7B 20 87 EA JSR $EA87       scan keyboard
.,EA7E AD 0D DC LDA $DC0D       clear CIA#1 I.C.R to enable next IRQ
.,EA81 68       PLA             restore (Y), (X), (A)
.,EA82 A8       TAY
.,EA83 68       PLA
.,EA84 AA       TAX
.,EA85 68       PLA
.,EA86 40       RTI             back to normal


---
Additional information can be found by searching:
- "scnkey_keyboard_scan" which expands on keyboard scanning entry point called by MAIN IRQ
- "process_key_image_decode_and_buffer" which expands on processing of key once SCNKEY found a key
