# 6502 Instruction Set - Detailed analysis of how undocumented opcodes arise from executing two instruction micro-threads (c=1 and c=2) concurrently when opcode low bits = 3, leading to combined operations whose outputs are AND-ed on internal data lines. Explains JAM (timing failure), NOPs (non-sensical mode combos), and unstable instructions where contention leads to 'magic constant' behavior depending on chip series/temperature. Specific opcode mappings and examples given (ANE $8B, LXA $AB, TAS $9B and SHA/SHX/SHY 'H+1' behaviors). Concludes illegals are undefined input behavior.

              LDA #$32 ;00110010
              PHA  ->  0 0 1 1 0 0 1 0   =  $32
              PLP  <-  0 0 - - 0 0 1 0   =  $02
          3)
              LDA #$C0
              PHA -> 1 1 0 0 0 0 0 0     =  $C0
                                                               6502 Instruction Set
              LDA #$08
              PHA -> 0 0 0 0 1 0 0 0     =  $08
              LDA #$12
              PHA -> 0 0 0 1 0 0 1 0     =  $12
              RTI
                    SR: 0 0 - - 0 0 1 0  =  $02
                    PC: $C008
          Mind that most emulators are displaying the status register (SR or P) in the
          state as it would be currently pushed to the stack, with bits 4 and 5 on, adding
          a bias of $30 to the register value. Here, we chose to rather omit this virtual
          presence of these bits, since there isn't really a slot for them in the hardware.
          6502 Instruction Layout
          The 6502 instruction table is laid out according to a pattern a-b-c, where
          a and b are an octal number each, followed by a group of two binary digits c,
          as in the bit-vector "aaabbbcc".
                  a a a b b b c c
            bit   7 6 5 4 3 2 1 0
                   (0…7)  (0…7) (0…3)
          Example:
          All ROR instructions share a = 3 and c = 2 (3b2) with the address mode in b.
          At the same time, all instructions addressing the zero-page share b = 1 (a1c).
          abc = 312 => ( 3 << 5 | 1 << 2 | 2 ) = %011.001.10 = $66 "ROR zpg".
          Notably, there are no legal opcodes defined where c = 3, accounting for the
          empty columns in the usual, hexadecimal view of the instruction table.
          (For compactness empty rows where c = 3 are omitted from the tables below.)
          The following table lists the instruction set, rows sorted by c, then a.
          Generally, instructions of a kind are typically found in rows as a combination
          of a and c, and address modes are in columns b.
          However, there are a few exception to this rule, namely, where bits 0 of both
          c and b are low (c = 0, 2; b = 0, 2, 4, 6) and combinations of c and b select
          a group of related operations. (E.g., c=0 ∧ b=4: branch, c=0 ∧ b=6: set flag)
                c          a                                                               b
                                         0               1           2            3                  4     5      6       7
                0          0       $00  BRK impl                $08 PHP impl                 $10   BPL rel   $18 CLC impl
                           1       $20  JSR abs     $24 BIT zpg $28 PLP impl $2C BIT abs     $30   BMI rel   $38 SEC impl
                                                                         6502 Instruction Set
               c          a                                                                      b
                                         0               1              2               3                  4            5             6             7
                          2       $40  RTI impl                   $48  PHA impl   $4C  JMP abs     $50   BVC rel                 $58 CLI impl
                          3       $60  RTS impl                   $68  PLA impl   $6C  JMP ind     $70   BVS rel                 $78 SEI impl
                          4                         $84 STY zpg   $88  DEY impl   $8C  STY abs     $90   BCC rel   $94 STY zpg,X $98 TYA impl
                          5       $A0  LDY #        $A4 LDY zpg   $A8  TAY impl   $AC  LDY abs     $B0   BCS rel   $B4 LDY zpg,X $B8 CLV impl  $BC LDY abs,X
                          6       $C0  CPY #        $C4 CPY zpg   $C8  INY impl   $CC  CPY abs     $D0   BNE rel                 $D8 CLD impl
                          7       $E0  CPX #        $E4 CPX zpg   $E8  INX impl   $EC  CPX abs     $F0   BEQ rel                 $F8 SED impl
                          0       $01  ORA X,ind    $05 ORA zpg   $09  ORA #      $0D  ORA abs     $11   ORA ind,Y $15 ORA zpg,X $19 ORA abs,Y $1D ORA abs,X
                          1       $21  AND X,ind    $25 AND zpg   $29  AND #      $2D  AND abs     $31   AND ind,Y $35 AND zpg,X $39 AND abs,Y $3D AND abs,X
                          2       $41  EOR X,ind    $45 EOR zpg   $49  EOR #      $4D  EOR abs     $51   EOR ind,Y $55 EOR zpg,X $59 EOR abs,Y $5D EOR abs,X
                          3       $61  ADC X,ind    $65 ADC zpg   $69  ADC #      $6D  ADC abs     $71   ADC ind,Y $75 ADC zpg,X $79 ADC abs,Y $7D ADC abs,X
               1
                          4       $81  STA X,ind    $85 STA zpg                   $8D  STA abs     $91   STA ind,Y $95 STA zpg,X $99 STA abs,Y $9D STA abs,X
                          5       $A1  LDA X,ind    $A5 LDA zpg   $A9  LDA #      $AD  LDA abs     $B1   LDA ind,Y $B5 LDA zpg,X $B9 LDA abs,Y $BD LDA abs,X
                          6       $C1  CMP X,ind    $C5 CMP zpg   $C9  CMP #      $CD  CMP abs     $D1   CMP ind,Y $D5 CMP zpg,X $D9 CMP abs,Y $DD CMP abs,X
                          7       $E1  SBC X,ind    $E5 SBC zpg   $E9  SBC #      $ED  SBC abs     $F1   SBC ind,Y $F5 SBC zpg,X $F9 SBC abs,Y $FD SBC abs,X

---
Additional information can be found by searching:
- "revA_ror_bug" which expands on example of implementation-specific missing instruction (Rev A ROR)
- "w65c02_extensions_address_modes" which expands on how WDC treats previously illegal opcodes/extends instruction set
