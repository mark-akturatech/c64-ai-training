# C64 BASIC ROM - Action Addresses, Functions

Token #    Keyword
162 $A3    TAB(
164 $A4    TO
165 $A5    FN
166 $A6    SPC(
167 $A7    THEN
168 $A8    NOT
169 $A9    STEP

3.  The math operators found in OPTAB at 41088 ($A080), in the token
number order indicated (token numbers 170-179).

4.  The functions found in FUNDSP at 41042 ($A052), in the token
number order indicated (token numbers 182-202).

5.  The word GO (token number 203 ($CB)).  This word was added to the
table to make the statement GO TO legal, to afford some compatibility
with the very first PET BASIC, which allowed spaces within keywords.

41374-41767   $A19E-$A327    ERRTAB
ASCII Text of BASIC Error Messages

This table contains the ASCII text of all of the BASIC error messages.
As in the keyword table, Bit 7 of the last letter of each message is
set to indicate the end of the message.  Although we've all seen some
of them at one time or another, it's somewhat daunting to see the
whole list at once.  The possible errors you can make include:

 1.  TOO MANY FILES
 2.  FILE OPEN
 3.  FILE NOT OPEN
 4.  FILE NOT FOUND
 5.  DEVICE NOT PRESENT
 6.  NOT INPUT FILE
 7.  NOT OUTPUT FILE
 8.  MISSING FILENAME
 9.  ILLEGAL DEVICE NUMBER
10.  NEXT WITHOUT FOR
11.  SYNTAX
12.  RETURN WITHOUT GOSUB
13.  OUT OF DATA
14.  ILLEGAL QUANTITY
15.  OVERFLOW
16.  OUT OF MEMORY
17.  UNDEF'D STATEMENT
18.  BAD SUBSCRIPT
19.  REDIM'D ARRAY
20.  DIVISION BY ZERO
21.  ILLEGAL DIRECT
22.  TYPE MISMATCH
23.  STRING TOO LONG
24.  FILE DATA
25.  FORMULA TOO COMPLEX
26.  CAN'T CONTINUE
27.  UNDEF'D FUNCTION
28.  VERIFY
29.  LOAD

Message number 30, BREAK, is located in the Miscellaneous Messages
table below.

41768-41828   $A328-$A364
Error Message Vector Table

This table contains the two-byte address of the first letter of each
of the 30 error messages.

41829-41865   $A365-$A389
Miscellaneous Messages

The text of some of the other messages that BASIC can give you is
stored here.  This text includes cursor movement characters, and each
message ends with a 0 character.  The messages are:

1) Carriage return, OK, carriage return
2) Space, space, ERROR
3) Space, IN, space
4) Carriage return, linefeed, READY., carraige return, linefeed
5) Carriage return, linefeed, BREAK

41866-41911   $A38A-$A3B7    FNDFOR
Find FOR on Stack

This routine searches the stack for the blocks of data entries which
are stored by each FOR command.  For more information on the data that
FOR places on the stack, see location 256 ($100).

41912         $A3B8          BLTU
Open a Space in Memory for a New Program Line or Variable

When a new nonarray variable is being created, or when a BASIC program
line is being added or replaced, this routine is used to make room for
the addition.  It first checks to see if space is available, and then
moves the program text and/or variables to make room.

41979-41991   $A3FB-$A407    GETSTK
Check for Space on Stack

Before undertaking an operation that requires stack space, this
routine is used to check if there is enough room on the stack.  If
there is not, an OUT OF MEMORY error is issued.

41992-42036   $A408-$A434    REASON
Check for Space in Memory

This is the subroutine that checks to see if there is enough space in
free memory for proposed additions such as new lines of program text.
If not, it calls for garbage collection, and if this still does not
produce enough space, an OUT OF MEMORY error is issued.

42037-42088   $A435-$A468    OMERR
OUT OF MEMORY Error Handler

This routine just sets the error message code, and falls through to
the general error handler.

42039-42088   $A437-$A468    ERROR
General Error Handler

The error number is passed to this routine in the .X register, and it
displays the appropriate error message.  Since this routine is
vectored through RAM at 768 ($300), you can divert this vector to the
address of your own routine, which would allow error trapping, or the
addition of new commands.

42089-42099   $A474-$A47F    READY
Print READY

This routine displays the word READY, sets the Kernal message flag to
show that direct mode is operative, and falls through to the main
BASIC loop.

42112-42139   $A480-$A49B    MAIN
Main Loop, Receives Input and Executes Immediately or Stores as
Program Line

This is the main BASIC program loop.  It jumps through the RAM vector
at 770 ($302), so this routine can be diverted.  The routine gets a
line of input from the keyboard, and checks for a line number.  If
there is a line number, the program branches to the routine that
stores a line of program text.  If there is no line number, it
branches to the routine that executes statements.

42140         $A49C          MAIN1
Add or Replace a Line of Program Text

This routine calls subroutines to get the line number, tokenize
keywords, and then looks for a line with the same line number.

If it finds a line with the same number, the routine deletes that line
by moving all higher program text and variables down to where it
started.  The new line is then added.  Since the CLR routine is
called, the value of all current program variables is lost.

42291         $A533          LINKPRG
Relink Lines of Tokenized Program Text

Each line of program text starts with a pointer to the address of the
next line (link address).  This routine scans each line to the end
(which is marked with a 0), and calculates the new link address by
adding the offset to the address of the current statement.

42336         $A560          INLIN
Input a Line to Buffer from Keyboard

This subroutine calls the Kernal CHRIN routine (61783, $F157) to
obtain a line of input from the current input device (usually the
keyboard).  It stores the characters in the BASIC text input buffer at
512 ($200) until a carriage return or 89 characters have been
received.  The keyboard device will never return more than 80
characters before a carriage return, but other devices can output a
longer line.  An error will occur if the line goes over 80 characters.

42361         $A579          CRUNCH
Tokenize Line in Input Buffer

When a line of program text has been input into the BASIC text buffer
at 512 ($200), this routine goes through the line and changes any
keywords or their abbreviations, which do not appear in quotes, into
their corresponding token.  This command is vectored through RAM at
772 ($304), so it can be diverted in order to add new commands.

42515         $A613          FINDLN
Search for Line Number

This routine searches through the program text, trying to match the
two-byte integer line number that is stored in 20-21 ($14-$15).  If it
is found, 95-96 ($5F-$60) will be set as a pointer to the address of
the link field for that line, and the Carry flag will be set.  If it
is not found, the Carry flag will be cleared.

42562         $A642          SCRTCH
Perform NEW

The NEW command stores two zeros in the link address of the first
program line to indicate the end of program, and sets the end of
program pointer at 45-46 ($2D-$2E) to point to the byte past those
zeros.  It continues through to the CLR command code.

42590         $A65E          CLEAR
Perform CLR

The CLR command closes all I/O files with the Kernal CLALL routine
(62255, $F32F).  It eliminates string variables by copying the end of
memory pointer at 55-56 ($37-$38) to the bottom of strings pointer at
51-52 ($33-$34).  It also copies the pointer to the end of BASIC
program text at 49-50 ($31-$31) to the pointer to the start of
nonarray variables at 45-46 ($2D-$2E) and the start of array variables
at 47-48 ($2F-$30).  This makes these variables unusable (although the
contents of these areas are not actually erased).  RESTORE is called
to set the data pointer back to the beginning, and the stack is
cleared.

42638         $A68E          RUNC
Reset Pointer to Current Text Character to the Beginning of Program
Text

This routine resets the CHRGET pointer TXTPTR (122-123, $7A-$7B) so
that the next byte of text that the interpreter will read comes from
the beginning of program text.

52652         $A69C          LIST
Perform LIST

This routine saves the range of lines to be printed in pointers at
95-96 ($5F- $60) and 20-21 ($14-$15), and then prints them out,
translating any tokens back to their ASCII equivalent.

42775         $A717          QPLOP
Print BASIC Tokens as ASCII Characters

This is the part of the LIST routine that chagnes one-byte program
tokens back to their ASCII text characters.  The routine is vectored
through RAM at 774 ($306), so it is possible to list out new command
words that you have added by changing this vector to detour through
your own routine.

42818         $A742          FOR
Perform FOR

FOR is performed mostly by saving the needed information for the NEXT
part of the command on the stack (see the entry for 256 ($100) for
details).  This includes the TO termination value, so if the upper
limit is a variable, the current value of the variable will be stored,
and you cannot end the loop early by decreasing the value of the TO
variable within the loop (although you can end it early by increasing
the value of the FOR variable within the loop).

Also, since the TO expression is evaluated only once, at the time FOR
is performed, a statement such as FOR I=1 TO I+100 is valid.  The
