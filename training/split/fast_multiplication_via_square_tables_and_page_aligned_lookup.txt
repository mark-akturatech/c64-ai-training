# 6502 Multiplication and Division Algorithms - Source: llx.com - Fast 8-bit multiply using tables of squares and the identities: (a+b)^2 − (a−b)^2 = 4ab, so ab = ( (a+b)^2/4 − (a−b)^2/4 ). Implementation details: store tables of x^2/4 (losing two LSBs cancels in subtraction); keep two page-aligned tables (sum SSQLO/SSQHI and diff DSQLO/DSQHI), with diff offset by one to allow -A-1 via EOR #$FF; set up four zero-page pointers PSLO/PSHI/PDLO/PDHI to the high pages. Call protocol: multiplicand in A, multiplier in Y; code indexes (PS*) and (PD*) by Y to fetch lo/hi words, subtract to produce product; result returned in A (hi) and X (lo). Worst-case timing: 38 cycles. Note: tables must be page-aligned; tables provided separately; origin note.

Fortunately, with a little bit of algebra, the multiplcation table can
be made much smaller, at the cost of a little extra execution time.
Consider these two ways of writing the binomial equation:


(a + b)^2 = a^2 + 2*a*b + b^2,
(a - b)^2 = a^2 - 2*a*b + b^2.


If the bottom equation is subtracted from the top, we get


(a + b)^2 - (a - b)^2 = 4*a*b,


Or, rearranging,


a*b = ((a + b)^2 - (a - b)^2)/4
    = (a + b)^2/4 - (a - b)^2/4.


Thus we can do a multiplication with an addition, two subtractions,
a couple of right shifts, and a couple of lookups in a table of squares.
And if we're clever about the coding, we can make most of that work
trivial - Here are the tricks to make it work:


  * Instead of storing a table of x^2, the table will
    store x^2/4.  This means each table entry needs only two
    bytes intstead of three.  The two low-order bits of each entry are
    lost, but that's OK, since (a+b)^2 and
    (a-b)^2 are guaranteed to lose exactly the same
    bits, so the subtraction cancels the lost bits.

  * We'll actually store the table twice, once to look up
    (a+b)^2/4, and once to look up (a-b)^2/4.
    The total memory cost is 2048 bytes (2K).

  * The (a-b)^2/4 table is offset by one.  This is so we
    can store b in the accumulator, and negate it with
    EOR #$FF without having to add 1.

  * The tables are page-aligned.  This greatly streamlines the
    indexing.


A brief setup routine is needed to set up four pointers in page 0:


LDA #SSQLO/256
        STA PSLO+1
        LDA #SSQHI/256
        STA PSHI+1
        LDA #DSQLO/256
        STA PDLO+1
        LDA #DSQHI/256
        STA PDHI+1


With that done, we can multiply two bytes by putting one in the
accumulator and the other in the Y register, and calling this
routine:


STA PSLO     ;Index into sum table by A
        STA PSHI
        EOR #$FF
        STA PDLO     ;Index into diff table by -A-1
        STA PDHI
        LDA (PSLO),Y ;Get (a+y)^2/4 (lo byte)
        SEC
        SBC (PDLO),Y ;Subtract (-a+y)^2/4 (lo byte)
        TAX          ;Save it
        LDA (PSHI),Y ;Get (a+y)^2/4 (hi byte)
        SBC (PDHI),Y ;Subtract (-a+y)^2/4 (hi byte)


This leaves the product in the accumulator (high byte) and the X
register (low byte).  Worst-case time (all indexing crosses a page
boundary): 38 cycles.


The tables necessary to make this work are too long to show here, so
I've provided them in a separate text file.
Remember, the tables have to be page-aligned, or the above code won't
work.


(The above routine is based on some code I found on a
Commodore-64-related web page, which, unfortunately, I haven't been able
locate again.  The method doesn't seem to have been widely known among
Apple II programmers.)



---
Additional information can be found by searching:
- "one_byte_multiplication_speed_optimizations_and_table_lookup_intro" which expands on Motivation and transition from loop-optimized multiply to table methods
- "binary_multiplication_algorithm_and_routines" which expands on Contrasts with shift-add multiplication approach
