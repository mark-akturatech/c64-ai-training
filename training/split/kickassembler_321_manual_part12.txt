# KickAssembler - Advanced Macros and Functions

   .for (;i<10;) {
         .print i
       .eval i++
   }
   // Sum the numbers from 0 to 9 and print the sum at each step
   .for(var i=0, var sum=0;i<10;sum=sum+i,i++)
             .print “The sum at step “ + i “ is “ + sum
The for loop is good for generating tables and unrolling loops. You can, for example, do a classic
‘blitter fill’ routine like this:
   .var blitterBuffer=$3000
   .var charset=$3800
   .for (x=0;x<16;x++) {
         for(var y=0;y<128;y++) {
                if (var y=0) lda blitterBuffer+x*128+y
                else              eor blitterBuffer+x*128+y
                sta charset+x*128+y
         }
   }
6.5 Optimization Considerations when using Loops
Here is a tip if you want to optimize your assembling. Kick assembler has two modes of executing
directives. ‘Function Mode’ is used when the directive is placed inside a function or define
directive, otherwise ‘Asm Mode’ is used. ‘Function Mode’ is executed fast but is restricted to script
commands only (.var, .const, .for, etc.), while ‘Asm Mode’ remembers intermediate results so the
assembler won’t have to make the same calculations in succeeding passes.
If you make heavy calculations and get slow performance or lack of memory, then place your for
loops inside a define directive or inside a function. No time or memory will be wasted to record
intermediate results, and the define directive or the directive that called the function, will remember
the result in the succeeding passes.
                                                                                                     31
Read more about the define directive in the chapter ‘Working with mutable values’.
                                                                                   32
7 Macros, Functions and Pseudo Commands
This chapter shows how to define and use macros, pseudo commands and functions.
7.1 Macros
Macros are collections of assembler directives. When called, they generate code as if the directives
where placed at the macro call. The following code defines and executes the macro ‘SetColor’:
   // Define macro
   .macro SetColor(color) {
             lda #color
             sta $d020
   }
   // Execute macro
   :SetColor(1)
A macro can have any number of arguments. Macro calls are encapsulated in a scope, hence any
variable defined inside a macro can’t be seen from the outside. This means that a series of macro
calls to the same macro doesn’t interfere:
   // Execute macro
   :ClearScreen($0400,$20)                     // Since they are encapsulated in a scope
   :ClearScreen($4400,$20)                     // the two resulting loop labels don’t
                                               // interfere
   // Define macro
   .macro ClearScreen(screen,clearByte) {
             lda #clearByte
             ldx #0
   Loop:                          // The loop label can’t be seen from the outside
             sta screen,x
             sta screen+$100,x
             sta screen+$200,x
