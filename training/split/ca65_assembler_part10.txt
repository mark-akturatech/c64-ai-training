# CA65 Assembler - Scopes (Global, Cheap Locals, Generic Nested)

7. Scopes
ca65 implements several sorts of scopes for symbols.

7.1 Global scope
All (non cheap local) symbols that are declared outside of any nested scopes are in global scope.

7.2 Cheap locals
A special scope is the scope for cheap local symbols. It lasts from one non local symbol to the next one, without any provisions made by the programmer. All other scopes differ in usage but use the same concept internally.

7.3 Generic nested scopes
A nested scoped for generic use is started with .SCOPE and closed with .ENDSCOPE. The scope can have a name, in which case it is accessible from the outside by using explicit scopes. If the scope does not have a name, all symbols created within the scope are local to the scope, and aren't accessible from the outside.

A nested scope can access symbols from the local or from enclosing scopes by name without using explicit scope names. In some cases there may be ambiguities, for example if there is a reference to a local symbol that is not yet defined, but a symbol with the same name exists in outer scopes:


        .scope  outer
                foo     = 2
                .scope  inner
                        lda     #foo
                        foo     = 3
                .endscope
        .endscope
In the example above, the lda instruction will load the value 3 into the accumulator, because foo is redefined in the scope. However:


        .scope  outer
                foo     = $1234
                .scope  inner
                        lda     foo,x
                        foo     = $12
                .endscope
        .endscope
Here, lda will still load from $12,x, but since it is unknown to the assembler that foo is a zeropage symbol when translating the instruction, absolute mode is used instead. In fact, the assembler will not use absolute mode by default, but it will search through the enclosing scopes for a symbol with the given name. If one is found, the address size of this symbol is used. This may lead to errors:


        .scope  outer
                foo     = $12
                .scope  inner
                        lda     foo,x
                        foo     = $1234
                .endscope
        .endscope
In this case, when the assembler sees the symbol foo in the lda instruction, it will search for an already defined symbol foo. It will find foo in scope outer, and a close look reveals that it is a zeropage symbol. So the assembler will use zeropage addressing mode. If foo is redefined later in scope inner, the assembler tries to change the address in the lda instruction already translated, but since the new value needs absolute addressing mode, this fails, and an error message "Range error" is output.

Of course the most simple solution for the problem is to move the definition of foo in scope inner upwards, so it precedes its use. There may be rare cases when this cannot be done. In these cases, you can use one of the address size override operators:


        .scope  outer
                foo     = $12
                .scope  inner
                        lda     a:foo,x
                        foo     = $1234
                .endscope
        .endscope
This will cause the lda instruction to be translated using absolute addressing mode, which means changing the symbol reference later does not cause any errors.

7.4 Nested procedures
A nested procedure is created by use of .PROC. It differs from a .SCOPE in that it must have a name, and a it will introduce a symbol with this name in the enclosing scope. So


        .proc   foo
                ...
        .endproc
is actually the same as


        foo:
        .scope  foo
                ...
        .endscope
This is the reason why a procedure must have a name. If you want a scope without a name, use .SCOPE.

Note: As you can see from the example above, scopes and symbols live in different namespaces. There can be a symbol named foo and a scope named foo without any conflicts (but see the section titled "Scope search order").

