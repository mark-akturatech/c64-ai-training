# 6502 Comparisons and BIT Instruction - CMP, CPX, CPY Behavior

          Pragmatics of Comparisons and the BIT Instruction
          Compare Instructions
          The 6502 MPU features three basic compare instructions in various address modes:
           Instruction     Comparison
           CMP             Accumulator and operand
           CPX             X register and operand
                                                                  6502 Instruction Set
           Instruction    Comparison
           CPY            Y register and operand
          The various compare instructions subtract the operand from the respective register
          (as if the carry was set) without setting the result in the accumulator (rather,
          leaving its content unchanged) and adjust the N, Z, and C flags as with any ordinary
          subtraction.
          Flags will be set as follows:
           Relation                 Z      C     N
           register < operand       0      0     sign-bit of result
           register = operand       1      1     0
           register > operand       0      1     sign-bit of result
          Meaning, we may dertermine the derivative relation "greater than or equal" (gte) by
          checking just the carry flag (using instruction BCS):
           Relation                 Z      C     N
           register ≥ operand       x      1     sign-bit of result
          (For why the carry flag is set this way, see the notes on subtraction, below.)
          Mind that the negative flag is not significant and all conditions may be evaluated
          by checking the carry and/or zero flag(s).
          The BIT Instruction
          The BIT instruction may be the most obscure instruction of the 6502:
          While other instruction serve a very clear purpose, like transferring values or
          performing basic arithmetic or logical operations, this one serves a rather
          specialized purpose, but it does so in a very general way.
          This purpose is bit testing.
          Generally, testing of a particular bit is achieved by masking (isolating) this
          bit (or multiple bits) by an AND operation and then checking the zero flag (Z) by
          a BNE or BEQ instruction. This, however, destroys the contents of the accumulator.
          This is, where the BIT instruction comes in: much like the comparisons perform a
          subtraction without setting the result, the BIT instruction performs a logical AND
          without setting the result, but still reflects the result in the state of the zero
          flag (Z). Which allows for the same checks using the BNE or BEQ instructions,
          without affecting the contents of the accumulator.
          Since the sign-bit is often used as a flag, testing this is also covered by the BIT
          instruction, which additionally to setting the zero flag also transfers bits 7 and 6
          of the operand into the corresponding bits of the status register — which happen to
                                                                    6502 Instruction Set
          be the negative (N) and overflow (V) flags. Therefore, bits 7 and 6 of the operand
          may be tested independently using the BMI/BPL and BVS/BVC instructions.
            accumulator         operand
            [76543210] AND     [76543210]    == 0 ?
                                ↓↓            ↓
                                NV            Z
          An interesting use of the BIT instruction may be observed in MS/Commodore BASIC:
                        ;a condition has been previously evaluated
                        ;by setting the carry, now set a flag…
                        BCS SETFLAG       ;set a flag in location "FLAG"
                         (...)
            SETFLAG     ROR FLAG          ;rotate carry into sign position
                                          ;previous sign-bit now in bit 6
                        BIT FLAG          ;bit 6 (prev. sign) into overflow flag (V)
                        BVS ABORT         ;was the flag set already?
                         (...)            ;no: adjust to condition…
                        JMP CONTINUE      ;done, continue with task…
            ABORT        (...)            ;flag set twice, abort the operation…
          Notably, this is easily modified to check the state of 'FLAG' first:
                        BCS SETFLAG       ;set a flag…
                         (...)
            SETFLAG     BIT FLAG          ;sign-bit into negative flag (N)
                        BMI ABORT         ;is the flag set already?
                        ROR FLAG          ;no: rotate carry into sign position
                                          ;(carry is left untouched by BIT)
                         (...)            ;adjust to condition…
                        JMP CONTINUE      ;done
            ABORT        (...)            ;flag already set, abort…
          In both cases, we don't care about the AND operation and its result in the zero
          flag (Z), but only about the bit transfer into the V or N flag, respectively.
