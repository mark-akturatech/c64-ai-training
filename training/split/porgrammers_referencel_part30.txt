# C64 PRG Chapter 3 - Sprites: Defining, Pointers

  146   PROGRAMMING GRAPHICS
~


start tok64 page147.prg
  10 rem sprite example 2...
  20 rem the hot air balloon again
  30 vic=13*4096:rem this is where the vic registers begin
  35 pokevic+21,63:rem enable sprites 0 thru 5
  36 pokevic+33,14:rem set background color to light blue
  37 pokevic+23,3:rem expand sprites 0 and 1 in y
  38 pokevic+29,3:rem expand sprites 0 and 1 in x
  40 poke2040,192:rem set sprite 0's pointer
  50 poke2041,193:rem set sprite 1's pointer
  60 poke2042,192:rem set sprite 2's pointer
  70 poke2043,193:rem set sprite 3's pointer
  80 poke2044,192:rem set sprite 4's pointer
  90 poke2045,193:rem set sprite 5's pointer
  100 pokevic+4,30:rem set sprite 2's x position
  110 pokevic+5,58:rem set sprite 2's y position
  120 pokevic+6,65:rem set sprite 3's x position
  130 pokevic+7,58:rem set sprite 3's y position
  140 pokevic+8,100:rem set sprite 4's x position
  150 pokevic+9,58:rem set sprite 4's y position
  160 pokevic+10,100:rem set sprite 5's x position
  170 pokevic+11,58:rem set sprite 5's y position
  175 print"{white}{clear}"tab(15)"this is two hires sprites";
  176 printtab(55)"on top of each other"
  180 pokevic+0,100:rem set sprite 0's x position
  190 pokevic+1,100:rem set sprite 0's y position
  200 pokevic+2,100:rem set sprite 1's x position
  210 pokevic+3,100:rem set sprite 1's y position
  220 pokevic+39,1:rem set sprite 0's color
  230 pokevic+41,1:rem set sprite 2's color
  240 pokevic+43,1:rem set sprite 4's color
  250 pokevic+40,6:rem set sprite 1's color
  260 pokevic+42,6:rem set sprite 3's color
  270 pokevic+44,6:rem set sprite 5's color
  280 forx=192to193:rem the start of the loop that defines the sprites
  290 fory=0to63:rem byte counter with sprite loop
  300 reada:rem read in a byte
  310 pokex*64+y,a:rem store the data in sprite area
  320 nexty,x:rem close loops
  330 dx=1:dy=1
  340 x=peek(vic):rem look at sprite 0's x position
  350 ify=50ory=208thendy=-dy:rem if y is on the edge of the...





  370 rem screen, then reverse delta y
  380 ifx=24and(peek(vic+16)and1)=0thendx=-dx:rem if sprite is...
  390 rem touching the left edge, then reverse it
  400 ifx=40and(peek(vic+16)and1)=1thendx=-dx:rem if sprite is...
  410 rem touching the right edge, then reverse it
  420 ifx=255anddx=1thenx=-1:side=3
  430 rem switch to other side of the screen
  440 ifx=0anddx=-1thenx=256:side=0
  450 rem switch to other side of the screen
  460 x=x+dx:rem add delta x to x
  470 x=xand255:rem make sure x is in allowed range
  480 y=y+dy:rem add delta y to y
  485 pokevic+16,side
  490 pokevic,x:rem put new x value into sprite 0's x position
  500 pokevic+2,x:rem put new x value into sprite 1's x position
  510 pokevic+1,y:rem put new y value into sprite 0's y position
  520 pokevic+3,y:rem put new y value into sprite 1's y position
  530 goto340
  600 rem ***** sprite data *****
  610 data0,255,0,3,153,192,7,24,224,7,56,224,14,126,112,14,126,112,14,126
  620 data112,6,126,96,7,56,224,7,56,224,1,56,128,0,153,0,0,90,0,0,56,0
  630 data0,56,0,0,0,0,0,0,0,0,126,0,0,42,0,0,84,0,0,40,0,0
  640 data0,0,0,0,102,0,0,231,0,0,195,0,1,129,128,1,129,128,1,129,128
  650 data1,129,128,0,195,0,0,195,0,4,195,32,2,102,64,2,36,64,1,0,128
  660 data1,0,128,0,153,0,0,153,0,0,0,0,0,84,0,0,42,0,0,20,0,0
stop tok64








start tok64 page148.prg
  10 rem sprite example 3...
  20 rem the hot air gorf
  30 vic=53248:rem this is where the vic registers begin
  35 pokevic+21,1:rem enable sprite 0
  36 pokevic+33,14:rem set background color to light blue
  37 pokevic+23,1:rem expand sprite 0 in y
  38 pokevic+29,1:rem expand sprite 0 in x





  40 poke2040,192:rem set sprite 0's pointer
  50 pokevic+28,1:rem turn on multicolor
  60 pokevic+37,7:rem set multicolor 0
  70 pokevic+38,4:rem set multicolor 1
  180 pokevic+0,100:rem set sprite 0's x position
  190 pokevic+1,100:rem set sprite 0's y position
  220 pokevic+39,2:rem set sprite 0's color
  290 fory=0to63:rem byte counter with sprite loop
  300 reada:rem read in a byte
  310 poke12288+y,a:rem store the data in sprite area
  320 next y:rem close loop
  330 dx=1:dy=1
  340 x=peek(vic):rem look at sprite 0's x position
  350 y=peek(vic+1):rem look at sprite 0's y position
  360 ify=50ory=208then dy=-dy:rem if y is on the edge of the...
  370 rem screen, then reverse delta y
  380 ifx=24and(peek(vic+16)and1)=0thendx=-dx:rem if sprite is...
  390 rem touching the left edge, then reverse it
  400 ifx=40and(peek(vic+16)and1)=1thendx=-dx:rem if sprite is...
  410 rem touching the right edge, then reverse it
  420 ifx=255anddx=1thenx=-1:side=1
  430 rem switch to other side of the screen
  440 ifx=0anddx=-1thenx=256:side=0
  450 rem switch to other side of the screen
  460 x=x+dx:rem add delta x to x
  470 x=xand255:rem make sure that x is in allowed range
  480 y=y+dy:rem add delta y to y
  485 pokevic+16,side
  490 pokevic,x:rem put new x value into sprite 0's x position
  510 pokevic+1,y:rem put new y value into sprite 0's y position
  520 geta$:rem get a key from the keyboard
  521 ifa$="m"thenpokevic+28,1:rem user selected multicolor
  522 ifa$="h"thenpokevic+28,0:rem user selected high resolution
  530 goto340
  600 rem ***** sprite data *****
  610 data64,0,1,16,170,4,6,170,144,10,170,160,42,170,168,41,105,104,169
  620 data235,106,169,235,106,169,235,106,170,170,170,170,170,170,170,170
  630 data170,170,170,170,166,170,154,169,85,106,170,85,170,42,170,168,10
  640 data170,160,1,0,64,1,0,64,5,0,80,0
stop tok64



                                                 PROGRAMMING GRAPHICS   149
~


  OTHER GRAPHICS FEATURES

  SCREEN BLANKING

    Bit 4 of the VIC-II control register controls the screen blanking func-
  tion. It is found in the control register at location 53265 ($D011). When
  it is turned ON (in other words, set to a 1) the screen is normal. When
  bit 4 is set to 0 (turned OFF), the entire screen changes to border
  color.
    The following POKE blanks the screen. No data is lost, it just isn't
  displayed.

    POKE 53265,PEEK(53265)AND 239

  To bring back the screen. use the POKE shown below:

    POKE 53265,PEEK(53265)OR 16
  +-----------------------------------------------------------------------+
  | NOTE: Turning off the screen will speed up the processor slightly.    |
  | This means that program RUNning is also sped up.                     |
  +-----------------------------------------------------------------------+

  RASTER REGISTER

    The raster register is found in the VIC-II chip at location 53266
  ($D012). The raster register is a dual purpose register. When you read
  this register it returns the lower 8 bits of the current raster position.
  The raster position of the most significant bit is in register location
  53265 ($D011). You use the raster register to set up timing changes in
  your display so that you can get rid of screen flicker. The changes on
  your screen should be mode when the raster is not in the visible display
  area, which is when your dot positions fall between 51 and 251.
    When the raster register is written to (including the MSB) the number
  written to is saved for use with the raster compare function. When the
  actual raster value becomes the same as the number written to the raster
  register, a bit in the VIC-II chip interrupt register 53273 ($D019) is
  turned ON by setting it to 1.

  +-----------------------------------------------------------------------+
  | NOTE: If the proper interrupt bit is enabled (turned on), an interrupt|
  | (IRQ) will occur.                                                     |
  +-----------------------------------------------------------------------+

  150   PROGRAMMING GRAPHICS
~


  INTERRUPT STATUS REGISTER

    The interrupt status register shows the current status of any interrupt
  source. The current status of bit 2 of the interrupt register will be a 1
  when two sprites hit each other. The same is true, in a corresponding 1
  to 1 relationship, for bits 0-3 listed in the chart below. Bit 7 is also
  set with a 1, whenever an interrupt occurs.
    The interrupt status register is located at 53273 ($D019) and is as
  follows:

    LATCH  BIT#             DESCRIPTION
  -------------------------------------------------------------------------
    IRST    0   Set when current raster count = stored raster count
    IMDC    1   Set by SPRITE-DATA collision (1st one only, until reset)
    IMMC    2   Set by SPRITE-SPRITE collision (1st one only, until reset)
     ILP    3   Set by negative transition of light pen (1 per frame)
     IRQ    7   Set by latch set and enabled
  -------------------------------------------------------------------------
    Once an interrupt bit has been set, it's "latched" in and must be
  cleared by writing a 1 to that bit in the interrupt register when you're
  ready to handle it. This allows selective interrupt handling, without
  having to store the other interrupt bits.
    The INTERRUPT ENABLE REGISTER is located at 53274 ($D01A). It has the
  same format as the interrupt status register. Unless the corresponding
  bit in the interrupt enable register is set to a 1, no interrupt from
  that source will take place. The interrupt status register can still be
  polled for information, but no interrupts will be generated.
    To enable an interrupt request the corresponding interrupt enable bit
  (as shown in the chart above) must be set to a 1.
    This powerful interrupt structure lets you use split screen modes. For
  instance you can have half of the screen bit mapped, half text, more than
  8 sprites at a time, etc. The secret is to use interrupts properly. For
  example, if you want the top half of the screen to be bit mapped and the
  bottom to be text, just set the raster compare register (as explained
  previously) for halfway down the screen. When the interrupt occurs, tell
  the VIC-II chip to get characters from ROM, then set the raster compare
  register to interrupt at the top of the screen. When the interrupt occurs
  at the top of the screen, tell the VIC-II chip to get characters from RAM
  (bit map mode).
    You can also display more than 8 sprites in the same way. Unfortunately
  BASIC isn't fast enough to do this very well. So if you want to start
  using display interrupts, you should work in machine language.

                                                 PROGRAMMING GRAPHICS   151
~


  SUGGESTED SCREEN AND CHARACTER COLOR COMBINATIONS

    Color TV sets are limited in their ability to place certain colors next
  to each other on the same line. Certain combinations of screen and char-
  acter colors produce blurred images. This chart shows which color com-
  binations to avoid, and which work especially well together.

                          CHARACTER COLOR
            0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         0| x| o| x| o| o| /| x| o| o| x| o| o| o| o| o| o|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         1| o| x| o| x| o| o| o| x| /| o| /| o| o| x| o| o|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         2| x| o| x| x| /| x| x| o| o| x| o| x| x| x| x| /|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         3| o| x| x| x| x| /| o| x| x| x| x| /| x| x| /| x|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         4| o| /| x| x| x| x| x| x| x| x| x| x| x| x| x| /|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         5| o| /| x| /| x| x| x| x| x| x| x| /| x| o| x| /|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  SCREEN 6| /| o| x| o| x| x| x| x| x| x| x| x| x| /| o| o|
  COLOR   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         7| o| x| o| x| x| x| /| x| /| o| /| o| o| x| x| x|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         8| /| o| o| x| x| x| x| o| x| o| x| x| x| x| x| /|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         9| x| o| x| x| x| x| x| o| o| x| o| x| x| x| x| o|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        10| /| /| o| x| x| x| x| /| x| o| x| x| x| x| x| /|   o = EXCELLENT
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        11| o| o| x| /| x| x| x| o| x| x| x| x| o| o| /| o|   / = FAIR
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        12| o| o| /| x| x| x| /| x| x| /| x| o| x| x| x| o|   x = POOR
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        13| o| x| x| x| x| o| /| x| x| x| x| o| x| x| x| x|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        14| o| o| x| o| x| x| o| x| x| x| x| /| x| x| x| /|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        15| o| o| o| x| /| /| o| x| x| /| /| o| o| x| /| x|
          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

