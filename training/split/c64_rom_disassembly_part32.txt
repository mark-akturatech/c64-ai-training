# C64 KERNAL ROM Disassembly $E900-$ECFF - Screen Address, Print

.,E900 20 F0 E9 JSR $E9F0       fetch a screen address, set the start of line X
.,E903 E0 18    CPX #$18        compare with last line
.,E905 B0 0C    BCS $E913       branch if >= $16
.,E907 BD F1 EC LDA $ECF1,X     get the start of the next line pointer low byte
.,E90A 85 AC    STA $AC         save the next line pointer low byte
.,E90C B5 DA    LDA $DA,X       get the start of the next line pointer high byte
.,E90E 20 C8 E9 JSR $E9C8       shift the screen line up
.,E911 30 EC    BMI $E8FF       loop, branch always
.,E913 20 FF E9 JSR $E9FF       clear screen line X
                                now shift up the start of logical line bits
.,E916 A2 00    LDX #$00        clear index
.,E918 B5 D9    LDA $D9,X       get the start of line X pointer high byte
.,E91A 29 7F    AND #$7F        clear the line X start of logical line bit
.,E91C B4 DA    LDY $DA,X       get the start of the next line pointer high byte
.,E91E 10 02    BPL $E922       if next line is not a start of line skip the start set
.,E920 09 80    ORA #$80        set line X start of logical line bit
.,E922 95 D9    STA $D9,X       set start of line X pointer high byte
.,E924 E8       INX             increment line number
.,E925 E0 18    CPX #$18        compare with last line
.,E927 D0 EF    BNE $E918       loop if not last line
.,E929 A5 F1    LDA $F1         get start of last line pointer high byte
.,E92B 09 80    ORA #$80        mark as start of logical line
.,E92D 85 F1    STA $F1         set start of last line pointer high byte
.,E92F A5 D9    LDA $D9         get start of first line pointer high byte
.,E931 10 C3    BPL $E8F6       if not start of logical line loop back and
                                scroll the screen up another line
.,E933 E6 D6    INC $D6         increment the cursor row
.,E935 EE A5 02 INC $02A5       increment screen row marker
.,E938 A9 7F    LDA #$7F        set keyboard column c7
.,E93A 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,E93D AD 01 DC LDA $DC01       read VIA 1 DRB, keyboard row port
.,E940 C9 FB    CMP #$FB        compare with row r2 active, [CTL]
.,E942 08       PHP             save status
.,E943 A9 7F    LDA #$7F        set keyboard column c7
.,E945 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,E948 28       PLP             restore status
.,E949 D0 0B    BNE $E956       skip delay if ??
                                first time round the inner loop X will be $16
.,E94B A0 00    LDY #$00        clear delay outer loop count, do this 256 times
.,E94D EA       NOP             waste cycles
.,E94E CA       DEX             decrement inner loop count
.,E94F D0 FC    BNE $E94D       loop if not all done
.,E951 88       DEY             decrement outer loop count
.,E952 D0 F9    BNE $E94D       loop if not all done
.,E954 84 C6    STY $C6         clear the keyboard buffer index
.,E956 A6 D6    LDX $D6         get the cursor row
                                restore the tape buffer pointers and exit
.,E958 68       PLA             pull tape buffer end pointer
.,E959 85 AF    STA $AF         restore it
.,E95B 68       PLA             pull tape buffer end pointer
.,E95C 85 AE    STA $AE         restore it
.,E95E 68       PLA             pull tape buffer pointer
.,E95F 85 AD    STA $AD         restore it
.,E961 68       PLA             pull tape buffer pointer
.,E962 85 AC    STA $AC         restore it
.,E964 60       RTS             

                                *** open up a space on the screen
.,E965 A6 D6    LDX $D6         get the cursor row
.,E967 E8       INX             increment the row
.,E968 B5 D9    LDA $D9,X       get the start of line X pointer high byte
.,E96A 10 FB    BPL $E967       loop if not start of logical line
.,E96C 8E A5 02 STX $02A5       save the screen row marker
.,E96F E0 18    CPX #$18        compare it with the last line
.,E971 F0 0E    BEQ $E981       if = last line go ??
.,E973 90 0C    BCC $E981       if < last line go ??
                                else it was > last line
.,E975 20 EA E8 JSR $E8EA       scroll the screen
.,E978 AE A5 02 LDX $02A5       get the screen row marker
.,E97B CA       DEX             decrement the screen row marker
.,E97C C6 D6    DEC $D6         decrement the cursor row
.,E97E 4C DA E6 JMP $E6DA       add this row to the current logical line and return
.,E981 A5 AC    LDA $AC         copy tape buffer pointer
.,E983 48       PHA             save it
.,E984 A5 AD    LDA $AD         copy tape buffer pointer
.,E986 48       PHA             save it
.,E987 A5 AE    LDA $AE         copy tape buffer end pointer
.,E989 48       PHA             save it
.,E98A A5 AF    LDA $AF         copy tape buffer end pointer
.,E98C 48       PHA             save it
.,E98D A2 19    LDX #$19        set to end line + 1 for predecrement loop
.,E98F CA       DEX             decrement the line number
.,E990 20 F0 E9 JSR $E9F0       fetch a screen address
.,E993 EC A5 02 CPX $02A5       compare it with the screen row marker
.,E996 90 0E    BCC $E9A6       if < screen row marker go ??
.,E998 F0 0C    BEQ $E9A6       if = screen row marker go ??
.,E99A BD EF EC LDA $ECEF,X     else get the start of the previous line low byte from the
                                ROM table
.,E99D 85 AC    STA $AC         save previous line pointer low byte
.,E99F B5 D8    LDA $D8,X       get the start of the previous line pointer high byte
.,E9A1 20 C8 E9 JSR $E9C8       shift the screen line down
.,E9A4 30 E9    BMI $E98F       loop, branch always
.,E9A6 20 FF E9 JSR $E9FF       clear screen line X
.,E9A9 A2 17    LDX #$17        
.,E9AB EC A5 02 CPX $02A5       compare it with the screen row marker
.,E9AE 90 0F    BCC $E9BF       
.,E9B0 B5 DA    LDA $DA,X       
.,E9B2 29 7F    AND #$7F        
.,E9B4 B4 D9    LDY $D9,X       get start of line X pointer high byte
.,E9B6 10 02    BPL $E9BA       
.,E9B8 09 80    ORA #$80        
.,E9BA 95 DA    STA $DA,X       
.,E9BC CA       DEX             
.,E9BD D0 EC    BNE $E9AB       
.,E9BF AE A5 02 LDX $02A5       get the screen row marker
.,E9C2 20 DA E6 JSR $E6DA       add this row to the current logical line
.,E9C5 4C 58 E9 JMP $E958       restore the tape buffer pointers and exit

                                *** shift screen line up/down
.,E9C8 29 03    AND #$03        mask 0000 00xx, line memory page
.,E9CA 0D 88 02 ORA $0288       OR with screen memory page
.,E9CD 85 AD    STA $AD         save next/previous line pointer high byte
.,E9CF 20 E0 E9 JSR $E9E0       calculate pointers to screen lines colour RAM
.,E9D2 A0 27    LDY #$27        set the column count
.,E9D4 B1 AC    LDA ($AC),Y     get character from next/previous screen line
.,E9D6 91 D1    STA ($D1),Y     save character to current screen line
.,E9D8 B1 AE    LDA ($AE),Y     get colour from next/previous screen line colour RAM
.,E9DA 91 F3    STA ($F3),Y     save colour to current screen line colour RAM
.,E9DC 88       DEY             decrement column index/count
.,E9DD 10 F5    BPL $E9D4       loop if more to do
.,E9DF 60       RTS             

                                *** calculate pointers to screen lines colour RAM
.,E9E0 20 24 EA JSR $EA24       calculate the pointer to the current screen line colour
                                RAM
.,E9E3 A5 AC    LDA $AC         get the next screen line pointer low byte
.,E9E5 85 AE    STA $AE         save the next screen line colour RAM pointer low byte
.,E9E7 A5 AD    LDA $AD         get the next screen line pointer high byte
.,E9E9 29 03    AND #$03        mask 0000 00xx, line memory page
.,E9EB 09 D8    ORA #$D8        set  1101 01xx, colour memory page
.,E9ED 85 AF    STA $AF         save the next screen line colour RAM pointer high byte
.,E9EF 60       RTS             

                                *** fetch a screen address
.,E9F0 BD F0 EC LDA $ECF0,X     get the start of line low byte from the ROM table
.,E9F3 85 D1    STA $D1         set the current screen line pointer low byte
.,E9F5 B5 D9    LDA $D9,X       get the start of line high byte from the RAM table
.,E9F7 29 03    AND #$03        mask 0000 00xx, line memory page
.,E9F9 0D 88 02 ORA $0288       OR with the screen memory page
.,E9FC 85 D2    STA $D2         save the current screen line pointer high byte
.,E9FE 60       RTS             

                                *** clear screen line X
.,E9FF A0 27    LDY #$27        set number of columns to clear
.,EA01 20 F0 E9 JSR $E9F0       fetch a screen address
.,EA04 20 24 EA JSR $EA24       calculate the pointer to colour RAM
.,EA07 20 DA E4 JSR $E4DA       save the current colour to the colour RAM
.,EA0A A9 20    LDA #$20        set [SPACE]
.,EA0C 91 D1    STA ($D1),Y     clear character in current screen line
.,EA0E 88       DEY             decrement index
.,EA0F 10 F6    BPL $EA07       loop if more to do
.,EA11 60       RTS

                                *** orphan byte
.,EA12 EA       NOP             unused

                                *** print character A and colour X
.,EA13 A8       TAY             copy the character
.,EA14 A9 02    LDA #$02set the count to $02, usually $14 ??
.,EA16 85 CD    STA $CD         save the cursor countdown
.,EA18 20 24 EA JSR $EA24       calculate the pointer to colour RAM
.,EA1B 98       TYA             get the character back

                                *** save the character and colour to the screen @ the cursor
.,EA1C A4 D3    LDY $D3         get the cursor column
.,EA1E 91 D1    STA ($D1),Y     save the character from current screen line
.,EA20 8A       TXA             copy the colour to A
.,EA21 91 F3    STA ($F3),Y     save to colour RAM
.,EA23 60       RTS             

                                *** calculate the pointer to colour RAM
.,EA24 A5 D1    LDA $D1         get current screen line pointer low byte
.,EA26 85 F3    STA $F3         save pointer to colour RAM low byte
.,EA28 A5 D2    LDA $D2         get current screen line pointer high byte
.,EA2A 29 03    AND #$03        mask 0000 00xx, line memory page
.,EA2C 09 D8    ORA #$D8        set  1101 01xx, colour memory page
.,EA2E 85 F4    STA $F4         save pointer to colour RAM high byte
.,EA30 60       RTS             

                                *** IRQ vector
.,EA31 20 EA FF JSR $FFEA       increment the real time clock
.,EA34 A5 CC    LDA $CC         get the cursor enable, $00 = flash cursor
.,EA36 D0 29    BNE $EA61       if flash not enabled skip the flash
.,EA38 C6 CD    DEC $CD         decrement the cursor timing countdown
.,EA3A D0 25    BNE $EA61       if not counted out skip the flash
.,EA3C A9 14    LDA #$14        set the flash count
.,EA3E 85 CD    STA $CD         save the cursor timing countdown
.,EA40 A4 D3    LDY $D3         get the cursor column
.,EA42 46 CF    LSR $CF         shift b0 cursor blink phase into carry
.,EA44 AE 87 02 LDX $0287       get the colour under the cursor
.,EA47 B1 D1    LDA ($D1),Y     get the character from current screen line
.,EA49 B0 11    BCS $EA5C       branch if cursor phase b0 was 1
.,EA4B E6 CF    INC $CF         set the cursor blink phase to 1
.,EA4D 85 CE    STA $CE         save the character under the cursor
.,EA4F 20 24 EA JSR $EA24       calculate the pointer to colour RAM
.,EA52 B1 F3    LDA ($F3),Y     get the colour RAM byte
.,EA54 8D 87 02 STA $0287       save the colour under the cursor
.,EA57 AE 86 02 LDX $0286       get the current colour code
.,EA5A A5 CE    LDA $CE         get the character under the cursor
.,EA5C 49 80    EOR #$80        toggle b7 of character under cursor
.,EA5E 20 1C EA JSR $EA1C       save the character and colour to the screen @ the cursor
.,EA61 A5 01    LDA $01         read the 6510 I/O port
.,EA63 29 10    AND #$10        mask 000x 0000, the cassette switch sense
.,EA65 F0 0A    BEQ $EA71       if the cassette sense is low skip the motor stop
                                the cassette sense was high, the switch was open, so turn
                                off the motor and clear the interlock
.,EA67 A0 00    LDY #$00        clear Y
.,EA69 84 C0    STY $C0         clear the tape motor interlock
.,EA6B A5 01    LDA $01         read the 6510 I/O port
.,EA6D 09 20    ORA #$20        mask xxxx xx1x, turn off the motor
.,EA6F D0 08    BNE $EA79       go save the port value, branch always
                                the cassette sense was low so turn the motor on, perhaps
.,EA71 A5 C0    LDA $C0         get the tape motor interlock
.,EA73 D0 06    BNE $EA7B       if the cassette interlock <> 0 don't turn on motor
.,EA75 A5 01    LDA $01         read the 6510 I/O port
.,EA77 29 1F    AND #$1F        mask xxxx xx0x, turn on the motor
.,EA79 85 01    STA $01         save the 6510 I/O port
.,EA7B 20 87 EA JSR $EA87       scan the keyboard
.,EA7E AD 0D DC LDA $DC0D       read VIA 1 ICR, clear the timer interrupt flag
.,EA81 68       PLA             pull Y
.,EA82 A8       TAY             restore Y
.,EA83 68       PLA             pull X
.,EA84 AA       TAX             restore X
.,EA85 68       PLA             restore A
.,EA86 40       RTI

                                *** scan keyboard performs the following ..
                                
                                1) check if key pressed, if not then exit the routine
                                
                                2) init I/O ports of VIA ?? for keyboard scan and set pointers to decode table 1.
                                clear the character counter
                                
                                3) set one line of port B low and test for a closed key on port A by shifting the
                                byte read from the port. if the carry is clear then a key is closed so save the
                                count which is incremented on each shift. check for shift/stop/cbm keys and
                                flag if closed
                                
                                4) repeat step 3 for the whole matrix
                                
                                5) evaluate the SHIFT/CTRL/C= keys, this may change the decode table selected
                                
                                6) use the key count saved in step 3 as an index into the table selected in step 5
                                
                                7) check for key repeat operation
                                
                                8) save the decoded key to the buffer if first press or repeat
                                scan the keyboard
.,EA87 A9 00    LDA #$00clear A
.,EA89 8D 8D 02 STA $028D       clear the keyboard shift/control/c= flag
.,EA8C A0 40    LDY #$40        set no key
.,EA8E 84 CB    STY $CB         save which key
.,EA90 8D 00 DC STA $DC00       clear VIA 1 DRA, keyboard column drive
.,EA93 AE 01 DC LDX $DC01       read VIA 1 DRB, keyboard row port
.,EA96 E0 FF    CPX #$FF        compare with all bits set
.,EA98 F0 61    BEQ $EAFB       if no key pressed clear current key and exit (does
                                further BEQ to $EBBA)
.,EA9A A8       TAY             clear the key count
.,EA9B A9 81    LDA #$81get the decode table low byte
.,EA9D 85 F5    STA $F5         save the keyboard pointer low byte
.,EA9F A9 EB    LDA #$EB        get the decode table high byte
.,EAA1 85 F6    STA $F6save the keyboard pointer high byte
.,EAA3 A9 FE    LDA #$FE        set column 0 low
.,EAA5 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,EAA8 A2 08    LDX #$08        set the row count
.,EAAA 48       PHA             save the column
.,EAAB AD 01 DC LDA $DC01       read VIA 1 DRB, keyboard row port
.,EAAE CD 01 DC CMP $DC01       compare it with itself
.,EAB1 D0 F8    BNE $EAAB       loop if changing
.,EAB3 4A       LSR             shift row to Cb
.,EAB4 B0 16    BCS $EACC       if no key closed on this row go do next row
.,EAB6 48       PHA             save row
.,EAB7 B1 F5    LDA ($F5),Y     get character from decode table
.,EAB9 C9 05    CMP #$05        compare with $05, there is no $05 key but the control
                                keys are all less than $05
.,EABB B0 0C    BCS $EAC9       if not shift/control/c=/stop go save key count
                                else was shift/control/c=/stop key
.,EABD C9 03    CMP #$03        compare with $03, stop
.,EABF F0 08    BEQ $EAC9       if stop go save key count and continue
                                character is $01 - shift, $02 - c= or $04 - control
.,EAC1 0D 8D 02 ORA $028D       OR it with the keyboard shift/control/c= flag
.,EAC4 8D 8D 02 STA $028D       save the keyboard shift/control/c= flag
.,EAC7 10 02    BPL $EACB       skip save key, branch always
.,EAC9 84 CB    STY $CB         save key count
.,EACB 68       PLA             restore row
.,EACC C8       INY             increment key count
.,EACD C0 41    CPY #$41        compare with max+1
.,EACF B0 0B    BCS $EADC       exit loop if >= max+1
                                else still in matrix
.,EAD1 CA       DEX             decrement row count
.,EAD2 D0 DF    BNE $EAB3       loop if more rows to do
.,EAD4 38       SEC             set carry for keyboard column shift
.,EAD5 68       PLA             restore the column
.,EAD6 2A       ROL             shift the keyboard column
.,EAD7 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,EADA D0 CC    BNE $EAA8       loop for next column, branch always
.,EADC 68       PLA             dump the saved column
.,EADD 6C 8F 02 JMP ($028F)     evaluate the SHIFT/CTRL/C= keys, $EBDC
                                key decoding continues here after the SHIFT/CTRL/C= keys are evaluated
.,EAE0 A4 CB    LDY $CB         get saved key count
.,EAE2 B1 F5    LDA ($F5),Y     get character from decode table
.,EAE4 AA       TAX             copy character to X
.,EAE5 C4 C5    CPY $C5         compare key count with last key count
.,EAE7 F0 07    BEQ $EAF0       if this key = current key, key held, go test repeat
.,EAE9 A0 10    LDY #$10        set the repeat delay count
.,EAEB 8C 8C 02 STY $028C       save the repeat delay count
.,EAEE D0 36    BNE $EB26       go save key to buffer and exit, branch always
.,EAF0 29 7F    AND #$7F        clear b7
.,EAF2 2C 8A 02 BIT $028A       test key repeat
.,EAF5 30 16    BMI $EB0D       if repeat all go ??
.,EAF7 70 49    BVS $EB42       if repeat none go ??
.,EAF9 C9 7F    CMP #$7F        compare with end marker
.,EAFB F0 29    BEQ $EB26       if $00/end marker go save key to buffer and exit
.,EAFD C9 14    CMP #$14        compare with [INSERT]/[DELETE]
.,EAFF F0 0C    BEQ $EB0D       if [INSERT]/[DELETE] go test for repeat
.,EB01 C9 20    CMP #$20        compare with [SPACE]
.,EB03 F0 08    BEQ $EB0D       if [SPACE] go test for repeat
.,EB05 C9 1D    CMP #$1D        compare with [CURSOR RIGHT]
.,EB07 F0 04    BEQ $EB0D       if [CURSOR RIGHT] go test for repeat
.,EB09 C9 11    CMP #$11        compare with [CURSOR DOWN]
.,EB0B D0 35    BNE $EB42       if not [CURSOR DOWN] just exit
                                was one of the cursor movement keys, insert/delete
                                key or the space bar so always do repeat tests
.,EB0D AC 8C 02 LDY $028C       get the repeat delay counter
.,EB10 F0 05    BEQ $EB17       if delay expired go ??
.,EB12 CE 8C 02 DEC $028C       else decrement repeat delay counter
.,EB15 D0 2B    BNE $EB42       if delay not expired go ??
                                repeat delay counter has expired
.,EB17 CE 8B 02 DEC $028B       decrement the repeat speed counter
.,EB1A D0 26    BNE $EB42       branch if repeat speed count not expired
.,EB1C A0 04    LDY #$04        set for 4/60ths of a second
.,EB1E 8C 8B 02 STY $028B       save the repeat speed counter
.,EB21 A4 C6    LDY $C6         get the keyboard buffer index
.,EB23 88       DEY             decrement it
