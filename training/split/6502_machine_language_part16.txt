# ML for C64 - Chapter 7: Wedge, Extending BASIC

  page addresses reference a single address in the range $0000 to $00FF--the
  high byte of the address (00) is the memory page.  These address modes are
  used for fixed locations containing work values or system interfaces.

- Absolute, indexed and zero-page, indexed allows the named address to be
  adjusted by the contents of an index register--X or Y.  These instructions
  can reach a range of up to 256 addresses.  They are commonly used for
  tables of data or temporary storage areas.

- Relative addresses are used exclusively with branch instructions.  They
  have a limited "reach" of about 127 locations forward or backward.  It
  takes a little arithmetic to calculate the proper values, but the computer
  usually works this out for us.

- Indirect addressing is used only for jumps, most often to allow a fixed ROM
  program to take a variable jump.  The average machine language programmer
  will seldom need these, but the principle of indirect addressing is worth
  learning.

- Indirect, indexed addressing is the most important way to deal with data
  anywhere in memory.  We may reach anywhere by setting the indirect address,
  then we may "fine adjust" that address by indexing it with the contents of
  Y.

- Indirect, indexed addressing requires the indirect address to be in zero-
  page.  We need to conserve zero-page locations for this use.

- An addressing mode called indexed, indirect is rarely used when programming
  Commodore computers, but it's there if you want it.


Questions and Projects
----------------------

Write a program to clear the screen of your computer--check Appendix C for
the location of screen memory if you've forgotten.  Don't just print the
clear screen character ($93); do it another way.  Can you write the entire
program without using indirect, indexed addressing?

Write the program again using indirect, indexed addressing.  The program may
be a little shorter.  Can you think of any other advantages of writing this
way?

A user wishes to type in a line of text on the keyboard, ending with a
RETURN.  He then wants to have the program repeat the line ten times on the
screen.  What addressing mode or modes would you use to handle the user's
text?  Why?  You may try your hand at writing the program if you wish.

Take one of the previous exercises and try to write it again without using
immediate addressing.  Is it hard to do?  Can you see any reason to want to
code without using immediate addressing at all?

                                                                         :90:
                                                                         :91:



                                                          Chapter 6

                                                            Linking
                                                          BASIC and
                                                            Machine
                                                           Language


          This chapter discusses:

            o Where to put a machine language program

            o BASIC memory layout

            o Loading and the SOV pointer

            o BASIC variables:  fixed, floating, string

            o Exchanging data with BASIC


                                                                         :92:

Siting the Program
------------------

Up to this point, we have been placing all programs in the cassette buffer.
This is a good place for short test programs, but we need to examine
alternatives that are often more attractive.


BASIC Memory Layout
-------------------

BASIC RAM is organized according to the diagram below.  The following
locations are of particular interest:

  1.  Below the BASIC area, we have the cassette buffer area.  This is
      available to us, providing we are not engaged in input/output activity.

  2.  Start-of-BASIC (SOB) is usually a fixed address within the machine.  In
      PET/CBM, it's at $0401 (decimal 1025).  In Commodore 64, it's at $0801
      (decimal 2049).  In the PLUS/4 series, it's at $1001 (decimal 4097).
      In the VIC-20, it may be at one of several places:  $0401, $1001, or
      $1201.  A pointer marks this location.  The pointer is located at
      $28/$29 (decimal 40 and 41) in PET/CBM, and at $2B/$2C (decimal 43 and
      44), in VIC-20, Commodore 64, and PLUS/4.

  3.  End-of-BASIC is always signaled by three zero bytes somewhere after the
      SOB.  If you command NEW in BASIC, you'll find the three bytes right at
      the start of BASIC; there is no program, so start and end are there.
      There is no pointer that indicates end-of-BASIC, just the three zeros;
      but the next location (SOV) will often be directly behind the end-of-
      BASIC.

      The BASIC program that you type in will occupy memory space from start-
      of-BASIC to end-of-BASIC.  If you add lines to a program, end-of-BASIC
      will move up as extra memory is taken up by your programs.  If you
      delete lines, end-of-BASIC will move down.


                       __________________BASIC RAM_______________________
                      /                                                  \
  -+--------+-------+-+---------+---+-----------+-------+------+---------+--
   |Cassette|       | |  BASIC  |0  |   BASIC   | BASIC |      | DYNAMIC |
   |        |       |0|         | 0 |           |       | FREE |         |
   | Buffer |       | | PROGRAM |  0| VARIABLES | ARRAYS|      | STRINGS |
  -+--------+-------+-+---------+---+-----------+-------+------+---------+--
                       ^             ^           ^       ^      ^         ^
                       |             |           |       |      |         |
                      SOB           SOV         SOA     EOA    BOS       TOM

  Figure 6.1

                                                                         :93:

  4.  Start-of-variables (SOV) is often positioned directly behind the end-
      of-BASIC.  When the BASIC program runs, the variables will be written
      into memory starting at this point; each variable is exactly seven
      bytes long.  A pointer marks this location.  The pointer is located at
      $2A/$2B (decimal 42 and 43) in PET/CBM, and at $2D/$2E (decimal 45 and
      46) in VIC-20, Commodore 64, and PLUS/4.

      The SOV pointer is extremely important during BASIC load and save
      activities.  If we give the BASIC command SAVE in direct mode, the
      computer will automatically save all memory from SOB to just before the
      SOV.  Thus, it saves the whole BASIC program, including the end-of-
      BASIC marker of three zero bytes, but does not save any variables.  If
      we give the BASIC command LOAD in direct mode, the computer will
      automatically load the program, and then place the SOV pointer to just
      behind the last byte loaded.  In this way, variables will never be
      stored over the BASIC program; they will be written above the end-of-
      BASIC.  More on this later.

      If the BASIC program is changed, the SOV may move up or down as needed.

  5.  Start-of-arrays (SOA) also represents one location beyond the end-of-
      BASIC variables, and thus could be named end-of-variables.  Arrays
      created by the BASIC program, either by use of a DIM statement or by
      default dimensioning, will occupy memory starting at this point.  A
      pointer marks this location.  The pointer is located at $2C/$2D
      (decimal 44 and 45) in PET/CBM, and at $2F/$30 (decimal 47 and 48) in
      VIC-20, Commodore 64, and PLUS/4.  If the BASIC program is changed, the
      SOA pointer is set to match the SOV.  Thus, all BASIC variables are
      wiped out the moment a change is made to the program.

  6.  End-of-arrays (EOA) is set one location beyond the last array location
      in BASIC.  Above this point is seemingly "free" memory--but it's not
      really free, as we'll see soon.  A pointer marks this location.  The
      pointer is located at $2E/$2F (decimal 46 and 47) in PET/CBM, and at
      $31/$32 (decimal 49 and 50) in VIC-20, Commodore 64, and PLUS/4.

      If the BASIC program is changed, the EOA pointer is set to match the
      SOA and SOV.  Thus, all BASIC arrays are wiped out the moment a change
      is made to the BASIC program.

      Let's change direction and start to work our way down from the top of
      BASIC memory.

  7.  Top-of-memory (TOM) is set one location beyond the last byte available
      to BASIC.  On the PET/CBM and VIC-20, its location depends on the
      amount of memory fitted; a 32K PET would locate TOM at $8000.  On the
      Commodore 64, the TOM will normally be located at $A000.  A pointer
      marks this location.  The pointer is located at $34/$35 (decimal 52 and
      53) in PET/CBM, and at $37/$38 (decimal 55 and 56) in VIC-20, Commodore
      64, and PLUS/4.

                                                                         :94:

      If you examine the TOM pointer, you may find that it does not point at
      the expected position.  That may be because of the machine language
      monitor, which has taken up residence at the top of memory and stolen
      away some memory.

  8.  Bottom-of-strings, (BOS) is set to the last "dynamic" string that has
      been created.  If there are no BASIC strings, the BOM will be set to
      the same address as TOM.  As new dynamic strings are created, this
      pointer moves down from the top-of-memory towards the EOA address.  A
      pointer marks this location.  The pointer is located at $30/$31
      (decimal 48 and 49) in PET/CBM, and at $33/$34 (decimal 51 and 52) in
      VIC-20, Commodore 64, and PLUS/4.

A dynamic string is one that cannot be used directly from the program where
it is defined; you might like to think of it as a manufactured string.  If,
within a BASIC program, I type:  100 X$="HAPPY NEW YEAR", the BASIC
interpreter will not need to store the string in upper memory; it will use
the string directly from where it lies within the program.  On the other
hand, if I define strings with commands such as R$=R$+"*" or INPUT N$, the
strings must be built into some spare part of memory.  That's where the BOS
pointer comes in:  the computed string is placed high in memory, and the BOS
moved down to mark the next free place.

If the BASIC program is changed, the BOS pointer is set to match the TOM.
Thus, all strings are wiped out the moment a change is made to the BASIC
program.


Free Memory:  The Dangerous Place
---------------------------------

It seems to beginners that there is a great deal of free memory available
above the end-of-arrays and below the bottom-of-strings, and that this would
be an ideal place to put a machine language program.  This is a pitfall:  it
usually won't work.

Here's the danger.  As more and more dynamic strings are created, the bottom-
of-strings location keeps moving down.  Even when strings are no longer
needed, they are abandoned and left dead in memory, taking up space.

The BOS keeps moving down.  Only when it touches the EOA will the dead
strings be cleaned up and the good ones repacked, an action called garbage
collection.  It's important for BASIC programmers to know about garbage
collection:  except on BASIC 4.0 and Commodore PLUS/4 systems, it can be a
cause of serious program slowdown.

                                                                         :95:

It's evident that the space between EOA and BOS is not safe.  If you put a
program there, the strings will eventually destroy it.  We must look
elsewhere.


Where to Put Your ML Program
----------------------------

First, you may put your program in the cassette buffer.  Providing you are
not performing input/output activity, your program will be safe.  Your space
here is limited to 190 characters or so.


                 SOB        SOV   SOA   EOA   BOS   TOM
                  |          |     |     |     |     |
  -+========+----+----------+-----+-----+-- --+-----+--
   |C.B.====|    | BASIC... | VAR | ARR | ... | STR |
  -+========+----+----------+-----+-----+-- --+-----+--

  Figure 6.2


Second, move down the top-of-memory pointer and place the program in the
space that has been freed.  Your space here is unlimited.  Programs placed
here will take up permanent residence until the power is turned off.  Many
monitors, such as Supermon, live here.

                                                NEW  OLD
                 SOB       SOV  SOA  EOA   BOS  TOM  TOM
                  |         |    |    |     |    |    |
  -+--------+----+---------+----+----+-- --+----+====+--
   |C.B.    |    |         |    |    | ... |    |====|
  -+--------+----+---------+----+----+-- --+----+====+--

  Figure 6.3


                           OLD  NEW
                 SOB       SOV  SOV  SOA  EOA   BOS  TOM
                  |         |    |    |    |     |    |
  -+--------+----+---------+====+----+----+-- --+----+--
   |C.B.    |    |      000|====|    |    | ... |    |
  -+--------+----+---------+====+----+----+-- --+----+--

  Figure 6.3


Third, move up the start-of-variables pointer, and place the program after
the end of BASIC and before the new start-of-variables.  Your space here is
unlimited  Programs placed here will tend to "join company" with the BASIC
program; the two will save and load together.

                                                                         :96:

After moving a pointer--as was done in the last two methods--it's a good idea
to return to BASIC and command CLR, so that all other variable pointers will
align correctly with the ones that have moved.

These three areas will be discussed more in a few moments.  First there are
one or two extra locations available to VIC-20 and Commodore 64.


Extras for VIC and Commodore 64
-------------------------------

The Commodore 64 has a free block of RAM at locations $C000 to $CFFF (decimal
