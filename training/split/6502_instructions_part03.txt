# 6502 Address Modes in Detail - Accumulator, Absolute, Immediate

            Most arithmetic and logical operations interact with this
            register.
            The X and Y registers are auxiliary registers. Like the
            accumulator, they can be loaded directly with values, both
            immediatedly (as literal constants) or from memory.
            Additionally, they can be incremented and decremented, and
            their contents may be transferred to and from the acuumulator.
            Their main purpose is the use as index registers, where their
            contents is added to a base memory location, before any values
            are either stored to or retrieved from the resulting address,
            which is known as the effective address. This is commonly used
            for loops and table lookups at a given index, hence the name.
            (See address modes, below.)
            The program counter keeps track of the memory location holding
            the current instruction code. Its contents is automatically
            stepped up as the program is executed and is modified by
            branch and jump operations. As it must be able to address the
            full 16-bit address range of 64K bytes, it's the only 16-bit
            register of the 6502.
            The stack pointer points to the current top of stack (or
            rather, to its bottom, as the stack grows top-down.) The
            processor stack is located on memory page #1 ($0100â€“$01FF), a
            256 bytes last-in-first-out (LIFO) stack, which enables
            subroutines and also serves as a quick intermediate storage.
            As a 8-bit register, the stack pointer holds just the low-byte
            of this address (the offset from $0100.)
            Be aware that this will just wrap around, in case that the
            stack underflows.
                                                          6502 Instruction Set
            The status register holds the status of the processor,
            consisting of flags reflecting results of previous operations,
            configuration flags, like disabeling (blocking) interrupts or
            setting up binary encoded decimal mode (BCD), and the carry
            flag, which enables multi-byte arithmetics.
          Status Register Flags (bit 7 to bit 0)
             N .... Negative
             V .... Overflow
             - .... ignored
             B .... Break
             D .... Decimal (use BCD for arithmetics)
             I .... Interrupt (IRQ disable)
             Z .... Zero
             C .... Carry
            The zero flag (Z) indicates a value of all zero bits and the
            negative flag (N) indicates the presence of a set sign bit in
            bit-position 7. These flags are always updated, whenever a
            value is transferred to a CPU register (A,X,Y) and as a result
            of any logical ALU operations. The Z and N flags are also
            updated by increment and decrement operations acting on a
            memory location.
            The carry flag (C) flag is used as a buffer and as a borrow in
            arithmetic operations. Any comparisons will update this
            additionally to the Z and N flags, as do shift and rotate
            operations.
            All arithmetic operations update the Z, N, C and V flags.
            The overflow flag (V) indicates overflow with signed binary
            arithmetics. As a signed byte represents a range of -128 to
            +127, an overflow can never occur when the operands are of
            opposite sign, since the result will never exceed this range.
            Thus, overflow may only occur, if both operands are of the
            same sign. Then, the result must be also of the same sign.
            Otherwise, overflow is detected and the overflow flag is set.
            (I.e., both operands have a zero in the sign position at bit
            7, but bit 7 of the result is 1, or, both operands have the
            sign-bit set, but the result is positive.)
            The decimal flag (D) sets the ALU to binary coded decimal
            (BCD) mode for additions and subtractions (ADC, SBC).
            The interrupt inhibit flag (I) blocks any maskable interrupt
            requests (IRQ).
            The break flag (B) is not an actual flag implemented in a
            register, and rather appears only, when the status register is
            pushed onto or pulled from the stack. When pushed, it will be
            1 when transfered by a BRK or PHP instruction, and zero
                                                                     6502 Instruction Set
            otherwise (i.e., when pushed by a hardware interrupt). When
            pulled into the status register (by PLP or on RTI), it will be
            ignored.
            In other words, the break flag will be inserted, whenever the
            status register is transferred to the stack by software (BRK
            or PHP), and will be zero, when transferred by hardware. Since
            there is no actual slot for the break flag, it will be always
            ignored, when retrieved (PLP or RTI). The break flag is not
            accessed by the CPU at anytime and there is no internal
            representation. Its purpose is more for patching, to discern
            an interrupt caused by a BRK instruction from a normal
            interrupt initiated by hardware.
            Any of these flags (but the break flag) may be set or cleared
            by dedicated instructions. Moreover, there are branch
            instructions to conditionally divert the control flow
            depending on the respective state of the Z, N, C or V flag.
          Processor Stack
          LIFO, top-down, 8 bit range, 0x0100 - 0x01FF
          Bytes, Words, Addressing
          8 bit bytes, 16 bit words in lobyte-hibyte representation (Little-Endian).
          16 bit address range, operands follow instruction codes.
          Signed values are two's complement, sign in bit 7 (most significant bit).
          (%11111111 = $FF = -1, %10000000 = $80 = -128, %01111111 = $7F = +127)
          Signed binary and binary coded decimal (BCD) arithmetic modes.
          System Vectors
          $FFFA, $FFFB ... NMI (Non-Maskable Interrupt) vector, 16-bit (LB, HB)
          $FFFC, $FFFD ... RES (Reset) vector, 16-bit (LB, HB)
          $FFFE, $FFFF ... IRQ (Interrupt Request) vector, 16-bit (LB, HB)
          Start/Reset Operations
          An active-low reset line allows to hold the processor in a known disabled
          state, while the system is initialized. As the reset line goes high, the
          processor performs a start sequence of 7 cycles, at the end of which the
          program counter (PC) is read from the address provided in the 16-bit reset
          vector at $FFFC (LB-HB). Then, at the eighth cycle, the processor transfers
          control by performing a JMP to the provided address.
          Any other initializations are left to the thus executed program. (Notably,
          instructions exist for the initialization and loading of all registers, but
          for the program counter, which is provided by the reset vector at $FFFC.)
                                                                6502 Instruction Set
