# ********* - Complete BASIC source listing and explanation for RELFILE.PRG. Includes the tok64 directive and full BASIC program that demonstrates creating a relative file, opening devices (OPEN statements), positioning record pointers using print#1,"p" with chr$ sequences, writing and reading records to/from channels 1 and 2, prompting for user input, handling replacement of records, use of the error channel (subroutine at line 2000), keyboard function-key scanning (subroutine at line 5000), hardcopy/continue handling (subroutine at line 6000), helper comments and alternate-read notes (7000+), and the record-replacement subroutine (8000+). The listing ends with the 'stop tok64' directive. This chunk is a standalone BASIC program and documents all in-BASIC behaviors and subroutines referenced by the encoded distribution below.


PROGRAM AND EXPLANATION

start tok64 relfile.prg
 1 rem relative file program
 2 dim a$(5):dim c$(5):print"{clear}"
 3 print "hit f1 to construct a relative file"
 4 print "hit f3 to read a relative file"
 5 print "hit f5 to read the error channel":gosub 5000
 6 input "enter relative file name";z$
 8 open 2,8,2,z$+",l,"+chr$(50):rem create the relative file
 9 open 1,8,15
 11 gosub 1000
 20 for i=1 to 5
 30 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(1):rem position the \
    record pointer
 40 print "enter a name"
 50 input a$(i)
 60 print#2,a$(i)
 63 input "enter additional info";c$(i)
 65 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(25):rem position \
    pointer to 25th character
 67 print#2,c$(i)
 70 next i
 75 print "do you wish to replace a record":input d$
 76 if d$="n" then 80
 77 gosub 8000
 78 go to 75
 80 print "the relative file is constructed"
 82 for de=1 to 2500: next de: gosub 6000
 85 close 2
 90 end:stop
 100 input "enter desired file to read";z$
 105 open 2,8,2,z$:open 1,8,15
 106 print "reading " z$
 110 for i=1 to 5
 115 rem for i=5 to 1 step -1
 130 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(1)
 160 input#2,a$(i)
 170 print "record#(" i ")=", a$(i)
 175 k=6-i
 177 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(25)
 179 input#2,c$(i):print "additional info:";c$(i)
 180 next i
 181 print "do you wish to replace a record":input d$
 182 if d$="n" then 185
 183 gosub 8000
 184 go to 181
 185 gosub 1000
 186 j=i+1
 190 print "end of read":for de=1 to 1500:next de:gosub 6000:\
     close 2:close 1:end
 1000 input#1,a,b$,c,d:if a<20 then return
 1001 if a<>50 then print a,b$,c,d :stop: return
 1999 end
 2000 open 15,8,15
 2001 input#15,a,b$,c,d
 2002 print a,b$,c,d
 2003 close 15:end
 5000 get s$:if s$="" then 5000: rem scan keyboard for function \
      key chr$ codes
 5001 if s$=chr$(133) then 6: rem assign f1 function key
 5002 if s$=chr$(134) then 100: rem assign f3 function key
 5003 if s$=chr$(135) then 2000: rem assign f5 function key
 5004 return
 6000 print "{clear}hit f7: for hard copy or c to continue"
 6001 get p$: if p$<>chr$(136) and p$="c" then return
 6002 for de=1 to 500: next de: if p$ ="" or p$<>chr$(136) then 6000
 6003 open 4,4:cmd 4
 6004 print#4,"the " z$ " file consists of:"
 6005 for i=1 to 5
 6010 print#4,"record #";i;"=";a$(i)
 6012 print#4,"additional info ";i;"=";c$(i)
 6015 next i
 6020 close 4:return
 7000 rem to read in records in reverse order remove the rem in \
      line #115 and
 7002 rem put a rem before line#110
 7005 rem to read the 1st field of the 1st record and the 2nd \
      field of the last
 7007 rem replace the chr$(i) in line 177 with chr$(k)
 8000 print "which record # do you want replaced":input i
 8001 input "enter new record";a$(i)
 8002 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(1):rem position \
      file pointer
 8003 print#2,a$(i)
 8004 input "enter new record (field 2)";c$(i)
 8005 print#1,"p" chr$(2+96)chr$(i)chr$(0)chr$(25):rem position \
      file pointer
 8007 print#2,c$(i)
 8009 print "record#";i;" has been replaced"
 8010 return
stop tok64


---
Additional information can be found by searching:
- "relfile_prg_encoded_dump" which expands on encoded/tokenized distribution of this RELFILE.PRG program (begin 644 ... end)
