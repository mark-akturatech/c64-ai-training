# 6502 Instructions by Type - Interrupts, Flags

           This mode looks up a given address and uses the contents of this
           address and the next one (in LLHH little-endian order) as the
           effective address. In its basic form, this mode is available for the
           JMP instruction only. (Its generally use is jump vectors and jump
           tables.)
           Like the absolute JMP instruction it uses a 16-bit address (3 bytes
           in total), but takes two additional CPU cycles to execute, since
           there are two additional bytes to fetch for the lookup of the
           effective jump target.
           Generally, indirect addressing is denoted by putting the lookup
           address in parenthesis.
            Mnemonic      Instruction          Lookup
            JMP ($FF82)    6C 82 FF     $FF82: C4 80
                                           PC: $80C4 (Effective Targe
           Mnemonic Example:
           JMP ($FF82) ... jump to address given in locations "$FF82" and "$FF83"
           Note: On the original NMOS 6502, the high-byte of the lookup address
           is not incremented at page boundaries. Meaning, if the low-byte of
           the lookup address is $FF, the high-byte will be fetched from $00 at
           the same page. (E.g., "JMP ($11FF)" will effectively resolve to a
           lookup at $1199 for the low-byte and $1100 for the high-byte, while
           we should expect $1200 being used for the latter.)
           This is corrected on the CMOS version of the CPU, where this behaves
           as expected, but the processor will take an extra cycle to so.
           Pre-Indexed Indirect, "(Zero-Page,X)"
           Indexed indirect address modes are generally available only for
           instructions supplying an operand to the accumulator (LDA, STA, ADC,
           SBC, AND, ORA, EOR, etc). The placement of the index register inside
           or outside of the parenthesis indicating the address lookup will
           give you clue what these instructions are doing.
           Pre-indexed indirect address mode is only available in combination
           with the X-register. It works much like the "zero-page,X" mode, but,
           after the X-register has been added to the base address, instead of
           directly accessing this, an additional lookup is performed, reading
                                                                       6502 Instruction Set
           the contents of resulting address and the next one (in LLHH little-
           endian order), in order to determine the effective address.
           Like with "zero-page,X" mode, the total instruction length is 2
           bytes, but there are two additional CPU cycles in order to fetch the
           effective 16-bit address. As "zero-page,X" mode, a lookup address
           will never overflow into the next page, but will simply wrap around
           in the zero-page.
           These instructions are useful, whenever we want to loop over a table
           of pointers to disperse addresses, or where we want to apply the
           same operation to various addresses, which we have stored as a table
           in the zero-page.
            Mnemonic    Instruction           Lookup        Data
            LDA ($70,X)   A1 70
                                 + = $0075: 23 30     $3023: A5
                          X: 05
                                                         A: A5
           Mnemonic Examples:
           LDA ($70,X) ... load the contents of the location given in addresses
                           "$0070+X" and "$0070+1+X" into A
           STA ($A2,X) ... store the contents of A in the location given in
                           addresses "$00A2+X" and "$00A3+X"
           EOR ($BA,X) ... perform an exlusive OR of the contents of A and the contents
                           of the location given in addresses "$00BA+X" and "$00BB+X"
           Post-Indexed Indirect, "(Zero-Page),Y"
           Post-indexed indirect addressing is only available in combination
           with the Y-register. As indicated by the indexing term ",Y" being
           appended to the outside of the parenthesis indicating the indirect
           lookup, here, a pointer is first read (from the given zero-page
           address) and resolved and only then the contents of the Y-register
           is added to this to give the effective address.
           Like with "zero-page,Y" mode, the total instruction length is 2
           bytes, but there it takes an additional CPU cycles to resolve and
           index the 16-bit pointer. As with "absolute,X" mode, the effective
           address may overflow into the next page, in the case of which the
           execution uses an extra CPU cycle.
           These instructions are useful, wherever we want to perform lookups
           on varying bases addresses or whenever we want to loop over tables,
           the base address of which we have stored in the zero-page.
                                                                         6502 Instruction Set
            Mnemonic    Instruction         Lookup             Data
            LDA ($70),Y    B1 70    $0070: 43 35
                                                    + = $3553: 23
                                            Y: 10
                                                            A: 23
           Mnemonic Examples:
           LDA ($70),Y ... add the contents of the Y-register to the pointer provided in
                            "$0070" and "$0071" and load the contents of this address into A
           STA ($A2),Y ... store the contents of A in the location given by the pointer
                            in "$00A2" and "$00A3" plus the contents of the Y-register
           EOR ($BA),Y ... perform an exlusive OR of the contents of A and the address
                            given by the addition of Y to the pointer in "$00BA" and "$00BB"
           Relative Addressing (Conditional Branching)
           This final address mode is exlusive to conditional branch
           instructions, which branch in the execution path depending on the
           state of a given CPU flag. Here, the instruction provides only a
           relative offset, which is added to the contents of the program
           counter (PC) as it points to the immediate next instruction. The
           relative offset is a signed single byte value in two's complement
           encoding (giving a range of −128…+127), which allows for branching
           up to half a page forwards and backwards.
           On the one hand, this makes these instructions compact, fast and
           relocatable at the same time. On the other hand, we have to mind
           that our branch target is no farther away than half a memory page.
           Generally, an assembler will take care of this and we only have to
           provide the target address, not having to worry about relative
           addressing.
           These instructions are always of 2 bytes length and perform in 2 CPU
           cycles, if the branch is not taken (the condition resolving to
           'false'), and 3 cycles, if the branch is taken (when the condition
           is true). If a branch is taken and the target is on a different
           page, this adds another CPU cycle (4 in total).
              PC         Mnemonic    Instruction             Target
            $1000       BEQ $1005       F0 03
                                                Offset
            $1002
                                                +        PC: $1005
                  PC pointing to next instruction
           Mnemonic Examples:
           (Examples are provided in usual assembler format. Mind how these
           look much like instructions in absolute address mode.)
                                                                         6502 Instruction Set
            BEQ $1005 ... branch to location "$1005", if the zero flag is set.
                          if the current address is $1000, this will give an offset of $03.
            BCS $08C4 ... branch to location "$08C4", if the carry flag is set.
                          if the current address is $08D4, this will give an offset of $EE (−$12).
            BCC $084A ... branch to location "$084A", if the carry flag is clear.
          Vendor
          MOS Technology, 1975
                Image: Wikimedia Commons.
