# MACHINE - Principles of addition applied to bytes and multi-byte values: start at the low-order byte, include any previous carry, clear the carry with CLC before starting a new addition, and treat a final carry on unsigned additions as overflow. Includes a decimal example and ASCII figure illustrating carries. Gives machine-language translation: use CLC, perform additions in A with ADC from low to high bytes, and check flags after completion (C for unsigned overflow, V for signed overflow). Includes example code for 1-byte and 2-byte additions (LDA/ADC/STA sequences) and suggestion to branch on carry or overflow to error routines. Notes that signed multi-byte additions use the same code but check V (BVS) instead of C.



Addition
--------

Principles of addition are similar to those we use in decimal arithmetic;
for decimal "columns," you may substitute "bytes."  Let's look at a simple
decimal addition:

                                                                         :59:

    142856
  + 389217
  --------

  Rule 1:  We start at the right-hand column (the low-order byte).

  Rule 2:  We add the two values, plus any carry from the previous column.  A
  new carry may be generated; it can never be greater than one.  (ADC
  includes any carry from a previous activity, and may generate a new carry
  bit, which is either 0 or 1.)

  Rule 3:  When we start at the right-hand column, there is no carry for the
  first addition.  (We must clear the carry with CLC before starting a new
  addition.)

  Rule 4:  When we have finished the whole addition, if we have a carry and
  no column to put it in, we say the answer "won't fit."  (If an addition
  sequence of unsigned numbers ends up with the carry flag set, it's an
  overflow condition.)


    HIGH BYTE        LOW BYTE
                               Start:
    00101011         10111001  No carry
    00001010         11100101 /
    -------------------------/
                     10011110
                    /
                   /
              Carry
             /
            /
    00110110

    Figure 4.1


How do we translate these rules into machine language addition?

  1.  Before we start an addition sequence, clear the carry with CLC.

  2.  If the numbers are more than one byte in size, start at the low byte
      and work up to the high ones.  Addition will take place in the A
      register only; you may add the contents of an address or an immediate
      value.  The carry flag will take care of any carries.

  3.  When the addition sequence is complete, check for overflow:
      a)  if the numbers are unsigned, a set C flag indicates overflow;
      b)  if the numbers are signed, a set V flag indicates overflow.

Thus, to add two unsigned numbers located at addresses $0380 and $0381 and to
place the result at $0382, we might code

                                                                         :60:

  CLC
  LDA $0380
  ADC $0381
  STA $0382

We might also BCS to an error routine, if desired.

To add a two-byte number located at $03A0 (low) and $03A1 (high) to another
two-byte number located at $03B0 (low) and $03B1 (high), placing the result
at $03C0/1, we might code

  CLC
  LDA $03A0
  ADC $03B0
  STA $03C0
  LDA $03A1
  ADC $03B1
  STA $03C1

Again, we might BCS to an overflow error routine.

If we had two-byte signed numbers in the same locations, we'd add them
exactly the same way, using the same code as above.  In this case, however,
we'd check for overflow by adding the instruction BVS, which would branch to
an error routine.  The carry flag would have no meaning at the end of the
addition sequence.


---
Additional information can be found by searching:
- "big_numbers_multi_byte" which expands on why carries matter across bytes and how to size numbers
- "subtraction_multi_byte_machine_code" which expands on related rules for subtraction (inverted borrow, SEC, SBC)
