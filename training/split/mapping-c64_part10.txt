# C64 Zero Page - Screen Editor, Keyboard $C5-$FF


The exception to this rule is the DELETE key, which will function
normally within quote mode.  The only way to print a character which
is equivalent to the DELETE key is by entering insert mode (see
loctaion 216 ($D8)).  Quote mode may be exited by printing a closing
quote, or by hitting the RETURN or SHIFT-RETURN keys.

Sometimes, it would be handy to be able to escape from quote mode or
insert mode without skipping to a new line.  The machine language
program below hooks into the keyscan interrupt routine, and allows you
to escape quote mode by changing this flag to 0 when you press the f1
key:

10 FOR I=850 TO I+41:READ A:POKE I,A:NEXT
20 PRINTCHR$(147)"PRESS F1 KEY TO ESCAPE QUOTE MODE"
30 PRINT"TO RESTART AFTER RESTORE ONLY, SYS 850":SYS850:NEW
40 DATA  173 , 143 , 2 , 141 , 46 , 3 , 173 , 144 , 2 , 141
50 DATA 47 , 3 , 120 , 169 , 107 , 141 , 143 , 2 , 169 , 3
60 DATA 141 , 144 , 2 , 88 , 96 , 165 , 203 , 201 , 4 , 208
70 DATA 8 , 169 , 0 , 133 , 212 , 133 , 216 , 133 , 199 , 108 , 46 , 3

213           $D5            LNMX
Maximum Length of Physical Screen Line

The line editor uses this location when the end of a line has been
reached to determine whether another physical line can be added to the
current logical line, or if a new logical line must be started.

214           $D6            TBLX
Current Cursor Physical Line Number

This location contains the current physical screen line position of
the cursor (0-24).  It can be used in a fashion to move the cursor
vertically, by POKEing the target screen line (1-25) minus 1 here,
followed by a PRINT command.  For example,

POKE 214,9:PRINT:PRINT "WE'RE ON LINE ELEVEN"

prints the message on line 11.  The first PRINT statement allows the
system to update the other screen editor variables so that they will
also show the new line.  The cursor can also be set or read using the
Kernal PLOT routine (58634, $E50A) as explained in the entry from
locations 780-783 ($30C-$30F).

215           $D7
Temporary Storage Area for ASCII Value of Last Character Printed

The ASCII value of the last character printed to the screen is held
here temporarily.

216           $D8            INSRT
Flag: Insert Mode (Any Number Greater Than 0 Is the Number of Inserts)

When the INST key is pressed, the screen editor shifts the line to the
right, allocates another physical line to the logical line if
necessary (and possible), updates the screen line length in 213 ($D5),
and adjusts the screen line link table at 217 ($D9).  This location is
used to keep track of the number of spaces that has been opened up in
this way.

Until the spaces that have been opened up are filled, the editor acts
as if in quote mode (see location 212 ($D4), the quote mode flag).
This means that cursor control characters that are normally
nonprinting will leave a printed equivalent on the screen when
entered, instead of having their normal effect on cursor movement,
etc.  The only difference between insert and quote mode is that the
DELETE key will leave a printed equivalent in insert mode, while the
INST key will insert spaces as normal.

217-242       $D9-$F2        LDTB1
Screen Line Link Table/Editor Temporary Storage

This table contains 25 entries, one for each row of the screen
display.  Each entry has two functions.  Bits 0-3 indicate on which of
the four pages of screen memory  the first byte of memory for that row
is located.  This is used in calculating the pointer to the starting
address of a screen line at 209 ($D1).

While earlier PETs used one table for the low bytes of screen rows and
another for the high bytes, this is not possible on the 64, where
screen memory is not fixed in any one spot.  Therefore, the Operating
System uses a table of low bytes at 60656 ($ECF0), but calculates the
high byte by adding the value of the starting page of screen memory
held in 648 ($288) to the displacement page held here.

The other function of this table is to establish the makeup of logical
lines on the screen.  While each screen line is only 40 characters
long, BASIC allows the entry of program lines that contain up to 80
characters.  Therefore, some method must be used to determine which
pairs of physical lines are linked into a longer logical line, so that
this longer logical line may be edited as a unit.

The high bit of each byte here is used as a flag by the screen editor.
That bit is set (leaving the value of the byte over 128 ($80)) when a
line is the first or only physical line in a logical line.  The high
bit is reset to 0 only when a line is the second half of a logical
line.

243-244       $F3-$F4        USER
Pointer to the Address of the Current Screen Color RAM Location

This poitner is synchronized with the pointer to the address of the
first byte of screen RAM for the current line kept in location 209
($D1).  It holds the address of the first byte of color RAM for the
corresponding screen line.

245-246       $F5-$F6        KEYTAB
Vector: Keyboard Decode Table

KEYTAB points to the address of the keyboard matrix lookup table
currently being used.  Although there are only 64 keys on the keyboard
matrix, each key can be used to print up to four different characters,
depending on whether it is struck by itself or in combination with the
SHIFT, CTRL, or Commodore logo keys.

The tables pointed to y this address hold the ASCII value of each of
the 64 keys for one of these possible combinations of keypresses.
When it comes time to print the character, the table that is used
determines which character is printed.

The addresses of the four tables are:

60289 ($EB81) = default uppercase/graphics characters (unshifted)
60354 ($EBC2) = shifted characters
60419 ($EC03) = Commodore logo key characters
60536 ($EC78) = CTRL characters

The concept of the keyboard matrix tables should not be confused with
changing the character sets from uppercase/graphics to
upper/lowercase.  The former involves determining what character is to
be placed into screen memory, while the latter involves determining
which character data table is to be used to decode the screen memory
into individual dots for the display of characters on the screen.
That character base is determined by location 53272 ($D018) of the
VIC-II chip.

247-248       $F7-$F8        RIBUF
Pointer: RS-232 Input Buffer

When device number 2 (the RS-232 channel) is opened, two buffers of
256 bytes each are created at the top of memory.  This location points
to the address of the one which is used to store characters as they
are received.  A BASIC program should always OPEN device 2 before
assigning any variables to avoid the consequences of overwriting
variables which were previously located at the top of memory, as BASIC
executes a CLR after opening this device.

249-250       $F9-$FA        ROBUF
Pointer: RS-232 Output Buffer

This location points to the address of the 256-byte output buffer
which is used for transmitting data to RS-232 devices (device number
2)l

251-254       $FB-$FE        FREEZP
Four Free Bytes of Zero Page for User Programs

These locations were specifically set aside for user-written ML
routines that require zero-page addressing.  While other zero-page
locations can be used on a noninterference basis, it is guaranteed
that BASIC will not alter these locations.

255           $FF            BASZPT
BASIC Temporary Data for Floating Point to ASCII Conversion

This location is used for temporary storage in the process of
converting floating point numbers to ASCII characters..


:::::::::::::
