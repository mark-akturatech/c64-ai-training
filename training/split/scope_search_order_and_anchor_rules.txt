# ca65 Users Guide - Detailed scope search order and anchoring: how the assembler searches current then enclosing scopes; scope references must reference a previously defined scope (scopes can't be used forward unless anchored with ::), examples of complex scope chains and how anchoring with :: changes lookup behavior.

7.7 Scope search order
The assembler searches for a scope in a similar way as for a symbol. First, it looks in the current scope, and then it walks up the enclosing scopes until the scope is found.

However, one important thing to note when using explicit scope syntax is, that a symbol may be accessed before it is defined, but a scope may not be used without a preceding definition. This means that in the following example:


        .scope  foo
                bar     = 3
        .endscope

        .scope  outer
                lda     #foo::bar  ; Will load 3, not 2!
                .scope  foo
                        bar     = 2
                .endscope
        .endscope
the reference to the scope foo will use the global scope, and not the local one, because the local one is not visible at the point where it is referenced.

Things get more complex if a complete chain of scopes is specified:


        .scope  foo
                .scope  outer
                        .scope  inner
                                bar = 1
                        .endscope
                .endscope
                .scope  another
                        .scope  nested
                                lda     #outer::inner::bar      ; 1
                        .endscope
                .endscope
        .endscope

        .scope  outer
                .scope  inner
                        bar = 2
                .endscope
        .endscope
When outer::inner::bar is referenced in the lda instruction, the assembler will first search in the local scope for a scope named outer. Since none is found, the enclosing scope (another) is checked. There is still no scope named outer, so scope foo is checked, and finally scope outer is found. Within this scope, inner is searched, and in this scope, the assembler looks for a symbol named bar.

Please note that once the anchor scope is found, all following scopes (inner in this case) are expected to be found exactly in this scope. The assembler will search the scope tree only for the first scope (if it is not anchored in the root scope). Starting from there on, there is no flexibility, so if the scope named outer found by the assembler does not contain a scope named inner, this would be an error, even if such a pair does exist (one level up in global scope).

Ambiguities that may be introduced by this search algorithm may be removed by anchoring the scope specification in the global scope. In the example above, if you want to access the "other" symbol bar, you would have to write:


        .scope  foo
                .scope  outer
                        .scope  inner
                                bar = 1
                        .endscope
                .endscope
                .scope  another
                        .scope  nested
                                lda     #::outer::inner::bar    ; 2
                        .endscope
                .endscope
        .endscope

        .scope  outer
                .scope  inner
                        bar = 2
                .endscope
        .endscope
The above example also shows that to search a scope that is not yet defined in the code above the usage, you should use the namespace token (::) and specify the full scope name, to allow the assembler to create the scope at the correct place.

---
Additional information can be found by searching:
- "structs_unions_enums_and_explicit_scope_spec" which expands on explicit scope syntax (::)
