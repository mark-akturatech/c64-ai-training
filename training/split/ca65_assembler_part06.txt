# CA65 Assembler - CPU Modes (65SC02, 65C02, 65816, Sweet16)

sir #{imm} Generates opcode $42.
Supported undocumented instructions:


ALR: A:=(A and #{imm})/2;
ANC: A:=A and #{imm}; Generates opcode $0B.
ARR: A:=(A and #{imm})/2;
AXS: X:=A and X-#{imm};
LAS: A,X,S:={addr} and S;
LAX: A,X:={addr};
NOP: #{imm}; zp; zp,x; abs; abs,x
RLA: {addr}:={addr}rol; A:=A and {addr};
RRA: {addr}:={addr}ror; A:=A adc {addr};
SHX: {addr}:=X and {addr hi +1};
SHY: {addr}:=y and {addr hi +1};
65SC02 mode
65SC02 mode supports all regular 6502 instructions, plus the original CMOS instructions.

65C02 mode (CMOS with Rockwell extensions)
65C02 mode supports all original CMOS instructions, plus the Rockwell (bit manipulation instructions) extensions.

W65C02 mode (CMOS with WDC extensions)
W65C02 mode supports the Rockwell extensions, plus wai and stp.

65CE02 mode
All 65CE02 instructions are accepted, plus the Rockwell extensions.

4510 mode
The 4510 is a microcontroller that is the core of the Commodore C65 aka C64DX. It contains among other functions a slightly modified 65CE02/4502 CPU, to allow address mapping for 20 bits of address space (1 megabyte addressable area).

As compared to the description of the CPU in the C65 System Specification (updated version) uses these changes:

LDA (d,SP),Y may also be written as LDA (d,S),Y (matching the 65816 notation).
All branch instruction allow now 16 bit offsets. To use a 16 bit branch you have to prefix these with an "L" (e.g. "LBNE" instead of "BNE"). This might change at a later implementation of the assembler.
For more information about the Commodore C65/C64DX and the 4510 CPU, see http://www.zimmers.net/anonftp/pub/cbm/c65/ and Wikipedia.

45GS02 mode
The 45GS02 is a microcontroller that is the core of the MEGA65. It is an extension of the 4510 CPU and adds 32-bit addressing and a 32-bit pseudo register Q that is comprised of the four registers A, X, Y, and Z.

HUC6280 mode (CMOS with Hudson extensions)
The HUC6280 is a superset of 65C02, used in the PC Engine.

M740 mode
The M740 is a microcontroller by Mitsubishi, which was marketed for embedded devices in the mid 80s. It is a superset of 6502, and a subset of 65SC02, plus some new instructions.

For more information about the M740 Controllers, see Wikipedia.

65816 mode
In 65816 mode, several aliases are accepted, in addition to the official mnemonics:


CPA is an alias for CMP
DEA is an alias for DEC A
INA is an alias for INC A
SWA is an alias for XBA
TAD is an alias for TCD
TAS is an alias for TCS
TDA is an alias for TDC
TSA is an alias for TSC
The MVN and MVP instructions accept two different argument forms. Either two bank bytes may be given with a # prefix, or two far addresses whose high byte will be used.


                mvn     #^src, #^dst       ; bank of src to bank of dst
                mvn     src, dst           ; bank of src to bank of dst
                mvp     #$12, #$78         ; bank $12 to $78
                mvp     $123456, $789ABC   ; bank $12 to $78
also see long_jsr_jmp_rts .SMART .A8 .A16 .I8 .I16

sweet16 mode
SWEET 16 is an interpreter for a pseudo 16 bit CPU written by Steve Wozniak for the Apple ][ machines. It is available in the Apple ][ ROM. ca65 can generate code for this pseudo CPU when switched into sweet16 mode. The following is special in sweet16 mode:


The '@' character denotes indirect addressing and is no longer available for cheap local labels. If you need cheap local labels, you will have to switch to another lead character using the .LOCALCHAR command.
Registers are specified using R0 .. R15. In sweet16 mode, these identifiers are reserved words.
Please note that the assembler does neither supply the interpreter needed for SWEET 16 code, nor the zero page locations needed for the SWEET 16 registers, nor does it call the interpreter. All this must be done by your program. Apple ][ programmers do probably know how to use sweet16 mode.

For more information about SWEET 16, see http://www.6502.org/source/interpreters/sweet16.htm.

4.2 Number format
For literal values, the assembler accepts the widely used number formats: A preceding '$' or a trailing 'h' denotes a hex value, a preceding '%' denotes a binary value, and a bare number is interpreted as a decimal. There are currently no octal values and no floats.

4.3 Conditional assembly
Please note that when using the conditional directives (.IF and friends), the input must consist of valid assembler tokens, even in .IF branches that are not assembled. The reason for this behaviour is that the assembler must still be able to detect the ending tokens (like .ENDIF), so conversion of the input stream into tokens still takes place. As a consequence conditional assembly directives may not be used to prevent normal text (used as a comment or similar) from being assembled.
