# C64 Zero Page - BASIC Pointers $03-$06


3-4           $3-$4          ADRAY1
Vector: Routine to Convert a Number from Floating Point to Signed
Integer

This vector points to the address of the BASIC routine which converts
a floating point number to an integer.  In the current Kernal version,
the address that it points to is 45482 ($B1AA).  Disassembly of the
ROMs indicates that BASIC does not use this vector.  However, it may
be of real assistance to the programmer who wishes to use data that is
stored in floating point format.  The parameter that is passed by the
USR command is available only in that format, for example.

Since it is extremely difficult to decipher and use a floating point
number, the simplest way to deal with such data is to use the
conversion routines that are built into BASIC to change it into a
two-byte signed integer.  This could be accomplished by jumping
directly into the BASIC ROM, if you know the location of the routine.
Therefore, if the address changes in future versions of the 64 or
future Commodore computers, you won't have to modify your program to
make it work with them.

See the entry for the USR vector at 785 ($311) for an explanation of
how to use this routine in connection with the USR command.

5-6           $5-$6          ADRAY2
Vector: Routine to Convert a Number from Integer to Floating Point

This vector points to the address of the BASIC routine which converts
an integer to a floating point number.  This routine is currently
located at 45969 ($B391).  BASIC does not appear to reference this
location.  It is available for use by the programmer who needs to make
such a conversion for a machine language program that interacts with
BASIC.  For an explanation of how to use this routine in connection
with the USR command, see the entry for the USR vector at 785 ($311).

7             $7             CHARAC
Search Character for Scanning BASIC Text Input

This location and the next are used heavily by the BASIC routines that
scan the text that comes into the buffer at 512 ($200), in order to
detect significant characters such as quotes, comma, the colon which
separates BASIC statements, and end-of-line.  The ASCII values of such
special characters are usually stored here.

This location is also used as a work area by other BASIC routines that
do not involve scanning text.

8             $8             ENDCHR
Search Character for Statement Termination or Quote

Like location 7, this location is used as a work byte during the
tokenization of a BASIC statement.  Most of the time, its value is 0
or 34.

9             $9             TRMPOS
Column position of the Cursor before the Last TAB or SPC

TRMPOS is used by TAB and SPC.  The cursor column position prior to
the TAB or SPC is moved here from 211 ($D3), and is used to calculate
where the cursor ends up after one of these functions is invoked.
Note that the value contained here shows the position of the cursor on
a logical line.  Since one logical line can be up to two physical
lines long, the value stored here can range from 0 to 79.

10            $A             VERCK
Flag: LOAD or VERIFY

BASIC uses one Kernal routine to perform either the LOAD or VERIFY
function, depending on whether the Accumulator (.A) is set to 0 or 1
upon entry to the routine.  BASIC sets the value of VERCK to 0 for a
LOAD, or 1 for a VERIFY.  Its contents are passed to the Kernal LOAD
routine, which in turn stores it in location 147 ($93).

11            $B             COUNT
Index into the Text Input Buffer/Number of Array Subscripts

The routines that convert the text in the input buffer at 512 ($200)
into lines of executable program tokes, and the routines that link
these program lines together, use this location as an index into the
input buffer area.  When the job of converting text to tokens is
finished, the value in this location is equal to the length of the
tokenized line.

The routines which build an array or locate an element in an array use
this location to calculate the number of DIMensions called for and the
amount of storage required for a newly created array, or the number of
subscripts specified when referencing an array element.

12            $C             DIMFLG
Flags for the Routines That Locate or Build an Array

This location is used as a flag by the routines that build an array or
reference an existing array.  It is used to determine whether a
variable is in an array, whether the array has already been
DIMensioned, and whether a new array should assume the default
dimensions.

13            $D             VALTYP
Flag: Type of Data (String or Numeric)

This flag is used internally to indicate whether data being operated
upon is string or numeric.  A value of 255 ($FF) in this location
indicates string data, while a 0 indicates numeric data.  This
determination is made every time a variable is located or created.

14            $E             INTFLG
Flat: Type of Numeric Data (Integer or Floating Point)

If data which BASIC is using is determined to be numeric, it is
further classified here as either a floating point number or as an
integer.  A 128 ($80) in this location identifies the number as an
integer, and a 0 indicates a floating point number.

15            $F             GARBFL
Flag for LIST, Garbage Collection, and Program Tokenization

The LIST routine uses this byte as a flag to let it know when it has
come to a character string in quotes.  It will then print the string,
rather than search it for BASIC keyword tokens.

The garbage collection routine uses this location as a flag to
indicate that garbage collection has already been tried before adding
a new string.  If there is still not enough memory, an OUT OF MEMORY
message will result.

This location is also used as a work byte for the process of
converting a line of text in the BASIC input buffer (512, $200) into a
linked program line of BASIC keyword tokens.

16            $10            SUBFLG
Flag: Subscript Reference to an Array or User-Defined Function Call (FN)

This flag is used by the PTRGET routine which finds or creates a
variable, at the time it checks whether the name of a variable is
valid.  If an opening parenthesis is found, this flag is set to
indicate that the variable in question is either an array variable or
a user-defined function.

You should note that it is perfectly legal for a user-defined function
(FN) to have the same name as a floating point variable.  Moreover, it
is also legal to redefine a function.  Using a FN name in an already
defined function results in the new definition of the function.

17            $11            INPFLG
Flag: Is Data Input to GET, READ or INPUT?

Since the keywords GET, INPUT, and READ perform similar functions,
BASIC executes some of the same instructions for all three.  There are
also many areas of difference, however, and this flag indicates which
of the three keywords is currently being executed, so that BASIC will
know whether or not to execute the instructions which relate to the
areas in which the commands differ (152 ($98)=READ, 64 ($40)=GET,
0=INPUT).

As a result, INPUT will show the ? prompt, will echo characters back
to the screen, and will wait for a whole line of text ended by a
carriage return.  GET gives no prompt and accepts one character
without waiting.  The colon character and the comma are valid data for
GET, but are treated as delimiters between data by INPUT and READ.

As each command has its own error messages, this flag is used to
determine the appropriate message to issue in case of an error.

18            $12            TANSGN
Flag: Sign of the Result of the TAN or SIN Function

This location is used to determine whether the sign of the value
returned by the functions SIN or TAN is positive or negative.

Additionally, the string and numeric comparison routines use this
location to indicate the outcome of the comparison.  For a comparison
of variable A to variable B, the value here will be 1 if A is greater
than B, 2 if A equals B, and 4 if a is less than B.  If more than one
comparison operator was used to compare the two variables (e.g., >= or
<=), the value here will be a combination of the above values.

19            $13            CHANNL
Current I/O Channel (CMD Logical File) Number

Whenever BASIC inputs or outputs data, it looks here to determine
which I/O device is currently active for the purpose of prompting or
output control.  It uses location 184 ($B8) for purposes of deciding
what device actually to put input from or output to.

When the default input device (number 0, the keyboard) or output
device (number 3, the display screen) is used, the value here will be
a zero, and the format of prompting and output will be the standard
screen output format.

When another device is used, the logical file number (CMD channel
number) will be placed here.  This lets the system now that it may
have to make some subtle changes in the way it performs the I/O
operation.  For example, if TAB is used with the PRINT command, cursor
right characters are used if the device PRINTed to is the screen.
Otherwise, spaces are output when the number here is other than zero
(the assumption being that you can't tab a printer like you can the
screen).

Likewise, the ? prompt for INPUT is suppressed if the file number here
is nonzero, as is the EXTRA IGNORED message, and input of a carriage
return by itself is ignored, rather than being treated as a null
string ("").  Therefore, by OPENing the screen as a device, and
issuing the CMD statement, you can force the suppression of the ?
prompt, and the other effects above.

CMD places the new output file number here, and calls the Kernal to
open the device for output, leaving it LISTENing for output (such as
the READY prompt, which is diverted to the new device).

Many routines reset this location and UNLISTEN the device, defeating
the CMD and once again sending the output to the screen.  If an error
message has to be displayed, for example, this location will be reset
and the message will be displayed on the screen.  GET, GET#, INPUT,
INPUT#, and PRINT# all will reset this location after the I/O is
completed, effectively redirecting output back to the screen.  PRINT
and LIST are the only I/O operations that will not undo the CMD.

This location can also be used to fool BASIC into thinking that data
it is reading from the tape is actually being entered into the
keyboard in immediate mode.

For a look at a technique that uses a different approach to accomplish
the same thing for disk or tape users, see location 512 ($200), the
keyboard buffer.

20-21         $14-$15        LINNUM
Integer Line Number Value

The target line number for GOTO, LIST, ON, and GOSUB is stored here in
