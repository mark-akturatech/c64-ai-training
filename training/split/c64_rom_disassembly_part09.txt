# C64 BASIC ROM Disassembly $A900-$A9FF - IF, REM, ON, Variable Lookup

.,A91F F0 E4    BEQ $A905       exit if found
.,A921 C8       INY             else increment index
.,A922 C9 22    CMP #$22        compare current character with open quote
.,A924 D0 F3    BNE $A919       if found go swap search character for alternate search
                                character
.,A926 F0 E9    BEQ $A911       loop for next character, branch always

                                *** perform IF
.,A928 20 9E AD JSR $AD9E       evaluate expression
.,A92B 20 79 00 JSR $0079       scan memory
.,A92E C9 89    CMP #$89        compare with "GOTO" token
.,A930 F0 05    BEQ $A937       if it was  the token for GOTO go do IF ... GOTO
                                wasn't IF ... GOTO so must be IF ... THEN
.,A932 A9 A7    LDA #$A7        set "THEN" token
.,A934 20 FF AE JSR $AEFF       scan for CHR$(A), else do syntax error then warm start
.,A937 A5 61    LDA $61         get FAC1 exponent
.,A939 D0 05    BNE $A940       if result was non zero continue execution
                                else REM rest of line

                                *** perform REM
.,A93B 20 09 A9 JSR $A909       scan for next BASIC line
.,A93E F0 BB    BEQ $A8FB       add Y to the BASIC execute pointer and return, branch
                                always
                                result was non zero so do rest of line
.,A940 20 79 00 JSR $0079       scan memory
.,A943 B0 03    BCS $A948       branch if not numeric character, is variable or keyword
.,A945 4C A0 A8 JMP $A8A0       else perform GOTO n
                                is variable or keyword
.,A948 4C ED A7 JMP $A7ED       interpret BASIC code from BASIC execute pointer

                                *** perform ON
.,A94B 20 9E B7 JSR $B79E       get byte parameter
.,A94E 48       PHA             push next character
.,A94F C9 8D    CMP #$8D        compare with GOSUB token
.,A951 F0 04    BEQ $A957       if GOSUB go see if it should be executed
.,A953 C9 89    CMP #$89        compare with GOTO token
.,A955 D0 91    BNE $A8E8       if not GOTO do syntax error then warm start
                                next character was GOTO or GOSUB, see if it should be executed
.,A957 C6 65    DEC $65         decrement the byte value
.,A959 D0 04    BNE $A95F       if not zero go see if another line number exists
.,A95B 68       PLA             pull keyword token
.,A95C 4C EF A7 JMP $A7EF       go execute it
.,A95F 20 73 00 JSR $0073       increment and scan memory
.,A962 20 6B A9 JSR $A96B       get fixed-point number into temporary integer
                                skip this n
.,A965 C9 2C    CMP #$2C        compare next character with ","
.,A967 F0 EE    BEQ $A957       loop if ","
.,A969 68       PLA             else pull keyword token, ran out of options
.,A96A 60       RTS             

                                *** get fixed-point number into temporary integer
.,A96B A2 00    LDX #$00        clear X
.,A96D 86 14    STX $14         clear temporary integer low byte
.,A96F 86 15    STX $15         clear temporary integer high byte
.,A971 B0 F7    BCS $A96A       return if carry set, end of scan, character was not 0-9
.,A973 E9 2F    SBC #$2F        subtract $30, $2F+carry, from byte
.,A975 85 07    STA $07         store #
.,A977 A5 15    LDA $15         get temporary integer high byte
.,A979 85 22    STA $22         save it for now
.,A97B C9 19    CMP #$19        compare with $19
.,A97D B0 D4    BCS $A953       branch if >= this makes the maximum line number 63999
                                because the next bit does $1900 * $0A = $FA00 = 64000
                                decimal. the branch target is really the SYNTAX error
                                at $A8E8 but that is too far so an intermediate
                                compare and branch to that location is used. the problem
                                with this is that line number that gives a partial result
                                from $8900 to $89FF, 35072x to 35327x, will pass the new
                                target compare and will try to execute the remainder of
                                the ON n GOTO/GOSUB. a solution to this is to copy the
                                byte in A before the branch to X and then branch to
                                $A955 skipping the second compare
.,A97F A5 14    LDA $14         get temporary integer low byte
.,A981 0A       ASL             *2 low byte
.,A982 26 22    ROL $22         *2 high byte
.,A984 0A       ASL             *2 low byte
.,A985 26 22    ROL $22         *2 high byte (*4)
.,A987 65 14    ADC $14         + low byte (*5)
.,A989 85 14    STA $14         save it
.,A98B A5 22    LDA $22         get high byte temp
.,A98D 65 15    ADC $15         + high byte (*5)
.,A98F 85 15    STA $15         save it
.,A991 06 14    ASL $14         *2 low byte (*10d)
.,A993 26 15    ROL $15         *2 high byte (*10d)
.,A995 A5 14    LDA $14         get low byte
.,A997 65 07    ADC $07         add #
.,A999 85 14    STA $14         save low byte
.,A99B 90 02    BCC $A99F       branch if no overflow to high byte
.,A99D E6 15    INC $15         else increment high byte
.,A99F 20 73 00 JSR $0073       increment and scan memory
.,A9A2 4C 71 A9 JMP $A971       loop for next character

                                *** perform LET
.,A9A5 20 8B B0 JSR $B08B       get variable address
.,A9A8 85 49    STA $49         save variable address low byte
.,A9AA 84 4A    STY $4A         save variable address high byte
.,A9AC A9 B2    LDA #$B2        $B2 is "=" token
.,A9AE 20 FF AE JSR $AEFF       scan for CHR$(A), else do syntax error then warm start
.,A9B1 A5 0E    LDA $0E         get data type flag, $80 = integer, $00 = float
.,A9B3 48       PHA             push data type flag
.,A9B4 A5 0D    LDA $0D         get data type flag, $FF = string, $00 = numeric
.,A9B6 48       PHA             push data type flag
.,A9B7 20 9E AD JSR $AD9E       evaluate expression
.,A9BA 68       PLA             pop data type flag
.,A9BB 2A       ROL             string bit into carry
.,A9BC 20 90 AD JSR $AD90       do type match check
.,A9BF D0 18    BNE $A9D9       branch if string
.,A9C1 68       PLA             pop integer/float data type flag
                                assign value to numeric variable
.,A9C2 10 12    BPL $A9D6       branch if float
                                expression is numeric integer
.,A9C4 20 1B BC JSR $BC1B       round FAC1
.,A9C7 20 BF B1 JSR $B1BF       evaluate integer expression, no sign check
.,A9CA A0 00    LDY #$00        clear index
.,A9CC A5 64    LDA $64         get FAC1 mantissa 3
.,A9CE 91 49    STA ($49),Y     save as integer variable low byte
.,A9D0 C8       INY             increment index
.,A9D1 A5 65    LDA $65         get FAC1 mantissa 4
.,A9D3 91 49    STA ($49),Y     save as integer variable high byte
.,A9D5 60       RTS             
.,A9D6 4C D0 BB JMP $BBD0       pack FAC1 into variable pointer and return
                                assign value to numeric variable
.,A9D9 68       PLA             dump integer/float data type flag
.,A9DA A4 4A    LDY $4A         get variable pointer high byte
.,A9DC C0 BF    CPY #$BF        was it TI$ pointer
.,A9DE D0 4C    BNE $AA2C       branch if not
                                else it's TI$ = <expr$>
.,A9E0 20 A6 B6 JSR $B6A6       pop string off descriptor stack, or from top of string
                                space returns with A = length, X = pointer low byte,
                                Y = pointer high byte
.,A9E3 C9 06    CMP #$06        compare length with 6
.,A9E5 D0 3D    BNE $AA24       if length not 6 do illegal quantity error then warm start
.,A9E7 A0 00    LDY #$00        clear index
.,A9E9 84 61    STY $61         clear FAC1 exponent
.,A9EB 84 66    STY $66         clear FAC1 sign (b7)
.,A9ED 84 71    STY $71         save index
.,A9EF 20 1D AA JSR $AA1D       check and evaluate numeric digit
.,A9F2 20 E2 BA JSR $BAE2       multiply FAC1 by 10
.,A9F5 E6 71    INC $71         increment index
.,A9F7 A4 71    LDY $71         restore index
.,A9F9 20 1D AA JSR $AA1D       check and evaluate numeric digit
.,A9FC 20 0C BC JSR $BC0C       round and copy FAC1 to FAC2
.,A9FF AA       TAX             copy FAC1 exponent
