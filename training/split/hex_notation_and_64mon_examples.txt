# COMMODORE 64 - Hexadecimal (base 16) primer: digit symbols 0â€“F, conversion examples between decimal/hex/binary, positional notation, addresses up to $FFFF, use of $ prefix for hex, and examples of viewing memory and registers using 64MON (SYS, B*, .M and memory dump format). Encouragement to learn to think in hex.


  HEXADECIMAL NOTATION

  Hexadecimal notation is used by most machine language programmers when
  they talk about a number or address in a machine language program.
    Some assemblers let you refer to addresses and numbers in decimal
  (base 10), binary (base 2), or even octal (base 8) as well as hexadecimal



                                            BASIC TO MACHINE LANGUAGE   215
~


  (base 16) (or just "hex" as most people say). These assemblers do the
  conversions for you.
    Hexadecimal probably seems a little hard to grasp at first, but like
  most things, it won't take long to master with practice.
    By looking at decimal (base 10) numbers, you can see that each digit
  fails somewhere in the range between zero and a number equal to the base
  less one (e.g., 9). THIS IS TRUE OF ALL NUMBER BASES. Binary (base 2)
  numbers have digits ranging from zero to one (which is one less than the
  base). Similarly, hexadecimal numbers should have digits ranging from
  zero to fifteen, but we do not have any single digit figures for the
  numbers ten to fifteen, so the first six letters of the alphabet are used
  instead:


                    +---------+-------------+----------+
                    | DECIMAL | HEXADECIMAL |  BINARY  |
                    +---------+-------------+----------+
                    |    0    |      0      | 00000000 |
                    |    1    |      1      | 00000001 |
                    |    2    |      2      | 00000010 |
                    |    3    |      3      | 00000011 |
                    |    4    |      4      | 00000100 |
                    |    5    |      5      | 00000101 |
                    |    6    |      6      | 00000110 |
                    |    7    |      7      | 00000111 |
                    |    8    |      8      | 00001000 |
                    |    9    |      9      | 00001001 |
                    |   10    |      A      | 00001010 |
                    |   11    |      B      | 00001011 |
                    |   12    |      C      | 00001100 |
                    |   13    |      D      | 00001101 |
                    |   14    |      E      | 00001110 |
                    |   15    |      F      | 00001111 |
                    |   16    |     10      | 00010000 |
                    +---------+-------------+----------+








  216   BASIC TO MACHINE LANGUAGE
~


    Let's look at it another way; here's an example of how a base 10
  (decimal number) is constructed:

    Base raised by
    increasing powers:... 10^3 10^2 10^1 10^0
                         ---------------------
    Equals:.............. 1000  100   10    1
                         ---------------------

    Consider 4569 (base 10)  4    5    6    9 = (4*1000)+(5*100)+(6*10)+9

  Now look at an example of how a base 16 (hexadecimal number) is
  constructed:

    Base raised by
    increasing powers:... 16^3 16^2 16^1 16^0
                         ---------------------
    Equals:.............. 4096  256   16    1
                         ---------------------

    Consider 11D9 (base 16)  1    1    D    9 = 1*4096+1*256+13*16+9

  Therefore, 4569 (base 10) = 11D9 (base 16)
    The range for addressable memory locations is 0-65535 (as was stated
  earlier). This range is therefore 0-FFFF in hexadecimal notation.
    Usually hexadecimal numbers are prefixed with a dollar sign ($). This
  is to distinguish them from decimal numbers. Let's look at some "hex"
  numbers, using 64MON, by displaying the contents of some memory by
  typing:

    SYS 8*4096   (or SYS 12*4096)
    B*
       PC  SR AC XR YR SP
    .;0401 32 04 5E 00 F6 (these may be different)

  Then if you type in:

  .M 0000 0020 (and press <RETURN>).

  you will see rows of 9 hex numbers. The first 4-digit number is the ad-
  dress of the first byte of memory being shown in that row, and the other
  eight numbers are the actual contents of the memory locations beginning
  at that start address.
                                            BASIC TO MACHINE LANGUAGE   217
~


    You should really try to learn to "think" in hexadecimal. It's not too
  difficult, because you don't have to think about converting it back into
  decimal. For example, if you said that a particular value is stored at
  $14ED instead of 5357, it shouldn't make any difference.



---
Additional information can be found by searching:
- "writing_machine_language_and_assemblers" which expands on Assemblers display and accept hex addresses and values
- "lda_immediate_absolute_and_address_representation" which expands on How hex is used to represent instruction tokens and operands
