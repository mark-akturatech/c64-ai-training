# C64 Kernal ROM - Keyboard Handler

output to the screen device.  It takes an ASCII character number, and
tests if the character is printable.  If it is, it prints it (taking
into consideration the reverse flag, if any inserts are left, etc.).
If it is a nonprinting character, the routine performs the appropriate
cursor movement, color change, screen clearing, or whatever else might
be indicated.

59516         $E87C
Move Cursor to Next Line

This subroutine moves the cursor down to the next line if possible, or
scrolls the screen if the cursor is on the last line.

59537         $E891
Output a Carriage Return

A carriage return is performed by clearing insert mode, reverse video,
and quote mode, and moving the cursor to the next line.

59553         $E8A1
If at the Beginning of a Screen Line, Move Cursor to Previous Line

59571         $E8B3
If at the End of a Screen Line, Move Cursor to the Next Line

59595         $E8CB
Check for a Color Change

This routine is used by the screen CHROUT routine to check if the
character to be printed is one that causes the current foreground
color to change (such as the CTRL-1 combination).

59601         $E8D1
PETASCII Color Code Equivalent Table

This table gives the PETASCII values of the color change characters
for each of the 16 possible colors.  These values are:

144 ($90)  Change to color 0 (black)
  5 ($05)  Change to color 0 (white)
 28 ($1C)  Change to color 0 (red)
159 ($9F)  Change to color 0 (cyan)
156 ($9C)  Change to color 0 (purple)
 30 ($1E)  Change to color 0 (green)
 31 ($1F)  Change to color 0 (blue)
158 ($9E)  Change to color 0 (yellow)
129 ($81)  Change to color 0 (orange)
149 ($95)  Change to color 0 (brown)
150 ($96)  Change to color 0 (light red)
151 ($97)  Change to color 0 (dark gray)
152 ($98)  Change to color 0 (medium gray)
153 ($99)  Change to color 0 (light green)
154 ($9A)  Change to color 0 (light blue)
155 ($9B)  Change to color 0 (light gray)

59626         $E8EA
Scroll Screen

This subroutine moves all of the screen lines up, so that a blank line
is created at the bottom of the screen and the top screen line is
lost.  If the top logical line is two physical lines long, all lines
are moved up two lines.  Holding down the CTRL key will cause a brief
pause after the scroll.

59749         $E965
Insert a Blank Line on the Screen

This subroutine is used when INSERTing to add a blank physical line to
a logical line.

59848         $E9C8
Move Screen Line

This subroutine is used by the scroll routine to move one screen line
(and its associated Color RAM) up a line.

59872         $E9E0
Set Temporary Color Pointer for Scrolling

This subrouting sets up a pointer in 17-175 ($AE-$AF) to the Color RAM
address that corresponds to the temporary screen line address in
172-173 ($AC-$AD).

59888         $E9F0
Set Pointer to Screen Address of Start of Line

This subroutine puts the address of the first byte of the screen line
designated by the .X register into locations 209-210 ($D1-$D2).

59903         $E9FF
Clear Screen Line

This subroutine writes space characters to an entire line of screen
memory, and clears the corresponding line of color memory to color in
Background Color Register 0 (53281, $D021).

59923         $EA13
Set Cursor Blink Timing and Color Memory Address for Print to Screen

This subroutine sets the cursor blink countdown and sets the pointer
to Color RAM.  It then falls through to the next routine.

59932         $EA1C
Store to Screen

This routine stores the character in the .A register to the screen
address pointed to by 209 ($D1), and stores the color in the .X
register to the address pointed to by 243 ($F3).

59940         $EA24
Synchronize Color RAM Pointer to Screen Line Pointer

This subroutine sets the pointer at 243 ($F3) to the address of the
beginning of the line of Color RAM which corresponds to the current
line of screen RAM (whose pointer is at 209 ($D1)).

59953         $EA31
IRQ Interrupt Entry

This is the entry point to the standard IRQ interrupt handler.  Timer
A of CIA #1 is set at power-on to cause an IRQ interrupt to occur
every 1/60 second.  When the interrupt occurs, program flow is
transferred here via the CINV vector at 788 ($314).  This routine
updates the software clock at 160-162 ($A0-$A2), handles the cursor
flash, and maintains the tape interlock which keeps the cassette motor
on if a button is pushed and the interlock flag is on.  Finally, it
calls the keyboard scan routine, which checks the keyboard and puts
any character it finds into the keyboard buffer.

60039         $EA87          SCNKEY
Read the Keyboard

This subroutine is called by the IRQ interrupt handler above to read
the keyboard device which is connected to CIA #1 (see entry for 56320
($DC00) for details on how to read the keyboard).

It is the Kernal routine SCNKEY which can be entered from the jump
table at 65439 ($FF9F).  This routine returns the keycode of the key
currently being pressed in 203 ($CB), sets the shift/control flag if
appropriate, and jumps through the vector at 655 ($28F) to the routine
that sets up the proper table to translate the keycode to PETASCII.
It concludes with the next routine, which places the PETASCII value of
the character in the keyboard buffer.

60128         $EAE0
Decode the Keystroke and Place its ASCII Value in the Keyboard Buffer

This is the continuation of the IRQ keyscan routine.  It decodes the
keycode with the proper PETASCII table, and compares it with the last
keystroke.  If if is the same, it checks to see if it is okay to
repeat the character without waiting for the key to be let up.  If the
character should be printed, it is moved to the end of the keyboard
buffer at 631 ($277).

60232         $Eb48
Set Up the Proper Keyboard Decode Table

This routine is pointed to by the vector at 655 ($28F).  Its function
is to read the shift/control flag at 653 ($28D), and set the value of
the decode table pointer at 245 ($F5) accordingly.

First it checks if the SHIFT/Commodore logo combination was pressed,
and if the toggle enable at 657 (291) will allow a change, the
character set will be changed to lowercase/uppercase or
uppercase/graphics by changing the VIC Memory Control Register at
53272 ($D018), and no character will be printed.

Next it sets the decode table pointer.  There are 64 keys, and each
can have four different PETASCII values, depending on whether the key
is pressed by itself, or in combination with the SHIFT, CTRL, or
Commodore logo keys.  Therefore, there are four tables of 64 entries
each to translate the keycode to PETASCII:  the standard table, the
SHIFT table, the Commodore logo table, and the CONTROL table.  The
routine will set up the pointer for the appropriate table, depending
on whether the SHIFT, CTRL, or logo key was pressed.  The CTRL key
takes precedence, so that if another of these keys is pressed along
with the CTRL key, the CONTROL table is used.

60281         $EB79
Keyboard Decode Table Vectors

This table contains the two-byte addresses of the four keyboard decode
tables in low-byte, high-byte format.

60289         $EB81
Standard Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the standard keyboard,
one for each key which is struck by itself.  The table is in keycode
order (see the keycode table in Appendix H for the correspondence of
keycode to key).  A 65th byte with the value of 255 ($FF) marks the
end of the table (this corresponds to a keypress value of 64, no key
pressed).

60354         $EBC2
SHIFTed Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the shifted keyboard,
one for each key which is struck while the SHIFT key is pressed.  The
table is in keycode order (see the keycode table in Appendix H for the
correspondence of keycode to key).  A 65th byte with the value of 255
($FF) marks the end of the table (this corresponds to a keypress value
of 64, no key pressed).

60419         $EC03
Commodore Logo Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the logo keyboard, one
for each key which is struck while the Commodore logo key is pressed.
The table is in keycode order (see the keycode table in Appendix H for
the correspondence of keycode to key).  A 65th byte with the value of
255 ($FF) marks the end of the table (this corresponds to a keypress
value of 64, no key pressed).

60484         $EC44
Set Lowercase/Uppercase or Uppercase/Graphics Character Set

The part of the Kernal CHROUT routine that outputs to the screen uses
this subroutine to check for the special nonprinting characters that
switch the character set (CHR$(14) and CHR$(142)).  If one of these is
the character to be printed, this routine makes the switch by setting
the location 53272 ($D018) accordingly.

60510         $EC5E
Set Flag to Enable or Disable Switching Character Sets

This subroutine is also used to check for special characters to print.
In this case, it checks for the characters that enable or disable the
SHIFT/logo combination from toggling the character set currently in
use (CHR$(8) and CHR$(9)).  If one of these is to be printed, the flag
at 657 ($291) is changed.

60536         $EC78
Control Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the Control keyboard,
one for each key which is struck while the CTRL key is pressed.  The
table is in keycode order (see the keycode table in Appendix H for the
correspondence of keycode to key).  A 65th byte with the value of 255
($FF) marks the end of the table (this corresponds to a keypress value
of 64, no key pressed).

The only keys generally struck in combination with the CTRL key are
the ones that change the colors on the top row of the keyboard, but
this doesn't necessarily mean that the other CTRL key combinations
don't do anything.  On the contrary, looking at the values in this
table, you can see that any of the first 32 values in the PETASCII
table can be produced by some combination of the CTRL key and another
key.  CTRL-@ produces a CHR$(0).  CTRL-A through CTRL-Z produce
CHR$(1) through CHR$(26).  Ctrl-: is the same as CHR$(27), CTRL-Lira
(that's the slashed-L British pound sign) produces CHR$(28), CTRL-;
equals CHR$(29), CTRL-up arrow produces CHR$(30), and CTRL-= produces
CHR$(31).

Any of these combinations produce the same effect as the CHR$(X)
statement.  For examble, CTRL-; moves the cursor over to the right,
CTRL-N switches to lowercase, CTRL-R turns on reverse video, and
CTRL-E changes the printing to white.

60601         $ECB9
Video Chip Register Default Table

This table contains the default values that are stored in the 47
VIC-II chip registers.  It is interesting to note that this table
appears to be incomplete.  While Sprite Color Registers 0-6 are
initialized to values of 1-7, Sprite Color Register 7 is initialized
to 76--the ASCII value of the letter L which begins on the next table.

60647         $ECE7
Text for Keyboard Buffer When SHIFT/RUN is Pressed

When the SHIFT and RUN keys are pressed, the ASCII text stored here is
forced into the keyboard buffer.  That text is LOAD, carriage return,
RUN, carriage return.

60656         $ECF0
Low Byte Table of Screen Line Addresses

This table holds the low byte of the screen address for lines 0-24.
The high byte is derived from combining a value from the screen line
link table at 217 ($D9) with the pointer to screen memory at 648
($288).

60681         $ED09          TALK
Send TALK to a Device on the Serial Bus

This is a documented Kernal routine whose entry in the jump table is
65460 ($FFB4).  When called, it ORs the device number in the
Accumulator with the TALK code (64, $40) and sends it on the serial
bus.  This commands the device to TALK.

60684         $ED0C          LISTEN

This is a documented Kernal routine whose entry in the jump table is
65457 ($FFB1).  When called, it ORs the device number in the
Accumulator with the LISTEN code (32, $20) and sends it on the serial
bus.  This commands the device to LISTEN.

60689         $ED11
Send Command Code to a Device on the Serial Bus
