# KickAssembler - Name Spaces and File Namespaces

             sta screen+$300,x
             inx
             bne Loop
   }
Notice that it is ok to use the macro before it is declared.
Macros are good for building libraries. In my standard library I have macros for moving and filling
memory, setting up char matrixes, declaring basic upstart programs, etc†. They are also good for
doing things like double buffering. Typically you have a routine you want to work on two buffers,
but making it take the buffer as an argument would slow it down. Instead you define the routine in
a macro, which takes a buffer as an argument and then call the macro with each buffer. This saves
you the trouble of maintaining two identical routines only differing by the buffer they use.
†
  The library isn’t included in the assembler.
                                                                                                   33
7.2 Functions
 You can also define you own functions. Here is an example of a function:
  .function area(width,height) {
            .return width*height
  }
  lda #10+area(4,8)
You can use your own functions like you would use any of the library functions described earlier.
Functions consist of non-byte generating directives like .eval, .for, .var, and .if. When the assembler
evaluates the .return directives it returns the value given by the proceeding expression. If no
expression is given, or if no .return directive is reached, a null value is returned. Here are some
more examples of functions:
  // Returns a string telling if a number is odd or even
  .function oddEven(number) {
            .if ([number&1] == 0 ) .return "even"
            else .return "odd"
  }
  // Empty function – always returns null
  .function emptyFunction() {
  }
As macros, functions can have side effects as shown in the following function that returns no result
(null), but modifies its list argument.
  // Inserts null in all elements of a list
  .function clearList(list) {
            // Return if the list is null
            .if (list==null) .return
            .for(var i=0; i<list.size(); i++) {
                list.set(i,null)
            }
  }
With functions you can calculate data for your programs. Instead of using other programming
languages like C or Java you can code your data generators directly in Kick Assembler. Put your
data in a list and use the list to generate your speed code or your .byte tables. This eases the
development process by making it more integrated.
                                                                                                    34
7.3 Pseudo Commands
Pseudo commands are a special kind of macros that takes command arguments, like #20, table,y or
($30),y as arguments just like mnemonics do. With these you can make your own extended
commands. Here is an example of a mov command that moves a byte from one place to another:
   .pseudocommand mov src;tar {
           lda src
           sta tar
   }
You use the mov command like this:
   :mov #10 ; $1000                      // Sets $1000 to 10 (lda #10, sta $1000)
   :mov source ; target                  // target = source       (lda source, sta target)
   :mov source,x ; target,y              // (lda source,x , sta target,y)
   :mov #20 ; ($30),y                    // (lda #20, sta ($30),y )
The arguments to a pseudo command are separated by semicolon and you can use any argument
you would give to a mnemonic.
The command arguments are passed to the pseudo command as CmdValues. These are values that
contain an argument type and a number value. You access these by their getter functions. Here is a
table of the functions:
Function      Description                                     Example
getType()     Returns a type constant (See the table below    #20 will return
              for possibilities)                              AT_IMMEDIATE
getValue() Returns the value                                  #20 will return 20
The argument type constants are the following:
Constant                          Example
AT_ABSOLUTE                       $1000
AT_ABSOLUTEX                      $1000,x
AT_ABSOLUTEY                      $1000,y
AT_IMMEDIATE                      #10
AT_INDIRECT                       ($1000)
AT_IZEROPAGEX                     ($10,x)
AT_IZEROPAGEY                     ($10),y
AT_NONE
Some addressing modes, like absolute zeropage and relative, are missing from the above table. This
is because the assembler automatically detect when these should be used from the corresponding
absolute mode.
You can construct new command arguments with the CmdArgument function. If you want to
construct a new immediate argument with the value 100, you do it like this:
                                                                                                 35
  .var myArgument = CmdArgument(AT_IMMEDIATE, 100)
  lda myArgument         // Gives lda #100
Now let’s use the above functionalities to define a 16 bit instruction set. We start by defining a
function that given the first argument will return the next in a 16 bit instruction.
  .function _16bit_nextArgument(arg) {
           .if (arg.getType()==AT_IMMEDIATE)
                             .return CmdArgument(arg.getType(),>arg.getValue())
           .return CmdArgument(arg.getType(),arg.getValue()+1)
  }
We always return an argument of the same type as the original. If it’s an immediate argument we
set the value to be the high byte of the original value, otherwise we just increment it by 1. This will
supply the correct argument for the ABSOLUTE, ABSOLUTEX, ABSOLUTEY and
IMMEDIATE addressing modes. With this we can easily define some 16 bits commands:
  .pseudocommand inc16 arg {
           inc arg
           bne over
           inc _16bit_nextArgument(arg)
  over:
  }
  .pseudocommand mov16 src;tar {
           lda src
           sta tar
           lda _16bit_nextArgument(src)
           sta _16bit_nextArgument(tar)
  }
  .pseudocommand add16 arg1 ; arg2 ; tar {
           .if (tar.getType()==AT_NONE) .eval tar=arg1
           lda arg1
           adc arg2
           sta tar
           lda _16bit_nextArgument(arg1)
           adc _16bit_nextArgument(arg2)
           sta _16bit_nextArgument(tar)
  }
You can use these like this:
  :inc16 counter
  :mov16 #irq1; $0314
  :mov16 #startAddress; $30
  :add16 $30; #128
  :add16 $30; #$1000; $32
Note how the target argument of the add16 command can be left out. When this is the case an
argument with type AT_NONE is passed to the pseudo command and the first argument is then
used as target.
With the pseudo command directive you can define your own extended instruction libraries, which
speed up some of the more trivial tasks of programming.
                                                                                                    36
8 Name Spaces
Namespaces are named scopes. When you enclose code in a scope, you hide information about the
