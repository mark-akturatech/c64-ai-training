# 6502 Instruction Set - Detailed explanation of jump vectors and stack operations: stack layout at $0100-$01FF, NMI/RES/IRQ vectors at $FFFA..$FFFF, and the sequence for handling interrupts (complete current instruction, push PC hi/lo and SR, jump to vector). ASCII-style diagrams showing stack memory layout before/after IRQ/NMI and JSR/RTS examples and how PC and SR are stored. Notes on subtle interrupt timing (branches and extra cycles) and NMOS peculiarities where NMI occurring at BRK may hijack BRK vector. W65C02 clears D flag on interrupts.

            LDA $1001     ;load high byte of first argument
            ADC $1003     ;add high byte of second argument
            STA $1005     ;store high byte of result (result in $1004 and $1005)
          and, conversely, for a 16-bit subtraction:
            SEC           ;prepare carry for subtraction
            LDA $1000     ;load value at address $1000 into A (low byte of first argument)
            SBC $1002     ;subtract low byte of second argument at $1002
            STA $1004     ;store low byte of result at $1004
            LDA $1001     ;load high byte of first argument
            SBC $1003     ;subtract high byte of second argument
            STA $1005     ;store high byte of result (result in $1004 and $1005)
          Note: Another, important preparatory step is to set the processor into binary
            mode by use of the CLD (CLear Decimal flag) instruction. (Compare the section
            on decimal mode below.) This has to be done only once.
          Signed Values
          Operations for unsigned and signed values are principally the same, the only
          difference being in how we interpret the values. Generally, the 6502 uses what
          is known as two's complement to represent negative values.
          (In earlier computers,something known as ones' complement was used, where we
          simply flip all bits to their opposite state to represent a negative value.
          While simple, this came with a few drawbacks, like an additional value of
          negative zero, which are overcome by two's complement.)
          In two's complement representation, we simply flip all the bits in a byte to
          their opposite (the same as an XOR by $FF) and then add 1 to this.
          E.g., to represent -4:,
          (We here use "$" to indicate a hexadecimal number and "%" for binary notation.
          A dot is used to separate the high- and low-nibble, i.e. group of 4 bits.)
                %0000.0100      4
            XOR %1111.1111    255
            -------------
                %1111.1011    complement (all bits flipped)
             +            1
            -------------
                %1111.1100     -4, two's complement
          Thus, in a single byte, we may represent values in the range
                                                                       6502 Instruction Set
            from   -128   (%1000.0000 or $80)
            to     +127   (%0111.1111 or $7F)
          A notable feature is that the highest value bit (first bit from the left) will
          always be 1 for a negative value and always be 0 for a positive one, for which
          it is also known as the sign bit. Whenever we interpret a value as a signed
          number, a set sign bit indicates a negative value.
          This works just the same for larger values, e.g., for a signed 16-bit value:
            -512   =  %1111.1110.0000.0000     =   $FE $00
            -516   =  %1111.1101.1111.1100     =   $FD $FC (mind how the +1 step carries over)
          Notably, the binary operations are still the same as with unsigned values and
          provide the expected results:
               dec      binary     hex
               100   %0110.0100    $64
            + -24    %1110.1000    $E8
            ------------------------
                76   %0100.1100    $4C   (+ carry)
          Note: We may now see how SBC actually works, by adding ones' complement of
            the operand to the accumulator. If we add 1 from the carry to the result,
            this effectively results in a subtraction in two's complement (the inverse
            of the operand + 1). If the carry happens to be zero, the result falls
            short by 1 in terms of two's complement, which is equivalent to adding 1
            to the operand before the subtraction. Thus, the carry either provides
            the correction required for a valid two's complement representation or,
            if missing, results in a subtraction including a binary borrow.

---
Additional information can be found by searching:
- "interrupts_and_vectors" which expands on interrupt vector addresses and hardware semantics
- "break_flag_and_stack_examples" which expands on how break flag behaves in PHP/PLP and BRK/RTI sequences
