# ML for C64 - Appendix A: Instruction Details (ADC-DEY)

you think that this feature is done with a SYS command, a wedge, or an
interrupt technique?  Why?

A SYS command from BASIC is like a subroutine call; so it must place an
address on the stack to allow RTS to return to BASIC.  Take a look at the
stack and see if you can determine what address is used to return to BASIC on
your machine.

                                                                        :129:
                                                                        :130:
                                                                        :131:



                                                          Chapter 8

                                                            Timing,
                                                      Input/Output,
                                                                and
                                                         Conclusion


          This chapter discusses:

            o How to estimate the speed of your program

            o Input and output from tape, disk, and printer

            o Review of instructions

            o Debugging

            o Symbolic assemblers

            o Where to go from here


                                                                        :132:

Timing
------

For many applications, machine language programs seem to run instantaneously.
The speed of the 650x is much greater than that of other devices, including
the human user.  The machine language program usually ends up waiting for
something:  waiting for the keyboard, waiting for the printer, waiting for
the disk, or waiting for the human to read and react to the information
presented on the screen.

Occasionally, it may be important to get fairly precise timing for a machine
language program.  If so, the following rules of thumb may be kept in mind:

  - All timing estimates are crude if the interrupt routines are still
    active.  The effect of interrupt on timing can be crudely estimated by
    adding 10 percent to the running time.

  - Remember to allow for loops.  If an instruction within a loop is repeated
    ten times, its timing will need to be counted ten times.

  - The "clock speed," or memory cycle speed, of most Commodore machines is
    roughly 1 microsecond--one millionth of a second.  The precise number
    varies from one machine to another, and also varies between North America
    and other regions.

  - Most instructions run at the fastest imaginable speed.  Count the memory
    cycles, and that's how fast the instruction will execute.  For example,
    LDA #$0D will need two memory cycles just to get the instruction--and
    that's how fast it runs.  LDA $0500,X will usually take four memory
    cycles:  three to get the instruction, and one to fetch the data from page
    5.  Exceptions:  no instruction runs in less than two cycles; and shift/
    rotate instructions, INC/DEC, and JSR/RTS take longer than you might
    expect by this rule.

  - Branches time differently, depending on whether the branch is taken
    (three cycles) or not taken (two cycles).

  - When a page boundary is crossed, the computer needs an extra cycle to do
    the arithmetic.  If the program branches from $0FE4 to $1023, there will
    be an extra cycle; if we LDA $24E7,Y, there will be an extra cycle if Y
    contains a value of $19 or greater.

Detailed timing values can be obtained from most tables of instructions.

Let's take a simple routine and estimate its timing.  The following program
logically ANDs the contents of 100 locations from $17E0 to $1844:

  033C  LDX #$00
  033E  LDA #$00
  0340  AND $17E0,X
  0343  INX
  0345  CPX #$64
  0347  BCC $0340
  0349  RTS

                                                                        :133:

We may work out timing as follows:

  LDX #$00--executed once:               2

  LDA #$00--executed once:               2

  AND $17E0,X:  32 times at 4 cycles:  128
    68 times at 5 cycles (page cross): 340

  INX--100 times at 2 cycles:          200

  CPX #$64--100 times at 2 cycles:     200

  BCC--99 times at 3 cycles:           297
    1 time at 2 cycles (no branch):      2

  RTS--6 cycles:                         6

Total time:  1171 cycles, or slightly over one thousandth of a second.  We
might add 10 percent to allow for the effects of interrupt; and since this is
a subroutine, we could also add the extra six cycles needed to perform the
JSR.

Where timing is critical, the interrupt could be locked out with SEI.  Be
careful; it's seldom necessary, and is potentially dangerous.


Input and Output
----------------

We know that calling the kernal routine CHROUT at $FFD2 will send an ASCII
character to the screen.  We may also redirect output to any logical file.

We have seen that we may obtain input from the keyboard buffer into the A
register by calling kernal routine GETIN at $FFE4.  We may also redirect the
input so that we draw information from any logical file.

The same commands--$FFD2 and $FFE4--still perform the input and output.  But
we "switch" either of them to connect to a chosen device--or more accurately,
a chosen logical file.  The file must be open; we may switch to the file, and
then switch back to normal I/O as we wish.


Switching Output
----------------

We use subroutine CHKOUT at address $FFC9 to switch output to a logical file.
When we want to restore output to the screen, we call subroutine CLRCHN at
$FFCC.  This is not the same as an OPEN and CLOSE--we simply connect to the
file and disconnect, and we can do this as many times as we want.

                                                                        :134:


  KEYBOARD                +---------+                  ,------.
   +----+         INPUT   |         |   OUTPUT         |      |
   |::::|-o<--O-----------| PROGRAM |------------O-->o-|SCREEN|
   +----+                 |         |                  |      |
           o              +---------+               o  `------'
          /  o                                    o  \
         |  /   CHKIN ($FFC6)     CHKOUT ($FFC9)   \  |
         | |    SETS THE INPUT   SETS THE OUTPUT    | |
        INPUT   SWITCH                    SWITCH  OUTPUT
       DEVICES                                    DEVICES
                        CLRCHN ($FFCC)
                         RESTORES BOTH
                     SWITCHES TO "NORMAL"

  Figure 8.1


*---------------------------------------------------------------------------*
|                                                                           |
| Subroutine:   CHKOUT                                                      |
| Address:      $FFC9                                                       |
| Action:       Switches the output path (used by CHROUT, $FFD2) so that    |
|               output is directed to the logical file specified in the X   |
|               register.  The logical file must previously have been       |
|               opened.                                                     |
|                                                                           |
| The character subsequently sent by $FFD2 is usually ASCII (or PET ASCII). |
| When sent to the printer, special characters--text/graphics, width--will  |
| be honored in the usual way.  Similarly, disk commands can be transmitted |
| over secondary address 15 if desired; a logical "command channel" file    |
| must be previously opened.                                                |
|                                                                           |
| Registers:  Registers A and X will be changed during the CHKOUT call.  Be |
| sure to save any sensitive data in these registers before calling CHKOUT. |
|                                                                           |
| Status:  Status flags may be changed.  In VIC and Commodore 64, the C     |
| (carry) flag indicates some type of problem with connecting to the output |
| channel.                                                                  |
|                                                                           |
*---------------------------------------------------------------------------*

                                                                        :135:

To switch output to logical file 1, we would need to follow these steps:

  1.  Load a value of 1 into X (LDX #$01).

  2.  JSR to address $FFC9.

Once the output is switched, we may send as many characters as we wish using
subroutine $FFD2.  Eventually, we must disconnect from the logical file and
return to our default output, the screen.  We do this by calling subroutine
CLRCHN at address $FFCC.

*---------------------------------------------------------------------------*
|                                                                           |
| Subroutine:   CLRCHN                                                      |
| Address:      $FFCC                                                       |
| Action:       Disconnects input and output from any logical files and     |
|               restores them to the "default" input and output channels,   |
|               keyboard and screen.  The logical files are not closed, and |
|               may be reconnected at a later time.                         |
|                                                                           |
| Registers:  Registers A and X will be changed during the CLRCHN call.  Be |
| sure to save any sensitive data in these registers.                       |
|                                                                           |
| Status:  Status flags may be changed.  In VIC and Commodore 64, the C     |
| (carry) flag indicates some type of problem with output                   |
|                                                                           |
*---------------------------------------------------------------------------*

The logical file concept is important.  I may send to any destination--
cassette, printer, disk, or screen--without knowing which device is involved.
I send the characters on their way and the operating system sees that they
are delivered wherever they need to go.

This simplifies the machine language programmer's job.  It's a simple task to
send the characters to some logical channel; the programmer does not need to
take special coding action depending on which device is involved.


Output Example
--------------

If we wanted to print the message HI on the printer, we might code as
follows.

First, we'll open the printer channel in BASIC.  Let's use logical file
number 1:

  100 OPEN 1,4
  110 SYS 828
  120 CLOSE 1

If you don't have a printer, you may open the file to cassette (OPEN 1,1,2)
or to disk (OPEN 1,8,3,"0:DEMO,S,W").  The machine language program won't
care:  it will sent to logical file number 1 no matter what it is; it might
even be the screen (OPEN 1,3).  Let's write the coding:

                                                                        :136:

  .A 033C  LDX #$01
  .A 033E  JSR $FFC9

Now the output is connected to logical file 1.  Let's say HI:

  .A 0341  LDA #$48
  .A 0343  JSR $FFD2
  .A 0346  LDA #$49
  .A 0348  JSR $FFD2
  .A 034B  LDA #$0D
  .A 034D  JSR $FFD2
  .A 0350  JSR $FFCC
  .A 0353  RTS

Don't forget to send the RETURN--the printer needs it.  After the machine
language program says HI, the program will return to BASIC and close the
file.  Notice that the machine language program doesn't care what it's saying
HI to...it sends the data to logical file 1.


Switching Input
---------------

We use subroutine CHKIN at address $FFC6 to switch input so as to draw data
from a logical file.  When we want to restore input from the keyboard, we
call subroutine CLRCHN at $FFCC.  Again, this is not the same as OPEN and
CLOSE--we simply connect the file and disconnect, and we can do this as many
times as we want.

*---------------------------------------------------------------------------*
|                                                                           |
| Subroutine:   CHKIN                                                       |
| Address:      $FFC6                                                       |
| Action:       Switches the input path (used by GETIN, $FFE4) so that      |
|               input is taken from the logical file specified in the X     |
|               register.  The logical file must previously have been       |
|               opened.                                                     |
|                                                                           |
| The character subsequently obtained by $FFE4 into the A register is       |
| usually ASCII (or PET ASCII).  A binary zero received from a file usually |
| represents exactly that:  an input character whose value is CHR$(0); this |
| is different from keyboard GETIN where a binary zero means "no key        |
| pressed."  When accessing a file, ST (address $90 for VIC and Commodore   |
| 64, $96 for most PET/CBM) is used for its usual functions of signaling    |
| end-of-file or error.  Similarly, disk status information can be received |
| over secondary address 15 if desired; a logical "command channel" file    |
| must be previously opened.                                                |
|                                                                           |
| Registers:  Registers A and X will be changed during the CHKIN call.  Be  |
