# 6502 Instruction Set - Start/reset operations continued and an introductory categorization 'Instructions by Type': transfer instructions (LDA, LDX, LDY, STA, STX, STY, TAX, TAY, TSX, TXA, TXS, TYA), stack instructions (PHA, PHP, PLA, PLP) with stack behavior details (push decrements SP, pull increments), decrement/increment group (DEC, DEX, DEY, INC, INX, INY), arithmetic operations (ADC, SBC) and logical ops (AND, EOR, ORA). Shift & rotate behavior: ASL, LSR, ROL, ROR (carry preserves bit shifted out).

           See the Primer of 6502 Arithmetic Instructions below for details.
           Logical Operations
           AND .... and (with accumulator)
           EOR .... exclusive or (with accumulator)
           ORA .... (inclusive) or with accumulator
           Shift & Rotate Instructions
           All shift and rotate instructions preserve the bit shifted out in
           the carry flag.
           ASL .... arithmetic shift left (shifts in a zero bit on the right)
           LSR .... logical shift right (shifts in a zero bit on the left)
           ROL .... rotate left (shifts in carry bit on the right)
           ROR .... rotate right (shifts in carry bit on the left)
           Flag Instructions
           CLC .... clear carry
           CLD .... clear decimal (BCD arithmetics disabled)
           CLI .... clear interrupt disable
           CLV .... clear overflow
           SEC .... set carry
           SED .... set decimal (BCD arithmetics enabled)
           SEI .... set interrupt disable
           Comparisons
           Generally, comparison instructions subtract the operand from the
           given register without affecting that register. Flags are still set
           as with a normal subtraction and thus the relation of the two values
           becomes accessible by the Zero, Carry and Negative flags.
           (See the branch instructions below for how to evaluate flags.)
             Relation R âˆ’ Op      Z   C    N
             Register < Operand   0   0    sign bit of result
             Register = Operand   1   1    0
             Register > Operand   0   1    sign bit of result
           CMP .... compare (with accumulator)
           CPX .... compare with X
           CPY .... compare with Y
                                                               6502 Instruction Set
           Bit Test
           The BIT instruction is somewhat similar to the CMP instruction, but
           performs a bit-wise comparison between the contents of the
           accumulator and a memory location given as the operand.
           BIT performs a logical AND operation between the two values and sets
           the Zero flag according to the result. Additionally, bit #7 (sign-
           bit) and bit #6 of the operand are transferred to the respective
           bits of the status register, the Negative flag and the oVerflow
           flag. (Thus, these two bits can be easily used to store and set
           flags for conditional branches, see below.)
           The contents of the accumulator remains uneffected.
           BIT .... bit test (accumulator & memory)
           Conditional Branch Instructions
           Branch targets are relative, signed 8-bit address offsets.
           (An offset of zero corresponds to the immedately following address.
           While it is perfectly feasible to calculate offsets by hand, more
           often these are computed by an assembler program from absoulte
           addresses or labels. In the latter case, branch instructions may
           look more like absolute address mode instructions, while taking in
           actuality just a relative offset as a single-byte operand.)
           BCC .... branch on carry clear
           BCS .... branch on carry set
           BEQ .... branch on equal                (zero flag set)
           BMI .... branch on minus                (negative flag set)
           BNE .... branch on not equal            (zero flag clear)
           BPL .... branch on plus                 (negative flag clear)

---
Additional information can be found by searching:
- "shift_and_rotate_instructions" which expands on details and opcode forms of ASL/LSR/ROL/ROR
- "arithmetic_instructions_primer" which expands on ADC/SBC primer and multi-byte arithmetic
