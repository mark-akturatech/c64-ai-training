# C64 BASIC ROM - Important Routines $A000-$BFFF


The DEF statement must fit on one line, but functions can be extended
by nesting them (having one function call another).

46049         $B3E1          GETFNM
Check DEF and FN Syntax

This routine checks to make sure that FN follow SEG, and that the
dependent variable has a valid floating point variable name.  It calls
the routine to find or create a variable to get the pointer to its
address.

46068         $B3F4          FNDOER
Perform FN

The FN evaluation is done by evaluating the FN argument (for example,
FN(A+B*C/D)) and then getting the rest of the expression from the text
of the function definition statement.  The function variable
descriptor area is used as a work area, and the dependent variable is
not disturbed (so that if the definition used FN(X), the value of X
will not be changed by the function call).

46181         $B465          STRD
Perform STR$

STR$ first checks to make sure that the parameter is a number, and
then calls the routines that convert floating point to ASCII and crate
the pointers to a string constant.

46215         $B487          STRLIT
Scan and Set Up Pointers to a String in Memory

This routine calculates the length of the string, and calls the
routine that allocates space in memory.  It then saves the string, or
creates a pointer to its location in the BASIC text input buffer at
512 ($200).

46324         $B4F4          GETSPA
Allocate Space in Memory for String

The amount of space needed for a string is passed to this routine, and
the routine checks if there is that amount of space available in free
memory.  If not, it does a garbage collection and tries again.

46374         $B526          GARBAG
String Garbage Collection

Whenever a string is changed in any way, the revised version of the
text is added to the bottom of the string text area, leaving the old
version higher up in memory, wasting space.

In order to reclaim that space, the descriptor for every string whose
text is in the string text area (rather than in the program text area)
must be searched to find the valid text that is highest in memory.  If
that string is not as high as it could be, it is moved up to replace
any string that is no longer valid.  Then all of the string
descriptors must be searched again to find the next highest string and
move it up.  This continues until every string that is un use has been
covered.  After all have been moved up, the pointer to the bottom of
string text at 51-52 ($33-$34) is changed to show the new bottom
location.

If there are more than a few strings whose text is in the string text
storage area, rather than in the body of the program, scanning every
string as many times as there are strings can take an awful lot of
time.  The computer may seem as if it had died (the STOP key is not
even checked during the procedure).

The collection will take about as long whether there is any spare
space or not; the full collection will be done even if it is done
immediately after the last collection.  Although the increased memory
capacity of the 64 helps to forestall the need for garbage collection,
a large program with many string arrays may still experience lengthy
collection delays.

46525         $B5BD
Check for Most Eligible String to Collect

This part of the garbage collection routine checks to see if the
current string is the highest in memory.

46598         $B606
Collect a String

This part of the garbage collection routine moves the string to high
memory and updates the descriptor to point to its new location.

46653         $B63D          CAT
Concatenate Two Strings

This routine is used to add the text of one string onto the end of
another (A$+B$).  Error checking is done to see if the length of the
combined string is within range, the allocation routine is called to
allocate space, and the new string is built at the bottom of the
string text area.

46714         $B67A          MOVINS
Move a String in Memory

This is the routine which is used to move a string to the bottom of
the string text area for the above routine.  It is generally used as a
utility routine to move strings.

46755         $B6A3          FRESTR
Discard a Temporary String

This routine calls the following routine which clears an entry from
the temporary descriptor stack.  If the descriptor was on the stack,
it exits after setting pointers to the string and its length.  If it
wasn't on the temporary stack and is at the bottom of string text
storage, the pointer to the bottom is moved up to deallocate the
string.

46811         $B6DB          FRETMS
Remove an Entry from the String Descriptor Stack

If the descriptor of a currently valid string is the same as one of
the entries on the temporary string descriptor stack, the stack entry
is removed.

46828         $B6EC          CHRD
Perform CHR$

The CHR$ routine creates a descriptor on the temporary string stack
for the one-byte string whose value is specified in the command, and
sets a pointer to that string.

46848         $B700          LEFTD
Perform LEFT$

LEFT$ creates a temporary string descriptor for a new string which
contains the number of characters from the left side of the string
that is specified in the command.

46892         $B72C          RIGHTD
Perform RIGHT$

RIGHT$ manipulates its parameters so that the tail end of LEFT$ can be
used to create a temporary string descriptor for a new string.  This
new string contains the number of characters from the right side of
the string that is specified in the command.

46903         $B737          MIDD
Perform MID$

MID$ manipulates its parameters so that the tail end of LEFT$ can be
used to create a temporary string descriptor for a new string.  This
new string contains the number of characters from the position in the
middle of the string that is specified in the command.

46945         $B761          PREAM
Pull String Function Parameters from Stack for LEFT$, RIGHT$, and MID$

This routine is used to obtain the first two parameters for all three
of these commands.

46972         $B77C          LEN
Perform LEN

The LEN function is performed by obtaining the string length from the
descriptor and converting it to a floating point number.

46987         $B78B          ASC
Perform ASC

This routine gets the first character of the string in the .Y register
(if it's not a null string).  Then it calls the part of POS that
converts a one- byte integer in .Y to a floating point number.

47003         $B79B          GETBYTC
Input a Parameter Whose Value Is Between 0 and 255

This routine reads numeric ASCII program text, converts it to an
integer, checks that it is in the range 0-255, and stores it in the .X
register.  This routine can be useful for reading parameters from a
USR statement or new commands.

47021         $B7AD          VAL
Perform VAL

The VAL routine obtains the string pointer, and reads the string one
character at a time until an invalid character is found (ASCII
numbers, sign character, a single decimal point, exponent, and spaces
are all valid).  Then the string is changed to floating point.  If no
valid characters are found, a 0 is returned.

47083         $B7EB          GETNUM
Get a 16-Bit Address Parameter and an 8-Bit Parameter (for POKE and WAIT)

This routine gets the next numeric parameter from the current place in
program text.  The routine evaluates it, checks that it is a positive
integer within the range 0-65535, and changes it from floating point
to a two-byte integer in 20-21 ($14-$15).  It checks for and skips a
comma, then gets a one-byte integer parameter in the .X register.  The
routine is used to get the parameters for POKE an WAIT.

47095         $B7F7          GETADR
Convert a Floating Point Number to an Unsigned Two-Byte Integer

This routine checks the number in the Floating Point Accumulator to
make sure that it is a positive number less than 65536, and then calls
the subroutine which conerts floatin point to integer.  It is used to
get address parameters, for commands such as PEEK.

47117         $B80D          PEEK
Perform PEEK

PEEK reads the address parameter and converts it to a pointer.  Then
it gets the byte pointed to into the .Y register, and calls the part
of POS that converts a single integer in .Y to a floating point
number.

47140         $B824          POKE
Perform POKE

POKE gets a pointer to the address parameter, and stores the next
parameter there.

47149         $B82D          FUWAIT
Perform WAIT

WAIT gets an address parameter and an integer parameter to use as a
mask.  WAIT then looks for an optional parameter to use as a pattern
for the exclusive OR.  Then, the address location is read, its value
is exclusive ORed with the optional pattern value (or 0 if there is
none).  This value is ANDed with the mask value.  The command loops
continuously until the result is not- zero.

The purpose of this command is to allow the program to watch a
location which can be changed by the system or by outside hardware
(such as the software clock or keycode value locations).

The AND function lets you check if a bit changes from 0 to 1, while
the EOR function allows you to check if a bit changes from 1 to 0.
For more information, see the article "All About the Wait
Instruction," by Louis Sander and Doug Ferguson, in COMPUTE!'s First
Book of Commodore 64.

47177         $B849          FADDH
Add .5 to Contents of Floating Point Accumulator #1

47184         $B850          FSUB
Subtract FAC1 from a Number in Memory

This routine is used to subtract the Floating Point Accumulator from a
number in memory.  It moves the number in memory into FAC2, and falls
through to the next routine.

47187         $B853          FSUBT
BASIC's Subtraction Operation
