# KickAssembler - Command Line Options Reference

            .var m = ScaleMatrix(120,120,0)*
                     PerspectiveMatrix(zp)*
                     MoveMatrix(0,0,zp+5)*
                     RotationMatrix(aX,aY,aZ)
            // Transform the coordinates
            .var coords = List()
            .for (var i=0; i<object.size(); i++) {
                          .eval coords.add(m*object.get(i))
            }
            .eval frames.add(coords)
        }
        // Dump the list to the memory
        .for (var coordNr=0; coordNr<object.size(); coordNr++) {
            .for (var xy=0;xy<2; xy++) {
               .fill animLength, $80+round(frames.get(i).get(coordNr).get(xy))
            }
        }
}
//------------------------------------------------------------------------------------------
// The vector data
//------------------------------------------------------------------------------------------
.align $100
cubeCoords: :PrecalcObject(Cube,256,2,-1,1)
//------------------------------------------------------------------------------------------
                                                                                              52
10 Testing
Kick Assembler has some build in .assert directives that are useful for testing. They were made to
make it easy to test the assembler itself, but you can use them for testing your own pseudo-
commands, macros, functions. When assertions are used, the assembler will automatically count the
number of assertions and the number of failed assertions and display these when the assembling has
finished.
10.1 Asserting expressions
With the assert directive you can test the value of expressions. It takes three arguments: a
description, an expression, and an expected result.
   .assert “2+5*10/2”, 2+5*10/2, 27
   .assert “2+2”, 2+2, 5
   .assert “Vector(1,2,3)+Vector(1,1,1)”, Vector(1,2,3)+Vector(1,1,1),
   Vector(2,3,4)
When assembling this code the assembler prints the description, the result of the expression and the
expected result. If these don’t match an error message is appended:
   2+5*10/2=27.0 (27.0)
   2+2=4.0 (5.0) -- ERROR IN ASSERTION!!!
   Vector(1,2,3)+Vector(1,1,1)=(2.0,3.0,4.0) ((2.0,3.0,4.0))
10.2 Asserting errors in expressions
To make sure that an expression gives an error when the user gives the wrong parameters to a
function, use the .asserterror directive:
   .asserterror "Test1" , 20/10
   .asserterror "Test2" , 20/false
 In the above example test1 will fail since its perfectly legal to divide 20 by 10. Test2 will produce
the expected error so this assertion is ok. The above will give the following output:
      Test1 -- ERROR IN ASSERTION!
      Test2 -- OK. | Can't get a numeric representation from a value of type
   boolean
10.3 Asserting code
The assert directive has a second form which makes it possible to compare pieces of assembled
code:
                                                                                                     53
  .assert "Test2", { lda $1000 }, {ldx $1000}
  .assert "Test", {
           .for (var i=0; i<4; i++)
              sta $0400+i
  }, {
           sta $0400
           sta $0401
           sta $0402
           sta $0403
  }
The assert directive will give an ok or failed message and the assembled result as output. The
output of the above example is as follows:
    Test1 -- FAILED! | 2000:ad,00,10 -- 2000:ae,00,10
    Test2 -- OK. | 2000:8d,00,04,8d,01,04,8d,02,04,8d,03,04
10.4 Asserting errors in code
Like the assert directive the asserterror directive also has a form that can assert code:
  .asserterror "Test" , { lda #"This must fail"}
Output:
    Test -- OK. | The value of a Command Argument Value must be an integer.
  Can't get an integer from a value of type 'string'
                                                                                               54
11 Some technical details
In Kick Assembler 3 some rather advanced techniques have been implemented to make the
assembling more flexible and correct. I’ll describe some of the main points here. YOU DON’T
NEED TO KNOW THIS, but if you are curious about technical details then read on.
11.1 The flexible parse algorithm
Kick Assembler 3 uses a flexible pass algorithm, which parses each assembler command or
directive as much as possible in each pass. Some commands can be finished in first pass, such as
lda #10 or sta $1000. But if a command depends on information not yet given, like ‘jmp routine’
where the routine label hasn’t been defined yet, an extra pass is required. Kick Assembler keeps
executing passes until the assembling is finished or no progress has been made. You can write
programs that only need one pass, but most programs will need two or more. This approach is more
flexible and gives advantages over normal fixed pass assembling. All directives don’t have to be in
the same phase of assembling, which gives some nice possibilities for future directives.
11.2 Recording of side effects
Side effects of directives are now recorded and replayed the subsequent passes. Consider the
following eval directive: .eval a=[5+8/2+1]*10.In the first pass the calculation [5+8/2 + 1]*10 will
be executed and find the result 100, which will be assigned to a. In the next pass no calculation is
done, only the side effect (a=100) is executed. This speeds up programs with heavy scripting, since
the script only has to execute once.
11.3 Function Mode and Asm Mode
Kick assembler has two modes for executing directives. ‘Function Mode’ is used when the
directive is placed inside a function or .define directive, otherwise ‘Asm Mode’ is used. ‘Function
Mode’ is executed fast but is restricted to script commands only (.var, .const, .for, etc.), while ‘Asm
Mode’ can handle all directives and records the side effects as described in previous section. All
evaluation starts in ‘Asm Mode’ and enters ‘Function Mode’ if you get inside the body a function
or .define directive. This means that at some point there is always a directive that records the result
of the evaluation.
11.4 Invalid value calculations
Invalid values occur when the information used to calculate a value that isn’t available yet. Usually
this starts with an unresolved label value, which is defined later in the source code. Normally you
would stop assembling the current directive once you reach an invalid value, but that might leave
out some side effects you did intend to happen, so instead of stopping, the assembler now carries on
operating on the invalid values. So an unresolved label is just an unresolved Number value. If you
add two number values and one of them is invalid then the result will be another invalid number
value. If you compare two invalid numbers then you get an invalid boolean and so forth. This helps
to track down which values to invalidate. If for example you use an invalid number as index in a set
function on a list, you must invalidate the whole list since you don’t know which element is
overwritten.
                                                                                                      55
4+InvalidNumber -> InvalidNumber
InvalidNumber != 5 -> InvalidBoolean
myList.set(3, InvalidNumber) -> [?,?,InvalidNumber]
myList.set(InvalidNumber, “Hello”) -> InvalidList
myList.set(4+4*InvalidNumber, “Hello”) -> InvalidList
                                                      56
12 Going from Kick Assembler 2.x to 3.x
If you have trouble assembling you old Kick Assembler 2.x sources then check the following list:
    •   The .if directive now has its own scope, so you can no longer access variables defined
        inside an if from the outside scope. Instead, just define you variables before the .if directive.
    •    To access a mutable value defined in a different pass it has to be locked. Consult the
        chapter ‘Working with Mutable Values’ to see how this works.
    •   If you experience bad performance or lack of memory, then read the chapter “Optimization
        Considerations when using Loops”
                                                                                                       57
13 Command line options
The command line options for Kick Assembler are:
Option         Example                Description
-o             -o dots.prg            Sets the output file. Default is the input filename with a
                                      ‘.prg’ as suffix.
-libdir        -libdir ../stdLib      Defines a library where the assembler will look when it
                                      tries to open external files.
-showmem       -showmem               Show a memory map after assembling.
-execute       -execute x64           Execute a given program with the assembled file as
               or                     argument. You can use this to start a C64 emulator with
               -execute “x64
               +sound”
                                      the assembled program if the assembling is successful..
-warningsoff   -warningsoff           Turns off warning messages
-log           -log logfile.txt       Prints the output of the assembler to a logfile
-dtv           -dtv                   Enables DTV opcodes
-aom           -aom                   Allow overlapping memory blocks. With this option,
                                      overlapping memory blocks will produce a warning
                                      instead of an error.
-time          -time                  Displays the assemble time.
-vicesymbols   -vicesymbols           Generates a label file for VICE.
-binfile       -binfile               Sets the output to be a bin file instead of a prg file. The
                                      difference between a bin and a prg file is that the bin file
                                      doesn’t contain the two start address bytes.
-afo           -afo                   Allows file output to user defined files
:name=value    :x=34                  The ‘:’ notation denotes string variables passed to the
               :version=beta2
               :path=”c:/C 64/”
                                      script. They can be accessed by using the ‘cmdLineVars’
                                      hashtable which is available from the script.
-symbolfile    -symbolfile            Genrates a .sym file with the resolved symbols. The file
                                      can be used in other sources with the .import source
                                      directive.
-fillbyte      -fillbyte 255          Sets the byte used to fill the space between
                                      memoryblocks in the prg file.
                                                                                                  58
