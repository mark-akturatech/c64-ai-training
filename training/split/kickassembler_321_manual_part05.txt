# KickAssembler - Data Directives, Text Encoding

rti         $40
rts         $60
sax                        $87            $97    $83           $8f
sbc                 $e9    $e5    $f5            $e1    $f1    $ed     $fd    $f9
sbc2                $eb
sec         $38
sed         $f8
sei         $78
shx                                                                           $9e
shy                                                                    $9c
slo                        $07    $17            $03    $13    $0f     $1f    $1b
sre                        $47    $57            $43    $53    $4f     $5f    $5b
sta                        $85    $95            $81    $91    $8d     $9d    $99
stx                        $86            $96                  $8e
sty                        $84    $94                          $8c
tas                                                                           $9b
tax         $aa
tay         $a8
tsx         $ba
txa         $8a
txs         $9a
tya         $98
xaa                 $8b
DTV opcodes are also supported. To use these you have to use the –dtv option at the command line
when running Kick Assembler. The DTV commands are:
Mnemonic noarg imm         zp     zpx     zpy    izx    izy    abs     Abx    aby     ind  rel
bra                                                                                        $12
sac                 $32
sir                 $42
                                                                                               9
3.2 Addressing Modes / Argument Types
Kick Assembler uses the traditional notation for addressing modes / argument types:
Mode                                    Example
No argument                             Nop
Immediate                               lda #$30
Zeropage                                lda $30
Zeropage,x                              lda $30,x
Zeropage,y                              ldx $30,y
Indirect zeropage,x                     lda ($30,x)
Indirect zeropage,y                     lda ($30),y
Abolute                                 lda $1000
Absolute,x                              lda $1000,x
Absolute,y                              lda $1000,y
Indirect                                jmp ($1000)
Relative to program counter             bne loop
An argument is converted to its zeropage mode if possible. This means that lda $0030 will generate
an lda command in its zeropage mode*.
You can force the assembler to use a given addressing mode by using mnemonic extensions like
this:
    lda.a $0030        // Uses absolute mode
    sta.z label        // Uses zeropage mode
    ldx.im $10          // Equal to lda #$10
    label:
Here is a list of the extensions:
Ext             Mode                        Example
im, imm         Immediate
z, zp           Zeropage                    ldx.z $1234
zx, zpx         Zeropage,x                  lda.zpx table
zy, zpy         Zeropage,y
izx, izpx       Indirect zeropage,x
izy, izpy       Indirect zeropage,y
a, abs          Abolute                     ldx.a $0010
ax, absx        Absolute,x                  lda.absx $1234
ay, absy        Absolute,y
i, ind          Indirect                    jmp.i $1000
r, rel          Relative to program
                counter
*
  If the argument is unknown (eg. an unresolved label) in the first pass, the assembler will assume it’s a 16 bit value an
not reduce it.
                                                                                                                         10
3.3 Number formats
Kick Assembler supports the standard number formats:
Prefix    Format           Example
          Decimal          lda #42
$         Hexadecimal      lda #$2a, lda #$FF
%         Binary           lda #%101010
3.4 Labels and Multi Labels
Label declarations in Kick Assembler end with ‘:’ and have no postfix when referred to, as shown
in the following program:
   loop: inc $d020
            inc $d021
            jmp loop
Kick Assembler also supports multi labels, which are labels that can be declared more than once.
These are useful to prevent name conflicts between labels. A multi label starts with a ‘!’ and when
your reference it you have to end with a ‘+’ to refer to the next multi label or ‘-‘ to refer to the
previous multi label:
            ldx #100
   !loop: inc $d020
            dex
            bne !loop-      // Jumps to the previous instance of !loop
            ldx #100
   !loop: inc $d021
            dex
            bne !loop-      // Jumps to the previous instance of !loop
or
            ldx #10
   !loop:
            jmp !+          // Jumps over the two next nops to the ! label
            nop
            nop
   !:       jmp !+          // Jumps over the two next nops to the ! label
            nop
            nop
   !:
            dex
            bne !loop-      // Jumps to the previous !loop label
Another way to avoid conflicting variables is to use user defined scopes, which are explained in the
Scopes section of the script chapter.
A ‘*’ returns the value of the current memory location so instead of using labels you can write your
jumps like this:
                                                                                                     11
With ‘*’ reference:                      With label:
   jmp *                                   this: jmp this
   inc $d020                               !loop: inc $d020
   inc $d021                                       inc $d021
   jmp *-6                                         jmp !loop-
3.5 Memory and Data Directives
 The .pc directive is used to set the program counter. A program should always start with a .pc
directive to tell the assembler where to put the program. Here are some examples of use:
   .pc = $1000 “Program”
            ldx #10
   !loop: dex
            bne !loop-
            rts
   .pc = $4000 “Data”
            .byte 1,0,2,0,3,0,4,0
   .pc = $5000 “More data”
            .text “Hello”
The last argument is optional and is used to name the memory block created by the directive. When
using the ‘-showmem’ option when running the assembler a memory map will be generated that
displays the memory usage and block names. The map of the above program looks like this:
   Memory Map
   ----------------------------
   $1000-$1005 Program
   $4000-$4007 Data
   $5000-$5004 More data
By using the virtual option on the .pc directive you can declare a memory block that is not saved in
the resulting file.
   .pc = $0400 “Data Tables 1” virtual
   table1: .fill $100,0
   table2: .fill $100,0
   .pc = $0400 “Data Tables 2” virtual
   table3: .fill $150,0
   table4: .fill $100,0
   .pc = $1000 “Program”
            ldx #0
