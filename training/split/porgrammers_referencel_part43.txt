# C64 PRG Chapter 5 - Addressing Modes

  222   BASIC TO MACHINE LANGUAGE
~


    Up to this point, we have covered immediate, zero page, and absolute
  mode instructions. We have also covered, but have not really talked
  about, the "implied" mode. The implied mode means that information is
  implied by an instruction itself. In other words, what registers, flags,
  and memory the instruction is referring to. The examples we have seen are
  PHA, PLA, PHP, and PLP, which refer to stack processing and the
  accumulator and status registers, respectively.

  +-----------------------------------------------------------------------+
  | NOTE: The X register will be referred to as X from now on, and        |
  | similarly A (accumulator), Y (Y index register), S (stack pointer),   |
  | and P (processor status).                                             |
  +-----------------------------------------------------------------------+

  INDEXING

    Indexing plays an extremely important part in the running of the 6510
  microprocessor. It can be defined as "creating an actual address from a
  base address plus the contents of either the X or Y index registers."
    For example, if X contains $05, and the microprocessor executes an LDA
  instruction in the "absolute X indexed mode" with base address (e.g.,
  $9000), then the actual location that is loaded into the A register is
  $9000 + $05 = $9005. The mnemonic format of an absolute indexed
  instruction is the same as an absolute instruction except a ",X" or ",Y"
  denoting the index is added to the address.

  EXAMPLE:

    LDA $9000,X

    There are absolute indexed, zero page indexed, indirect indexed, and
  indexed indirect modes of addressing available on the 6510
  microprocessor.


  INDIRECT INDEXED

    This only allows usage of the Y register as the index. The actual ad-
  dress can only be in zero page, and the mode of instruction is called
  indirect because the zero page address specified in the instruction con-
  tains the low byte of the actual address, and the next byte to it
  contains the high order byte.

                                            BASIC TO MACHINE LANGUAGE   223
~


  EXAMPLE:

    Let us suppose that location $02 contains $45, and location $03 con-
  tains $1E. If the instruction to load the accumulator in the indirect
  indexed mode is executed and the specified zero page address is $02, then
  the actual address will be:

    Low order = contents of $02
    High order = contents of $03
    Y register = $00

  Thus the actual address = $1E45 + Y = $1E45.
    The title of this mode does in fact imply an indirect principle,
  although this may be difficult to grasp at first sight. Let's look at it
  another way:
    "I am going to deliver this letter to the post office at address $02,
  MEMORY ST., and the address on the letter is $05 houses past $1600,
  MEMORY street." This is equivalent to the code:

    LDA #$00      - load low order actual base address
    STA $02       - set the low byte of the indirect address
    LDA #$16      - load high order indirect address
    STA $03       - set the high byte of the indirect address
    LDY #$05      - set the indirect index (Y)
    LDA ($02),Y   - load indirectly indexed by Y


  INDEXED INDIRECT

    Indexed indirect only allows usage of the X register as the index. This
  is the some as indirect indexed, except it is the zero page address of
  the pointer that is indexed, rather than the actual base address.
  Therefore, the actual base address IS the actual address because the
  index has already been used for the indirect. Index indirect would also
  be used if a table of indirect pointers were located in zero page memory,
  and the X register could then specify which indirect pointer to use.







  224   BASIC TO MACHINE LANGUAGE
~


  EXAMPLE:

    Let us suppose that location $02 contains $45, and location $03 con-
  tains $10. If the instruction to load the accumulator in the indexed
  indirect mode is executed and the specified zero page address is $02,
  then the actual address will be:

    Low order = contents of ($02+X)
    High order = contents of ($03+X)
    X register = $00

  Thus the actual pointer is in = $02 + X = $02.
    Therefore, the actual address is the indirect address contained in $02
  which is again $1045.
    The title of this mode does in fact imply the principle, although it
  may be difficult to grasp at first sight. Look at it this way:
    "I am going to deliver this letter to the fourth post office at address
  $01,MEMORY ST., and the address on the letter will then be delivered to
  $1600, MEMORY street." This is equivalent to the code:


    LDA #$00    - load low order actual base address
    STA $06     - set the low byte of the indirect address
    LDA #$16    - load high order indirect address
    STA $07     - set the high byte of the indirect address
    LDX #$05    - set the indirect index (X)
    LDA ($02,X) - load indirectly indexed by X



  +-----------------------------------------------------------------------+
  | NOTE: Of the two indirect methods of addressing, the first (indirect  |
  | indexed) is far more widely used.                                     |
  +-----------------------------------------------------------------------+









                                            BASIC TO MACHINE LANGUAGE   225
~


  BRANCHES AND TESTING

    Another very important principle in machine language is the ability to
  test, and detect certain conditions, in a similar fashion to the "IF...
  THEN, IF... GOTO" structure in CBM BASIC.
    The various flags in the status register are affected by different in-
  structions in different ways. For example, there is a flag that is set
  when an instruction has caused a zero result, and is reset when a result
  is not zero. The instruction:

    LDA #$00

  will cause the zero result flag to be set, because the instruction has
  resulted in the accumulator containing a zero.
    There are a set of instructions that will, given a particular
  condition, branch to another part of the program. An example of a branch
  instruction is BEQ, which means Branch if result EQual to zero. The
  branch instructions branch if the condition is true, and if not, the
  program continues onto the next instruction, as if nothing had occurred.
  The branch instructions branch not by the result of the previous
  instructions), but by internally examining the status register. As was
  just mentioned, there is a zero result flag in the status register. The
  BEQ instruction branches if the zero result flag (known as Z) is set.
  Every branch instruction has an opposite branch instruction. The BEQ
  instruction has an opposite instruction BNE, which means Branch on result
  Not Equal to zero (i.e., Z not set).
    The index registers have a number of associated instructions which
  modify their contents. For example, the INX instruction INcrements the X
  index register. If the X register contained $FF before it was incremented
  (the maximum number the X register can contain), it will "wrap around"
  back to zero. If you wanted a program to continue to do something until
  you had performed the increment of the X index that pushed it around to
  zero, you could use the BNE instruction to continue "looping" around,
  until X became zero.
    The reverse of INX, is DEX, which is DEcrement the X index register. If
  the X index register is zero, DEX wraps around to $FF. Similarly, there
  are INY and DEY for the Y index register.






  226   BASIC TO MACHINE LANGUAGE
~


    But what if a program didn't want to wait until X or Y had reached (or
  not reached) zero? Well there are comparison instructions, CPX and CPY,
  which allow the machine language programmer to test the index registers
  with specific values, or even the contents of memory locations. If you
  wanted to see if the X register contained $40, you would use the
  instruction:


    CPX #$40         - compare X with the "value" $40.
    BEQ              - branch to somewhere else in the
    (some other        program, if this condition is "true."
     part of the
     program)


  The compare, and branch instructions play a major part in any machine
  language program.
    The operand specified in a branch instruction when using 64MON is the
  address of the part of the program that the branch goes to when the
  proper conditions are met. However, the operand is only an offset, which
  gets you from where the program currently is to the address specified.
  This offset is just one byte, and therefore the range that a branch
  instruction can branch to is limited. It can branch from 128 bytes back-
  ward, to 127 bytes forward.

  +-----------------------------------------------------------------------+
  | NOTE: This is a total range of 255 bytes which is, of course, the     |
  | maximum range of values one byte can contain.                         |
  +-----------------------------------------------------------------------+

    64MON will tell you if you "branch out of range" by refusing to "as-
  semble" that particular instruction. But don't worry about that now be-
  cause it's unlikely that you will have such branches for quite a while.
  The branch is a "quick" instruction by machine language standards because
  of the "offset" principle as opposed to an absolute address. 64MON allows
  you to type in an absolute address, and it calculates the correct offset.
  This is just one of the "comforts" of using an assembler.

  +-----------------------------------------------------------------------+
  | NOTE: It is NOT possible to cover every single branch instruction. For|
  | further information, refer to the Bibliography section in Appendix F. |
  +-----------------------------------------------------------------------+

                                            BASIC TO MACHINE LANGUAGE   227
~


  SUBROUTINES

    In machine language (in the same way as using BASIC), you can call
  subroutines. The instruction to call a subroutine is JSR (Jump to Sub-
  Routine), followed by the specified absolute address.
    Incorporated in the operating system, there is a machine language
  subroutine that will PRINT a character to the screen. The CBM ASCII code
  of the character should be in the accumulator before calling the
  subroutine. The address of this subroutine is $FFD2.
    Therefore, to print "Hi" to the screen, the following program should be
  entered:



    .A 1400 LDA #$48     - load the CBM ASCII code of "H"
    .A 1402 JSR $FFD2    -  print it
    .A 1405 LDA #$49     - load the CBM ASCII code of "I"
    .A 1407 JSR $FFD2    -  print that too
    .A 140A LDA #$0D     - print a carriage return as well
    .A 140C JSR $FFD2
    .A 140F BRK          - return to 64MON
    .G 1400              - will print "HI" and return to 64MON



    The "PRINT a character" routine we have just used is part of the KERNAL
  jump table. The instruction similar to GOTO in BASIC is JMP, which means
  JUMP to the specified absolute address. The KERNAL is a long list of
  "standardized" subroutines that control ALL input and output of the
  Commodore 64. Each entry in the KERNAL JMPs to a subroutine in the
  operating system. This "jump table" is found between memory locations
  $FF84 to $FFF5 in the operating system. A full explanation of the KERNAL
  is available in the "KERNAL Reference Section" of this manual. However,
  certain routines are used here to show how easy and effective the KERNAL
  is.
    Let's now use the new principles you've just learned in another pro-
  gram. It will help you to put the instructions into context:






