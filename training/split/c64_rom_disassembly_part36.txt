# C64 KERNAL ROM Disassembly $EF00-$F1FF - RS-232

.,EF00 E6 B4    INC $B4         decrement RS232 bit count
.,EF02 A2 FF    LDX #$FF        set stop bit = 1
.,EF04 D0 CB    BNE $EED1       save stop bit and exit, branch always

                                *** setup next RS232 Tx byte
.,EF06 AD 94 02 LDA $0294       read the 6551 pseudo command register
.,EF09 4A       LSR             handshake bit inot Cb
.,EF0A 90 07    BCC $EF13       if 3 line interface go ??
.,EF0C 2C 01 DD BIT $DD01       test VIA 2 DRB, RS232 port
.,EF0F 10 1D    BPL $EF2E       if DSR = 0 set DSR signal not present and exit
.,EF11 50 1E    BVC $EF31       if CTS = 0 set CTS signal not present and exit
                                was 3 line interface
.,EF13 A9 00    LDA #$00        clear A
.,EF15 85 BD    STA $BD         clear the RS232 parity byte
.,EF17 85 B5    STA $B5         clear the RS232 next bit to send
.,EF19 AE 98 02 LDX $0298       get the number of bits to be sent/received
.,EF1C 86 B4    STX $B4         set the RS232 bit count
.,EF1E AC 9D 02 LDY $029D       get the index to the Tx buffer start
.,EF21 CC 9E 02 CPY $029E       compare it with the index to the Tx buffer end
.,EF24 F0 13    BEQ $EF39       if all done go disable T?? interrupt and return
.,EF26 B1 F9    LDA ($F9),Y     else get a byte from the buffer
.,EF28 85 B6    STA $B6         save it to the RS232 output byte buffer
.,EF2A EE 9D 02 INC $029D       increment the index to the Tx buffer start
.,EF2D 60       RTS             

                                *** set DSR signal not present
.,EF2E A9 40    LDA #$40        set DSR signal not present
.:EF30 2C       .BYTE $2C       makes next line BIT $10A9

                                *** set CTS signal not present
.,EF31 A9 10    LDA #$10        set CTS signal not present
.,EF33 0D 97 02 ORA $0297       OR it with the RS232 status register
.,EF36 8D 97 02 STA $0297       save the RS232 status register

                                *** disable timer A interrupt
.,EF39 A9 01    LDA #$01        disable timer A interrupt

                                *** set VIA 2 ICR from A
.,EF3B 8D 0D DD STA $DD0D       save VIA 2 ICR
.,EF3E 4D A1 02 EOR $02A1       EOR with the RS-232 interrupt enable byte
.,EF41 09 80    ORA #$80        set the interrupts enable bit
.,EF43 8D A1 02 STA $02A1       save the RS-232 interrupt enable byte
.,EF46 8D 0D DD STA $DD0D       save VIA 2 ICR
.,EF49 60       RTS             

                                *** compute bit count
.,EF4A A2 09    LDX #$09        set bit count to 9, 8 data + 1 stop bit
.,EF4C A9 20    LDA #$20        mask for 8/7 data bits
.,EF4E 2C 93 02 BIT $0293       test pseudo 6551 control register
.,EF51 F0 01    BEQ $EF54       branch if 8 bits
.,EF53 CA       DEX             else decrement count for 7 data bits
.,EF54 50 02    BVC $EF58       branch if 7 bits
.,EF56 CA       DEX             else decrement count ..
.,EF57 CA       DEX             .. for 5 data bits
.,EF58 60       RTS             

                                *** RS232 Rx NMI
.,EF59 A6 A9    LDX $A9         get start bit check flag
.,EF5B D0 33    BNE $EF90       if no start bit received go ??
.,EF5D C6 A8    DEC $A8         decrement receiver bit count in
.,EF5F F0 36    BEQ $EF97       if the byte is complete go add it to the buffer
.,EF61 30 0D    BMI $EF70       
.,EF63 A5 A7    LDA $A7         get the RS232 received data bit
.,EF65 45 AB    EOR $AB         EOR with the receiver parity bit
.,EF67 85 AB    STA $AB         save the receiver parity bit
.,EF69 46 A7    LSR $A7         shift the RS232 received data bit
.,EF6B 66 AA    ROR $AA         
.,EF6D 60       RTS             
.,EF6E C6 A8    DEC $A8         decrement receiver bit count in
.,EF70 A5 A7    LDA $A7         get the RS232 received data bit
.,EF72 F0 67    BEQ $EFDB       
.,EF74 AD 93 02 LDA $0293       get pseudo 6551 control register
.,EF77 0A       ASL             shift the stop bit flag to Cb
.,EF78 A9 01    LDA #$01        + 1
.,EF7A 65 A8    ADC $A8         add receiver bit count in
.,EF7C D0 EF    BNE $EF6D       exit, branch always

                                *** setup to receive an RS232 bit
.,EF7E A9 90    LDA #$90        enable FLAG interrupt
.,EF80 8D 0D DD STA $DD0D       save VIA 2 ICR
.,EF83 0D A1 02 ORA $02A1       OR with the RS-232 interrupt enable byte
.,EF86 8D A1 02 STA $02A1       save the RS-232 interrupt enable byte
.,EF89 85 A9    STA $A9         set start bit check flag, set no start bit received
.,EF8B A9 02    LDA #$02        disable timer B interrupt
.,EF8D 4C 3B EF JMP $EF3B       set VIA 2 ICR from A and return

                                *** no RS232 start bit received
.,EF90 A5 A7    LDA $A7         get the RS232 received data bit
.,EF92 D0 EA    BNE $EF7E       if ?? go setup to receive an RS232 bit and return
.,EF94 4C D3 E4 JMP $E4D3       flag the RS232 start bit and set the parity

                                *** received a whole byte, add it to the buffer
.,EF97 AC 9B 02 LDY $029B       get index to Rx buffer end
.,EF9A C8       INY             increment index
.,EF9B CC 9C 02 CPY $029C       compare with index to Rx buffer start
.,EF9E F0 2A    BEQ $EFCA       if buffer full go do Rx overrun error
.,EFA0 8C 9B 02 STY $029B       save index to Rx buffer end
.,EFA3 88       DEY             decrement index
.,EFA4 A5 AA    LDA $AA         get assembled byte
.,EFA6 AE 98 02 LDX $0298       get bit count
.,EFA9 E0 09    CPX #$09        compare with byte + stop
.,EFAB F0 04    BEQ $EFB1       branch if all nine bits received
.,EFAD 4A       LSR             else shift byte
.,EFAE E8       INX             increment bit count
.,EFAF D0 F8    BNE $EFA9       loop, branch always
.,EFB1 91 F7    STA ($F7),Y     save received byte to Rx buffer
.,EFB3 A9 20    LDA #$20        mask 00x0 0000, parity enable bit
.,EFB5 2C 94 02 BIT $0294       test the pseudo 6551 command register
.,EFB8 F0 B4    BEQ $EF6E       branch if parity disabled
.,EFBA 30 B1    BMI $EF6D       branch if mark or space parity
.,EFBC A5 A7    LDA $A7         get the RS232 received data bit
.,EFBE 45 AB    EOR $AB         EOR with the receiver parity bit
.,EFC0 F0 03    BEQ $EFC5       
.,EFC2 70 A9    BVS $EF6D       if ?? just exit
.:EFC4 2C       .BYTE $2C       makes next line BIT $A650
.,EFC5 50 A6    BVC $EF6D       if ?? just exit
.,EFC7 A9 01    LDA #$01        set Rx parity error
.:EFC9 2C       .BYTE $2C       makes next line BIT $04A9
.,EFCA A9 04    LDA #$04        set Rx overrun error
.:EFCC 2C       .BYTE $2C       makes next line BIT $80A9
.,EFCD A9 80    LDA #$80        set Rx break error
.:EFCF 2C       .BYTE $2C       makes next line BIT $02A9
.,EFD0 A9 02    LDA #$02        set Rx frame error
.,EFD2 0D 97 02 ORA $0297       OR it with the RS232 status byte
.,EFD5 8D 97 02 STA $0297       save the RS232 status byte
.,EFD8 4C 7E EF JMP $EF7E       setup to receive an RS232 bit and return
.,EFDB A5 AA    LDA $AA         
.,EFDD D0 F1    BNE $EFD0       if ?? do frame error
.,EFDF F0 EC    BEQ $EFCD       else do break error, branch always

                                *** open RS232 channel for output
.,EFE1 85 9A    STA $9A         save the output device number
.,EFE3 AD 94 02 LDA $0294       read the pseudo 6551 command register
.,EFE6 4A       LSR             shift handshake bit to carry
.,EFE7 90 29    BCC $F012       if 3 line interface go ??
.,EFE9 A9 02    LDA #$02        mask 0000 00x0, RTS out
.,EFEB 2C 01 DD BIT $DD01       test VIA 2 DRB, RS232 port
.,EFEE 10 1D    BPL $F00D       if DSR = 0 set DSR not present and exit
.,EFF0 D0 20    BNE $F012       if RTS = 1 just exit
.,EFF2 AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,EFF5 29 02    AND #$02        mask 0000 00x0, timer B interrupt
.,EFF7 D0 F9    BNE $EFF2       loop while the timer B interrupt is enebled
.,EFF9 2C 01 DD BIT $DD01       test VIA 2 DRB, RS232 port
.,EFFC 70 FB    BVS $EFF9       loop while CTS high
.,EFFE AD 01 DD LDA $DD01       read VIA 2 DRB, RS232 port
.,F001 09 02    ORA #$02        mask xxxx xx1x, set RTS high
.,F003 8D 01 DD STA $DD01       save VIA 2 DRB, RS232 port
.,F006 2C 01 DD BIT $DD01       test VIA 2 DRB, RS232 port
.,F009 70 07    BVS $F012       exit if CTS high
.,F00B 30 F9    BMI $F006       loop while DSR high
                                set no DSR and exit
.,F00D A9 40    LDA #$40        set DSR signal not present
.,F00F 8D 97 02 STA $0297       save the RS232 status register
.,F012 18       CLC             flag ok
.,F013 60       RTS             

                                *** send byte to the RS232 buffer
.,F014 20 28 F0 JSR $F028       setup for RS232 transmit
                                send byte to the RS232 buffer, no setup
.,F017 AC 9E 02 LDY $029E       get index to Tx buffer end
.,F01A C8       INY             + 1
.,F01B CC 9D 02 CPY $029D       compare with index to Tx buffer start
.,F01E F0 F4    BEQ $F014       loop while buffer full
.,F020 8C 9E 02 STY $029E       set index to Tx buffer end
.,F023 88       DEY             index to available buffer byte
.,F024 A5 9E    LDA $9E         read the RS232 character buffer
.,F026 91 F9    STA ($F9),Y     save the byte to the buffer

                                *** setup for RS232 transmit
.,F028 AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,F02B 4A       LSR             shift the enable bit to Cb
.,F02C B0 1E    BCS $F04C       if interrupts are enabled just exit
.,F02E A9 10    LDA #$10        start timer A
.,F030 8D 0E DD STA $DD0E       save VIA 2 CRA
.,F033 AD 99 02 LDA $0299       get the baud rate bit time low byte
.,F036 8D 04 DD STA $DD04       save VIA 2 timer A low byte
.,F039 AD 9A 02 LDA $029A       get the baud rate bit time high byte
.,F03C 8D 05 DD STA $DD05       save VIA 2 timer A high byte
.,F03F A9 81    LDA #$81        enable timer A interrupt
.,F041 20 3B EF JSR $EF3B       set VIA 2 ICR from A
.,F044 20 06 EF JSR $EF06       setup next RS232 Tx byte
.,F047 A9 11    LDA #$11        load timer A, start timer A
.,F049 8D 0E DD STA $DD0E       save VIA 2 CRA
.,F04C 60       RTS             

                                *** input from RS232 buffer
.,F04D 85 99    STA $99         save the input device number
.,F04F AD 94 02 LDA $0294       get pseudo 6551 command register
.,F052 4A       LSR             shift the handshake bit to Cb
.,F053 90 28    BCC $F07D       if 3 line interface go ??
.,F055 29 08    AND #$08        mask the duplex bit, pseudo 6551 command is >> 1
.,F057 F0 24    BEQ $F07D       if full duplex go ??
.,F059 A9 02    LDA #$02        mask 0000 00x0, RTS out
.,F05B 2C 01 DD BIT $DD01       test VIA 2 DRB, RS232 port
.,F05E 10 AD    BPL $F00D       if DSR = 0 set no DSR and exit
.,F060 F0 22    BEQ $F084       if RTS = 0 just exit
.,F062 AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,F065 4A       LSR             shift the timer A interrupt enable bit to Cb
.,F066 B0 FA    BCS $F062       loop while the timer A interrupt is enabled
.,F068 AD 01 DD LDA $DD01       read VIA 2 DRB, RS232 port
.,F06B 29 FD    AND #$FD        mask xxxx xx0x, clear RTS out
.,F06D 8D 01 DD STA $DD01       save VIA 2 DRB, RS232 port
.,F070 AD 01 DD LDA $DD01       read VIA 2 DRB, RS232 port
.,F073 29 04    AND #$04        mask xxxx x1xx, DTR in
.,F075 F0 F9    BEQ $F070       loop while DTR low
.,F077 A9 90    LDA #$90        enable the FLAG interrupt
.,F079 18       CLC             flag ok
.,F07A 4C 3B EF JMP $EF3B       set VIA 2 ICR from A and return
.,F07D AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,F080 29 12    AND #$12        mask 000x 00x0
.,F082 F0 F3    BEQ $F077       if FLAG or timer B bits set go enable the FLAG inetrrupt
.,F084 18       CLC             flag ok
.,F085 60       RTS             

                                *** get byte from RS232 buffer
.,F086 AD 97 02 LDA $0297       get the RS232 status register
.,F089 AC 9C 02 LDY $029C       get index to Rx buffer start
.,F08C CC 9B 02 CPY $029B       compare with index to Rx buffer end
.,F08F F0 0B    BEQ $F09C       return null if buffer empty
.,F091 29 F7    AND #$F7        clear the Rx buffer empty bit
.,F093 8D 97 02 STA $0297       save the RS232 status register
.,F096 B1 F7    LDA ($F7),Y     get byte from Rx buffer
.,F098 EE 9C 02 INC $029C       increment index to Rx buffer start
.,F09B 60       RTS             
.,F09C 09 08    ORA #$08        set the Rx buffer empty bit
.,F09E 8D 97 02 STA $0297       save the RS232 status register
.,F0A1 A9 00    LDA #$00        return null
.,F0A3 60       RTS             

                                *** check RS232 bus idle
.,F0A4 48       PHA             save A
.,F0A5 AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,F0A8 F0 11    BEQ $F0BB       if no interrupts enabled just exit
.,F0AA AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,F0AD 29 03    AND #$03        mask 0000 00xx, the error bits
.,F0AF D0 F9    BNE $F0AA       if there are errors loop
.,F0B1 A9 10    LDA #$10        disable FLAG interrupt
.,F0B3 8D 0D DD STA $DD0D       save VIA 2 ICR
.,F0B6 A9 00    LDA #$00        clear A
.,F0B8 8D A1 02 STA $02A1       clear the RS-232 interrupt enable byte
.,F0BB 68       PLA             restore A
.,F0BC 60       RTS             

                                *** kernel I/O messages
.:F0BD 0D 49 2F 4F 20 45 52 52  I/O ERROR #
.:F0C6 52 20 A3 0D 53 45 41 52
.:F0C9 0D 53 45 41 52 43 48 49  SEARCHING
.:F0D1 4E 47 A0 46 4F 52 A0 0D
.:F0D4 46 4F 52 A0 0D 50 52 45  FOR
.:F0D8 0D 50 52 45 53 53 20 50  PRESS PLAY ON TAPE
.:F0E0 4C 41 59 20 4F 4E 20 54
.:F0E8 41 50 C5 50 52 45 53 53
.:F0EB 50 52 45 53 53 20 52 45  PRESS RECORD & PLAY ON TAPE
.:F0F3 43 4F 52 44 20 26 20 50
.:F0FB 4C 41 59 20 4F 4E 20 54
.:F103 41 50 C5 0D 4C 4F 41 44
.:F106 0D 4C 4F 41 44 49 4E C7  LOADING
.:F10E 0D 53 41 56 49 4E 47 A0  SAVING
.:F116 0D 56 45 52 49 46 59 49  VERIFYING
.:F11E 4E C7 0D 46 4F 55 4E 44
.:F120 0D 46 4F 55 4E 44 A0 0D  FOUND
.:F127 0D 4F 4B 8D              OK

                                *** display control I/O message if in direct mode
.,F12B 24 9D    BIT $9D         test message mode flag
.,F12D 10 0D    BPL $F13C       exit if control messages off
                                display kernel I/O message
.,F12F B9 BD F0 LDA $F0BD,Y     get byte from message table
.,F132 08       PHP             save status
.,F133 29 7F    AND #$7F        clear b7
.,F135 20 D2 FF JSR $FFD2       output character to channel
.,F138 C8       INY             increment index
.,F139 28       PLP             restore status
.,F13A 10 F3    BPL $F12F       loop if not end of message
.,F13C 18       CLC             
.,F13D 60       RTS             

                                *** get character from the input device
.,F13E A5 99    LDA $99         get the input device number
.,F140 D0 08    BNE $F14A       if not the keyboard go handle other devices
                                the input device was the keyboard
.,F142 A5 C6    LDA $C6         get the keyboard buffer index
.,F144 F0 0F    BEQ $F155       if the buffer is empty go flag no byte and return
.,F146 78       SEI             disable the interrupts
.,F147 4C B4 E5 JMP $E5B4       get input from the keyboard buffer and return
                                the input device was not the keyboard
.,F14A C9 02    CMP #$02        compare the device with the RS232 device
.,F14C D0 18    BNE $F166       if not the RS232 device go ??
                                the input device is the RS232 device
.,F14E 84 97    STY $97         save Y
.,F150 20 86 F0 JSR $F086       get a byte from RS232 buffer
.,F153 A4 97    LDY $97         restore Y
.,F155 18       CLC             flag no error
.,F156 60       RTS             

                                *** input a character from channel
.,F157 A5 99    LDA $99         get the input device number
.,F159 D0 0B    BNE $F166       if not the keyboard continue
                                the input device was the keyboard
.,F15B A5 D3    LDA $D3         get the cursor column
.,F15D 85 CA    STA $CA         set the input cursor column
.,F15F A5 D6    LDA $D6         get the cursor row
.,F161 85 C9    STA $C9         set the input cursor row
.,F163 4C 32 E6 JMP $E632       input from screen or keyboard
                                the input device was not the keyboard
.,F166 C9 03    CMP #$03        compare device number with screen
.,F168 D0 09    BNE $F173       if not screen continue
                                the input device was the screen
.,F16A 85 D0    STA $D0         input from keyboard or screen, $xx = screen,
                                $00 = keyboard
.,F16C A5 D5    LDA $D5         get current screen line length
.,F16E 85 C8    STA $C8         save input [EOL] pointer
.,F170 4C 32 E6 JMP $E632       input from screen or keyboard
                                the input device was not the screen
.,F173 B0 38    BCS $F1AD       if input device > screen go do IEC devices
                                the input device was < screen
.,F175 C9 02    CMP #$02        compare the device with the RS232 device
.,F177 F0 3F    BEQ $F1B8       if RS232 device go get a byte from the RS232 device
                                only the tape device left ..
.,F179 86 97    STX $97         save X
.,F17B 20 99 F1 JSR $F199       get a byte from tape
.,F17E B0 16    BCS $F196       if error just exit
.,F180 48       PHA             save the byte
.,F181 20 99 F1 JSR $F199       get the next byte from tape
.,F184 B0 0D    BCS $F193       if error just exit
.,F186 D0 05    BNE $F18D       if end reached ??
.,F188 A9 40    LDA #$40        set EOI
.,F18A 20 1C FE JSR $FE1C       OR into the serial status byte
.,F18D C6 A6    DEC $A6         decrement tape buffer index
.,F18F A6 97    LDX $97         restore X
.,F191 68       PLA             restore the saved byte
.,F192 60       RTS             
.,F193 AA       TAX             copy the error byte
.,F194 68       PLA             dump the saved byte
.,F195 8A       TXA             restore error byte
.,F196 A6 97    LDX $97         restore X
.,F198 60       RTS             

                                *** get byte from tape
.,F199 20 0D F8 JSR $F80D       bump tape pointer
.,F19C D0 0B    BNE $F1A9       if not end get next byte and exit
.,F19E 20 41 F8 JSR $F841       initiate tape read
.,F1A1 B0 11    BCS $F1B4       exit if error flagged
.,F1A3 A9 00    LDA #$00        clear A
.,F1A5 85 A6    STA $A6         clear tape buffer index
.,F1A7 F0 F0    BEQ $F199       loop, branch always
.,F1A9 B1 B2    LDA ($B2),Y     get next byte from buffer
.,F1AB 18       CLC             flag no error
.,F1AC 60       RTS             
                                input device was serial bus
.,F1AD A5 90    LDA $90         get the serial status byte
.,F1AF F0 04    BEQ $F1B5       if no errors flagged go input byte and return
.,F1B1 A9 0D    LDA #$0D        else return [EOL]
.,F1B3 18       CLC             flag no error
.,F1B4 60       RTS             
.,F1B5 4C 13 EE JMP $EE13       input byte from serial bus and return
                                input device was RS232 device
.,F1B8 20 4E F1 JSR $F14E       get byte from RS232 device
.,F1BB B0 F7    BCS $F1B4       branch if error, this doesn't get taken as the last
                                instruction in the get byte from RS232 device routine
                                is CLC ??
.,F1BD C9 00    CMP #$00        compare with null
.,F1BF D0 F2    BNE $F1B3       exit if not null
.,F1C1 AD 97 02 LDA $0297       get the RS232 status register
.,F1C4 29 60    AND #$60        mask 0xx0 0000, DSR detected and ??
.,F1C6 D0 E9    BNE $F1B1       if ?? return null
.,F1C8 F0 EE    BEQ $F1B8       else loop, branch always

                                *** output character to channel
.,F1CA 48       PHA             save the character to output
.,F1CB A5 9A    LDA $9A         get the output device number
.,F1CD C9 03    CMP #$03        compare the output device with the screen
.,F1CF D0 04    BNE $F1D5       if not the screen go ??
.,F1D1 68       PLA             else restore the output character
.,F1D2 4C 16 E7 JMP $E716       go output the character to the screen
.,F1D5 90 04    BCC $F1DB       if < screen go ??
.,F1D7 68       PLA             else restore the output character
.,F1D8 4C DD ED JMP $EDDD       go output the character to the serial bus
.,F1DB 4A       LSR             shift b0 of the device into Cb
.,F1DC 68       PLA             restore the output character

                                *** output the character to the cassette or RS232 device
.,F1DD 85 9E    STA $9E         save the character to the character buffer
.,F1DF 8A       TXA             copy X
.,F1E0 48       PHA             save X
.,F1E1 98       TYA             copy Y
.,F1E2 48       PHA             save Y
.,F1E3 90 23    BCC $F208       if Cb is clear it must be the RS232 device
                                output the character to the cassette
.,F1E5 20 0D F8 JSR $F80D       bump the tape pointer
.,F1E8 D0 0E    BNE $F1F8       if not end save next byte and exit
.,F1EA 20 64 F8 JSR $F864       initiate tape write
.,F1ED B0 0E    BCS $F1FD       exit if error
.,F1EF A9 02    LDA #$02        set data block type ??
.,F1F1 A0 00    LDY #$00        clear index
.,F1F3 91 B2    STA ($B2),Y     save type to buffer ??
.,F1F5 C8       INY             increment index
.,F1F6 84 A6    STY $A6         save tape buffer index
.,F1F8 A5 9E    LDA $9E         restore character from character buffer
.,F1FA 91 B2    STA ($B2),Y     save to buffer
.,F1FC 18       CLC             flag no error
.,F1FD 68       PLA             pull Y
.,F1FE A8       TAY             restore Y
.,F1FF 68       PLA             pull X
