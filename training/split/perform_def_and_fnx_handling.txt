# - Fully Commented Commodore 64 ROM Disassembly (English) - DEF and FNx handling: checks FNx syntax, scanning for parentheses and CHR$ tokens, sets FN/DEF flags, obtains variable and function addresses, validates numeric source types, prepares and pushes variable/execute pointers on the stack, calls DATA to fetch constants, and stores the execute pointer and variable pointer into the function. Contains the core flow for DEFINE/FNx evaluation and control transfer into user-defined function storage.

                                *** perform DEF
.,B3B3 20 E1 B3 JSR $B3E1       check FNx syntax
.,B3B6 20 A6 B3 JSR $B3A6       check not direct, back here if ok
.,B3B9 20 FA AE JSR $AEFA       scan for "(", else do syntax error then warm start
.,B3BC A9 80    LDA #$80        set flag for FNx
.,B3BE 85 10    STA $10         save subscript/FNx flag
.,B3C0 20 8B B0 JSR $B08B       get variable address
.,B3C3 20 8D AD JSR $AD8D       check if source is numeric, else do type mismatch
.,B3C6 20 F7 AE JSR $AEF7       scan for ")", else do syntax error then warm start
.,B3C9 A9 B2    LDA #$B2        get = token
.,B3CB 20 FF AE JSR $AEFF       scan for CHR$(A), else do syntax error then warm start
.,B3CE 48       PHA             push next character
.,B3CF A5 48    LDA $48         get current variable pointer high byte
.,B3D1 48       PHA             push it
.,B3D2 A5 47    LDA $47         get current variable pointer low byte
.,B3D4 48       PHA             push it
.,B3D5 A5 7B    LDA $7B         get BASIC execute pointer high byte
.,B3D7 48       PHA             push it
.,B3D8 A5 7A    LDA $7A         get BASIC execute pointer low byte
.,B3DA 48       PHA             push it
.,B3DB 20 F8 A8 JSR $A8F8       perform DATA
.,B3DE 4C 4F B4 JMP $B44F       put execute pointer and variable pointer into function
                                and return

                                *** check FNx syntax
.,B3E1 A9 A5    LDA #$A5        set FN token
.,B3E3 20 FF AE JSR $AEFF       scan for CHR$(A), else do syntax error then warm start
.,B3E6 09 80    ORA #$80        set FN flag bit
.,B3E8 85 10    STA $10         save FN name
.,B3EA 20 92 B0 JSR $B092       search for FN variable
.,B3ED 85 4E    STA $4E         save function pointer low byte
.,B3EF 84 4F    STY $4F         save function pointer high byte
.,B3F1 4C 8D AD JMP $AD8D       check if source is numeric and return, else do type
                                mismatch

                                *** Evaluate FNx
.,B3F4 20 E1 B3 JSR $B3E1       check FNx syntax
.,B3F7 A5 4F    LDA $4F         get function pointer high byte
.,B3F9 48       PHA             push it
.,B3FA A5 4E    LDA $4E         get function pointer low byte
.,B3FC 48       PHA             push it
.,B3FD 20 F1 AE JSR $AEF1       evaluate expression within parentheses
.,B400 20 8D AD JSR $AD8D       check if source is numeric, else do type mismatch
.,B403 68       PLA             pop function pointer low byte
.,B404 85 4E    STA $4E         restore it
.,B406 68       PLA             pop function pointer high byte
.,B407 85 4F    STA $4F         restore it
.,B409 A0 02    LDY #$02        index to variable pointer high byte
.,B40B B1 4E    LDA ($4E),Y     get variable address low byte
.,B40D 85 47    STA $47         save current variable pointer low byte
.,B40F AA       TAX             copy address low byte
.,B410 C8       INY             index to variable address high byte
.,B411 B1 4E    LDA ($4E),Y     get variable pointer high byte
.,B413 F0 99    BEQ $B3AE       branch if high byte zero
.,B415 85 48    STA $48         save current variable pointer high byte
.,B417 C8       INY             index to mantissa 3
                                now stack the function variable value before use
.,B418 B1 47    LDA ($47),Y     get byte from variable
.,B41A 48       PHA             stack it
.,B41B 88       DEY             decrement index
.,B41C 10 FA    BPL $B418       loop until variable stacked
.,B41E A4 48    LDY $48get current variable pointer high byte
.,B420 20 D4 BB JSR $BBD4       pack FAC1 into (XY)
.,B423 A5 7B    LDA $7B         get BASIC execute pointer high byte
.,B425 48       PHA             push it
.,B426 A5 7A    LDA $7A         get BASIC execute pointer low byte
.,B428 48       PHA             push it
.,B429 B1 4E    LDA ($4E),Y     get function execute pointer low byte
.,B42B 85 7A    STA $7A         save BASIC execute pointer low byte
.,B42D C8       INY             index to high byte
.,B42E B1 4E    LDA ($4E),Y     get function execute pointer high byte
.,B430 85 7B    STA $7B         save BASIC execute pointer high byte
.,B432 A5 48    LDA $48         get current variable pointer high byte
.,B434 48       PHA             push it
.,B435 A5 47    LDA $47         get current variable pointer low byte
.,B437 48       PHA             push it
.,B438 20 8A AD JSR $AD8A       evaluate expression and check is numeric, else do
                                type mismatch
.,B43B 68       PLA             pull variable address low byte
.,B43C 85 4E    STA $4E         save variable address low byte
.,B43E 68       PLA             pull variable address high byte
.,B43F 85 4F    STA $4F         save variable address high byte
.,B441 20 79 00 JSR $0079       scan memory
.,B444 F0 03    BEQ $B449       branch if null (should be [EOL] marker)
.,B446 4C 08 AF JMP $AF08       else syntax error then warm start

                                *** restore BASIC execute pointer and function variable from stack
.,B449 68       PLA             pull BASIC execute pointer low byte
.,B44A 85 7A    STA $7A         save BASIC execute pointer low byte
.,B44C 68       PLA             pull BASIC execute pointer high byte
.,B44D 85 7B    STA $7B         save BASIC execute pointer high byte
                                put execute pointer and variable pointer into function
.,B44F A0 00    LDY #$00        clear index
.,B451 68       PLA             pull BASIC execute pointer low byte
.,B452 91 4E    STA ($4E),Y     save to function
.,B454 68       PLA             pull BASIC execute pointer high byte
.,B455 C8       INY             increment index
.,B456 91 4E    STA ($4E),Y     save to function
.,B458 68       PLA             pull current variable address low byte
.,B459 C8       INY             increment index
.,B45A 91 4E    STA ($4E),Y     save to function
.,B45C 68       PLA             pull current variable address high byte
.,B45D C8       INY             increment index
.,B45E 91 4E    STA ($4E),Y     save to function
.,B460 68       PLA             pull ??
.,B461 C8       INY             increment index
.,B462 91 4E    STA ($4E),Y     save to function
.,B464 60       RTS             


---
Additional information can be found by searching:
- "str_destr_and_string_space_allocation" which expands on string allocation and STR$ uses (string/CHR$ tokens scanned during FNx/DEF parsing)
- "string_concatenation_and_descriptor_ops" which expands on descriptor layout used when FNx returns string values
