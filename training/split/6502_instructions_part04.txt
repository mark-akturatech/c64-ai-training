# 6502 Instructions by Type - Transfer, Stack, Decrements, Increments

          Instructions by Type
            Transfer Instructions
            Load, store, interregister transfer
            LDA .... load accumulator
            LDX .... load X
            LDY .... load Y
            STA .... store accumulator
            STX .... store X
            STY .... store Y
            TAX .... transfer accumulator to X
            TAY .... transfer accumulator to Y
            TSX .... transfer stack pointer to X
            TXA .... transfer X to accumulator
            TXS .... transfer X to stack pointer
            TYA .... transfer Y to accumulator
            Stack Instructions
            These instructions transfer the accumulator or status register
            (flags) to and from the stack. The processor stack is a last-in-
            first-out (LIFO) stack of 256 bytes length, implemented at addresses
            $0100 - $01FF. The stack grows down as new values are pushed onto it
            with the current insertion point maintained in the stack pointer
            register.
            (When a byte is pushed onto the stack, it will be stored in the
            address indicated by the value currently in the stack pointer, which
            will be then decremented by 1. Conversely, when a value is pulled
            from the stack, the stack pointer is incremented. The stack pointer
            is accessible by the TSX and TXS instructions.)
            PHA .... push accumulator
            PHP .... push processor status register (with break flag set)
            PLA .... pull accumulator
            PLP .... pull processor status register
            Decrements & Increments
            DEC .... decrement (memory)
            DEX .... decrement X
            DEY .... decrement Y
            INC .... increment (memory)
            INX .... increment X
            INY .... increment Y
            Arithmetic Operations
                                                               6502 Instruction Set
           ADC .... add with carry (prepare by CLC)
           SBC .... subtract with carry (prepare by SEC)
           See the Primer of 6502 Arithmetic Instructions below for details.
           Logical Operations
           AND .... and (with accumulator)
           EOR .... exclusive or (with accumulator)
           ORA .... (inclusive) or with accumulator
           Shift & Rotate Instructions
           All shift and rotate instructions preserve the bit shifted out in
           the carry flag.
           ASL .... arithmetic shift left (shifts in a zero bit on the right)
           LSR .... logical shift right (shifts in a zero bit on the left)
           ROL .... rotate left (shifts in carry bit on the right)
           ROR .... rotate right (shifts in carry bit on the left)
           Flag Instructions
           CLC .... clear carry
           CLD .... clear decimal (BCD arithmetics disabled)
           CLI .... clear interrupt disable
           CLV .... clear overflow
           SEC .... set carry
           SED .... set decimal (BCD arithmetics enabled)
           SEI .... set interrupt disable
           Comparisons
           Generally, comparison instructions subtract the operand from the
           given register without affecting that register. Flags are still set
           as with a normal subtraction and thus the relation of the two values
           becomes accessible by the Zero, Carry and Negative flags.
           (See the branch instructions below for how to evaluate flags.)
             Relation R âˆ’ Op      Z   C    N
             Register < Operand   0   0    sign bit of result
             Register = Operand   1   1    0
             Register > Operand   0   1    sign bit of result
           CMP .... compare (with accumulator)
           CPX .... compare with X
           CPY .... compare with Y
                                                               6502 Instruction Set
           Bit Test
           The BIT instruction is somewhat similar to the CMP instruction, but
           performs a bit-wise comparison between the contents of the
           accumulator and a memory location given as the operand.
           BIT performs a logical AND operation between the two values and sets
           the Zero flag according to the result. Additionally, bit #7 (sign-
