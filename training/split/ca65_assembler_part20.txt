# CA65 Assembler - Control Commands (.A16 .A8 .ADDR .ALIGN)

11. Control commands
Here's a list of all control commands and a description, what they do:

11.1 .A16
Valid only in 65816 mode. Assume the accumulator is 16 bit.

Note: This command will not emit any code, it will tell the assembler to create 16 bit operands for immediate accumulator addressing mode.

See also: .SMART

11.2 .A8
Valid only in 65816 mode. Assume the accumulator is 8 bit.

Note: This command will not emit any code, it will tell the assembler to create 8 bit operands for immediate accu addressing mode.

See also: .SMART

11.3 .ADDR
Define word sized data. In 6502 mode, this is an alias for .WORD and may be used for better readability if the data words are address values. In 65816 mode, the address is forced to be 16 bit wide to fit into the current segment. See also .FARADDR. The command must be followed by a sequence of (not necessarily constant) expressions.

Example:


        .addr   $0D00, $AF13, _Clear
  
See: .FARADDR, .WORD

11.4 .ALIGN
Align data to a given boundary. The command expects a constant integer argument in the range 1 ... 65536, plus an optional second argument in byte range. If there is a second argument, it is used as fill value, otherwise the value defined in the linker configuration file is used (the default for this value is zero).

.ALIGN will insert fill bytes, and the number of fill bytes depend of the final address of the segment. .ALIGN cannot insert a variable number of bytes, since that would break address calculations within the module. So each .ALIGN expects the segment to be aligned to a multiple of the alignment, because that allows the number of fill bytes to be calculated in advance by the assembler. You are therefore required to specify a matching alignment for the segment in the linker config. The linker will output a warning if the alignment of the segment is less than what is necessary to have a correct alignment in the object file. It will also emit a warning to inform about the number of bytes wasted for alignment.

Example:


        .align  256
  
Some unexpected behaviour might occur if there are multiple .ALIGN commands with different arguments. To allow the assembler to calculate the number of fill bytes in advance, the alignment of the segment must be a multiple of each of the alignment factors. This may result in unexpectedly large alignments for the segment within the module.

Example:


        .align  15
        .byte   15
        .align  18
        .byte   18
  
For the assembler to be able to align correctly, the segment must be aligned to the least common multiple of 15 and 18 which is 90. The assembler will calculate this automatically and will mark the segment with this value.

Unfortunately, the combined alignment may get rather large without the user knowing about it, wasting space in the final executable. If we add another alignment to the example above


        .align  15
        .byte   15
        .align  18
        .byte   18
        .align  251
        .byte   0
  
the assembler will force a segment alignment to the least common multiple of 15, 18 and 251 - which is 22590. To protect the user against errors, when the combined alignment is larger than the explicitly requested alignments, the assembler will issue a warning if it also exceeds 256. The command line option --large-alignment will disable this warning.

Please note that with only alignments that are a power of two, a warning will never occur, because the least common multiple of powers to the same base is always simply the larger one.

