# CA65 Assembler - Macros (C Style Macros)

Macros with parameters may also be useful:


.define DEBUG(message)  .out    message

        DEBUG   "Assembling include file #3"
Note that, while formal parameters have to be placed in parentheses, the actual argument used when invoking the macro should not be. The invoked arguments are separated by commas only; if parentheses are used by accident, they will become part of the replaced token.

If you wish to have an expression follow the macro invocation, the last parameter can be enclosed in curly braces {} to indicate the end of that argument.

Examples:


.define COMBINE(ta,tb,tc) ta+tb*10+tc*100

.word COMBINE 5,6,7      ; 5+6*10+7*100 = 765
.word COMBINE(5,6,7)     ; (5+6*10+7)*100 = 7200 ; incorrect use of parentheses
.word COMBINE 5,6,7+1    ; 5+6*10+7+1*100 = 172
.word COMBINE 5,6,{7}+1  ; 5+6*10+7*100+1 = 766 ; {} encloses the argument
.word COMBINE 5,6-2,7    ; 5+6-2*10+7*100 = 691
.word COMBINE 5,(6-2),7  ; 5+(6-2)*10+7*100 = 745
.word COMBINE 5,6,7+COMBINE 0,1,2    ; 5+6*10+7+0+1*10+2*100*100 = 20082
.word COMBINE 5,6,{7}+COMBINE 0,1,2  ; 5+6*10+7*100+0+1*10+2*100 = 975
With C macros it is common to enclose the results in parentheses to prevent unintended interactions with the text of the arguments, but additional care must be taken in this assembly context where parentheses may alter the meaning of a statement. In particular, indirect addressing modes may be accidentally implied:


.define DUO(ta,tb) (ta+(tb*10))

        lda DUO(5,4), Y         ; LDA (indirect), Y
        lda 0+DUO(5,4), Y       ; LDA absolute indexed, Y
12.8 Characters in macros
When using the -t option, characters are translated into the target character set of the specific machine. However, this happens as late as possible. This means that strings are translated if they are part of a .BYTE or .ASCIIZ command. Characters are translated as soon as they are used as part of an expression.

This behaviour is very intuitive outside of macros but may be confusing when doing more complex macros. If you compare characters against numeric values, be sure to take the translation into account.

12.9 Deleting macros
Macros can be deleted. This will not work if the macro that should be deleted is currently expanded as in the following non-working example:


.macro  notworking
        .delmacro       notworking
.endmacro

        notworking              ; Will not work
The commands to delete classic and define style macros differ. Classic macros can be deleted by use of .DELMACRO, while for .DEFINE style macros, .UNDEFINE must be used. Example:


.define value   1
.macro  mac
        .byte   2
.endmacro

        .byte   value           ; Emit one byte with value 1
        mac                     ; Emit another byte with value 2

.undefine value
.delmacro mac

        .byte   value           ; Error: Unknown identifier
        mac                     ; Error: Missing ":"
A separate command for .DEFINE style macros was necessary, because the name of such a macro is replaced by its replacement list on a very low level. To get the actual name, macro replacement has to be switched off when reading the argument to .UNDEFINE. This does also mean that the argument to .UNDEFINE is not allowed to come from another .DEFINE. All this is not necessary for classic macros, so having two different commands increases flexibility.

