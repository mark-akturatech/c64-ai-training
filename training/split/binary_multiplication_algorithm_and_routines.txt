# 6502 Multiplication and Division Algorithms - Source: llx.com - Schoolbook binary multiplication algorithm (add shifted multiplicand for each 1-bit of multiplier). Includes decimal vs. binary walkthrough; 1-byte by 1-byte routine producing 2-byte result (uses LSR on multiplier, conditional ADC, stairstep ROR into RESULT); 2-byte by 2-byte routine producing 4-byte result (shifts multiplier right across two bytes, conditional add into result high word, then stairstep rotates). Notes general result-width rule: bytes(result) = bytes(a) + bytes(b).


Multplying Arbitrary Numbers
----------------------------------------


A reasonable way to multiply arbitrary numbers is to do it the way
you learned in school, with pencil and paper.  Consider an example:


654
 x 321
 -----
654
 1308
1962
------
209934


If the steps are written out as an algorithm, it goes something like
this:


  * Set the answer to 0.

  * Repeat as many times as there are digits in the bottom number:


  * Remove the rightmost digit of the bottom number.

  * Multiply the top number by the digit just removed.

  * Add the result to the answer, shifted one more place to the left
      each time.


 The secret of binary multiplication is that it works exactly like
decimal multiplication, as long as you use the addition and
multiplication tables for binary digits:


+| 0  1      x| 0 1
--+-----     --+----
 0| 0  1      0| 0 0
 1| 1 10      1| 0 1


The algorithm in the binary case is slightly simpler than the decimal
algorithm:


  * Set the answer to 0.

  * Repeat as many times as there are bits in the bottom number:


  * Remove the rightmost bit of the bottom number.

  * If the bit removed was 1, add the top number to the answer,
      shifted one more place to the left each time.


Here's an example:


110
x 101
-----
  110
110
-----
11110


This is quite easy to turn into machine language - the only tricky
thing in the code below is that instead of shifting the added number to
the left, it shifts the answer one place to the right each time,
catching the lost bit in a memory location.  Here it is for one-byte
numbers:


LDA #0       ;Initialize RESULT to 0
        LDX #8       ;There are 8 bits in NUM2
L1      LSR NUM2     ;Get low bit of NUM2
        BCC L2       ;0 or 1?
        CLC          ;If 1, add NUM1
        ADC NUM1
L2      ROR A        ;"Stairstep" shift (catching carry from add)
        ROR RESULT
        DEX
        BNE L1
        STA RESULT+1


Note that though we were multiplying one-byte numbers, the result
requires two bytes.  The general rule for multiplication is that the
number of bytes in the result will be equal to the number of bytes in
the first number, plus the number of bytes in the second number.


The method is easily extendable to wider numbers.  Here's a routine
for multiplying two-byte numbers, giving a four-byte result:


LDA #0       ;Initialize RESULT to 0
        STA RESULT+2
        LDX #16      ;There are 16 bits in NUM2
L1      LSR NUM2+1   ;Get low bit of NUM2
        ROR NUM2
        BCC L2       ;0 or 1?
        TAY          ;If 1, add NUM1 (hi byte of RESULT is in A)
        CLC
        LDA NUM1
        ADC RESULT+2
        STA RESULT+2
        TYA
        ADC NUM1+1
L2      ROR A        ;"Stairstep" shift
        ROR RESULT+2
        ROR RESULT+1
        ROR RESULT
        DEX
        BNE L1
        STA RESULT+3


At this point it seems to be common for people to ask for additional
routines to multiply even wider numbers.  Rather than bloat this article
with even more routines for numbers of various sizes, I encourage readers
to look back over the algorithm just described and the examples that
implement it - once these are understood, writing additional routines is
straightforward.


---
Additional information can be found by searching:
- "multiply_by_constant_using_shifts_and_adds_asl_rol" which expands on Alternate approach when one factor is constant
- "one_byte_multiplication_speed_optimizations_and_table_lookup_intro" which expands on Optimized variants of 1-byte multiply and performance considerations
- "fast_multiplication_via_square_tables_and_page_aligned_lookup" which expands on Lookup-table based fast multiplication using square identities
- "signed_multiplication_and_division_strategies_and_wrappers" which expands on Adapting unsigned algorithms for signed operands
