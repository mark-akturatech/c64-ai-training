# ca65 Users Guide - Parametrized classic macros using .macro/.endmacro. Covers parameter substitution, multiple parameters separated by commas, allowing fewer or empty parameters, naming cautions (avoid a,x,y), and control commands for variable parameter lists (.IFBLANK/.IFNBLANK). Shows the ldaxy example demonstrating conditional emission based on which parameters are present. Describes .PARAMCOUNT (reports number of arguments including explicit empties) and the use of curly braces to group parameters that contain commas or parentheses.

12.3 Parametrized macros
When using macro parameters, macros can be even more useful:


.macro  inc16   addr
        clc
        lda     addr
        adc     #<$0001
        sta     addr
        lda     addr+1
        adc     #>$0001
        sta     addr+1
.endmacro
When calling the macro, you may give a parameter, and each occurrence of the name "addr" in the macro definition will be replaced by the given parameter. So


        inc16   $1000
will be expanded to


        clc
        lda     $1000
        adc     #<$0001
        sta     $1000
        lda     $1000+1
        adc     #>$0001
        sta     $1000+1
A macro may have more than one parameter, in this case, the parameters are separated by commas. You are free to give less parameters than the macro actually takes in the definition. You may also leave intermediate parameters empty. Empty parameters are replaced by empty space (that is, they are removed when the macro is expanded). If you have a look at our macro definition above, you will see, that replacing the "addr" parameter by nothing will lead to wrong code in most lines.

The names "a", "x" and "y" should be avoided for macro parameters, as these will usually conflict with the 6502 registers.

For writing macros with a variable parameter list, control commands are available:

.IFBLANK tests the rest of the line and returns true, if there are any tokens on the remainder of the line. Since empty parameters are replaced by nothing, this may be used to test if a given parameter is empty. .IFNBLANK tests the opposite.

Look at this example:


.macro  ldaxy   i, j, k
.ifnblank       i
        lda     #i
.endif
.ifnblank       j
        ldx     #j
.endif
.ifnblank       k
        ldy     #k
.endif
.endmacro
That macro may be called as follows:


        ldaxy   1, 2, 3         ; Load all three registers

        ldaxy   1, , 3          ; Load only a and y

        ldaxy   , , 3           ; Load y only
There's another helper command for determining which macro parameters are valid: .PARAMCOUNT. That command is replaced by the parameter count given, including explicitly empty parameters:


        ldaxy   1       ; .PARAMCOUNT = 1
        ldaxy   1,,3    ; .PARAMCOUNT = 3
        ldaxy   1,2     ; .PARAMCOUNT = 2
        ldaxy   1,      ; .PARAMCOUNT = 2
        ldaxy   1,2,3   ; .PARAMCOUNT = 3
Macro parameters may optionally be enclosed into curly braces. This allows the inclusion of tokens that would otherwise terminate the parameter (the comma in case of a macro parameter).


.macro  foo     arg1, arg2
        ...
.endmacro

        foo     ($00,x)         ; Two parameters passed
        foo     {($00,x)}       ; One parameter passed
In the first case, the macro is called with two parameters: '($00' and 'x)'. The comma is not passed to the macro, because it is part of the calling sequence, not the parameters.

In the second case, '($00,x)' is passed to the macro; this time, including the comma.


---
Additional information can be found by searching:
- "macros_intro_and_basic_no_params" which expands on Basic macros without parameters and simple expansion example
- "parameter_type_detection_match_functions" which expands on Detecting parameter types (.MATCH, .LEFT, .RIGHT) for different argument forms
- "recursive_macros_and_exitmacro" which expands on Using parameter tests in recursive macros and termination with .EXITMACRO
