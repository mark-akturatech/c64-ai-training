# - Fully Commented Commodore 64 ROM Disassembly (English) - Prepare for restoring CPU state and handle STOP/checksum finalization. Disables interrupts (SEI), disables Timer A interrupt and saves/reads VIA ICR ($DC0D). Manages copies count ($BE) and the receiver-bit temporary storage ($A7), decrementing and saving counts; if STOP conditions are met it calls the restore-for-STOP routine (JSR $FC93). Calls FB8E to copy the I/O start address to the buffer, clears the checksum index ($AB) and computes the checksum by iterating over buffer bytes (LDA ($AC),Y, EOR $AB) while incrementing the read/write pointer (JSR $FCDB/FCD1 checks). Compares the computed checksum with stored checksum ($BD) and sets the serial-status checksum-error bit (JSR $FE1C) on mismatch, then jumps to the common register-restore/exit ($FEBC).

.,FB48 A9 80    LDA #$80        
.,FB4A 85 AA    STA $AA         
.,FB4C 78       SEI             
.,FB4D A2 01    LDX #$01        disable timer A interrupt
.,FB4F 8E 0D DC STX $DC0D       save VIA 1 ICR
.,FB52 AE 0D DC LDX $DC0D       read VIA 1 ICR
.,FB55 A6 BE    LDX $BE         get copies count
.,FB57 CA       DEX             
.,FB58 30 02    BMI $FB5C       
.,FB5A 86 BE    STX $BE         save copies count
.,FB5C C6 A7    DEC $A7         decrement receiver input bit temporary storage
.,FB5E F0 08    BEQ $FB68       
.,FB60 A5 9E    LDA $9E         
.,FB62 D0 27    BNE $FB8B       if ?? restore registers and exit interrupt
.,FB64 85 BE    STA $BE         save copies count
.,FB66 F0 23    BEQ $FB8B       restore registers and exit interrupt, branch always
.,FB68 20 93 FC JSR $FC93       restore everything for STOP
.,FB6B 20 8E FB JSR $FB8E       copy I/O start address to buffer address
.,FB6E A0 00    LDY #$00        clear index
.,FB70 84 AB    STY $AB         clear checksum
.,FB72 B1 AC    LDA ($AC),Y     get byte from buffer
.,FB74 45 AB    EOR $AB         XOR with checksum
.,FB76 85 AB    STA $AB         save new checksum
.,FB78 20 DB FC JSR $FCDB       increment read/write pointer
.,FB7B 20 D1 FC JSR $FCD1       check read/write pointer, return Cb = 1 if pointer >= end
.,FB7E 90 F2    BCC $FB72       loop if not at end
.,FB80 A5 AB    LDA $AB         get computed checksum
.,FB82 45 BD    EOR $BD         compare with stored checksum ??
.,FB84 F0 05    BEQ $FB8B       if checksum ok restore registers and exit interrupt
.,FB86 A9 20    LDA #$20        else set checksum error
.,FB88 20 1C FE JSR $FE1C       OR into the serial status byte
.,FB8B 4C BC FE JMP $FEBC       restore registers and exit interrupt

---
Additional information can be found by searching:
- "verify_and_pointer_increment" which expands on Final pointer increment and possible early exit return here when read/write pointer handling finishes
- "store_character_entry_and_initial_timing" which expands on Shares the common register-restore/exit target ($FEBC) used by initial short-block and other early exits
