# 6502 Multiplication and Division Algorithms - Source: llx.com - Issues with signed values: LSR/ROR are not sign-preserving. Strategy for signed multiplication: determine result sign via EOR of high bytes (N flag), make both operands positive (two's complement negation), perform unsigned multiply, then apply sign to result (negate product if needed). Shows negation in A using EOR #$FF; ADC #1, and in memory by subtracting from zero; complete wrapper for signed 8-bit multiply around the earlier 1-byte routine. Signed division semantics: maintain dividend = divisor*quotient + remainder; two conventions described: floored division (remainder >= 0; quotient <= true quotient) and toward-zero division (quotient truncated toward zero; remainder has sign of dividend). Wrapper guidance for each convention after unsigned division.

But what about negative numbers?
----------------------------------------


Up to this point, all the code presented in this article has been
designed to work with unsigned (positive) numbers.  The simple
multiply-by-constant routines will also work with negative numbers,
but none of the others will.  Generally, if you see a LSR
or ROR instruction in one of the above routines, it will
give wrong results for negative numbers.


The problem is that the 6502's LSR and ROR
instructions are not sign-preserving.  They could be replaced by calls
to subroutines that perform the shift in a sign-preserving manner,
but that's probably not the best way to solve the problem.


The usual way to multiply signed numbers on the 6502 is to compute the
sign of the result first, then make both numbers positive, multiply
them, and apply the proper sign to the result.


Computing the sign of the result is very easy:  If the two original
numbers have the same sign, the result is positive, and if they have
different signs, the result is negative.  Assuming the usual
two's-complement representation of negative numbers, the sign of the
result can be found by EORing the high bytes of the two
numbers, which leaves the sign of the result in the high bit of the
accumulator and in the N flag.


To make a number positive, first examine its high bit.  If the high
bit is 0, no action is necessary, otherwise the number will have to
negated.  The best way to do this depends on where the number is stored
- if it's in the accumulator, the quickest way is this:


EOR #$FF
        CLC
        ADC #1


If the number to be negated is in a memory location, the quickest way
to negate it is to subtract it from 0.  For example, to negate a
two-byte number:


LDA #0
        SEC
        SBC NUM
        STA NUM
        LDA #0
        SBC NUM+1
        STA NUM+1


Putting it all together, here's a routine that multiplies two signed
one-byte numbers, using the one-byte multiply routine from above:


LDA NUM1     ;Compute sign of result
        EOR NUM2
        PHP          ;Save it on the stack
        LDA NUM1     ;Is NUM1 negative?
        BPL T1
        EOR #$FF     ;If so, make it positive
        CLC
        ADC #1
        STA NUM1
T1      LDA NUM2     ;Is NUM2 negative?
        BPL T2
        EOR #$FF     ;If so, make it positive
        CLC
        ADC #1
        STA NUM2
T2      JSR MUL1BYTE ;Do the unsigned multiplication
        PLP          ;Get sign of result
        BPL T3
        LDA #0       ;If negative, negate result
        SEC
        SBC RESULT
        STA RESULT
        LDA #0
        SBC RESULT+1
        STA RESULT+1
T3      ...


Doing signed division is a bit trickier.  The trick is to preserve the
following relation:


dividend = divisor * quotient + remainder


In the unsigned case there's only one way to arrange this:  The quotient
is always less than or equal to the true mathematical quotient (which may
have a fractional part), and the remainder is always positive.


In the signed case, the ability to have signed remainders makes the issue
murkier.  There are two conventions in common use:


  * Floored division:  If the true mathematical quotient has a
    fractional part, the same choices are made as in the unsigned case:
    the quotient is always less than (more negative) or equal to the
    mathematical quotient, and the remainder is always positive.

  * Toward-zero division:  If the true mathematical quotient
    has a fractional part, the fractional part is truncated (i.e. the
    quotient is rounded toward zero), and the remainder has the sign of the
    dividend.


Signed division is implemented with a wrapper around an unsigned
routine, as with signed multiplication, but the wrapper varies depending
on which convention you choose.  In either case, first compute the sign
of the quotient the same way you would compute the sign of the result of
a multiplication, and then make both numbers positive, and call the
unsigned division routine.  What happens next depends on which
convention you choose.


  * Floored division:  If the quotient should be negative,
    negate it.  Leave the remainder unchanged.

  * Toward-zero division:  If the quotient should be negative,
    negate it, and then add one to it.  If the quotient should be negative
    and the original dividend was negative, negate the
    remainder.


The code is analogous to the signed multiplication example above.


---
Additional information can be found by searching:
- "binary_multiplication_algorithm_and_routines" which expands on Unsigned multiply routine used inside signed wrapper
- "binary_division_algorithm_and_two_byte_routine" which expands on Unsigned division core used for signed division wrapper
- "multiply_by_constant_using_shifts_and_adds_asl_rol" which expands on Constant-multiply routines that also work with signed values
