# - Fully Commented Commodore 64 ROM Disassembly (English) - Main routine for reading input either from the screen or waiting for a keyboard key: saves registers, branches to keyboard wait if needed, reads the character under the cursor from screen memory, masks and tests it for 'no key', handles quote mode and open-quote toggling, advances cursor column, may convert a screen-read into a CR (end of input) and route output accordingly, restores registers and returns with the character in A.


                                *** input from screen or keyboard
.,E632 98       TYA             copy Y
.,E633 48       PHA             save Y
.,E634 8A       TXA             copy X
.,E635 48       PHA             save X
.,E636 A5 D0    LDA $D0         input from keyboard or screen, $xx = screen,
                                $00 = keyboard
.,E638 F0 93    BEQ $E5CD       if keyboard go wait for key
.,E63A A4 D3    LDY $D3         get the cursor column
.,E63C B1 D1    LDA ($D1),Y     get character from the current screen line
.,E63E 85 D7    STA $D7         save temporary last character
.,E640 29 3F    AND #$3F        mask key bits
.,E642 06 D7    ASL $D7         << temporary last character
.,E644 24 D7    BIT $D7         test it
.,E646 10 02    BPL $E64A       branch if not [NO KEY]
.,E648 09 80    ORA #$80        
.,E64A 90 04    BCC $E650       
.,E64C A6 D4    LDX $D4         get the cursor quote flag, $xx = quote, $00 = no quote
.,E64E D0 04    BNE $E654       if in quote mode go ??
.,E650 70 02    BVS $E654       
.,E652 09 40    ORA #$40        
.,E654 E6 D3    INC $D3         increment the cursor column
.,E656 20 84 E6 JSR $E684       if open quote toggle the cursor quote flag
.,E659 C4 C8    CPY $C8         compare ?? with input [EOL] pointer
.,E65B D0 17    BNE $E674       if not at line end go ??
.,E65D A9 00    LDA #$00        clear A
.,E65F 85 D0    STA $D0         clear input from keyboard or screen, $xx = screen,
                                $00 = keyboard
.,E661 A9 0D    LDA #$0D        set character [CR]
.,E663 A6 99    LDX $99         get the input device number
.,E665 E0 03    CPX #$03        compare the input device with the screen
.,E667 F0 06    BEQ $E66F       if screen go ??
.,E669 A6 9A    LDX $9A         get the output device number
.,E66B E0 03    CPX #$03        compare the output device with the screen
.,E66D F0 03    BEQ $E672       if screen go ??
.,E66F 20 16 E7 JSR $E716       output the character
.,E672 A9 0D    LDA #$0D        set character [CR]
.,E674 85 D7    STA $D7         save character
.,E676 68       PLA             pull X
.,E677 AA       TAX             restore X
.,E678 68       PLA             pull Y
.,E679 A8       TAY             restore Y
.,E67A A5 D7    LDA $D7         restore character
.,E67C C9 DE    CMP #$DE        
.,E67E D0 02    BNE $E682       
.,E680 A9 FF    LDA #$FF        
.,E682 18       CLC             flag ok
.,E683 60       RTS             

---
Additional information can be found by searching:
- "keyboard_buffer_read_and_shift" which expands on used when input source is the keyboard
- "toggle_open_quote_flag" which expands on calls the quote-toggle helper when encountering a " character
- "output_character_unshifted_and_control_dispatch" which expands on outputs characters or handles CR when required
