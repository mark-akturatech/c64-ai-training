# ********* - Steps to display a sprite: set Sprite Display Enable bits ($D015), set horizontal/vertical position registers ($D000-$D010), set Sprite Color Registers ($D027-$D02E), and optionally use expand registers for doubling size, collision detection registers for overlaps, priority register for foreground/background, and sprite multicolor mode ($D01C) with shared multicolor registers ($D025-$D026).

Because of the unusual layout of bitmap screen data on the 64, it is
fairly easy to transfer text characters to a bitmap screen, but it is
somewhat awkward finding the bit which affects the screen dot having a
given X-Y coordinate.  First, you must find the byte BY in which the
bit resides, and then you must POKE a vlue into that byte which turns
the desired bit on or off.  Given that the horizontal position of the
dot is stored in the variable X, its vertical position is in the
variable Y, and the base address of the bitmap area is in the variable
BASE, you can find the desired byte with the formula:

BY=BASE+40*(Y AND 256)+(Y AND 7)+(X AND 504)

To turn on the desired dot,

POKE BY, PEEK(BY) OR (2^(NOTX AND 7)

To turn the dot off,

POKE BY, PEEK(BY) AND (255-2^(NOTX AND 7))

The exponentation function takes a lot of time.  To speed things up,
an array can be created, each of whose elements corresponds to a power
of two.

FOR I=0 TO 7:BIT(I)=2^1:NEXT

After this is done, the expression 2^(I) can be replaced by BI(I).

The following sample program illustrates the bit-graphics concepts
explained above, and serves as a summary of that information.

10 FOR I=0 TO 7:BI(I)=2^I:NEXT: REM SET UP ARRAY OF POWERS OF 2 (BIT VALUE)
20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
30 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE
40 A$="":FOR I=1 TO 37:A$=A$+"C":NEXT:PRINT CHR$(19);
50 FOR I=1 TO 27:PRINTA$;:NEXT:POKE2023,PEEK(2022): REM SET COLOR MAP
60 A$="":FOR I=1 TO 27:A$=A$+"@":NEXT:FOR I=32 TO 63 STEP 2
70 POKE648,I:PRINT CHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLEAR HI-RES SCREEN
80 FORY=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM
90 X=INT(160+40*SIN(Y/10)): REM SINE WAVE SHAPE
100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504): REM FIND HI-RES BYTE
110 POKEBY,PEEK(BY)OR(BI(NOT X AND 7)):NEXT Y:REM POKE IN BIT VALUE
120 GOTO 120: REM LET IT STAY ON SCREEN

As you can see, using BASIC to draw in bit-graphics mode is somewhat
slow and tedious.  Machine language is much more suiable for
bit-graphics plotting.  For a program that lets you replace some BASIC
ommands with high-res drawing commands, see the article "Hi-Res
Graphics Made Simple," by Paul F. Schatz, in COMPUTE!'s First Book of
Commodore 64 Sound and Graphics.

There is a slightly lower resolution bitmap graphics mode available
which offers up to four colors per 8 by 8 dot matrix.  To enable this
mode, you must set the multicolor bit (Bit 4 of 53270 ($D016)) while
in bitmap graphics mode.  For more information on this mode, see the
entry for the multicolor enable bit.

Bit 6.  This bit of this register enables extended background color
mode.  This mode lets you select the background color of each text
character, as well as its foreground color.  It is able to increase
the number of background colors displayed, by reducing the number of
characters that can be shown on the screen.

Normally, 256 character shapes can be displayed on the screen.  You
can use them either by using the PRINT statement or by POKEing a
display code from 0 to 255 into screen memory.  If the POKEing method
is used, you must also POKE a color code from 0 to 15 into color
memory (for example, if you POKE 1024,1, and POKE 55296,1, a white A
appears in the top-left corner of the screen).

The background color of the screen is determined by Background Color
Register 0, and you can change this color by POKEing a new value to
that register, which is located at 53281 ($D021).  For example, POKE
53281,0 creates a black background.

When extended background color mode is activated, however, only the
first 64 shapes found in the table of the screen display codes can be
displayed on the screen.  This group includes the letters of the
alphabet, numerals, and punctuation marks.  If you try to print on the
screen a character having a higher display code, the shape displayed
will be from the first group of 64, but that character's background
will no longer be determined by the register at 53281 ($D021).
Instead, it will be determined by one of the other background color
registers.

When in extended background color mode, characters having display
codes 64- 127 will take their background color from register 1, and
location 53282 ($D022).  These characters include various SHIFTed
characters.  Those with codes 128-191 will have their background
colors determined by register 2, at 53283 ($D023).  These include the
reversed numbers, letters, and punctuation marks.  Finally, characters
with codes 192-255 will use register 4, at 53284 ($D024).  These are
the reversed graphics characters.

Let's try an experiment to see just how this works.  First, we will
put the codes for four different letters in screen memory:

FOR I=0 TO 3:POKE 1230+(I*8),I*64+I:POKE 55502+(I*8),1:NEXT

Four white letters should appear on the screen, an A, a shifted A, a

---
Additional information can be found by searching:
- "sprite_data_format_and_bit_patterns" which expands on Shape data must contain non-zero data for collisions/visibility
