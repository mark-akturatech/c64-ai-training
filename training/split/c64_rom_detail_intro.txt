# MACHINE - Commodore 64 ROM detail introduction. Explains purpose of ROM memory map for disassembly and understanding built-in subroutines, cautioning against relying on ROM subroutines for production code because they change between machines; recommends using kernal jump table ($FFD2, $FFE4, $FFE1, $FFC6, $FFC9, $FFCC) instead. References 'Mapping the Commodore 64' for deeper study.


Commodore 64:  ROM Detail
-------------------------

This type of ROM memory map is intended primarily for users who want to
"browse" through the inner logic of the computer.  It allows a user to
disassemble an area of interest, to see why the computer behaves in a certain
way.  With the use of this map, the user will be able to identify subroutines
that are called by the coding under study.

I recommend against using the ROM subroutines as part of your own programs.
They often don't do precisely what you want.  They change locations when you
move to a different machine.  With rare exceptions, you can probably write
better coding to do the job yourself.  Stick with the kernal jump table:
especially $FFD2 to output; $FFE4 to get input; $FFE1 to check the RUN/STOP
key; $FFC6 and $FFC9 to switch input and output respectively; and $FFCC to
restore normal input/output.  They are the same on all Commodore products.

[if you're looking for more in-depth information, you definitely should read
 "Mapping the Commodore 64", which should be available from where you got
 this e-text.  -wf]


---
Additional information can be found by searching:
- "c64_rom_vectors_a000_to_ba80" which expands on list of ROM routine addresses and brief descriptions
