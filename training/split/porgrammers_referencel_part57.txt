# C64 PRG Chapter 5 - Kernal: MEMTOP, OPEN, PLOT, RAMTAS

  306   BASIC TO MACHINE LANGUAGE
~


  USING MACHINE LANGUAGE FROM BASIC

    There are several methods of using BASIC and machine language on the
  Commodore 64, including special statements as part of CBM BASIC as well
  as key locations in the machine. There are five main ways to use machine
  language routines from BASIC on the Commodore 64. They are:


                1) The BASIC SYS statement
                2) The BASIC USR function
                3) Changing one of the RAM I/O vectors
                4) Changing one of the RAM interrupt vectors
                5) Changing the CHRGET routine


    1) The BASIC statement SYS X causes a JUMP to a machine language
       subroutine located at address X. The routine must end with an RTS
       (ReTurn from Subroutine) instruction. This will transfer control
       back to BASIC.
         Parameters are generally passed between the machine language
       routine and the BASIC program using the BASIC PEEK and POKE
       statements, and their machine language equivalents.
         The SYS command is the most useful method of combining BASIC with
       machine language. PEEKs and POKEs make multiple parameter passing
       easy. There can be many SYS statements in a program, each to a
       different (or even the same) machine language routine.

    2) The BASIC function USR(X) transfers control to the machine language
       subroutine located at the address stored in locations 785 and 786.
       (The address is stored in standard low-byte/high-byte format.) The
       value X is evaluated and passed to the machine language subroutine
       through floating point accumulator #1, located beginning at address
       $61 (see memory map for more details). A value may be returned back
       to the BASIC program by placing it in the floating point
       accumulator. The machine language routine must end with an RTS
       instruction to return to BASIC.
         This statement is different from the SYS, because you have to set
       up an indirect vector. Also different is the format through which
       the variable is passed (floating point format). The indirect vector
       must be changed if more than one machine language routine is used.



                                            BASIC TO MACHINE LANGUAGE   307
~


    3) Any of the inpUt/OUtPUT or BASIC internal routines accessed through
       the vector table located on page 3 (see ADDRESSING MODES, ZERO PAGE)
       can be replaced, or amended by user code. Each 2-byte vector
       consists of a low byte and a high byte address which is used by the
       operating system.
         The KERNAL VECTOR routine is the most reliable way to change any
       of the vectors, but a single vector can be changed by POKES. A new
       vector will point to a user prepared routine which is meant to
       replace or augment the standard system routine. When the appropriate
       BASIC command is executed, the user routine will be executed. If
       after executing the user routine, it is necessary to execute the
       normal system routine, the user program must JMP (JUMP) to the
       address formerly contained in the vector. If not, the routine must
       end with a RTS to transfer control back to BASIC.

    4) The HARDWARE INTERRUPT (IRQ) VECTOR can be changed. Every 1/60th of
       a second, the operating system transfers control to the routine
       specified by this vector. The KERNAL normally uses this for timing,
       keyboard scanning, etc. If this technique is used, you should always
       transfer control to the normal IRQ handling routine, unless the
       replacement routine is prepared to handle the CIA chip. (REMEMBER to
       end the routine with an RTI (ReTurn from Interrupt) if the CIA is
       handled by the routine).
         This method is useful for tasks which must happen concurrently
       with a BASIC program, but has the drawback of being more difficult.

  +-----------------------------------------------------------------------+
  | NOTE: ALWAYS DISABLE INTERRUPTS BEFORE CHANGING THIS VECTOR!          |
  +-----------------------------------------------------------------------+

    5) The CHRGET routine is used by BASIC to get each character/token.
       This makes it simple to add new BASIC commands. Naturally, each new
       command must be executed by a user written machine language
       subroutine. A common way to use this method is to specify a
       character (@ for example) which will occur before any of the new
       commands. The new CHRGET routine will search for the special
       character. If none is present, control is passed to the normal BASIC
       CHRGET routine. If the special character is present, the new command
       is interpreted and executed by your machine language program. This
       minimizes the extra execution time added by the need to search for
       additional commands. This technique is often called a wedge.


  308   BASIC TO MACHINE LANGUAGE
~


  WHERE TO PUT MACHINE LANGUAGE ROUTINES

    The best place for machine language routines on the Commodore 64 is
  from $C000-$CFFF, assuming the routines are smaller than 4K bytes long.
  This section of memory is not disturbed by BASIC.
    If for some reason it's not possible or desirable to put the machine
  language routine at $C000, for instance if the routine is larger than 4K
  bytes, it then becomes necessary to reserve an area at the top of memory
  from BASIC for the routine. The top of memory is normally $9FFF. The top
  of memory can be changed through the KERNAL routine MEMTOP, or by the
  following BASIC statements:

    10 POKE51,L:POKE52,H:POKE55,1:POKE56,H:CLR

  Where H and L are the high and low portions, respectively, of the new
  top of memory. For example, to reserve the area from $9000 to $9FFF for
  machine language, use the following:

    10 POKE5110:POKE52,144:POKE5510:POKE56,144:CLR


  HOW TO ENTER MACHINE LANGUAGE

    There are 3 common methods to add the machine language programs to a
  BASIC program. They are:

  1) DATA STATEMENTS:

    By READing DATA statements, and POKEing the values into memory at the
  start of the program, machine language routines can be added. This is the
  easiest method. No special methods are needed to save the two parts of
  the program, and it is fairly easy to debug. The drawbacks include taking
  up more memory space, and the wait while the program is POKED in.
  Therefore, this method is better for smaller routines.

  EXAMPLE:

  10 RESTORE:FORX=1T09:READA:POKE12*4096+X,A:NEXT
  .
  BASIC PROGRAM
  .
  1000 DATA 161,1,204,204,204,204,204,204,96

                                            BASIC TO MACHINE LANGUAGE   309
~


  2) MACHINE LANGUAGE MONITOR (64MON):

    This program allows you to enter a program in either HEX or SYMBOLIC
  codes, and save the portion of memory the program is in. Advantages of
  this method include easier entry of the machine language routines,
  debugging aids, and a much faster means of saving and loading. The
  drawback to this method is that it generally requires the BASIC program
  to load the machine language routine from tape or disk when it is
  started. (For more details on 64MON see the machine language section.)

  EXAMPLE:

    The following is an example of a BASIC program using a machine language
  routine prepared by 64MON. The routine is stored on tape:

    10 IF FLAG=L THEN 20
    15 FLAG=1:LOAD"MACHINE LANGUAGE ROUTINE NAME",1,1
    20
    .
    .
    REST OF BASIC PROGRAM


  3) EDITOR/ASSEMBLER PACKAGE:

    Advantages are similar to using a machine language monitor, but
  programs are even easier to enter. Disadvantages are also similar to the
  use of a machine language monitor.


  COMMODORE 64 MEMORY MAP

             HEX        DECIMAL
   LABEL   ADDRESS      LOCATION               DESCRIPTION
  -------------------------------------------------------------------------

  D6510   0000            0        6510 On-Chip Data-Direction Register
  R6510   0001            1        6510 On-Chip 8-Bit Input/Output Register
          0002            2        Unused
  ADRAY1  0003-0004       3-4      Jump Vector: Convert Floating-Integer



  310   BASIC TO MACHINE LANGUAGE
~


             HEX        DECIMAL
   LABEL   ADDRESS      LOCATION               DESCRIPTION
  -------------------------------------------------------------------------

  ADRAY2  0005-0006       5-6      Jump Vector: Convert Integer--Floating
  CHARAC  0007            7        Search Character
  ENDCHR  0008            8        Flag: Scan for Quote at End of String
  TRMPOS  0009            9        Screen Column From Last TAB
  VERCK   000A           10        Flag: 0 = Load, 1 = Verify
  COUNT   000B           11        Input Buffer Pointer / No. of Subscripts
  DIMFLG  000C           12        Flag: Default Array DiMension
  VALTYP  000D           13        Data Type: $FF = String, $00 = Numeric
  INTFLG  000E           14        Data Type: $80 = Integer, $00 = Floating
  GARBFL  000F           15        Flag: DATA scan/LIST quote/Garbage Coll
  SUBFLG  0010           16        Flag: Subscript Ref / User Function Call
  INPFLG  0011           17        Flag: $00 = INPUT, $40 = GET, $98 = READ
  TANSGN  0012           18        Flag TAN sign / Comparison Result
          0013           19        Flag: INPUT Prompt
  LINNUM  0014-0015      20-21     Temp: Integer Value
  TEMPPT  0016           22        Pointer Temporary String
  LASTPT  0017-0018      23-24     Last Temp String Address
  TEMPST  0019-0021      25-33     Stack for Temporary Strings
  INDEX   0022-0025      34-37     Utility Pointer Area

  INDEX1  0022-0023      34-35     First Utility Pointer.
  INDEX2  0024-0025      36-37     Second Utility Pointer.

  RESHO   0026-002A      38-42     Floating-Point Product of Multiply
  TXTTAB  002B-002C      43-44     Pointer: Start of BASIC Text
  VARTAB  002D-002E      45-46     Pointer: Start of BASIC Variables
  ARYTAB  002F-0030      47-48     Pointer: Start of BASIC Arrays
  STREND  0031-0032      49-50     Pointer End of BASIC Arrays (+1)
  FRETOP  0033-0034      51-52     Pointer: Bottom of String Storage
  FRESPC  0035-0036      53-54     Utility String Pointer
  MEMSIZ  0037-0038      55-56     Pointer: Highest Address Used by BASIC
  CURLIN  0039-003A      57-58     Current BASIC Line Number
  OLDLIN  003B-003C      59-60     Previous BASIC Line Number
  OLDTXT  003D-003E      61-62     Pointer: BASIC Statement for CONT
  DATLIN  003F-0040      63-64     Current DATA Line Number
  DATPTR  0041-0042      65-66     Pointer: Current DATA Item Address
  INPPTR  0043-0044      67-68     Vector: INPUT Routine
  VARNAM  0045-0046      69-70     Current BASIC Variable Name

                                            BASIC TO MACHINE LANGUAGE   311
~


             HEX        DECIMAL
   LABEL   ADDRESS      LOCATION               DESCRIPTION
  -------------------------------------------------------------------------

  VARPNT  0047-0048      71-72     Pointer: Current BASIC Variable Data
  FORPNT  0049-004A      73-74     Pointer: Index Variable for FOR/NEXT
          004B-0060      75-96     Temp Pointer / Data Area

  VARTXT  004B-004C      75-76     Temporary storage for TXTPTR during
                                     READ, INPUT and GET.
  OPMASK  004D           77        Mask used during FRMEVL.
  TEMPF3  004E-0052      78-82     Temporary storage for FLPT value.
  FOUR6   0053           83        Length of String Variable during Garbage
                                     collection.
  JMPER   0054-0056      84-86     Jump Vector used in Function Evaluation-
                                     JMP followed by Address ($4C,$LB,$MB).
  TEMPF1  0057-005B      87-91     Temporary storage for FLPT value.
  TEMPF2  005C-0060      92-96     Temporary storage for FLPT value.
  FACEXP  0061           97        Floating-Point Accumulator #1: Exponent
  FACHO   0062-0065      98-101    Floating Accum. #1: Mantissa
  FACSGN  0066          102        Floating Accum. #1: Sign
  SGNFLG  0067          103        Pointer: Series Evaluation Constant
  BITS    0068          104        Floating Accum. #1: Overflow Digit
  ARGEXP  0069          105        Floating-Point Accumulator #2: Exponent
  ARGHO   006A-006D     106-109    Floating Accum. #2: Mantissa
  ARGSGN  006E          110        Floating Accum. #2: Sign
  ARISGN  006F          111        Sign Comparison Result: Accum. # 1 vs #2
  FACOV   0070          112        Floating Accum. #1. Low-Order (Rounding)
  FBUFPT  0071-0072     113-114    Pointer: Cassette Buffer
  CHRGET  0073-008A     115-138    Subroutine: Get Next Byte of BASIC Text

  CHRGOT  0079          121        Entry to Get Same Byte of Text Again
  TXTPTR  007A-007B     122-123    Pointer: Current Byte of BASIC Text

  RNDX    008B-008F     139-143    Floating RND Function Seed Value
  STATUS  0090          144        Kernal I/O Status Word: ST
  STKEY   0091          145        Flag: STOP key / RVS key
  SVXT    0092          146        Timing Constant for Tape
  VERCK   0093          147        Flag: 0 = Load, 1 = Verify
  C3PO    0094          148        Flag: Serial Bus-Output Char. Buffered
  BSOUR   0095          149        Buffered Character for Serial Bus
  SYNO    0096          150        Cassette Sync No.

