# ********* - Sprite system overview: eight sprites (0-7), each 24x21 dots, shapes come from 63-byte blocks pointed to by Sprite Data Pointers located in the last eight bytes of screen memory (default $07F8-$07FF). Pointer value * 64 gives address of sprite data (within VIC-II addressable 16K block).

the whole screen display down by from 1 to 7 dot spaces.  Stepping
through the values 1 to 7 allows you to smoothly make the transition
from having a character appear in one row on the screen to having it
appear in the next row.  To demonstrate this, type in the following
sample program, LIST it, and RUN.

10 FOR I= 1 TO 50:FOR J=0 TO 7
20 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I
30 FOR I= 1 TO 50:FOR J=7 TO 0 STEP-1
40 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I

As you can see, after the display has moved seven dot positions up or
down, it starts over at its original position.  In order to continue
the scroll, you must do a coarse scroll every time the value of the
scroll bits goes from 7 to 0, or from 0 to 7.  This is accomplished by
moving the display data for each line by 40 bytes in either direction,
overwriting the data for the last line, and introducing a line of data
at the opposite end of screen memory to replace it.  Obviously, ony a
machine language program can move all of these lines quickly enough to
maintain the effect of smooth motion.  The following BASIC program,
however, will give you an iea of what vertical fine scrolling is like:

10 POKE 53281,0:PRINTCHR$(5);CHR$(147)
20 FORI=1 TO 27:
30 PRINTTAB(15)CHR$(145)"            ":POKE 53265,PEEK(53265)AND248
40 WAIT53265,128:PRINTTAB(15)"I'M FALLING"
50 FOR J=1 TO 7
60 POKE53265,(PEEK(53265)AND248)+J
70 FORK=1TO50
80 NEXT K,J,I:RUN

Bit 3.  This bit register allows you to select either the normal
25-line text display (by setting the bit to 1), or a shortened 24-row
display (by resetting that bit to 0).  This shortened display is
created by extending the border to overlap the top or bottom row.  The
characters in these rows are still there; they are just covered up.

The shortened display is designed to aid vertical fine scrolling.  It
covers up the line into which new screen data is introduced, so that
the viewer does not see the new data being moved into place.

However, unlink the register at 53270 ($D016) which shortens the
screen by one character space on either side to aid horizontal
scrolling in either direction, this register can blank only one
vertical line at a time.  In order to compensate, it blanks the top
line when the three scroll bits in this register are set to 0, and
shifts the blanking one scan line at a time as the value of thee bits
increases.  Thus the bottom line is totally blanked when these bits
are set to 7.

Bit 4.  Bit 4 of this register controls the screen blanking feature.
When this bit is set to 0, no data can be displayed on the screen.
Instead, the whole screen will be filled with the color of the frame
(which is controlled by th eBorder Color Register at 53280 ($D020)).

Screen blanking is useful because of the way in which the VIC-II chip
interacts with the 6510 microprocessor.  Since the VIC-II and the 6510
both have to address the same memory, they must share the system data
bus.  Sharing the data bus means that they must take turns whenever
they want to address memory.

The VIC-II chip was designed so that it fetches most of the data it
needs during the part of the cycle in which the 6510 is not using the
data bus.  But certain operations, such as reading the 40 screen codes
needed for each line of text from video mmeory, or fetching sprite
data, require that the VIC-II chip get data at a faster rate than is
possible just by using the off half of the 6510 cycle.

Thus, the VIC-II chip must delay the 6510 for a short amount of time
while it is using the data bus to gather display information for text
or bitmap graphics, and must delay it a little more if sprites are
also enabled.  When you set the screen blanking bit to 0, these delays
are eliminated, and the 6510 processor is allowed to run at its full
speed.  This speeds up any processing task a little.

To demonstrate this, run the following short program.  As you will
see, leaving the screen on makes the processor run about 7 percent
slower than when you turn it off.  If you perform the same timing test
on the VIC-20, you will find that it runs at the same speed with its
screen on as the 64 does with its screen off.  And the same test on a
PET will run substantially slower.

10 PRINT CHR$(147);TAB(13);"TIMING TEST":PRINT:TI$="000000":GOTO 30
20 FOR I=1 TO 10000:NEXT I:RETURN
30 GOSUB 20:DISPLAY=TI
40 POKE 53265,11:TI$="000000"
50 GOSUB 20:NOSCREEN=TI:POKE 53265,27
60 PRINT "THE LOOP TOOK";DISPLAY;" JIFFIES"
70 PRINT "WITH NO SCREEN BLANKING":PRINT
80 PRINT "THE LOOP TOOK";NOSCREEN;" JIFFIES"
90 PRINT "WITH SCREEN BLANKING":PRINT
100 PRINT "SCREEN BLANKING MAKE THE PROCESSOR"
110 PRINT "GO";DISPLAY/NOSCREEN*100-100;"PERCENT FASTER"

The above explanation accounts for the screen being turned off during
tape read and write operations.  The timing of these operations is
rather critical, and would be affected by even the relatively small
delay caused by the video chip.  It also explains why the 64 has
difficulty loading programs from an unmodified 1540 Disk Drive, since
the 1540 was set up to transfer data from the VIC-20, which does not

---
Additional information can be found by searching:
- "sprite_data_format_and_bit_patterns" which expands on How sprite shape bytes map to dots
- "sprite_position_registers_and_msb_handling" which expands on Sprite placement using horizontal/vertical registers and MSB register
