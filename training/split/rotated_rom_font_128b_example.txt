# Kick Assembler - A submitted 128-byte font example that rotates the ROM font 90 degrees. Shows .segment Main [min=$0801, max=$0880-2, outPrg="out.prg"] .label SCREEN = $400 .label CHARGEN = $d000 .label CHARSET = $3000 and code with BasicUpstart placements and character/pixel loops. Illustrates tight size constraint and use of labels/constants.

but you can allow overlap with the 'allowOverlap' parameter. This is useful if you want to patch files. Here is an
example where the file "base.prg" is applied two changes and saved to the file "patched.prg":
// Setup
.file [name="patched.prg", segments="Base,Patch", allowOverlap]
.segmentdef Base [prgFiles="data/base.prg"]
.segmentdef Patch []
// Patch Code
.segment Patch
*=$3802 "Insert jmp"
jmp $3fe0
*=$38c2 "Insert lda #$ff"
lda #$ff

The memory map looks like this:
Base-segment:
$3800-$39ff base.prg
Patch-segment:
$3802-$3804 Insert jmp
$38c2-$38c3 Insert lda #$ff

In the above example we have a base segment with the original file and a patch segment with the modifications. They are combined in the intermediate segment generated by the file directive which has the allowOverlap
parameter set.
Overlapping blocks are cut so the byte from the block with the highest priority are returned. The latest added
blocks wins so since the 'Patch' segment lies after 'Base' in the segments list the patch code is chosen.

10.13. Segment Modifiers
The memory block of a segment can be modified before it is passed on to its consumers. A segment-modifier
takes a list of memory blocks as input and outputs a modified list of memory blocks.
The build in 'BasicUpstart' modifier adds a memory block in $0801 with a basic upstart program that jumps
to a given address:

50

Segments

.file [name="test.prg", segments="Code"]
.segment Code [start=$8000, modify="BasicUpstart", _start=$8000]
inc $d020
jmp *-3

The 'modify' parameter assigns the 'BasicUpstart' modifier. As a convention, arguments to the modifier has a
_ appended in front, so '_start' is an argument for the BasicUpstart modifier.
Users can write their own modifiers as plug-ins (Crunchers etc.) as shown in the plug-in chapter.
Here is a list of build in segment modifiers:

Table 10.1. Build in modifiers
Name

Parameters

Description

---
Additional information can be found by searching:
- "segment_boundaries_min_max_and_fill" which expands on constraints and fill options for enforcing sizes
