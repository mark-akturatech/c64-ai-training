# CA65 Assembler - Macros (Introduction, Without Parameters, Parametrized)

12. Macros
12.1 Introduction
Macros may be thought of as "parametrized super instructions". Macros are sequences of tokens that have a name. If that name is used in the source file, the macro is "expanded", that is, it is replaced by the tokens that were specified when the macro was defined.

12.2 Macros without parameters
In its simplest form, a macro does not have parameters. Here's an example:


.macro  asr             ; Arithmetic shift right
        cmp     #$80    ; Put bit 7 into carry
        ror             ; Rotate right with carry
.endmacro
The macro above consists of two real instructions, that are inserted into the code, whenever the macro is expanded. Macro expansion is simply done by using the name, like this:


        lda     $2010
        asr
        sta     $2010
12.3 Parametrized macros
When using macro parameters, macros can be even more useful:


.macro  inc16   addr
        clc
        lda     addr
        adc     #<$0001
        sta     addr
        lda     addr+1
        adc     #>$0001
        sta     addr+1
.endmacro
When calling the macro, you may give a parameter, and each occurrence of the name "addr" in the macro definition will be replaced by the given parameter. So


        inc16   $1000
will be expanded to


        clc
        lda     $1000
        adc     #<$0001
        sta     $1000
        lda     $1000+1
        adc     #>$0001
        sta     $1000+1
A macro may have more than one parameter, in this case, the parameters are separated by commas. You are free to give less parameters than the macro actually takes in the definition. You may also leave intermediate parameters empty. Empty parameters are replaced by empty space (that is, they are removed when the macro is expanded). If you have a look at our macro definition above, you will see, that replacing the "addr" parameter by nothing will lead to wrong code in most lines.

The names "a", "x" and "y" should be avoided for macro parameters, as these will usually conflict with the 6502 registers.

For writing macros with a variable parameter list, control commands are available:

.IFBLANK tests the rest of the line and returns true, if there are any tokens on the remainder of the line. Since empty parameters are replaced by nothing, this may be used to test if a given parameter is empty. .IFNBLANK tests the opposite.

Look at this example:


.macro  ldaxy   i, j, k
.ifnblank       i
        lda     #i
.endif
.ifnblank       j
        ldx     #j
.endif
.ifnblank       k
        ldy     #k
.endif
.endmacro
That macro may be called as follows:


        ldaxy   1, 2, 3         ; Load all three registers

        ldaxy   1, , 3          ; Load only a and y

        ldaxy   , , 3           ; Load y only
There's another helper command for determining which macro parameters are valid: .PARAMCOUNT. That command is replaced by the parameter count given, including explicitly empty parameters:


        ldaxy   1       ; .PARAMCOUNT = 1
        ldaxy   1,,3    ; .PARAMCOUNT = 3
        ldaxy   1,2     ; .PARAMCOUNT = 2
        ldaxy   1,      ; .PARAMCOUNT = 2
        ldaxy   1,2,3   ; .PARAMCOUNT = 3
Macro parameters may optionally be enclosed into curly braces. This allows the inclusion of tokens that would otherwise terminate the parameter (the comma in case of a macro parameter).


.macro  foo     arg1, arg2
        ...
.endmacro

        foo     ($00,x)         ; Two parameters passed
        foo     {($00,x)}       ; One parameter passed
In the first case, the macro is called with two parameters: '($00' and 'x)'. The comma is not passed to the macro, because it is part of the calling sequence, not the parameters.

In the second case, '($00,x)' is passed to the macro; this time, including the comma.

