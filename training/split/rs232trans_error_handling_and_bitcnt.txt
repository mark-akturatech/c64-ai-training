# - Fully Commented Commodore 64 KERNAL ROM Disassembly (English, "CBM") - Transmitter error handling and BITCNT: RST... error labels (DSRERR/CTSERR) update RSSTAT, OENABL manipulates D2ICR and ENABL to manage NMIs for timer T1, and BITCNT calculates actual number of bits to send (taking into account 6551 M51CTR settings) to return #bits+1. Provides support for 7/8/6/5 bit words depending on M51CTR.

                                ;   RETURNS #OF BITS+1
                                ;
.,EF4A A2 09    LDX #$09        BITCNT LDX #9          ;CALC WORD LENGTH
.,EF4C A9 20    LDA #$20               LDA #$20
.,EF4E 2C 93 02 BIT $0293              BIT M51CTR
.,EF51 F0 01    BEQ $EF54              BEQ BIT010
.,EF53 CA       DEX                    DEX             ;BIT 5 HIGH IS A 7 OR 5
.,EF54 50 02    BVC $EF58       BIT010 BVC BIT020
.,EF56 CA       DEX                    DEX             ;BIT 6 HIGH IS A 6 OR 5
.,EF57 CA       DEX                    DEX
.,EF58 60       RTS             BIT020 RTS
                                .END
                                .LIB   RS232RCVR
                                ; RSRCVR - NMI ROUTINE TO COLLECT
                                ;  DATA INTO BYTES
                                ;
                                ; RSR 8/18/80
                                ;
                                ; VARIABLES USED
                                ;   INBIT - INPUT BIT VALUE
                                ;   BITCI - BIT COUNT IN
                                ;   RINONE - FLAG FOR START BIT CHECK <>0 START BIT
                                ;   RIDATA - BYTE INPUT BUFFER
                                ;   RIPRTY - HOLDS BYTE INPUT PARITY
                                ;   RIBUF - INDIRECT POINTER TO DATA BUFFER
                                ;   RIDBE - INPUT BUFFER INDEX TO END
                                ;   RIDBS - INPUT BUFFER POINTER TO START
                                ;   IF RIDBE=RIDBS THEN INPUT BUFFER EMPTY
                                ;
.,EF59 A6 A9    LDX $A9         RSRCVR LDX RINONE      ;CHECK FOR START BIT
.,EF5B D0 33    BNE $EF90              BNE RSRTRT      ;WAS START BIT
                                ;
.,EF5D C6 A8    DEC $A8                DEC BITCI       ;CHECK WHERE WE ARE IN INPUT...
.,EF5F F0 36    BEQ $EF97              BEQ RSR030      ;HAVE A FULL BYTE
.,EF61 30 0D    BMI $EF70              BMI RSR020      ;GETTING STOP BITS
                                ;
                                ; CALC PARITY
                                ;
.,EF63 A5 A7    LDA $A7                LDA INBIT       ;GET DATA UP
.,EF65 45 AB    EOR $AB                EOR RIPRTY      ;CALC NEW PARITY
.,EF67 85 AB    STA $AB                STA RIPRTY
                                ;
                                ; SHIFT DATA BIT IN
                                ;
.,EF69 46 A7    LSR $A7                LSR INBIT       ;IN BIT POS 0
.,EF6B 66 AA    ROR $AA                ROR RIDATA      ;C INTO DATA
                                ;
                                ; EXIT
                                ;
.,EF6D 60       RTS             RSREXT RTS
                                ; HAVE STOP BIT, SO STORE IN BUFFER
                                ;
.,EF6E C6 A8    DEC $A8         RSR018 DEC BITCI       ;NO PARITY, DEC SO CHECK WORKS
.,EF70 A5 A7    LDA $A7         RSR020 LDA INBIT       ;GET DATA...
.,EF72 F0 67    BEQ $EFDB              BEQ RSR060      ;...ZERO, AN ERROR?
                                ;
.,EF74 AD 93 02 LDA $0293              LDA M51CTR      ;CHECK FOR CORRECT # OF STOP BITS
.,EF77 0A       ASL                    ASL A           ;CARRY TELL HOW MAY STOP BITS
.,EF78 A9 01    LDA #$01               LDA #01
.,EF7A 65 A8    ADC $A8                ADC BITCI

---
Additional information can be found by searching:
- "rs232trans_parity_and_bgn" which expands on transmitter start and parity code uses BITCNT
