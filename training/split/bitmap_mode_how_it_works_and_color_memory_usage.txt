# COMMODORE 64 - Explains how programmable characters are repurposed in bitmap mode: character memory holds bitmap bytes and screen memory holds color/nybble data. The upper 4 bits of screen memory specify color for bits set to 1 in the 8x8 area; lower 4 bits specify color for bits set to 0. Demonstrates setting BASE and entering bitmap mode and that clearing must be done by zeroing the bitmap RAM area (not CLR).

    Before we get into the details of the bit map mode, there is one more
  issue to tackle, and that is where to locate the bit map area.

  HOW IT WORKS

    If you remember the PROGRAMMABLE CHARACTERS section you will recall
  that you were able to set the bit pattern of a character stored in RAM to
  almost anything you wanted. If at the same time you change the character
  that is displayed on the screen, you would be able to change a single
  dot, and watch it happen. This is the basis of bit-mapping. The entire



  122   PROGRAMMING GRAPHICS
~


  screen is filled with programmable characters, and you make your changes
  directly into the memory that the programmable characters get their
  patterns from.
    Each of the locations in screen memory that were used to control what
  character was displayed, are now used for color information. For example,
  instead of POKEing a I in location 1024 to make an "A" appear in the top
  left hand corner of the screen, location 1024 now controls the colors of
  the bits in that top left space.
    Colors of squares in bit map mode do not come from color memory, as
  they do in the character modes. Instead, colors are taken from screen
  memory. The upper 4 bits of screen memory become the color of any bit
  that is set to 1 in the 8 by 8 area controlled by that screen memory
  location. The lower 4 bits become the color of any bit that is set to
  a 0.


---
Additional information can be found by searching:
- "standard_bitmap_mode_enable_disable_and_types" which expands on turning bitmap on/off and choosing base
