# An Introduction to Programming C-64 Demos - Example program to modify the character set in realtime: clears screen and charset ($2000), sets $D018 to $18 (screen $0400, chars $2000), main loop polls $D012 for raster $FF and then inverts a byte in charset at $2000+counter to create animation (DYCP-like effects). Explains char data layout (char N at $2000 + N*8).

Altering the Character Set in Realtime
I mention above that you can make interesting effects by altering the character set in realtime. How do you do this? Well, if you've specified that you want your character set at $2000, you can start poking values in the addresses from $2000 to $2800, and see what happens. As you're altering the character set that's used for displaying what's on the screen, the things on the screen will change immediately. You don't have to change anything in screen memory, just in the character set.

A classical example of an effect that you can do by poking data into a character set is a DYCP (Different Y Character Positions). A DYCP is a scroll text where the letters move up and down, independent of each other. You can figure out how to do it yourself, or read the article about it in Commodore Hacking.

An easier exercise than writing a DYCP would be to create some animated graphics by changing the character data. You can also use this to scroll text without using $d016, by ROLing the char data through character memory...

Here's a simple example program, that doesn't really do much, except illustrate what I've just written. It sets the position of the character set to $2000, and then alters it in realtime. Note that I'm using $d012, as always.


           * = $0801

           lda #$00     ; black
           sta $d020    ; border background colour
           sta $d021    ; screen background colour

           tax          ; set X to 0 too

clrscreen               ; set all char codes to 0
           sta $0400,x  ; on the screen
           sta $0500,x
           sta $0600,x
           sta $0700,x
           sta $2000,x  ; and set charset data to 0
           dex
           bne clrscreen

           lda #$18     ; screen at $0400, chars at $2000
           sta $d018

mainloop
           lda $d012
           cmp #$ff     ; on raster line $ff?
           bne mainloop ; no, go to mainloop

           ldx counter  ; get offset value
           inx          ; increment it
           cpx #$28     ; if it's $28, start over
           bne juststx
           ldx #$00
juststx
           stx counter

           lda $2000,x  ; get byte nr x from chardata
           eor #$ff     ; invert it
           sta $2000,x  ; store it back

           jmp mainloop ; keep going...

counter
           .byte 8      ; initial value for counter
Some small things in the example might have to be explained. The reason why I'm counting to $28, and not just 8 (which would be sufficient for inverting every byte that make up the character 0), is so that it won't be too fast to see what's going on. The reason why we're poking stuff into $2000 and up is that we're using character number 0. The data for char 0 starts at $2000, the data for char 1 starts at $2008, the data for char 2 at $2010 and so on.

---
Additional information can be found by searching:
- "text_scroller_implementation" which expands on DYCP and realtime charset updates used for scrollers and animated fonts
