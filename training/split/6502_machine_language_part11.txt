# ML for C64 - Chapter 5: Indexed Modes, Indirect Addressing

255).

It makes no difference to the computer.  If you consider a number signed, you
may wish to test the sign using the N flag.  If not, you won't do such a
test.


Big Numbers:  Multiple Bytes
----------------------------

You may use more than one byte to hold a number.  Again, it's your decision.
If you think the numbers may go up to a million, you might allocate three
bytes (or more or fewer).  If you are doing arithmetic on multi-byte numbers,
the computer will help you by signaling in the carry flag that there's
something to be carried across from a lower byte to a higher one.  But it's
up to you to write the code to handle the extra bytes.

You may size numbers by using the following table:

           Unsigned:                       Signed:
-----------------------------------------------------------
1 byte     0 to 255                     -128 to +127
2 bytes    0 to 65,535               -32,768 to +32,767
3 bytes    0 to 16,777,215        -8,388,608 to +8,388,607
4 bytes    0 to over 4 billion    -2 billion to +2 billion

It's possible to work with binary fractions, but that is beyond the scope of
this book.  Many applications "scale" numbers, so that dollar-and-cents
amounts are held as integer quantities of pennies.  Thus, two bytes unsigned
would hold values up to $655.35, and three bytes up to $167,772.15.

When signed numbers are held in multiple bytes, the sign is the highest bit
of the highest byte only.

We will concentrate on single-byte arithmetic principles here, touching on
multiple-byte numbers as a generalization of the same ideas.


Addition
--------

Principles of addition are similar to those we use in decimal arithmetic;
for decimal "columns," you may substitute "bytes."  Let's look at a simple
decimal addition:

                                                                         :59:

    142856
  + 389217
  --------

  Rule 1:  We start at the right-hand column (the low-order byte).

  Rule 2:  We add the two values, plus any carry from the previous column.  A
  new carry may be generated; it can never be greater than one.  (ADC
  includes any carry from a previous activity, and may generate a new carry
  bit, which is either 0 or 1.)

  Rule 3:  When we start at the right-hand column, there is no carry for the
  first addition.  (We must clear the carry with CLC before starting a new
  addition.)

  Rule 4:  When we have finished the whole addition, if we have a carry and
  no column to put it in, we say the answer "won't fit."  (If an addition
  sequence of unsigned numbers ends up with the carry flag set, it's an
  overflow condition.)


    HIGH BYTE        LOW BYTE
                               Start:
    00101011         10111001  No carry
    00001010         11100101 /
    -------------------------/
                     10011110
                    /
                   /
              Carry
             /
            /
    00110110

    Figure 4.1


How do we translate these rules into machine language addition?

  1.  Before we start an addition sequence, clear the carry with CLC.

  2.  If the numbers are more than one byte in size, start at the low byte
      and work up to the high ones.  Addition will take place in the A
      register only; you may add the contents of an address or an immediate
      value.  The carry flag will take care of any carries.

  3.  When the addition sequence is complete, check for overflow:
      a)  if the numbers are unsigned, a set C flag indicates overflow;
      b)  if the numbers are signed, a set V flag indicates overflow.

Thus, to add two unsigned numbers located at addresses $0380 and $0381 and to
place the result at $0382, we might code

                                                                         :60:

  CLC
  LDA $0380
  ADC $0381
  STA $0382

We might also BCS to an error routine, if desired.

To add a two-byte number located at $03A0 (low) and $03A1 (high) to another
two-byte number located at $03B0 (low) and $03B1 (high), placing the result
at $03C0/1, we might code

  CLC
  LDA $03A0
  ADC $03B0
  STA $03C0
  LDA $03A1
  ADC $03B1
  STA $03C1

Again, we might BCS to an overflow error routine.

If we had two-byte signed numbers in the same locations, we'd add them
exactly the same way, using the same code as above.  In this case, however,
we'd check for overflow by adding the instruction BVS, which would branch to
an error routine.  The carry flag would have no meaning at the end of the
addition sequence.


Subtraction
-----------

Subtraction might be defined as "upside down" addition.  The carry flag again
serves to link the parts of a multi-byte subtraction, but its role is
reversed.  The carry flag is sometimes called an "inverted borrow" when used
in subtraction.  Before performing a subtraction, we must set the C flag with
SEC.  If we are worried about unsigned overflow, we look to confirm that the
carry is set at the completion of the subtraction operation.  If the carry is
clear, there's a problem.

Thus, to perform a subtraction, we follow these rules:

  1.  Before we start a subtraction sequence, set the carry with SEC.

  2.  If the numbers are more than one byte in size, start at the low byte
      and work up to the high ones.  Subtraction will take place in the A
      register only; you may subtract the contents of an address or an
      immediate value.  The C flag will take care of any "borrows."

  3.  When the subtraction sequence is complete, check for overflow:
      a)  if the numbers are unsigned, a clear C flag indicates overflow;
      b)  if the numbers are signed, a set V flag indicates overflow.

                                                                         :61:

Thus, to subtract two unsigned numbers located at addresses $0380 and $0381
and to place the result at $0382, we might code

  SEC
  LDA $0380
  SBC $0381
  STA $0382

A BCC could go to an error routine.


Comparing Numbers
-----------------

If we have two unsigned numbers and wish to know which one is larger, we can
use the appropriate compare instruction--CMP, CPX, or CPY--and then check the
carry flag.  We've done this before.  If the numbers are more than one byte
long, however, it's not quite so easy.  We must then use a new technique.

The easiest way to go about such a comparison is to subtract one number from
the other.  You need not keep the result; all you care about is the carry
flag when the subtraction is complete.  If the C flag is set, the first
number (the one you are subtracting from) is greater than or equal to the
second number.  Why?  Because carry set indicated that the unsigned
subtraction was legal; we have subtracted the two numbers and have obtained a
positive (unsigned) result.  On the other hand, if the C flag ends up clear,
this would mean that the first number is less than the second.  The
subtraction couldn't take place correctly since the result--a negative
number--can't be represented in unsigned arithmetic.


Left Shift:  Multiplication by Two
----------------------------------

If we write the decimal numbers 100 and 200 in binary, we see an interesting
pattern:

  100:  %01100100
  200:  %11001000

To double the number, each bit has moved one position to the left.  This
makes sense, since each bit has twice the numeric "weight" of the bit to its
right.

The command to multiply a byte by two is ASL (arithmetic shift left).  A zero
bit is pushed into the low (or "right") side of the byte; all bits move left
one position; and the bit that "falls out" of the byte--in this case, a zero
bit--moves into the carry.  It can be diagrammed like this:

                                                                         :62:

              +-----+----+----+----+----+----+----+-----+
              |     |    |    |    |    |    |    |     |
    CARRY   <---- <--- <--- <--- <--- <--- <--- <---  <---- 0
   (C FLAG)   |     |    |    |    |    |    |    |     |
              +-----+----+----+----+----+----+----+-----+
                                  ASL

   IN AN ASL (ARITHMETIC SHIFT LEFT), EACH BIT MOVES ONE POSITION LEFT.
   A ZERO MOVES INTO THE LOW-ORDER BIT.

   Figure 4.2


That's good for doubling the value of a single byte.  If a "one" bit falls
into the carry flag, we can treat that as an overflow.  What about multiple
bytes?

It would be ideal if we had another instruction that would work just like
ASL.  Instead of pushing a zero bit into the right hand site of the byte,
however, it would push the carry bit, that is, the bit that "fell out" of the
last operation.  We have such an instruction:  ROL.

ROL (rotate left) works exactly like ASL except that the carry bit is pushed
into the next byte.  We can diagram it as follows:


                                                           CARRY
              +-----+----+----+----+----+----+----+-----+  |
              |     |    |    |    |    |    |    |     |  |
           ,----- <--- <--- <--- <--- <--- <--- <---  <----'
           |  |     |    |    |    |    |    |    |     |
           |  +-----+----+----+----+----+----+----+-----+
           v                      ROL
         CARRY

   IN A ROL (ROTATE LEFT), THE CARRY MOVES INTO THE LOW ORDER BIT; EACH
   BIT MOVES LEFT; AND THE HIGH ORDER BIT BECOMES THE NEW CARRY.

   Figure 4.3


Thus, we can hook to or more bytes together.  If they hold a single
multi-byte number, we can double that number by starting at the low-order
end.  We ASL the first value and ROL the remainder.  As the bits fall out of
each byte, they will be picked up in the next.


Multiplication
--------------

Multiplying by two may not seem too powerful.  We can build on this starting
point, however, and arrange to multiply by any number we choose.

                                                                         :63:

                                                ASL         0
                                               +---------+  |
                                               |         |  |
                                            ,---- <- <- <---'
                                            |  |         |
                              ROL           |  +---------+
                             +---------+    |   LOW ORDER BYTE
                             |         |    v
                          ,---- <- <- <---CARRY
                          |  |         |
            ROL           |  +---------+
           +----------+   |
           |          |   v
        ,---- <- <- <---CARRY
        |  |          |
        |  +----------+
        |   HIGH ORDER BYTE
        v

   TO MULTIPLY A THREE-BYTE NUMBER BY TWO, WE SHIFT THE LOW ORDER
   BYTE WITH ASL; THEN WE USE ROL TO ALLOW THE C FLAG TO "LINK" FROM
   ONE BYTE TO THE NEXT.

   Figure 4.4


We won't deal with a generalized multiplication routine here, but a couple
of specific examples can be shown.

How can we multiply by four?  Multiply by two, twice.  How can we multiply by
eight?  Multiply by two, three times.

Here's an important one.  We often want to multiply by ten.  For example, if
a decimal number is being typed in at the keyboard, the number will arrive
one digit at a time.  The user might type 217, for example.  The program must
then input the two and put it away; when the one arrives, the two must be
multiplied by ten, giving twenty, and the one added; when the seven is typed,
the twenty-one must be multiplied by ten before the seven is added.  Result:
