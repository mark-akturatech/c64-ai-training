# - Fully Commented Commodore 64 ROM Disassembly (English) - Continuation of EXP() in the KERNAL ($E000). This code saves FAC2 rounding byte, copies FAC1 to FAC2, checks the exponent against overflow limits and calls overflow/underflow handler if needed, uses INT() to normalise/adjust exponent, swaps FAC1 and FAC2 bytes, restores rounding byte, performs FAC2-from-FAC1 subtraction and a negation step, sets up a counter pointer into the coefficient table and jumps to the series-evaluation driver. Ends by testing/adjusting accumulators and returning.

                                *** start of the kernal ROM
                                EXP() continued
.,E000 85 56    STA $56         save FAC2 rounding byte
.,E002 20 0F BC JSR $BC0F       copy FAC1 to FAC2
.,E005 A5 61    LDA $61         get FAC1 exponent
.,E007 C9 88    CMP #$88        compare with EXP limit (256d)
.,E009 90 03    BCC $E00E       branch if less
.,E00B 20 D4 BA JSR $BAD4       handle overflow and underflow
.,E00E 20 CC BC JSR $BCCC       perform INT()
.,E011 A5 07    LDA $07         get mantissa 4 from INT()
.,E013 18       CLC             clear carry for add
.,E014 69 81    ADC #$81        normalise +1
.,E016 F0 F3    BEQ $E00B       if $00 result has overflowed so go handle it
.,E018 38       SEC             set carry for subtract
.,E019 E9 01    SBC #$01        exponent now correct
.,E01B 48       PHA             save FAC2 exponent
                                swap FAC1 and FAC2
.,E01C A2 05    LDX #$05        4 bytes to do
.,E01E B5 69    LDA $69,X       get FAC2,X
.,E020 B4 61    LDY $61,X       get FAC1,X
.,E022 95 61    STA $61,X       save FAC1,X
.,E024 94 69    STY $69,X       save FAC2,X
.,E026 CA       DEX             decrement count/index
.,E027 10 F5    BPL $E01E       loop if not all done
.,E029 A5 56    LDA $56         get FAC2 rounding byte
.,E02B 85 70    STA $70         save as FAC1 rounding byte
.,E02D 20 53 B8 JSR $B853       perform subtraction, FAC2 from FAC1
.,E030 20 B4 BF JSR $BFB4       do - FAC1
.,E033 A9 C4    LDA #$C4        set counter pointer low byte
.,E035 A0 BF    LDY #$BF        set counter pointer high byte
.,E037 20 59 E0 JSR $E059       go do series evaluation
.,E03A A9 00    LDA #$00        clear A
.,E03C 85 6F    STA $6F         clear sign compare (FAC1 EOR FAC2)
.,E03E 68       PLA             get saved FAC2 exponent
.,E03F 20 B9 BA JSR $BAB9       test and adjust accumulators
.,E042 60       RTS             

---
Additional information can be found by searching:
- "exp_entry_prepare" which expands on entry code jumps here after initial prepare/rounding
- "series_evaluation_routine" which expands on this routine sets up and then branches into the generic series evaluator
- "power_function_driver" which expands on EXP called by the power driver for X^Y computation
