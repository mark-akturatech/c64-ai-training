# ML for C64 - Chapter 8: Conclusion, Advanced Topics

even though there was no subroutine call; all we have to do is prepare the
stack with the proper address.  Try to figure out what the following code
will do:

  LDA #$24
  PHA
  LDA #$68
  PHA
  RTS

This coding is identical to JMP $2469.  We have placed a "false return
address" onto the stack, and RTS has removed it and used it.  This may not
seem very useful, since we could easily have coded the JMP $2469 directly.
But look at the following code:

  LDA TABLE1,X
  PHA
  LDA TABLE2,X
  PHA
  RTS

The principle of coding is the same, but now we can "fan out" to any of
several different addresses, depending on the value contained in X.


USR:  A Brother to SYS
----------------------

We have used SYS a number of times.  It means, "Go to the address supplied
and execute machine code there as a subroutine."  USR is similar in may
respects:  it means, "Go to a fixed address and execute machine code there as
a subroutine."  The fixed address may be POKEd into the USR vector.  On most
Commodore machines this is at addresses 1 and 2; on the Commodore 64, it's at
addresses 7875 and 786 (hex 0311 and 0312).

                                                                        :117:

There's another difference that seems important at first.  SYS is a command;
USR is a function.  You cannot type the command USR(0)--all you'll get is
SYNTAX ERROR.  You must say something like PRINT USR(0) or X=USR(0), where
USR is used as a function.  It seems as if SYS was meant to connect to action
programs, and USR was meant to link to evaluation programs.  In reality, the
difference in usage is not that great.

Whatever value is within the parentheses--the argument of the USR function--
is computed and placed into the floating accumulator before the USR function
is called.  The floating accumulator is located at $5E to $63 in most PET/CBM
computers, and at $61 to $66 in VIC-20, Commodore 64, and PLUS/4.  Floating-
point representation is complex, as we have hinted in Chapter 6.  Most
beginning programmers prefer to leave this area alone and pass values through
memory POKEs or integer values.

When the USR function returns control to BASIC, the function value will be
whatever is in the floating accumulator.  If we have not modified it, this
will be the same as the argument, so that in many cases PRINT USR(5) would
print a value of 5.


Interrupts:  NMI, IRQ, and BRK
------------------------------

We have mentioned the mechanical aspects of interrupt.  Now let's look at how
to use the interrupt for simple jobs.

The IRQ connects through a vector in RAM; if we change the address within the
vector, we will change the address to which the interrupt goes.  The
interrupt vector is located as follows:

  Most PET/CBM:  0090-0091 (decimal 144-145)

  VIC/Commodore 64:  0314-0315 (decimal 788-789)

Before we change this vector, we should realize something quite important:
the interrupt does a lot of work sixty times a second.  It updates the clock,
checks the RUN/STOP key, gives service to the cassette motors, flashes the
cursor, and handles keyboard input.  If you thoughtlessly change the IRQ
vector, it will stop doing these things, and it's hard to handle a computer
when it has a dead keyboard.  You could try to program all these functions
yourself; but there's an easier way.

                                                                        :118:

Suppose we use the vector to temporarily divert to our own program, and at
the end of our program we allow the interrupt to continue with whatever it
was going to do anyway.  That way, our program would get service sixty times
a second, and the usually interrupted jobs would still get done.

It's not hard to do, and we can achieve many interesting effects by diverting
the interrupt.  Remember that the interrupt runs all the time, even when no
BASIC program is running.  By playing with the interrupt, we can make a
permanent computer system change that is in effect even when no programs are
in place.

Care must be taken in changing an interrupt vector.  Suppose we are beginning
to change the two-byte address; we have changed the first byte, and suddenly,
the interrupt strikes.  It will use an address that's neither fish nor fowl:
half is the old address, and half is the new.  In such a case, it's likely
that the interrupt will become confused; and f the interrupt is confused, the
whole computer is in trouble.  We must find a way to prevent interrupt from
striking when we change the vector.

We could do this in machine language:  before a routine to change the IRQ
vector, we could give the instruction SEI (set interrupt disable).  After
this instruction is given, the IRQ cannot interrupt us.  We may set the
vector and then re-enable the interrupt with the instruction CLI (clear
interrupt disable).  Be sure that you do this, since the interrupt routine
performs many vital functions.  We may say that we have masked off the
interrupt in the time period between execution of SEI and CLI.  The NMI
interrupt, however, is non-maskable, and SEI will have no effect on it.

There's a second way of turning off the interrupt--that is, by shutting off
the interrupt source.  Something makes an interrupt happen--it might be a
timer, it might be an external signal, or it might even be a screen event.
Whatever it is, we can get to the source of the interrupt and disconnect it.

Almost all interrupt signals are delivered through an IA (interface adapter)
chip; and these chips invariably allow the path of the interrupt signals to
be blocked temporarily.  We'll discuss the IA chips later; for the moment,
the normal interrupt signals can be blocked with the following actions:

  Commodore 64:  Store $7F into address $DC0C (POKE 56333,127) to disable;
  store $81 into the same address (POKE 56333,129) to re-enable.

                                                                        :119:

  VIC-20:  Store $7F into address $912E (POKE 37166,127) to disable; store
  $C0 into the same address (POKE 37166,192) to re-enable.

  PET/CBM:  Store $3C into address $E813 (POKE 59411,60) to disable; store
  $3D into the same address (POKE 59411,61) to re-enable.

It goes without saying that the above POKEs should not normally be given as
direct commands; the first POKE in each case will disable the keyboard (among
other things), and you won't be able to type the restoring POKE.

A warning about interrupt programs:  changing the IRQ vector is likely to
make it difficult to load and save programs.  You may need to put the vector
back to its original state before you attempt any of these activities.


An Interrupt Project
--------------------

The following project is written for the Commodore 64 only.  The equivalent
coding for PET/CBM may be found in Appendix E.

Let's write the coding for the interrupt itself.  Sixty times a second, we'd
like to copy the contents of address $91 to the top of the screen.  Here
goes:

  .A 033C  LDA $91
  .A 033E  STA $0400
  .A 0341  JMP ($03A0)

Why the indirect jump?  We want to "pick up" the regular interrupt routine,
but we don't know where it is yet.  When we find the address, we'll but it
into locations $03A0/$03A1 so that the indirect jump will link things up for
us.

Now let's write the routine to enable the above interrupt coding.  First,
let's copy the interrupt address from $0314 into the indirect address at
$03A0:

  .A 0344  LDA $0314
  .A 0347  STA $03A0
  .A 034A  LDA $0315
  .A 034D  STA $03A1

Now we are ready to put the address of our own interrupt routine (at $033C)
into the IRQ vector:

  .A 0350  SEI
  .A 0351  LDA #$3C
  .A 0353  STA $0314
  .A 0356  LDA #$03
  .A 0358  STA $0315
  .A 035B  CLI
  .A 035C  RTS

We will enable the new interrupt procedure by a SYS to $0344, above (SYS
836).  Before we give that command, let's write the coding to put everything
back:

  .A 035D  SEI
  .A 035E  LDA $03A0
  .A 0361  STA $0314
  .A 0364  LDA $03A1
  .A 0367  STA $0315
  .A 036A  CLI
  .A 036B  RTS

As you can see, we put the original address back, copying it from the
indirect address area where it was saved.

Once this code is in place, disassembled, and checked, you may return to
BASIC.  SYS 836 will invoke the new interrupt code; SYS 861 will turn it off.
Note that the character (a copy of the contents of address $91) appears at
the top left of the screen.  The character seems to be affected by pressing
some keys; can you established how may keys are involved?

Some models of Commodore 64 may print blue-on-blue when screen memory is
POKEd, as we are doing now.  If so, the character may not always appear in
the left-hand corner.  Project for enthusiasts:  Fix this problem by storing
a value into the color nybble table at address $D800.


The IA Chips:  PIA, VIA, and CIA
--------------------------------

The interface adapter (IA) chips are richly detailed.  To understand them
fully, you'll need to read the specifications in some detail.  Here, we'll
give their main functions.

PIA stands for peripheral interface adapter, VIA for versatile interface
adapter, and CIA for complex interface adapter.  There is speculation among
Commodore owners that the next interface chip will be called "FBI."

The functions performed by an interface adapter are:

  1.  Event latching and interrupt control.  We have noted that these chips
      can be manipulated to block the interrupt signal.  In fact, they do
      more than "gating" the signal--allowing it through to the processor's
      IRQ trigger or alternatively blocking it.  They also often latch a
      signal into an event flag, sometimes called an interrupt flag.

                                                                        :121:

      Latching is important.  A triggering event may be brief; so short, in
      fact, that the original signal causing interrupt might go away before
      the processor can look at it.  An IA event flag locks in the signal and
      holds it until the program turns it off.


        NEAR "THE IA CHIPS..."

                            ON +-------+ OFF
       INTERRUPTING----------->| LATCH |<-------------.
       EVENT                   +-------+              |
                                   |                  |
                                   v              COMPUTER
                                 EVENT         ACKNOWLEDGEMENT
                                 FLAG

       Figure 7.2


      If an event has time importance--that is, if the event's timing must be
      accurately measured, or if the event flag must be cleared quickly so as
      to allow for the detection of a  new event--we may link the event flag
      to the interrupt line.  If we do so, the occurrence of the event will
      cause the processor to be interrupted.  We must write coding linked to
      the interrupt routines to detect this event, clear the flag, and do
      whatever processing is needed.  We set up this link to the interrupt
      line by means of a register usually called the interrupt enable
      register.

      On the other hand, the event might not be particularly time critical.
      In this case, you can simply check the appropriate event flag from time
      to time.  When the event occurs, you may then clear the flag and handle
      it.  No interrupt is needed.  Even when an event flag is not connected
      to the interrupt, it may be called an interrupt flag; don't let the
      terminology confuse you.

      Whether or not you handle these events through interrupt sequences,
      it's important to know that it's your job to turn the event flag off.
      The flag will hold the signal until it's turned off--and it usually
      won't turn off unless your program takes some action to do this.

      The various flags are triggered by timers or external signals.  You can
      read a flag's state by checking the interrupt flag register.  Several
      flags will be packed together in this register; as always, you will use
      the logical operators--AND, ORA, and EOR--to extract or modify the
      particular flags in which you are interested.  You may also use the IFR
      (interrupt flag register) to clear the flags.

  2.  Timing.  Certain addresses within the IA chip are often assigned as
      "timers."  These timers count down; in other words, if we place a value
      of $97 into a timer and look at the value immediately, we might find
      that it has gone down to $93.  Timers come in many shapes and sizes--
      again, check the chip reference for details--but most of them toggle an
      interrupt flag when they have counted down to zero.  As discussed, you
      may choose whether or not this flag will really cause an interrupt
      signal.

                                                                        :122:

  3.  Input/output.  Certain addresses within the IA chip are connected to
      "ports," which extend outside the computer.  Thus, the computer can
      detect external events or control external devices.  Output signals are
      usually latching in nature:  in other words, a store command might be
      taken to mean, "turn on port 5 and leave it on."


Tips on IA Chips
----------------

Many addresses within an IA chip have a different meaning, depending on
whether they are being written to (stored) or read (loaded).  Watch for this
when you are reading the chip specifications.

