# ML for C64 - Chapter 1: First Concepts - Binary, Hex, Architecture

===================
= Note to Readers =
===================

  This book introduces beginners to the principles of machine language:  what
it is, how it works, and how to program with it.
  It is based on an intensive two-day course on machine language that has
been presented many times over the past five years.
  Readers of this book should have a computer on hand:  students will learn
by doing, not just by reading.  Upon completing the tutorial material in this
book, the reader will have a good idea of the fundamentals of machine
language.  There will be more to be learned; but by this time, students
should understand how to adapt other material from books and magazines to
their own particular computers.


                            LIMITS OF LIABILITY AND
                             DISCLAIMER OF WARRANTY

  The author and publisher [and e-text converter  -wf] of this book have used
their best efforts in preparing this book and the programs contained in it.
These efforts include the development, research, and testing of the programs
to determine their effectiveness.  The author and the publisher [and e-text
converter  -wf] make no warranty of any kind, expressed or implied, with
regard to these programs, the text, or the documentation contained in this
book.  The author and the publisher [and e-text converter  -wf] shall not be
liable in any event for claims of incidental of consequential damages in
connection with, or arising out of, the furnishing, performance, or use of
the text or the programs.
  At time of publication, the Commodore 264 is still undergoing design
changes.  The name is being changed to the "PLUS/4"; a related machine, the
Commodore 16, has also been announced.  Detailed design information is not
available; but the information given in this book for the Commodore 264
should be generally accurate.

                                                                        :vii:

===========
= Preface =
===========

  This book is primarily tutorial in nature.  It contains, however, extensive
reference material, which the reader will want to continue to use.
  No previous machine language experience is required.  It is useful if the
reader has had some background in programming in other languages, so that
concepts such as loops and decisions are understood.
  Beginners will find that the material in this book moves at a fast pace.
Stay with it; if necessary, skip ahead to the examples and then come back to
reread a difficult area.
  Readers with some machine language experience may find some of the material
too easy; for example, they are probably quite familiar with hexadecimal
notation and don't need to read that part.  If this is the case, skip ahead.
But do enter all the programming projects; if you have missed a point, you
may spot it while doing an exercise.
  Programming students learn by doing.  The beginner needs to learn simple
things about his or her machine in order to feel in control.  The elements
that are needed may be itemized as:

 o Machine language.  This is the objective, but you can't get there without
   the next two items.

 o Machine architecture.  All the machine language theory in the world will
   have little meaning unless the student knows such things as where a
   program may be placed in memory, how to print to the screen, or how to
   input from the keyboard.

 o Machine language tools.  The use of a simple machine language monitor to
   read and change memory is vital to the objective of making the computer do
   something in machine language.  Use of a simple assembler and elements of
   debugging are easy once you know them; but until you know them, it's hard
   to make the machine do anything.

  Principles of sound coding are important.  They are seldom discussed
explicitly, but run as an undercurrent through the material.  The objective
is this:  it's easy to do things the right way, and more difficult to do them
the wrong way.  By introducing examples of good coding practices early, the
student will not be motivated to look for a harder (and inferior) way of
coding.
  It should be pointed out that this book deals primarily with machine
language, not assembly language.  Assembler programs are marvelous things,

                                                                       :viii:

but they are too advanced for the beginner.  I prefer to see the student
forming an idea of how the bytes of the program lie within memory.  After
this concept is firmly fixed in mind, he or she can then look to the greater
power and flexibility offered by an assembler.


====================
= Acknowledgements =
====================

  Thanks go to Elizabeth Deal for acting as resource person in the
preparation of this book.  When I was hard to find, the publisher could call
upon Elizabeth for technical clarification.

                                                                         :ix:

================
= Introduction =
================

  Why learn machine language?  There are three reasons.  First, for speed;
machine language programs are fast.  Second, for versatility; all other
languages are limited in some way, but not machine language.  Third, for
comprehension; since the computer really works in machine language only, the
key to understanding how the machine operates is machine language.
  Is it hard?  Not really.  It's finicky, but not difficult.  Individual
machine language instructions don't do much, so we need many of them to do a
job.  But each instruction is simply, and anyone can understand it if he or
she has the patience.
  Some programmers who started their careers in machine language find "higher
level" languages such as BASIC quite difficult by comparison.  To them,
machine language instructions are simple and precise, whereas BASIC
statements seem vague and poorly defined by comparison.
  Where will this book take you?  You will end up with a good understanding
of what machine language is, and the principles of how to program in it.  You
won't be an expert, but you'll have a good start and will no longer be
frightened by this seemingly mysterious language.
  Will the skills you learn be transportable to other machines?  Certainly.
Once you understand the principles of programming, you'll be able to adapt.
If you were to change to a non-Commodore machine that used the 6502 chip
(such as Apple or Atari), you'd need to learn about the architecture of these
machines an about their machine language monitors.  They would be different,
but the same principles would apply on all of them.
  Even if you change to a computer that doesn't use a chip from the 6502
family, you will be able to adapt.  As you pick through the instructions and
bits of the Commodore machine, you will have learned about the principles of
all binary computers.  You will need to learn the new microprocessor's
instruction set, but it will be much easier the second time around.
  Do you need to be a BASIC expert before tackling machine language?  Not at
all.  This book assumes you know a little about programming fundamentals:
loops, branching, subroutines, and decision making.  But you don't need to be
an advanced programmer to learn machine language.

                                                                          :1:



                                                          Chapter 1

                                                              First
                                                           Concepts


          This chapter discusses:

            o The inner workings of microcomputers

            o Computer notation:  binary and hexadecimal

            o The 650x's inner architecture

            o Beginning use of a machine language monitor

            o First machine language commands

            o Writing and entering a simple program


                                                                          :2:

The Inner Workings of Microcomputers
------------------------------------

All computers contain a large number of electrical circuits.  Within any
binary computer, these circuits may be in only two states:  "on" or "off."

Technicians will tell you that "on" usually means full voltage on the circuit
concerned, and "off" means no voltage.  There's no need for volume control
adjustments within a digital computer:  each circuit is either fully on or
fully off.

The word "binary" means "based on two," and everything that happens within
the computer is based on the two possibilities of each circuit:  on or off.
We can identify these two conditions in any of several ways:

                                    ON or OFF
                                  TRUE or FALSE
                                   YES or NO
                                     1 or 0

The last description, 1 or 0, is quite useful.  It is compact and numeric.
If we had a group of eight circuits within the computer, some of which were
"on" and others "off," we could describe their conditions with an expression
such as:

  11000111

This would signify that the two leftmost wires were on, the next three off,
and the remaining three on.  The value 11000111 looks like a number; in fact,
it is a binary number in which each digit is 0 or 1.  It should not be
confused with the equivalent decimal value of slightly over 11 million; the
digits would look the same, but in decimal each digit could have a value from
0 to 9.  To avoid confusion with decimal numbers, binary numbers are often
preceded by a percent sign, so that the number might be shown as %11000111.

Each digit of a binary number is called a bit, which is short for "binary
digit."  The number shown above has eight bits; a group of eight bits is a
byte.  Bits are often numbered from the right, starting at zero.  The right-
hand bit of the above number would be called "bit 0," and the left-hand bit
would be called "bit 7."  This may seem odd, but there's a good mathematical
reason for using such a numbering scheme.

                                                                          :3:

The Bus
-------

It's fairly common for a group of circuits to be used together.  The wires
run from one microchip to another, and then on to the next.  Where a group of
wires are used together and connect to several different points, the group is
called a bus (sometimes spelled "buss").  [um, isn't a "buss" another word
for a "kiss"?  better check what's going on inside my machine... HEY! -wf]

The PET, CBM, and VIC-20 use a microprocessor chip called the 6502.  The
Commodore 64 uses a 6510.  The Commodore B series uses a 6509 chip, and the
Commodore PLUS/4 uses a chip called the 7501.  All these chips are similar,
and there are other chips in the same family with numbers like 6504; every
one works on the same principles, and we'll refer to all of them by the
family name 650x.

Let's take an example of a bus used on any 650x chip.  A 650x chip has little
built-in storage.  To get an instruction or perform a computation, the 650x
must call up information from "memory"--data stored within other chips.

The 650x sends out a "call" to all memory chips, asking for information.  It
does this by sending out voltages on a group of sixteen wires called the
"address bus."  Each of the sixteen wires may carry either voltage or no
voltage; this combination of signals is called an address.

Every memory chip is connected to the address bus.  Each chip reads the
address, the combination of voltages sent by the processor.  One and only one
chip says, "That's me!"  In other words, the specific address causes that
chip to be selected; it prepares to communicate with the 650x.  All other
chips say, "That's not me!" and will not participate in data transfer.


               +------+
               |      | ->          ->          ->         ->
               |      o-------o-----------o-----------o--------
               |      o-------+o----------+o----------+o-------
               | 650x o-------++o---------++o---------++o------
               |      o-------+++o--------+++o--------+++o-----
               |      |       ||||        ||||        ||||
               |      |      |||||       |||||       |||||
               +------+      v||||       v||||       v||||
                              ||||        ||||        ||||
                           +--oooo--+  +--oooo--+  +--oooo--+
                           |        |  |        |  |        |
                           | Memory |  | Memory |  | Memory |
                           |  Chip  |  |  Chip  |  |  Chip  |
                           |        |  |        |  |        |
                           +--------+  +--------+  +--------+

               Figure 1.1  Address bus connecting 650x & 3 chips

                                                                          :4:

The Data Bus
------------

Once the 650x microprocessor has sent an address over the address bus and it
has been recognized by a memory chip, data may flow between memory and 650x.
This data is eight bits (it flows over eight wires).  It might look like
this:

  01011011

The data might flow either way.  That is, the 650x might read from the memory
chip, in which case the selected memory chip places information onto the data
bus which is read by the microprocessor.  Alternatively, the 650x might wish
to write to the memory chip.  In this case, the 650x places information onto
the data bus, and the selected memory chip receives the data and stores it.


           +------+
           |      | -> ADDRESS BUS  ->            ->          ->
           |      o--------o--------------o--------------o--------
           |      o--------+o-------------+o-------------+o-------
           |      o--------++o------------++o------------++o------
           |      o--------+++o-----------+++o-----------+++o-----
           |      |        ||||           ||||           ||||
           |      |       |||||          |||||          |||||
           | 650x |       v||||          v||||          v||||
           |      |        ||||           ||||           ||||
           |      |DATA BUS||||   <->     ||||    <->    |||| <->
           |      o------o-++++---------o-++++---------o-++++-----
           |      o-----o+-++++--------o+-++++--------o+-++++-----
           |      o----o++-++++-------o++-++++-------o++-++++-----
