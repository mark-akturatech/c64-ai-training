# C64 KERNAL ROM Disassembly $EC00-$ECFF - Keyboard Tables

.,EB24 10 1C    BPL $EB42       if the buffer isn't empty just exit
                                else repeat the key immediately
                                possibly save the key to the keyboard buffer. if there was no key pressed or the key
                                was not found during the scan (possibly due to key bounce) then X will be $FF here
.,EB26 A4 CB    LDY $CB         get the key count
.,EB28 84 C5    STY $C5         save it as the current key count
.,EB2A AC 8D 02 LDY $028D       get the keyboard shift/control/c= flag
.,EB2D 8C 8E 02 STY $028E       save it as last keyboard shift pattern
.,EB30 E0 FF    CPX #$FF        compare the character with the table end marker or no key
.,EB32 F0 0E    BEQ $EB42       if it was the table end marker or no key just exit
.,EB34 8A       TXA             copy the character to A
.,EB35 A6 C6    LDX $C6         get the keyboard buffer index
.,EB37 EC 89 02 CPX $0289       compare it with the keyboard buffer size
.,EB3A B0 06    BCS $EB42       if the buffer is full just exit
.,EB3C 9D 77 02 STA $0277,X     save the character to the keyboard buffer
.,EB3F E8       INX             increment the index
.,EB40 86 C6    STX $C6         save the keyboard buffer index
.,EB42 A9 7F    LDA #$7F        enable column 7 for the stop key
.,EB44 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,EB47 60       RTS             

                                *** evaluate the SHIFT/CTRL/C= keys
.,EB48 AD 8D 02 LDA $028D       get the keyboard shift/control/c= flag
.,EB4B C9 03    CMP #$03        compare with [SHIFT][C=]
.,EB4D D0 15    BNE $EB64       if not [SHIFT][C=] go ??
.,EB4F CD 8E 02 CMP $028E       compare with last
.,EB52 F0 EE    BEQ $EB42       exit if still the same
.,EB54 AD 91 02 LDA $0291       get the shift mode switch $00 = enabled, $80 = locked
.,EB57 30 1D    BMI $EB76       if locked continue keyboard decode
                                toggle text mode
.,EB59 AD 18 D0 LDA $D018       get the start of character memory address
.,EB5C 49 02    EOR #$02        toggle address b1
.,EB5E 8D 18 D0 STA $D018       save the start of character memory address
.,EB61 4C 76 EB JMP $EB76       continue the keyboard decode
                                select keyboard table
.,EB64 0A       ASL             << 1
.,EB65 C9 08    CMP #$08        compare with [CTRL]
.,EB67 90 02    BCC $EB6B       if [CTRL] is not pressed skip the index change
.,EB69 A9 06    LDA #$06        else [CTRL] was pressed so make the index = $06
.,EB6B AA       TAX             copy the index to X
.,EB6C BD 79 EB LDA $EB79,X     get the decode table pointer low byte
.,EB6F 85 F5    STA $F5         save the decode table pointer low byte
.,EB71 BD 7A EB LDA $EB7A,X     get the decode table pointer high byte
.,EB74 85 F6    STA $F6         save the decode table pointer high byte
.,EB76 4C E0 EA JMP $EAE0       continue the keyboard decode

                                *** table addresses
.:EB79 81 EB                    standard
.:EB7B C2 EB                    shift
.:EB7D 03 EC                    commodore
.:EB7F 78 EC                    control

                                *** standard keyboard table
.:EB81 14 0D 1D 88 85 86 87 11
.:EB89 33 57 41 34 5A 53 45 01
.:EB91 35 52 44 36 43 46 54 58
.:EB99 37 59 47 38 42 48 55 56
.:EBA1 39 49 4A 30 4D 4B 4F 4E
.:EBA9 2B 50 4C 2D 2E 3A 40 2C
.:EBB1 5C 2A 3B 13 01 3D 5E 2F
.:EBB9 31 5F 04 32 20 02 51 03
.:EBC1 FF
                                *** shifted keyboard table
.:EBC2 94 8D 9D 8C 89 8A 8B 91
.:EBCA 23 D7 C1 24 DA D3 C5 01
.:EBD2 25 D2 C4 26 C3 C6 D4 D8
.:EBDA 27 D9 C7 28 C2 C8 D5 D6
.:EBE2 29 C9 CA 30 CD CB CF CE
.:EBEA DB D0 CC DD 3E 5B BA 3C
.:EBF2 A9 C0 5D 93 01 3D DE 3F
.:EBFA 21 5F 04 22 A0 02 D1 83
.:EC02 FF
                                *** CBM key keyboard table
.:EC03 94 8D 9D 8C 89 8A 8B 91
.:EC0B 96 B3 B0 97 AD AE B1 01
.:EC13 98 B2 AC 99 BC BB A3 BD
.:EC1B 9A B7 A5 9B BF B4 B8 BE
.:EC23 29 A2 B5 30 A7 A1 B9 AA
.:EC2B A6 AF B6 DC 3E 5B A4 3C
.:EC33 A8 DF 5D 93 01 3D DE 3F
.:EC3B 81 5F 04 95 A0 02 AB 83
.:EC43 FF

                                *** check for special character codes
.,EC44 C9 0E    CMP #$0E        compare with [SWITCH TO LOWER CASE]
.,EC46 D0 07    BNE $EC4F       if not [SWITCH TO LOWER CASE] skip the switch
.,EC48 AD 18 D0 LDA $D018       get the start of character memory address
.,EC4B 09 02    ORA #$02        mask xxxx xx1x, set lower case characters
.,EC4D D0 09    BNE $EC58       go save the new value, branch always
                                check for special character codes except fro switch to lower case
.,EC4F C9 8E    CMP #$8E        compare with [SWITCH TO UPPER CASE]
.,EC51 D0 0B    BNE $EC5E       if not [SWITCH TO UPPER CASE] go do the [SHIFT]+[C=] key
                                check
.,EC53 AD 18 D0 LDA $D018       get the start of character memory address
.,EC56 29 FD    AND #$FD        mask xxxx xx0x, set upper case characters
.,EC58 8D 18 D0 STA $D018       save the start of character memory address
.,EC5B 4C A8 E6 JMP $E6A8       restore the registers, set the quote flag and exit
                                do the [SHIFT]+[C=] key check
.,EC5E C9 08    CMP #$08        compare with disable [SHIFT][C=]
.,EC60 D0 07    BNE $EC69       if not disable [SHIFT][C=] skip the set
.,EC62 A9 80    LDA #$80        set to lock shift mode switch
.,EC64 0D 91 02 ORA $0291       OR it with the shift mode switch
.,EC67 30 09    BMI $EC72       go save the value, branch always
.,EC69 C9 09    CMP #$09        compare with enable [SHIFT][C=]
.,EC6B D0 EE    BNE $EC5B       exit if not enable [SHIFT][C=]
.,EC6D A9 7F    LDA #$7F        set to unlock shift mode switch
.,EC6F 2D 91 02 AND $0291       AND it with the shift mode switch
.,EC72 8D 91 02 STA $0291       save the shift mode switch $00 = enabled, $80 = locked
.,EC75 4C A8 E6 JMP $E6A8       restore the registers, set the quote flag and exit

                                *** control keyboard table
.:EC78 FF FF FF FF FF FF FF FF
.:EC80 1C 17 01 9F 1A 13 05 FF
.:EC88 9C 12 04 1E 03 06 14 18
.:EC90 1F 19 07 9E 02 08 15 16
.:EC98 12 09 0A 92 0D 0B 0F 0E
.:ECA0 FF 10 0C FF FF 1B 00 FF
.:ECA8 1C FF 1D FF FF 1F 1E FF
.:ECB0 90 06 FF 05 FF FF 11 FF
.:ECB8 FF

                                *** vic ii chip initialisation values
.:ECB9 00 00                    sprite 0 x,y
.:ECBB 00 00                    sprite 1 x,y 
.:ECBD 00 00                    sprite 2 x,y 
.:ECBF 00 00                    sprite 3 x,y
.:ECC1 00 00                    sprite 4 x,y 
.:ECC3 00 00                    sprite 5 x,y 
.:ECC5 00 00                    sprite 6 x,y 
.:ECC7 00 00                    sprite 7 x,y
.:ECC9 00                       sprites 0 to 7 x bit 8
.:ECCA 9B                       enable screen, enable 25 rows
                                vertical fine scroll and control
                                bit function
                                --- -------
                                 7  raster compare bit 8
                                 6  1 = enable extended color text mode
                                 5  1 = enable bitmap graphics mode
                                 4  1 = enable screen, 0 = blank screen
                                 3  1 = 25 row display, 0 = 24 row display
                                2-0 vertical scroll count
.:ECCB 37                       raster compare
.:ECCC 00                       light pen x
.:ECCD 00                       light pen y
.:ECCE 00                       sprite 0 to 7 enable
.:ECCF 08                       enable 40 column display
                                horizontal fine scroll and control
                                bit function
                                --- -------
                                7-6 unused
                                 5  1 = vic reset, 0 = vic on
                                 4  1 = enable multicolor mode
                                 3  1 = 40 column display, 0 = 38 column display
                                2-0 horizontal scroll count
.:ECC0 00                       sprite 0 to 7 y expand
.:ECD1 14                       memory control
                                bit function
                                --- -------
                                7-4 video matrix base address
                                3-1 character data base address
                                 0  unused
.:ECD2 0F                       clear all interrupts
                                interrupt flags
                                 7 1 = interrupt
                                6-4 unused
                                 3  1 = light pen interrupt
                                 2  1 = sprite to sprite collision interrupt
                                 1  1 = sprite to foreground collision interrupt
                                 0  1 = raster compare interrupt
.:ECD3 00                       all vic IRQs disabeld
                                IRQ enable
                                bit function
                                --- -------
                                7-4 unused
                                 3  1 = enable light pen
                                 2  1 = enable sprite to sprite collision
                                 1  1 = enable sprite to foreground collision
                                 0  1 = enable raster compare
.:ECD4 00                       sprite 0 to 7 foreground priority
.:ECD5 00                       sprite 0 to 7 multicolour
.:ECD6 00                       sprite 0 to 7 x expand
.:ECD7 00                       sprite 0 to 7 sprite collision
.:ECD8 00                       sprite 0 to 7 foreground collision
.:ECD9 0E                       border colour
.:ECDA 06                       background colour 0
.:ECDB 01                       background colour 1
.:ECDC 02                       background colour 2
.:ECDD 03                       background colour 3
.:ECDE 04                       sprite multicolour 0
.:ECDF 00                       sprite multicolour 1
.:ECD0 01                       sprite 0 colour
.:ECE1 02                       sprite 1 colour
.:ECE2 03                       sprite 2 colour
.:ECE3 04                       sprite 3 colour
.:ECE4 05                       sprite 4 colour
.:ECE5 06                       sprite 5 colour
.:ECE6 07                       sprite 6 colour
                                sprite 7 colour is actually the first character of "LOAD" ($4C)

                                *** keyboard buffer for auto load/run
.:ECE7 4C 4F 41 44 0D 52 55 4E  'load (cr) run (cr)'
.:ECEA 44 0D 52 55 4E 0D

                                *** low bytes of screen line addresses
.:ECF0 00 28 50 78 A0 C8 F0 18
.:ECF8 40 68 90 B8 E0 08 30 58
