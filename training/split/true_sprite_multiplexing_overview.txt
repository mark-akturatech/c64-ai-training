# Sprite Multiplexing Techniques by Cadaver (Lasse Oorni) - Overview of general (true) sprite multiplexing: allow more than 8 'virtual' sprites by sorting them top-to-bottom and remapping virtual sprites to the 8 physical hardware sprites. Hardware limits: max 8 sprites per raster line; rewriting registers may cause graphical glitches if tightly packed. Tasks: sort sprites by Y, map virtualâ†’physical, write hardware registers in raster IRQs, reset offscreen sprites (Y=255). Optional: reject offscreen or >8-on-row sprites, precalc $D010 values, and doublebuffer sorted sprite table.

2. True (general) sprite multiplexing

This methods allows to freely use sprites as if there were more than 8
available (Green Beret, Ghosts'n Goblins, Midnight Resistance, Turricans when
*not* in a bossfight and many more.) Of course, the hardware limits come into
play: it is simply impossible to display more than 8 sprites on the same raster
line, and because rewriting the sprite registers takes some time, ugly graphical
effects can be displayed if sprites are packed tight and registers are actually
being rewritten while the sprites are being displayed.

The key to general multiplexing is to have the sprites in a list sorted from
top to bottom (using the Y-coordinate), so that the raster interrupts to handle
sprite re-use will always run from top to bottom in a controlled fashion.

It is a bit more complicated than the zone-split multiplexing, but the
complexity will be hidden within the sprite sorting routine and the raster
interrupts that actually display the sprites: to the rest of the program it will
be as easy to access the sprites as if they were hardware sprites (or in fact
easier, because the sprite sorting routine can also take care of bit
manipulation like the X-coord most significant bits or sprite enabled bits)

So, what needs to be done is to:

- Sort the sprites by increasing Y-coordinate, this means the sprites at the
  top of the screen will come first in the sorted order. (done in the sprite
  sorting routine)

- Map the "virtual" sprites onto the C64's 8 physical sprites (done in the
  sprite sorting routine or in the raster interrupts)

- Write the correct values to the sprite hardware registers so that the
  "virtual" sprites can be displayed as correctly as possible (done in the
  raster interrupts)

- When done displaying the sprites, reset their positions to the lowest
  possible position (255). This is to ensure that any sprites aren't
  displayed too early on the next frame, if the sprites are moving downwards.
  If writing the first 8 sprites well before the sprite displaying begins,
  this can be left out!

Optionally, we can:

- Reject sprites that are outside visible X- or Y-coordinate range (this could
  also be responsibility of the main program)

- Reject sprites if there is more than 8 on a row (done in the sprite sorting
  routine or in the raster interrupts.) If this isn't done, some definitely
  ugly graphics will appear when more than 8 sprites try to coexist on a single
  rasterline.

- Figure out beforehand all the raster interrupts' positions and sprite numbers
  that will be (re)written in them.

- Precalculate values of the $d010 register to execute the raster interrupts
  quicker.

- Implement doublebuffering for the "sorted sprite table" used by raster
  interrupts. This allows to sort the sprites for the next frame to display
  while the previous sprites are still being displayed.



---
Additional information can be found by searching:
- "sprite_arrays_and_terms" which expands on defines arrays used for sorting and sprite properties
- "mapping_virtual_to_physical_sprites" which expands on explains how virtual sprites are assigned to physical sprites
- "doublebuffering_sorted_sprite_tables" which expands on doublebuffering sorted arrays to allow sorting while display IRQs run
