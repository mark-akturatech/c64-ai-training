# Kick Assembler - Explains the default memory block of a segment and controlling start address via parameters when .segmentdef is used (e.g., .segmentdef MySegment2 [start=$1000]). Describes startAfter parameter to make one segment start after another: .segmentdef Data [startAfter="Code"]. Useful for reusing memory for init code vs buffer.


By the memory map printed while assembling, you see the start of the Virtual100 segment is aligned to a $100
boundary to avoid spending an extra cycle when accessing the table:
Code-segment:
$8000-$8004 Some code
Virtual100-segment:
*$8100-$81ff Table

In the above example was also used 'virtual' (When no '=' is present its shorthand for 'virtual=true') to declare
all the memory blocks in the virtual100 segment virtual. In most cases this won't be necessary since you just don't
direct the segment anywhere so the generated bytes are thrown away, but in some cases it can come in handy.
'segmentAfter' works by taking the last defined memory block (Either the default or user defined by *=) and
starts where this ends. Block included in other ways (imported from other segments, included from files etc.) are
not considered.

10.8. Including other segments
You can include the memory blocks from other segments into the a segment by using the 'segments' parameter
when defining the segment:
.segmentdef Upstart [start=$0801]
.segmentdef Code
[start=$1000]
.segmentdef Data
[start=$3000]
.segmentdef Combi1 [segments="Code, Data"]
.segmentdef Combi2 [segments="Code, Data, Upstart"]


---
Additional information can be found by searching:
- "segment_naming_and_example_project" which expands on organizing code/data for memory savings
