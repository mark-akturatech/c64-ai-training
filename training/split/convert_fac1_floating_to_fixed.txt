# - Fully Commented Commodore 64 ROM Disassembly (English) - Convert FAC1 from floating to fixed integer: if FAC1 exponent is zero clear FAC1; subtract max-integer exponent ($A0), test sign and handle negative overflow (set overflow byte and twos-complement mantissa), compute shift count and branch to short or long shift routines, and clear overflow on success.


                                *** convert FAC1 floating to fixed
.,BC9B A5 61    LDA $61         get FAC1 exponent
.,BC9D F0 4A    BEQ $BCE9       if zero go clear FAC1 and return
.,BC9F 38       SEC             set carry for subtract
.,BCA0 E9 A0    SBC #$A0        subtract maximum integer range exponent
.,BCA2 24 66    BIT $66         test FAC1 sign (b7)
.,BCA4 10 09    BPL $BCAF       branch if FAC1 +ve
                                FAC1 was -ve
.,BCA6 AA       TAX             copy subtracted exponent
.,BCA7 A9 FF    LDA #$FF        overflow for -ve number
.,BCA9 85 68    STA $68         set FAC1 overflow byte
.,BCAB 20 4D B9 JSR $B94D       twos complement FAC1 mantissa
.,BCAE 8A       TXA             restore subtracted exponent
.,BCAF A2 61    LDX #$61        set index to FAC1
.,BCB1 C9 F9    CMP #$F9        compare exponent result
.,BCB3 10 06    BPL $BCBB       if < 8 shifts shift FAC1 A times right and return
.,BCB5 20 99 B9 JSR $B999       shift FAC1 A times right (> 8 shifts)
.,BCB8 84 68    STY $68         clear FAC1 overflow byte
.,BCBA 60       RTS             


---
Additional information can be found by searching:
- "shift_fac1_right_a_times" which expands on short-shift path for shifting FAC1 right A times (<8 shifts)
- "shift_fac1_right_a_times" which expands on calls long-shift subroutine for >8 shifts via JSR $B999/$B9B0
- "clear_fac1" which expands on called when exponent is zero (result cleared)
