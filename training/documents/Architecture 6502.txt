Architecture of 6502 Microprocessor

The 6502 microprocessor was manufactured by MOS Technology in the late 1970’s, and was the main processor in a variety of early microcomputers, such as the Apple II, BBC Model B, Acorn Electron, Atari 800 and the Commodore 64, Vic 20 and PET models.

It had a relatively simple instruction set by modern standards, which made it cheap to produce.

Basic Specifications

Clock speed	1, 2 and even 3 Mhz models were available.

Wordlength	8 bits

Input / Output	Memory mapped.

There are no I/O registers in the processor, so a set of memory addresses will be allocated to the I/O devices.  The motherboard hardware will ensure that if a value is written to memory address $E000 (for example), it will be sent straight to a specific output device.

Addresses

Address bus	16 bits

Addresses in the range 	0000000000000000 	to 	1111111111111111 	binary

or			$0000 			to	$FFFF 			hex

can be accessed by the processor.

Adressable Memory is therefore	64 Kb

Little endian	Addresses stored least significant byte first.

A 16 bit address needs to be stored in two consecutive bytes.  A little endian processor will store the address $458D as $8D followed by the byte $45.


Paged Memory

Memory is viewed as a set of 256 byte pages.

The first page ($0000 to $00FF) is called the ‘Zero page’, and can be accessed by using a special addressing mode which enables you to use shorter and therefore faster executing instructions.

This makes it useful for storing tables of values or addresses that are going to be accessed frequently by your program.

The second page ($0100 to $01FF) is used to hold the system stack.  This is used to keep track of values, especially during subroutine calls.  It cannot be moved.

Other reserved locations:

$FFFA		Address of NMI handler
$FFFB		ditto
$FFFC		Address of power on reset location
$FFFD		ditto
$FFFE		BRK / interrupt request handler
$FFFF		ditto
Registers

The 6502 only has 6 registers.  Five are 8 bits wide, one is 16 bits wide.

	A		Accumulator
			
	X		Index Register X
			
	Y		Index Register Y
			
PCH	PCL		Program Counter
			
	S		Stack Pointer
			
	P		Processor Status  (Flags)


Accumulator		8 bits		A

Used for all arithmetic and logical operations (apart from increments and decrements).  Data must be loaded into the Acc before it can be manipulated.


Index Register X	8 bits		X

Usually used to hold counters or offsets for accessing memory.  Contents can be compared with memory locations and incremented and decremented.

Unlike other registers (including the Y register), can be used to get a copy of the stack pointer or change its value.


Index Register Y	8 bits		Y

Usually used to hold counters or offsets for accessing memory.  Contents can be compared with memory locations and incremented or decremented.


Program Counter	16 bits		PC


Contains the address of the next instruction to be executed.  Automatically incremented by the hardware, but can be altered by a jump, branch or subroutine call / return.


Stack Pointer		8 bits		S

The 6502 uses a 256 byte stack located on page 1 ($0100 to $01FF).  The stack pointer is an 8 bit register that holds the least significant byte of the next free location on the stack.  This means that the stack cannot be moved.  The stack starts at $01FF and grows downward.  When a byte is pushed onto the stack, the stack pointer is decremented.  When something is popped off the stack, it is incremented.

The hardware does not detect stack overflow.  The programmer must ensure that the program does not make excessive demands on the stack space.

Processor Status Register


N	V	-	B	D	I	Z	C


Also known as the flags register.  Used to indicate the results of an operation.  Each bit in the register signifies a different condition.

Some of the instructions allow you to test the values of various bits, set them, clear them, and push the entire set onto the stack (or pop them off).


Carry Flag	C

The carry flag is set if the last operation caused an overflow from the most significant bit (bit 7) of the result or an underflow from the least significant bit (bit 0). 

This condition is set during arithmetic instructions, comparison instructions and during logical shifts.  It can be explicitly set using the 'Set Carry Flag' (SEC) instruction and cleared with 'Clear Carry Flag' (CLC).


Zero Flag 	Z

The zero flag is set if the result of the last operation was zero.


Interrupt Disable 	I

The interrupt disable flag is set if the program has executed a 'Set Interrupt Disable' (SEI) instruction. While this flag is set the processor will not respond to interrupts from external devices until it is cleared by a 'Clear Interrupt Disable' (CLI) instruction.


Decimal Mode 		D

While the decimal mode flag is set the processor will obey the rules of Binary Coded Decimal (BCD) arithmetic during addition and subtraction. The flag can be explicitly set using 'Set Decimal Flag' (SED) and cleared with 'Clear Decimal Flag' (CLD).


Break Command 	B

The break command bit is set when a BRK instruction has been executed and an interrupt has been generated to process it.


Overflow Flag 		V

The overflow flag is set during arithmetic operations if the result has yielded an invalid 2's complement result (e.g. adding two positive numbers and ending up with a negative result: 64 + 64 => -128). 

If the most significant bit of the two numbers being added is the same, and if it is different to the msb of the result, then the overflow flag will be set.

Negative Flag 		N

The negative flag is set if the result of the last operation had the most significant bit (bit 7) set to a one.

