# Using an Assembler (Commodore Macro Assembler Development System)

**Summary:** Describes that the book's examples are in 6502 assembly and use Commodore's Macro Assembler Development System (CMDAS); notes that assembler pseudo-opcodes/directives (e.g., BYTE) vary between assemblers and must be adapted when porting listings.

**Overview**

The book's examples are written in assembly language for the 6502 and were produced with Commodore's Macro Assembler Development System (CMDAS). BASIC programmers may still reuse some routines from these listings to speed up parts of BASIC programs.

Each assembler provides its own set of pseudo-opcodes (assembler directives)—instructions that tell the assembler to do something other than generate machine code (for example, storage/data directives, origin setting, equates, and macro facilities). To run the examples with a different assembler, you must translate CMDAS pseudo-opcodes to the equivalent directives for your assembler. In general, a pseudo-opcode may be placed anywhere a CPU opcode is legal in the source listing, so you can often substitute directives inline when adapting code.

The book's listings assume CMDAS semantics and dialect; adapting them typically requires:

- Translating data and byte directives (e.g., BYTE) to the target assembler's data directives.
- Adjusting origin/address directives and label syntax if necessary.
- Replacing macro/pseudo-opcode names and parameters with equivalents in the target assembler.

**CMDAS Pseudo-Opcodes**

CMDAS provides several assembler directives (pseudo-opcodes) to facilitate assembly programming. Below is a list of these directives:

- `.BYTE`: Reserves one byte of memory and loads it with a value. Multiple operands can store values in consecutive bytes. ASCII strings can be generated by enclosing the string in quotes. For example:


  Note: Numbers may be represented in various forms, including decimal, hexadecimal (prefixed with `$`), octal (prefixed with `@`), and binary (prefixed with `%`).

- `.WORD`: Reserves two bytes of memory and loads them with a value. Multiple operands can store values in consecutive words. For example:


- `.DBYTE`: Similar to `.WORD`, but reserves two bytes for each operand. For example:


- `.PAGE`: Aligns the program counter to the next page boundary (256-byte boundary). This is useful for ensuring that code or data starts at a page boundary.

- `.SKIP`: Skips a specified number of bytes in memory, effectively advancing the program counter. For example:


  This would advance the program counter by 10 bytes.

- `.OPT`: Sets assembler options. The specific options available depend on the assembler's implementation.

- `.END`: Marks the end of the source file. The assembler will stop processing the source code upon encountering this directive.

- `.FILE`: Specifies an external file to include in the assembly. This is useful for including common routines or data.

- `.LIB`: Specifies a library file to include in the assembly. This allows for modular programming by including pre-assembled code or data.

- `=` (Equate): Assigns a value to a symbol. This is used to define constants or symbolic names for values. For example:


- `*` (Asterisk): Represents the current value of the location counter. This is used to set the program counter to a specific address. For example:


  This sets the program counter to address `$2000`.

**Translation of CMDAS Pseudo-Opcodes to Other Assemblers**

When porting CMDAS assembly code to other assemblers, it's essential to translate CMDAS pseudo-opcodes to their equivalents in the target assembler. Below is a mapping of CMDAS pseudo-opcodes to directives in other common assemblers:

| CMDAS Directive | Description                                      | Other Assemblers' Equivalent Directives |
|-----------------|--------------------------------------------------|-----------------------------------------|
| `.BYTE`         | Define byte(s)                                   | `.DB` (Intel), `.BYTE` (Merlin), `.BY` (MADS) |
| `.WORD`         | Define word(s) (2 bytes)                         | `.DW` (Intel), `.WORD` (Merlin), `.WO` (MADS) |
| `.DBYTE`        | Define double byte(s) (2 bytes)                  | `.DW` (Intel), `.WORD` (Merlin), `.WO` (MADS) |
| `.PAGE`         | Align to page boundary                           | `.ALIGN 256` (various assemblers)       |
| `.SKIP`         | Skip bytes                                       | `.DS` (Intel), `.DS.B` (MADS)           |
| `.OPT`          | Set assembler options                            | Assembler-specific                      |
| `.END`          | End of source file                               | `.END` (common across assemblers)       |
| `.FILE`         | Include external file                            | `.INCLUDE` (various assemblers)         |
| `.LIB`          | Include library file                             | Assembler-specific                      |
| `=`             | Define constant                                  | `EQU` (Intel), `=` (Merlin)             |
| `*`             | Set program counter                              | `ORG` (Intel), `*` (Merlin)             |

Note: The exact syntax and availability of directives may vary between assemblers. Always refer to the target assembler's documentation for precise usage.

**Example: Using the BYTE Directive**

The `.BYTE` directive in CMDAS is used to reserve memory and initialize it with specified values. Here's an example demonstrating its use:


In this example:

- The program counter is set to `$1000`.
- The label `LABEL` is assigned to this address.
- The values `1`, `2`, and `3` are stored in consecutive memory locations.
- The ASCII character `'A'` is stored in the next memory location.
- The ASCII string `'BCD'` is stored in the subsequent memory locations.

When adapting this code to another assembler, ensure that the equivalent directive for `.BYTE` is used, and adjust the syntax as required by the target assembler.

## Source Code

  ```
  .BYTE 2
  .BYTE 1, $F, @3, %101, 7
  .BYTE 'ABCDEFH'
  ```

  ```
  .WORD $1234
  .WORD 1, 2, 3
  ```

  ```
  .DBYTE $1234, $5678
  ```

  ```
  .SKIP 10
  ```

  ```
  RED = 5
  BLUE = $FF
  ```

  ```
  * = $2000
  ```

```
* = $1000        ; Set program counter to $1000
LABEL .BYTE 1    ; Store the value 1 at address $1000
       .BYTE 2   ; Store the value 2 at address $1001
       .BYTE 3   ; Store the value 3 at address $1002
       .BYTE 'A' ; Store the ASCII value of 'A' at address $1003
       .BYTE 'BCD' ; Store ASCII values of 'B', 'C', 'D' at addresses $1004, $1005, $1006
```


## References

- "pseudo_opcode_byte_directive" — expands on specific pseudo-opcode examples (BYTE)
- "assembler_porting_and_translation_advice" — advice on adapting listings to other assemblers

## Labels
- RED
- BLUE
