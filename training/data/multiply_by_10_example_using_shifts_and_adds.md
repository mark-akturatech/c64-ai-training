# 6502: Multiply a two-byte value by 10 using ASL/ROL + ADC

**Summary:** Example 6502 assembly to multiply a 16-bit value (NUM, NUM+1) by 10 using shifts and addition: uses ASL/ROL to form 2x and 4x, ADC to form 5x, then ASL/ROL to get 10x. Searchable terms: ASL, ROL, ADC, CLC, two-byte multiplication, shifts, carry propagation.

## Algorithm
This routine computes 10 * NUM for a two-byte (little-endian) value NUM/NUM+1 by composing powers of two: 10x = 8x + 2x (equivalently 2*(4x + x)). The steps:

- Copy NUM into RESULT (two bytes).
- Use ASL RESULT / ROL RESULT+1 to compute 2 * NUM (low byte shifted by ASL, high byte rotated through carry by ROL).
- Repeat ASL/ROL to compute 4 * NUM.
- Add NUM to 4*NUM (CLC; ADC low byte, ADC high byte) to produce 5*NUM (ADC carries propagate from low to high).
- Final ASL/ROL produces 10*NUM from 5*NUM.

Key implementation details:
- ASL shifts the low byte left and sets the carry to the bit shifted out; ROL on the high byte rotates that carry into the high byte, preserving multi-byte shifts.
- Clear carry (CLC) before ADC so the low-byte addition doesn't include a stray carry.
- ADC of the high byte includes the carry generated by the low-byte ADC, producing correct 16-bit addition.
- The routine stores the 16-bit product back into RESULT/RESULT+1. Any overflow beyond 16 bits (a 17th bit) will be left in the processor carry after the final ASL/ROL (not stored unless the caller saves it).

## Source Code
```asm
        ; Multiply 16-bit NUM (NUM = low, NUM+1 = high) by 10, store in RESULT/RESULT+1

        LDA NUM
        STA RESULT
        LDA NUM+1
        STA RESULT+1

        ASL RESULT
        ROL RESULT+1      ; RESULT = 2 * NUM

        ASL RESULT
        ROL RESULT+1      ; RESULT = 4 * NUM

        CLC
        LDA NUM
        ADC RESULT
        STA RESULT        ; low byte: NUM + (4*NUM) -> low of 5*NUM
        LDA NUM+1
        ADC RESULT+1
        STA RESULT+1      ; high byte: include carry -> high of 5*NUM

        ASL RESULT
        ROL RESULT+1      ; RESULT = 10 * NUM
```

## References
- "multiply_by_non_power_of_two_strategy" — composing powers of two to multiply by non-power constants
- "binary_decomposition_of_constants_examples" — binary representation of constants (10 = 1010b) and corresponding shifts

## Mnemonics
- ASL
- ROL
- ADC
- CLC
