# Kick Assembler: .segmentdef — start, startAfter, virtual, segments

**Summary:** Describes Kick Assembler .segmentdef parameters: start ($1000), startAfter (make one segment start after another), virtual shorthand (virtual=true when no '=' present), segment alignment (e.g., align to $100 boundary), and including other segments via segments="Code, Data". Examples use addresses $0801, $1000, $3000, $8000, $8100-$81FF.

**Overview**
.segmentdef accepts parameters to control where a segment's default memory block(s) are placed (start, startAfter), to declare blocks virtual, and to include blocks from other segments using the segments parameter. The assembler prints a memory map while assembling; you can use start/startAfter to control exact placement and alignment to optimize runtime access patterns (example: aligning a table to a $100 boundary to avoid an extra access cycle).

**start / startAfter behavior**
- **start** sets the explicit start address for the segment's default memory block (e.g., .segmentdef MySegment2 [start=$1000]).
- **startAfter** makes a segment start immediately after the last defined memory block of another segment: .segmentdef Data [startAfter="Code"].
- The "last defined memory block" is the last memory block defined for that segment by the assembler itself (either the default block or one explicitly set with *=). Blocks that were added to a segment by importing from other segments, including files, or other inclusion mechanisms are NOT considered when computing the end for startAfter.
- This makes it possible to reuse address ranges (for example, use the same region for init code at runtime and a buffer at build time) by ordering and chaining segments.

**virtual shorthand**
- When a segment parameter value is provided without an '=' sign (e.g., using the keyword virtual without =), it is shorthand for virtual=true. Declaring a memory block virtual means its generated bytes are not directed to an output memory image by default — they are effectively discarded unless explicitly directed.
- In most cases, virtual is unnecessary because if you don't direct a segment anywhere, its bytes are already unused; virtual can be handy when you want to make that explicit for certain blocks (e.g., temporary tables or debug data).

**Alignment / Practical effect shown in assembler map**
- The assembler's memory map can show alignment choices used to avoid runtime penalties. Example: a table in a "Virtual100" segment is placed on a $100 boundary so table accesses avoid an extra cycle:
  - Code-segment: $8000-$8004 Some code
  - Virtual100-segment: *$8100-$81FF Table

**Including other segments**
- Use the segments parameter to include the memory blocks from other segments into the new segment definition:
  - .segmentdef Upstart [start=$0801]
  - .segmentdef Code [start=$1000]
  - .segmentdef Data [start=$3000]
  - .segmentdef Combi1 [segments="Code, Data"]
  - .segmentdef Combi2 [segments="Code, Data, Upstart"]
- The segments parameter concatenates or merges blocks from the named segments into the new segment definition. When segments have overlapping memory blocks, the assembler detects overlaps and, by default, reports them as errors. However, you can allow overlaps by using the allowOverlap parameter. In such cases, overlapping blocks are resolved by prioritizing the latest added blocks; the bytes from the block added last will take precedence. ([theweb.dk](https://www.theweb.dk/KickAssembler/webhelp/content/ch10s12.html?utm_source=openai))

## Source Code
```asm
.segmentdef MySegment2 [start=$1000]
.segmentdef Data [startAfter="Code"]

; Example memory map printed while assembling:
; Code-segment:
; $8000-$8004 Some code
; Virtual100-segment:
; *$8100-$81FF Table

; 'virtual' shorthand example (no '=' -> virtual=true)
; When no '=' is present, it's shorthand for 'virtual=true' to declare
; all the memory blocks in the virtual100 segment virtual.

.segmentdef Upstart [start=$0801]
.segmentdef Code [start=$1000]
.segmentdef Data [start=$3000]
.segmentdef Combi1 [segments="Code, Data"]
.segmentdef Combi2 [segments="Code, Data, Upstart"]
```

## References
- "segment_naming_and_example_project" — expands on organizing code/data for memory savings
- Kick Assembler Manual: Overlapping memory block ([theweb.dk](https://www.theweb.dk/KickAssembler/webhelp/content/ch10s12.html?utm_source=openai))