[{"id": "map-EA13", "address_start": 59923, "address_end": 59923, "hex_start": "$EA13", "hex_end": "$EA13", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59923         $EA13\nSet Cursor Blink Timing and Color Memory Address for Print to Screen\n\nThis subroutine sets the cursor blink countdown and sets the pointer\nto Color RAM.  It then falls through to the next routine."}, {"id": "map-EA1C", "address_start": 59932, "address_end": 59932, "hex_start": "$EA1C", "hex_end": "$EA1C", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59932         $EA1C\nStore to Screen\n\nThis routine stores the character in the .A register to the screen\naddress pointed to by 209 ($D1), and stores the color in the .X\nregister to the address pointed to by 243 ($F3)."}, {"id": "map-EA24", "address_start": 59940, "address_end": 59940, "hex_start": "$EA24", "hex_end": "$EA24", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59940         $EA24\nSynchronize Color RAM Pointer to Screen Line Pointer\n\nThis subroutine sets the pointer at 243 ($F3) to the address of the\nbeginning of the line of Color RAM which corresponds to the current\nline of screen RAM (whose pointer is at 209 ($D1))."}, {"id": "map-EA31", "address_start": 59953, "address_end": 59953, "hex_start": "$EA31", "hex_end": "$EA31", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59953         $EA31\nIRQ Interrupt Entry\n\nThis is the entry point to the standard IRQ interrupt handler.  Timer\nA of CIA #1 is set at power-on to cause an IRQ interrupt to occur\nevery 1/60 second.  When the interrupt occurs, program flow is\ntransferred here via the CINV vector at 788 ($314).  This routine\nupdates the software clock at 160-162 ($A0-$A2), handles the cursor\nflash, and maintains the tape interlock which keeps the cassette motor\non if a button is pushed and the interlock flag is on.  Finally, it\ncalls the keyboard scan routine, which checks the keyboard and puts\nany character it finds into the keyboard buffer."}, {"id": "map-EA87", "address_start": 60039, "address_end": 60039, "hex_start": "$EA87", "hex_end": "$EA87", "label": "SCNKEY", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60039         $EA87          SCNKEY\nRead the Keyboard\n\nThis subroutine is called by the IRQ interrupt handler above to read\nthe keyboard device which is connected to CIA #1 (see entry for 56320\n($DC00) for details on how to read the keyboard).\n\nIt is the Kernal routine SCNKEY which can be entered from the jump\ntable at 65439 ($FF9F).  This routine returns the keycode of the key\ncurrently being pressed in 203 ($CB), sets the shift/control flag if\nappropriate, and jumps through the vector at 655 ($28F) to the routine\nthat sets up the proper table to translate the keycode to PETASCII.\nIt concludes with the next routine, which places the PETASCII value of\nthe character in the keyboard buffer."}, {"id": "map-EAE0", "address_start": 60128, "address_end": 60128, "hex_start": "$EAE0", "hex_end": "$EAE0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60128         $EAE0\nDecode the Keystroke and Place its ASCII Value in the Keyboard Buffer\n\nThis is the continuation of the IRQ keyscan routine.  It decodes the\nkeycode with the proper PETASCII table, and compares it with the last\nkeystroke.  If if is the same, it checks to see if it is okay to\nrepeat the character without waiting for the key to be let up.  If the\ncharacter should be printed, it is moved to the end of the keyboard\nbuffer at 631 ($277)."}, {"id": "map-Eb48", "address_start": 60232, "address_end": 60232, "hex_start": "$Eb48", "hex_end": "$Eb48", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60232         $Eb48\nSet Up the Proper Keyboard Decode Table\n\nThis routine is pointed to by the vector at 655 ($28F).  Its function\nis to read the shift/control flag at 653 ($28D), and set the value of\nthe decode table pointer at 245 ($F5) accordingly.\n\nFirst it checks if the SHIFT/Commodore logo combination was pressed,\nand if the toggle enable at 657 (291) will allow a change, the\ncharacter set will be changed to lowercase/uppercase or\nuppercase/graphics by changing the VIC Memory Control Register at\n53272 ($D018), and no character will be printed.\n\nNext it sets the decode table pointer.  There are 64 keys, and each\ncan have four different PETASCII values, depending on whether the key\nis pressed by itself, or in combination with the SHIFT, CTRL, or\nCommodore logo keys.  Therefore, there are four tables of 64 entries\neach to translate the keycode to PETASCII:  the standard table, the\nSHIFT table, the Commodore logo table, and the CONTROL table.  The\nroutine will set up the pointer for the appropriate table, depending\non whether the SHIFT, CTRL, or logo key was pressed.  The CTRL key\ntakes precedence, so that if another of these keys is pressed along\nwith the CTRL key, the CONTROL table is used."}, {"id": "map-EB79", "address_start": 60281, "address_end": 60281, "hex_start": "$EB79", "hex_end": "$EB79", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60281         $EB79\nKeyboard Decode Table Vectors\n\nThis table contains the two-byte addresses of the four keyboard decode\ntables in low-byte, high-byte format."}, {"id": "map-EB81", "address_start": 60289, "address_end": 60289, "hex_start": "$EB81", "hex_end": "$EB81", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60289         $EB81\nStandard Keyboard Matrix Decode Table\n\nThis table contains the 64 PETASCII values for the standard keyboard,\none for each key which is struck by itself.  The table is in keycode\norder (see the keycode table in Appendix H for the correspondence of\nkeycode to key).  A 65th byte with the value of 255 ($FF) marks the\nend of the table (this corresponds to a keypress value of 64, no key\npressed)."}, {"id": "map-EBC2", "address_start": 60354, "address_end": 60354, "hex_start": "$EBC2", "hex_end": "$EBC2", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60354         $EBC2\nSHIFTed Keyboard Matrix Decode Table\n\nThis table contains the 64 PETASCII values for the shifted keyboard,\none for each key which is struck while the SHIFT key is pressed.  The\ntable is in keycode order (see the keycode table in Appendix H for the\ncorrespondence of keycode to key).  A 65th byte with the value of 255\n($FF) marks the end of the table (this corresponds to a keypress value\nof 64, no key pressed)."}, {"id": "map-EC03", "address_start": 60419, "address_end": 60419, "hex_start": "$EC03", "hex_end": "$EC03", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60419         $EC03\nCommodore Logo Keyboard Matrix Decode Table\n\nThis table contains the 64 PETASCII values for the logo keyboard, one\nfor each key which is struck while the Commodore logo key is pressed.\nThe table is in keycode order (see the keycode table in Appendix H for\nthe correspondence of keycode to key).  A 65th byte with the value of\n255 ($FF) marks the end of the table (this corresponds to a keypress\nvalue of 64, no key pressed)."}, {"id": "map-EC44", "address_start": 60484, "address_end": 60484, "hex_start": "$EC44", "hex_end": "$EC44", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60484         $EC44\nSet Lowercase/Uppercase or Uppercase/Graphics Character Set\n\nThe part of the Kernal CHROUT routine that outputs to the screen uses\nthis subroutine to check for the special nonprinting characters that\nswitch the character set (CHR$(14) and CHR$(142)).  If one of these is\nthe character to be printed, this routine makes the switch by setting\nthe location 53272 ($D018) accordingly."}, {"id": "map-EC5E", "address_start": 60510, "address_end": 60510, "hex_start": "$EC5E", "hex_end": "$EC5E", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60510         $EC5E\nSet Flag to Enable or Disable Switching Character Sets\n\nThis subroutine is also used to check for special characters to print.\nIn this case, it checks for the characters that enable or disable the\nSHIFT/logo combination from toggling the character set currently in\nuse (CHR$(8) and CHR$(9)).  If one of these is to be printed, the flag\nat 657 ($291) is changed."}, {"id": "map-EC78", "address_start": 60536, "address_end": 60536, "hex_start": "$EC78", "hex_end": "$EC78", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60536         $EC78\nControl Keyboard Matrix Decode Table\n\nThis table contains the 64 PETASCII values for the Control keyboard,\none for each key which is struck while the CTRL key is pressed.  The\ntable is in keycode order (see the keycode table in Appendix H for the\ncorrespondence of keycode to key).  A 65th byte with the value of 255\n($FF) marks the end of the table (this corresponds to a keypress value\nof 64, no key pressed).\n\nThe only keys generally struck in combination with the CTRL key are\nthe ones that change the colors on the top row of the keyboard, but\nthis doesn't necessarily mean that the other CTRL key combinations\ndon't do anything.  On the contrary, looking at the values in this\ntable, you can see that any of the first 32 values in the PETASCII\ntable can be produced by some combination of the CTRL key and another\nkey.  CTRL-@ produces a CHR$(0).  CTRL-A through CTRL-Z produce\nCHR$(1) through CHR$(26).  Ctrl-: is the same as CHR$(27), CTRL-Lira\n(that's the slashed-L British pound sign) produces CHR$(28), CTRL-;\nequals CHR$(29), CTRL-up arrow produces CHR$(30), and CTRL-= produces\nCHR$(31).\n\nAny of these combinations produce the same effect as the CHR$(X)\nstatement.  For examble, CTRL-; moves the cursor over to the right,\nCTRL-N switches to lowercase, CTRL-R turns on reverse video, and\nCTRL-E changes the printing to white."}, {"id": "map-ECB9", "address_start": 60601, "address_end": 60601, "hex_start": "$ECB9", "hex_end": "$ECB9", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60601         $ECB9\nVideo Chip Register Default Table\n\nThis table contains the default values that are stored in the 47\nVIC-II chip registers.  It is interesting to note that this table\nappears to be incomplete.  While Sprite Color Registers 0-6 are\ninitialized to values of 1-7, Sprite Color Register 7 is initialized\nto 76--the ASCII value of the letter L which begins on the next table."}, {"id": "map-ECE7", "address_start": 60647, "address_end": 60647, "hex_start": "$ECE7", "hex_end": "$ECE7", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60647         $ECE7\nText for Keyboard Buffer When SHIFT/RUN is Pressed\n\nWhen the SHIFT and RUN keys are pressed, the ASCII text stored here is\nforced into the keyboard buffer.  That text is LOAD, carriage return,\nRUN, carriage return."}, {"id": "map-ECF0", "address_start": 60656, "address_end": 60656, "hex_start": "$ECF0", "hex_end": "$ECF0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60656         $ECF0\nLow Byte Table of Screen Line Addresses\n\nThis table holds the low byte of the screen address for lines 0-24.\nThe high byte is derived from combining a value from the screen line\nlink table at 217 ($D9) with the pointer to screen memory at 648\n($288)."}, {"id": "map-ED09", "address_start": 60681, "address_end": 60681, "hex_start": "$ED09", "hex_end": "$ED09", "label": "TALK", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60681         $ED09          TALK\nSend TALK to a Device on the Serial Bus\n\nThis is a documented Kernal routine whose entry in the jump table is\n65460 ($FFB4).  When called, it ORs the device number in the\nAccumulator with the TALK code (64, $40) and sends it on the serial\nbus.  This commands the device to TALK."}, {"id": "map-ED0C", "address_start": 60684, "address_end": 60684, "hex_start": "$ED0C", "hex_end": "$ED0C", "label": "LISTEN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60684         $ED0C          LISTEN\n\nThis is a documented Kernal routine whose entry in the jump table is\n65457 ($FFB1).  When called, it ORs the device number in the\nAccumulator with the LISTEN code (32, $20) and sends it on the serial\nbus.  This commands the device to LISTEN."}, {"id": "map-ED11", "address_start": 60689, "address_end": 60689, "hex_start": "$ED11", "hex_end": "$ED11", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60689         $ED11\nSend Command Code to a Device on the Serial Bus\n\nThis subroutine is used in common by many Kernal routines to send the\ncommand code in the Accumulator to a device on the serial bus."}, {"id": "map-ED40", "address_start": 60736, "address_end": 60736, "hex_start": "$ED40", "hex_end": "$ED40", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60736         $ED40\nSend a Byte on the Serial Bus\n\nThis subroutine is used in common by several Kernal routines to send\nthe byte in the serial bus character buffer at 149 ($95) on the serial\nbus."}, {"id": "map-EDB0", "address_start": 60848, "address_end": 60848, "hex_start": "$EDB0", "hex_end": "$EDB0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60848         $EDB0\nTime-Out Error on Serial Bus\n\nThis subroutine handles the case when the device does not respond by\nsetting the DEVICE NOT PRESENT error code and exiting."}, {"id": "map-EDB9", "address_start": 60857, "address_end": 60857, "hex_start": "$EDB9", "hex_end": "$EDB9", "label": "SECOND", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60857         $EDB9          SECOND\nSend a Secondary Address to a Device on the Serial Bus after LISTEN\n\nThis is a documented Kernal routine that can be entered from the jump\ntable at 65427 ($FF93).  It sends a secondary address from the\nAccumulator to the device on the serial bus that has just been\ncommanded to LISTEN.  This is usually done to give the device more\nparticular instructions on how the I/O is to be carried out before\ninformation is sent."}, {"id": "map-EDC7", "address_start": 60871, "address_end": 60871, "hex_start": "$EDC7", "hex_end": "$EDC7", "label": "TKSA", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60871         $EDC7          TKSA\nSend a Secondary Address to a Device on the Serial Bus after TALK\n\nThis is a documented Kernal routine that can be entered from the jump\ntable at 65430 ($FF96).  It sends a secondary address from the\nAccumulator to the device on the serial bus that has just been\ncommanded to TALK.  This is usually done to give the device more\nparticular instructions on how the I/O is to be carried out before\ninformation is sent."}, {"id": "map-EDDD", "address_start": 60893, "address_end": 60893, "hex_start": "$EDDD", "hex_end": "$EDDD", "label": "CIOUT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60893         $EDDD          CIOUT\nSend a Byte to an I/O Device over the Serial Bus\n\nThis is a documented Kernal routine which can be entered from the jump\ntable at 65448 ($FFA8).  Its purpose is to send a byte of data over\nthe serial bus.  In order for the data to be received, the serial\ndevice must have first been commanded to LISTEN and been given a\nsecondary address if necessary.  This routine always buffers the\ncurrent character, and defers sending it until the next byte is\nbuffered.  When the UNLISTEN command is sent, the last byte will be\nsent with an End or Identify (EOI)."}, {"id": "map-EDEF", "address_start": 60911, "address_end": 60911, "hex_start": "$EDEF", "hex_end": "$EDEF", "label": "UNTLK", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60911         $EDEF          UNTLK\nSend UNTALK to a Device on the Serial Bus\n\nThis is a documented Kernal routine whose entry in the jump table is\n65451 ($FFAB).  When called, it sends the UNTALK code (95, $5F) on the\nserial bus.  This commands any TALKer on the bus to stop sending data."}, {"id": "map-EDFE", "address_start": 60926, "address_end": 60926, "hex_start": "$EDFE", "hex_end": "$EDFE", "label": "UNLSN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60926         $EDFE          UNLSN\nSend UNLISTED to a Device on the Serial Bus\n\nThis is a documented Kernal routine whose entry in the jump table is\n65454 ($FFAE).  It sends the UNLISTEN code (63, $3F) on the serial\nbus.  This commands any LISTENers to get off the serial bus, and frees\nup the bus for other users."}, {"id": "map-EE13", "address_start": 60947, "address_end": 60947, "hex_start": "$EE13", "hex_end": "$EE13", "label": "ACPTR", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "60947         $EE13          ACPTR\nReceive a Byte of Data from a Device on the Serial Bus\n\nThis is a documented Kernal routine whose entry point in the jump\ntable is 65445 ($FFA5).  When called, it will get a byte of data from\nthe current TALKer on the serial bus and store it in the Accumulator.\nIn order to receive the data, the device must have previously been\nsent a command to TALK and a secondary address if it needs one."}, {"id": "map-EE85", "address_start": 61061, "address_end": 61061, "hex_start": "$EE85", "hex_end": "$EE85", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61061         $EE85\nSet the Serial Clock Line Low (Active)\n\nThis subroutine clears the serial bus clock pulse output bit (Bit 4 of\nCIA #2 Data Port A at 56576 ($DD00))."}, {"id": "map-EE8E", "address_start": 61070, "address_end": 61070, "hex_start": "$EE8E", "hex_end": "$EE8E", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61070         $EE8E\nSet the Serial Clock Line High (Inactive)\n\nThis subroutine sets the serial bus clock pulse output bit to 1 (Bit 4\nof CIA #2 Data Port A at 56576 ($DD00))."}, {"id": "map-EE97", "address_start": 61079, "address_end": 61079, "hex_start": "$EE97", "hex_end": "$EE97", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61079         $EE97\nSet Serial Bus Data Output Line Low\n\nThis subroutine clears the serial bus data output to 0 (Bit 5 of CIA\n#2 Data Port A at 56576 ($DD00))."}, {"id": "map-EEA9", "address_start": 61097, "address_end": 61097, "hex_start": "$EEA9", "hex_end": "$EEA9", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61097         $EEA9\nGet Serial Bus Data Input Bit and Clock Pulse Input Bit\n\nThis subroutine reads the serial bus data input bit and clock pulse\ninput bit (Bits 7 and 6 of CIA #2 Data Port A at 56576 ($DD00)), and\nreturns the data bit in the Carry flag and the clock bit in the\nNegative flag."}, {"id": "map-EEB3", "address_start": 61107, "address_end": 61107, "hex_start": "$EEB3", "hex_end": "$EEB3", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61107         $EEB3\nPerform a One-Millisecond Delay"}, {"id": "map-EEBB", "address_start": 61115, "address_end": 61115, "hex_start": "$EEBB", "hex_end": "$EEBB", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61115         $EEBB\nSend Next RS-232 Bit (NMI)\n\nThis subroutine is called by the NMI interrupt handler routine to send\nthe next bit of data to the RS-232 device."}, {"id": "map-EF2E", "address_start": 61230, "address_end": 61230, "hex_start": "$EF2E", "hex_end": "$EF2E", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61230         $EF2E\nHandle RS-232 Errors\n\nThis subroutine sets the appropriate error bits in the status register\nat 663 ($297).\n\n61258         $#F4A\nSet the Word Length For the Current RS-232 Character\n\nThis routine takes the number of data bits to send per RS-232\ncharacter from the control register and puts it into the .X register\nfor use by the RS-232 routines."}, {"id": "map-EF59", "address_start": 61273, "address_end": 61273, "hex_start": "$EF59", "hex_end": "$EF59", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61273         $EF59\nReceive Next RS-232 Bit (NMI)\n\nThis routine is called by the NMI interrupt handler routine to receive\nthe next bit of data from the RS-232 device."}, {"id": "map-EF7E", "address_start": 61310, "address_end": 61310, "hex_start": "$EF7E", "hex_end": "$EF7E", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61310         $EF7E\nSetup to Receive a New Byte from RS-232"}, {"id": "map-EF90", "address_start": 61328, "address_end": 61328, "hex_start": "$EF90", "hex_end": "$EF90", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61328         $EF90\nTest If Start Bit Received from RS-232"}, {"id": "map-EF97", "address_start": 61335, "address_end": 61335, "hex_start": "$EF97", "hex_end": "$EF97", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61335         $EF97\nPut a Byte of Received Data into RS-232 Receive Buffer\n\nThis routine checks for a Receive Buffer Overrun, stores the byte just\nreceived in the RS-232 receive buffer, and checks for Parity Error,\nFraming Error, or Break Detected Error.  It then sets up to receive\nthe next byte."}, {"id": "map-EFE1", "address_start": 61409, "address_end": 61409, "hex_start": "$EFE1", "hex_end": "$EFE1", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61409         $EFE1\nCHKOUT for the RS-232 device\n\nThe Kernal CHKOUT routine calls this subroutine to define the RS-232\ndevice's logical file as an output channel.  Before this can be done,\nthe logical file must first be OPENed."}, {"id": "map-F014", "address_start": 61460, "address_end": 61460, "hex_start": "$F014", "hex_end": "$F014", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61460         $F014\nCHROUT for the RS-232 Device\n\nThe Kernal CHROUT routine calls this subroutine to output a character\nto the RS-232 device.  After the logical file has been OPENed and set\nfor output using CHKOUT, the CHROUT routine is used to actually send a\nbyte of data."}, {"id": "map-F04D", "address_start": 61517, "address_end": 61517, "hex_start": "$F04D", "hex_end": "$F04D", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61517         $F04D\nCHKIN for the RS-232 Device\n\nThe Kernal CHKIN routine calls this subroutine to define the RS-232\ndevice's logical file as an input channel.  A prerequisite for this is\nthat the logical file first be OPENed."}, {"id": "map-F086", "address_start": 61574, "address_end": 61574, "hex_start": "$F086", "hex_end": "$F086", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61574         $F086\nGETIN for the RS-232 Device\n\nThe Kernal GETIN routine calls this subroutine to remove the next byte\nof data from the RS-232 receive buffer and return it in the\nAccumulator.  The routine checks for the Receive Buffer Empty Error.\nIt is also called by the Kernal CHRIN routine, which essentially does\nthe same thing as GETIN for the RS-232 device."}, {"id": "map-F0A4", "address_start": 61604, "address_end": 61604, "hex_start": "$F0A4", "hex_end": "$F0A4", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61604         $F0A4\nStop CIA #2 RS-232 NMIs for Serial/Cassette Routines\n\nThis subroutine turns off the NMIs that drive the RS-232 routines\nbefore any I/O is done using the serial bus or cassette device.  Such\ninterrupts could throw off the timing of those I/O routines, and\ninterfere with the transmission of data."}, {"id": "map-F0BD", "address_start": 61629, "address_end": 61629, "hex_start": "$F0BD", "hex_end": "$F0BD", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61629         $F0BD\nKernal Control Messages\n\nThe ASCII text of the Kernal I/O control messages is stored here.  The\nlast byte of every message has Bit 7 set to 1 (ASCII value + 128).\nThe messages are:\n\nI/O ERROR\nSEARCHING\nFOR\nPRESS PLAY ON TAPE\nPRESS RECORD & PLAY ON TAPE\nLOADING\nSAVING\nVERIFYING\nFOUND\nOK"}, {"id": "map-F12B", "address_start": 61739, "address_end": 61739, "hex_start": "$F12B", "hex_end": "$F12B", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61739         $F12B\nPrint Kernal Error Message if in Direct Mode\n\nThis routine first checks location 157 ($9D) to see if the messages\nare enabled.  If they are, it prints the message indexed by the .Y\nregister."}, {"id": "map-F13E", "address_start": 61758, "address_end": 61758, "hex_start": "$F13E", "hex_end": "$F13E", "label": "GETIN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61758         $F13E          GETIN\nGet One Byte from the Input Device\n\nThis is a documented Kernal routine whose jump table entry point is at\n65508 ($FFE4).  The routine jumps through a RAM vector at 810 ($32A).\nIts function is to get a character from the current input device\n(whose device number is stored at 153 ($99)).  In practive, it\noperates identically to the CHRIN routine below for all devices except\nfor the keyboard.  If the keyboard is the current input device, this\nroutine gets one character from the keyboard buffer at 631 ($277).  It\ndepends on the IRQ interrupt routine to rad the keyboard and put\ncharacters into the buffer."}, {"id": "map-F157", "address_start": 61783, "address_end": 61783, "hex_start": "$F157", "hex_end": "$F157", "label": "CHRIN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61783         $F157          CHRIN\nInput a Character from the Current Device\n\nThis is a documented Kernal routine whose jump table entry point is at\n65487 ($FFCF).\n\nThe routine jumps through a RAM vector at 804 ($324).  Its function is\nto get a character from the current input device (whose device number\nis stored at 153 ($99)).  This device must first have been OPENed and\nthen designated as the input channel by the CHKIN routine.\n\nWhen this routine is called, the next byte of data available from this\ndevice is returned in the Accumulator.  The only exception is the\nroutine for the keyboard device (which is the default input device).\nIt the keyboard is the current input device, this routine blinks the\ncursor, fetches characters from the keyboard buffer, and echoes them\nto the screen until a carriage return is encountered.  When a carriage\nreturn is round, the routine sets a flag to indicate the length of the\nlast logical line before the return character, and reads the first\ncharacter of this logical line from the screen.\n\nSubsequent calls to this routine will cause the next character in the\nline to be read from the screen and returned in the Accumulator, until\nthe carriage return character is returned to indicate the end of the\nline.  Any call after this character is received will start the whole\nprocess over again.\n\nNote that only the last logical line before the carriage return is\nused.  Any time you type in more than 80 characters, a new logical\nline is started.  This routine will ignore any characters on the old\nlogical line, and process only the most recent 80-character group."}, {"id": "map-F1CA", "address_start": 61898, "address_end": 61898, "hex_start": "$F1CA", "hex_end": "$F1CA", "label": "CHROUT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61898         $F1CA          CHROUT\nOutput a Byte\n\nThis is a documented Kernal routine whose jump table entry point is at\n65490 ($FFD2).  The routine jumps through a RAM vector at 806 ($326).\nIt is probably one of the best known and most used Kernal routines,\nbecause it sends the character in the Accumulator to the current\noutput device.  Unless a device has been OPENed and designated as the\ncurrent output channel using the CHKOUT routine, the character is\nprinted to the screen, which is the default output device.  If the\ncassette is the current device, outputting a byte will only add it to\nthe buffer.  No actual transmission of data will occur until the\n192-byte buffer is full."}, {"id": "map-F20E", "address_start": 61966, "address_end": 61966, "hex_start": "$F20E", "hex_end": "$F20E", "label": "CHKIN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "61966         $F20E          CHKIN\nDesignate a Logical File As the Current Input Channel\n\nThis is a documented Kernal routine which can be entered from the jump\ntable at 65478 ($FFC6).\n\nThe routine jumps through a RAM vector at 798 ($31E).  If you wish to\nget data from any device other than the keyboard, this routine must be\ncalled after OPENing the device, before you can get a data byte with\nthe CHRIN or GETIN routine.  When called, the routine will designate\nthe logical file whose file number is in the .X register as the\ncurrent file, its device as the current device, and its secondary\naddress as the current secondary address.  If the device on the\nchannel is a serial device, which requires a TALK command and\nsometimes a secondary address, this routine will send them over the\nserial bus."}]