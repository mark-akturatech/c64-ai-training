[{"id": "map-30E", "address_start": 782, "address_end": 782, "hex_start": "$30E", "hex_end": "$30E", "label": "SYREG", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "782           $30E           SYREG\nStorage Area for .Y Index Register"}, {"id": "map-30F", "address_start": 783, "address_end": 783, "hex_start": "$30F", "hex_end": "$30F", "label": "SPREG", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "783           $30F           SPREG\nStorage Area for .P (Status) Register\n\nThe Status (.P) register has seven different flags.  Their bit\nassignments are as follows:\n\nBit 7 (bit value of 128) = Negative\nBit 6 (bit value of 64)  = Overflow\nBit 5 (bit value of 32)  = Not Used\nBit 4 (bit value of 16)  = BREAK\nBit 3 (bit value of 8)   = Decimal\nBit 2 (bit value of 4)   = Interrupt Disable\nBit 1 (bit value of 2)   = Zero\nBit 0 (bit value of 1)   = Carry\n\nIf you wish to clear any flag before a SYS, it is safe to clear them\nall with a POKE 783,0.  The reverse is not true, however, as you must\nwatch out for the Interrupt disable flag.\n\nA 1 in this flag bit is equal to an SEI instruction, which turns off\nall IRQ interrupts (like the one that reads the keyboard, for\nexample).  Turning off the keyboard could make the computer very\ndifficult to operate!  To set all flags except for Interrupt disable\nto 1, POKE 783,247."}, {"id": "map-310", "address_start": 784, "address_end": 784, "hex_start": "$310", "hex_end": "$310", "label": "USRPOK", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "784           $310           USRPOK\nJump Instruction for User Function ($4C)\n\nThe value here (67, $4C) is first part of the 6510 machine language\nJuMP instruction for the USR command."}, {"id": "map-311-312", "address_start": 785, "address_end": 786, "hex_start": "$311", "hex_end": "$312", "label": "USRADD", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "785-786       $311-$312      USRADD\nAddress of USR Routine (Low Byte First)\n\nThese locations contain the target address of the USR command.  They\nare initialized by the Operating System to point to the BASIC error\nmessage handler routine, so that if you try to execute a USR call\nwithout changing these values, you wil receive an ILLEGAL QUANTITY\nerror message.\n\nIn order to successfully execute a USR call, you must first POKE in\nthe target address in low-byte, high-byte order.  You can calculate\nthese two values for any address with the formula:\n\nHI=INT(AD/256):LO=AD-(HI*256)\n\nFor example, if the USR routine started at 49152 ($C000), you would\nPOKE 786, INT(49152/256):POKE 785,49152-(PEEK(786)*256 before\nexecuting the USR command.\n\nWhat makes the USR command different from SYS is that you can pass a\nparameter into the machine language routine by placing it in\nparenthesis after the USR keyword, and you can pass a parameter back\nto a variable by assigning its value to the USR function.\n\nIn other words, the statement X=USR(50) will first put the number 50\nin floating point format into the Floating Point Accumulator (FAC1) at\n97-102 ($61-$66).  Then, the machine language program designated by\nthe address at this vector will be executed.  Finally, the variable X\nwill be assigned the floating point value which ends up in FAC1 after\nthe user-written routine is finished.\n\nSince floating point representation is difficult to work with, it is\nhandy to change these floating point parameters into integers before\nworking with them.  Fortunately, there are vectored routines which\nwill do the conversions for you.  The routine vectored at locations\n3-4 converts the number in FAC1 to a two-byte signed integer, with the\nlow byte in the .Y register (and location 101 ($65)) and the high byte\nin the Accumulator (.A).  Remember, that number is converted to a\nsigned integer in the range between 32767 and -32768, with Bit 7 of\nthe high byte used to indicate the sign.\n\nTo pass a value back through the USR function, you need to place the\nnumber into FAC1.  To conert a signed integer to floating point\nformat, place the high byte into the Accumulator (.A), the low byte\ninto the .Y register, and jump through the vector at locations 5-6\nwith a JMP ($0005) instruction.  The floating point result will be\nleft in FAC1."}, {"id": "map-314-315", "address_start": 788, "address_end": 789, "hex_start": "$314", "hex_end": "$315", "label": "CINV", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "788-789       $314-$315      CINV\nVector to IRQ Interrupt Routine\n\nThis vector points to the address of the routine that is executed when\nan IRQ interrupt occurs (normally 59953 ($FA31)).\n\nAt power on, the CIA #1 Timer B is set to cause an IRQ interrupt to\noccur every 1/60 second.  This vector is set to point to the routine\nwhich updates the software clock and STOP key check, blinks the\ncursor, maintains the tape interlock, and reads the keyboard.  By\nchanging this vector, the user can add or substitute a machine\nlanguage routine that will likewise execute every 1/60 second.  The\nuser who is writing IRQ interrupt routines should consider the\nfollowing:\n\n1.  It is possible for an IRQ interrupt to occur while you are\nchanging this vector, which would cause an error from which no\nrecovery could be made.  Therefore, you must disable all IRQ\ninterrupts before changing the contents of this location, and reenable\nthem afterwards, by using the 6510 SEI and CLI instructions, or by\nusing the Kernal VECTOR routine (64794, $FD1A) to set this vector.\n\n2.  There is some code in ROM that is executed before the interrupt\nroutine is directed through this vector.  This code checks whether the\nsource of the interrupt was an IRQ or BRK instruction.  If first\npreserves the contents of all the registers by pushing them onto the\nstack in the following sequence:  PHA, TXA, PHA, TYA, PHA.  It is up\nto the user to restore the stack at the end of his routine, either by\nexiting through the normal IRQ, or with the sequence:  PLA, TAY, PLA,\nTAX, PLA, RTI.\n\n3.  There is only one IRQ vector, but there are many sources for IRQ\ninterrupts (two CIA chips, and several VIC chip IRQs).  If you plan to\nenable IRQs from more than one source, the IRQ routine here must\ndetermine the source, and continue the routine in the appropriate\nplace for an IRQ from that source.\n\nIn the same vein, if you replace the normal IRQ routine with your own,\nyou should be aware that the keyboard's scanning and clock update will\nnot occur unless you call the old interrupt routine once every 1/60\nsecond.  It is suggested that if you plan to use that routine, you\nsave the old vector address in some other location.  In that way, you\ncan JuMP to the keyboard interrupt routine through this alternate\nvector, rather than assuming that the ROM address will never change\nand that it is safe to jump into the ROM directly."}, {"id": "map-316-317", "address_start": 790, "address_end": 791, "hex_start": "$316", "hex_end": "$317", "label": "CBINV", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "790-791       $316-$317      CBINV\nVector: BRK Instruction Interrupt\n\nThis vector points to the address of the routine which will be\nexecuted anytime that a 6510 BRK instruction (00) is encountered.\n\nThe default value points to a routine that calls several of the Kernal\ninitialization routines such as RESTOR, IOINIT and part of CINT, and\nthen jumps through the BASIC warm start vector at 40962.  This is the\nsame routine that is used when the STOP and RESTORE keys are pressed\nsimultaneously, and is currently located at 65126 ($Fe66).\n\nA machine language monitor program will usually change this vector to\npoint to the monitor warm start address, so that break points may be\nset that will return control to the monitor for debugging purposes."}, {"id": "map-318-319", "address_start": 792, "address_end": 793, "hex_start": "$318", "hex_end": "$319", "label": "NMINV", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "792-793       $318-$319      NMINV\nVector: Non-Maskable Interrupt\n\nThis vector points to the address of the routine that will be executed\nwhen a Non-Maskable Interrupt (NMI) occurs (currently at 65095\n($FE47)).\n\nThere are two possible sources for an NMI interrupt.  The first is the\nRESTORE key, which is connected directly to the 6510 NMI line.  The\nsecond is CIA #2, the interrupt line of which is connected to the 6510\nNMI line.\n\nWhen an NMI interrupt occurs, a ROM routine sets the Interrupt disable\nflag, and then jumps through this RAM vector.  The default vector\npoints to an interrupt routine which checks to see what the cause of\nthe NMI was.\n\nIf the cause was CIA #2, the routine checks to see if one of the\nRS-232 routines should be called.  If the source was the RESTORE key,\nit checks for a cartridge, and if present, the cartridge is entered at\nthe warm start entry point.  If there is no cartridge, the STOP key is\ntested.  If the STOP key was pressed at the same time as the RESTORE\nkey, several of the Kernal initialization routines such as RESTOR,\nIOINIT and part of CINT are executed, and BASIC is entered through its\nwarm start vector at 40962.  If the STOP key was not pressed\nsimultaneously with the RESTORE, the interrupt will end without\nletting the user know that anything happened at all when the RESTORE\nkey was pressed.\n\nSince this vector controls the outcome of pressing the RESTORE key, it\ncan be used to disable the STOP/RESTORE sequence.  A simple way to do\nthis is to change this vector to point to the RTI instruction.  A\nsimple POKE 792,193 will accomplish this.  To set the vector back,\nPOKE 792,71.  Note that this will cut out all NMIs, including those\nrequired for RS-232 I/O."}, {"id": "map-31A-32D", "address_start": 794, "address_end": 813, "hex_start": "$31A", "hex_end": "$32D", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location_range", "text": "Location Range: 794-813 ($31A-$32D)\nKernal Indirect Vectors\n\nThere are 39 Kernal routines for which there are vectors in the jump\ntable located at the top of the ROM (65409, $FF81).  For ten of these\nroutines, the jump table entry contains a machine language instruction\nto jump to the address pointed to by the RAM vector in this table.\nThe addresses in this table are initialized to point to the\ncorresponding routines in the Kernal ROM.  Since these addresses are\nin RAM, however, any entry in this table may be changed.  This enables\nthe user to add to these routines, or to replace them completely.\n\nYou will notice, for example, that many of these routines involve\nInput/ Output functions.  By changing the vectors  to these routines,\nit is possible to support new I/O devices, such as an IEEE disk drive\nused through an adapter.\n\nThe user should be cautioned that since some of these routines are\ninterrupt-driven, it is dangerous to change these vectors without\nfirst turning off all interrupts.  For a safe method of changing all\nof these vectors at one time, along with the interrupt vectors above,\nsee the entry for the Kernal VECTOR routine at 64794 ($FD1A).\n\nMore specific information about the individual routines can be found\nin the descriptions given for their ROM locations."}, {"id": "map-31A-31B", "address_start": 794, "address_end": 795, "hex_start": "$31A", "hex_end": "$31B", "label": "IOPEN", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "794-795       $31A-$31B      IOPEN\nVector to Kernal OPEN Routine (Currently at 62282 ($F34A))"}, {"id": "map-31C-31D", "address_start": 796, "address_end": 797, "hex_start": "$31C", "hex_end": "$31D", "label": "ICLOSE", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "796-797       $31C-$31D      ICLOSE\nVector to Kernal CLOSE Routine (Currently at 62097 ($F291))"}, {"id": "map-31E-31F", "address_start": 798, "address_end": 799, "hex_start": "$31E", "hex_end": "$31F", "label": "ICHKIN", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "798-799       $31E-$31F      ICHKIN\nVector to Kernal CHKIN Routine (Currently at 61966 ($F20E))"}, {"id": "map-320-321", "address_start": 800, "address_end": 801, "hex_start": "$320", "hex_end": "$321", "label": "ICKOUT", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "800-801       $320-$321      ICKOUT\nVector to Kernal CKOUT Routine (Currently at 62032 ($F250))"}, {"id": "map-322-323", "address_start": 802, "address_end": 803, "hex_start": "$322", "hex_end": "$323", "label": "ICLRCH", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "802-803       $322-$323      ICLRCH\nVector to Kernal CLRCHN Routine (Currently at 62259 ($F333))"}, {"id": "map-324-325", "address_start": 804, "address_end": 805, "hex_start": "$324", "hex_end": "$325", "label": "IBASIN", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "804-805       $324-$325      IBASIN\nVector to Kernal CHRIN Routine (Currently at 61783 ($F157))"}, {"id": "map-326-327", "address_start": 806, "address_end": 807, "hex_start": "$326", "hex_end": "$327", "label": "IBSOUT", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "806-807       $326-$327      IBSOUT\nVector to Kernal CHROUT Routine (Currently at 61898 ($F1CA))"}, {"id": "map-328-329", "address_start": 808, "address_end": 809, "hex_start": "$328", "hex_end": "$329", "label": "ISTOP", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "808-809       $328-$329      ISTOP\nVector to Kernal STOP Routine (Currently at 63213 ($F6ED))\n\nThis vector points to the address of the routine that tests the STOP\nkey.  The STOP key can be disabled by changing this with a POKE\n808,239.  This will not disable the STOP/RESTORE combination, however.\nTo disable both STOP and STOP/ RESTORE, POKE 808,234 (POKEing 234 here\nwill cause the LIST command not to function properly).  To bring\nthings back to normal in either case, POKE 808, 237."}, {"id": "map-32A-32B", "address_start": 810, "address_end": 811, "hex_start": "$32A", "hex_end": "$32B", "label": "IGETIN", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "810-811       $32A-$32B      IGETIN\nVector to Kernal GETIN Routine (Currently at 61758 ($F13E))"}, {"id": "map-32C-32D", "address_start": 812, "address_end": 813, "hex_start": "$32C", "hex_end": "$32D", "label": "ICLALL", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "812-813       $32C-$32D      ICLALL\nVector to Kernal CLALL Routine (Currently at 62255 ($F32F))"}, {"id": "map-32E-32F", "address_start": 814, "address_end": 815, "hex_start": "$32E", "hex_end": "$32F", "label": "USRCMD", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "814-815       $32E-$32F      USRCMD\nVector to User-Defined Command (Currently Points to BRK at 65126\n($FE66))\n\nThis appears to be a holdover from PET days, when the built-in machine\nlanguage monitor would JuMP through the USRCMD vector when it\nencountered a command that it did not understand, allowing the user to\nadd new commands to the monitor.\n\nAlthough this vector is initialized to point to the routine called by\nSTOP/ RESTORE and the BRK interrupt, and is updated by the Kernal\nVECTOR routine (64794, $FD1A), it does not seem to have the function\nof aiding in the addition of new commands."}, {"id": "map-330-331", "address_start": 816, "address_end": 817, "hex_start": "$330", "hex_end": "$331", "label": "ILOAD", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "816-817       $330-$331      ILOAD\nVector to Kernal LOAD Routine (Currently at 62622 ($F49E))"}, {"id": "map-332-333", "address_start": 818, "address_end": 819, "hex_start": "$332", "hex_end": "$333", "label": "ISAVE", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "818-819       $332-$333      ISAVE\nVector: Kernal SAVE Routine (Currently at 62941 ($F5DD))"}, {"id": "map-334-33B", "address_start": 820, "address_end": 827, "hex_start": "$334", "hex_end": "$33B", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "820-827       $334-$33B\nUnused\n\nEight free bytes for user vectors or other data."}, {"id": "map-33C-3FB", "address_start": 828, "address_end": 1019, "hex_start": "$33C", "hex_end": "$3FB", "label": "TBUFFER", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "828-1019      $33C-$3FB      TBUFFER\nCassette I/O Buffer\n\nThis 192-byte buffer area is used to temporarily hold data that is\nread from or written to the tape device (device number 1).\n\nWhen not being used for tape I/O, the cassette buffer has long been a\nfavorite place for Commodore programmers to place short machine\nlanguage routines (although the 64 has 4K of unused RAM above the\nBASIC ROM at 49152 ($C000) that would probably better serve the\npurpose).\n\nOf more practical interest to the 64 programmer is the possible use of\nthis area for VIC-II chip graphics memory (for example, sprite shape\ndata or text character dot data).  If the VIC-II chip is banked to the\nlowest 16K of memory (as is the default selection), there is very\nlittle memory space which can be used for such things as sprite shape\ndata without conflict.  If the tape is not in use, locations 832-895\n($340-$37F) can be used as sprite data block number 13, and locations\n896-959 ($380-$3BF) can be used as sprite data block number 14.\n\nThe types of tape blocks that can be stored here are program header\nblocks, data header blocks, and data storage blocks.\n\nThe first byte of any kind of block (which is stored at location 828\n($33C)) identifies the block type.  Header blocks follow this\nidentifier byte with the two-byte starting RAM address of the tape\ndata, the two-byte ending RAM address, and the filename, padded with\nblanks so that the total length of the name portion equals 187 bytes.\nData storage blocks have 191 bytes of data following the identifier\nbyte.  The meanings of the various identifier blocks are as follows:\n\nA value of 1 signifies that the block is the header for a relocatable\nprogram file, while a value of 3 indicates that the block is the\nheader for a nonrelocatable program file.\n\nA relocatable file is created when a program is SAVEd with a secondary\naddress of 0 (or any even number), while a nonrelocatable program file\nis created if the secondary SAVE address is 1 (or any odd number).\nThe difference between the two types of files is that a nonrelocatable\nprogram will always load at the address specified in the header.  A\nrelocatable program will load at the current start of BASIC address\nunless the LOAD statement uses a secondary address of 1, in which case\nit will also be loaded at the addrss specified in the header.\n\nYou should note that a program file uses the cassette buffer only to\nstore the header block.  Actual program data is transferred directly\nto or from RAM, without first being buffered.\n\nAn identifier value of 4 means that the block is a data file header.\nSuch a header block is stored in the cassette buffer whenever a BASIC\nprogram OPENs a tape data file for reading or writing.  Subsequent\ndata blocks start with an identifier byte of 2.  These blocks contain\nthe actual data byte written by the PRINT #1 command, and read by the\nGET #1 and INPUT #1 commands.  Unlike the body of a program file,\nthese blocks are temporarily stored in the cassette byffer when being\nwritten or read.\n\nAn identifier byte of 5 indicates that this block is the logical end\nof the tape.  This signals the Kernal not to search past this point,\neven if there are additional tape blocks physically present on the\ntape."}, {"id": "map-3FC-3FF", "address_start": 1020, "address_end": 1023, "hex_start": "$3FC", "hex_end": "$3FF", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "1020-1023     $3FC-$3FF\nUnused\n\nFour more free bytes.\n\n\n::::::::::::::::::::::::\n::                    ::\n::     1K to 40K      ::\n::                    ::\n::   Screen Memory,   ::\n::Sprite Pointers, and::\n:: BASIC Program Text ::\n::::::::::::::::::::::::"}, {"id": "map-400-7FF", "address_start": 1024, "address_end": 2047, "hex_start": "$400", "hex_end": "$7FF", "label": "VICSCN", "source": "mapping-c64.txt", "chapter": "::     Chapter 4      ::", "type": "location", "text": "1024-2047     $400-$7FF      VICSCN\nVideo Screen Memory Area\n\nThis is the default location of the video screen memory area, which\ncontains the video matrix and the sprite data pointers.  Keep in mind,\nhowever, that the video screen memory area can be relocated to start\non any even 1K boundary.  Its location at any given moment is\ngetermined by the VIC-II chip memory control register at 53272\n($D018), and the VIC-II memory bank select bits on CIA #2 Data Port A\n(56576, $DD00)."}, {"id": "map-400-7E7", "address_start": 1024, "address_end": 2023, "hex_start": "$400", "hex_end": "$7E7", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 4      ::", "type": "location", "text": "1024-2023     $400-$7E7\nVideo Matrix: 25 Lines by 40 Columns\n\nThe video matrix is where thext screen characters are stored in RAM.\nNormally, the VIC-II chip will treat each byte of memory here as a\nscreen display code and will display the text character that\ncorresponds to that byte of code.  The first byte of memory here will\nbe displayed in the top-left corner of the screen, and subsequent\nbytes will be displayed in the columns to the right and the rows below\nthat character.\n\nIt is possible to make text or graphics characters appear on the\nscreen by POKEing their screen codes directly into this area of RAM.\nFor example, the letter A has a screen code value of 1.  Therefore,\nPOKE 1024,1 should make the letter A appear in the top-left corner of\nthe screen.\n\nHowever, you should be aware that the most current version of the\nOperating System initializes the color RAM which is used for the\nforeground color of text characters to the same value as the\nbackground color every time that the screen is cleared.  The result is\nthat although the POKE will put a blue A on the screen, you won't be\nable to see it because it is the same color blue as the background.\nThis can be remedied by POKEing a different value into color RAM\n(which starts at 55296 ($D800)).\n\nA POKE 1024,1:POKE 1024+54272,1 will put a white A in the upper-left\ncorner of the screen.  The loop\n\nFOR I=0 TO 255:POKE 1024+I,I:POKE 1024+54272+I,1:NEXT\n\nwill display all of the characters in white at the top of the screen.\nAnother solution to the color RAM problem is to fool the Operating\nSystem into initializing the color RAM for you.  If you change the\nbackground color to the desired foreground color before you clear the\nscreen, color RAM will be set to that color.  Then, all you have to do\nis change the background color back to what it was.  This example will\nshow how it's done:\n\n10 POKE 53281,2:REM BACKGROUND IS RED\n20 PRINT CHR$(147):REM CLEAR SCREEN\n30 POKE 53281,1:REM BACKGROUND IS WHITE\n40 POKE 1024,1:REM RED \"A\" APPEARS IN TOP LEFT CORNER"}, {"id": "map-7F8-7FF", "address_start": 2040, "address_end": 2047, "hex_start": "$7F8", "hex_end": "$7FF", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 4      ::", "type": "location", "text": "2040-2047     $7F8-$7FF\nSprite Shape Data Pointers\n\nThe last eight bytes of the video matrix (whether it is here at the\ndefault location, or has been relocated elsewhere) are used as\npointers to the data blocks used to define the sprite shapes.\n\nEach sprite is 3 bytes wide (24 bits) by 21 lines high.  It therefore\nrequires 63 bytes for its shape definition, but it actually uses 64\nbytes in order to arrive at an even 256 shape blocks in the 16K area\nof RAM which the VIC-II chip addresses.\n\nEach pointer holds the current data block being used to define the\nshape of one sprite.  The block numver used to define the shape of\nSprite 0 is held in location 2040 ($7F8), the Sprite 1 shape block is\ndesignated by location 2041 ($7F9), etc.  The value in the pointer\ntimes 64 equals the starting location of the sprite shape data table.\nFor example, a value of 11 in location 2040 indicates that the shape\ndata for Sprite 0 starts at address 704 (11*64), and continues for 63\nmore bytes to 767.\n\nFor additional information on sprite graphics, see the entries for\nindividual VIC-II chip sprite graphics locations, and the summary at\nthe beginning of the VIC-II chip section, at 53248 ($D000)."}, {"id": "map-800-9FFF", "address_start": 2048, "address_end": 40959, "hex_start": "$800", "hex_end": "$9FFF", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 4      ::", "type": "location", "text": "2048-40959    $800-$9FFF\nBASIC Program Text\n\nThis is the area where the actual BASIC program text is stored.  The\ntext of a BASIC program consists of linked lines of program tokens.\nEach line contains the following:\n\n1.  A two-byte pointer to the address of the next program line (in\nstandard low-byte, high-byte order).  After the last program line, a\nlink pointer consisting of two zeros marks the end of the program.\n\n2.  A two-byte line number (also in low-byte, high-byte order).\n\n3.  The program commands.  Each keyword is stored as a one-byte\ncharacter whose value is equal to or greater than 128.  Print, for\nexample, is stored as the number 151.  Other elements of the BASIC\ncommand, such as the variable names, string literals (\"HELLO\"), and\nnumbers, are stored using their ASCII equivalents.\n\n4.  A 0 character, which acts as a line terminator.  In order for\nBASIC to work correctly, the first character of the BASIC text area\nmust be 0.\n\nA quick review of the BASIC pointers starting at 43 ($2B) reveals that\nthe layout of the BASIC program area (going from lower memory\naddresses to higher) is as follows:\n\nBASIC Program Text\nNon-Array Variables and String Descriptors\nArray Variables\nFree Area (Reported by FRE(0))\nString Text Area (Strings build from top of memory down into free area)\nBASIC ROM\n\nIt is interesting to note that the NEW command does not zero out the\ntext area but rather replaces the first link address in the BASIC\nprogram with two zeros, indicating the end of the program.  Therefore,\nyou can recover a program from a NEW by replacing the first link\nadress, finding the address of the two zeros that actually mark the\nend of the program, and setting the pointers at 45, 47, and 49 (which\nall point to the end of a BASIC program before the program is RUN) to\nthe byte following these zeros."}, {"id": "map-1000-1FFF", "address_start": 4096, "address_end": 8191, "hex_start": "$1000", "hex_end": "$1FFF", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 4      ::", "type": "location", "text": "4096-8191     $1000-$1FFF\nCharacter ROM Image for VIC-II Chip When Using Memory Bank 0 (Default)\n\nThough the VIC-II chip shares memory with the 6510 processor chip, it\ndoes not always see that memory in exactly the same way as the main\nmicroprocessor.\n\nAlthough the 6510 accesses RAM at these locations, when the VIC-II is\nbanked to use the first 16K of RAM (which is the default condition),\nit sees the character ROM here (the 6510 cannot access this ROM unless\nit is switched into its memory at 49152 ($C000)).  This solves the\nriddle of how the VIC-II chip can use the character ROM at 49152\n($C000) for character shape data and RAM at 1024 ($400), when it can\nonly address memory within a 16K range.  It also means that the RAM at\n4096-8191 cannot be used for screen display memory or user-defined\ncharacter dot data, and sprite data blocks 64-127 are not accessible.\n\nYou can verify this by turning on bitmap graphics with the screen\nmemory set to display addresses from 0 to 8192.  You will see that the\nbottom portion of the screen shows all of the text character shapes\nstored in the ROM.  For more information on the format of text\ncharacter data storage, see the description of the Character ROM at\n49152 ($C000)."}, {"id": "map-8000", "address_start": 32768, "address_end": 32768, "hex_start": "$8000", "hex_end": "$8000", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 4      ::", "type": "location", "text": "32768         $8000\nAutostart ROM Cartridge\n\nAn 8K or 16K autostart ROM cartridge designed to use this as a\nstarting memory address may be plugged into the Expansion Port on the\nback.  If the cartridge ROM at locations 32772-32776 ($8004-$8008)\ncontains the numbers 195, 194, 205, 56, 48 ($C3, $C2, $CD, $38, $30)\nwhen the computer powers up, it will start the program pointed to by\nthe vector at locations 32768-32769 ($8000-$8001), and will use\n32770-32771 ($8002-$8003) for a warm start vector when the RESTORE key\nis pressed.  These characters are PETASCII for the inverse letters\nCBM, followed by the digits 80.  An autostart cartridge may also be\naddressed at 40960 ($A000), where it would replace BASIC, or at 61440\n($F000), where it would replace the Kernal.\n\nIt is possible to have a 16K cartridge sitting at 32768 ($8000), such\nas Simon's BASIC, which can be turned on and off so that the BASIC ROM\nunderneath can also be used.  Finally, it is even possible to have\nbank-selected cartridges, which turn banks of memory in the cartidge\non and off alternately, so that a 32K program could fit into only 16K\nof addressing space."}, {"id": "map-9000-9FFF", "address_start": 36864, "address_end": 40959, "hex_start": "$9000", "hex_end": "$9FFF", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 4      ::", "type": "location", "text": "36864-40959   $9000-$9FFF\nCharacter ROM Image for VIC-II Chip When Using Memory Bank 2\n\nWhen the VIC-II chip is set up to use the third 16K block of memory\nfor graphics (as would be the case when the 64 is set up to emulate\nthe PET, which has its text screen memory at 32768 ($8000), it sees\nthe character generator ROM at this address (see entry at 4096 ($1000)\nabove for more details).\n\nIt should be noted that the character ROM is available only when the\nVIC-II chip is using banks 0 or 2.  When using one of the other two\nbanks, the user must supply all of the character shape data in a RAM\ntable.\n\n\n::::::::::::::\n::          ::\n:: 8K BASIC ::\n::ROM and 4K::\n:: Free RAM ::\n::::::::::::::\n\nLocations 40960 to 49152 ($A000 to $BFFF) are used by the BASIC ROM\nwhen it is selected (which is the default condition).  BASIC is the\n64's main program, which is always run if there is no autostart\ncartridge inserted at power-up time.  When the 64 tells you READY,\nthat's BASIC talking.\n\nThe BASIC interpreter that comes with the 64 is, aside from being\nlocated in a different memory space, almost identical to the Microsoft\nBASIC interpreter found on the VIC-20.  Both of these interpreters are\nslightly modified versions of PET BASIC 2.0, also known as PET BASIC\n3.0 or Upgrade BASIC, because it was an upgraded version of the BASIC\nfound on the original PET.\n\nThis is a somewhat mixed blessing, because while PET BASIC was, in its\nday, quote an advanced language for use with an eight-bit\nmicroprocessor, it lacks several of the features (such as error\ntrapping) which are now standard on most home computers.  And, of\ncourse, it makes no provision whatever for easy use of the many\ngraphics and sound capabilities made available by the new dedicated\nvideo and sound support chips.\n\nOn the other hand, its faithfulness to the original Commodore BASIC\nallows a large body of software to be translated for the 64 with\nlittle change (in most cases, the PET Emulator program from Commodore\nwill allow you to run PET programs with no changes).  Programming aids\nand tricks developed for the PET and VIC will, for the most part,\ncarry over quite nicely to the 64.  Although there is no official\nsource code listing of the ROM available from Commodore, this version\nof BASIC has been around long enough that it has been thoroughly\ndisassembled, dissected, and documented by PET users.\n\nThe labels used here correspond to those used by Jim Butterfield in\nhis PET memory maps, which are well-known among PET BASIC users.  They\nshould, therefore, provide some assistance in locating equivalent\nroutines on the two machines.  A good description of the workings of\nPET BASIC can be found in Programming the PET/CBM by Raeto West.\n\nIt is beyond the scope of this book to detail the inner workings of\neach routine in the BASIC interpreter.  However, the following summary\nof routines and their functions should aid the user who is interested\nin calling BASIC routines from his or her own program, or in modifying\nthe BASIC.\n\nPlease keep in mind that the entry and exit points listed for routines\nthat perform a particular function are to be used as guideposts, and\nnot absolutes.  In fact, BASIC enters many of these routines from\nslightly different places to accomplish different tasks.  Some\nsubroutines are called by so many commands that it is hard to say\nwhich they belong to.  You will even find that some whole commands are\npart of other commands.  Where it is important for you to know the\ndetails of a particular routine, you will need to obtain a disassembly\nof that section and look at the machine language program itself.\n\nIt should be noted that when BASIC is not neede,d it can be switched\nout and the RAM underneath can be accessed by the VIC-II chip and used\nfor screen graphics.  See location 56576 ($DD00) for more information."}, {"id": "map-A000-A001", "address_start": 40960, "address_end": 40961, "hex_start": "$A000", "hex_end": "$A001", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "40960-40961   $A000-$A001\nCold Start Vector\n\nThis vector points to the address of the routine used to initialize\nBASIC.  After the Operating System finishes its power-on activities,\nit enters the BASIC program through this vector.  The most visible\neffect of the BASIC initialization routine is that the screen is\ncleared, and the words:\n\n     **** COMMODORE 64 BASIC V2 ****\n\nare printed along with the BYTES FREE message.  For details of the\nsteps taken during the initialization of BASIC, see the entry for\n58260 ($E394), the current cold start entry point."}, {"id": "map-A002-A003", "address_start": 40962, "address_end": 40963, "hex_start": "$A002", "hex_end": "$A003", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "40962-40963   $A002-$A003\nWarm Start Vector\n\nThe warm start vector points to the address of the routines used to\nreset BASIC after the STOP/RESTORE key combination is pressed.  This\nis the same address to which the BRK instruction is vectored.  When\nBASIC is entered through this vector, the program in memory is not\ndisturbed.  For more information, see the entry for 58235 ($E37B), the\ncurrent warm start entry point."}, {"id": "map-A004-A00B", "address_start": 40964, "address_end": 40971, "hex_start": "$A004", "hex_end": "$A00B", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "40964-40971   $A004-$A00B\nASCII Text characters CBMBASIC\n\nThe ASCII characters for the letters CBMBASIC are located here.\nPossibly an identifier, this text is not referenced elsewhere in the\nprogram.\n\n40972041941   $A00C-$A051    STMDSP\nStatement Dispatch Vector Table\n\nThis table contains two-byte vectors, each of which points to an\naddress which is one byte before the address of one of the routines\nthat perform a BASIC statement.\n\nThe statements are in token number order.  When it comes time to\nexecute a statement, the NEWSTT routine at 42926 ($A7AE) places this\naddress-1 on the stack and jumps to the CHRGET routine.  The RTS\ninstruction at the end of that routine causes the statement address to\nbe pulled off the stack, incremented, and placed in the Program\nCounter, just as if it were the actual return address.\n\nThis table is handy for locating the address of the routine that\nperforms a BASIC statement, so that the routine can be disassembled\nand examined.  To aid in this purpose, the table is reproduced below\nwith the actual target address, and not in the address-1 format used\nby BASIC.\n\nToken #   Statement   Routine Address"}, {"id": "map-A052-A07F", "address_start": 41042, "address_end": 41087, "hex_start": "$A052", "hex_end": "$A07F", "label": "FUNDSP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41042-41087   $A052-$A07F    FUNDSP\n                             TABLE\nFunction Dispatch Vector Table\n\nThis table contains two-byte vectors, each of which points to the\naddress of one of the routines that performs a BASIC function.\n\nA function is distinguished by a following argument, in parentheses.\nThe expression in the parentheses is first evaluated by the routines\nwhich begin at 44446 ($AD9E).  Then this table is used to find the\naddress of the function that corresponds to the token number of the\nfunction to be executed.\n\nThe substance of this table, which can be used for locating the\naddresses of these routines, is reproduced below.  Note that the\naddress for the USR function is 784 ($310), which is the address of\nthe JMP instruction which precedes the user-supplied vector.\n\nToken #   Function     Routine Address"}, {"id": "map-BD", "address_start": 189, "address_end": 189, "hex_start": "$BD", "hex_end": "$BD", "label": "EXP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "189 $BD   EXP          49133 $BFED\n180 $BE   COS          57956 $E264"}, {"id": "map-A080-A09D", "address_start": 41088, "address_end": 41117, "hex_start": "$A080", "hex_end": "$A09D", "label": "OPTAB", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41088-41117   $A080-$A09D    OPTAB\nOperator Dispatch Vector Table\n\nThis table contains two-byte vectors, each of which points to an\naddress which is one byte before the address of one of the routines\nthat perform a BASIC math operation.\n\nFor the reasoning behind the one-byte offset to the true address, see\nthe entry for location 40972 ($A00C).  In addition, each entry has a\none-byte number which indicates the degree of precedence that\noperation takes.  Operations with a higher degree of precedence are\nperformed before operations of a lower degree (for example, in the\nexpression A=3+4*6, the 4*6 operation is performed first, and 3 is\nadded to the total).  The order in which they are performed is:\n\n1.  Expressions in parentheses\n2.  Exponentation (raising to a power, using the up-arrow symbol)\n3.  Negation of an expression (-5, -A)\n4.  Multiplication and division\n5.  Addition and subtraction\n6.  Relation tests (=, <>, <, >, <=, >= all have the same precedence)\n7.  NOT (logical operation)\n8.  AND (logical operation)\n9.  OR (logical operation)\n\nThe substance of this table, which can be used to locate the addresses\nof the math routines, is given below.  Note that less that, equal, and\ngreater than operators all use the same routines, though they have\ndifferent token numbers.\n\nToken #   Operator           Routine Address"}, {"id": "map-A09E-A19D", "address_start": 41118, "address_end": 41373, "hex_start": "$A09E", "hex_end": "$A19D", "label": "RESLST", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41118-41373   $A09E-$A19D    RESLST\nList of Keywords\n\nThis table contains a complete list of the reserved BASIC keywords\n(those combinations of ASCII text characters that cause BASIC to do\nsomething).  The ASCII text characters of these words are stored in\ntoken number order.  Bit #7 of the last letter of each word is set to\nindicate the end of the word (the last letter has 128 added to its\ntrue ASCII value).\n\nWhen the BASIC program text is stored, this list of words is used to\nreduce any keywords to a single-byte value called a token.  The\ncommand PRINT, for example, is not stored in a program as five ASCII\nbytes, but rather as the single token 153 ($99).\n\nWhen the BASIC program is listed, this table is used to convert these\ntokens back to ASCII text.  The entries in this table consist of the\nfollowing:\n\n1.  The statements found in STMDSP at 40972 ($A00C), in the token\nnumber order indicated (token numbers 128-162).\n\n2.  Some miscellaneous keywords which never begin a BASIC statement:\n\nToken #    Keyword\n162 $A3    TAB("}, {"id": "map-A9", "address_start": 169, "address_end": 169, "hex_start": "$A9", "hex_end": "$A9", "label": "STEP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "169 $A9    STEP\n\n3.  The math operators found in OPTAB at 41088 ($A080), in the token\nnumber order indicated (token numbers 170-179).\n\n4.  The functions found in FUNDSP at 41042 ($A052), in the token\nnumber order indicated (token numbers 182-202).\n\n5.  The word GO (token number 203 ($CB)).  This word was added to the\ntable to make the statement GO TO legal, to afford some compatibility\nwith the very first PET BASIC, which allowed spaces within keywords."}, {"id": "map-A19E-A327", "address_start": 41374, "address_end": 41767, "hex_start": "$A19E", "hex_end": "$A327", "label": "ERRTAB", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41374-41767   $A19E-$A327    ERRTAB\nASCII Text of BASIC Error Messages\n\nThis table contains the ASCII text of all of the BASIC error messages.\nAs in the keyword table, Bit 7 of the last letter of each message is\nset to indicate the end of the message.  Although we've all seen some\nof them at one time or another, it's somewhat daunting to see the\nwhole list at once.  The possible errors you can make include:\n\n 1.  TOO MANY FILES\n 2.  FILE OPEN\n 3.  FILE NOT OPEN\n 4.  FILE NOT FOUND\n 5.  DEVICE NOT PRESENT\n 6.  NOT INPUT FILE\n 7.  NOT OUTPUT FILE\n 8.  MISSING FILENAME\n 9.  ILLEGAL DEVICE NUMBER\n10.  NEXT WITHOUT FOR\n11.  SYNTAX\n12.  RETURN WITHOUT GOSUB\n13.  OUT OF DATA\n14.  ILLEGAL QUANTITY\n15.  OVERFLOW\n16.  OUT OF MEMORY\n17.  UNDEF'D STATEMENT\n18.  BAD SUBSCRIPT\n19.  REDIM'D ARRAY\n20.  DIVISION BY ZERO\n21.  ILLEGAL DIRECT\n22.  TYPE MISMATCH\n23.  STRING TOO LONG\n24.  FILE DATA\n25.  FORMULA TOO COMPLEX\n26.  CAN'T CONTINUE\n27.  UNDEF'D FUNCTION\n28.  VERIFY\n29.  LOAD\n\nMessage number 30, BREAK, is located in the Miscellaneous Messages\ntable below."}, {"id": "map-A328-A364", "address_start": 41768, "address_end": 41828, "hex_start": "$A328", "hex_end": "$A364", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41768-41828   $A328-$A364\nError Message Vector Table\n\nThis table contains the two-byte address of the first letter of each\nof the 30 error messages."}, {"id": "map-A365-A389", "address_start": 41829, "address_end": 41865, "hex_start": "$A365", "hex_end": "$A389", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41829-41865   $A365-$A389\nMiscellaneous Messages\n\nThe text of some of the other messages that BASIC can give you is\nstored here.  This text includes cursor movement characters, and each\nmessage ends with a 0 character.  The messages are:\n\n1) Carriage return, OK, carriage return\n2) Space, space, ERROR\n3) Space, IN, space\n4) Carriage return, linefeed, READY., carraige return, linefeed\n5) Carriage return, linefeed, BREAK"}, {"id": "map-A38A-A3B7", "address_start": 41866, "address_end": 41911, "hex_start": "$A38A", "hex_end": "$A3B7", "label": "FNDFOR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41866-41911   $A38A-$A3B7    FNDFOR\nFind FOR on Stack\n\nThis routine searches the stack for the blocks of data entries which\nare stored by each FOR command.  For more information on the data that\nFOR places on the stack, see location 256 ($100)."}, {"id": "map-A3B8", "address_start": 41912, "address_end": 41912, "hex_start": "$A3B8", "hex_end": "$A3B8", "label": "BLTU", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41912         $A3B8          BLTU\nOpen a Space in Memory for a New Program Line or Variable\n\nWhen a new nonarray variable is being created, or when a BASIC program\nline is being added or replaced, this routine is used to make room for\nthe addition.  It first checks to see if space is available, and then\nmoves the program text and/or variables to make room."}, {"id": "map-A3FB-A407", "address_start": 41979, "address_end": 41991, "hex_start": "$A3FB", "hex_end": "$A407", "label": "GETSTK", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41979-41991   $A3FB-$A407    GETSTK\nCheck for Space on Stack\n\nBefore undertaking an operation that requires stack space, this\nroutine is used to check if there is enough room on the stack.  If\nthere is not, an OUT OF MEMORY error is issued."}, {"id": "map-A408-A434", "address_start": 41992, "address_end": 42036, "hex_start": "$A408", "hex_end": "$A434", "label": "REASON", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "41992-42036   $A408-$A434    REASON\nCheck for Space in Memory\n\nThis is the subroutine that checks to see if there is enough space in\nfree memory for proposed additions such as new lines of program text.\nIf not, it calls for garbage collection, and if this still does not\nproduce enough space, an OUT OF MEMORY error is issued."}, {"id": "map-A435-A468", "address_start": 42037, "address_end": 42088, "hex_start": "$A435", "hex_end": "$A468", "label": "OMERR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42037-42088   $A435-$A468    OMERR\nOUT OF MEMORY Error Handler\n\nThis routine just sets the error message code, and falls through to\nthe general error handler."}, {"id": "map-A437-A468", "address_start": 42039, "address_end": 42088, "hex_start": "$A437", "hex_end": "$A468", "label": "ERROR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42039-42088   $A437-$A468    ERROR\nGeneral Error Handler\n\nThe error number is passed to this routine in the .X register, and it\ndisplays the appropriate error message.  Since this routine is\nvectored through RAM at 768 ($300), you can divert this vector to the\naddress of your own routine, which would allow error trapping, or the\naddition of new commands.\n\n42089-42099   $A474-$A47F    READY\nPrint READY\n\nThis routine displays the word READY, sets the Kernal message flag to\nshow that direct mode is operative, and falls through to the main\nBASIC loop."}, {"id": "map-A480-A49B", "address_start": 42112, "address_end": 42139, "hex_start": "$A480", "hex_end": "$A49B", "label": "MAIN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42112-42139   $A480-$A49B    MAIN\nMain Loop, Receives Input and Executes Immediately or Stores as\nProgram Line\n\nThis is the main BASIC program loop.  It jumps through the RAM vector\nat 770 ($302), so this routine can be diverted.  The routine gets a\nline of input from the keyboard, and checks for a line number.  If\nthere is a line number, the program branches to the routine that\nstores a line of program text.  If there is no line number, it\nbranches to the routine that executes statements."}, {"id": "map-A49C", "address_start": 42140, "address_end": 42140, "hex_start": "$A49C", "hex_end": "$A49C", "label": "MAIN1", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42140         $A49C          MAIN1\nAdd or Replace a Line of Program Text\n\nThis routine calls subroutines to get the line number, tokenize\nkeywords, and then looks for a line with the same line number.\n\nIf it finds a line with the same number, the routine deletes that line\nby moving all higher program text and variables down to where it\nstarted.  The new line is then added.  Since the CLR routine is\ncalled, the value of all current program variables is lost."}]