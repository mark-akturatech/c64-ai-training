[{"id": "map-259-276", "address_start": 601, "address_end": 630, "hex_start": "$259", "hex_end": "$276", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location_range", "text": "Location Range: 601-630 ($259-$276)\nTables for File Numbers, Device Numbers, and Secondary Addresses\n\nAll three of the tables here have room for ten one-byte entries, each\nof which represents an active Input/Output file.  When an I/O file is\nopened, its logical file number is put into the table at 601 ($259),\nthe device number of the I/O device is put into the table at 611\n($263), and its secondary address is put into the table at 621 ($26D).\n\nThe entry for any particular I/O file will occupy the same position in\neach of the three tables.  That is, if logical file number 2 is the\nthird entry in the file number table, its secondary address will be\nthe third entry in the secondary address table, and its corresponding\ndevice number will occupy the third spot in the device number table.\n\nEvery time a device is OPENed, its information is added as the last\nentry in each table, and the value at location 152 ($98) is increased\nby one, indicating that there is one more active I/O file.  When a\ndevice is CLOSEd, the value at location 152 is decreased by one, and\nall entries that occupy a position in the tables that is higher than\nthat of the closed device are moved down one position, thus\neliminating the entry for that device.  The Kernal CLALL routine\n(62255, $F32F) simply zeros location 152, which has the effect of\nemptying these tables."}, {"id": "map-259-262", "address_start": 601, "address_end": 610, "hex_start": "$259", "hex_end": "$262", "label": "LAT", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "601-610       $259-$262      LAT\nKernal Table of Active Logical File Numbers"}, {"id": "map-263-26C", "address_start": 611, "address_end": 620, "hex_start": "$263", "hex_end": "$26C", "label": "FAT", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "611-620       $263-$26C      FAT\nKernal Table of Device Numbers for Each Logical File"}, {"id": "map-26D-276", "address_start": 621, "address_end": 630, "hex_start": "$26D", "hex_end": "$276", "label": "SAT", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "621-630       $26D-$276      SAT\nKernal Table of Secondary Addresses for Each Logical File"}, {"id": "map-277-280", "address_start": 631, "address_end": 640, "hex_start": "$277", "hex_end": "$280", "label": "KEYD", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "631-640       $277-$280      KEYD\nKeyboard Buffer (Queue)\n\nThis buffer, sometimes also referred to as the keyboard queue, holds\nthe ASCII values of the characters entered from the keyboard.  The\ninterrupt routine which scans the keyboard deposits a character here\neach time a key is pressed.  When BASIC sees that there are characters\nwaiting, it removes and prints them, one by one, in the order in which\nthey were entered.\n\nThis kind of a buffer is known as FIFO, for First In, First Out.  The\nbuffer will hold up to ten characters, allowing you to type faster\nthan the computer prints characters, without losing characters.  The\nmaximum number of characters this buffer can hold at one time is ten\n(as determined by the value at 649 ($289)).  Characters entered after\nthe buffer is full will be ignored.\n\nThe commands GET and INPUT retrieve characters from this buffer.  If\none of these is executed while there are already characters waiting in\nthe buffer, those characters will be fetched as if they were part of\nthe data being input.  To prevent this from happening, you can clear\nthe buffer by POKEing a 0 into location 198 ($C6), which holds the\nnumber of characters that are waiting in the buffer.\n\nOne of the most interesting and useful techniques for programming\nCommodore computers is to have a program simulate direct entry of\ncommands from the keyboard.  This dynamic keyboard trick is achieved\nby first POKEing PETASCII characters, usually cursor movement\ncharacters and carriage returns, into the buffer, and setting location\n198 ($C6) to show how many characters are waiting in the buffer.\n\nNext, you clear the screen, and PRINT the statements that you wish to\nhave executed on the screen, carefully positioning them so that the\nfirst statement to be entered is on the fourth line of the screen.\n\nYou then home the cursor and execute an END statement.  This causes\nthe keyboard buffer to be read, and the carriage returns to be\nexecuted, thus entering the printed lines as if they had been typed in\nimmediate or direct mode.  The program can be continued by including a\nGOTO statement in the last line entered.\n\nMany interesting effects can be achieved using this method.  Examples\nof a few of these are included below.  For example, program lines can\nbe added, modified, or deleted, while the program is running.  The\nfollowing example shows how this is done:\n\n10 REM THIS LINE WILL BE DELETED\n20 REM A NEW LINE 30 WILL BE CREATED\n40 PRINT CHR$(147):PRINT:PRINT\n50 PRINT \"80 LIST\":PRINT\"30 REM THIS LINE WASN'T HERE BEFORE\"\n60 PRINT \"10\":PRINT \"GOTO 80\"CHR$(19)\n70 FOR I=631 TO 634:POKE I,13:NEXT:POKE 198,4:END\n80 REM THIS LINE WILL BE REPLACED\n\nYou can use this technique to enter numbered DATA statements\nautomatically, using values in memory.  These statements become a\npermanent part of the program.\n\nAnother interesting application is taking ASCII program lines from a\ntape data file, or sequential disk file, and having them entered\nautomatically.  This can be used for merging programs, or for\ntransferring programs between computers with a modem and a terminal\nprogram.  To create the ASCII program file, you use CMD to direct a\nLISTing to the desired device as follows:\n\nFor tape: OPEN 1,1,1,\"ASCII\":CMD 1:LIST\nAfter the listing has ended: PRINT #1:CLOSE 1\n\nFor disk: OPEN 8,8,8,\"ASCII,S,W\":CMD 8:LIST\nAfter the listing has ended: PRINT #8:CLOSE 8\n\nThis file can then be uploaded using a modem and appropriate terminal\nsoftware, entered by itself or merged with another program by using\nthe following program.  Be sure to save this program before you run\nit, because it will erase itself when it is done.\n\n60000 OPEN 1,8,8,\"ASCII\"\n60010 POKE 152,1:B=0:GOSUB 60170\n60020 GET #1,A$:IF A$=\"\"THEN60020\n60030 IF ST AND 64 THEN 60120\n60040 IF A$=CHR$(13)AND B=0THEN60020\n60050 PRINT A$;:B=1:IF A$=CHR$(34)THEN POKE 212,0\n60060 IF A$<>CHR$(13) THEN 60020\n60070 PRINT CHR$(5);\"GOTO 60010\";CHR$(5):PRINT:PRINT:POKE 198,0\n60080 PRINT \"RETURN=KEEP LINE    S=SKIP LINE\":B=0\n60090 GET A$:IF A$=\"\"THEN 60090\n60100 IF A$=\"S\" THEN 60010\n60110 GOTO 60180\n60120 PRINT \"END OF FILE--HIT RETURN TO FINISH MERGE\"\n60130 IF PEEK(197)<>1THEN60130\n60140 A=60000\n60150 GOSUB 60170:FOR I=A TO A+60 STEP10:PRINTI:NEXT\n60160 PRINT \"A=\"I\":GOTO 60150\":GOTO 60180\n60170 PRINT CHR$(147):PRINT:PRINT:RETURN\n60180 FOR I=631TO640:POKEI,13:NEXT:POKE198,10:PRINTCHR$(19);:END\n\nIf you wish to merge additional programs at the same time, when it\nindicates that the file has ended, press the STOP key rather than\nRETURN, enter the name of the new file in line 60000, and RUN 60000"}, {"id": "map-281", "address_start": 641, "address_end": 642, "hex_start": "$281", "hex_end": "$281", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "641-642       $281-282       MEMSTR\nPointer: O.S. Start of Memory\n\nWhen the power is first turned on, or a cold start RESET is performed,\nthe Kernal routine RAMTAS (64848, $FD50) sets this location to point\nto address 2048 ($800).  This indicates that this is the starting\naddress of user RAM.  BASIC uses this location to set its own start of\nmemory pointer at location 43 ($2B), and thereafter uses only its own\npointer.\n\nThe Kernal routine MEMBOT (65076, $FE34) may be used to read or set\nthis pointer, or these locations may be directly PEEKed or POKEd from\nBASIC."}, {"id": "map-283", "address_start": 643, "address_end": 644, "hex_start": "$283", "hex_end": "$283", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "643-644       $283-284       MEMSIZ\nPointer: O.S. End of Memory\n\nWhen the power is first turned on, or a cold start RESET is performed,\nthe Kernal routine RAMTAS (64848, $FD50) performs a nondestructive\ntest of RAM from 1024 ($400) up, stopping when the test fails,\nindicating the presence of ROM.  This will normally occur at 40960\n($A000), the location of the BASIC ROM.  The top of user RAM pointer\nis then set to point to that first ROM location.\n\nAfter BASIC has been started, the system will alter this location only\nwhen an RS-232 channel (device number 2) is OPENed or CLOSEd.  As 512\nbytes of memory are required for the RS-232 transmission and reception\nbuffers, this pointer, as well as the end of BASIC pointer at 55\n($37), is lowered to create room for those buffers when the device is\nopened.  CLOSing the device resets these pointers.\n\nThe Kernal routine MEMTOP (65061, $FE25) may be used to read or set\nthis pointer."}, {"id": "map-285", "address_start": 645, "address_end": 645, "hex_start": "$285", "hex_end": "$285", "label": "TIMOUT", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "645           $285           TIMOUT\nFlag: Kernal Variable for IEEE Time-Out\n\nThis location is used only with the external IEEE interface card\n(which was not yet available from Commodore at the time of writing).\nFor more information, see the entry for the Kernal SETTMO routine at\n65057 ($FE21)."}, {"id": "map-286", "address_start": 646, "address_end": 646, "hex_start": "$286", "hex_end": "$286", "label": "COLOR", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "646           $286           COLOR\nCurrent Foreground Color for Text\n\nThe process of PRINTing a character to the screen consists of both\nplacing the screen code value for the character in screen memory and\nplacing a foreground color value in the corresponding location in\ncolor RAM.  Whenever a character is PRINTed, the Operating System\nfetches the value to be put in color RAM from this location.\n\nThe foreground color may be changed in a number of ways.  Pressing the\nCTRL or Commodore logo key and numbers 1-8 at the same time will\nchange the value stored here, and thus the color being printed.\nPRINTing the PETASCII equivalent character with the CHR$ command will\nhave the same effect.  But probably the easiest method is to POKE the\ncolor value directly to this location.  The table below lists the\npossible colors that may be produced, and shows how to produce them\nusing all three methods.\n\nPOKE\nCOLOR #   COLOR     CHR$   KEYS TO PRESS\n 0        Black     144    CTRL-1\n 1        White       5    CTRL-2\n 2        Red        28    CTRL-3\n 3        Cyan      159    CTRL-4\n 4        Purple    156    CTRL-5\n 5        Green      30    CTRL-6\n 6        Blue       31    CTRL-7\n 7        Yellow    158    CTRL-8\n 8        Orange    129    Logo-1\n 9        Brown     149    Logo-2\n10        Lt Red    150    Logo-3\n11        Dark Gray 151    Logo-4\n12        Med Gray  152    Logo-5\n13        Lt Green  153    Logo-6\n14        Lt Blue   154    Logo-7\n15        Lt Gray   155    Logo-8"}, {"id": "map-287", "address_start": 647, "address_end": 647, "hex_start": "$287", "hex_end": "$287", "label": "GDCOL", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "647           $287           GDCOL\nColor of Character under Cursor\n\nThis location is used to keep track of the original color code of the\ncharacter stored at the present cursor location.  Since the blinking\ncursor uses the current foreground color at 646 ($286), the original\nvalue must be stored here so that if the cursor moves on without\nchanging that character, its color code can be restored to its\noriginal value."}, {"id": "map-288", "address_start": 648, "address_end": 648, "hex_start": "$288", "hex_end": "$288", "label": "HIBASE", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "648           $288           HIBASE\nTop Page of Screen Memory\n\nThis location contains the value used by the Operating System routines\nthat print to the screen as the base address for screen RAM.  The top\nof screen memory can be found by multiplying this location by 256.\nThe default value for screen RAM is set on power-up to location 1024\n($400), and this location therefore usually contains a 4.\n\nScreen display memory on the Commodore 64 can be moved to start on any\n1K boundary (location evenly divisible by 1024).  This is done by\nmanipulating the VIC-II chip memory bank select at location 56576\n($DD00).\n\nIt is important to note, however, that while any area may be\ndisplayed, the Operating System will look here to find out where it\nshould PRINT characters.  Therefore, if you change the screen location\nby altering the contents of one of the two addresses listed above, the\nOperating System will still not know where to PRINT characters unless\nyou also change this address as well.  The result will be that\ncharacters entered from the keyboard or PRINTed will not appear on the\nscreen.\n\nExamples of how to properly relocate the screen can be found at the\nentries for location 53272 ($D018) and 43 ($2B).\n\nSince the PRINT command in essence just POKEs a lot of values to\nscreen and color memory, by changing this pointer you can print a\nstring of characters to memory locations other than screen RAM.  For\nexample, you could PRINT a sprite shape to memory without having to\nREAD a lot of DATA statements.  The program below PRINTs different\nsprite shapes into the sprite data area:\n\n10 SP=53248:POKESP,170:POKESP+1,125:POKESP+21,1:POKE 2040,13:PRINT CHR$(147)\n20 A$=\"THIS TEXT WILL BE PRINTED TO THE SPRITE SHAPE DATA AREA AND DISPLAYED\"\n30 GOSUB 100\n40 A$=\"THIS IS SOME DIFFERENT TEXT TO BE PRINTED TO THE SPRITE SHAPE AREA\"\n50 GOSUB 100\n60 COUNT=COUNT+1:IF COUNT<15 THEN 20\n70 END\n100 POKE 648,3:PRINT CHR$(19);CHR$(17);SPC$(24);A$;:POKE 648,4:RETURN\n\nSince PRINTing also changes color memory, you can change the pointer\nto print the characters harmlessly to ROM, while changing a lot of\nscreen RAM at one time, as the following program demonstrates:\n\n10 D$=CHR(94):FOR I=1 TO 4:D$=D$+D$:NEXT\n20 PRINT CHR$(147);:FOR I=1 TO 7:PRINT TAB(10) D$:NEXT:PRINT:PRINT:PRINT:PRINT\n30 PRINT TAB(9);CHR$(5);\"HIT ANY KEY TO STOP\"\n40 DIM C(15):FOR I=0TO14:READ A:C(I)=A:NEXT:DATA2,8,7,5,6,4,1,2,8,7,5,6,4,1,2\n50 POKE 53281,0:POKE 648,212:FOR J=0 TO 6:PRINT CHR$(19);\n60 FOR I=J TO J+6:POKE 646,C(I):PRINT TAB(10) D$:NEXT I,J\n70 GET A$:IF A$=\"\" THEN 50\n80 POKE 648,4:POKE 646,1"}, {"id": "map-289", "address_start": 649, "address_end": 649, "hex_start": "$289", "hex_end": "$289", "label": "XMAX", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "649           $289           XMAX\nMaximum Keyboard Buffer Size\n\nThe value here indicates the maximum number of characters that the\nkeyboard buffer at 631 ($277) may hold at any one time.  Anytime that\nthe current buffer length in location 198 ($C6) matches the value\nhere, further keypresses will be ignored.\n\nAlthough the maximum size of the keyboard buffer is usually 10\ncharacters, it may be possible to extend it up to 15 characters by\nchanging the number here.  This could cause the Operating System\npointers to the bottom and top of memory at 641-644 ($281-$284) to be\noverwritten, but no real harm should result."}, {"id": "map-28A", "address_start": 650, "address_end": 650, "hex_start": "$28A", "hex_end": "$28A", "label": "RPTFLAG", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "650           $28A           RPTFLAG\nFlag: Which Keys Will Repeat?\n\nThe flag at this location is used to determine whether to continue\nprinting a character as long as its key is held down, or whether to\nwait until the key is let up before allowing it to be printed again.\nThe default value here is 0, which allows only the cursor movement\nkeys, insert/delete key, and the space bar to repeat.\n\nPOKEing this location with 128 ($80) will make all keys repeating,\nwhile a value of 64 ($40) will disable all keys from repeating."}, {"id": "map-28B", "address_start": 651, "address_end": 651, "hex_start": "$28B", "hex_end": "$28B", "label": "KOUNT", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "651           $28B           KOUNT\nCounter for Timing the Delay Between Key Repeats\n\nThis location is used as a delay counter to determine how long to wait\nwhile a key is being held down until the next repeat printing of that\nkey.\n\nThe value here starts at 6.  If location 652 ($28C) contains a 0, the\nvalue in this location is counted down once every 1/60 second, so long\nas the same key is held down.  When this counter gets to 0, and if the\nrepeat flag at 650 ($28A) allows that key to repeat, its ASCII\nequivalent will once again be placed in the keyboard buffer.  A value\nof 4 is then placed in location 651, allowing subsequent repeats to\noccur at a rate of 15 per second."}, {"id": "map-28C", "address_start": 652, "address_end": 652, "hex_start": "$28C", "hex_end": "$28C", "label": "DELAY", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "652           $28C           DELAY\nCounter for Timing the Delay Until the First Key Repeat Begins\n\nThis location is used as a delay counter to determine how long a key\nmust be held down before the entry of that key should be repeated.\n\nThe initial value of 16 is counted down every 1/60 second, as long as\nthe same key remains pressed.  When the value gets to 0, location 651\n($28B) is counted down from 6, and the key is repeated when the value\nthere reaches 0.  Thus a total of 22/60, or approximately 1/3, second\nwill elapse before the first repeat of a key.  The value here will be\nheld to 0 after the first repeat, so that subsequent keystroke\nrepititions occur much more quickly."}, {"id": "map-28D", "address_start": 653, "address_end": 653, "hex_start": "$28D", "hex_end": "$28D", "label": "SHFLAG", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "653           $28D           SHFLAG\nFlag: SHIFT/CTRL/Logo Keypress\n\nThis flag signals which of the SHIFT, CTRL, or Commodore logo keys are\ncurrently being pressed, if any.\n\nA value of 1 signifies that one of the SHIFT keys is being pressed, a\n2 shows that the Commodore logo key is down, and 4 means that the CTRL\nkey is being pressed.  If more than one key is held down, these values\nwill be added; for example, a 3 indicates that SHIFT and logo are both\nheld down.\n\nThe value here is used by the Operating System when determining how to\nconvert a keypress into a PETASCII character.  There are four\ndifferent tables used to translate one of the 64 keys on the keyboard\nmatrix into a PETASCII character, and the combination of special SHIFT\nkeys determines which of these tables will be used (see the entry for\nlocation 245 ($F5) for more details on the keyboard tables).\n\nPressing the SHIFT and Commodore logo keys at the same time will\ntoggle the character set that is presently being used between the\nuppercase/graphics set, and the lowercase/uppercase set (provided that\nthe flag at 657 ($291) has not been set to disable this switch).\n\nThis changes the appearance of all of the characters on the screen at\nonce.  It has nothing whatever to do with the keyboard shift tables,\nhowever, and should not be confused with the printing of SHIFTed\ncharacters, which affects only one character at a time.  Rather, it is\nthe result of the value of the character dot data table base address\nin 53272 ($D018) being changed.  The came result may be obtained by\nPOKEing that address directly."}, {"id": "map-28E", "address_start": 654, "address_end": 654, "hex_start": "$28E", "hex_end": "$28E", "label": "LSTSHF", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "654           $28E           LSTSHF\nLast Pattern of SHIFT/CTRL/Logo Keypress\n\nThis location is used in combination with the one above to debounce\nthe special SHIFT keys.  This will keep the SHIFT/logo combination\nfrom changing character sets back and forth during a single pressing\nof both keys."}, {"id": "map-28F-290", "address_start": 655, "address_end": 656, "hex_start": "$28F", "hex_end": "$290", "label": "KEYLOG", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "655-656       $28F-$290      KEYLOG\nVector to Keyboard Table Setup Routine\n\nThis location points to the address of the Operating System routine\nwhich actually determines which keyboard matrix lookup table will be\nused.\n\nThe routine looks at the value of the SHIFT flag at 653 ($28D), and\nbased on what value it finds there, stores the address of the correct\ntable to use at location 245 ($F5).\n\nThe interrupt driven keyboard-scanning routine jumps through this RAM\nvector to get to the table setup routine.  Therefore, it is possible\nto alter the address contained in this vector, and direct the keyscan\nroutine to your own routine, which can check the keypress and SHIFT\ncombination, and act before a character is printed.\n\nSince this routine comes after the keypress, but before it is printed,\nthis is a very good place to have your preprocessor routine check for\na particular keypress.  An excellent example of such a program is the\n\"VICword\" program by Mark Niggemann, COMPUTE!'s Second Book of VIC.\nThis program adds a machine language routine that checks if the SHIFT\nor Commodore logo key is pressed while not in quote mode.  If it finds\none of these keypresses, it substitutes an entire BASIC keyword for\nthe letter (A-Z) of the key that was pressed.  An adaptation of that\nprogram for the 64 appears below.\n\n100 IF PEEK(PEEK(56)*256)<>120THENPOKE56,PEEK(56)-1:CLR\n110 HI=PEEK(56):BASE=HI*256\n120 PRINTCHR$(147)\"READING DATA\"\n130 FOR AD=0 TO 211:READ BY\n140 POKE BASE+AD,BY:NEXT AD\n150 :\n200 REM RELOCATION ADJUSTMENTS\n210 POKE BASE+26,HI:POKE BASE+81,HI\n220 POKE BASE+123,HI:POKE BASE+133,HI\n230 :\n240 PRINT CHR$(147) TAB(15)\"***64WORD***\":PRINT\n250 PRINT\"TO TOGGLE THE PROGRAM ON/OFF:\":PRINT:PRINT:PRINT \"SYS\";BASE;\n260 PRINT CHR$(145);CHR$(145);\n270 DATA 120,173,143,2,201,32\n280 DATA 208,12,169,220,141,143\n290 DATA 2,169,72,141,144,2\n300 DATA 88,96,169,32,141,143\n310 DATA 2,169,0,141,144,2\n320 DATA 88,96,165,212,208,117\n330 DATA 173,141,2,201,3,176\n340 DATA 110,201,0,240,106,169\n350 DATA 194,133,245,169,235,133\n360 DATA 246,165,215,201,193,144\n370 DATA 95,201,219,176,91,56\n380 DATA 233,193,174,141,2,224\n390 DATA 2,208,3,24,105,26\n400 DATA 170,189,159,0,162,0\n410 DATA 134,198,170,160,158,132\n420 DATA 34,160,160,132,35,160\n430 DATA 0,10,240,16,202,16\n440 DATA 12,230,34,208,2,230\n450 DATA 35,177,34,16,246,48\n460 DATA 241,200,177,34,48,17\n470 DATA 8,142,211,0,230,198\n480 DATA 166,198,157,119,2,174\n490 DATA 211,0,40,208,234,230\n500 DATA 198,166,198,41,127,157\n510 DATA 199,2,230,198,169,20\n520 DATA 141,119,2,76,72,235\n530 DATA 76,224,234\n550 REM TOKENS FOR SHIFT KEY\n570 DATA 153,175,199,135,161,129\n580 DATA 141,164,133,137,134,147\n590 DATA 202,181,159,151,163,201\n600 DATA 196,139,192,149,150,155\n610 DATA 191,138\n630 REM TOKENS FOR COMMODORE KEY\n650 DATA 152,165,198,131,128,130\n660 DATA 142,169,132,145,140,148\n670 DATA 195,187,160,194,166,200\n680 DATA 197,167,186,157,165,184\n690 DATA 190,158,0\n\nCommodore 64word: Keys into BASIC Commands\n\nKey   SHIFT   Commodore\nA     PRINT   PRINT#\nB     AND     OR\nC     CHR$    ASC\nD     READ    DATA\nE     GET     END\nF     FOR     NEXT\nG     GOSUB   RETURN\nH     TO      STEP\nI     INPUT   INPUT#\nJ     GOTO    ON\nK     DIM     RESTORE\nL     LOAD    SAVE\nM     MID$    LEN\nN     INT     RND\nO     OPEN    CLOSE\nP     POKE    PEEK\nQ     TAB(    SPC(\nR     RIGHT$  LEFT$\nS     STR$    VAL\nT     IF      THEN\nU     TAN     SQR\nV     VERIFY  CMD\nW     DEF     FN\nX     LIST    FRE\nY     SIN     COS\nZ     RUN     SYS"}, {"id": "map-291", "address_start": 657, "address_end": 657, "hex_start": "$291", "hex_end": "$291", "label": "MODE", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "657           $291           MODE\nFlag: Enable or Disable Changing Character Sets with SHIFT/Logo\nKeypress\n\nThis flag is used to enable or disable the feature which lets you\nswitch between the uppercase/graphics and upper/lowercase character\nsets by pressing the SHIFT and Commodore logo keys simultaneously.\n\nThis flag affects only this special SHIFT key function, and does not\naffect the printing of SHIFTed characters.  POKEing a value of 128\n($80) here will disable this feature, while POKEing a value of 0 will\nenable it once more.  The same effect can be achieved by PRINTing\nCHR$(8) or CTRL-H to disable the switching of character sets, and\nCHR$(9) or CTRL-I to enable it.  See entries for locations 53272\n($D018) and 49152 ($C000) for more information on switching character\nsets."}, {"id": "map-292", "address_start": 658, "address_end": 658, "hex_start": "$292", "hex_end": "$292", "label": "AUTODN", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "658           $292           AUTODN\nFlag: Screen Scrolling Enabled\n\nThis location is used to determine whether moving the cursor past the\nfortieth column of a logical line will cause another physical line to\nbe added to the logical line.\n\nA value of 0 enables the screen to scroll the following lines down in\norder to add that line; any nonzero value will disable the scroll.\nThis flag is set to disable the scroll temporarily when there are\ncharacters waiting in the keyboard buffer (these may include cursor\nmovement characters that would eliminate the need for a scroll)."}, {"id": "map-293-297", "address_start": 659, "address_end": 663, "hex_start": "$293", "hex_end": "$297", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location_range", "text": "Location Range: 659-663 ($293-$297)\nRS-232 Pseudo 6551 Registers\n\nFor serial Input/Output via the RS-232 port, the internal software of\nthe Commodore 64 emulates the operation of a 6551 UART chip (that's\nUniversal Asynchronous Receiver/Transmitter, for you acronym buffs),\nalso known as an ACIA (Asynchronous Communications Interface Adapter).\n\nThese RAM locations are used to mimic the functions of that chip's\nhardware command, control, and status registers.  Although RAM\nlocations are allocated for mimicking the 6551's ability to use either\nan on-board baud rate generator or an external clock crystal, this\nfunction is not implemented by the internal software.\n\nProvisions have been made for the user to communicate with these\nregisters through the RS-232 OPEN command.  When device 2 is opened, a\nfilename of up to four characters may be appended.  These four\ncharacters are copied to locations 659-662 ($293-$296), although the\nlast two, which specify a nonstandard baud rate, are not used because\nthat feature is not implemented."}, {"id": "map-293", "address_start": 659, "address_end": 659, "hex_start": "$293", "hex_end": "$293", "label": "M51CTR", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "659           $293           M51CTR\nRS-232: Mock 6551 Control Register\n\nThis location is used to control the RS-232 serial I/O baud rate\n(speed at which data is transmitted and received), the word length\n(number of bits per data character), and the number of stop bits used\nto mark the end of a transmitted character.  It uses the same format\nas that of the 6551 UART control register to set these parameters,\nalthough, as you will see, some of the 6551 configurations are not\nimplemented by the software that emulates the UART device.  For\nexample, the standard baud rates which are higher than 2400 baud are\nnot implemented, presumably because the software cannot keep up at\nhigher rates.  The meanings of the various bit patterns are as\nfollows:\n\nBit 7: STOP Bits\n0    (bit value of 0)   = 1 STOP Bit\n1    (bit value of 128) = 0 STOP Bits\n\nBits 6-5: WORD LENGTH\n00   (bit value of 0)   = 8 DATA Bits\n01   (bit value of 32)  = 7 DATA Bits\n10   (bit value of 64)  = 6 DATA Bits\n11   (bit value of 96)  = 5 DATA Bits\n\nBit 4: Unused\n\nBits 3-0: BAUD RATE\n0000 (bit value of 0)   = Nonstandard (User-Defined) Rate (Not Implemented)\n0001 (bit value of 1)   = 50 Baud\n0010 (bit value of 2)   = 75 Baud\n0011 (bit value of 3)   = 110 Baud\n0100 (bit value of 4)   = 134.5 Baud\n0101 (bit value of 5)   = 150 Baud\n0110 (bit value of 6)   = 300 Baud\n0111 (bit value of 7)   = 600 Baud\n1000 (bit value of 8)   = 1200 Baud\n1001 (bit value of 9)   = 1800 Baud\n1010 (bit value of 10)  = 2400 Baud\n1011 (bit value of 11)  = 3600 Baud (Not Implemented on the Commodore 64)\n1100 (bit value of 12)  = 4800 Baud (Not Implemented on the Commodore 64)\n1101 (bit value of 13)  = 7200 Baud (Not Implemented on the Commodore 64)\n1110 (bit value of 14)  = 9600 Baud (Not Implemented on the Commodore 64)\n1111 (bit value of 15)  = 19200 Baud (Not Implemented on the Commodore 64)\n\nThis register is the only one which must be set when opening RS-232\ndevice (number 2).  The first character of the filename will be stored\nhere.  For example, the statement OPEN 2,2,0,CHR$(6+32) will set the\nvalue of this location to 38.  As you can see from the above chart,\nthis sets up the RS-232 device for a data transfer rate of 300 baud,\nusing seven data bits per character and one stop bit."}, {"id": "map-294", "address_start": 660, "address_end": 660, "hex_start": "$294", "hex_end": "$294", "label": "M51CDR", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "660           $294           M51CDR\nRS-232: Mock 6551 Command Register\n\nThis location performs the same function as the 6551 UART chip's\ncommand register, which specifies type of parity, duplex mode, and\nhandshaking protocol.\n\nThe type of parity used determines how the 64 will check that RS-232\ndata is received correctly.\n\nThe duplex mode can be either full duplex (the 64 will be able to\ntransmit at the same time it is receiving) or half duplex (it will\ntake turns sending and receiving).\n\nThe handshaking protocol has to do with the manner in which the\nsending device lets the receiver know that it is ready to send data,\nand the receiver lets the sender know that it has gotten the data\ncorrectly.  The meanings of the bit patterns in this register are as\nfollows:\n\nBits 7-5: Parity\nXX0 (bit value of\n     0,64,128, or 192) = No Parity Generated or Received\n001 (bit value of 32)  = Odd Parity Transmitted and Received\n011 (bit value of 96)  = Even Parity Transmitted and Received\n101 (bit value of 160) = Mark Parity Transmitted and Received\n111 (bit value of 224) = Space Parity Transmitted and Received\n\nBit 4: Duplex\n0 (bit value of 0)  = Full Duplex\n1 (bit value of 16) = Half Duplex\n\nBits 3-1: Unused\n\nBit 0: Handshake Protocol\n0 (bit value of 0) = 3 Line\n1 (bit value of 1) = X Line\n\nThis register can be set at the user's option when opening RS-232\ndevice (number 2).  The second character of the filename will be\nstored here.  For example, the statement\n\nOPEN 2,2,0,CHR$(6+32)+CHR$(32+16)\n\nwill set the value of this location to 48, which is the value of the\nsecond character in the filename portion of the statement.  As you can\nsee from the above chart, this configures the RS-232 device for half\nduplex data transfer using odd parity and three-line handshaking."}, {"id": "map-295-296", "address_start": 661, "address_end": 662, "hex_start": "$295", "hex_end": "$296", "label": "M51AJB", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "661-662       $295-$296      M51AJB\nRS-232: Nonstandard Bit Timing\n\nThese locations are provided for storing a nonstandard user-defined\nbaud rate, to be used when the low nybble of the control register at\n659 ($293) is set to 0.  They were presumable provided to conform to\nthe nodel of the 6551 UART device, which allows a nonstandard baud\nrate to be generated from an external reference crystal.  However, the\nsoftware emulation of that feature is not provided in the current\nversion of the Kernal, and thus these locations are currently\nnonfunctional.\n\nNonetheless, Commodore has specified that if the nonstandard baud rate\nfeature is implemented, the value placed here should equal the system\nclock frequency divided by the baud rate divided by 2 minus 100,\nstored in low byte, high byte order.  The system clock frequency for\nAmerican television monitors (NTSC standard) is 1.02273 MHz, and for\nEuropean monitors (PAL standard) .98525 MHz."}, {"id": "map-297", "address_start": 663, "address_end": 663, "hex_start": "$297", "hex_end": "$297", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "663           $297           $RSSTAT\nRS-232: Mock 6551 Status Register\n\nThe contents of this register indicate the error status of RS-232 data\ntransmission.  That status can be determined by PEEKing this location\ndirectly, by referencing the BASIC reserved variable ST, or by using\nthe Kernal READST (65031, $FE07) routine.\n\nNote that if you use ST or Kernal, this location will be set to 0\nafter it is read.  Therefore, if you need to test more than one bit,\nmake sure that each test preserves the original value, because you\nwon't be able to read it again.  The meaning of each bit value is\nspecified below:\n\nBit 7: 1 (bit value of 128) = Break Detected\nBit 6: 1 (bit value of 64)  = DTR (Data Set Ready) Signal Missing\nBit 5: Unused\nBit 4: 1 (bit value of 16)  = CTS (Clear to Send) Signal Missing\nBit 3: 1 (bit value of 8)   = Receiver Buffer Empty\nBit 2: 1 (bit value of 4)   = Receiver Buffer Overrun\nBit 1: 1 (bit value of 2)   = Framing Error\nBit 0: 1 (bit value of 1)   = Parity Error\n\nThe user is responsible for checking these errors and taking\nappropriate action.  If, for example, you find that Bit 0 or 1 is set\nwhen you are sending, indicating a framing or parity error, you should\nresend the last byte.  If Bit 2 is set, the GET#2 command is not being\nexecuted quickly enough to empty the buffer (BASIC should be able to\nkeep up at 300 baud, but not higher).  If Bit 7 is set, you will want\nto stop sending, and execute a GET#2 to see what is being sent."}, {"id": "map-298", "address_start": 664, "address_end": 664, "hex_start": "$298", "hex_end": "$298", "label": "BITNUM", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "664           $298           BITNUM\nRS-232: Number of Bits Left to be Sent/Received\n\nThis location is used to determine how many zero bits must be added to\nthe data character to pad its length out to the word length specified\nin 659 ($293)."}, {"id": "map-299-29A", "address_start": 665, "address_end": 666, "hex_start": "$299", "hex_end": "$29A", "label": "BAUDOF", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "665-666       $299-$29A      BAUDOF\nTime Required to Send a Bit\n\nThis location holds the prescaler value used by CIA #2 timers A and B.\n\nThese timers cause an NMI interrupt to drive the RS-232 receive and\ntransmit routines CLOCK/PRESCALER times per second each, where CLOCK\nis the system 02 frequency of 1,022,730 Hz (985,250 if you are using\nthe European PAL television standard rather than the American NTSC\nstandard), and PRESCALER is the value stored at 56580-1 ($DD04-5) and\n56582-3 ($DD06-7), in low-byte, high-byte order.  You can use the\nfollowing formula to figure the correct prescaler value for a\nparticular RS-232 baud rate:\n\nPRESCALER=((CLOCK/BAUDRATE)/2)-100\n\nThe American (NTSC standard) prescaler values for the standard RS-232\nbaud rates which the control register at 659 ($293) makes available\nare stored in a table at 65218 ($FEC2), starting with the two-byte\nvalue used for 50 baud.  The European (PAL standard) version of that\ntable is located at 58604 ($E4EC)."}, {"id": "map-29B-29E", "address_start": 667, "address_end": 670, "hex_start": "$29B", "hex_end": "$29E", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location_range", "text": "Location Range: 667-670 ($29B-$29E)\nByte Indices to the Beginning and End of Receive and Transmit Buffers\n\nThe two 256-byte First In, First Out (FIFO) buffers for RS-232 data\nreception and transmission are dynamic wraparound buffers.  This means\nthat the starting point and the ending point of the buffer can change\nover time, and either point can be anywhere withing the buffer.  If,\nfor example, the starting point is at byte 100, the buffer will fill\ntowards byte 255, at which point it will wrap around to byte 0 again.\nTo maintain this system, the following four locations are used as\nindices to the starting and the ending point of each buffer."}, {"id": "map-29B", "address_start": 667, "address_end": 667, "hex_start": "$29B", "hex_end": "$29B", "label": "RIDBE", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "667           $29B           RIDBE\nRS-232: Index to End of Receive Buffer\n\nThis index points to the ending byte within the 256-byte RS-232\nreceive buffer, and is used to add data to that buffer."}, {"id": "map-29C", "address_start": 668, "address_end": 668, "hex_start": "$29C", "hex_end": "$29C", "label": "RIDBS", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "668           $29C           RIDBS\nRS-232: Index to Start of Receive Buffer\n\nThis index points to the starting byte within the 256-byte RS-232\nreceive buffer, and is used to remove data from that buffer."}, {"id": "map-29D", "address_start": 669, "address_end": 669, "hex_start": "$29D", "hex_end": "$29D", "label": "RODBS", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "669           $29D           RODBS\nRS-232: Index to Start of Transmit Buffer\n\nThis index points to the starting byte within the 256-byte RS-232\ntransmit buffer, and is used to remove data from that buffer."}, {"id": "map-29E", "address_start": 670, "address_end": 670, "hex_start": "$29E", "hex_end": "$29E", "label": "RODBE", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "670           $29E           RODBE\nRS-232: Index to End of Transmit Buffer\n\nThis index points to the ending byte within the 256-byte RS-232\ntransmit buffer, and is used to add data to that buffer."}, {"id": "map-29F-2A0", "address_start": 671, "address_end": 672, "hex_start": "$29F", "hex_end": "$2A0", "label": "IRQTMP", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "671-672       $29F-$2A0      IRQTMP\nSAve Area for IRQ Vector During Cassette I/O\n\nThe routines that read and write tape data are driven by an IRQ\ninterrupt.  In order to hook one of these routines into the interrupt,\nthe RAM IRQ vector at 788-789 ($314-$315) must be changed to point to\nthe address at which it starts.  Before that change is made, the old\nIRQ vector address is saved at these locations, so that after the tape\nI/O is finished, the interrupt that is used for scanning the keyboard,\nchecking the stop key, and updating the clock can be restored.\n\nYou will note that all of the above functions will be suspended during\ntape I/O."}, {"id": "map-2A1", "address_start": 673, "address_end": 673, "hex_start": "$2A1", "hex_end": "$2A1", "label": "ENABL", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "673           $2A1           ENABL\nRS-232 Interrupts Enabled\n\nThis location holds the active NMI interrupt flag byte from CIA #2\nInterrupt Control Register (56589, $DD0D).  The bit values for this\nflag are as follows:\n\nBit 4: 1 (bit value of 16) = System is Waiting for Receiver Edge\nBit 1: 1 (bit value of 2)  = System is Receiving Data\nBit 0: 1 (bit value of 1)  = System is Transmitting Data"}, {"id": "map-2A2", "address_start": 674, "address_end": 674, "hex_start": "$2A2", "hex_end": "$2A2", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "674           $2A2\nIndicator of CIA #1 Control Register B Activity During Cassette I/O"}, {"id": "map-2A3", "address_start": 675, "address_end": 675, "hex_start": "$2A3", "hex_end": "$2A3", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "675           $2A3\nSave Area for CIA #1 Interrupt Control Register During Cassette Read"}, {"id": "map-2A4", "address_start": 676, "address_end": 676, "hex_start": "$2A4", "hex_end": "$2A4", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "676           $2A4\nSave Area for CIA #1 Control Register A During Cassette Read"}, {"id": "map-2A5", "address_start": 677, "address_end": 677, "hex_start": "$2A5", "hex_end": "$2A5", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "677           $2A5\nTemporary Index to the Next 40-Column Line for Screen Scrolling"}, {"id": "map-2A6", "address_start": 678, "address_end": 678, "hex_start": "$2A6", "hex_end": "$2A6", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "678           $2A6\nPAL/NTSC Flag\n\nAt power-on, a test is performed to see if the monitor uses the NTSC\n(North American) or PAL (European) television standard.\n\nThis test is accomplished by setting a raster interrupt for scan line\n311, and testing if the interrupt occurs.  Since NTSC monitors have\nonly 262 raster scan lines per screen, the interrupt will occur only\nif a PAL monitor is used.  The results of that test are stored here,\nwith a 0 indicating an NTSC system in use, and one signifying a PAL\nsystem.\n\nThis information is used by the routines which set the prescaler\nvalues for the system IRQ timer, so that the IRQ occurs every 1/60\nsecond.  Since the PAL system 02 clock runs a bit slower than the NTSC\nversion, this prescaler value must be adjusted accordingly."}, {"id": "map-2A7-2FF", "address_start": 679, "address_end": 767, "hex_start": "$2A7", "hex_end": "$2FF", "label": "", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "679-767       $2A7-$2FF\nUnused\n\nThe programmer may use this area for machine language subroutines, or\nfor graphics data storage.\n\nIf the VIC-II ship is using the bottom 16K for graphics and memory\n(the default setting when the system is turned on), this is one of the\nfew free areas available for storing sprite or character data.\nLocaitons 704-767 could be used for sprite data block number 11,\nwithout interfering with BASIC program text or variables."}, {"id": "map-300-30B", "address_start": 768, "address_end": 779, "hex_start": "$300", "hex_end": "$30B", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location_range", "text": "Location Range: 768-779 ($300-$30B)\nBASIC Indirect Vector Table\n\nSeveral important BASIC routines are vectored through RAM.  This means\nthat the first instruction executed by the routine is an indirect jump\nto a location pointed to by one of the vectors in this table.\n\nOn power up, the system sets these vectors to point to the next\ninstruction past the original JuMP instruction.  The routine then\ncontinues with that instruction as if the jump never took place.  For\nexample, the BASIC error message routine starts at 42039 ($A437) with\nthe instruction JMP ($300).  The indirect vector at 768 ($300) points\nto 42042 ($A43A), which is the instruction immediately following JMP\n($300).\n\nAlthough this may seem like a fancy way of accomplishing nothing,\nusing these indirect vectors serves two important purposes.  First, it\nallows you to use these important BASIC routines without knowing their\naddresses in the BASIC ROM.\n\nFor example, the routine to LIST the ASCII text of the single-byte\nBASIC program token that is currently in the Accumulator (.A) is\nlocated at one address in the VIC, and another in the 64.  On future\nCommodore computers it may be found at still another location.  Yet as\nlong as the routine is vectored in RAM at 774 ($306), the statement\nQP=PEEK(774)+256*PEEK(775) would find the address of that routine on\nany of the machines.  Thus, entering such routines through RAM vectors\nrather than a direct jump into the ROMs helps to keep your programs\ncompatible with different machines.\n\nThe other important effect of having these vectors in RAM is that you\ncan alter them.  In that way, you can redirect these important BASIC\nroutines to execute your own preprocessing routines first.\n\nIf you wanted to add commands to BASIC, for example, how would you go\nabout it?  First, you would need to change the BASIC routines that\nconvert ASCII program text to tokenized program format, so that when a\nline of program text was entered, the new keyword would be stored as a\ntoken.\n\nNext, you would need to change the routine that executes tokens, so\nthat when the interpreter comes to your new keyword token, it will\ntake the proper action.\n\nYou would also have to change the routine that converts tokens back to\nASCII text, so that your program would LIST the token out correctly.\nAnd you might want to alter the routine that prints error messages, to\nadd new messages for your keyword.\n\nAs you will see, vectors to all of these routines can be found in the\nfollowing indirect vector table.  Changing these vectors is a much\nmore elegant and efficient solution than the old wedge technique\ndiscussed at location 115 ($73)"}, {"id": "map-300-301", "address_start": 768, "address_end": 769, "hex_start": "$300", "hex_end": "$301", "label": "IERROR", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "768-769       $300-$301      IERROR\nVector to the Print BASIC Error Message Routine\n\nThis vector points to the address of the ERROR routine at 58251\n($E38B)."}, {"id": "map-302-303", "address_start": 770, "address_end": 771, "hex_start": "$302", "hex_end": "$303", "label": "IMAIN", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "770-771       $302-$303      IMAIN\nVector to the Main BASIC Program Loop\n\nThis vector points to the address of the main BASIC program loop at\n42115 ($A483).  This is the routine that is operating when you are in\nthe direct mode (READY).  It executes statements, or stores them as\nprogram lines."}, {"id": "map-304-305", "address_start": 772, "address_end": 773, "hex_start": "$304", "hex_end": "$305", "label": "ICRNCH", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "772-773       $304-$305      ICRNCH\nVector to the Routine That Crunches the ASCII Text of Keywords into\nTokens\n\nThis vector points to the address of the CRUNCH routine at 42364\n($A57C)."}, {"id": "map-306-307", "address_start": 774, "address_end": 775, "hex_start": "$306", "hex_end": "$307", "label": "IQPLOP", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "774-775       $306-$307      IQPLOP\nVector to the Routine That Lists BASIC Program Token as ASCII Text\n\nThis vector points to the address of the QPLOP routine at 42778\n($A71A)."}, {"id": "map-308-309", "address_start": 776, "address_end": 777, "hex_start": "$308", "hex_end": "$309", "label": "IGONE", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "776-777       $308-$309      IGONE\nVector to the Routine That Executes the Next BASIC Program Token\n\nThis vector points to the address of the GONE routine at 42980 ($A7E4)\nthat executes the next program token."}, {"id": "map-30A-30B", "address_start": 778, "address_end": 779, "hex_start": "$30A", "hex_end": "$30B", "label": "IEVAL", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "778-779       $30A-$30B      IEVAL\nVector to the Routine That Evaluates a Single-Term Arithmetic\nExpression\n\nThis vector points to the address of the EVAL routinea t 44678 ($AE86)\nwhich, among other things, is used to evaluate BASIC functions such as\nINT and ABS."}, {"id": "map-30C-30F", "address_start": 780, "address_end": 783, "hex_start": "$30C", "hex_end": "$30F", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location_range", "text": "Location Range: 780-783 ($30C-$30F)\nRegister Storage Area\n\nThe BASIC SYS command uses this area to store 6510 internal\nregisters--the Accumulator (.A), the .X and .Y index registers, and\nthe status register, .P.\n\nBefore every SYS command, each of the registers is loaded with the\nvalue found in the corresponding storage address.  After the ML\nprogram finished executing, and returns to BASIC with an RTS\ninstruction, the new value of each register is stored in the\nappropriate storage address.  This is only true of SYS, not of the\nsimilar USR command.\n\nThis feature allows you to place the necessary preentry values into\nthe registers from BASIC before you SYS to a Kernal or BASIC ML\nroutine.  It also enables you to examine the resulting effect of the\nroutine on the registers, and to preserve the condition of the\nregisters on exit for subsequent SYS calls.\n\nAn extremely practical application comes immediately to mind.\nAlthough the 64's BASIC 2 has many commands for formatting printed\ncharacters on the monitor screen (for example, TAB, SPC, PRINT A$,B),\nthere is none to adjust the vertical cursor position.\n\nThere is a Kernal routine, PLOT (58634, $E50A), which will allow you\nto position the cursor anywhere on the screen.  In order to use it,\nyou must first clear the carry flag (set it to 0), and then place the\ndesired horizontal column number in the .Y register and the vertical\nrow number in the .X register before entering the routine with a SYS\n65520.  Using the register storage area, we can print the work HELLO\nat row 10, column 5 with the following BASIC line:\n\nPOKE 781,10:POKE 782,5:POKE 783,0:SYS 65520:PRINT \"HELLO\"\n\nYou can also use these locations to help you take advantage of Kernal\nroutines that return information in the register.  For example, the\nSCREEN routine (58629,$E505) returns the number of screen rows int he\n.Y register, and the number of columns in the .X register.  Using this\nroutine, a BASIC program could be written to run on machines with\ndifferent screen formats (for example, the 64 and the VIC-20).  Just\nPEEK(781) after a SYS 65517 to see how many screen columns the\ncomputer display has."}, {"id": "map-30C", "address_start": 780, "address_end": 780, "hex_start": "$30C", "hex_end": "$30C", "label": "SAREG", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "780           $30C           SAREG\nStorage Area for .A Register (Accumulator)"}, {"id": "map-30D", "address_start": 781, "address_end": 781, "hex_start": "$30D", "hex_end": "$30D", "label": "SXREG", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "781           $30D           SXREG\nStorage Area for .X Index Register"}]