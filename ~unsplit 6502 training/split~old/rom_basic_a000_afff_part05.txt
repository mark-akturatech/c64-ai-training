
                                *** perform END
.,A831 18       CLC             clear carry
.,A832 D0 3C    BNE $A870       return if wasn't CTRL-C
.,A834 A5 7A    LDA $7A         get BASIC execute pointer low byte
.,A836 A4 7B    LDY $7B         get BASIC execute pointer high byte
.,A838 A6 3A    LDX $3A         get current line number high byte
.,A83A E8       INX             increment it
.,A83B F0 0C    BEQ $A849       branch if was immediate mode
.,A83D 85 3D    STA $3D         save continue pointer low byte
.,A83F 84 3E    STY $3E         save continue pointer high byte
.,A841 A5 39    LDA $39         get current line number low byte
.,A843 A4 3A    LDY $3A         get current line number high byte
.,A845 85 3B    STA $3B         save break line number low byte
.,A847 84 3C    STY $3C         save break line number high byte
.,A849 68       PLA             dump return address low byte
.,A84A 68       PLA             dump return address high byte
.,A84B A9 81    LDA #$81        set [CR][LF]"BREAK" pointer low byte
.,A84D A0 A3    LDY #$A3        set [CR][LF]"BREAK" pointer high byte
.,A84F 90 03    BCC $A854       if was program end skip the print string
.,A851 4C 69 A4 JMP $A469       print string and do warm start
.,A854 4C 86 E3 JMP $E386       do warm start

                                *** perform CONT
.,A857 D0 17    BNE $A870       exit if following byte to allow syntax error
.,A859 A2 1A    LDX #$1A        error code $1A, can't continue error
.,A85B A4 3E    LDY $3E         get continue pointer high byte
.,A85D D0 03    BNE $A862       go do continue if we can
.,A85F 4C 37 A4 JMP $A437       else do error #X then warm start
                                we can continue so ...
.,A862 A5 3D    LDA $3D         get continue pointer low byte
.,A864 85 7A    STA $7A         save BASIC execute pointer low byte
.,A866 84 7B    STY $7B         save BASIC execute pointer high byte
.,A868 A5 3B    LDA $3B         get break line low byte
.,A86A A4 3C    LDY $3C         get break line high byte
.,A86C 85 39    STA $39         set current line number low byte
.,A86E 84 3A    STY $3A         set current line number high byte
.,A870 60       RTS             

                                *** perform RUN
.,A871 08       PHP             save status
.,A872 A9 00    LDA #$00        no control or kernal messages
.,A874 20 90 FF JSR $FF90       control kernal messages
.,A877 28       PLP             restore status
.,A878 D0 03    BNE $A87D       branch if RUN n
.,A87A 4C 59 A6 JMP $A659       reset execution to start, clear variables, flush stack
                                and return
.,A87D 20 60 A6 JSR $A660       go do "CLEAR"
.,A880 4C 97 A8 JMP $A897       get n and do GOTO n

                                *** perform GOSUB
.,A883 A9 03    LDA #$03        need 6 bytes for GOSUB
.,A885 20 FB A3 JSR $A3FB       check room on stack for 2*A bytes
.,A888 A5 7B    LDA $7B         get BASIC execute pointer high byte
.,A88A 48       PHA             save it
.,A88B A5 7A    LDA $7A         get BASIC execute pointer low byte
.,A88D 48       PHA             save it
.,A88E A5 3A    LDA $3A         get current line number high byte
.,A890 48       PHA             save it
.,A891 A5 39    LDA $39         get current line number low byte
.,A893 48       PHA             save it
.,A894 A9 8D    LDA #$8D        token for GOSUB
.,A896 48       PHA             save it
.,A897 20 79 00 JSR $0079       scan memory
.,A89A 20 A0 A8 JSR $A8A0       perform GOTO
.,A89D 4C AE A7 JMP $A7AE       go do interpreter inner loop

                                *** perform GOTO
.,A8A0 20 6B A9 JSR $A96B       get fixed-point number into temporary integer
.,A8A3 20 09 A9 JSR $A909       scan for next BASIC line
.,A8A6 38       SEC             set carry for subtract
.,A8A7 A5 39    LDA $39         get current line number low byte
.,A8A9 E5 14    SBC $14         subtract temporary integer low byte
.,A8AB A5 3A    LDA $3A         get current line number high byte
.,A8AD E5 15    SBC $15         subtract temporary integer high byte
.,A8AF B0 0B    BCS $A8BC       if current line number >= temporary integer, go search
                                from the start of memory
.,A8B1 98       TYA             else copy line index to A
.,A8B2 38       SEC             set carry (+1)
.,A8B3 65 7A    ADC $7A         add BASIC execute pointer low byte
.,A8B5 A6 7B    LDX $7B         get BASIC execute pointer high byte
.,A8B7 90 07    BCC $A8C0       branch if no overflow to high byte
.,A8B9 E8       INX             increment high byte
.,A8BA B0 04    BCS $A8C0       branch always (can never be carry)

                                *** search for line number in temporary integer from start of memory pointer
.,A8BC A5 2B    LDA $2B         get start of memory low byte
.,A8BE A6 2C    LDX $2Cget start of memory high byte

                                *** search for line # in temporary integer from (AX)
.,A8C0 20 17 A6 JSR $A617       search Basic for temp integer line number from AX
.,A8C3 90 1E    BCC $A8E3       if carry clear go do unsdefined statement error
                                carry all ready set for subtract
.,A8C5 A5 5F    LDA $5F         get pointer low byte
.,A8C7 E9 01    SBC #$01        -1
.,A8C9 85 7A    STA $7A         save BASIC execute pointer low byte
.,A8CB A5 60    LDA $60         get pointer high byte
.,A8CD E9 00    SBC #$00        subtract carry
.,A8CF 85 7B    STA $7B         save BASIC execute pointer high byte
.,A8D1 60       RTS             

                                *** perform RETURN
.,A8D2 D0 FD    BNE $A8D1       exit if following token to allow syntax error
.,A8D4 A9 FF    LDA #$FF        set byte so no match possible
.,A8D6 85 4A    STA $4A         save FOR/NEXT variable pointer high byte
.,A8D8 20 8A A3 JSR $A38A       search the stack for FOR or GOSUB activity,
                                get token off stack
.,A8DB 9A       TXScorrect the stack
.,A8DC C9 8D    CMP #$8D        compare with GOSUB token
.,A8DE F0 0B    BEQ $A8EB       if matching GOSUB go continue RETURN
.,A8E0 A2 0C    LDX #$0C        else error code $04, return without gosub error
.:A8E2 2C       .BYTE $2C       makes next line BIT $11A2
.,A8E3 A2 11    LDX #$02        error code $11, undefined statement error
.,A8E5 4C 37 A4 JMP $A437       do error #X then warm start
.,A8E8 4C 08 AF JMP $AF08       do syntax error then warm start
                                was matching GOSUB token
.,A8EB 68       PLA             dump token byte
.,A8EC 68       PLA             pull return line low byte
.,A8ED 85 39    STA $39         save current line number low byte
.,A8EF 68       PLA             pull return line high byte
.,A8F0 85 3A    STA $3A         save current line number high byte
.,A8F2 68       PLA             pull return address low byte
.,A8F3 85 7A    STA $7A         save BASIC execute pointer low byte
.,A8F5 68       PLA             pull return address high byte
.,A8F6 85 7B    STA $7B         save BASIC execute pointer high byte

                                *** perform DATA
.,A8F8 20 06 A9 JSR $A906       scan for next BASIC statement ([:] or [EOL])

                                *** add Y to the BASIC execute pointer
.,A8FB 98       TYA             copy index to A
.,A8FC 18       CLC             clear carry for add
.,A8FD 65 7A    ADC $7A         add BASIC execute pointer low byte
.,A8FF 85 7A    STA $7A         save BASIC execute pointer low byte
.,A901 90 02    BCC $A905       skip increment if no carry
.,A903 E6 7B    INC $7B         else increment BASIC execute pointer high byte
.,A905 60       RTS             

                                *** scan for next BASIC statement ([:] or [EOL])
                                returns Y as index to [:] or [EOL]
.,A906 A2 3A    LDX #$3A        set look for character = ":"
.:A908 2C       .BYTE $2C       makes next line BIT $00A2

                                *** scan for next BASIC line
                                returns Y as index to [EOL]
.,A909 A2 00    LDX #$00        set alternate search character = [EOL]
.,A90B 86 07    STX $07         store alternate search character
.,A90D A0 00    LDY #$00        set search character = [EOL]
.,A90F 84 08    STY $08         save the search character
.,A911 A5 08    LDA $08         get search character
.,A913 A6 07    LDX $07         get alternate search character
.,A915 85 07    STA $07         make search character = alternate search character
.,A917 86 08    STX $08         make alternate search character = search character
.,A919 B1 7A    LDA ($7A),Y     get BASIC byte
.,A91B F0 E8    BEQ $A905       exit if null [EOL]
.,A91D C5 08    CMP $08         compare with search character
.,A91F F0 E4    BEQ $A905       exit if found
.,A921 C8       INY             else increment index
.,A922 C9 22    CMP #$22        compare current character with open quote
.,A924 D0 F3    BNE $A919       if found go swap search character for alternate search
                                character
.,A926 F0 E9    BEQ $A911       loop for next character, branch always

                                *** perform IF
.,A928 20 9E AD JSR $AD9E       evaluate expression
.,A92B 20 79 00 JSR $0079       scan memory
.,A92E C9 89    CMP #$89        compare with "GOTO" token
.,A930 F0 05    BEQ $A937       if it was  the token for GOTO go do IF ... GOTO
                                wasn't IF ... GOTO so must be IF ... THEN
.,A932 A9 A7    LDA #$A7        set "THEN" token
.,A934 20 FF AE JSR $AEFF       scan for CHR$(A), else do syntax error then warm start
.,A937 A5 61    LDA $61         get FAC1 exponent
.,A939 D0 05    BNE $A940       if result was non zero continue execution
                                else REM rest of line

                                *** perform REM
.,A93B 20 09 A9 JSR $A909       scan for next BASIC line
.,A93E F0 BB    BEQ $A8FB       add Y to the BASIC execute pointer and return, branch
                                always
                                result was non zero so do rest of line
.,A940 20 79 00 JSR $0079       scan memory
.,A943 B0 03    BCS $A948       branch if not numeric character, is variable or keyword
.,A945 4C A0 A8 JMP $A8A0       else perform GOTO n
                                is variable or keyword
.,A948 4C ED A7 JMP $A7ED       interpret BASIC code from BASIC execute pointer

                                *** perform ON
.,A94B 20 9E B7 JSR $B79E       get byte parameter
.,A94E 48       PHA             push next character
.,A94F C9 8D    CMP #$8D        compare with GOSUB token
.,A951 F0 04    BEQ $A957       if GOSUB go see if it should be executed
.,A953 C9 89    CMP #$89        compare with GOTO token
.,A955 D0 91    BNE $A8E8       if not GOTO do syntax error then warm start
                                next character was GOTO or GOSUB, see if it should be executed
.,A957 C6 65    DEC $65         decrement the byte value
.,A959 D0 04    BNE $A95F       if not zero go see if another line number exists
.,A95B 68       PLA             pull keyword token
.,A95C 4C EF A7 JMP $A7EF       go execute it
.,A95F 20 73 00 JSR $0073       increment and scan memory
.,A962 20 6B A9 JSR $A96B       get fixed-point number into temporary integer
                                skip this n
.,A965 C9 2C    CMP #$2C        compare next character with ","
.,A967 F0 EE    BEQ $A957       loop if ","
.,A969 68       PLA             else pull keyword token, ran out of options
.,A96A 60       RTS             

                                *** get fixed-point number into temporary integer
.,A96B A2 00    LDX #$00        clear X
.,A96D 86 14    STX $14         clear temporary integer low byte
.,A96F 86 15    STX $15         clear temporary integer high byte
.,A971 B0 F7    BCS $A96A       return if carry set, end of scan, character was not 0-9
.,A973 E9 2F    SBC #$2F        subtract $30, $2F+carry, from byte
.,A975 85 07    STA $07         store #
.,A977 A5 15    LDA $15         get temporary integer high byte
.,A979 85 22    STA $22         save it for now
.,A97B C9 19    CMP #$19        compare with $19
.,A97D B0 D4    BCS $A953       branch if >= this makes the maximum line number 63999
                                because the next bit does $1900 * $0A = $FA00 = 64000
                                decimal. the branch target is really the SYNTAX error
                                at $A8E8 but that is too far so an intermediate
                                compare and branch to that location is used. the problem
                                with this is that line number that gives a partial result
                                from $8900 to $89FF, 35072x to 35327x, will pass the new
                                target compare and will try to execute the remainder of
                                the ON n GOTO/GOSUB. a solution to this is to copy the
                                byte in A before the branch to X and then branch to
                                $A955 skipping the second compare
.,A97F A5 14    LDA $14         get temporary integer low byte
.,A981 0A       ASL             *2 low byte
.,A982 26 22    ROL $22         *2 high byte
.,A984 0A       ASL             *2 low byte
.,A985 26 22    ROL $22         *2 high byte (*4)
.,A987 65 14    ADC $14         + low byte (*5)
.,A989 85 14    STA $14         save it
.,A98B A5 22    LDA $22         get high byte temp
.,A98D 65 15    ADC $15         + high byte (*5)
.,A98F 85 15    STA $15         save it
.,A991 06 14    ASL $14         *2 low byte (*10d)
.,A993 26 15    ROL $15         *2 high byte (*10d)
.,A995 A5 14    LDA $14         get low byte
.,A997 65 07    ADC $07         add #
.,A999 85 14    STA $14         save low byte
.,A99B 90 02    BCC $A99F       branch if no overflow to high byte
.,A99D E6 15    INC $15         else increment high byte
.,A99F 20 73 00 JSR $0073       increment and scan memory
.,A9A2 4C 71 A9 JMP $A971       loop for next character
