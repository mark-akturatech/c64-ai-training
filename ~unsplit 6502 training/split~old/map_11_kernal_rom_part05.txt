64096         $FA60
Receive and Store the Next Character from Cassette

This is the part of the cassette read IRQ routine that actually gets
the next byte of data from the cassette.

64398         $FB8E
Move the Tape SAVE/LOAD Address into the Pointer at 172

64407         $FB97
Reset Counters for Reading or Writing a New Byte of Cassette Data

64422         $FBA6
Toggle the Tape Data Output Line

This routine sets the CIA #1 Timer B, and toggles the Tape Data Output
line on the 6510 on-chip I/O port (Bit 3 of location 1).

64456         $FBC8
Write Data to Cassette--Part 2 (IRQ)

This IRQ handler routine is one part of the write data to cassette
routine

64618         $FC6A
Write Data fo Cassette--Part 1 (IRQ)

This IRQ handler routine is the other part of the write data to
cassette routine.

64659         $FC93
Restores the Default IRQ Routine

At the end of the tape I/O operations, this subroutine is used to turn
the screen back on and stop the cassette motor.  It then resets the
CIA #1 Timer A to generate an interrupt every sixtieth of a second,
and restores the IRQ vector to point to the normal interrupt routine
that updates the software clock and scans the keyboard.

64696         $FCB8
Terminate Cassette I/O

This routine calls the subroutine above and returns from the
interrupt.

64714         $FCCA
Turn Off the Tape Motor

64721         $FCD1
Check the Tape Read/Write Pointer

This routine compares the current tape read/write address with the
ending read/write address.

64731         $FCDB
Advance the Tape Read/Write Pointer

This routine is used to move the pointer to the current read/write
address up a byte.

64738         $FCE2
Power-On Reset Routine

This is the RESET routine which is pointed to by the 6510 hardware
RESET vector at 65532 ($FFFC).

This routine is automatically executed when the computer is first
turned on.  First, it sets the Interrupt disable flag, sets the stack
pointer, and clears the Decimal mode flag.  Next, it tests for an
autostart cartridge.  If one is found, the routine immediately jumps
through the cartridge cold start vector at 32768 ($8000).  If no
cartridge is found, the Kernal initialization routines IOINIT, RAMTAS,
RESTOR, and CINT are called, the Interrupt disable flag is cleared,
and the BASIC program is entered through the cold start vector at
40960 ($A000).

64770         $FD02
Check for an Autostart Cartridge

This routine tests for an autostart cartridge by comparing the
characters at location 32772-6 ($8004-8) to the text below.  The Zero
flag will be set if they match, and cleared if they don't.

64784         $FD10
Text for Autostart Cartridge Check

The characters stored here must be the fifth through the ninth
characters in the cartridge in order for it to be started on power-up.
These characters are the PETASCII values for CBM, each with the high
bit set (+128), and the characters "80".

64789         $FD15          RESTOR
Restore RAM Vectors for Default I/O Routines

This documented Kernal routine can be entered through the jump table
at 65418 ($FF8A).

It sets the values for the 16 RAM vectors to the interrupt and
important Kernal I/O routines in the table that starts at 788 ($314)
to the standard values held in the ROM table at 64816 ($FD30).

64794         $FD1A          VECTOR
Set the RAM Vector Table from the Table Pointed to by .X and .Y

This documented Kernal routine can be entered through the jump table
at 65421 ($FF8D).

It is used to read or change the values for the 16 RAM vectors to the
interrupt and important Kernal I/O routines in the table that starts
at 788 ($314).  If the Carry flag is set when the routine is called,
the current value of the 16 vectors will be stored at a table whose
address is pointed to by the values in the .X and .Y registers.  If
the Carry flag is cleared, the RAM vectors will be loaded from the
table whose address is pointed to by the .X and .Y registers.  Since
this routine can change the vectors for the IRQ and NMI interrupts,
you might expect that the Interrupt disable flag would be set at its
beginning.  Such is not the case, however, and therefore it would be
wise to execute an SEI before calling it and a CLI afterwards (as the
power-on RESET routine does) just to be safe.

64816         $FD30
Table of RAM Vectors to the Default I/O Routines

This table contains the 16 RAM I/O vectors that are moved to 788-819
($314-$333).

64848         $FD50          RAMTAS
Perform RAM Test and Set Pointers to the Top and Bottom of RAM

This documented Kernal routine, which can be entered through location
65415 ($FF87) of the jump table, performs a number of initialization
tasks.

First, it clears Pages 0, 2, and 3 of memory to zeros.  Next, it sets
the tape buffer pointer to address 828 ($33C), and performs a
nondestructive test of RAM from 1024 ($400) up.  When it reaches a
non-RAM address (presumably the BASIC ROM at 40960 ($A000)), that
address is placed in the top of memory pointer at 643-4 ($283-4).  The
bottom of memory pointer at 641-2 ($281-2) is set to point to address
2048 ($800), which is the beginning of BASIC program text.  Finally,
the pointer to screen memory at 648 ($288) is set to 4, which lets the
Operating System know that screen memory starts at 1024 ($400).

64923         $FD9B
Table of IRQ Vectors

This table holds the vectors to the four IRQ routines which the system
uses.  The first points to Part 1 of the cassette write routine at
64618 ($FC6A), the second to Part 2 of the cassette write routine at
64461 ($FBCD), the third to the standard scan keyboard IRQ at 59953
($EA31), and the last to the cassette read routine at 63788 ($F92C).

64931         $FDA3          IOINIT
Initialize CIA I/O Devices

This documented Kernal routine, which can be entered through the jump
table at 65412 ($FF84), intializes the Complex Interface Adapter (CIA)
devices, and turns the volume of the SID chip off.  As part of this
initialization, it sets CIA #1 Timer A to cause an IRQ interrupt every
sixtieth of a second.

65017         $FDF9          SETNAM
Set Filename Parameters

This is a documented Kernal routine, which can be entered through the
jump table at location 65469 ($FFBD).

It puts the value in the Accumulator into the location which stores
the number of characters in the filename, and sets the pointer to the
address of the ASCII text of the filename from the .X and .Y
registers.  This sets up the filename for the OPEN, LOAD, or SAVE
routine.

65024         $FE00          SETLFS
Set Logical File Number, Device Number, and Secondary Address

This is a documented Kernal routine, which can be entered through the
jump table at location 65466 ($FFBA).

It stores the value in the Accumulator in the location which holds the
current logical file number, the value in the .X register is put in
the location that holds the current device number, and the value in
the .Y register is stored in the location that holds the current
secondary address.  If no secondary address is used, the .Y register
should be set to 255 ($FF).  It is necessary to set the values of the
current file number, device number, and secondary address before you
OPEN a file, or LOAD or SAVE.

65031         $FE07          READST
Read the I/O Status Word

This is a documented Kernal routine, which can be entered through the
jump table at location 65463 ($FFB7).

Whenever an I/O error occurs, a bit of the Status Word is set to
indicate what the problem was.  The routine allows you to read the
status word (it is returned in the Accumulator).  If the device was
the RS-232, its status register is read and cleared to zero.  For the
meanings of the various status codes, see the entry for location 144
($90) or 663 ($297) for the RS-232 device.

65048         $FE18          SETMSG
Set the Message Control Flag

This documented Kernal routine can be entered through its jump table
vector at 65424 ($FF90).

The routine controls the printing of error messages and control
messages by the Kernal.  It Bit 6 is seto to 1 (bit value of 64),
Kernal control messages can be printed.  These messages include
SEARCHING FOR, LOADING, and the like.  If Bit 6 is cleared to 0, these
messages will not be printed (BASIC will clear this bit when a program
is running so that the messages do not appear when I/O is performed
from a program).  Setting Bit 6 will not suppress the PRESS PLAY ON
TAPE or PRESS PLAY & RECORD messages, however.

If Bit 7 is set to 1 (bit value of 128), Kernal error messages can be
printed.  If Bit 7 is set to 0, those error messages (for example, I/O
ERROR #nn) will be suppressed.  Note that BASIC has its own set of
error messages (such as FILE NOT FOUND ERROR) which it uses in
preference to the Kernal's message.

65057         $E21           SETTMO
Set Time-Out Flag for IEEE Bus

This documented Kernal routine can be entered fromthe jump table at
65442 ($FFA2).

The routine sets the time-out flag for the IEEE bus.  When timeouts
are enabled, the Commodore will wait for a device for 64 milliseconds,
and if it does not receive a response to its signal it will issue a
time-out error.  Loading the Accumulator with a value less than 128
and calling this routine will enable time-outs, while using a value
over 128 will disable time-outs.

This routine is for use only with the Commodore IEEE add-on card,
which at the time of this writing was not yet available.

65061         $FE25          MEMTOP
Read/Set Top of RAM Pointer

This is a documented Kernal routine, which can be entered through the
jump table at location 65433 ($FF99).

It can be used to either read or set the top of RAM pointer.  If
called with the Carry flag set, the address in the pointer will be
loaded into the .X and .Y registers.  If called with the Carry flag
cleared, the pointer will be changed to the address found in the .X
and .Y registers.

65076         $FE34          MEMBOT
Read/Set Bottom of RAM Pointer

This is a documented Kernal routine, which can be entered through the
jump table at location 65436 ($FF9C).

It can be used to either read or set the bottom of RAM pointer.  If
called with the Carry flag set, the address in the pointer willbe
loaded into the .X and .Y registers.  If called with the Carry flag
cleared, the pointer will be changed to the address found in the .X
and .Y registers.

65091         $FE43
NMI Interrupt Entry Point

This routine is the NMI interrupt handler entry, which is pointed to
by the hardware NMI vector at 65530 ($FFFA).

Any time an NMI interrupt occurs, the Interrupt disable flag will be
set, and the routine will jump through the RAM vector at 792 ($318),
which ordinarily points to the continuation of this routine.  The
standard handler first checks to see if the NMI was caused by the
RS-232 device.  If not, the RESTORE key is assumed.  The routine
checks for a cartridge, and if one is found it exits through the
cartridge warm start vector at 32770 ($8002).  If not, the STOP key is
checked, and if it is being pressed, the BRK routine is executed.  If
the RS-232 device was the cause of the NMI, the cartridge and STOP key
checks are bypassed, and the routine skips to the end, where it checks
whether it is time to send or receive a data bit via the RS-232
device.

65126         $FE66
BRK, Warm Start Routine

This routine is executed when the STOP/RESTORE combination of
keypresses occurs.  In addition, it is the default target address of
the BRK instruction vector.  This routine calls the Kernal
intialization routines RESTOR, IOINIT, and part of CINT.  It then
exits through the BASIC warm start vector at 40962 ($A002).

65138         $FE72
NMI RS-232 Handler

This is the part of the NMI handler that checks if it is time to
receive or send a bit on the RS-232 channel, and takes the appropriate
action if it is indeed the time.

65218         $FEC2
RS-232 Baud Rate Tables for U.S. Television Standard (NTSC)

This table contains the ten prescaler values for the ten standard baud
rates implemented by the RS-232 Control Register at 659 ($293).  The
table starts with the two values needed for the lowest baud rate (50
baud) and finishes with the entries for the highest baud rate, 2400
baud.  The RS-232 routines are handled by NMI interrupts which are
caused by the timers on CIA #2.  Since the RS-232 device could both
receive and send a bit in a single cycle, the time between interrupts
should be a little less than half of the clock frequency divided by
the baud rate.  The exact formula used is:

((CLOCK/BAUD)/2)-100

where CLOCK is the processor clock speed and BAUD is the baud rate.
The clock frequency for machines using the U.S. television standard
(NTSC) is 1,022,730 cycles per second, while the frequency for the
European (PAL) standard is 985,250 cycles per second.  For this
reason, separate baud rate tables were added for European machines at
58604 ($E4EC).

65238         $FED6
RS-232 Receive the Next Bit (NMI)

The NMI handler calls this subroutine to input the next bit on the
RS-232 bus.  It then calls the next subroutine to reload the timer
that causes the interrupts.

65306         $FF1A
Load the Timer with Prescaler Values from the Baud Rate Lookup Table

65352         $FF48
Main IRQ/BRK Interrupt Entry Point

The 6510 hardware IRQ/BRK vector at 65534 ($FFFE) points to this
address.

Anytime the BRK instruction is encountered or an IRQ interrupt occurs,
this routine will be executed.  The routine first saves the .A, .X,
and .Y registers on the stack, and then tests the BRK bit of the
status register (.P) to see if a BRK was executed.  If it was, the
routine exits through the RAM BRK vector at 790 ($316), where it will
usually be directed to the BRK routine at 65126 ($FE66).  If not, the
routine exits through the RAM IRQ vector at 788 ($314), where it will
usually be directed to the handler that scans the keyboard at 59953
($EA31).

If you plan to change either of these vectors to your own routine,
remember to pull the stored register values off the stack before
finishing.

Location Range: 65371-65407 ($FF5B-$FF7F)
Patches Added to Later Kernal Versions

This area contains additional code not found in the original version
of the Kernal.  It is used to test whether a European (PAL) or U.S.
(NTSC) standard monitor is used, and to compensate so that the
sixtieth of a second interrupt will be accurately timed on either
system.

