44446         $AD9E          FRMEVAL
Evaluate Expression

This is the beginning point of a very powerful group of subroutines
which are used extensively by BASIC.

The main purpose of these routines is to read in the ASCII text of
BASIC expressions, separate the operators and terms of the expression,
check them for errors, combine the individual terms by performing the
indicated operations, and obtain a single value which the BASIC
program can use.

This can be a very complex task, and expressions an be of the string
or numeric type, and can contain any type of variable, as well as
constants.

At the end, the flag which shows whether the resulting value is string
or numeric at 13 ($D) is set, and if the value is numeric, the flag at
14 ($E) is set as well, to show if it is an integer or floating point
numer.

44675         $AE83          EVAL
Convert a Single Numeric Term from ASCII Text to a Floating Point
Number

This routine reduces a single arithmetic term which is part of an
expression from ASCII text to its floating point equivalent.

If the term is a constant, the routine sets the data type flag to
number, sets the text pointer to the first ASCII numeric character,
and jumps to the routine which converts the ASCII string to a floating
point number.

If the term is a variable, the variable value is retrieved.  If it is
the PI character, the value of PI is moved into the Floating Point
Accumulator.

This routine is vectored through RAM at 778 ($30A).

44712         $AEA8          PIVAL
PI Expressed as a Five-Byte Floating Point Number

The value of PI is stored here as a five-byte floating point number.

44785         $AEF1          PARCHK
Evaluate Expression Within Parentheses

This routine evaluates an expression within parentheses by calling the
syntax checking routines that look for opening and closing
parentheses, and then calling FRMEVL (4446, $AD9E) for each level of
parentheses.

44791         $AEF7          CHKCLS
Check for and Skip Closing Parentheses

44794         $AEFA          CHKOPN
Check for and Skip Opening Parentheses

44799         $AEFF          CHKCOM
Check for and Skip Comma

This syntax checking device is the same in substance as the two
checking routines above.  It is used when the next character should be
a comma.  If it is not, a SYNTAX ERROR retults.  If it is, the
character is skipped and the next character is read.  Any character
can be checked for and skipped this way by loading the character into
the Accumulator and entering this routine from SYNCHR at 44799
($AEFF).

44808         $AF08          SNERR
Print Syntax Error Message

44843         $AF2B          ISVAR
Get the Value of a Variable

44967         $AFA7          ISFUN
Dispatch and Evaluate a Function

If a BASIC function (like ASC("A")) is part of an expression, this
routine will use the function dispatch table at 42242 ($A502) to set
up the address of th proper function routine, and then branch to that
routine.

45030         $AFE6          OROP
Perform OR

The OR routine sets the .Y register as a flag, and falls through to
the AND routine, which also performs OR.

45033         $AFE9          ANDOP
Perform AND

The AND routine changes the parameters to two-byte integer values, and
performs the appropriate logical operation (AND or OR).  A result of 0
signifies false, while a result of -1 signifies true.

45078         $B016          DORE1
Perform Comparisons

This routine does the greater than (>), less than (<), and equal (=)
comparisons for foating point numbers and strings.  The result in the
Floating Point Accumulator will be 0 if the comparison is false, and
-1 if it is true.

45185         $B018          DIM
Perform DIM

This command calls the next routine to create an array for every
variable dimensioned (since a statement can take the form DIM A(12),
B(13), C(14)...).  If the array element is referenced before a DIM
statement (for example, A(3)=4), the array will be dimensioned to 10
(as if DIM A(10) were executed).  Remember, DIMensioning an array to
10 really creates 11 elements (10).  The 0 element should always be
considered in calculating the size to DIMension your array.

45195         $B08B          PTRGET
Search for a Variable and Set It Up If It Is Not Found

This routine attempts to locate a variable by searching for its name
in the variable area.  If an existing variable of that name cannot be
found, one is created with the NOTFNS routine below.

45331         $B113
Check If .A Register Holds Alphabetic ASCII Character

This is part of the check for a valid variable name (it must start
with an alphabetic character).

45341         $B11D          NOTFNS
Create a New BASIC Variable

This routine makes space for a seven-byte descriptor by moving the
variable storage area seven bytes higher in memory, and then creates
the descriptor.

45445         $B185          FINPTR
Return the Address of the Variable That Was Found or Created

This routine stores the address of the variable that was found or
created by the preceding routines in a pointer at 71-72 ($47-$48).

45460         $B194          ARYGET
Allocate Space for Array Descriptors

This routine allocates five bytes plus two bytes for every dimension
specified for the array descriptor.

45477         $B1A5          N32768
The Constant -32768 in Five-Byte Floating Point Format

This constant is used for range checking in the conversion of a
floating point number to a signed integer (the minimum inter value is
-32768).

45482         $B1AA
Convert a Floating Point Number to a Signed Integer in .A and .Y Registers

This subroutine calls AYINT, below, which checks to make sure that the
number in the Floating Point Accumulator is between 32767 and -32768,
and converts it to a 16-bit signed integer in 100-101 ($64-$65), high
byte first.  It leaves the high byte of the integer in the
Accumulator, and the low byte in the .Y register.

Although this routine does not appear to be referenced anywhere in
BASIC, the vector at locations 3-4 points to its address.  Presumably,
it is provided for the benefit of the user who wishes to pass
parameters in a USR call, or the like.

45490         $B1B2          INTIDX
Input and Convert a Floating Point Subscript to a Positive Integer

This routine converts a floating point subscript value to an integer,
making sure first that it is positive.

45503         $B1BF          AYINT
Convert a Floating Point Number to a Signed Integer

This subroutine first checks to make sure that the number in the
Floating Point Accumulator is between 32767 and -32768.  If it is not,
an ILLEGAL QUANTITY error results.  If it is, the routine converts it
to a 16-bit signed integer with the high byte in location 100 ($64),
and the low byte in location 101 ($65).

45521         $B1D1          ISARY
Find Array Element or Create New Array in RAM

This routine searches for an array.  If it is found, the subscript
value is checked to see if it is valid, and pointers to the array and
element of the array are set.  If it is not found, the array is
created, and the pointers set.

45637         $B245          BSERR
Print BAD SUBSCRIPT Error Message

45640         $B248          FCERR
Print ILLEGAL QUANTITY Error Message

45900         $B34C          UMULT
Compute the Size of a Multidimensional Array

This routine calculates the size of a multidimensional array by
multiplying the dimensions.

45949         $B37D          FRE
Perform FRE

The FRE function calls the garbage collection routine at 46374 ($B526)
to get rid of unused string text, and calculates the difference
between the bottom of string text and the top of array storage.  It
then drops through to the follow routine, which assumes that the free
memory value is a 16-bit signed integer, and converts it to floating
point accordingly.

Of course, while the free memory space on the PET might have always
been 32767 or less (the maximum value of a signed integer), sich is
definitely not the case on the 64.  Because conversion is from a
signed integer, any memory value over 32767 will be regarded as
negative (the high bit is treated as a sign bit).  Therefore, for
these higher values you must add twice the bit value of the high bit
(65536) in order to come up with the correct value.  The expression
FRE(0)-6556*(FRE(0)<0) will always return the correct amount of free
memory.

45969         $B391          GIVAYF
Convert 16-Bit Signed Integer to Floating Point

This routine treats the value in the Accumulator as the high byte of a
16-bit signed integer, and the value in the .Y register as the low
byte, and converts the signed integer into a floating point number in
the Floating Point Accumulator.

The address of this routine is pointed to by the RAM vector at 5-6,
and the routine can be used to return an argument from the USR call in
the Floating Point Accumulator.

45982         $B39E          POS
Perform POS

The POS command calls the Kernal PLOT routine (58634, $E50A) to get
the position of the cursor on the logical line.  What it really does
is an equivalent of PEEK(211).  Remember, since we are dealing with a
logical line, this number can be over 39.  The statement "THIS
SENTENCE IS LONGER THAN ONE PHYSICAL LINE";POS(X) will return a value
of 48 for the POS(X).

45990         $B3A6          ERRDIR
Check If the Program is Running in Direct Mode, and If So Issue an Error

This routine is called by statements that prohibit execution in direct
mode.  It checks a flag that is set when a line without a linenumber
is entered, and causes an ILLEGAL DIRECT error if the flag is set.

46003         $B3B3          DEF
Perform DEF

DEF performs some syntax checking, and pushes five bytes onto the
stack:  the first byte of the function statement, a two-byte pointer
to the dependent variable (the X in FN(X)), and the address of the
first character of the definition itself, where it resides in the
program text.

The DEF statement must fit on one line, but functions can be extended
by nesting them (having one function call another).

46049         $B3E1          GETFNM
Check DEF and FN Syntax

This routine checks to make sure that FN follow SEG, and that the
dependent variable has a valid floating point variable name.  It calls
the routine to find or create a variable to get the pointer to its
address.

46068         $B3F4          FNDOER
Perform FN

The FN evaluation is done by evaluating the FN argument (for example,
FN(A+B*C/D)) and then getting the rest of the expression from the text
of the function definition statement.  The function variable
descriptor area is used as a work area, and the dependent variable is
not disturbed (so that if the definition used FN(X), the value of X
will not be changed by the function call).

46181         $B465          STRD
Perform STR$

STR$ first checks to make sure that the parameter is a number, and
then calls the routines that convert floating point to ASCII and crate
the pointers to a string constant.

46215         $B487          STRLIT
Scan and Set Up Pointers to a String in Memory

This routine calculates the length of the string, and calls the
routine that allocates space in memory.  It then saves the string, or
creates a pointer to its location in the BASIC text input buffer at
512 ($200).

46324         $B4F4          GETSPA
Allocate Space in Memory for String

The amount of space needed for a string is passed to this routine, and
the routine checks if there is that amount of space available in free
memory.  If not, it does a garbage collection and tries again.

46374         $B526          GARBAG
String Garbage Collection

Whenever a string is changed in any way, the revised version of the
text is added to the bottom of the string text area, leaving the old
version higher up in memory, wasting space.

In order to reclaim that space, the descriptor for every string whose
text is in the string text area (rather than in the program text area)
must be searched to find the valid text that is highest in memory.  If
that string is not as high as it could be, it is moved up to replace
any string that is no longer valid.  Then all of the string
descriptors must be searched again to find the next highest string and
move it up.  This continues until every string that is un use has been
covered.  After all have been moved up, the pointer to the bottom of
string text at 51-52 ($33-$34) is changed to show the new bottom
location.

If there are more than a few strings whose text is in the string text
storage area, rather than in the body of the program, scanning every
string as many times as there are strings can take an awful lot of
time.  The computer may seem as if it had died (the STOP key is not
even checked during the procedure).

The collection will take about as long whether there is any spare
space or not; the full collection will be done even if it is done
immediately after the last collection.  Although the increased memory
capacity of the 64 helps to forestall the need for garbage collection,
a large program with many string arrays may still experience lengthy
collection delays.

46525         $B5BD
Check for Most Eligible String to Collect

This part of the garbage collection routine checks to see if the
current string is the highest in memory.

46598         $B606
Collect a String

This part of the garbage collection routine moves the string to high
memory and updates the descriptor to point to its new location.

46653         $B63D          CAT
Concatenate Two Strings

This routine is used to add the text of one string onto the end of
another (A$+B$).  Error checking is done to see if the length of the
combined string is within range, the allocation routine is called to
allocate space, and the new string is built at the bottom of the
string text area.

46714         $B67A          MOVINS
Move a String in Memory

This is the routine which is used to move a string to the bottom of
the string text area for the above routine.  It is generally used as a
utility routine to move strings.

46755         $B6A3          FRESTR
Discard a Temporary String

This routine calls the following routine which clears an entry from
the temporary descriptor stack.  If the descriptor was on the stack,
it exits after setting pointers to the string and its length.  If it
wasn't on the temporary stack and is at the bottom of string text
storage, the pointer to the bottom is moved up to deallocate the
string.

46811         $B6DB          FRETMS
Remove an Entry from the String Descriptor Stack

If the descriptor of a currently valid string is the same as one of
the entries on the temporary string descriptor stack, the stack entry
is removed.

46828         $B6EC          CHRD
Perform CHR$

The CHR$ routine creates a descriptor on the temporary string stack
for the one-byte string whose value is specified in the command, and
sets a pointer to that string.

