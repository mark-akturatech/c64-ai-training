
                                *** initialise BASIC RAM locations
.,E3BF A9 4C    LDA #$4C        opcode for JMP
.,E3C1 85 54    STA $54         save for functions vector jump
.,E3C3 8D 10 03 STA $0310       save for USR() vector jump
                                set USR() vector to illegal quantity error
.,E3C6 A9 48    LDA #$48        set USR() vector low byte
.,E3C8 A0 B2    LDY #$B2        set USR() vector high byte
.,E3CA 8D 11 03 STA $0311       save USR() vector low byte
.,E3CD 8C 12 03 STY $0312       save USR() vector high byte
.,E3D0 A9 91    LDA #$91        set fixed to float vector low byte
.,E3D2 A0 B3    LDY #$B3        set fixed to float vector high byte
.,E3D4 85 05    STA $05         save fixed to float vector low byte
.,E3D6 84 06    STY $06         save fixed to float vector high byte
.,E3D8 A9 AA    LDA #$AA        set float to fixed vector low byte
.,E3DA A0 B1    LDY #$B1        set float to fixed vector high byte
.,E3DC 85 03    STA $03         save float to fixed vector low byte
.,E3DE 84 04    STY $04         save float to fixed vector high byte
                                copy the character get subroutine from $E3A2 to $0074
.,E3E0 A2 1C    LDX #$1C        set the byte count
.,E3E2 BD A2 E3 LDA $E3A2,X     get a byte from the table
.,E3E5 95 73    STA $73,X       save the byte in page zero
.,E3E7 CA       DEX             decrement the count
.,E3E8 10 F8    BPL $E3E2       loop if not all done
                                clear descriptors, strings, program area and mamory pointers
.,E3EA A9 03    LDA #$03        set the step size, collecting descriptors
.,E3EC 85 53    STA $53         save the garbage collection step size
.,E3EE A9 00    LDA #$00        clear A
.,E3F0 85 68    STA $68         clear FAC1 overflow byte
.,E3F2 85 13    STA $13         clear the current I/O channel, flag default
.,E3F4 85 18    STA $18         clear the current descriptor stack item pointer high byte
.,E3F6 A2 01    LDX #$01        set X
.,E3F8 8E FD 01 STX $01FD       set the chain link pointer low byte
.,E3FB 8E FC 01 STX $01FC       set the chain link pointer high byte
.,E3FE A2 19    LDX #$19        initial the value for descriptor stack
.,E400 86 16    STX $16         set descriptor stack pointer
.,E402 38       SEC             set Cb = 1 to read the bottom of memory
.,E403 20 9C FF JSR $FF9C       read/set the bottom of memory
.,E406 86 2B    STX $2B         save the start of memory low byte
.,E408 84 2C    STY $2C         save the start of memory high byte
.,E40A 38       SEC             set Cb = 1 to read the top of memory
.,E40B 20 99 FF JSR $FF99       read/set the top of memory
.,E40E 86 37    STX $37         save the end of memory low byte
.,E410 84 38    STY $38         save the end of memory high byte
.,E412 86 33    STX $33         set the bottom of string space low byte
.,E414 84 34    STY $34         set the bottom of string space high byte
.,E416 A0 00    LDY #$00        clear the index
.,E418 98       TYA             clear the A
.,E419 91 2B    STA ($2B),Y     clear the the first byte of memory
.,E41B E6 2B    INC $2B         increment the start of memory low byte
.,E41D D0 02    BNE $E421       if no rollover skip the high byte increment
.,E41F E6 2C    INC $2C         increment start of memory high byte
.,E421 60       RTS             

                                *** print the start up message and initialise the memory pointers
.,E422 A5 2B    LDA $2B         get the start of memory low byte
.,E424 A4 2C    LDY $2C         get the start of memory high byte
.,E426 20 08 A4 JSR $A408       check available memory, do out of memory error if no room
.,E429 A9 73    LDA #$73        set "**** COMMODORE 64 BASIC V2 ****" pointer low byte
.,E42B A0 E4    LDY #$E4        set "**** COMMODORE 64 BASIC V2 ****" pointer high byte
.,E42D 20 1E AB JSR $AB1E       print a null terminated string
.,E430 A5 37    LDA $37         get the end of memory low byte
.,E432 38       SEC             set carry for subtract
.,E433 E5 2B    SBC $2B         subtract the start of memory low byte
.,E435 AA       TAX             copy the result to X
.,E436 A5 38    LDA $38         get the end of memory high byte
.,E438 E5 2C    SBC $2C         subtract the start of memory high byte
.,E43A 20 CD BD JSR $BDCD       print XA as unsigned integer
.,E43D A9 60    LDA #$60        set " BYTES FREE" pointer low byte
.,E43F A0 E4    LDY #$E4        set " BYTES FREE" pointer high byte
.,E441 20 1E AB JSR $AB1E       print a null terminated string
.,E444 4C 44 A6 JMP $A644       do NEW, CLEAR, RESTORE and return

                                *** BASIC vectors, these are copied to RAM from $0300 onwards
.:E447 8B E3                    error message          $0300
.:E449 83 A4                    BASIC warm start       $0302
.:E44B 7C A5                    crunch BASIC tokens    $0304
.:E44D 1A A7                    uncrunch BASIC tokens  $0306
.:E44F E4 A7                    start new BASIC code   $0308
.:E451 86 AE                    get arithmetic element $030A

                                *** initialise the BASIC vectors
.,E453 A2 0B    LDX #$0B        set byte count
.,E455 BD 47 E4 LDA $E447,X     get byte from table
.,E458 9D 00 03 STA $0300,X     save byte to RAM
.,E45B CA       DEX             decrement index
.,E45C 10 F7    BPL $E455       loop if more to do
.,E45E 60       RTS             

                                *** BASIC startup messages
.:E45F 00 20 42 41 53 49 43 20  basic bytes free
.:E467 42 59 54 45 53 20 46 52
.:E46F 45 45 0D 00 93 0D 20 20
.:E473 93 0D 20 20 20 20 2A 2A  (clr) **** commodore 64 basic v2 ****
.:E47B 2A 2A 20 43 4F 4D 4D 4F  (cr) (cr) 64k ram system
.:E483 44 4F 52 45 20 36 34 20
.:E48B 42 41 53 49 43 20 56 32
.:E493 20 2A 2A 2A 2A 0D 0D 20
.:E49B 36 34 4B 20 52 41 4D 20
.:E4A3 53 59 53 54 45 4D 20 20
.:E4AB 00

                                *** unused
.:E4AC 5C

                                *** open channel for output
.,E4AD 48       PHA             save the flag byte
.,E4AE 20 C9 FF JSR $FFC9       open channel for output
.,E4B1 AA       TAX             copy the returned flag byte
.,E4B2 68       PLA             restore the alling flag byte
.,E4B3 90 01    BCC $E4B6       if there is no error skip copying the error flag
.,E4B5 8A       TXA             else copy the error flag
.,E4B6 60       RTS             

                                *** unused bytes
.:E4B7 AA AA AA AA AA AA AA AA
.:E4BF AA AA AA AA AA AA AA AA
.:E4C7 AA AA AA AA AA AA AA AA
.:E4CF AA AA AA AA AA

                                *** flag the RS232 start bit and set the parity
.,E4D3 85 A9    STA $A9         save the start bit check flag, set start bit received
.,E4D5 A9 01    LDA #$01        set the initial parity state
.,E4D7 85 AB    STA $AB         save the receiver parity bit
.,E4D9 60       RTS

                                *** save the current colour to the colour RAM
.,E4DA AD 21 D0 LDA $D021       get the current colour code
.,E4DD 91 F3    STA ($F3),Y     save it to the colour RAM
.,E4DF 60       RTS             

                                *** wait ~8.5 seconds for any key from the STOP key column
.,E4E0 69 02    ADC #$02        set the number of jiffies to wait
.,E4E2 A4 91    LDY $91         read the stop key column
.,E4E4 C8       INY             test for $FF, no keys pressed
.,E4E5 D0 04    BNE $E4EB       if any keys were pressed just exit
.,E4E7 C5 A1    CMP $A1         compare the wait time with the jiffy clock mid byte
.,E4E9 D0 F7    BNE $E4E2       if not there yet go wait some more
.,E4EB 60       RTS             

                                *** baud rate tables for PAL C64
                                baud rate word is calculated from ..
                                
                                (system clock / baud rate) / 2 - 100
                                
                                    system clock
                                    ------------
                                PAL       985248 Hz
                                NTSC     1022727 Hz
.:E4EC 19 26                      50   baud   985300
.:E4EE 44 19                      75   baud   985200
.:E4F0 1A 11                     110   baud   985160
.:E4F2 E8 0D                     134.5 baud   984540
.:E4F4 70 0C                     150   baud   985200
.:E4F6 06 06                     300   baud   985200
.:E4F8 D1 02                     600   baud   985200
.:E4FA 37 01                    1200   baud   986400
.:E4FC AE 00                    1800   baud   986400
.:E4FE 69 00                    2400   baud   984000

                                *** return the base address of the I/O devices
.,E500 A2 00    LDX #$00        get the I/O base address low byte
.,E502 A0 DC    LDY #$DC        get the I/O base address high byte
.,E504 60       RTS             

                                *** return the x,y organization of the screen
.,E505 A2 28    LDX #$28        get the x size
.,E507 A0 19    LDY #$19        get the y size
.,E509 60       RTS             

                                *** read/set the x,y cursor position
.,E50A B0 07    BCS $E513       if read cursor go do read
.,E50C 86 D6    STX $D6         save the cursor row
.,E50E 84 D3    STY $D3         save the cursor column
.,E510 20 6C E5 JSR $E56C       set the screen pointers for the cursor row, column
.,E513 A6 D6    LDX $D6         get the cursor row
.,E515 A4 D3    LDY $D3         get the cursor column
.,E517 60       RTS             

                                *** initialise the screen and keyboard
.,E518 20 A0 E5 JSR $E5A0       initialise the vic chip
.,E51B A9 00    LDA #$00        clear A
.,E51D 8D 91 02 STA $0291       clear the shift mode switch
.,E520 85 CF    STA $CF         clear the cursor blink phase
.,E522 A9 48    LDA #$48        get the keyboard decode logic pointer low byte
.,E524 8D 8F 02 STA $028F       save the keyboard decode logic pointer low byte
.,E527 A9 EB    LDA #$EB        get the keyboard decode logic pointer high byte
.,E529 8D 90 02 STA $0290       save the keyboard decode logic pointer high byte
.,E52C A9 0A    LDA #$0A        set the maximum size of the keyboard buffer
.,E52E 8D 89 02 STA $0289       save the maximum size of the keyboard buffer
.,E531 8D 8C 02 STA $028C       save the repeat delay counter
.,E534 A9 0E    LDA #$0E        set light blue
.,E536 8D 86 02 STA $0286       save the current colour code
.,E539 A9 04    LDA #$04        speed 4
.,E53B 8D 8B 02 STA $028B       save the repeat speed counter
.,E53E A9 0C    LDA #$0C        set the cursor flash timing
.,E540 85 CD    STA $CD         save the cursor timing countdown
.,E542 85 CC    STA $CC         save the cursor enable, $00 = flash cursor

                                *** clear the screen
.,E544 AD 88 02 LDA $0288       get the screen memory page
.,E547 09 80    ORA #$80        set the high bit, flag every line is a logical line start
.,E549 A8       TAY             copy to Y
.,E54A A9 00    LDA #$00        clear the line start low byte
.,E54C AA       TAX             clear the index
.,E54D 94 D9    STY $D9,X       save the start of line X pointer high byte
.,E54F 18       CLC             clear carry for add
.,E550 69 28    ADC #$28        add the line length to the low byte
.,E552 90 01    BCC $E555       if no rollover skip the high byte increment
.,E554 C8       INY             else increment the high byte
.,E555 E8       INX             increment the line index
.,E556 E0 1A    CPX #$1A        compare it with the number of lines + 1
.,E558 D0 F3    BNE $E54D       loop if not all done
.,E55A A9 FF    LDA #$FF        set the end of table marker
.,E55C 95 D9    STA $D9,X       mark the end of the table
.,E55E A2 18    LDX #$18        set the line count, 25 lines to do, 0 to 24
.,E560 20 FF E9 JSR $E9FF       clear screen line X
.,E563 CA       DEX             decrement the count
.,E564 10 FA    BPL $E560       loop if more to do

                                *** home the cursor
.,E566 A0 00    LDY #$00        clear Y
.,E568 84 D3    STY $D3         clear the cursor column
.,E56A 84 D6    STY $D6         clear the cursor row

                                *** set screen pointers for cursor row, column
.,E56C A6 D6    LDX $D6         get the cursor row
.,E56E A5 D3    LDA $D3         get the cursor column
.,E570 B4 D9    LDY $D9,X       get start of line X pointer high byte
.,E572 30 08    BMI $E57C       if it is the logical line start continue
.,E574 18       CLC             else clear carry for add
.,E575 69 28    ADC #$28        add one line length
.,E577 85 D3    STA $D3         save the cursor column
.,E579 CA       DEX             decrement the cursor row
.,E57A 10 F4    BPL $E570       loop, branch always
.,E57C 20 F0 E9 JSR $E9F0       fetch a screen address
.,E57F A9 27    LDA #$27        set the line length
.,E581 E8       INX             increment the cursor row
.,E582 B4 D9    LDY $D9,X       get the start of line X pointer high byte
.,E584 30 06    BMI $E58C       if logical line start exit
.,E586 18       CLC             else clear carry for add
.,E587 69 28    ADC #$28        add one line length to the current line length
.,E589 E8       INX             increment the cursor row
.,E58A 10 F6    BPL $E582       loop, branch always
.,E58C 85 D5    STA $D5         save current screen line length
.,E58E 4C 24 EA JMP $EA24       calculate the pointer to colour RAM and return
.,E591 E4 C9    CPX $C9         compare it with the input cursor row
.,E593 F0 03    BEQ $E598       if there just exit
.,E595 4C ED E6 JMP $E6ED       else go ??
.,E598 60       RTS             

                                *** orphan bytes ??
.,E599 EA       NOP             huh
.,E59A 20 A0 E5 JSR $E5A0       initialise the vic chip
.,E59D 4C 66 E5 JMP $E566       home the cursor and return

                                *** initialise the vic chip
.,E5A0 A9 03    LDA #$03        set the screen as the output device
.,E5A2 85 9A    STA $9A         save the output device number
.,E5A4 A9 00    LDA #$00        set the keyboard as the input device
.,E5A6 85 99    STA $99         save the input device number
.,E5A8 A2 2F    LDX #$2F        set the count/index
.,E5AA BD B8 EC LDA $ECB8,X     get a vic ii chip initialisation value
.,E5AD 9D FF CF STA $CFFF,X     save it to the vic ii chip
.,E5B0 CA       DEX             decrement the count/index
.,E5B1 D0 F7    BNE $E5AA       loop if more to do
.,E5B3 60       RTS             
