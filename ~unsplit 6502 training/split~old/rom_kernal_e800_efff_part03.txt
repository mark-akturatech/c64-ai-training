
                                *** scan keyboard performs the following ..
                                
                                1) check if key pressed, if not then exit the routine
                                
                                2) init I/O ports of VIA ?? for keyboard scan and set pointers to decode table 1.
                                clear the character counter
                                
                                3) set one line of port B low and test for a closed key on port A by shifting the
                                byte read from the port. if the carry is clear then a key is closed so save the
                                count which is incremented on each shift. check for shift/stop/cbm keys and
                                flag if closed
                                
                                4) repeat step 3 for the whole matrix
                                
                                5) evaluate the SHIFT/CTRL/C= keys, this may change the decode table selected
                                
                                6) use the key count saved in step 3 as an index into the table selected in step 5
                                
                                7) check for key repeat operation
                                
                                8) save the decoded key to the buffer if first press or repeat
                                scan the keyboard
.,EA87 A9 00    LDA #$00clear A
.,EA89 8D 8D 02 STA $028D       clear the keyboard shift/control/c= flag
.,EA8C A0 40    LDY #$40        set no key
.,EA8E 84 CB    STY $CB         save which key
.,EA90 8D 00 DC STA $DC00       clear VIA 1 DRA, keyboard column drive
.,EA93 AE 01 DC LDX $DC01       read VIA 1 DRB, keyboard row port
.,EA96 E0 FF    CPX #$FF        compare with all bits set
.,EA98 F0 61    BEQ $EAFB       if no key pressed clear current key and exit (does
                                further BEQ to $EBBA)
.,EA9A A8       TAY             clear the key count
.,EA9B A9 81    LDA #$81get the decode table low byte
.,EA9D 85 F5    STA $F5         save the keyboard pointer low byte
.,EA9F A9 EB    LDA #$EB        get the decode table high byte
.,EAA1 85 F6    STA $F6save the keyboard pointer high byte
.,EAA3 A9 FE    LDA #$FE        set column 0 low
.,EAA5 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,EAA8 A2 08    LDX #$08        set the row count
.,EAAA 48       PHA             save the column
.,EAAB AD 01 DC LDA $DC01       read VIA 1 DRB, keyboard row port
.,EAAE CD 01 DC CMP $DC01       compare it with itself
.,EAB1 D0 F8    BNE $EAAB       loop if changing
.,EAB3 4A       LSR             shift row to Cb
.,EAB4 B0 16    BCS $EACC       if no key closed on this row go do next row
.,EAB6 48       PHA             save row
.,EAB7 B1 F5    LDA ($F5),Y     get character from decode table
.,EAB9 C9 05    CMP #$05        compare with $05, there is no $05 key but the control
                                keys are all less than $05
.,EABB B0 0C    BCS $EAC9       if not shift/control/c=/stop go save key count
                                else was shift/control/c=/stop key
.,EABD C9 03    CMP #$03        compare with $03, stop
.,EABF F0 08    BEQ $EAC9       if stop go save key count and continue
                                character is $01 - shift, $02 - c= or $04 - control
.,EAC1 0D 8D 02 ORA $028D       OR it with the keyboard shift/control/c= flag
.,EAC4 8D 8D 02 STA $028D       save the keyboard shift/control/c= flag
.,EAC7 10 02    BPL $EACB       skip save key, branch always
.,EAC9 84 CB    STY $CB         save key count
.,EACB 68       PLA             restore row
.,EACC C8       INY             increment key count
.,EACD C0 41    CPY #$41        compare with max+1
.,EACF B0 0B    BCS $EADC       exit loop if >= max+1
                                else still in matrix
.,EAD1 CA       DEX             decrement row count
.,EAD2 D0 DF    BNE $EAB3       loop if more rows to do
.,EAD4 38       SEC             set carry for keyboard column shift
.,EAD5 68       PLA             restore the column
.,EAD6 2A       ROL             shift the keyboard column
.,EAD7 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,EADA D0 CC    BNE $EAA8       loop for next column, branch always
.,EADC 68       PLA             dump the saved column
.,EADD 6C 8F 02 JMP ($028F)     evaluate the SHIFT/CTRL/C= keys, $EBDC
                                key decoding continues here after the SHIFT/CTRL/C= keys are evaluated
.,EAE0 A4 CB    LDY $CB         get saved key count
.,EAE2 B1 F5    LDA ($F5),Y     get character from decode table
.,EAE4 AA       TAX             copy character to X
.,EAE5 C4 C5    CPY $C5         compare key count with last key count
.,EAE7 F0 07    BEQ $EAF0       if this key = current key, key held, go test repeat
.,EAE9 A0 10    LDY #$10        set the repeat delay count
.,EAEB 8C 8C 02 STY $028C       save the repeat delay count
.,EAEE D0 36    BNE $EB26       go save key to buffer and exit, branch always
.,EAF0 29 7F    AND #$7F        clear b7
.,EAF2 2C 8A 02 BIT $028A       test key repeat
.,EAF5 30 16    BMI $EB0D       if repeat all go ??
.,EAF7 70 49    BVS $EB42       if repeat none go ??
.,EAF9 C9 7F    CMP #$7F        compare with end marker
.,EAFB F0 29    BEQ $EB26       if $00/end marker go save key to buffer and exit
.,EAFD C9 14    CMP #$14        compare with [INSERT]/[DELETE]
.,EAFF F0 0C    BEQ $EB0D       if [INSERT]/[DELETE] go test for repeat
.,EB01 C9 20    CMP #$20        compare with [SPACE]
.,EB03 F0 08    BEQ $EB0D       if [SPACE] go test for repeat
.,EB05 C9 1D    CMP #$1D        compare with [CURSOR RIGHT]
.,EB07 F0 04    BEQ $EB0D       if [CURSOR RIGHT] go test for repeat
.,EB09 C9 11    CMP #$11        compare with [CURSOR DOWN]
.,EB0B D0 35    BNE $EB42       if not [CURSOR DOWN] just exit
                                was one of the cursor movement keys, insert/delete
                                key or the space bar so always do repeat tests
.,EB0D AC 8C 02 LDY $028C       get the repeat delay counter
.,EB10 F0 05    BEQ $EB17       if delay expired go ??
.,EB12 CE 8C 02 DEC $028C       else decrement repeat delay counter
.,EB15 D0 2B    BNE $EB42       if delay not expired go ??
                                repeat delay counter has expired
.,EB17 CE 8B 02 DEC $028B       decrement the repeat speed counter
.,EB1A D0 26    BNE $EB42       branch if repeat speed count not expired
.,EB1C A0 04    LDY #$04        set for 4/60ths of a second
.,EB1E 8C 8B 02 STY $028B       save the repeat speed counter
.,EB21 A4 C6    LDY $C6         get the keyboard buffer index
.,EB23 88       DEY             decrement it
.,EB24 10 1C    BPL $EB42       if the buffer isn't empty just exit
                                else repeat the key immediately
                                possibly save the key to the keyboard buffer. if there was no key pressed or the key
                                was not found during the scan (possibly due to key bounce) then X will be $FF here
.,EB26 A4 CB    LDY $CB         get the key count
.,EB28 84 C5    STY $C5         save it as the current key count
.,EB2A AC 8D 02 LDY $028D       get the keyboard shift/control/c= flag
.,EB2D 8C 8E 02 STY $028E       save it as last keyboard shift pattern
.,EB30 E0 FF    CPX #$FF        compare the character with the table end marker or no key
.,EB32 F0 0E    BEQ $EB42       if it was the table end marker or no key just exit
.,EB34 8A       TXA             copy the character to A
.,EB35 A6 C6    LDX $C6         get the keyboard buffer index
.,EB37 EC 89 02 CPX $0289       compare it with the keyboard buffer size
.,EB3A B0 06    BCS $EB42       if the buffer is full just exit
.,EB3C 9D 77 02 STA $0277,X     save the character to the keyboard buffer
.,EB3F E8       INX             increment the index
.,EB40 86 C6    STX $C6         save the keyboard buffer index
.,EB42 A9 7F    LDA #$7F        enable column 7 for the stop key
.,EB44 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,EB47 60       RTS             

                                *** evaluate the SHIFT/CTRL/C= keys
.,EB48 AD 8D 02 LDA $028D       get the keyboard shift/control/c= flag
.,EB4B C9 03    CMP #$03        compare with [SHIFT][C=]
.,EB4D D0 15    BNE $EB64       if not [SHIFT][C=] go ??
.,EB4F CD 8E 02 CMP $028E       compare with last
.,EB52 F0 EE    BEQ $EB42       exit if still the same
.,EB54 AD 91 02 LDA $0291       get the shift mode switch $00 = enabled, $80 = locked
.,EB57 30 1D    BMI $EB76       if locked continue keyboard decode
                                toggle text mode
.,EB59 AD 18 D0 LDA $D018       get the start of character memory address
.,EB5C 49 02    EOR #$02        toggle address b1
.,EB5E 8D 18 D0 STA $D018       save the start of character memory address
.,EB61 4C 76 EB JMP $EB76       continue the keyboard decode
                                select keyboard table
.,EB64 0A       ASL             << 1
.,EB65 C9 08    CMP #$08        compare with [CTRL]
.,EB67 90 02    BCC $EB6B       if [CTRL] is not pressed skip the index change
.,EB69 A9 06    LDA #$06        else [CTRL] was pressed so make the index = $06
.,EB6B AA       TAX             copy the index to X
.,EB6C BD 79 EB LDA $EB79,X     get the decode table pointer low byte
.,EB6F 85 F5    STA $F5         save the decode table pointer low byte
.,EB71 BD 7A EB LDA $EB7A,X     get the decode table pointer high byte
.,EB74 85 F6    STA $F6         save the decode table pointer high byte
.,EB76 4C E0 EA JMP $EAE0       continue the keyboard decode

                                *** table addresses
.:EB79 81 EB                    standard
.:EB7B C2 EB                    shift
.:EB7D 03 EC                    commodore
.:EB7F 78 EC                    control

                                *** standard keyboard table
.:EB81 14 0D 1D 88 85 86 87 11
.:EB89 33 57 41 34 5A 53 45 01
.:EB91 35 52 44 36 43 46 54 58
.:EB99 37 59 47 38 42 48 55 56
.:EBA1 39 49 4A 30 4D 4B 4F 4E
.:EBA9 2B 50 4C 2D 2E 3A 40 2C
.:EBB1 5C 2A 3B 13 01 3D 5E 2F
.:EBB9 31 5F 04 32 20 02 51 03
.:EBC1 FF
                                *** shifted keyboard table
.:EBC2 94 8D 9D 8C 89 8A 8B 91
.:EBCA 23 D7 C1 24 DA D3 C5 01
.:EBD2 25 D2 C4 26 C3 C6 D4 D8
.:EBDA 27 D9 C7 28 C2 C8 D5 D6
.:EBE2 29 C9 CA 30 CD CB CF CE
.:EBEA DB D0 CC DD 3E 5B BA 3C
.:EBF2 A9 C0 5D 93 01 3D DE 3F
.:EBFA 21 5F 04 22 A0 02 D1 83
.:EC02 FF
                                *** CBM key keyboard table
.:EC03 94 8D 9D 8C 89 8A 8B 91
.:EC0B 96 B3 B0 97 AD AE B1 01
.:EC13 98 B2 AC 99 BC BB A3 BD
.:EC1B 9A B7 A5 9B BF B4 B8 BE
.:EC23 29 A2 B5 30 A7 A1 B9 AA
.:EC2B A6 AF B6 DC 3E 5B A4 3C
.:EC33 A8 DF 5D 93 01 3D DE 3F
.:EC3B 81 5F 04 95 A0 02 AB 83
.:EC43 FF

                                *** check for special character codes
.,EC44 C9 0E    CMP #$0E        compare with [SWITCH TO LOWER CASE]
.,EC46 D0 07    BNE $EC4F       if not [SWITCH TO LOWER CASE] skip the switch
.,EC48 AD 18 D0 LDA $D018       get the start of character memory address
.,EC4B 09 02    ORA #$02        mask xxxx xx1x, set lower case characters
.,EC4D D0 09    BNE $EC58       go save the new value, branch always
                                check for special character codes except fro switch to lower case
.,EC4F C9 8E    CMP #$8E        compare with [SWITCH TO UPPER CASE]
.,EC51 D0 0B    BNE $EC5E       if not [SWITCH TO UPPER CASE] go do the [SHIFT]+[C=] key
                                check
.,EC53 AD 18 D0 LDA $D018       get the start of character memory address
.,EC56 29 FD    AND #$FD        mask xxxx xx0x, set upper case characters
.,EC58 8D 18 D0 STA $D018       save the start of character memory address
.,EC5B 4C A8 E6 JMP $E6A8       restore the registers, set the quote flag and exit
                                do the [SHIFT]+[C=] key check
.,EC5E C9 08    CMP #$08        compare with disable [SHIFT][C=]
.,EC60 D0 07    BNE $EC69       if not disable [SHIFT][C=] skip the set
.,EC62 A9 80    LDA #$80        set to lock shift mode switch
.,EC64 0D 91 02 ORA $0291       OR it with the shift mode switch
.,EC67 30 09    BMI $EC72       go save the value, branch always
.,EC69 C9 09    CMP #$09        compare with enable [SHIFT][C=]
.,EC6B D0 EE    BNE $EC5B       exit if not enable [SHIFT][C=]
.,EC6D A9 7F    LDA #$7F        set to unlock shift mode switch
.,EC6F 2D 91 02 AND $0291       AND it with the shift mode switch
.,EC72 8D 91 02 STA $0291       save the shift mode switch $00 = enabled, $80 = locked
.,EC75 4C A8 E6 JMP $E6A8       restore the registers, set the quote flag and exit

                                *** control keyboard table
.:EC78 FF FF FF FF FF FF FF FF
.:EC80 1C 17 01 9F 1A 13 05 FF
.:EC88 9C 12 04 1E 03 06 14 18
.:EC90 1F 19 07 9E 02 08 15 16
.:EC98 12 09 0A 92 0D 0B 0F 0E
.:ECA0 FF 10 0C FF FF 1B 00 FF
.:ECA8 1C FF 1D FF FF 1F 1E FF
.:ECB0 90 06 FF 05 FF FF 11 FF
.:ECB8 FF
