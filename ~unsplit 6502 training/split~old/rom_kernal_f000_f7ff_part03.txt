
                                *** send secondary address and filename
.,F3D5 A5 B9    LDA $B9         get the secondary address
.,F3D7 30 FA    BMI $F3D3       ok exit if -ve
.,F3D9 A4 B7    LDY $B7         get file name length
.,F3DB F0 F6    BEQ $F3D3       ok exit if null
.,F3DD A9 00    LDA #$00        clear A
.,F3DF 85 90    STA $90         clear the serial status byte
.,F3E1 A5 BA    LDA $BA         get the device number
.,F3E3 20 0C ED JSR $ED0C       command devices on the serial bus to LISTEN
.,F3E6 A5 B9    LDA $B9         get the secondary address
.,F3E8 09 F0    ORA #$F0        OR with the OPEN command
.,F3EA 20 B9 ED JSR $EDB9       send secondary address after LISTEN
.,F3ED A5 90    LDA $90         get the serial status byte
.,F3EF 10 05    BPL $F3F6       if device present skip the 'device not present' error
.,F3F1 68       PLA             else dump calling address low byte
.,F3F2 68       PLA             dump calling address high byte
.,F3F3 4C 07 F7 JMP $F707       do 'device not present' error and return
.,F3F6 A5 B7    LDA $B7         get file name length
.,F3F8 F0 0C    BEQ $F406       branch if null name
.,F3FA A0 00    LDY #$00        clear index
.,F3FC B1 BB    LDA ($BB),Y     get file name byte
.,F3FE 20 DD ED JSR $EDDD       output byte to serial bus
.,F401 C8       INY             increment index
.,F402 C4 B7    CPY $B7         compare with file name length
.,F404 D0 F6    BNE $F3FC       loop if not all done
.,F406 4C 54 F6 JMP $F654       command serial bus to UNLISTEN and return

                                *** open RS232 device
.,F409 20 83 F4 JSR $F483       initialise RS232 output
.,F40C 8C 97 02 STY $0297       save the RS232 status register
.,F40F C4 B7    CPY $B7         compare with file name length
.,F411 F0 0A    BEQ $F41D       exit loop if done
.,F413 B1 BB    LDA ($BB),Y     get file name byte
.,F415 99 93 02 STA $0293,Y     copy to 6551 register set
.,F418 C8       INY             increment index
.,F419 C0 04    CPY #$04        compare with $04
.,F41B D0 F2    BNE $F40F       loop if not to 4 yet
.,F41D 20 4A EF JSR $EF4A       compute bit count
.,F420 8E 98 02 STX $0298       save bit count
.,F423 AD 93 02 LDA $0293       get pseudo 6551 control register
.,F426 29 0F    AND #$0F        mask 0000 xxxx, baud rate
.,F428 F0 1C    BEQ $F446       if zero skip the baud rate setup
.,F42A 0A       ASL             * 2 bytes per entry
.,F42B AA       TAX             copy to the index
.,F42C AD A6 02 LDA $02A6       get the PAL/NTSC flag
.,F42F D0 09    BNE $F43A       if PAL go set PAL timing
.,F431 BC C1 FE LDY $FEC1,X     get the NTSC baud rate value high byte
.,F434 BD C0 FE LDA $FEC0,X     get the NTSC baud rate value low byte
.,F437 4C 40 F4 JMP $F440       go save the baud rate values
.,F43A BC EB E4 LDY $E4EB,X     get the PAL baud rate value high byte
.,F43D BD EA E4 LDA $E4EA,X     get the PAL baud rate value low byte
.,F440 8C 96 02 STY $0296       save the nonstandard bit timing high byte
.,F443 8D 95 02 STA $0295       save the nonstandard bit timing low byte
.,F446 AD 95 02 LDA $0295       get the nonstandard bit timing low byte
.,F449 0A       ASL             * 2
.,F44A 20 2E FF JSR $FF2E       
.,F44D AD 94 02 LDA $0294       read the pseudo 6551 command register
.,F450 4A       LSR             shift the X line/3 line bit into Cb
.,F451 90 09    BCC $F45C       if 3 line skip the DRS test
.,F453 AD 01 DD LDA $DD01       read VIA 2 DRB, RS232 port
.,F456 0A       ASL             shift DSR in into Cb
.,F457 B0 03    BCS $F45C       if DSR present skip the error set
.,F459 20 0D F0 JSR $F00D       set no DSR
.,F45C AD 9B 02 LDA $029B       get index to Rx buffer end
.,F45F 8D 9C 02 STA $029C       set index to Rx buffer start, clear Rx buffer
.,F462 AD 9E 02 LDA $029E       get index to Tx buffer end
.,F465 8D 9D 02 STA $029D       set index to Tx buffer start, clear Tx buffer
.,F468 20 27 FE JSR $FE27       read the top of memory
.,F46B A5 F8    LDA $F8         get the RS232 input buffer pointer high byte
.,F46D D0 05    BNE $F474       if buffer already set skip the save
.,F46F 88       DEY             decrement top of memory high byte, 256 byte buffer
.,F470 84 F8    STY $F8         save the RS232 input buffer pointer high byte
.,F472 86 F7    STX $F7         save the RS232 input buffer pointer low byte
.,F474 A5 FA    LDA $FA         get the RS232 output buffer pointer high byte
.,F476 D0 05    BNE $F47D       if ?? go set the top of memory to F0xx
.,F478 88       DEY             
.,F479 84 FA    STY $FA         save the RS232 output buffer pointer high byte
.,F47B 86 F9    STX $F9         save the RS232 output buffer pointer low byte

                                *** set the top of memory to F0xx
.,F47D 38       SEC             read the top of memory
.,F47E A9 F0    LDA #$F0        set $F000
.,F480 4C 2D FE JMP $FE2D       set the top of memory and return

                                *** initialise RS232 output
.,F483 A9 7F    LDA #$7F        disable all interrupts
.,F485 8D 0D DD STA $DD0D       save VIA 2 ICR
.,F488 A9 06    LDA #$06        set RS232 DTR output, RS232 RTS output
.,F48A 8D 03 DD STA $DD03       save VIA 2 DDRB, RS232 port
.,F48D 8D 01 DD STA $DD01       save VIA 2 DRB, RS232 port
.,F490 A9 04    LDA #$04        mask xxxx x1xx, set RS232 Tx DATA high
.,F492 0D 00 DD ORA $DD00       OR it with VIA 2 DRA, serial port and video address
.,F495 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,F498 A0 00    LDY #$00        clear Y
.,F49A 8C A1 02 STY $02A1       clear the RS-232 interrupt enable byte
.,F49D 60       RTS             

                                *** load RAM from a device
.,F49E 86 C3    STX $C3         set kernal setup pointer low byte
.,F4A0 84 C4    STY $C4         set kernal setup pointer high byte
.,F4A2 6C 30 03 JMP ($0330)     do LOAD vector, usually points to $F4A5

                                *** load
.,F4A5 85 93    STA $93         save load/verify flag
.,F4A7 A9 00    LDA #$00        clear A
.,F4A9 85 90    STA $90         clear the serial status byte
.,F4AB A5 BA    LDA $BA         get the device number
.,F4AD D0 03    BNE $F4B2       if not the keyboard continue
                                do 'illegal device number'
.,F4AF 4C 13 F7 JMP $F713       else do 'illegal device number' and return
.,F4B2 C9 03    CMP #$03        
.,F4B4 F0 F9    BEQ $F4AF       
.,F4B6 90 7B    BCC $F533       
.,F4B8 A4 B7    LDY $B7         get file name length
.,F4BA D0 03    BNE $F4BF       if not null name go ??
.,F4BC 4C 10 F7 JMP $F710       else do 'missing file name' error and return
.,F4BF A6 B9    LDX $B9         get the secondary address
.,F4C1 20 AF F5 JSR $F5AF       print "Searching..."
.,F4C4 A9 60    LDA #$60        
.,F4C6 85 B9    STA $B9         save the secondary address
.,F4C8 20 D5 F3 JSR $F3D5       send secondary address and filename
.,F4CB A5 BA    LDA $BA         get the device number
.,F4CD 20 09 ED JSR $ED09       command serial bus device to TALK
.,F4D0 A5 B9    LDA $B9         get the secondary address
.,F4D2 20 C7 ED JSR $EDC7       send secondary address after TALK
.,F4D5 20 13 EE JSR $EE13       input byte from serial bus
.,F4D8 85 AE    STA $AE         save program start address low byte
.,F4DA A5 90    LDA $90         get the serial status byte
.,F4DC 4A       LSR             shift time out read ..
.,F4DD 4A       LSR             .. into carry bit
.,F4DE B0 50    BCS $F530       if timed out go do file not found error and return
.,F4E0 20 13 EE JSR $EE13       input byte from serial bus
.,F4E3 85 AF    STA $AF         save program start address high byte
.,F4E5 8A       TXA             copy secondary address
.,F4E6 D0 08    BNE $F4F0       load location not set in LOAD call, so continue with the
                                load
.,F4E8 A5 C3    LDA $C3         get the load address low byte
.,F4EA 85 AE    STA $AE         save the program start address low byte
.,F4EC A5 C4    LDA $C4         get the load address high byte
.,F4EE 85 AF    STA $AF         save the program start address high byte
.,F4F0 20 D2 F5 JSR $F5D2       
.,F4F3 A9 FD    LDA #$FD        mask xxxx xx0x, clear time out read bit
.,F4F5 25 90    AND $90         mask the serial status byte
.,F4F7 85 90    STA $90         set the serial status byte
.,F4F9 20 E1 FF JSR $FFE1       scan stop key, return Zb = 1 = [STOP]
.,F4FC D0 03    BNE $F501       if not [STOP] go ??
.,F4FE 4C 33 F6 JMP $F633       else close the serial bus device and flag stop
.,F501 20 13 EE JSR $EE13       input byte from serial bus
.,F504 AA       TAX             copy byte
.,F505 A5 90    LDA $90         get the serial status byte
.,F507 4A       LSR             shift time out read ..
.,F508 4A       LSR             .. into carry bit
.,F509 B0 E8    BCS $F4F3       if timed out go try again
.,F50B 8A       TXA             copy received byte back
.,F50C A4 93    LDY $93         get load/verify flag
.,F50E F0 0C    BEQ $F51C       if load go load
                                else is verify
.,F510 A0 00    LDY #$00        clear index
.,F512 D1 AE    CMP ($AE),Y     compare byte with previously loaded byte
.,F514 F0 08    BEQ $F51E       if match go ??
.,F516 A9 10    LDA #$10        flag read error
.,F518 20 1C FE JSR $FE1C       OR into the serial status byte
.:F51B 2C       .BYTE $2C       makes next line BIT $AE91
.,F51C 91 AE    STA ($AE),Y     save byte to memory
.,F51E E6 AE    INC $AE         increment save pointer low byte
.,F520 D0 02    BNE $F524       if no rollover go ??
.,F522 E6 AF    INC $AF         else increment save pointer high byte
.,F524 24 90    BIT $90         test the serial status byte
.,F526 50 CB    BVC $F4F3       loop if not end of file
                                close file and exit
.,F528 20 EF ED JSR $EDEF       command serial bus to UNTALK
.,F52B 20 42 F6 JSR $F642       close serial bus device
.,F52E 90 79    BCC $F5A9       if ?? go flag ok and exit
.,F530 4C 04 F7 JMP $F704       do file not found error and return

                                *** ??
.,F533 4A       LSR             
.,F534 B0 03    BCS $F539       
.,F536 4C 13 F7 JMP $F713       else do 'illegal device number' and return
.,F539 20 D0 F7 JSR $F7D0       get tape buffer start pointer in XY
.,F53C B0 03    BCS $F541       if ??
.,F53E 4C 13 F7 JMP $F713       else do 'illegal device number' and return
.,F541 20 17 F8 JSR $F817       wait for PLAY
.,F544 B0 68    BCS $F5AE       exit if STOP was pressed
.,F546 20 AF F5 JSR $F5AF       print "Searching..."
.,F549 A5 B7    LDA $B7         get file name length
.,F54B F0 09    BEQ $F556       
.,F54D 20 EA F7 JSR $F7EA       find specific tape header
.,F550 90 0B    BCC $F55D       if no error continue
.,F552 F0 5A    BEQ $F5AE       exit if ??
.,F554 B0 DA    BCS $F530       , branch always
.,F556 20 2C F7 JSR $F72C       find tape header, exit with header in buffer
.,F559 F0 53    BEQ $F5AE       exit if ??
.,F55B B0 D3    BCS $F530       
.,F55D A5 90    LDA $90         get the serial status byte
.,F55F 29 10    AND #$10        mask 000x 0000, read error
.,F561 38       SEC             flag fail
.,F562 D0 4A    BNE $F5AE       if read error just exit
.,F564 E0 01    CPX #$01        
.,F566 F0 11    BEQ $F579       
.,F568 E0 03    CPX #$03        
.,F56A D0 DD    BNE $F549       
.,F56C A0 01    LDY #$01        
.,F56E B1 B2    LDA ($B2),Y     
.,F570 85 C3    STA $C3         
.,F572 C8       INY             
.,F573 B1 B2    LDA ($B2),Y     
.,F575 85 C4    STA $C4         
.,F577 B0 04    BCS $F57D       
.,F579 A5 B9    LDA $B9         get the secondary address
.,F57B D0 EF    BNE $F56C       
.,F57D A0 03    LDY #$03        
.,F57F B1 B2    LDA ($B2),Y     
.,F581 A0 01    LDY #$01        
.,F583 F1 B2    SBC ($B2),Y     
.,F585 AA       TAX             
.,F586 A0 04    LDY #$04        
.,F588 B1 B2    LDA ($B2),Y     
.,F58A A0 02    LDY #$02        
.,F58C F1 B2    SBC ($B2),Y     
.,F58E A8       TAY             
.,F58F 18       CLC             
.,F590 8A       TXA             
.,F591 65 C3    ADC $C3         
.,F593 85 AE    STA $AE         
.,F595 98       TYA             
.,F596 65 C4    ADC $C4         
.,F598 85 AF    STA $AF         
.,F59A A5 C3    LDA $C3         
.,F59C 85 C1    STA $C1         set I/O start addresses low byte
.,F59E A5 C4    LDA $C4         
.,F5A0 85 C2    STA $C2         set I/O start addresses high byte
.,F5A2 20 D2 F5 JSR $F5D2       display "LOADING" or "VERIFYING"
.,F5A5 20 4A F8 JSR $F84A       do the tape read
.:F5A8 24       .BYTE $24       makes next line BIT $18, keep the error flag in Cb
.,F5A9 18       CLC             flag ok
.,F5AA A6 AE    LDX $AE         get the LOAD end pointer low byte
.,F5AC A4 AF    LDY $AF         get the LOAD end pointer high byte
.,F5AE 60       RTS             

                                *** print "Searching..."
.,F5AF A5 9D    LDA $9D         get message mode flag
.,F5B1 10 1E    BPL $F5D1       exit if control messages off
.,F5B3 A0 0C    LDY #$0C        
                                index to "SEARCHING "
.,F5B5 20 2F F1 JSR $F12F       display kernel I/O message
.,F5B8 A5 B7    LDA $B7         get file name length
.,F5BA F0 15    BEQ $F5D1       exit if null name
.,F5BC A0 17    LDY #$17        
                                else index to "FOR "
.,F5BE 20 2F F1 JSR $F12F       display kernel I/O message

                                *** print file name
.,F5C1 A4 B7    LDY $B7         get file name length
.,F5C3 F0 0C    BEQ $F5D1       exit if null file name
.,F5C5 A0 00    LDY #$00        clear index
.,F5C7 B1 BB    LDA ($BB),Y     get file name byte
.,F5C9 20 D2 FF JSR $FFD2       output character to channel
.,F5CC C8       INY             increment index
.,F5CD C4 B7    CPY $B7         compare with file name length
.,F5CF D0 F6    BNE $F5C7       loop if more to do
.,F5D1 60       RTS             

                                *** display "LOADING" or "VERIFYING"
.,F5D2 A0 49    LDY #$49        
                                point to "LOADING"
.,F5D4 A5 93    LDA $93         get load/verify flag
.,F5D6 F0 02    BEQ $F5DA       branch if load
.,F5D8 A0 59    LDY #$59        
                                point to "VERIFYING"
.,F5DA 4C 2B F1 JMP $F12B       display kernel I/O message if in direct mode and return

                                *** save RAM to device, A = index to start address, XY = end address low/high
.,F5DD 86 AE    STX $AE         save end address low byte
.,F5DF 84 AF    STY $AF         save end address high byte
.,F5E1 AA       TAX             copy index to start pointer
.,F5E2 B5 00    LDA $00,X       get start address low byte
.,F5E4 85 C1    STA $C1         set I/O start addresses low byte
.,F5E6 B5 01    LDA $01,X       get start address high byte
.,F5E8 85 C2    STA $C2         set I/O start addresses high byte
.,F5EA 6C 32 03 JMP ($0332)     go save, usually points to $F685
