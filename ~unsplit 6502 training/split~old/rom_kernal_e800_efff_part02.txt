
                                *** open up a space on the screen
.,E965 A6 D6    LDX $D6         get the cursor row
.,E967 E8       INX             increment the row
.,E968 B5 D9    LDA $D9,X       get the start of line X pointer high byte
.,E96A 10 FB    BPL $E967       loop if not start of logical line
.,E96C 8E A5 02 STX $02A5       save the screen row marker
.,E96F E0 18    CPX #$18        compare it with the last line
.,E971 F0 0E    BEQ $E981       if = last line go ??
.,E973 90 0C    BCC $E981       if < last line go ??
                                else it was > last line
.,E975 20 EA E8 JSR $E8EA       scroll the screen
.,E978 AE A5 02 LDX $02A5       get the screen row marker
.,E97B CA       DEX             decrement the screen row marker
.,E97C C6 D6    DEC $D6         decrement the cursor row
.,E97E 4C DA E6 JMP $E6DA       add this row to the current logical line and return
.,E981 A5 AC    LDA $AC         copy tape buffer pointer
.,E983 48       PHA             save it
.,E984 A5 AD    LDA $AD         copy tape buffer pointer
.,E986 48       PHA             save it
.,E987 A5 AE    LDA $AE         copy tape buffer end pointer
.,E989 48       PHA             save it
.,E98A A5 AF    LDA $AF         copy tape buffer end pointer
.,E98C 48       PHA             save it
.,E98D A2 19    LDX #$19        set to end line + 1 for predecrement loop
.,E98F CA       DEX             decrement the line number
.,E990 20 F0 E9 JSR $E9F0       fetch a screen address
.,E993 EC A5 02 CPX $02A5       compare it with the screen row marker
.,E996 90 0E    BCC $E9A6       if < screen row marker go ??
.,E998 F0 0C    BEQ $E9A6       if = screen row marker go ??
.,E99A BD EF EC LDA $ECEF,X     else get the start of the previous line low byte from the
                                ROM table
.,E99D 85 AC    STA $AC         save previous line pointer low byte
.,E99F B5 D8    LDA $D8,X       get the start of the previous line pointer high byte
.,E9A1 20 C8 E9 JSR $E9C8       shift the screen line down
.,E9A4 30 E9    BMI $E98F       loop, branch always
.,E9A6 20 FF E9 JSR $E9FF       clear screen line X
.,E9A9 A2 17    LDX #$17        
.,E9AB EC A5 02 CPX $02A5       compare it with the screen row marker
.,E9AE 90 0F    BCC $E9BF       
.,E9B0 B5 DA    LDA $DA,X       
.,E9B2 29 7F    AND #$7F        
.,E9B4 B4 D9    LDY $D9,X       get start of line X pointer high byte
.,E9B6 10 02    BPL $E9BA       
.,E9B8 09 80    ORA #$80        
.,E9BA 95 DA    STA $DA,X       
.,E9BC CA       DEX             
.,E9BD D0 EC    BNE $E9AB       
.,E9BF AE A5 02 LDX $02A5       get the screen row marker
.,E9C2 20 DA E6 JSR $E6DA       add this row to the current logical line
.,E9C5 4C 58 E9 JMP $E958       restore the tape buffer pointers and exit

                                *** shift screen line up/down
.,E9C8 29 03    AND #$03        mask 0000 00xx, line memory page
.,E9CA 0D 88 02 ORA $0288       OR with screen memory page
.,E9CD 85 AD    STA $AD         save next/previous line pointer high byte
.,E9CF 20 E0 E9 JSR $E9E0       calculate pointers to screen lines colour RAM
.,E9D2 A0 27    LDY #$27        set the column count
.,E9D4 B1 AC    LDA ($AC),Y     get character from next/previous screen line
.,E9D6 91 D1    STA ($D1),Y     save character to current screen line
.,E9D8 B1 AE    LDA ($AE),Y     get colour from next/previous screen line colour RAM
.,E9DA 91 F3    STA ($F3),Y     save colour to current screen line colour RAM
.,E9DC 88       DEY             decrement column index/count
.,E9DD 10 F5    BPL $E9D4       loop if more to do
.,E9DF 60       RTS             

                                *** calculate pointers to screen lines colour RAM
.,E9E0 20 24 EA JSR $EA24       calculate the pointer to the current screen line colour
                                RAM
.,E9E3 A5 AC    LDA $AC         get the next screen line pointer low byte
.,E9E5 85 AE    STA $AE         save the next screen line colour RAM pointer low byte
.,E9E7 A5 AD    LDA $AD         get the next screen line pointer high byte
.,E9E9 29 03    AND #$03        mask 0000 00xx, line memory page
.,E9EB 09 D8    ORA #$D8        set  1101 01xx, colour memory page
.,E9ED 85 AF    STA $AF         save the next screen line colour RAM pointer high byte
.,E9EF 60       RTS             

                                *** fetch a screen address
.,E9F0 BD F0 EC LDA $ECF0,X     get the start of line low byte from the ROM table
.,E9F3 85 D1    STA $D1         set the current screen line pointer low byte
.,E9F5 B5 D9    LDA $D9,X       get the start of line high byte from the RAM table
.,E9F7 29 03    AND #$03        mask 0000 00xx, line memory page
.,E9F9 0D 88 02 ORA $0288       OR with the screen memory page
.,E9FC 85 D2    STA $D2         save the current screen line pointer high byte
.,E9FE 60       RTS             

                                *** clear screen line X
.,E9FF A0 27    LDY #$27        set number of columns to clear
.,EA01 20 F0 E9 JSR $E9F0       fetch a screen address
.,EA04 20 24 EA JSR $EA24       calculate the pointer to colour RAM
.,EA07 20 DA E4 JSR $E4DA       save the current colour to the colour RAM
.,EA0A A9 20    LDA #$20        set [SPACE]
.,EA0C 91 D1    STA ($D1),Y     clear character in current screen line
.,EA0E 88       DEY             decrement index
.,EA0F 10 F6    BPL $EA07       loop if more to do
.,EA11 60       RTS

                                *** orphan byte
.,EA12 EA       NOP             unused

                                *** print character A and colour X
.,EA13 A8       TAY             copy the character
.,EA14 A9 02    LDA #$02set the count to $02, usually $14 ??
.,EA16 85 CD    STA $CD         save the cursor countdown
.,EA18 20 24 EA JSR $EA24       calculate the pointer to colour RAM
.,EA1B 98       TYA             get the character back

                                *** save the character and colour to the screen @ the cursor
.,EA1C A4 D3    LDY $D3         get the cursor column
.,EA1E 91 D1    STA ($D1),Y     save the character from current screen line
.,EA20 8A       TXA             copy the colour to A
.,EA21 91 F3    STA ($F3),Y     save to colour RAM
.,EA23 60       RTS             

                                *** calculate the pointer to colour RAM
.,EA24 A5 D1    LDA $D1         get current screen line pointer low byte
.,EA26 85 F3    STA $F3         save pointer to colour RAM low byte
.,EA28 A5 D2    LDA $D2         get current screen line pointer high byte
.,EA2A 29 03    AND #$03        mask 0000 00xx, line memory page
.,EA2C 09 D8    ORA #$D8        set  1101 01xx, colour memory page
.,EA2E 85 F4    STA $F4         save pointer to colour RAM high byte
.,EA30 60       RTS             

                                *** IRQ vector
.,EA31 20 EA FF JSR $FFEA       increment the real time clock
.,EA34 A5 CC    LDA $CC         get the cursor enable, $00 = flash cursor
.,EA36 D0 29    BNE $EA61       if flash not enabled skip the flash
.,EA38 C6 CD    DEC $CD         decrement the cursor timing countdown
.,EA3A D0 25    BNE $EA61       if not counted out skip the flash
.,EA3C A9 14    LDA #$14        set the flash count
.,EA3E 85 CD    STA $CD         save the cursor timing countdown
.,EA40 A4 D3    LDY $D3         get the cursor column
.,EA42 46 CF    LSR $CF         shift b0 cursor blink phase into carry
.,EA44 AE 87 02 LDX $0287       get the colour under the cursor
.,EA47 B1 D1    LDA ($D1),Y     get the character from current screen line
.,EA49 B0 11    BCS $EA5C       branch if cursor phase b0 was 1
.,EA4B E6 CF    INC $CF         set the cursor blink phase to 1
.,EA4D 85 CE    STA $CE         save the character under the cursor
.,EA4F 20 24 EA JSR $EA24       calculate the pointer to colour RAM
.,EA52 B1 F3    LDA ($F3),Y     get the colour RAM byte
.,EA54 8D 87 02 STA $0287       save the colour under the cursor
.,EA57 AE 86 02 LDX $0286       get the current colour code
.,EA5A A5 CE    LDA $CE         get the character under the cursor
.,EA5C 49 80    EOR #$80        toggle b7 of character under cursor
.,EA5E 20 1C EA JSR $EA1C       save the character and colour to the screen @ the cursor
.,EA61 A5 01    LDA $01         read the 6510 I/O port
.,EA63 29 10    AND #$10        mask 000x 0000, the cassette switch sense
.,EA65 F0 0A    BEQ $EA71       if the cassette sense is low skip the motor stop
                                the cassette sense was high, the switch was open, so turn
                                off the motor and clear the interlock
.,EA67 A0 00    LDY #$00        clear Y
.,EA69 84 C0    STY $C0         clear the tape motor interlock
.,EA6B A5 01    LDA $01         read the 6510 I/O port
.,EA6D 09 20    ORA #$20        mask xxxx xx1x, turn off the motor
.,EA6F D0 08    BNE $EA79       go save the port value, branch always
                                the cassette sense was low so turn the motor on, perhaps
.,EA71 A5 C0    LDA $C0         get the tape motor interlock
.,EA73 D0 06    BNE $EA7B       if the cassette interlock <> 0 don't turn on motor
.,EA75 A5 01    LDA $01         read the 6510 I/O port
.,EA77 29 1F    AND #$1F        mask xxxx xx0x, turn on the motor
.,EA79 85 01    STA $01         save the 6510 I/O port
.,EA7B 20 87 EA JSR $EA87       scan the keyboard
.,EA7E AD 0D DC LDA $DC0D       read VIA 1 ICR, clear the timer interrupt flag
.,EA81 68       PLA             pull Y
.,EA82 A8       TAY             restore Y
.,EA83 68       PLA             pull X
.,EA84 AA       TAX             restore X
.,EA85 68       PLA             restore A
.,EA86 40       RTI
