
                                *** received a whole byte, add it to the buffer
.,EF97 AC 9B 02 LDY $029B       get index to Rx buffer end
.,EF9A C8       INY             increment index
.,EF9B CC 9C 02 CPY $029C       compare with index to Rx buffer start
.,EF9E F0 2A    BEQ $EFCA       if buffer full go do Rx overrun error
.,EFA0 8C 9B 02 STY $029B       save index to Rx buffer end
.,EFA3 88       DEY             decrement index
.,EFA4 A5 AA    LDA $AA         get assembled byte
.,EFA6 AE 98 02 LDX $0298       get bit count
.,EFA9 E0 09    CPX #$09        compare with byte + stop
.,EFAB F0 04    BEQ $EFB1       branch if all nine bits received
.,EFAD 4A       LSR             else shift byte
.,EFAE E8       INX             increment bit count
.,EFAF D0 F8    BNE $EFA9       loop, branch always
.,EFB1 91 F7    STA ($F7),Y     save received byte to Rx buffer
.,EFB3 A9 20    LDA #$20        mask 00x0 0000, parity enable bit
.,EFB5 2C 94 02 BIT $0294       test the pseudo 6551 command register
.,EFB8 F0 B4    BEQ $EF6E       branch if parity disabled
.,EFBA 30 B1    BMI $EF6D       branch if mark or space parity
.,EFBC A5 A7    LDA $A7         get the RS232 received data bit
.,EFBE 45 AB    EOR $AB         EOR with the receiver parity bit
.,EFC0 F0 03    BEQ $EFC5       
.,EFC2 70 A9    BVS $EF6D       if ?? just exit
.:EFC4 2C       .BYTE $2C       makes next line BIT $A650
.,EFC5 50 A6    BVC $EF6D       if ?? just exit
.,EFC7 A9 01    LDA #$01        set Rx parity error
.:EFC9 2C       .BYTE $2C       makes next line BIT $04A9
.,EFCA A9 04    LDA #$04        set Rx overrun error
.:EFCC 2C       .BYTE $2C       makes next line BIT $80A9
.,EFCD A9 80    LDA #$80        set Rx break error
.:EFCF 2C       .BYTE $2C       makes next line BIT $02A9
.,EFD0 A9 02    LDA #$02        set Rx frame error
.,EFD2 0D 97 02 ORA $0297       OR it with the RS232 status byte
.,EFD5 8D 97 02 STA $0297       save the RS232 status byte
.,EFD8 4C 7E EF JMP $EF7E       setup to receive an RS232 bit and return
.,EFDB A5 AA    LDA $AA         
.,EFDD D0 F1    BNE $EFD0       if ?? do frame error
.,EFDF F0 EC    BEQ $EFCD       else do break error, branch always

                                *** open RS232 channel for output
.,EFE1 85 9A    STA $9A         save the output device number
.,EFE3 AD 94 02 LDA $0294       read the pseudo 6551 command register
.,EFE6 4A       LSR             shift handshake bit to carry
.,EFE7 90 29    BCC $F012       if 3 line interface go ??
.,EFE9 A9 02    LDA #$02        mask 0000 00x0, RTS out
.,EFEB 2C 01 DD BIT $DD01       test VIA 2 DRB, RS232 port
.,EFEE 10 1D    BPL $F00D       if DSR = 0 set DSR not present and exit
.,EFF0 D0 20    BNE $F012       if RTS = 1 just exit
.,EFF2 AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,EFF5 29 02    AND #$02        mask 0000 00x0, timer B interrupt
.,EFF7 D0 F9    BNE $EFF2       loop while the timer B interrupt is enebled
.,EFF9 2C 01 DD BIT $DD01       test VIA 2 DRB, RS232 port
.,EFFC 70 FB    BVS $EFF9       loop while CTS high
.,EFFE AD 01 DD LDA $DD01       read VIA 2 DRB, RS232 port
