# ROM KERNAL E000 E7FF
# Source: C64 ROM Disassembly

.,E000 85 56    STA $56         save FAC2 rounding byte
.,E002 20 0F BC JSR $BC0F       copy FAC1 to FAC2
.,E005 A5 61    LDA $61         get FAC1 exponent
.,E007 C9 88    CMP #$88        compare with EXP limit (256d)
.,E009 90 03    BCC $E00E       branch if less
.,E00B 20 D4 BA JSR $BAD4       handle overflow and underflow
.,E00E 20 CC BC JSR $BCCC       perform INT()
.,E011 A5 07    LDA $07         get mantissa 4 from INT()
.,E013 18       CLC             clear carry for add
.,E014 69 81    ADC #$81        normalise +1
.,E016 F0 F3    BEQ $E00B       if $00 result has overflowed so go handle it
.,E018 38       SEC             set carry for subtract
.,E019 E9 01    SBC #$01        exponent now correct
.,E01B 48       PHA             save FAC2 exponent
                                swap FAC1 and FAC2
.,E01C A2 05    LDX #$05        4 bytes to do
.,E01E B5 69    LDA $69,X       get FAC2,X
.,E020 B4 61    LDY $61,X       get FAC1,X
.,E022 95 61    STA $61,X       save FAC1,X
.,E024 94 69    STY $69,X       save FAC2,X
.,E026 CA       DEX             decrement count/index
.,E027 10 F5    BPL $E01E       loop if not all done
.,E029 A5 56    LDA $56         get FAC2 rounding byte
.,E02B 85 70    STA $70         save as FAC1 rounding byte
.,E02D 20 53 B8 JSR $B853       perform subtraction, FAC2 from FAC1
.,E030 20 B4 BF JSR $BFB4       do - FAC1
.,E033 A9 C4    LDA #$C4        set counter pointer low byte
.,E035 A0 BF    LDY #$BF        set counter pointer high byte
.,E037 20 59 E0 JSR $E059       go do series evaluation
.,E03A A9 00    LDA #$00        clear A
.,E03C 85 6F    STA $6F         clear sign compare (FAC1 EOR FAC2)
.,E03E 68       PLA             get saved FAC2 exponent
.,E03F 20 B9 BA JSR $BAB9       test and adjust accumulators
.,E042 60       RTS             
                                ^2 then series evaluation
.,E043 85 71    STA $71         save count pointer low byte
.,E045 84 72    STY $72         save count pointer high byte
.,E047 20 CA BB JSR $BBCA       pack FAC1 into $57
.,E04A A9 57    LDA #$57        set pointer low byte (Y already $00)
.,E04C 20 28 BA JSR $BA28       do convert AY, FCA1*(AY)
.,E04F 20 5D E0 JSR $E05D       go do series evaluation
.,E052 A9 57    LDA #$57        pointer to original # low byte
.,E054 A0 00    LDY #$00        pointer to original # high byte
.,E056 4C 28 BA JMP $BA28       do convert AY, FCA1*(AY)
                                do series evaluation
.,E059 85 71    STA $71         save count pointer low byte
.,E05B 84 72    STY $72         save count pointer high byte
                                do series evaluation
.,E05D 20 C7 BB JSR $BBC7       pack FAC1 into $5C
.,E060 B1 71    LDA ($71),Y     get constants count
.,E062 85 67    STA $67         save constants count
.,E064 A4 71    LDY $71         get count pointer low byte
.,E066 C8       INY             increment it (now constants pointer)
.,E067 98       TYA             copy it
.,E068 D0 02    BNE $E06C       skip next if no overflow
.,E06A E6 72    INC $72         else increment high byte
.,E06C 85 71    STA $71         save low byte
.,E06E A4 72    LDY $72         get high byte
.,E070 20 28 BA JSR $BA28       do convert AY, FCA1*(AY)
.,E073 A5 71    LDA $71         get constants pointer low byte
.,E075 A4 72    LDY $72         get constants pointer high byte
.,E077 18       CLC             clear carry for add
.,E078 69 05    ADC #$05        +5 to low pointer (5 bytes per constant)
.,E07A 90 01    BCC $E07D       skip next if no overflow
.,E07C C8       INY             increment high byte
.,E07D 85 71    STA $71         save pointer low byte
.,E07F 84 72    STY $72         save pointer high byte
.,E081 20 67 B8 JSR $B867       add (AY) to FAC1
.,E084 A9 5C    LDA #$5C        set pointer low byte to partial
.,E086 A0 00    LDY #$00        set pointer high byte to partial
.,E088 C6 67    DEC $67         decrement constants count
.,E08A D0 E4    BNE $E070       loop until all done
.,E08C 60       RTS             

                                *** RND values
.:E08D 98 35 44 7A 00           11879546            multiplier
.:E092 68 28 B1 46 00           3.927677739E-8      offset

                                *** perform RND()
.,E097 20 2B BC JSR $BC2B       get FAC1 sign
                                return A = $FF -ve, A = $01 +ve
.,E09A 30 37    BMI $E0D3       if n<0 copy byte swapped FAC1 into RND() seed
.,E09C D0 20    BNE $E0BE       if n>0 get next number in RND() sequence
                                else n=0 so get the RND() number from VIA 1 timers
.,E09E 20 F3 FF JSR $FFF3       return base address of I/O devices
.,E0A1 86 22    STX $22         save pointer low byte
.,E0A3 84 23    STY $23         save pointer high byte
.,E0A5 A0 04    LDY #$04        set index to T1 low byte
.,E0A7 B1 22    LDA ($22),Y     get T1 low byte
.,E0A9 85 62    STA $62         save FAC1 mantissa 1
.,E0AB C8       INY             increment index
.,E0AC B1 22    LDA ($22),Y     get T1 high byte
.,E0AE 85 64    STA $64         save FAC1 mantissa 3
.,E0B0 A0 08    LDY #$08        set index to T2 low byte
.,E0B2 B1 22    LDA ($22),Y     get T2 low byte
.,E0B4 85 63    STA $63         save FAC1 mantissa 2
.,E0B6 C8       INY             increment index
.,E0B7 B1 22    LDA ($22),Y     get T2 high byte
.,E0B9 85 65    STA $65         save FAC1 mantissa 4
.,E0BB 4C E3 E0 JMP $E0E3       set exponent and exit
.,E0BE A9 8B    LDA #$8B        set seed pointer low address
.,E0C0 A0 00    LDY #$00        set seed pointer high address
.,E0C2 20 A2 BB JSR $BBA2       unpack memory (AY) into FAC1
.,E0C5 A9 8D    LDA #$8D        set 11879546 pointer low byte
.,E0C7 A0 E0    LDY #$E0        set 11879546 pointer high byte
.,E0C9 20 28 BA JSR $BA28       do convert AY, FCA1*(AY)
.,E0CC A9 92    LDA #$92        set 3.927677739E-8 pointer low byte
.,E0CE A0 E0    LDY #$E0        set 3.927677739E-8 pointer high byte
.,E0D0 20 67 B8 JSR $B867       add (AY) to FAC1
.,E0D3 A6 65    LDX $65         get FAC1 mantissa 4
.,E0D5 A5 62    LDA $62         get FAC1 mantissa 1
.,E0D7 85 65    STA $65         save FAC1 mantissa 4
.,E0D9 86 62    STX $62         save FAC1 mantissa 1
.,E0DB A6 63    LDX $63         get FAC1 mantissa 2
.,E0DD A5 64    LDA $64         get FAC1 mantissa 3
.,E0DF 85 63    STA $63         save FAC1 mantissa 2
.,E0E1 86 64    STX $64         save FAC1 mantissa 3
.,E0E3 A9 00    LDA #$00        clear byte
.,E0E5 85 66    STA $66         clear FAC1 sign (always +ve)
.,E0E7 A5 61    LDA $61         get FAC1 exponent
.,E0E9 85 70    STA $70         save FAC1 rounding byte
.,E0EB A9 80    LDA #$80        set exponent = $80
.,E0ED 85 61    STA $61         save FAC1 exponent
.,E0EF 20 D7 B8 JSR $B8D7       normalise FAC1
.,E0F2 A2 8B    LDX #$8B        set seed pointer low address
.,E0F4 A0 00    LDY #$00        set seed pointer high address

                                *** pack FAC1 into (XY)
.,E0F6 4C D4 BB JMP $BBD4       pack FAC1 into (XY)

                                *** handle BASIC I/O error
.,E0F9 C9 F0    CMP #$F0        compare error with $F0
.,E0FB D0 07    BNE $E104       branch if not $F0
.,E0FD 84 38    STY $38         set end of memory high byte
.,E0FF 86 37    STX $37         set end of memory low byte
.,E101 4C 63 A6 JMP $A663       clear from start to end and return
                                error was not $F0
.,E104 AA       TAX             copy error #
.,E105 D0 02    BNE $E109       branch if not $00
.,E107 A2 1E    LDX #$1E        else error $1E, break error
.,E109 4C 37 A4 JMP $A437       do error #X then warm start

                                *** output character to channel with error check
.,E10C 20 D2 FF JSR $FFD2       output character to channel
.,E10F B0 E8    BCS $E0F9       if error go handle BASIC I/O error
.,E111 60       RTS             

                                *** input character from channel with error check
.,E112 20 CF FF JSR $FFCF       input character from channel
.,E115 B0 E2    BCS $E0F9       if error go handle BASIC I/O error
.,E117 60       RTS             

                                *** open channel for output with error check
.,E118 20 AD E4 JSR $E4AD       open channel for output
.,E11B B0 DC    BCS $E0F9       if error go handle BASIC I/O error
.,E11D 60       RTS             

                                *** open channel for input with error check
.,E11E 20 C6 FF JSR $FFC6       open channel for input
.,E121 B0 D6    BCS $E0F9       if error go handle BASIC I/O error
.,E123 60       RTS             

                                *** get character from input device with error check
.,E124 20 E4 FF JSR $FFE4       get character from input device
.,E127 B0 D0    BCS $E0F9       if error go handle BASIC I/O error
.,E129 60       RTS             

                                *** perform SYS
.,E12A 20 8A AD JSR $AD8A       evaluate expression and check is numeric, else do
                                type mismatch
.,E12D 20 F7 B7 JSR $B7F7       convert FAC_1 to integer in temporary integer
.,E130 A9 E1    LDA #$E1        get return address high byte
.,E132 48       PHA             push as return address
.,E133 A9 46    LDA #$46        get return address low byte
.,E135 48       PHA             push as return address
.,E136 AD 0F 03 LDA $030F       get saved status register
.,E139 48       PHA             put on stack
.,E13A AD 0C 03 LDA $030C       get saved A
.,E13D AE 0D 03 LDX $030D       get saved X
.,E140 AC 0E 03 LDY $030E       get saved Y
.,E143 28       PLP             pull processor status
.,E144 6C 14 00 JMP ($0014)     call SYS address
                                tail end of SYS code
.,E147 08       PHP             save status
.,E148 8D 0C 03 STA $030C       save returned A
.,E14B 8E 0D 03 STX $030D       save returned X
.,E14E 8C 0E 03 STY $030E       save returned Y
.,E151 68       PLA             restore saved status
.,E152 8D 0F 03 STA $030F       save status
.,E155 60       RTS             

                                *** perform SAVE
.,E156 20 D4 E1 JSR $E1D4       get parameters for LOAD/SAVE
.,E159 A6 2D    LDX $2D         get start of variables low byte
.,E15B A4 2E    LDY $2E         get start of variables high byte
.,E15D A9 2B    LDA #$2B        index to start of program memory
.,E15F 20 D8 FF JSR $FFD8       save RAM to device, A = index to start address, XY = end
                                address low/high
.,E162 B0 95    BCS $E0F9       if error go handle BASIC I/O error
.,E164 60       RTS             

                                *** perform VERIFY
.,E165 A9 01    LDA #$01        flag verify
.:E167 2C       .BYTE $2C       makes next line BIT $00A9

                                *** perform LOAD
.,E168 A9 00    LDA #$00        flag load
.,E16A 85 0A    STA $0A         set load/verify flag
.,E16C 20 D4 E1 JSR $E1D4       get parameters for LOAD/SAVE
.,E16F A5 0A    LDA $0A         get load/verify flag
.,E171 A6 2B    LDX $2B         get start of memory low byte
.,E173 A4 2C    LDY $2C         get start of memory high byte
.,E175 20 D5 FF JSR $FFD5       load RAM from a device
.,E178 B0 57    BCS $E1D1       if error go handle BASIC I/O error
.,E17A A5 0A    LDA $0A         get load/verify flag
.,E17C F0 17    BEQ $E195       branch if load
.,E17E A2 1C    LDX #$1C        error $1C, verify error
.,E180 20 B7 FF JSR $FFB7       read I/O status word
.,E183 29 10    AND #$10        mask for tape read error
.,E185 D0 17    BNE $E19E       branch if no read error
.,E187 A5 7A    LDA $7A         get the BASIC execute pointer low byte
                                is this correct ?? won't this mean the "OK" prompt
                                when doing a load from within a program ?
.,E189 C9 02    CMP #$02        
.,E18B F0 07    BEQ $E194       if ?? skip "OK" prompt
.,E18D A9 64    LDA #$64        set "OK" pointer low byte
.,E18F A0 A3    LDY #$A3        set "OK" pointer high byte
.,E191 4C 1E AB JMP $AB1E       print null terminated string
.,E194 60       RTS             

                                *** do READY return to BASIC
.,E195 20 B7 FF JSR $FFB7       read I/O status word
.,E198 29 BF    AND #$BF        mask x0xx xxxx, clear read error
.,E19A F0 05    BEQ $E1A1       branch if no errors
.,E19C A2 1D    LDX #$1D        error $1D, load error
.,E19E 4C 37 A4 JMP $A437       do error #X then warm start
.,E1A1 A5 7B    LDA $7B         get BASIC execute pointer high byte
.,E1A3 C9 02    CMP #$02        compare with $02xx
.,E1A5 D0 0E    BNE $E1B5       branch if not immediate mode
.,E1A7 86 2D    STX $2D         set start of variables low byte
.,E1A9 84 2E    STY $2E         set start of variables high byte
.,E1AB A9 76    LDA #$76        set "READY." pointer low byte
.,E1AD A0 A3    LDY #$A3        set "READY." pointer high byte
.,E1AF 20 1E AB JSR $AB1E       print null terminated string
.,E1B2 4C 2A A5 JMP $A52A       reset execution, clear variables, flush stack,
                                rebuild BASIC chain and do warm start
.,E1B5 20 8E A6 JSR $A68E       set BASIC execute pointer to start of memory - 1
.,E1B8 20 33 A5 JSR $A533       rebuild BASIC line chaining
.,E1BB 4C 77 A6 JMP $A677       rebuild BASIC line chaining, do RESTORE and return

                                *** perform OPEN
.,E1BE 20 19 E2 JSR $E219       get parameters for OPEN/CLOSE
.,E1C1 20 C0 FF JSR $FFC0       open a logical file
.,E1C4 B0 0B    BCS $E1D1       branch if error
.,E1C6 60       RTS             

                                *** perform CLOSE
.,E1C7 20 19 E2 JSR $E219       get parameters for OPEN/CLOSE
.,E1CA A5 49    LDA $49         get logical file number
.,E1CC 20 C3 FF JSR $FFC3       close a specified logical file
.,E1CF 90 C3    BCC $E194       exit if no error
.,E1D1 4C F9 E0 JMP $E0F9       go handle BASIC I/O error
