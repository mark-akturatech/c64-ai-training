
                                *** open channel for input
.,F20E 20 0F F3 JSR $F30F       find a file
.,F211 F0 03    BEQ $F216       if the file is open continue
.,F213 4C 01 F7 JMP $F701       else do 'file not open' error and return
.,F216 20 1F F3 JSR $F31F       set file details from table,X
.,F219 A5 BA    LDA $BA         get the device number
.,F21B F0 16    BEQ $F233       if the device was the keyboard save the device #, flag
                                ok and exit
.,F21D C9 03    CMP #$03        compare the device number with the screen
.,F21F F0 12    BEQ $F233       if the device was the screen save the device #, flag ok
                                and exit
.,F221 B0 14    BCS $F237       if the device was a serial bus device go ??
.,F223 C9 02    CMP #$02        else compare the device with the RS232 device
.,F225 D0 03    BNE $F22A       if not the RS232 device continue
.,F227 4C 4D F0 JMP $F04D       else go get input from the RS232 buffer and return
.,F22A A6 B9    LDX $B9         get the secondary address
.,F22C E0 60    CPX #$60        
.,F22E F0 03    BEQ $F233       
.,F230 4C 0A F7 JMP $F70A       go do 'not input file' error and return
.,F233 85 99    STA $99         save the input device number
.,F235 18       CLC             flag ok
.,F236 60       RTS             
                                the device was a serial bus device
.,F237 AA       TAX             copy device number to X
.,F238 20 09 ED JSR $ED09       command serial bus device to TALK
.,F23B A5 B9    LDA $B9         get the secondary address
.,F23D 10 06    BPL $F245       
.,F23F 20 CC ED JSR $EDCC       wait for the serial bus end after send
.,F242 4C 48 F2 JMP $F248       
.,F245 20 C7 ED JSR $EDC7       send secondary address after TALK
.,F248 8A       TXA             copy device back to A
.,F249 24 90    BIT $90         test the serial status byte
.,F24B 10 E6    BPL $F233       if device present save device number and exit
.,F24D 4C 07 F7 JMP $F707       do 'device not present' error and return

                                *** open channel for output
.,F250 20 0F F3 JSR $F30F       find a file
.,F253 F0 03    BEQ $F258       if file found continue
.,F255 4C 01 F7 JMP $F701       else do 'file not open' error and return
.,F258 20 1F F3 JSR $F31F       set file details from table,X
.,F25B A5 BA    LDA $BA         get the device number
.,F25D D0 03    BNE $F262       if the device is not the keyboard go ??
.,F25F 4C 0D F7 JMP $F70D       go do 'not output file' error and return
.,F262 C9 03    CMP #$03        compare the device with the screen
.,F264 F0 0F    BEQ $F275       if the device is the screen go save output the output
                                device number and exit
.,F266 B0 11    BCS $F279       if > screen then go handle a serial bus device
.,F268 C9 02    CMP #$02        compare the device with the RS232 device
.,F26A D0 03    BNE $F26F       if not the RS232 device then it must be the tape device
.,F26C 4C E1 EF JMP $EFE1       else go open RS232 channel for output
                                open a tape channel for output
.,F26F A6 B9    LDX $B9         get the secondary address
.,F271 E0 60    CPX #$60        
.,F273 F0 EA    BEQ $F25F       if ?? do not output file error and return
.,F275 85 9A    STA $9A         save the output device number
.,F277 18       CLC             flag ok
.,F278 60       RTS             
.,F279 AA       TAX             copy the device number
.,F27A 20 0C ED JSR $ED0C       command devices on the serial bus to LISTEN
.,F27D A5 B9    LDA $B9         get the secondary address
.,F27F 10 05    BPL $F286       if address to send go ??
.,F281 20 BE ED JSR $EDBE       else set serial ATN high
.,F284 D0 03    BNE $F289       go ??, branch always
.,F286 20 B9 ED JSR $EDB9       send secondary address after LISTEN
.,F289 8A       TXA             copy device number back to A
.,F28A 24 90    BIT $90         test the serial status byte
.,F28C 10 E7    BPL $F275       if the device is present go save the output device number
                                and exit
.,F28E 4C 07 F7 JMP $F707       else do 'device not present error' and return

                                *** close a specified logical file
.,F291 20 14 F3 JSR $F314       find file A
.,F294 F0 02    BEQ $F298       if file found go close it
.,F296 18       CLC             else the file was closed so just flag ok
.,F297 60       RTS             
                                file found so close it
.,F298 20 1F F3 JSR $F31F       set file details from table,X
.,F29B 8A       TXA             copy file index to A
.,F29C 48       PHA             save file index
.,F29D A5 BA    LDA $BA         get the device number
.,F29F F0 50    BEQ $F2F1       if it is the keyboard go restore the index and close the
                                file
.,F2A1 C9 03    CMP #$03        compare the device number with the screen
.,F2A3 F0 4C    BEQ $F2F1       if it is the screen go restore the index and close the
                                file
.,F2A5 B0 47    BCS $F2EE       if > screen go do serial bus device close
.,F2A7 C9 02    CMP #$02        compare the device with the RS232 device
.,F2A9 D0 1D    BNE $F2C8       if not the RS232 device go ??
                                else close RS232 device
.,F2AB 68       PLA             restore file index
.,F2AC 20 F2 F2 JSR $F2F2       close file index X
.,F2AF 20 83 F4 JSR $F483       initialise RS232 output
.,F2B2 20 27 FE JSR $FE27       read the top of memory
.,F2B5 A5 F8    LDA $F8         get the RS232 input buffer pointer high byte
.,F2B7 F0 01    BEQ $F2BA       if no RS232 input buffer go ??
.,F2B9 C8       INY             else reclaim RS232 input buffer memory
.,F2BA A5 FA    LDA $FA         get the RS232 output buffer pointer high byte
.,F2BC F0 01    BEQ $F2BF       if no RS232 output buffer skip the reclaim
.,F2BE C8       INY             else reclaim the RS232 output buffer memory
.,F2BF A9 00    LDA #$00        clear A
.,F2C1 85 F8    STA $F8         clear the RS232 input buffer pointer high byte
.,F2C3 85 FA    STA $FA         clear the RS232 output buffer pointer high byte
.,F2C5 4C 7D F4 JMP $F47D       go set the top of memory to F0xx
                                is not the RS232 device
.,F2C8 A5 B9    LDA $B9         get the secondary address
.,F2CA 29 0F    AND #$0F        mask the device #
.,F2CC F0 23    BEQ $F2F1       if ?? restore index and close file
.,F2CE 20 D0 F7 JSR $F7D0       get tape buffer start pointer in XY
.,F2D1 A9 00    LDA #$00        character $00
.,F2D3 38       SEC             flag the tape device
.,F2D4 20 DD F1 JSR $F1DD       output the character to the cassette or RS232 device
.,F2D7 20 64 F8 JSR $F864       initiate tape write
.,F2DA 90 04    BCC $F2E0       
.,F2DC 68       PLA             
.,F2DD A9 00    LDA #$00        
.,F2DF 60       RTS             
.,F2E0 A5 B9    LDA $B9         get the secondary address
.,F2E2 C9 62    CMP #$62        
.,F2E4 D0 0B    BNE $F2F1       if not ?? restore index and close file
.,F2E6 A9 05    LDA #$05        set logical end of the tape
.,F2E8 20 6A F7 JSR $F76A       write tape header
.,F2EB 4C F1 F2 JMP $F2F1       restore index and close file

                                *** serial bus device close
.,F2EE 20 42 F6 JSR $F642       close serial bus device
.,F2F1 68       PLA             restore file index

                                *** close file index X
.,F2F2 AA       TAX             copy index to file to close
.,F2F3 C6 98    DEC $98         decrement the open file count
.,F2F5 E4 98    CPX $98         compare the index with the open file count
.,F2F7 F0 14    BEQ $F30D       exit if equal, last entry was closing file
                                else entry was not last in list so copy last table entry
                                file details over the details of the closing one
.,F2F9 A4 98    LDY $98         get the open file count as index
.,F2FB B9 59 02 LDA $0259,Y     get last+1 logical file number from logical file table
.,F2FE 9D 59 02 STA $0259,X     save logical file number over closed file
.,F301 B9 63 02 LDA $0263,Y     get last+1 device number from device number table
.,F304 9D 63 02 STA $0263,X     save device number over closed file
.,F307 B9 6D 02 LDA $026D,Y     get last+1 secondary address from secondary address table
.,F30A 9D 6D 02 STA $026D,X     save secondary address over closed file
.,F30D 18       CLC             flag ok
.,F30E 60       RTS             

                                *** find a file
.,F30F A9 00    LDA #$00        clear A
.,F311 85 90    STA $90         clear the serial status byte
.,F313 8A       TXA             copy the logical file number to A

                                *** find file A
.,F314 A6 98    LDX $98         get the open file count
.,F316 CA       DEX             decrememnt the count to give the index
.,F317 30 15    BMI $F32E       if no files just exit
.,F319 DD 59 02 CMP $0259,X     compare the logical file number with the table logical
                                file number
.,F31C D0 F8    BNE $F316       if no match go try again
.,F31E 60       RTS             

                                *** set file details from table,X
.,F31F BD 59 02 LDA $0259,X     get logical file from logical file table
.,F322 85 B8    STA $B8         save the logical file
.,F324 BD 63 02 LDA $0263,X     get device number from device number table
.,F327 85 BA    STA $BA         save the device number
.,F329 BD 6D 02 LDA $026D,X     get secondary address from secondary address table
.,F32C 85 B9    STA $B9         save the secondary address
.,F32E 60       RTS             

                                *** close all channels and files
.,F32F A9 00    LDA #$00        clear A
.,F331 85 98    STA $98         clear the open file count

                                *** close input and output channels
.,F333 A2 03    LDX #$03        set the screen device
.,F335 E4 9A    CPX $9A         compare the screen with the output device number
.,F337 B0 03    BCS $F33C       if <= screen skip the serial bus unlisten
.,F339 20 FE ED JSR $EDFE       else command the serial bus to UNLISTEN
.,F33C E4 99    CPX $99         compare the screen with the input device number
.,F33E B0 03    BCS $F343       if <= screen skip the serial bus untalk
.,F340 20 EF ED JSR $EDEF       else command the serial bus to UNTALK
.,F343 86 9A    STX $9A         save the screen as the output device number
.,F345 A9 00    LDA #$00        set the keyboard as the input device
.,F347 85 99    STA $99         save the input device number
.,F349 60       RTS             

                                *** open a logical file
.,F34A A6 B8    LDX $B8         get the logical file
.,F34C D0 03    BNE $F351       if there is a file continue
.,F34E 4C 0A F7 JMP $F70A       else do 'not input file error' and return
.,F351 20 0F F3 JSR $F30F       find a file
.,F354 D0 03    BNE $F359       if file not found continue
.,F356 4C FE F6 JMP $F6FE       else do 'file already open' error and return
.,F359 A6 98    LDX $98         get the open file count
.,F35B E0 0A    CPX #$0A        compare it with the maximum + 1
.,F35D 90 03    BCC $F362       if less than maximum + 1 go open the file
.,F35F 4C FB F6 JMP $F6FB       else do 'too many files error' and return
.,F362 E6 98    INC $98         increment the open file count
.,F364 A5 B8    LDA $B8         get the logical file
.,F366 9D 59 02 STA $0259,X     save it to the logical file table
.,F369 A5 B9    LDA $B9         get the secondary address
.,F36B 09 60    ORA #$60        OR with the OPEN CHANNEL command
.,F36D 85 B9    STA $B9         save the secondary address
.,F36F 9D 6D 02 STA $026D,X     save it to the secondary address table
.,F372 A5 BA    LDA $BA         get the device number
.,F374 9D 63 02 STA $0263,X     save it to the device number table
.,F377 F0 5A    BEQ $F3D3       if it is the keyboard go do the ok exit
.,F379 C9 03    CMP #$03        compare the device number with the screen
.,F37B F0 56    BEQ $F3D3       if it is the screen go do the ok exit
.,F37D 90 05    BCC $F384       if tape or RS232 device go ??
                                else it is a serial bus device
.,F37F 20 D5 F3 JSR $F3D5       send the secondary address and filename
.,F382 90 4F    BCC $F3D3       go do ok exit, branch always
.,F384 C9 02    CMP #$02        
.,F386 D0 03    BNE $F38B       
.,F388 4C 09 F4 JMP $F409       go open RS232 device and return
.,F38B 20 D0 F7 JSR $F7D0       get tape buffer start pointer in XY
.,F38E B0 03    BCS $F393       if >= $0200 go ??
.,F390 4C 13 F7 JMP $F713       else do 'illegal device number' and return
.,F393 A5 B9    LDA $B9         get the secondary address
.,F395 29 0F    AND #$0F        
.,F397 D0 1F    BNE $F3B8       
.,F399 20 17 F8 JSR $F817       wait for PLAY
.,F39C B0 36    BCS $F3D4       exit if STOP was pressed
.,F39E 20 AF F5 JSR $F5AF       print "Searching..."
.,F3A1 A5 B7    LDA $B7         get file name length
.,F3A3 F0 0A    BEQ $F3AF       if null file name just go find header
.,F3A5 20 EA F7 JSR $F7EA       find specific tape header
.,F3A8 90 18    BCC $F3C2       branch if no error
.,F3AA F0 28    BEQ $F3D4       exit if ??
.,F3AC 4C 04 F7 JMP $F704       do file not found error and return
.,F3AF 20 2C F7 JSR $F72C       find tape header, exit with header in buffer
.,F3B2 F0 20    BEQ $F3D4       exit if end of tape found
.,F3B4 90 0C    BCC $F3C2       
.,F3B6 B0 F4    BCS $F3AC       
.,F3B8 20 38 F8 JSR $F838       wait for PLAY/RECORD
.,F3BB B0 17    BCS $F3D4       exit if STOP was pressed
.,F3BD A9 04    LDA #$04        set data file header
.,F3BF 20 6A F7 JSR $F76A       write tape header
.,F3C2 A9 BF    LDA #$BF        
.,F3C4 A4 B9    LDY $B9         get the secondary address
.,F3C6 C0 60    CPY #$60        
.,F3C8 F0 07    BEQ $F3D1       
.,F3CA A0 00    LDY #$00        clear index
.,F3CC A9 02    LDA #$02        
.,F3CE 91 B2    STA ($B2),Y     save to tape buffer
.,F3D0 98       TYA             clear A
.,F3D1 85 A6    STA $A6         save tape buffer index
.,F3D3 18       CLC             flag ok
.,F3D4 60       RTS             
