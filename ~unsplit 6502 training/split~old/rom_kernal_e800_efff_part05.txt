
                                *** command serial bus to UNLISTEN
.,EDFE A9 3F    LDA #$3F        set the UNLISTEN command
.,EE00 20 11 ED JSR $ED11       send a control character
.,EE03 20 BE ED JSR $EDBE       set serial ATN high
                                1ms delay, clock high then data high
.,EE06 8A       TXA             save the device number
.,EE07 A2 0A    LDX #$0A        short delay
.,EE09 CA       DEX             decrement the count
.,EE0A D0 FD    BNE $EE09       loop if not all done
.,EE0C AA       TAX             restore the device number
.,EE0D 20 85 EE JSR $EE85       set the serial clock out high
.,EE10 4C 97 EE JMP $EE97       set the serial data out high and return

                                *** input a byte from the serial bus
.,EE13 78       SEI             disable the interrupts
.,EE14 A9 00    LDA #$00        set 0 bits to do, will flag EOI on timeour
.,EE16 85 A5    STA $A5         save the serial bus bit count
.,EE18 20 85 EE JSR $EE85       set the serial clock out high
.,EE1B 20 A9 EE JSR $EEA9       get the serial data status in Cb
.,EE1E 10 FB    BPL $EE1B       loop if the serial clock is low
.,EE20 A9 01    LDA #$01        set the timeout count high byte
.,EE22 8D 07 DC STA $DC07       save VIA 1 timer B high byte
.,EE25 A9 19    LDA #$19        load timer B, timer B single shot, start timer B
.,EE27 8D 0F DC STA $DC0F       save VIA 1 CRB
.,EE2A 20 97 EE JSR $EE97       set the serial data out high
.,EE2D AD 0D DC LDA $DC0D       read VIA 1 ICR
.,EE30 AD 0D DC LDA $DC0D       read VIA 1 ICR
.,EE33 29 02    AND #$02        mask 0000 00x0, timer A interrupt
.,EE35 D0 07    BNE $EE3E       if timer A interrupt go ??
.,EE37 20 A9 EE JSR $EEA9       get the serial data status in Cb
.,EE3A 30 F4    BMI $EE30       loop if the serial clock is low
.,EE3C 10 18    BPL $EE56       else go set 8 bits to do, branch always
                                timer A timed out
.,EE3E A5 A5    LDA $A5         get the serial bus bit count
.,EE40 F0 05    BEQ $EE47       if not already EOI then go flag EOI
.,EE42 A9 02    LDA #$02        else error $02, read timeour
.,EE44 4C B2 ED JMP $EDB2       set the serial status and exit
.,EE47 20 A0 EE JSR $EEA0       set the serial data out low
.,EE4A 20 85 EE JSR $EE85       set the serial clock out high
.,EE4D A9 40    LDA #$40        set EOI
.,EE4F 20 1C FE JSR $FE1C       OR into the serial status byte
.,EE52 E6 A5    INC $A5         increment the serial bus bit count, do error on the next
                                timeout
.,EE54 D0 CA    BNE $EE20       go try again, branch always
.,EE56 A9 08    LDA #$08        set 8 bits to do
.,EE58 85 A5    STA $A5         save the serial bus bit count
.,EE5A AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EE5D CD 00 DD CMP $DD00       compare it with itself
.,EE60 D0 F8    BNE $EE5A       if changing go try again
.,EE62 0A       ASL             shift the serial data into the carry
.,EE63 10 F5    BPL $EE5A       loop while the serial clock is low
.,EE65 66 A4    ROR $A4         shift the data bit into the receive byte
.,EE67 AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EE6A CD 00 DD CMP $DD00       compare it with itself
.,EE6D D0 F8    BNE $EE67       if changing go try again
.,EE6F 0A       ASL             shift the serial data into the carry
.,EE70 30 F5    BMI $EE67       loop while the serial clock is high
.,EE72 C6 A5    DEC $A5         decrement the serial bus bit count
.,EE74 D0 E4    BNE $EE5A       loop if not all done
.,EE76 20 A0 EE JSR $EEA0       set the serial data out low
.,EE79 24 90    BIT $90         test the serial status byte
.,EE7B 50 03    BVC $EE80       if EOI not set skip the bus end sequence
.,EE7D 20 06 EE JSR $EE06       1ms delay, clock high then data high
.,EE80 A5 A4    LDA $A4         get the receive byte
.,EE82 58       CLI             enable the interrupts
.,EE83 18       CLC             flag ok
.,EE84 60       RTS             

                                *** set the serial clock out high
.,EE85 AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EE88 29 EF    AND #$EF        mask xxx0 xxxx, set serial clock out high
.,EE8A 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,EE8D 60       RTS             

                                *** set the serial clock out low
.,EE8E AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EE91 09 10    ORA #$10        mask xxx1 xxxx, set serial clock out low
.,EE93 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,EE96 60       RTS             

                                *** set the serial data out high
.,EE97 AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EE9A 29 DF    AND #$DF        mask xx0x xxxx, set serial data out high
.,EE9C 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,EE9F 60       RTS             

                                *** set the serial data out low
.,EEA0 AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EEA3 09 20    ORA #$20        mask xx1x xxxx, set serial data out low
.,EEA5 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,EEA8 60       RTS             

                                *** get the serial data status in Cb
.,EEA9 AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EEAC CD 00 DD CMP $DD00       compare it with itself
.,EEAF D0 F8    BNE $EEA9       if changing got try again
.,EEB1 0A       ASL             shift the serial data into Cb
.,EEB2 60       RTS             

                                *** 1ms delay
.,EEB3 8A       TXA             save X
.,EEB4 A2 B8    LDX #$B8        set the loop count
.,EEB6 CA       DEX             decrement the loop count
.,EEB7 D0 FD    BNE $EEB6       loop if more to do
.,EEB9 AA       TAX             restore X
.,EEBA 60       RTS             

                                *** RS232 Tx NMI routine
.,EEBB A5 B4    LDA $B4         get RS232 bit count
.,EEBD F0 47    BEQ $EF06       if zero go setup next RS232 Tx byte and return
.,EEBF 30 3F    BMI $EF00       if -ve go do stop bit(s)
                                else bit count is non zero and +ve
.,EEC1 46 B6    LSR $B6         shift RS232 output byte buffer
.,EEC3 A2 00    LDX #$00        set $00 for bit = 0
.,EEC5 90 01    BCC $EEC8       branch if bit was 0
.,EEC7 CA       DEX             set $FF for bit = 1
.,EEC8 8A       TXA             copy bit to A
.,EEC9 45 BD    EOR $BD         EOR with RS232 parity byte
.,EECB 85 BD    STA $BD         save RS232 parity byte
.,EECD C6 B4    DEC $B4         decrement RS232 bit count
.,EECF F0 06    BEQ $EED7       if RS232 bit count now zero go do parity bit
                                save bit and exit
.,EED1 8A       TXA             copy bit to A
.,EED2 29 04    AND #$04        mask 0000 0x00, RS232 Tx DATA bit
.,EED4 85 B5    STA $B5         save the next RS232 data bit to send
.,EED6 60       RTS             

                                *** do RS232 parity bit, enters with RS232 bit count = 0
.,EED7 A9 20    LDA #$20        mask 00x0 0000, parity enable bit
.,EED9 2C 94 02 BIT $0294       test the pseudo 6551 command register
.,EEDC F0 14    BEQ $EEF2       if parity disabled go ??
.,EEDE 30 1C    BMI $EEFC       if fixed mark or space parity go ??
.,EEE0 70 14    BVS $EEF6       if even parity go ??
                                else odd parity
.,EEE2 A5 BD    LDA $BD         get RS232 parity byte
.,EEE4 D0 01    BNE $EEE7       if parity not zero leave parity bit = 0
.,EEE6 CA       DEX             make parity bit = 1
.,EEE7 C6 B4    DEC $B4         decrement RS232 bit count, 1 stop bit
.,EEE9 AD 93 02 LDA $0293       get pseudo 6551 control register
.,EEEC 10 E3    BPL $EED1       if 1 stop bit save parity bit and exit
                                else two stop bits ..
.,EEEE C6 B4    DEC $B4         decrement RS232 bit count, 2 stop bits
.,EEF0 D0 DF    BNE $EED1       save bit and exit, branch always
                                parity is disabled so the parity bit becomes the first,
                                and possibly only, stop bit. to do this increment the bit
                                count which effectively decrements the stop bit count.
.,EEF2 E6 B4    INC $B4         increment RS232 bit count, = -1 stop bit
.,EEF4 D0 F0    BNE $EEE6       set stop bit = 1 and exit
                                do even parity
.,EEF6 A5 BD    LDA $BD         get RS232 parity byte
.,EEF8 F0 ED    BEQ $EEE7       if parity zero leave parity bit = 0
.,EEFA D0 EA    BNE $EEE6       else make parity bit = 1, branch always
                                fixed mark or space parity
.,EEFC 70 E9    BVS $EEE7       if fixed space parity leave parity bit = 0
.,EEFE 50 E6    BVC $EEE6       else fixed mark parity make parity bit = 1, branch always
                                decrement stop bit count, set stop bit = 1 and exit. $FF is one stop bit, $FE is two
                                stop bits
.,EF00 E6 B4    INC $B4         decrement RS232 bit count
.,EF02 A2 FF    LDX #$FF        set stop bit = 1
.,EF04 D0 CB    BNE $EED1       save stop bit and exit, branch always

                                *** setup next RS232 Tx byte
.,EF06 AD 94 02 LDA $0294       read the 6551 pseudo command register
.,EF09 4A       LSR             handshake bit inot Cb
.,EF0A 90 07    BCC $EF13       if 3 line interface go ??
.,EF0C 2C 01 DD BIT $DD01       test VIA 2 DRB, RS232 port
.,EF0F 10 1D    BPL $EF2E       if DSR = 0 set DSR signal not present and exit
.,EF11 50 1E    BVC $EF31       if CTS = 0 set CTS signal not present and exit
                                was 3 line interface
.,EF13 A9 00    LDA #$00        clear A
.,EF15 85 BD    STA $BD         clear the RS232 parity byte
.,EF17 85 B5    STA $B5         clear the RS232 next bit to send
.,EF19 AE 98 02 LDX $0298       get the number of bits to be sent/received
.,EF1C 86 B4    STX $B4         set the RS232 bit count
.,EF1E AC 9D 02 LDY $029D       get the index to the Tx buffer start
.,EF21 CC 9E 02 CPY $029E       compare it with the index to the Tx buffer end
.,EF24 F0 13    BEQ $EF39       if all done go disable T?? interrupt and return
.,EF26 B1 F9    LDA ($F9),Y     else get a byte from the buffer
.,EF28 85 B6    STA $B6         save it to the RS232 output byte buffer
.,EF2A EE 9D 02 INC $029D       increment the index to the Tx buffer start
.,EF2D 60       RTS             

                                *** set DSR signal not present
.,EF2E A9 40    LDA #$40        set DSR signal not present
.:EF30 2C       .BYTE $2C       makes next line BIT $10A9

                                *** set CTS signal not present
.,EF31 A9 10    LDA #$10        set CTS signal not present
.,EF33 0D 97 02 ORA $0297       OR it with the RS232 status register
.,EF36 8D 97 02 STA $0297       save the RS232 status register

                                *** disable timer A interrupt
.,EF39 A9 01    LDA #$01        disable timer A interrupt

                                *** set VIA 2 ICR from A
.,EF3B 8D 0D DD STA $DD0D       save VIA 2 ICR
.,EF3E 4D A1 02 EOR $02A1       EOR with the RS-232 interrupt enable byte
.,EF41 09 80    ORA #$80        set the interrupts enable bit
.,EF43 8D A1 02 STA $02A1       save the RS-232 interrupt enable byte
.,EF46 8D 0D DD STA $DD0D       save VIA 2 ICR
.,EF49 60       RTS             

                                *** compute bit count
.,EF4A A2 09    LDX #$09        set bit count to 9, 8 data + 1 stop bit
.,EF4C A9 20    LDA #$20        mask for 8/7 data bits
.,EF4E 2C 93 02 BIT $0293       test pseudo 6551 control register
.,EF51 F0 01    BEQ $EF54       branch if 8 bits
.,EF53 CA       DEX             else decrement count for 7 data bits
.,EF54 50 02    BVC $EF58       branch if 7 bits
.,EF56 CA       DEX             else decrement count ..
.,EF57 CA       DEX             .. for 5 data bits
.,EF58 60       RTS             

                                *** RS232 Rx NMI
.,EF59 A6 A9    LDX $A9         get start bit check flag
.,EF5B D0 33    BNE $EF90       if no start bit received go ??
.,EF5D C6 A8    DEC $A8         decrement receiver bit count in
.,EF5F F0 36    BEQ $EF97       if the byte is complete go add it to the buffer
.,EF61 30 0D    BMI $EF70       
.,EF63 A5 A7    LDA $A7         get the RS232 received data bit
.,EF65 45 AB    EOR $AB         EOR with the receiver parity bit
.,EF67 85 AB    STA $AB         save the receiver parity bit
.,EF69 46 A7    LSR $A7         shift the RS232 received data bit
.,EF6B 66 AA    ROR $AA         
.,EF6D 60       RTS             
.,EF6E C6 A8    DEC $A8         decrement receiver bit count in
.,EF70 A5 A7    LDA $A7         get the RS232 received data bit
.,EF72 F0 67    BEQ $EFDB       
.,EF74 AD 93 02 LDA $0293       get pseudo 6551 control register
.,EF77 0A       ASL             shift the stop bit flag to Cb
.,EF78 A9 01    LDA #$01        + 1
.,EF7A 65 A8    ADC $A8         add receiver bit count in
.,EF7C D0 EF    BNE $EF6D       exit, branch always

                                *** setup to receive an RS232 bit
.,EF7E A9 90    LDA #$90        enable FLAG interrupt
.,EF80 8D 0D DD STA $DD0D       save VIA 2 ICR
.,EF83 0D A1 02 ORA $02A1       OR with the RS-232 interrupt enable byte
.,EF86 8D A1 02 STA $02A1       save the RS-232 interrupt enable byte
.,EF89 85 A9    STA $A9         set start bit check flag, set no start bit received
.,EF8B A9 02    LDA #$02        disable timer B interrupt
.,EF8D 4C 3B EF JMP $EF3B       set VIA 2 ICR from A and return

                                *** no RS232 start bit received
.,EF90 A5 A7    LDA $A7         get the RS232 received data bit
.,EF92 D0 EA    BNE $EF7E       if ?? go setup to receive an RS232 bit and return
.,EF94 4C D3 E4 JMP $E4D3       flag the RS232 start bit and set the parity
