53266          $D012         RASTER
Read Current Raster Scan Line/Write Line to Compare for Raster IRQ

The Raster Compare register has two different functions, depending on
whether you are reading from it or writing to it.  When this register
is read, it tells which screen line the electron beam is currently
scanning.

There are 262 horizontal lines which make up the American (NTSC)
standard display screen (312 lines in the European or PAL standard
screen).  Every one of these lines is scanned and updated 60 times per
second.  Only 200 of these lines (numbers 50-249) are part of the
visible display.

It is sometimes helpful to know just what line is being scanned,
because changing screen graphics on a particular line while that line
is being scanned may cause a slight disruption on the screen.  By
reading this register, it is possible for a machine language program
to wait until the scan is off the bottom of the screen before changing
the graphics display.

It is even possible for a machine language program to read this
register, and change the screen display when a certain scan line is
reached.  The program below uses this technique to change the
background color in midscreen, in order to show all 256 combinations
of foreground and background text colors at once.

40 FOR I=49152 TO 49188:READ A:POKE I,A:NEXT:POKE 53280,11
50 PRINT CHR$(147):FOR I=1024 TO I+1000:POKE I,160:POKE I+54272,11:NEXT I
60 FOR I=0 TO 15:FOR J=0 TO 15
70 P=1196+(48*I)+J:POKE P,J+I:POKE P+54272,J:NEXT J,I
80 PRINT TAB(15)CHR$(5)"COLOR CHART":FOR I=1 TO 19:PRINT:NEXT
85 PRINT "THIS CHART SHOWS ALL COMBINATIONS OF   "
86 PRINT "FOREGROUND AND BACKGROUND COLORS.      "
87 PRINT "FOREGROUND INCREASES FROM LEFT TO RIGHT"
88 PRINT "BACKGROUND INCREASES FROM TOP TO BOTTOM"
90 SYS 12*4096
100 DATA 169,90,133,251,169,0,141,33,208,162,15,120,173,17,208,48
105 DATA 251,173,18,208
110 DATA 197,251,208,249,238,33,208,24,105,8,133,251,202,16,233,48,219

Writing to this register designates the comparison value for the
Raster Compare Interrupt.  When that interrupt is enabled, a maskable
interrupt request will be issued every time the electron beam scan
reaches the scan line whose number was written here.  This is a much
more flexible technique for changing the display in midscreen than
reading this register as the sample program above does.  That
technique requires that the program continuously watch the Raster
Register, while the interrupt method will call the program when the
time is right to act.  For more information on raster interrupts, see
the entry for the Interrupt Mask Register (53274, $D01A).

It is very important to remember that this register requires nine
bits, and that this location only holds eight of those bits (the ninth
is Bit 7 of 53265 ($D011)).  If you forget to read or write to the
ninth bit, your results could be in error by a factor of 256.

For example, some early programs written to demonstrate the raster
interrupt took for granted that the ninth bit of this register would
be set to 0 on power-up.  When a later version of the Kernal changed
this initial value to a 1, their interrupt routines, which were
supposed to set the raster interrupt to occur at scan line number 150,
ended up setting it for line number 406 instead.  Since the scan line
numbers do not go up that high, no interrupt request was ever issued
and the program did not work.

Location Range: 53267-53268 ($D013-$D014)
Light Pen Registers

A light pen is an input device that can be plugged into joystick
Control Port #1.  It is shaped like a pen and has a light-sensitive
device at its tip that causes the trigger switch of the joystick port
to close at the moment the electron beam that updates the screen
display strikes it.  The VIC-II chip keeps track of where the beam is
when that happens, and records the corresponding horizontal and
vertical screen coordinates in the registers at these locations.

A program can read the position at which the light pen is held up to
the screen.  The values in these registers are updated once every
screen frame (60 times per second).  Once the switch is closed and a
value written to these registers, the registers are latched, and
subsequent switch closings during the same screen frame will not be
recorded.

A given light pen may not be entirely accurate (and the operator may
not have a steady hand).  It is probably wise to average the positions
returned from a number of samplings, particularly when using a machine
language driver.

53267         $D013          LPENX
Light Pen Horizontal Position

This location holds the horizontal position of the light pen.  Since
there are only eight bits available (which give a range of 256 values)
for 320 possible horizontal screen positions, the value here is
accurate only to every second dot position.  The number here will
range from 0 to 160 and must be multiplied by 2 in order to get a
close approximation of the actual horizontal dot position of the light
pen.

53268         $D014          LPENY
Light Pen Vertical Position

This location holds the vertical position of the light pen.  Since
there are only 200 visible scan lines on the screen, the value in this
register corresponds exactly to the current raster scan line.

53269         $D015          SPENA
Sprite Enable Register

Bit 0:  Enable Sprite 0 (1=sprite is on, 0=sprite is off)
Bit 1:  Enable Sprite 1 (1=sprite is on, 0=sprite is off)
Bit 2:  Enable Sprite 2 (1=sprite is on, 0=sprite is off)
Bit 3:  Enable Sprite 3 (1=sprite is on, 0=sprite is off)
Bit 4:  Enable Sprite 4 (1=sprite is on, 0=sprite is off)
Bit 5:  Enable Sprite 5 (1=sprite is on, 0=sprite is off)
Bit 6:  Enable Sprite 6 (1=sprite is on, 0=sprite is off)
Bit 7:  Enable Sprite 7 (1=sprite is on, 0=sprite is off)

In order for any sprite to be displayed, the corresponding bit in this
register must be set to 1 (the default for this location is 0).  Of
course, just setting this bit along will not guarantee that a sprite
will be shown on the screen.  The Sprite Data Pointer must indicate a
data area that holds some values other than 0.  The Sprite Color
Register must also contain a value other than that of the background
color.  In addition, the Sprite Horizontal and Vertical Position
Registers must be set for positions that lie within the visible screen
range in order for a sprite to appear on screen.

53270         $D016          SCROLX
Horizontal Fine Scrolling and Control Register

Bits 0-2:  Fine scroll display horizontally by X dot positions (0-7)
Bit 3:  Select a 38-column or 40-column text display (1=40 columns,
  0=38 columns)
Bit 4:  Enable multicolor text or multicolor bitmap mode (1=multicolor on,
  0=multicolor off)
Bit 5:  Video chip reset (0=normal operations, 1=video completely off)
Bits 6-7:  Unused

This is one of the two important multifunction control registers on
the VIC-II chip.  On power-up, it is set to a default value of 8,
which means that the VIC chip Reset line is set for a normal display,
Multicolor Mode is disabled, a 40-column text display is selected, and
no horizontal fine-scroll offset is used.

Bits 0-2.  The first three bits of this chip control vertical fine
scrolling of the screen display.  This feature allows you to smoothly
move the entire text display back and forth, enabling the display area
to act as a window, scrolling over a larger text or character graphics
display.

Since each text character is eight dots wide, moving each character
over one whole character position (known as coarse scrolling) is a
relatively big jump, and the motion looks jerky.  By placing a number
from 1 to 7 into these three bits, you can move the whole screen
display from one to seven dot spaces to the right.

Stepping through values 1 to 7 allows you to smoothly make the
transition from having a character appear at one screen column to
having it appear at the next one over.  To demonstrate this, type in
the following program, LIST, and RUN it.

10 FOR I=1 TO 50:FOR J=0 TO 7
20 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I
30 FOR I=1 TO 50:FOR J=7 TO 0 STEP-1
40 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I

As you can see, after the display has moved over seven dots, it starts
over at its original position.  In order to continue with the scroll,
you must do a coarse scroll every time the value of the scroll bits
goes from 7 to 0, or from 0 to 7.  This is accomplished by moving each
byte of display data on each line over one position, overwriting the
last character, and introducing a new byte of data on the opposite end
of the screen line to replace it.

Obviously, only a machine language program can move all of these bytes
quickly enough to maintain the effect of smooth motion.  The following
BASIC program, however, will give you an idea of what the combination
of fine and coarse scrolling looks like.

10 POKE 53281,0:PRINT CHR$(5);CHR$(147):FOR I=1 TO 5:PRINT CHR$(17):NEXT
20 FOR I=1 TO 30
30 PRINT TAB(I-1)"{UP}{10 SPACES}{UP}"
40 WAIT53265,128:POKE53270,PEEK(53270)AND248:PRINTTAB(I)"AWAY WE GO"
50 FOR J=1 TO 7
60 POKE 53270,(PEEK(53270)AND248)+J
70 FORK=1TO30-I
80 NEXT K,J,I:RUN

Changing the value of the three horizontal scroll bits will affect the
entire screen display.  If you wish to scroll only a portion of the
screen, you will have to use raster interrupts (see 53274 ($D01A)
below) to establish a scroll zone, change the value of these scroll
bits only when that zone is being displayed, and change it back to 0
afterward.

Bit 3.  Bit 3 of this register allows you to cover up the first and
last columns of the screen display with the border.  Since the viewers
cannot see the characters there, they will not be able to see you
insert a new character on the end of the line when you do coarse
scrolling (see explanation of Bits 0-2 above).

Setting this bit to 1 enables the normal 40-column display, while
resetting it to 0 changes the display to 38 columns.  This is a purely
cosmetic aid, and it is not necessary to change the screen to the
smaller size to use the scrolling feature.

Bit 4.  This bit selects multicolor graphics.  The effect of setting
this bit to 1 depends on whether or not the bitmap graphics mode is
also enabled.

If you are not in bitmap mode, and you select multicolor text
character mode by setting this bit to 1, characters with a color
nybble whose value is less than 8 are displyed normally.  There will
be one background color and one foreground color.  But each dot of a
character with a color nybble whose value is over 7 can have any one
of four different colors.

The two colors in the Background Control Registers 1 and 2 (53282-3,
$D022-3) are available in addition to the colors supplied by the Color
RAM.  The price of these extra colors is a reduction in horizontal
resolution.  Instead of each bit controlling one dot, in multicolor
mode a pair of bits control the color of a larger dot.  A pattern of
11 will light it with the color from the lower three bits of color
RAM.  Patterns of 01 and 10 will select the colors from Background
Color Registers 1 and 2, respectively, for the double-width dot.

You can see the effect that setting this bit has by typing in the
following BASIC command line:

POKE 53270,PEEK(53280)OR16:PRINT CHR$(149)"THIS IS MULTICOLOR MODE"

It is obvious from this example that the normal set of text characters
was not made to be used in multicolor mode.  In order to take
advantage of this mode, you will need to design custom four-color
characters.  For more information, see the alternate entry for 53248
($D000), the Character Generator ROM.

If the multicolor and bitmap enable bits are both set to 1, the result
is a multicolor bitmap mode.  As in multicolor text mode, pairs of
graphics data bits are used to set each dot in a 4 by 8 matrix to one
of four colors.  This results in a reduction of the horizontal
resolution to 160 double-wide dots across.  But while text multicolor
mode allows only one of the four colors to be set individually for
each 4 by 8 dot area, bitmap multicolor mode allows up to three
different colors to be individually selected in each 4 by 8 dot area.
The source of the dot color for each bit-pair combination is shown
below:

00 Background Color Register 0 (53281, $D021)
01 Upper four bits of Video Matrix
10 Lower four bits of Video Matrix
11 Color RAM nybble (area starts at 55296 ($D800))

The fact that bit-pairs are used in this mode changes the strategy for
plotting somewhat.  In order to find the byte BY in which the desired
bit-pair resides, you must multiply the horizontal position X, which
has a value of 0- 159, by 2, and then use the same formula as for
hi-res bitmap mode.

Given that the horizontal position (0-159) of the dot is stored in the
variable X, its vertical position is in the variable Y, and the base
address of the bitmap area ia in the variable BASE, you can find the
desired byte with the formula:

BY=BASE+(Y AND 248)*40+(Y AND 7)+(2*X AND 504)

Setting the desired bit-pair will depend on what color you chose.
First, you must set up an array of bit masks.

CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64

To turn on the desired dot, select a color CO from 0 to 3
(representing the color selected by the corresponding bit pattern) and
execute the following statement:

BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR (CO*CA(BI))

The following program will demonstrate this technique:

10 CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64:REM ARRAY FOR BIT PAIRS
20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
30 POKE53265,PEEK(53265)OR32:POKE53270,PEEK(53270)OR16:REM MULTI-COLOR BIT MAP
40 A$="":FOR I=1 TO 37:A$=A$+"C":NEXT:PRINT CHR$(19);
50 FOR I=1 TO 27:PRINT A$;:NEXT:POKE 2023,PEEK(2022): REM SET COLOR MAP
60 A$="":FOR I=1 TO 128:A$=A$+"@":NEXT:FOR I=32 TO 63 STEP 2
70 POKE648,I:PRINTCHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLR HI-RES SCREEN
80 FOR CO=1TO3:FOR Y=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM
90 X=INT(10*CO+15*SIN(CO*45+Y/10)): REM SINE WAVE SHAPE
100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X*2 AND 504): REM FIND HI-RES BYTE
110 BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR(CO*CA(BI))
120 NEXT Y,CO
130 GOTO 130: REM LET IT STAY ON SCREEN

Bit 5:  Bit 5 controls the VIC-II chip Reset line.  Setting this bit
to 1 will completely stop the video chip from operating.  On older
64s, the screen will go black.  It should always be set to 0 to insure
normal operation of the chip.

Bits 6 and 7.  These bits are not used.

