# ROM KERNAL F800 FFFF
# Source: C64 ROM Disassembly

.,F801 D0 E7    BNE $F7EA       if no match go get next header
.,F803 E6 9E    INC $9E         else increment name buffer index
.,F805 E6 9F    INC $9F         increment tape buffer index
.,F807 A4 9E    LDY $9E         get name buffer index
.,F809 D0 EC    BNE $F7F7       loop, branch always
.,F80B 18       CLC             flag ok
.,F80C 60       RTS             

                                *** bump tape pointer
.,F80D 20 D0 F7 JSR $F7D0       get tape buffer start pointer in XY
.,F810 E6 A6    INC $A6         increment tape buffer index
.,F812 A4 A6    LDY $A6         get tape buffer index
.,F814 C0 C0    CPY #$C0        compare with buffer length
.,F816 60       RTS             

                                *** wait for PLAY
.,F817 20 2E F8 JSR $F82E       return cassette sense in Zb
.,F81A F0 1A    BEQ $F836       if switch closed just exit
                                cassette switch was open
.,F81C A0 1B    LDY #$1B        
                                index to "PRESS PLAY ON TAPE"
.,F81E 20 2F F1 JSR $F12F       display kernel I/O message
.,F821 20 D0 F8 JSR $F8D0       scan stop key and flag abort if pressed
                                note if STOP was pressed the return is to the
                                routine that called this one and not here
.,F824 20 2E F8 JSR $F82E       return cassette sense in Zb
.,F827 D0 F8    BNE $F821       loop if the cassette switch is open
.,F829 A0 6A    LDY #$6A        
                                index to "OK"
.,F82B 4C 2F F1 JMP $F12F       display kernel I/O message and return

                                *** return cassette sense in Zb
.,F82E A9 10    LDA #$10        set the mask for the cassette switch
.,F830 24 01    BIT $01         test the 6510 I/O port
.,F832 D0 02    BNE $F836       branch if cassette sense high
.,F834 24 01    BIT $01         test the 6510 I/O port
.,F836 18       CLC             
.,F837 60       RTS             

                                *** wait for PLAY/RECORD
.,F838 20 2E F8 JSR $F82E       return the cassette sense in Zb
.,F83B F0 F9    BEQ $F836       exit if switch closed
                                cassette switch was open
.,F83D A0 2E    LDY #$2E        
                                index to "PRESS RECORD & PLAY ON TAPE"
.,F83F D0 DD    BNE $F81E       display message and wait for switch, branch always

                                *** initiate a tape read
.,F841 A9 00    LDA #$00        clear A
.,F843 85 90    STA $90         clear serial status byte
.,F845 85 93    STA $93         clear the load/verify flag
.,F847 20 D7 F7 JSR $F7D7       set the tape buffer start and end pointers
.,F84A 20 17 F8 JSR $F817       wait for PLAY
.,F84D B0 1F    BCS $F86E       exit if STOP was pressed, uses a further BCS at the
                                target address to reach final target at $F8DC
.,F84F 78       SEI             disable interrupts
.,F850 A9 00    LDA #$00        clear A
.,F852 85 AA    STA $AA         
.,F854 85 B4    STA $B4         
.,F856 85 B0    STA $B0         clear tape timing constant min byte
.,F858 85 9E    STA $9E         clear tape pass 1 error log/char buffer
.,F85A 85 9F    STA $9F         clear tape pass 2 error log corrected
.,F85C 85 9C    STA $9C         clear byte received flag
.,F85E A9 90    LDA #$90        enable CA1 interrupt ??
.,F860 A2 0E    LDX #$0E        set index for tape read vector
.,F862 D0 11    BNE $F875       go do tape read/write, branch always

                                *** initiate a tape write
.,F864 20 D7 F7 JSR $F7D7       set tape buffer start and end pointers
                                do tape write, 20 cycle count
.,F867 A9 14    LDA #$14        set write lead cycle count
.,F869 85 AB    STA $AB         save write lead cycle count
                                do tape write, no cycle count set
.,F86B 20 38 F8 JSR $F838       wait for PLAY/RECORD
.,F86E B0 6C    BCS $F8DC       if STOPped clear save IRQ address and exit
.,F870 78       SEI             disable interrupts
.,F871 A9 82    LDA #$82        enable ?? interrupt
.,F873 A2 08    LDX #$08        set index for tape write tape leader vector

                                *** tape read/write
.,F875 A0 7F    LDY #$7F        disable all interrupts
.,F877 8C 0D DC STY $DC0D       save VIA 1 ICR, disable all interrupts
.,F87A 8D 0D DC STA $DC0D       save VIA 1 ICR, enable interrupts according to A
                                check RS232 bus idle
.,F87D AD 0E DC LDA $DC0E       read VIA 1 CRA
.,F880 09 19    ORA #$19        load timer B, timer B single shot, start timer B
.,F882 8D 0F DC STA $DC0F       save VIA 1 CRB
.,F885 29 91    AND #$91        mask x00x 000x, TOD clock, load timer A, start timer A
.,F887 8D A2 02 STA $02A2       save VIA 1 CRB shadow copy
.,F88A 20 A4 F0 JSR $F0A4       
.,F88D AD 11 D0 LDA $D011       read the vertical fine scroll and control register
.,F890 29 EF    AND #$EF        mask xxx0 xxxx, blank the screen
.,F892 8D 11 D0 STA $D011       save the vertical fine scroll and control register
.,F895 AD 14 03 LDA $0314       get IRQ vector low byte
.,F898 8D 9F 02 STA $029F       save IRQ vector low byte
.,F89B AD 15 03 LDA $0315       get IRQ vector high byte
.,F89E 8D A0 02 STA $02A0       save IRQ vector high byte
.,F8A1 20 BD FC JSR $FCBD       set the tape vector
.,F8A4 A9 02    LDA #$02        set copies count. the first copy is the load copy, the
                                second copy is the verify copy
.,F8A6 85 BE    STA $BE         save copies count
.,F8A8 20 97 FB JSR $FB97       new tape byte setup
.,F8AB A5 01    LDA $01         read the 6510 I/O port
.,F8AD 29 1F    AND #$1F        mask 000x xxxx, cassette motor on ??
.,F8AF 85 01    STA $01         save the 6510 I/O port
.,F8B1 85 C0    STA $C0         set the tape motor interlock
                                326656 cycle delay, allow tape motor speed to stabilise
.,F8B3 A2 FF    LDX #$FF        outer loop count
.,F8B5 A0 FF    LDY #$FF        inner loop count
.,F8B7 88       DEY             decrement inner loop count
.,F8B8 D0 FD    BNE $F8B7       loop if more to do
.,F8BA CA       DEX             decrement outer loop count
.,F8BB D0 F8    BNE $F8B5       loop if more to do
.,F8BD 58       CLI             enable tape interrupts
.,F8BE AD A0 02 LDA $02A0       get saved IRQ high byte
.,F8C1 CD 15 03 CMP $0315       compare with the current IRQ high byte
.,F8C4 18       CLC             flag ok
.,F8C5 F0 15    BEQ $F8DC       if tape write done go clear saved IRQ address and exit
.,F8C7 20 D0 F8 JSR $F8D0       scan stop key and flag abort if pressed
                                note if STOP was pressed the return is to the
                                routine that called this one and not here
.,F8CA 20 BC F6 JSR $F6BC       increment real time clock
.,F8CD 4C BE F8 JMP $F8BE       loop

                                *** scan stop key and flag abort if pressed
.,F8D0 20 E1 FF JSR $FFE1       scan stop key
.,F8D3 18       CLC             flag no stop
.,F8D4 D0 0B    BNE $F8E1       exit if no stop
.,F8D6 20 93 FC JSR $FC93       restore everything for STOP
.,F8D9 38       SEC             flag stopped
.,F8DA 68       PLA             dump return address low byte
.,F8DB 68       PLA             dump return address high byte

                                *** clear saved IRQ address
.,F8DC A9 00    LDA #$00        clear A
.,F8DE 8D A0 02 STA $02A0       clear saved IRQ address high byte
.,F8E1 60       RTS             

                                *** # set timing
.,F8E2 86 B1    STX $B1         save tape timing constant max byte
.,F8E4 A5 B0    LDA $B0         get tape timing constant min byte
.,F8E6 0A       ASL             *2
.,F8E7 0A       ASL             *4
.,F8E8 18       CLC             clear carry for add
.,F8E9 65 B0    ADC $B0         add tape timing constant min byte *5
.,F8EB 18       CLC             clear carry for add
.,F8EC 65 B1    ADC $B1         add tape timing constant max byte
.,F8EE 85 B1    STA $B1         save tape timing constant max byte
.,F8F0 A9 00    LDA #$00        
.,F8F2 24 B0    BIT $B0         test tape timing constant min byte
.,F8F4 30 01    BMI $F8F7       branch if b7 set
.,F8F6 2A       ROL             else shift carry into ??
.,F8F7 06 B1    ASL $B1         shift tape timing constant max byte
.,F8F9 2A       ROL             
.,F8FA 06 B1    ASL $B1         shift tape timing constant max byte
.,F8FC 2A       ROL             
.,F8FD AA       TAX             
.,F8FE AD 06 DC LDA $DC06       get VIA 1 timer B low byte
.,F901 C9 16    CMP #$16        compare with ??
.,F903 90 F9    BCC $F8FE       loop if less
.,F905 65 B1    ADC $B1         add tape timing constant max byte
.,F907 8D 04 DC STA $DC04       save VIA 1 timer A low byte
.,F90A 8A       TXA             
.,F90B 6D 07 DC ADC $DC07       add VIA 1 timer B high byte
.,F90E 8D 05 DC STA $DC05       save VIA 1 timer A high byte
.,F911 AD A2 02 LDA $02A2       read VIA 1 CRB shadow copy
.,F914 8D 0E DC STA $DC0E       save VIA 1 CRA
.,F917 8D A4 02 STA $02A4       save VIA 1 CRA shadow copy
.,F91A AD 0D DC LDA $DC0D       read VIA 1 ICR
.,F91D 29 10    AND #$10        mask 000x 0000, FLAG interrupt
.,F91F F0 09    BEQ $F92A       if no FLAG interrupt just exit
                                else first call the IRQ routine
.,F921 A9 F9    LDA #$F9        set the return address high byte
.,F923 48       PHA             push the return address high byte
.,F924 A9 2A    LDA #$2A        set the return address low byte
.,F926 48       PHA             push the return address low byte
.,F927 4C 43 FF JMP $FF43       save the status and do the IRQ routine
.,F92A 58       CLI             enable interrupts
.,F92B 60       RTS             
