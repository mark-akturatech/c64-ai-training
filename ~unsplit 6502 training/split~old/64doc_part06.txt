
A note concerning the I/O area

  The I/O area of the Commodore 64 is divided as follows:

     Address range  Owner
     -------------  -----
       D000-D3FF    MOS 6567/6569 VIC-II Video Interface Controller
       D400-D7FF    MOS 6581 SID Sound Interface Device
       D800-DBFF    Color RAM (only lower nybbles are connected)
       DC00-DCFF    MOS 6526 CIA Complex Interface Adapter #1
       DD00-DDFF    MOS 6526 CIA Complex Interface Adapter #2
       DE00-DEFF    User expansion #1 (-I/O1 on Expansion Port)
       DF00-DFFF    User expansion #2 (-I/O2 on Expansion Port)

  As you can see, the address ranges for the chips are much larger
than required. Because of this, you can access the chips through
multiple memory areas. The VIC-II appears in its window every $40
addresses. For instance, the addresses $D040 and $D080 are both mapped
to the Sprite 0 X co-ordinate register. The SID has one register
selection line less, thus it appears at every $20 bytes. The CIA chips
have only 16 registers, so there are 16 copies of each in their memory
area.

  However, you should not use other addresses than those specified by
Commodore. For instance, the Commodore 128 mapped its additional I/O
chips to this same memory area, and the SID responds only to the
addresses D400-D4FF, also when in C64 mode. And the Commodore 65, or
the C64DX, which unfortunately did not make its way to the market,
could narrow the memory window reserved for its CSG 4567 VIC-III.


The video chip

  The MOS 6567/6569 VIC-II Video Interface Controller has access to
only 16 kilobytes at a time. To enable the VIC-II to access the whole
64 kB memory space, the main memory is divided to four banks of 16 kB
each. The lines PA0 and PA1 of the second CIA are the inverse of the
virtual VIC-II address lines VA14 and VA15, respectively. To select a
VIC-II bank other than the default, you must program the CIA lines to
output the desired bit pair. For instance, the following code selects
the memory area $4000-$7FFF (bank 1) for the video controller:

    LDA $DD02 ; Data Direction Register A
    ORA #$03  ; Set pins PA0 and PA1 to outputs
    STA $DD02
    LDA $DD00
    AND #$FC  ; Mask the lowmost bit pair off
    ORA #$02  ; Select VIC-II bank 1 (the inverse of binary 01 is 10)
    STA $DD00

  Why should you set the pins to outputs? Hardware RESET resets all
I/O lines to inputs, and thanks to the CIA's internal pull-up
resistors, the inputs actually output logical high voltage level. So,
upon -RESET, the video bank 0 is selected automatically, and older
Kernals could leave it uninitialized.

  Note that the VIC-II always fetches its information from the
internal RAM, totally ignoring the memory configuration lines. There
is only one exception to this rule: The character generator ROM.
Unless the Ultimax mode is selected, VIC-II "sees" character generator
ROM in the memory areas 1000-1FFF and 9000-9FFF. If the Ultimax
configuration is active, the VIC-II fetches all data from the internal
RAM.


Accessing the memory places 0 and 1

  Although the addresses 0 and 1 of the processor are hard-wired to
its on-chip I/O port registers, you can access the memory places 0 and
1. The video chip always reads from RAM (or character generator ROM),
so you can use it to read also from 0 and 1. Enable the bit-map screen
and set the start address of the graphics screen to 0. Now you can see
these two memory locations in the upper left corner. Alternatively,
you could set the character generator start address to 0, in which
case you would see these locations in @ characters (code 0). Or, you
can activate a sprite with start address 0. Whichever method you
choose, you can read these locations with sprite collision registers.
Define a sprite consisting of only one dot, and move it to read the 8
bits of each byte with the sprite to sprite or sprite to background
collision registers.

  But how can you write to these locations? If you execute the command
POKE 53265,59, you will see that the memory place 1 changes its value
wildly. If you disable the interrupts (POKE53664,127), it will remain
stable. How is this possible? When the processor writes to 0 or 1, it
will put the address on the address bus and set the R/-W line to indicate
a write cycle, but it does not put the data on the data bus. Thus, it
writes "random" data. Of course this data is not truly random. Actually
it is something that the video chip left on the bus on its clock half.
So, if you want to write a certain value on 0 or 1, you have to make the
video chip to read that value just before the store cycle. This requires
very accurate timing, but it can be achieved even with a carefully
written BASIC program. Just wait the video chip to be in the top or
bottom border and the beam to be in the middle of the screen (not in the
side borders). At this area, the video chip will always read the last
byte of the video bank (by default $3FFF). Now, if you store anything to
the I/O port registers 0 or 1 while the video chip is refreshing this
screen area, the contents of the memory place $3FFF will be written to
the respective memory place (0 or 1).  Note that this trick does not work
reliably on all computers.  You need good RF protection, as the data bus
will not be driven at all when the value remains on it.

  On the C128 in its 2 MHz mode, you can write to the memory places
with an easier kludge.  Just make sure that the video chip is not
performing the memory refresh (as it would slow down to 1 MHz in that
case), and use some instruction that reads from a proper memory location
before writing to 0 or 1.  Indexed zero-page addressing modes are good
for it.  I tested this trick with LDX#1 followed by STA $FF,X.  As you
can read from the instruction timing section of this document, the
instruction first reads from $FF (the base address) and then writes to 0.
The timing can be done with a simple LDA$D012:CMP$D012:BEQ *-3 loop.
But in the C128 mode you can relocate the stack page to zero page, so
this trick is not really useful.

  You can also read the memory places 0 and 1 much faster than with
sprite collisions. Just make the video chip to read from 0 or 1, and
then read from non-connected address space ($DE00-$DFFF on a stock C64;
also $D700-$D7FF on C128's). Actually, you can produce a complete map
of the video timing on your computer by making a loop that reads from
open address space, pausing one frame and one cycle in between. And if
you are into copy protections, you could write a program on the open
address space. Just remember that there must be a byte on the bus for
each clock cycle.

  These tricks unfortunately do not work reliably on all units. So far
I have had the opportunity to try it on three computers, two of which
were Commodore 128 DCR's (C128's housed in metal case with a 1571 floppy
disk drive, whose controller is integrated on the mother board). One
C128DCR drove some of its data bits too heavily to high state.  No wonder,
since its housing consisted of some newspapers spread on the floor.



                Autostart Code

  Although this document concentrates on hardware, there is one thing
that you must know about the firmware to get complete control over
your computer. As the Commodore 64 always switches the ROMs on upon
-RESET, you cannot relocate the RESET vector by writing something in
RAM. Instead, you have to use the Autostart code that will be
recognized by the KERNAL ROM. If the memory places from $8004 through
$8008 contain the PETSCII string 'CBM80' (C3 C2 CD 38 30), the RESET
routine jumps to ($8000) and the default NMI handler jumps to ($8002).

  Some programs that load into RAM take advantage of this and don't
let the machine to be reset. You don't have to modify the ROM to get
rid of this annoying behaviour. Simply ground the -EXROM line for the
beginning of the RESET sequence.



                Notes

  See the MCS 6500 Microcomputer Family Programming Manual for less
information.


References:
  C64 Memory Maps       C64 Programmer's Reference Guide, pp. 262-267
                        C64 Schematic Diagram
  6510 Block Diagram    C64 Programmer's Reference Guide,  p. 404
  Instruction Set       C64 Programmer's Reference Guide, pp. 254-255, 416-417
			C64/128 Real Programmer's Revenge Guide
                        C=Lehti magazine 4/87
