53276         $D01C          SPMC
Sprite Multicolor Registers

Bit 0:  Select multicolor mode for Sprite 0 (1=multicolor, 0=hi-res)
Bit 1:  Select multicolor mode for Sprite 1 (1=multicolor, 0=hi-res)
Bit 2:  Select multicolor mode for Sprite 2 (1=multicolor, 0=hi-res)
Bit 3:  Select multicolor mode for Sprite 3 (1=multicolor, 0=hi-res)
Bit 4:  Select multicolor mode for Sprite 4 (1=multicolor, 0=hi-res)
Bit 5:  Select multicolor mode for Sprite 5 (1=multicolor, 0=hi-res)
Bit 6:  Select multicolor mode for Sprite 6 (1=multicolor, 0=hi-res)
Bit 7:  Select multicolor mode for Sprite 7 (1=multicolor, 0=hi-res)

Sprite multicolor mode is very similar to text and bitmap multicolor
modes (see Bit 4 of 53270, $D016).  Normally, the color of each dot of
the sprite is controlled by a single bit of sprite shape data.  When
thi mode is enabled for a sprite, by setting the corresponding bit of
this register to 1, the bits of sprite shape data are grouped together
in pairs, with each pair of bits controlling a double-wide dot of the
sprite display.  By sacrificing some of the horizontal resolution (the
sprite, although the same size, is now only 12 dots wide), you gain
the use of two additional colors.  The four possible combinations of
these bit-pairs display dot colors from the following sources:

00 Background Color Register 0 (transparent)
01 Sprite Multicolor Register 0 (53285, $D025)
10 Sprite Color Registers (53287-94, $D027-E)
11 Sprite Multicolor Register 1 (53286, $D026)

Like multicolor text characters, multicolor sprites all share two
color registers.  While each sprite can display three foreground
colors, only one of these colors in unique to that sprite.  The number
of unique colors may be increated by combining more than one sprite
into a single character.

53277         $D01D          XXPAND
Sprite Horizontal Expansion Register

Bit 0:  Expand Sprite 0 horizontally (1=double-width sprite, 0=normal
        width)
Bit 1:  Expand Sprite 1 horizontally (1=double-width sprite, 0=normal
        width)
Bit 2:  Expand Sprite 2 horizontally (1=double-width sprite, 0=normal
        width)
Bit 3:  Expand Sprite 3 horizontally (1=double-width sprite, 0=normal
        width)
Bit 4:  Expand Sprite 4 horizontally (1=double-width sprite, 0=normal
        width)
Bit 5:  Expand Sprite 5 horizontally (1=double-width sprite, 0=normal
        width)
Bit 6:  Expand Sprite 6 horizontally (1=double-width sprite, 0=normal
        width)
Bit 7:  Expand Sprite 7 horizontally (1=double-width sprite, 0=normal
        width)

This register can be used to double the width of any sprite.  Setting
any bit of this register to 1 will cause each dot of the corresponding
sprite shape to be displayed twice as wide as normal, so that without
changing its horizontal resolution, the sprite takes up twice as much
space.  The horizontal expansion feature can be used alone, or in
combination with the vertical expansion register at 53271 ($D017).

Location Range: 53278-53279 ($D01E-$D01F)
Sprite Collision Detection Registers

While Bit 2 of the VIC IRQ Register at 53273 ($D019) is set to 1
anytime two sprites overlap, and Bit 1 is set to 1, when a sprite
shape is touching the foreground text or bit-graphics display, these
registers specify which sprites were involved in the collision.  Every
bit that is set to 1 indicates that the corresponding sprite was
involved in the collision.  Reading these registers clears them so
that they can detect the next collision.  Therefore, if you plan to
make multiple tests on the values stored here, it may be necessary to
copy it to a RAM variable for further reference.

Note that while these registers tell you what sprites were involved in
a collision, they do not necessarily tell you what objects have
collided with each other.  It is quite possible to have three sprites
lined up in a row, where Sprite A is on the left, Sprite B is in the
middle, touching Sprite A, and Sprite C is on the right, touching
Sprite B but not touching Sprite A.  The Sprite-Sprite Collision
register would show that all three are involved.  The only way to make
absolutely certain which collided with which is to check the position
of each sprite, and calculate for each sprite display line if a sprite
of that size would touch either of the others.  As you can imagine,
this is no easy task.

There are a few simple rules concerning what does or does not cause a
collision.  Though the sprite character consists of 504 dots in a 24
by 21 matrix, does which represent data bits that are equal to 0 (or
multicolor bit- pairs equal to 00), and therefore always displayed in
the background color, do not count when it comes to collision.

A collision can occur only if a dot which represents a sprite shape
data bit of 1 touches another dot of nonzero graphics data.  Consider
the case of two invisible sprites.  The first sprite is enabled, its
color set to contrast the background, and it is positioned on the
screen, but its shape data bytes are all 0.  This sprite can never be
involved in a collision, because it displays no nonzero data.  The
second sprite is enabled, positioned on the screen, and its shape
pointer set for a data read that is filled with bytes having a value
of 255.  Even if that sprite's color is set to the same value as the
background color, making the sprite invisible, it can still be
involved in collisions.  The only exception to this rule is the 01
bit-pair of multicolor graphics data.  This bit-pair is considered
part of the background, and the dot it displays can never be involved
in a collision.

The other rule to remember about collisions is that they can occur in
areas that are covered by the screen border.  Collision between
sprites can occur when the sprites are offscreen, and collisions
between sprites and foreground display data can occur when that data
is in an area that is covered by the border due to the reduction of
the display to 38 columns or 24 rows.

53278         $D01E          SPSPCL
Sprite to Sprite Collision Register

Bit 0:  Did Sprite 0 collide with another sprite?  (1=yes)
Bit 1:  Did Sprite 1 collide with another sprite?  (1=yes)
Bit 2:  Did Sprite 2 collide with another sprite?  (1=yes)
Bit 3:  Did Sprite 3 collide with another sprite?  (1=yes)
Bit 4:  Did Sprite 4 collide with another sprite?  (1=yes)
Bit 5:  Did Sprite 5 collide with another sprite?  (1=yes)
Bit 6:  Did Sprite 6 collide with another sprite?  (1=yes)
Bit 7:  Did Sprite 7 collide with another sprite?  (1=yes)

53279         $D01F          SPBGCL
Sprite to Foreground Collision Register

Bit 0:  Did Sprite 0 collide with the foreground display?  (1=yes)
Bit 1:  Did Sprite 1 collide with the foreground display?  (1=yes)
Bit 2:  Did Sprite 2 collide with the foreground display?  (1=yes)
Bit 3:  Did Sprite 3 collide with the foreground display?  (1=yes)
Bit 4:  Did Sprite 4 collide with the foreground display?  (1=yes)
Bit 5:  Did Sprite 5 collide with the foreground display?  (1=yes)
Bit 6:  Did Sprite 6 collide with the foreground display?  (1=yes)
Bit 7:  Did Sprite 7 collide with the foreground display?  (1=yes)

Location Range: 53280-53294 ($D020-$D02E)
VIC-II Color Register

Although these color registers are used for various purposes, all of
them have one thing in common.  Like the Color RAM Nybbles, only the
lower four bits are connected.  Therefore, when reading these
registers, you must mask out the upper four bits (that is,
BORDERCOLOR=PEEK(53280)AND15) in order to get a true reading.

53280         $D020          EXTCOL
Border Color Register

The color value here determines the color of the border or frame
around the central display area.  The entire screen is set to this
color when the blanking feature of Bit 4 of 53265 ($D011) is enabled.
The default color value is 14 (light blue).

53281         $D021          BGCOL0
Background Color 0

This register sets the background color for all text modes, sprite
graphics, and multicolor bitmap graphics.  The default color value is
6 (blue).

53282         $D022          BGCOL1
Background Color 1

This register sets the color for the 01 bit-pair of multicolor
character graphics, and the background color for characters having
screen codes 64-127 in extended background color text mode.  The
default color value is 1 (white).

53283         $D023          BGCOL2
Background Color 2

This register sets the color for the 10 bit-pair of multicolor
character graphics, and the background color for characters habing
screen codes 128-191 in extended background color text mode.  The
default color value is 2 (red).

53285         $D024          BGCOL3
Background Color 3

This register sets the background color for characters having screen
codes between 192 and 255 in extended background color text mode.  The
default color value is 3 (cyan).

53285         $D025          SPMC0
Sprite Multicolor Register 0

This register sets the color that is displayed by the 01 bit-pair in
multicolor sprite graphics.  The default color value is 4 (purple).

53286         $D026          SPMC1
Sprite Multicolor Register 1

This register sets the color that is displayed by the 11 bit-pair in
multicolor sprite graphics.  The default color value is 0 (black).

Location Range: 53287-53294 ($D027-$D02E)
Sprite Color Registers

These registers are used to set the color to be displayed by bits of
hi-res sprite data having a value of 1, and by bit-pairs of multicolor
sprite data having a value of 10.  The color of each sprite is
determined by its own individual color register.

53287         $D027          SP0COL
Sprite 0 Color Register (the default color value is 1, white)

53288         $D028          SP1COL
Sprite 1 Color Register (the default color value is 2, red)

53289         $D029          SP2COL
Sprite 2 Color Register (the default color value is 3, cyan)

53290         $D01A          SP3COL
Sprite 3 Color Register (the default color value is 4, purple)

53291         $D01B          SP4COL
Sprite 4 Color Register (the default color value is 5, green)

53292         $D01C          SP5COL
Sprite 5 Color Register (the default color value is 6, blue)

53293         $D01D          SP6COL
Sprite 6 Color Register (the default color value is 7, yellow)

53294         $D01E          SP7COL
Sprite 7 Color Register (the default color value is 12, medium gray)

Location Range: 53295-53311 ($D02F-$D03F)
Not Connected

The VIC-II chip has only 47 registers for 64 bytes of possible address
space.  Therefore, the remaining 17 addresses do not access any
memory.  When read, they will always give a value of 255 ($FF).  This
value will not change after writing to them.

Location Range: 53312-54271 ($D040-$D3FF)
VIC-II Register Images

Since the VIC-II requires only enough addressing lines to handle 64
locations (the minimum possible for its 47 registers), none of the
higher bits are decoded when addressing this 1K area.  The result is
that every 64 byte area in this 1K block is a mirror of every other.
POKE53281+64,1 has the same effect as POKE53281,1 or
POKE53281+10*64,1; they all turn the screen background to white.  For
the sake of clarity in your programs it is advisable to use the base
address of the chip.

54272-54300   $D400-$D41C
Sound Interface Device (SID) Registers

Mmeory locations 54272-54300 ($D400-$D41C) are used to address the
6581 Sound Interface Device (SID).

SID is a custom music synthesizer and sound effects generator chip
that gives the 64 its impressive musical capabilities.  It provides
three separate music channels, or voices, as they are called.  Each
voice has 16-bit frequency resolution, waveform control, envelope
shaping, oscillator synchronization, and ring modulation.  In
addition, programmable high-pass, low-pass, and band-pass filters can
be set and enabled or disabled for each sound channel.

Since quite a few of these locations must be used in concert to
produce sound, a brief summary of the interplay between some of these
registers may be helpful.

Often the first step is to select an overall volume level using the
Volume Register.  Then, the desired frequency or pitch of the note is
chosen by writing to each of the two bytes which make up the 16-bit
Frequency Register.

An ADSR envelope setting must be chosen by writing values to the
Attack/ Decay and Sustain/Release Register.  These determine the rate
of the rise and fall of the volume of the note from zero volume to
peak volume and back again.  These rates have a great influence on the
character of the sound.

Finally, the waveform must be selected, and the note started (or the
oscillator gated, as we say).  This is done by writing certain bits to
the Control Register.  The waveform control lets you select one of
four different waveforms, each of which has varying harmonic content
that affects the tone quality of the sound.  By writing a 1 to the
gate bit, you start the Attack/ Delay/Sustain cycle.  Afer rising to a
peak and declining to the Sustain volume, the volume will continue at
the same level until you write a 0 to the gate bit.  Then, the Release
cycle will start.  Make sure that you keep the same waveform bit set
to 1 while you write the 0 to the gate bit, so that the Release cycle
starts.  Otherwise, the sound will stop entirely, as it also will if
the Volume Register or the Frequency Register is set to 0.

It should be noted that except for the last four SID chip registers,
these addresses are write-only.  That means that their values cannot
be determined by PEEKing these locations.

Location Range: 