
                                *** find or make array
                                an array is stored as follows
                                
                                array name             two bytes with the following patterns for different types
                                                       1st char    2nd char
                                                          b7          b7       type             element size
                                                       --------    --------    -----            ------------
                                                          0           0        floating point   5
                                                          0           1        string           3
                                                          1           1        integer          2
                                offset to next array   word
                                dimension count        byte
                                1st dimension size     word, this is the number of elements including 0
                                2nd dimension size     word, only here if the array has a second dimension
                                2nd dimension size     word, only here if the array has a third dimension
                                                       note: the dimension size word is in high byte low byte
                                                       format, not like most 6502 words
                                then for each element the required number of bytes given as the element size above
.,B1D1 A5 0C    LDA $0C         get DIM flag
.,B1D3 05 0E    ORA $0E         OR with data type flag
.,B1D5 48       PHA             push it
.,B1D6 A5 0D    LDA $0D         get data type flag, $FF = string, $00 = numeric
.,B1D8 48       PHA             push it
.,B1D9 A0 00    LDY #$00        clear dimensions count
                                now get the array dimension(s) and stack it (them) before the data type and DIM flag
.,B1DB 98       TYA             copy dimensions count
.,B1DC 48       PHA             save it
.,B1DD A5 46    LDA $46         get array name 2nd byte
.,B1DF 48       PHA             save it
.,B1E0 A5 45    LDA $45         get array name 1st byte
.,B1E2 48       PHA             save it
.,B1E3 20 B2 B1 JSR $B1B2       evaluate integer expression
.,B1E6 68       PLA             pull array name 1st byte
.,B1E7 85 45    STA $45         restore array name 1st byte
.,B1E9 68       PLA             pull array name 2nd byte
.,B1EA 85 46    STA $46         restore array name 2nd byte
.,B1EC 68       PLA             pull dimensions count
.,B1ED A8       TAY             restore it
.,B1EE BA       TSX             copy stack pointer
.,B1EF BD 02 01 LDA $0102,X     get DIM flag
.,B1F2 48       PHA             push it
.,B1F3 BD 01 01 LDA $0101,X     get data type flag
.,B1F6 48       PHA             push it
.,B1F7 A5 64    LDA $64         get this dimension size high byte
.,B1F9 9D 02 01 STA $0102,X     stack before flag bytes
.,B1FC A5 65    LDA $65         get this dimension size low byte
.,B1FE 9D 01 01 STA $0101,X     stack before flag bytes
.,B201 C8       INY             increment dimensions count
.,B202 20 79 00 JSR $0079       scan memory
.,B205 C9 2C    CMP #$2C        compare with ","
.,B207 F0 D2    BEQ $B1DB       if found go do next dimension
.,B209 84 0B    STY $0B         store dimensions count
.,B20B 20 F7 AE JSR $AEF7       scan for ")", else do syntax error then warm start
.,B20E 68       PLA             pull data type flag
.,B20F 85 0D    STA $0D         restore data type flag, $FF = string, $00 = numeric
.,B211 68       PLA             pull data type flag
.,B212 85 0E    STA $0E         restore data type flag, $80 = integer, $00 = float
.,B214 29 7F    AND #$7F        mask dim flag
.,B216 85 0C    STA $0C         restore DIM flag
.,B218 A6 2F    LDX $2F         set end of variables low byte
                                (array memory start low byte)
.,B21A A5 30    LDA $30         set end of variables high byte
                                (array memory start high byte)
                                now check to see if we are at the end of array memory, we would be if there were
                                no arrays.
.,B21C 86 5F    STX $5F         save as array start pointer low byte
.,B21E 85 60    STA $60         save as array start pointer high byte
.,B220 C5 32    CMP $32         compare with end of arrays high byte
.,B222 D0 04    BNE $B228       branch if not reached array memory end
.,B224 E4 31    CPX $31         else compare with end of arrays low byte
.,B226 F0 39    BEQ $B261       go build array if not found
                                search for array
.,B228 A0 00    LDY #$00        clear index
.,B22A B1 5F    LDA ($5F),Y     get array name first byte
.,B22C C8       INY             increment index to second name byte
.,B22D C5 45    CMP $45         compare with this array name first byte
.,B22F D0 06    BNE $B237       branch if no match
.,B231 A5 46    LDA $46         else get this array name second byte
.,B233 D1 5F    CMP ($5F),Y     compare with array name second byte
.,B235 F0 16    BEQ $B24D       array found so branch
                                no match
.,B237 C8       INY             increment index
.,B238 B1 5F    LDA ($5F),Y     get array size low byte
.,B23A 18       CLC             clear carry for add
.,B23B 65 5F    ADC $5F         add array start pointer low byte
.,B23D AA       TAX             copy low byte to X
.,B23E C8       INY             increment index
.,B23F B1 5F    LDA ($5F),Y     get array size high byte
.,B241 65 60    ADC $60         add array memory pointer high byte
.,B243 90 D7    BCC $B21C       if no overflow go check next array

                                *** do bad subscript error
.,B245 A2 12    LDX #$12        error $12, bad subscript error
.:B247 2C       .BYTE $2C       makes next line BIT $0EA2

                                *** do illegal quantity error
.,B248 A2 0E    LDX #$0E        error $0E, illegal quantity error
.,B24A 4C 37 A4 JMP $A437       do error #X then warm start
