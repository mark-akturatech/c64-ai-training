
                                *** print "..." string to string utility area
.,AEBD A5 7A    LDA $7A         get BASIC execute pointer low byte
.,AEBF A4 7B    LDY $7B         get BASIC execute pointer high byte
.,AEC1 69 00    ADC #$00        add carry to low byte
.,AEC3 90 01    BCC $AEC6       branch if no overflow
.,AEC5 C8       INY             increment high byte
.,AEC6 20 87 B4 JSR $B487       print " terminated string to utility pointer
.,AEC9 4C E2 B7 JMP $B7E2       restore BASIC execute pointer from temp and return
                                get value from line .. continued
                                wasn't a string so ...
.,AECC C9 A8    CMP #$A8        compare with token for NOT
.,AECE D0 13    BNE $AEE3       branch if not token for NOT
                                was NOT token
.,AED0 A0 18    LDY #$18        offset to NOT function
.,AED2 D0 3B    BNE $AF0F       do set-up for function then execute, branch always
                                do = compare
.,AED4 20 BF B1 JSR $B1BF       evaluate integer expression, no sign check
.,AED7 A5 65    LDA $65         get FAC1 mantissa 4
.,AED9 49 FF    EOR #$FF        invert it
.,AEDB A8       TAY             copy it
.,AEDC A5 64    LDA $64         get FAC1 mantissa 3
.,AEDE 49 FF    EOR #$FF        invert it
.,AEE0 4C 91 B3 JMP $B391       convert fixed integer AY to float FAC1 and return
                                get value from line .. continued
                                wasn't a string or NOT so ...
.,AEE3 C9 A5    CMP #$A5        compare with token for FN
.,AEE5 D0 03    BNE $AEEA       branch if not token for FN
.,AEE7 4C F4 B3 JMP $B3F4       else go evaluate FNx
                                get value from line .. continued
                                wasn't a string, NOT or FN so ...
.,AEEA C9 B4    CMP #$B4        compare with token for SGN
.,AEEC 90 03    BCC $AEF1       if less than SGN token evaluate expression in parentheses
                                else was a function token
.,AEEE 4C A7 AF JMP $AFA7       go set up function references, branch always
                                get value from line .. continued
                                if here it can only be something in brackets so ....
                                evaluate expression within parentheses
.,AEF1 20 FA AE JSR $AEFA       scan for "(", else do syntax error then warm start
.,AEF4 20 9E AD JSR $AD9E       evaluate expression
                                all the 'scan for' routines return the character after the sought character
                                scan for ")", else do syntax error then warm start
.,AEF7 A9 29    LDA #$29        load A with ")"
.:AEF9 2C       .BYTE $2C       makes next line BIT $28A9
                                scan for "(", else do syntax error then warm start
.,AEFA A9 28    LDA #$28        load A with "("
.:AEFC 2C       .BYTE $2C       makes next line BIT $2CA9
                                scan for ",", else do syntax error then warm start
.,AEFD A9 2C    LDA #$2C        load A with ","
                                scan for CHR$(A), else do syntax error then warm start
.,AEFF A0 00    LDY #$00        clear index
.,AF01 D1 7A    CMP ($7A),Y     compare with BASIC byte
.,AF03 D0 03    BNE $AF08       if not expected byte do syntax error then warm start
.,AF05 4C 73 00 JMP $0073       else increment and scan memory and return
                                syntax error then warm start
.,AF08 A2 0B    LDX #$0B        error code $0B, syntax error
.,AF0A 4C 37 A4 JMP $A437       do error #X then warm start
.,AF0D A0 15    LDY #$15        set offset from base to > operator
.,AF0F 68       PLA             dump return address low byte
.,AF10 68       PLA             dump return address high byte
.,AF11 4C FA AD JMP $ADFA       execute function then continue evaluation

                                *** check address range, return Cb = 1 if address in BASIC ROM
.,AF14 38       SEC             set carry for subtract
.,AF15 A5 64    LDA $64         get variable address low byte
.,AF17 E9 00    SBC #$00        subtract $A000 low byte
.,AF19 A5 65    LDA $65         get variable address high byte
.,AF1B E9 A0    SBC #$A0        subtract $A000 high byte
.,AF1D 90 08    BCC $AF27       exit if address < $A000
.,AF1F A9 A2    LDA #$A2        get end of BASIC marker low byte
.,AF21 E5 64    SBC $64         subtract variable address low byte
.,AF23 A9 E3    LDA #$E3        get end of BASIC marker high byte
.,AF25 E5 65    SBC $65         subtract variable address high byte
.,AF27 60       RTS             

                                *** variable name set-up
.,AF28 20 8B B0 JSR $B08B       get variable address
.,AF2B 85 64    STA $64         save variable pointer low byte
.,AF2D 84 65    STY $65         save variable pointer high byte
.,AF2F A6 45    LDX $45         get current variable name first character
.,AF31 A4 46    LDY $46         get current variable name second character
.,AF33 A5 0D    LDA $0D         get data type flag, $FF = string, $00 = numeric
.,AF35 F0 26    BEQ $AF5D       branch if numeric
                                variable is string
.,AF37 A9 00    LDA #$00        else clear A
.,AF39 85 70    STA $70         clear FAC1 rounding byte
.,AF3B 20 14 AF JSR $AF14       check address range
.,AF3E 90 1C    BCC $AF5C       exit if not in BASIC ROM
.,AF40 E0 54    CPX #$54        compare variable name first character with "T"
.,AF42 D0 18    BNE $AF5C       exit if not "T"
.,AF44 C0 C9    CPY #$C9        compare variable name second character with "I$"
.,AF46 D0 14    BNE $AF5C       exit if not "I$"
                                variable name was "TI$"
.,AF48 20 84 AF JSR $AF84       read real time clock into FAC1 mantissa, 0HML
.,AF4B 84 5E    STY $5E         clear exponent count adjust
.,AF4D 88       DEY             Y = $FF
.,AF4E 84 71    STY $71         set output string index, -1 to allow for pre increment
.,AF50 A0 06    LDY #$06        HH:MM:SS is six digits
.,AF52 84 5D    STY $5D         set number of characters before the decimal point
.,AF54 A0 24    LDY #$24        
                                index to jiffy conversion table
.,AF56 20 68 BE JSR $BE68       convert jiffy count to string
.,AF59 4C 6F B4 JMP $B46F       exit via STR$() code tail
.,AF5C 60       RTS             
                                variable name set-up, variable is numeric
.,AF5D 24 0E    BIT $0E         test data type flag, $80 = integer, $00 = float
.,AF5F 10 0D    BPL $AF6E       branch if float
.,AF61 A0 00    LDY #$00        clear index
.,AF63 B1 64    LDA ($64),Y     get integer variable low byte
.,AF65 AA       TAX             copy to X
.,AF66 C8       INY             increment index
.,AF67 B1 64    LDA ($64),Y     get integer variable high byte
.,AF69 A8       TAY             copy to Y
.,AF6A 8A       TXA             copy loa byte to A
.,AF6B 4C 91 B3 JMP $B391       convert fixed integer AY to float FAC1 and return
                                variable name set-up, variable is float
.,AF6E 20 14 AF JSR $AF14       check address range
.,AF71 90 2D    BCC $AFA0       if not in BASIC ROM get pointer and unpack into FAC1
.,AF73 E0 54    CPX #$54        compare variable name first character with "T"
.,AF75 D0 1B    BNE $AF92       branch if not "T"
.,AF77 C0 49    CPY #$49        compare variable name second character with "I"
.,AF79 D0 25    BNE $AFA0       branch if not "I"
                                variable name was "TI"
.,AF7B 20 84 AF JSR $AF84       read real time clock into FAC1 mantissa, 0HML
.,AF7E 98       TYA             clear A
.,AF7F A2 A0    LDX #$A0        set exponent to 32 bit value
.,AF81 4C 4F BC JMP $BC4F       set exponent = X and normalise FAC1

                                *** read real time clock into FAC1 mantissa, 0HML
.,AF84 20 DE FF JSR $FFDE       read real time clock
.,AF87 86 64    STX $64         save jiffy clock mid byte as  FAC1 mantissa 3
.,AF89 84 63    STY $63         save jiffy clock high byte as  FAC1 mantissa 2
.,AF8B 85 65    STA $65         save jiffy clock low byte as  FAC1 mantissa 4
.,AF8D A0 00    LDY #$00        clear Y
.,AF8F 84 62    STY $62         clear FAC1 mantissa 1
.,AF91 60       RTS             
                                variable name set-up, variable is float and not "Tx"
.,AF92 E0 53    CPX #$53        compare variable name first character with "S"
.,AF94 D0 0A    BNE $AFA0       if not "S" go do normal floating variable
.,AF96 C0 54    CPY #$54        compare variable name second character with "
.,AF98 D0 06    BNE $AFA0       if not "T" go do normal floating variable
                                variable name was "ST"
.,AF9A 20 B7 FF JSR $FFB7       read I/O status word
.,AF9D 4C 3C BC JMP $BC3C       save A as integer byte and return
                                variable is float
.,AFA0 A5 64    LDA $64         get variable pointer low byte
.,AFA2 A4 65    LDY $65         get variable pointer high byte
.,AFA4 4C A2 BB JMP $BBA2       unpack memory (AY) into FAC1

                                *** get value from line continued
                                only functions left so ..
                                set up function references
.,AFA7 0A       ASL             *2 (2 bytes per function address)
.,AFA8 48       PHA             save function offset
.,AFA9 AA       TAX             copy function offset
.,AFAA 20 73 00 JSR $0073       increment and scan memory
.,AFAD E0 8F    CPX #$8F        compare function offset to CHR$ token offset+1
.,AFAF 90 20    BCC $AFD1       branch if < LEFT$ (can not be =)
                                get value from line .. continued
                                was LEFT$, RIGHT$ or MID$ so..
.,AFB1 20 FA AE JSR $AEFA       scan for "(", else do syntax error then warm start
.,AFB4 20 9E AD JSR $AD9E       evaluate, should be string, expression
.,AFB7 20 FD AE JSR $AEFD       scan for ",", else do syntax error then warm start
.,AFBA 20 8F AD JSR $AD8F       check if source is string, else do type mismatch
.,AFBD 68       PLA             restore function offset
.,AFBE AA       TAX             copy it
.,AFBF A5 65    LDA $65         get descriptor pointer high byte
.,AFC1 48       PHA             push string pointer high byte
.,AFC2 A5 64    LDA $64         get descriptor pointer low byte
.,AFC4 48       PHA             push string pointer low byte
.,AFC5 8A       TXA             restore function offset
.,AFC6 48       PHA             save function offset
.,AFC7 20 9E B7 JSR $B79E       get byte parameter
.,AFCA 68       PLA             restore function offset
.,AFCB A8       TAY             copy function offset
.,AFCC 8A       TXA             copy byte parameter to A
.,AFCD 48       PHA             push byte parameter
.,AFCE 4C D6 AF JMP $AFD6       go call function
                                get value from line .. continued
                                was SGN() to CHR$() so..
.,AFD1 20 F1 AE JSR $AEF1       evaluate expression within parentheses
.,AFD4 68       PLA             restore function offset
.,AFD5 A8       TAY             copy to index
.,AFD6 B9 EA 9F LDA $9FEA,Y     get function jump vector low byte
.,AFD9 85 55    STA $55         save functions jump vector low byte
.,AFDB B9 EB 9F LDA $9FEB,Y     get function jump vector high byte
.,AFDE 85 56    STA $56         save functions jump vector high byte
.,AFE0 20 54 00 JSR $0054       do function call
.,AFE3 4C 8D AD JMP $AD8D       check if source is numeric and RTS, else do type mismatch
                                string functions avoid this by dumping the return address

                                *** perform OR
                                this works because NOT(NOT(x) AND NOT(y)) = x OR y
.,AFE6 A0 FF    LDY #$FF        set Y for OR
.:AFE8 2C       .BYTE $2C       makes next line BIT $00A0

                                *** perform AND
.,AFE9 A0 00    LDY #$00        clear Y for AND
.,AFEB 84 0B    STY $0B         set AND/OR invert value
.,AFED 20 BF B1 JSR $B1BF       evaluate integer expression, no sign check
.,AFF0 A5 64    LDA $64         get FAC1 mantissa 3
.,AFF2 45 0B    EOR $0B         EOR low byte
.,AFF4 85 07    STA $07         save it
.,AFF6 A5 65    LDA $65         get FAC1 mantissa 4
.,AFF8 45 0B    EOR $0B         EOR high byte
.,AFFA 85 08    STA $08         save it
.,AFFC 20 FC BB JSR $BBFC       copy FAC2 to FAC1, get 2nd value in expression
.,AFFF 20 BF B1 JSR $B1BF       evaluate integer expression, no sign check
