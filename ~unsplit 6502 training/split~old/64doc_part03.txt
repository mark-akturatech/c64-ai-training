        unsigned
           A,  /* Accumulator */
           AL, /* low nybble of accumulator */
           AH, /* high nybble of accumulator */

           C,  /* Carry flag */
           Z,  /* Zero flag */
           V,  /* oVerflow flag */
           N,  /* Negative flag */

           s;  /* value to be added to Accumulator */

        AL = (A & 15) - (s & 15) - !C;        /* Calculate the lower nybble. */

        if (AL & 16) AL -= 6;                 /* BCD fixup for lower nybble. */

        AH = (A >> 4) - (s >> 4) - (AL & 16); /* Calculate the upper nybble. */

        if (AH & 16) AH -= 6;                 /* BCD fixup for upper nybble. */

        /* The flags are set just like in Binary mode. */

        C = (A - s - !C) & 256 != 0;
        Z = (A - s - !C) & 255 != 0;
        V = ((A - s - !C) ^ s) & 128 && (A ^ s) & 128;
        N = (A - s - !C) & 128 != 0;

        A = ((AH << 4) | (AL & 15)) & 255;


  Again Z flag is set before any BCD fixup. The N and V flags are set
at any time before fixing the high nybble. The C flag may be set in any
phase.

  Decimal subtraction is easier than decimal addition, as you have to
make the BCD fixup only when a nybble overflows. In decimal addition,
you had to verify if the nybble was greater than 9. The processor has
an internal "half carry" flag for the lower nybble, used to trigger
the BCD fixup. When calculating with legal BCD values, the lower nybble
cannot overflow again when fixing it.
So, the processor does not handle overflows while performing the fixup.
Similarly, the BCD fixup occurs in the high nybble only if the value
overflows, i.e. when the C flag will be cleared.

  Because SBC's flags are not affected by the Decimal mode flag, you
could guess that CMP uses the SBC logic, only setting the C flag
first. But the SBX instruction shows that CMP also temporarily clears
the D flag, although it is totally unnecessary.

  The following program, which tests SBC's result and flags,
contains the 6502 version of the pseudo code example above.

begin 600 dsbc
M 0@9",D'GL(H-#,IJC(U-JS"*#0T*:HR-@   'BI&*  A/N$_$B@+)$KH':1
M*S@(I?PI#X7]I?LI#^7]L /I!1@I#ZBE_"GPA?VE^RGP"#CE_2GPL KI7RBP
M#ND/.+ )*+ &Z0^P NE?A/T%_87]*+BE^^7\"&BH.+CXI?OE_-@(1?W0FVB$
8_47]T)3F^]">YOS0FFA)&- $J3C0B%A@

end

  Obviously the undocumented instructions RRA (ROR+ADC) and ISB
(INC+SBC) have inherited also the decimal operation from the official
instructions ADC and SBC. The program droradc proves this statement
for ROR, and the dincsbc test proves this for ISB. Finally,
dincsbc-deccmp proves that ISB's and DCP's (DEC+CMP) flags are not
affected by the D flag.

begin 644 droradc
M`0@9",D'GL(H-#,IJC(U-JS"*#0T*:HR-@```'BI&*``A/N$_$B@+)$KH(V1
M*S@(I?PI#X7]I?LI#V7]R0J0`FD%J"D/A?VE^RGP9?PI\`C`$)`":0^JL`@H
ML`?)H)`&""@X:5\X!?V%_0AH*3W@`!`""8"HBD7[$`JE^T7\,`28"4"H**7[
M9?S0!)@)`J@XN/BE^R;\9_S8"$7]T"=HA/U%_=`@YOO0A>;\T(%H21CP`EA@
2J1T892N%^ZD`92R%_*DX;/L`
`
end

begin 644 dincsbc
M`0@9",D'GL(H-#,IJC(U-JS"*#0T*:HR-@```'BI&*``A/N$_$B@+)$KH':1
M*S@(I?PI#X7]I?LI#^7]L`/I!1@I#ZBE_"GPA?VE^RGP"#CE_2GPL`KI7RBP
M#ND/.+`)*+`&Z0^P`NE?A/T%_87]*+BE^^7\"&BH.+CXI?O&_.?\V`A%_="9
::(3]1?W0DN;[T)SF_-"8:$D8T`2I.-"&6&#\
`
end

begin 644 dincsbc-deccmp
M`0@9",D'GL(H-#,IJC(U-JS"*#0T*:HR-@```'B@`(3[A/RB`XH8:7>HL2N@
M3Y$KH%R1*XII>ZBQ*Z!3D2N@8)$KBFE_J+$KH%61*Z!BD2OX.+BE^^;\Q_S8
L"&B%_3BXI?OF_,?\"&A%_?`!`.;[T-_F_-#;RA"M8!@X&#CFYL;&Q\?GYP#8
`
end



                 6510 features

   o  PHP always pushes the Break (B) flag as a `1' to the stack.
      Jukka Tapanim"aki claimed in C=lehti issue 3/89, on page 27 that the
      processor makes a logical OR between the status register's bit 4
      and the bit 8 of the stack pointer register (which is always 1).
      He did not give any reasons for this argument, and has refused to clarify
      it afterwards. Well, this was not the only error in his article...

   o  Indirect addressing modes do not handle page boundary crossing at all.
      When the parameter's low byte is $FF, the effective address wraps
      around and the CPU fetches high byte from $xx00 instead of $xx00+$0100.
      E.g. JMP ($01FF) fetches PCL from $01FF and PCH from $0100,
      and LDA ($FF),Y fetches the base address from $FF and $00.

   o  Indexed zero page addressing modes never fix the page address on
      crossing the zero page boundary.
      E.g. LDX #$01 : LDA ($FF,X) loads the effective address from $00 and $01.

   o  The processor always fetches the byte following a relative branch
      instruction. If the branch is taken, the processor reads then the
      opcode from the destination address. If page boundary is crossed, it
      first reads a byte from the old page from a location that is bigger
      or smaller than the correct address by one page.

   o  If you cross a page boundary in any other indexed mode,
      the processor reads an incorrect location first, a location that is
      smaller by one page.

   o  Read-Modify-Write instructions write unmodified data, then modified
      (so INC effectively does LDX loc;STX loc;INX;STX loc)

   o  -RDY is ignored during writes
      (This is why you must wait 3 cycles before doing any DMA --
      the maximum number of consecutive writes is 3, which occurs
      during interrupts except -RESET.)

   o  Some undefined opcodes may give really unpredictable results.

   o  All registers except the Program Counter remain unmodified after -RESET.
      (This is why you must preset D and I flags in the RESET handler.)


                Different CPU types

The Rockwell data booklet 29651N52 (technical information about R65C00
microprocessors, dated October 1984), lists the following differences between
NMOS R6502 microprocessor and CMOS R65C00 family:

 1. Indexed addressing across page boundary.
        NMOS: Extra read of invalid address.
        CMOS: Extra read of last instruction byte.

 2. Execution of invalid op codes.
        NMOS: Some terminate only by reset. Results are undefined.
        CMOS: All are NOPs (reserved for future use).

 3. Jump indirect, operand = XXFF.
        NMOS: Page address does not increment.
        CMOS: Page address increments and adds one additional cycle.

 4. Read/modify/write instructions at effective address.
        NMOS: One read and two write cycles.
        CMOS: Two read and one write cycle.

 5. Decimal flag.
        NMOS: Indeterminate after reset.
        CMOS: Initialized to binary mode (D=0) after reset and interrupts.

 6. Flags after decimal operation.
        NMOS: Invalid N, V and Z flags.
        CMOS: Valid flag adds one additional cycle.

 7. Interrupt after fetch of BRK instruction.
        NMOS: Interrupt vector is loaded, BRK vector is ignored.
        CMOS: BRK is executed, then interrupt is executed.



                6510 Instruction Timing

  The NMOS 6500 series processors always perform at least two reads
for each instruction. In addition to the operation code (opcode), they
fetch the next byte. This is quite efficient, as most instructions are
two or three bytes long.

  The processors also use a sort of pipelining. If an instruction does
not store data in memory on its last cycle, the processor can fetch
the opcode of the next instruction while executing the last cycle. For
instance, the instruction EOR #$FF truly takes three cycles. On the
first cycle, the opcode $49 will be fetched. During the second cycle
the processor decodes the opcode and fetches the parameter #$FF. On
the third cycle, the processor will perform the operation and store
the result to accumulator, but simultaneously it fetches the opcode
for the next instruction. This is why the instruction effectively
takes only two cycles.

  The following tables show what happens on the bus while executing
different kinds of instructions.

  Interrupts

     NMI and IRQ both take 7 cycles. Their timing diagram is much like
     BRK's (see below). IRQ will be executed only when the I flag is
     clear. IRQ and BRK both set the I flag, whereas the NMI does not
     affect its state.

     The processor will usually wait for the current instruction to
     complete before executing the interrupt sequence. To process the
     interrupt before the next instruction, the interrupt must occur
     before the last cycle of the current instruction.

     There is one exception to this rule: the BRK instruction. If a
     hardware interrupt (NMI or IRQ) occurs before the fourth (flags
     saving) cycle of BRK, the BRK instruction will be skipped, and
     the processor will jump to the hardware interrupt vector. This
     sequence will always take 7 cycles.

     You do not completely lose the BRK interrupt, the B flag will be
     set in the pushed status register if a BRK instruction gets
     interrupted. When BRK and IRQ occur at the same time, this does
     not cause any problems, as your program will consider it as a
     BRK, and the IRQ would occur again after the processor returned
     from your BRK routine, unless you cleared the interrupt source in
     your BRK handler. But the simultaneous occurrence of NMI and BRK
     is far more fatal. If you do not check the B flag in the NMI
     routine and subtract two from the return address when needed, the
     BRK instruction will be skipped.

     If the NMI and IRQ interrupts overlap each other (one interrupt
     occurs before fetching the interrupt vector for the other
     interrupt), the processor will most probably jump to the NMI
     vector in every case, and then jump to the IRQ vector after
     processing the first instruction of the NMI handler. This has not
     been measured yet, but the IRQ is very similar to BRK, and many
     sources state that the NMI has higher priority than IRQ. However,
     it might be that the processor takes the interrupt that comes
     later, i.e. you could lose an NMI interrupt if an IRQ occurred in
     four cycles after it.

     After finishing the interrupt sequence, the processor will start
     to execute the first instruction of the interrupt routine. This
     proves that the processor uses a sort of pipelining: it finishes
     the current instruction (or interrupt sequence) while reading the
     opcode of the next instruction.

     RESET does not push program counter on stack, and it lasts
     probably 6 cycles after deactivating the signal. Like NMI, RESET
     preserves all registers except PC.


  Instructions accessing the stack

     BRK

        #  address R/W description
       --- ------- --- -----------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  read next instruction byte (and throw it away),
                       increment PC
        3  $0100,S  W  push PCH on stack (with B flag set), decrement S
        4  $0100,S  W  push PCL on stack, decrement S
        5  $0100,S  W  push P on stack, decrement S
        6   $FFFE   R  fetch PCL
        7   $FFFF   R  fetch PCH


     RTI

        #  address R/W description
       --- ------- --- -----------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  read next instruction byte (and throw it away)
        3  $0100,S  R  increment S
        4  $0100,S  R  pull P from stack, increment S
        5  $0100,S  R  pull PCL from stack, increment S
        6  $0100,S  R  pull PCH from stack


     RTS

        #  address R/W description
       --- ------- --- -----------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  read next instruction byte (and throw it away)
        3  $0100,S  R  increment S
        4  $0100,S  R  pull PCL from stack, increment S
        5  $0100,S  R  pull PCH from stack
        6    PC     R  increment PC


     PHA, PHP

        #  address R/W description
       --- ------- --- -----------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  read next instruction byte (and throw it away)
        3  $0100,S  W  push register on stack, decrement S


     PLA, PLP

        #  address R/W description
       --- ------- --- -----------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  read next instruction byte (and throw it away)
        3  $0100,S  R  increment S
        4  $0100,S  R  pull register from stack


     JSR

        #  address R/W description
       --- ------- --- -------------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  fetch low address byte, increment PC
        3  $0100,S  R  internal operation (predecrement S?)
        4  $0100,S  W  push PCH on stack, decrement S
        5  $0100,S  W  push PCL on stack, decrement S
        6    PC     R  copy low address byte to PCL, fetch high address
                       byte to PCH



  Accumulator or implied addressing

        #  address R/W description
       --- ------- --- -----------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  read next instruction byte (and throw it away)


  Immediate addressing

        #  address R/W description
       --- ------- --- ------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  fetch value, increment PC


  Absolute addressing

     JMP

        #  address R/W description
       --- ------- --- -------------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  fetch low address byte, increment PC
        3    PC     R  copy low address byte to PCL, fetch high address
                       byte to PCH


     Read instructions (LDA, LDX, LDY, EOR, AND, ORA, ADC, SBC, CMP, BIT,
                        LAX, NOP)

        #  address R/W description
       --- ------- --- ------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  fetch low byte of address, increment PC
        3    PC     R  fetch high byte of address, increment PC
        4  address  R  read from effective address


     Read-Modify-Write instructions (ASL, LSR, ROL, ROR, INC, DEC,
                                     SLO, SRE, RLA, RRA, ISB, DCP)

        #  address R/W description
       --- ------- --- ------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  fetch low byte of address, increment PC
        3    PC     R  fetch high byte of address, increment PC
        4  address  R  read from effective address
        5  address  W  write the value back to effective address,
                       and do the operation on it
        6  address  W  write the new value to effective address


     Write instructions (STA, STX, STY, SAX)

        #  address R/W description
       --- ------- --- ------------------------------------------
        1    PC     R  fetch opcode, increment PC
        2    PC     R  fetch low byte of address, increment PC
        3    PC     R  fetch high byte of address, increment PC
        4  address  W  write register to effective address
