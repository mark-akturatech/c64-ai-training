
                                *** ??
.,FED6 AD 01 DD LDA $DD01       read VIA 2 DRB, RS232 port
.,FED9 29 01    AND #$01        mask 0000 000x, RS232 Rx DATA
.,FEDB 85 A7    STA $A7         save the RS232 received data bit
.,FEDD AD 06 DD LDA $DD06       get VIA 2 timer B low byte
.,FEE0 E9 1C    SBC #$1C        
.,FEE2 6D 99 02 ADC $0299       
.,FEE5 8D 06 DD STA $DD06       save VIA 2 timer B low byte
.,FEE8 AD 07 DD LDA $DD07       get VIA 2 timer B high byte
.,FEEB 6D 9A 02 ADC $029A       
.,FEEE 8D 07 DD STA $DD07       save VIA 2 timer B high byte
.,FEF1 A9 11    LDA #$11        set timer B single shot, start timer B
.,FEF3 8D 0F DD STA $DD0F       save VIA 2 CRB
.,FEF6 AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,FEF9 8D 0D DD STA $DD0D       save VIA 2 ICR
.,FEFC A9 FF    LDA #$FF        
.,FEFE 8D 06 DD STA $DD06       save VIA 2 timer B low byte
.,FF01 8D 07 DD STA $DD07       save VIA 2 timer B high byte
.,FF04 4C 59 EF JMP $EF59       
.,FF07 AD 95 02 LDA $0295       nonstandard bit timing low byte
.,FF0A 8D 06 DD STA $DD06       save VIA 2 timer B low byte
.,FF0D AD 96 02 LDA $0296       nonstandard bit timing high byte
.,FF10 8D 07 DD STA $DD07       save VIA 2 timer B high byte
.,FF13 A9 11    LDA #$11        set timer B single shot, start timer B
.,FF15 8D 0F DD STA $DD0F       save VIA 2 CRB
.,FF18 A9 12    LDA #$12        
.,FF1A 4D A1 02 EOR $02A1       EOR with the RS-232 interrupt enable byte
.,FF1D 8D A1 02 STA $02A1       save the RS-232 interrupt enable byte
.,FF20 A9 FF    LDA #$FF        
.,FF22 8D 06 DD STA $DD06       save VIA 2 timer B low byte
.,FF25 8D 07 DD STA $DD07       save VIA 2 timer B high byte
.,FF28 AE 98 02 LDX $0298       
.,FF2B 86 A8    STX $A8         
.,FF2D 60       RTS             

                                *** ??
.,FF2E AA       TAX             
.,FF2F AD 96 02 LDA $0296       nonstandard bit timing high byte
.,FF32 2A       ROL             
.,FF33 A8       TAY             
.,FF34 8A       TXA             
.,FF35 69 C8    ADC #$C8        
.,FF37 8D 99 02 STA $0299       
.,FF3A 98       TYA             
.,FF3B 69 00    ADC #$00        add any carry
.,FF3D 8D 9A 02 STA $029A       
.,FF40 60       RTS             

                                *** unused bytes
.,FF41 EA       NOP             waste cycles
.,FF42 EA       NOP             waste cycles

                                *** save the status and do the IRQ routine
.,FF43 08       PHP             save the processor status
.,FF44 68       PLA             pull the processor status
.,FF45 29 EF    AND #$EF        mask xxx0 xxxx, clear the break bit
.,FF47 48       PHA             save the modified processor status

                                *** IRQ vector
.,FF48 48       PHA             save A
.,FF49 8A       TXA             copy X
.,FF4A 48       PHA             save X
.,FF4B 98       TYA             copy Y
.,FF4C 48       PHA             save Y
.,FF4D BA       TSX             copy stack pointer
.,FF4E BD 04 01 LDA $0104,X     get stacked status register
.,FF51 29 10    AND #$10        mask BRK flag
.,FF53 F0 03    BEQ $FF58       branch if not BRK
.,FF55 6C 16 03 JMP ($0316)     else do BRK vector (iBRK)
.,FF58 6C 14 03 JMP ($0314)     do IRQ vector (iIRQ)

                                *** initialise VIC and screen editor
.,FF5B 20 18 E5 JSR $E518       initialise the screen and keyboard
.,FF5E AD 12 D0 LDA $D012       read the raster compare register
.,FF61 D0 FB    BNE $FF5E       loop if not raster line $00
.,FF63 AD 19 D0 LDA $D019       read the vic interrupt flag register
.,FF66 29 01    AND #$01        mask the raster compare flag
.,FF68 8D A6 02 STA $02A6       save the PAL/NTSC flag
.,FF6B 4C DD FD JMP $FDDD       

                                *** ??
.,FF6E A9 81    LDA #$81        enable timer A interrupt
.,FF70 8D 0D DC STA $DC0D       save VIA 1 ICR
.,FF73 AD 0E DC LDA $DC0E       read VIA 1 CRA
.,FF76 29 80    AND #$80        mask x000 0000, TOD clock
.,FF78 09 11    ORA #$11        mask xxx1 xxx1, load timer A, start timer A
.,FF7A 8D 0E DC STA $DC0E       save VIA 1 CRA
.,FF7D 4C 8E EE JMP $EE8E       set the serial clock out low and return

                                *** unused
.:FF80 03

                                *** initialise VIC and screen editor
.,FF81 4C 5B FF JMP $FF5B       initialise VIC and screen editor

                                *** initialise SID, CIA and IRQ, unused
.,FF84 4C A3 FD JMP $FDA3       initialise SID, CIA and IRQ

                                *** RAM test and find RAM end
.,FF87 4C 50 FD JMP $FD50       RAM test and find RAM end

                                *** restore default I/O vectors
                                this routine restores the default values of all system vectors used in KERNAL and
                                BASIC routines and interrupts.
.,FF8A 4C 15 FD JMP $FD15       restore default I/O vectors

                                *** read/set vectored I/O
                                this routine manages all system vector jump addresses stored in RAM. Calling this
                                routine with the carry bit set will store the current contents of the RAM vectors
                                in a list pointed to by the X and Y registers. When this routine is called with
                                the carry bit clear, the user list pointed to by the X and Y registers is copied
                                to the system RAM vectors.
                                NOTE: This routine requires caution in its use. The best way to use it is to first
                                read the entire vector contents into the user area, alter the desired vectors and
                                then copy the contents back to the system vectors.
.,FF8D 4C 1A FD JMP $FD1A       read/set vectored I/O

                                *** control kernal messages
                                this routine controls the printing of error and control messages by the KERNAL.
                                Either print error messages or print control messages can be selected by setting
                                the accumulator when the routine is called.
                                FILE NOT FOUND is an example of an error message. PRESS PLAY ON CASSETTE is an
                                example of a control message.
                                bits 6 and 7 of this value determine where the message will come from. If bit 7
                                is set one of the error messages from the KERNAL will be printed. If bit 6 is set
                                a control message will be printed.
.,FF90 4C 18 FE JMP $FE18       control kernal messages

                                *** send secondary address after LISTEN
                                this routine is used to send a secondary address to an I/O device after a call to
                                the LISTEN routine is made and the device commanded to LISTEN. The routine cannot
                                be used to send a secondary address after a call to the TALK routine.
                                A secondary address is usually used to give set-up information to a device before
                                I/O operations begin.
                                When a secondary address is to be sent to a device on the serial bus the address
                                must first be ORed with $60.
.,FF93 4C B9 ED JMP $EDB9       send secondary address after LISTEN

                                *** send secondary address after TALK
                                this routine transmits a secondary address on the serial bus for a TALK device.
                                This routine must be called with a number between 4 and 31 in the accumulator.
                                The routine will send this number as a secondary address command over the serial
                                bus. This routine can only be called after a call to the TALK routine. It will
                                not work after a LISTEN.
.,FF96 4C C7 ED JMP $EDC7       send secondary address after TALK

                                *** read/set the top of memory
                                this routine is used to read and set the top of RAM. When this routine is called
                                with the carry bit set the pointer to the top of RAM will be loaded into XY. When
                                this routine is called with the carry bit clear XY will be saved as the top of
                                memory pointer changing the top of memory.
.,FF99 4C 25 FE JMP $FE25       read/set the top of memory

                                *** read/set the bottom of memory
                                this routine is used to read and set the bottom of RAM. When this routine is
                                called with the carry bit set the pointer to the bottom of RAM will be loaded
                                into XY. When this routine is called with the carry bit clear XY will be saved as
                                the bottom of memory pointer changing the bottom of memory.
.,FF9C 4C 34 FE JMP $FE34       read/set the bottom of memory

                                *** scan the keyboard
                                this routine will scan the keyboard and check for pressed keys. It is the same
                                routine called by the interrupt handler. If a key is down, its ASCII value is
                                placed in the keyboard queue.
.,FF9F 4C 87 EA JMP $EA87       scan keyboard

                                *** set timeout on serial bus
                                this routine sets the timeout flag for the serial bus. When the timeout flag is
                                set, the computer will wait for a device on the serial port for 64 milliseconds.
                                If the device does not respond to the computer's DAV signal within that time the
                                computer will recognize an error condition and leave the handshake sequence. When
                                this routine is called and the accumulator contains a 0 in bit 7, timeouts are
                                enabled. A 1 in bit 7 will disable the timeouts.
                                NOTE: The the timeout feature is used to communicate that a disk file is not found
                                on an attempt to OPEN a file.
.,FFA2 4C 21 FE JMP $FE21       set timeout on serial bus

                                *** input byte from serial bus
                                
                                this routine reads a byte of data from the serial bus using full handshaking. the
                                data is returned in the accumulator. before using this routine the TALK routine,
                                $FFB4, must have been called first to command the device on the serial bus to
                                send data on the bus. if the input device needs a secondary command it must be sent
                                by using the TKSA routine, $FF96, before calling this routine.
                                
                                errors are returned in the status word which can be read by calling the READST
                                routine, $FFB7.
.,FFA5 4C 13 EE JMP $EE13       input byte from serial bus

                                *** output a byte to serial bus
                                this routine is used to send information to devices on the serial bus. A call to
                                this routine will put a data byte onto the serial bus using full handshaking.
                                Before this routine is called the LISTEN routine, $FFB1, must be used to
                                command a device on the serial bus to get ready to receive data.
                                the accumulator is loaded with a byte to output as data on the serial bus. A
                                device must be listening or the status word will return a timeout. This routine
                                always buffers one character. So when a call to the UNLISTEN routine, $FFAE,
                                is made to end the data transmission, the buffered character is sent with EOI
                                set. Then the UNLISTEN command is sent to the device.
.,FFA8 4C DD ED JMP $EDDD       output byte to serial bus

                                *** command serial bus to UNTALK
                                this routine will transmit an UNTALK command on the serial bus. All devices
                                previously set to TALK will stop sending data when this command is received.
.,FFAB 4C EF ED JMP $EDEF       command serial bus to UNTALK

                                *** command serial bus to UNLISTEN
                                this routine commands all devices on the serial bus to stop receiving data from
                                the computer. Calling this routine results in an UNLISTEN command being transmitted
                                on the serial bus. Only devices previously commanded to listen will be affected.
                                This routine is normally used after the computer is finished sending data to
                                external devices. Sending the UNLISTEN will command the listening devices to get
                                off the serial bus so it can be used for other purposes.
.,FFAE 4C FE ED JMP $EDFE       command serial bus to UNLISTEN

                                *** command devices on the serial bus to LISTEN
                                this routine will command a device on the serial bus to receive data. The
                                accumulator must be loaded with a device number between 4 and 31 before calling
                                this routine. LISTEN convert this to a listen address then transmit this data as
                                a command on the serial bus. The specified device will then go into listen mode
                                and be ready to accept information.
.,FFB1 4C 0C ED JMP $ED0C       command devices on the serial bus to LISTEN

                                *** command serial bus device to TALK
                                to use this routine the accumulator must first be loaded with a device number
                                between 4 and 30. When called this routine converts this device number to a talk
                                address. Then this data is transmitted as a command on the Serial bus.
.,FFB4 4C 09 ED JMP $ED09       command serial bus device to TALK
