# ROM BASIC A000 AFFF
# Source: C64 ROM Disassembly


                                *** start of the BASIC ROM
.:A000 94 E3                    BASIC cold start entry point
.:A002 7B E3                    BASIC warm start entry point

.:A004 43 42 4D 42 41 53 49 43  'cbmbasic', ROM name, unreferenced

                                *** action addresses for primary commands
                                these are called by pushing the address onto the stack and doing an RTS so the
                                actual address -1 needs to be pushed
.:A00C 30 A8                    perform END     $80
.:A00E 41 A7                    perform FOR     $81
.:A010 1D AD                    perform NEXT    $82
.:A012 F7 A8                    perform DATA    $83
.:A014 A4 AB                    perform INPUT#  $84
.:A016 BE AB                    perform INPUT   $85
.:A018 80 B0                    perform DIM     $86
.:A01A 05 AC                    perform READ    $87
.:A01C A4 A9                    perform LET     $88
.:A01E 9F A8                    perform GOTO    $89
.:A020 70 A8                    perform RUN     $8A
.:A022 27 A9                    perform IF      $8B
.:A024 1C A8                    perform RESTORE $8C
.:A026 82 A8                    perform GOSUB   $8D
.:A028 D1 A8                    perform RETURN  $8E
.:A02A 3A A9                    perform REM     $8F
.:A02C 2E A8                    perform STOP    $90
.:A02E 4A A9                    perform ON      $91
.:A030 2C B8                    perform WAIT    $92
.:A032 67 E1                    perform LOAD    $93
.:A034 55 E1                    perform SAVE    $94
.:A036 64 E1                    perform VERIFY  $95
.:A038 B2 B3                    perform DEF     $96
.:A03A 23 B8                    perform POKE    $97
.:A03C 7F AA                    perform PRINT#  $98
.:A03E 9F AA                    perform PRINT   $99
.:A040 56 A8                    perform CONT    $9A
.:A042 9B A6                    perform LIST    $9B
.:A044 5D A6                    perform CLR     $9C
.:A046 85 AA                    perform CMD     $9D
.:A048 29 E1                    perform SYS     $9E
.:A04A BD E1                    perform OPEN    $9F
.:A04C C6 E1                    perform CLOSE   $A0
.:A04E 7A AB                    perform GET     $A1
.:A050 41 A6                    perform NEW     $A2

                                *** action addresses for functions
.:A052 39 BC                    perform SGN     $B4
.:A054 CC BC                    perform INT     $B5
.:A056 58 BC                    perform ABS     $B6
.:A058 10 03                    perform USR     $B7
.:A05A 7D B3                    perform FRE     $B8
.:A05C 9E B3                    perform POS     $B9
.:A05E 71 BF                    perform SQR     $BA
.:A060 97 E0                    perform RND     $BB
.:A062 EA B9                    perform LOG     $BC
.:A064 ED BF                    perform EXP     $BD
.:A066 64 E2                    perform COS     $BE
.:A068 6B E2                    perform SIN     $BF
.:A06A B4 E2                    perform TAN     $C0
.:A06C 0E E3                    perform ATN     $C1
.:A06E 0D B8                    perform PEEK    $C2
.:A070 7C B7                    perform LEN     $C3
.:A072 65 B4                    perform STR$    $C4
.:A074 AD B7                    perform VAL     $C5
.:A076 8B B7                    perform ASC     $C6
.:A078 EC B6                    perform CHR$    $C7
.:A07A 00 B7                    perform LEFT$   $C8
.:A07C 2C B7                    perform RIGHT$  $C9
.:A07E 37 B7                    perform MID$    $CA

                                *** precedence byte and action addresses for operators
                                like the primary commands these are called by pushing the address onto the stack
                                and doing an RTS, so again the actual address -1 needs to be pushed
.:A080 79 69 B8                 +
.:A083 79 52 B8                 -
.:A086 7B 2A BA                 *
.:A089 7B 11 BB                 /
.:A08C 7F 7A BF                 ^
.:A08F 50 E8 AF                 AND
.:A092 46 E5 AF                 OR
.:A095 7D B3 BF                 >
.:A098 5A D3 AE                 =
.:A09B 64 15 B0                 <

                                *** BASIC keywords
                                each word has b7 set in it's last character as an end marker, even
                                the one character keywords such as "<" or "="
                                first are the primary command keywords, only these can start a statement
.:A09E 45 4E                    end
.:A0A0 C4 46 4F D2 4E 45 58 D4  for next
.:A0A8 44 41 54 C1 49 4E 50 55  data input#
.:A0B0 54 A3 49 4E 50 55 D4 44  input dim
.:A0B8 49 CD 52 45 41 C4 4C 45  read let
.:A0C0 D4 47 4F 54 CF 52 55 CE  goto run
.:A0C8 49 C6 52 45 53 54 4F 52  if restore
.:A0D0 C5 47 4F 53 55 C2 52 45  gosub return
.:A0D8 54 55 52 CE 52 45 CD 53  rem stop
.:A0E0 54 4F D0 4F CE 57 41 49  on wait
.:A0E8 D4 4C 4F 41 C4 53 41 56  load save
.:A0F0 C5 56 45 52 49 46 D9 44  verify def
.:A0F8 45 C6 50 4F 4B C5 50 52  poke print#
.:A100 49 4E 54 A3 50 52 49 4E  print
.:A108 D4 43 4F 4E D4 4C 49 53  cont list
.:A110 D4 43 4C D2 43 4D C4 53  clr cmd sys
.:A118 59 D3 4F 50 45 CE 43 4C  open close
.:A120 4F 53 C5 47 45 D4 4E 45  get new

                                next are the secondary command keywords, these can not start a statement
.:A128 D7 54 41 42 A8 54 CF 46  tab( to
.:A130 CE 53 50 43 A8 54 48 45  spc( then
.:A138 CE 4E 4F D4 53 54 45 D0  not stop
                                next are the operators
.:A140 AB AD AA AF DE 41 4E C4  + - * / ' and
.:A148 4F D2 BE BD BC           or <=>
.:A14D                53 47 CE  sgn

                                and finally the functions
.:A150 49 4E D4 41 42 D3 55 53  int abs usr
.:A158 D2 46 52 C5 50 4F D3 53  fre pos sqr
.:A160 51 D2 52 4E C4 4C 4F C7  rnd log
.:A168 45 58 D0 43 4F D3 53 49  exp cos sin
.:A170 CE 54 41 CE 41 54 CE 50  tan atn peek
.:A178 45 45 CB 4C 45 CE 53 54  len str$
.:A180 52 A4 56 41 CC 41 53 C3  val asc
.:A188 43 48 52 A4 4C 45 46 54  chr$ left$
.:A190 A4 52 49 47 48 54 A4 4D  right$ mid$

                                lastly is GO, this is an add on so that GO TO, as well as GOTO, will work
.:A198 49 44 A4 47 CF           go
.:A19F 00                       end marker

                                *** BASIC error messages
.:A1A0 54 4F                    1 too many files
.:A1A0 4F 20 4D 41 4E 59 20 46
.:A1A8 49 4C 45 D3 46 49 4C 45  2 file open
.:A1B0 20 4F 50 45 CE 46 49 4C  3 file not open
.:A1B8 45 20 4E 4F 54 20 4F 50
.:A1C0 45 CE 46 49 4C 45 20 4E  4 file not found
.:A1C8 4F 54 20 46 4F 55 4E C4  5 device not present
.:A1D0 44 45 56 49 43 45 20 4E
.:A1D8 4F 54 20 50 52 45 53 45
.:A1E0 4E D4 4E 4F 54 20 49 4E  6 not input file
.:A1E8 50 55 54 20 46 49 4C C5
.:A1F0 4E 4F 54 20 4F 55 54 50  7 not output file
.:A1F8 55 54 20 46 49 4C C5 4D
.:A200 49 53 53 49 4E 47 20 46  8 missing filename
.:A208 49 4C 45 20 4E 41 4D C5
.:A210 49 4C 4C 45 47 41 4C 20  9 illegal device number
.:A218 44 45 56 49 43 45 20 4E
.:A220 55 4D 42 45 D2 4E 45 58  10 next without for
.:A228 54 20 57 49 54 48 4F 55
.:A230 54 20 46 4F D2 53 59 4E  11 syntax
.:A238 54 41 D8 52 45 54 55 52  12 return without gosub
.:A240 4E 20 57 49 54 48 4F 55
.:A248 54 20 47 4F 53 55 C2 4F  13 out of data
.:A250 55 54 20 4F 46 20 44 41
.:A258 54 C1 49 4C 4C 45 47 41  14 illegal quantity
.:A260 4C 20 51 55 41 4E 54 49
.:A268 54 D9 4F 56 45 52 46 4C  15 overflow
.:A270 4F D7 4F 55 54 20 4F 46  16 out of memory
.:A278 20 4D 45 4D 4F 52 D9 55  17 undef'd statement
.:A280 4E 44 45 46 27 44 20 53
.:A288 54 41 54 45 4D 45 4E D4
.:A290 42 41 44 20 53 55 42 53  18 bad subscript
.:A298 43 52 49 50 D4 52 45 44  19 redim'd array
.:A2A0 49 4D 27 44 20 41 52 52
.:A2A8 41 D9 44 49 56 49 53 49  20 division by zero
.:A2B0 4F 4E 20 42 59 20 5A 45
.:A2B8 52 CF 49 4C 4C 45 47 41  21 illegal direct
.:A2C0 4C 20 44 49 52 45 43 D4
.:A2C8 54 59 50 45 20 4D 49 53  22 type mismatch
.:A2D0 4D 41 54 43 C8 53 54 52  23 string too long
.:A2D8 49 4E 47 20 54 4F 4F 20
.:A2E0 4C 4F 4E C7 46 49 4C 45  24 file data
.:A2E8 20 44 41 54 C1 46 4F 52  25 formula too complex
.:A2F0 4D 55 4C 41 20 54 4F 4F
.:A2F8 20 43 4F 4D 50 4C 45 D8
.:A300 43 41 4E 27 54 20 43 4F  26 can't continue
.:A308 4E 54 49 4E 55 C5 55 4E  27 undef'd function
.:A310 44 45 46 27 44 20 46 55
.:A318 4E 43 54 49 4F CE 56 45  28 verify
.:A320 52 49 46 D9 4C 4F 41 C4  29 load

                                *** error message pointer table
.:A328 9E A1 AC A1 B5 A1 C2 A1
.:A330 D0 A1 E2 A1 F0 A1 FF A1
.:A338 10 A2 25 A2 35 A2 3B A2
.:A340 4F A2 5A A2 6A A2 72 A2
.:A348 7F A2 90 A2 9D A2 AA A2
.:A350 BA A2 C8 A2 D5 A2 E4 A2
.:A358 ED A2 00 A3 0E A3 1E A3
.:A360 24 A3 83 A3

                                *** BASIC messages
.:A364 0D 4F 4B 0D              OK
.:A368 00 20 20 45 52 52 4F 52  ERROR
.:A370 00 20 49 4E 20 00 0D 0A  IN
.:A378 52 45 41 44 59 2E 0D 0A  READY.
.:A380 00 0D 0A 42 52 45 41 4B  BREAK
.:A388 00

                                *** spare byte, not referenced
.:A389 A0                       unused

                                *** search the stack for FOR or GOSUB activity
                                return Zb=1 if FOR variable found
.,A38A BA       TSX             copy stack pointer
.,A38B E8       INX             +1 pass return address
.,A38C E8       INX             +2 pass return address
.,A38D E8       INX             +3 pass calling routine return address
.,A38E E8       INX             +4 pass calling routine return address
.,A38F BD 01 01 LDA $0101,X     get the token byte from the stack
.,A392 C9 81    CMP #$81        is it the FOR token
.,A394 D0 21    BNE $A3B7       if not FOR token just exit
                                it was the FOR token
.,A396 A5 4A    LDA $4A         get FOR/NEXT variable pointer high byte
.,A398 D0 0A    BNE $A3A4       branch if not null
.,A39A BD 02 01 LDA $0102,X     get FOR variable pointer low byte
.,A39D 85 49    STA $49         save FOR/NEXT variable pointer low byte
.,A39F BD 03 01 LDA $0103,X     get FOR variable pointer high byte
.,A3A2 85 4A    STA $4A         save FOR/NEXT variable pointer high byte
.,A3A4 DD 03 01 CMP $0103,X     compare variable pointer with stacked variable pointer
                                high byte
.,A3A7 D0 07    BNE $A3B0       branch if no match
.,A3A9 A5 49    LDA $49         get FOR/NEXT variable pointer low byte
.,A3AB DD 02 01 CMP $0102,X     compare variable pointer with stacked variable pointer
                                low byte
.,A3AE F0 07    BEQ $A3B7       exit if match found
.,A3B0 8A       TXA             copy index
.,A3B1 18       CLC             clear carry for add
.,A3B2 69 12    ADC #$12        add FOR stack use size
.,A3B4 AA       TAX             copy back to index
.,A3B5 D0 D8    BNE $A38F       loop if not at start of stack
.,A3B7 60       RTS             

                                *** open up a space in the memory, set the end of arrays
.,A3B8 20 08 A4 JSR $A408       check available memory, do out of memory error if no room
.,A3BB 85 31    STA $31         set end of arrays low byte
.,A3BD 84 32    STY $32         set end of arrays high byte
                                open up a space in the memory, don't set the array end
.,A3BF 38       SEC             set carry for subtract
.,A3C0 A5 5A    LDA $5A         get block end low byte
.,A3C2 E5 5F    SBC $5F         subtract block start low byte
.,A3C4 85 22    STA $22         save MOD(block length/$100) byte
.,A3C6 A8       TAY             copy MOD(block length/$100) byte to Y
.,A3C7 A5 5B    LDA $5B         get block end high byte
.,A3C9 E5 60    SBC $60         subtract block start high byte
.,A3CB AA       TAX             copy block length high byte to X
.,A3CC E8       INX             +1 to allow for count=0 exit
.,A3CD 98       TYA             copy block length low byte to A
.,A3CE F0 23    BEQ $A3F3       branch if length low byte=0
                                block is (X-1)*256+Y bytes, do the Y bytes first
.,A3D0 A5 5A    LDA $5A         get block end low byte
.,A3D2 38       SEC             set carry for subtract
.,A3D3 E5 22    SBC $22         subtract MOD(block length/$100) byte
.,A3D5 85 5A    STA $5A         save corrected old block end low byte
.,A3D7 B0 03    BCS $A3DC       branch if no underflow
.,A3D9 C6 5B    DEC $5B         else decrement block end high byte
.,A3DB 38       SEC             set carry for subtract
.,A3DC A5 58    LDA $58         get destination end low byte
.,A3DE E5 22    SBC $22         subtract MOD(block length/$100) byte
.,A3E0 85 58    STA $58         save modified new block end low byte
.,A3E2 B0 08    BCS $A3EC       branch if no underflow
.,A3E4 C6 59    DEC $59         else decrement block end high byte
.,A3E6 90 04    BCC $A3EC       branch always
.,A3E8 B1 5A    LDA ($5A),Y     get byte from source
.,A3EA 91 58    STA ($58),Y     copy byte to destination
.,A3EC 88       DEY             decrement index
.,A3ED D0 F9    BNE $A3E8       loop until Y=0
                                now do Y=0 indexed byte
.,A3EF B1 5A    LDA ($5A),Y     get byte from source
.,A3F1 91 58    STA ($58),Y     save byte to destination
.,A3F3 C6 5B    DEC $5B         decrement source pointer high byte
.,A3F5 C6 59    DEC $59         decrement destination pointer high byte
.,A3F7 CA       DEX             decrement block count
.,A3F8 D0 F2    BNE $A3EC       loop until count = $0
.,A3FA 60       RTS             

                                *** check room on stack for A bytes
                                if stack too deep do out of memory error
.,A3FB 0A       ASL             *2
.,A3FC 69 3E    ADC #$3E        need at least $3E bytes free
.,A3FE B0 35    BCS $A435       if overflow go do out of memory error then warm start
.,A400 85 22    STA $22         save result in temp byte
.,A402 BA       TSX             copy stack
.,A403 E4 22    CPX $22         compare new limit with stack
.,A405 90 2E    BCC $A435       if stack < limit do out of memory error then warm start
.,A407 60       RTS             
