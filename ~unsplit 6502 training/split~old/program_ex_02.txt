6502 Program Example 02

Here is a program which is designed to add together two sixteen bits numbers.  Unfortunately, the accumulator register is only 8 bits long, so we have to do it in two stages.  After we have got the numbers stored in memory, we have to add together the least significant bytes of each number, which may or may not generate a carry, store that part of the result, then add together the most significant bytes of each number, along with the carry, and store that part of the result.



; Program to add two 16 bit numbers
; The numbers being added are $0194 and $01BA
; Add1601.65s

	.ORG $0200	; Store machine code starting here

	LDA #$94	; Store least significant end of number 1 in first	
	STA NO1+0	;   byte labelled NO1
	LDA #$01	; Store most significant end of number 1 in next byte
	STA NO1+1	;   after the one labelled NO1

	LDA #$BA	; Store little end of number 2 in first 
	STA NO2+0	;   byte labelled NO2
	LDA #$01	; Store big end of number 2 in next byte after 
	STA NO2+1	;   the one labelled NO2
	
	CLC		; Clear the carry flag
	LDA NO1+0	; Load little end of number 1 into accumulator register
	ADC NO2+0	; Add with carry the little end of number 2
	STA RES+0	; Store the little end of the result in byte labelled RES
	LDA NO1+1	; Load big end of number 1 into accumulator
	ADC NO2+1	; Add with carry the big end of number 2
	STA RES+1	; Store the big end of the result in the byte 
 			;     following the one labelled RES
	
	BRK		; Stop running the program
	
NO1:	.DW $0000	; The .DW directive instructs the assembler to 
 			;       reserve one word (16 bits)
NO2:	.DW $0000	;       of memory, and allows the programmer to 
 			;       refer to it by using a label.
RES:	.DW $0000	;  This is how you declare variables.



Exercises

Write out the machine code instructions that the assembler would produce for this program.  Check your answer against the simulator.

Trace through the program and watch the processor do the work.

You might have once written a C program, which involved a loop, and put a very high number in for it to count to.  At a certain point the numbers might have suddenly turned negative.  What happened?

How could we make this program more robust: for example, what would happen if we added $7FFF to $7FFF?

What issues are involved with the output of the result?

