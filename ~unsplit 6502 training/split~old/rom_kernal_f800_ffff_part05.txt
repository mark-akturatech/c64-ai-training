
                                *** set/read vectored I/O from (XY), Cb = 1 to read, Cb = 0 to set
.,FD1A 86 C3    STX $C3         save pointer low byte
.,FD1C 84 C4    STY $C4         save pointer high byte
.,FD1E A0 1F    LDY #$1F        set byte count
.,FD20 B9 14 03 LDA $0314,Y     read vector byte from vectors
.,FD23 B0 02    BCS $FD27       branch if read vectors
.,FD25 B1 C3    LDA ($C3),Y     read vector byte from (XY)
.,FD27 91 C3    STA ($C3),Y     save byte to (XY)
.,FD29 99 14 03 STA $0314,Y     save byte to vector
.,FD2C 88       DEY             decrement index
.,FD2D 10 F1    BPL $FD20       loop if more to do
.,FD2F 60       RTS             
                                 The above code works but it tries to write to the ROM. while this is usually harmless
                                 systems that use flash ROM may suffer. Here is a version that makes the extra write
                                 to RAM instead but is otherwise identical in function. ##
                                
                                 set/read vectored I/O from (XY), Cb = 1 to read, Cb = 0 to set
                                
                                STX $C3         ; save pointer low byte
                                STY $C4         ; save pointer high byte
                                LDY #$1F        ; set byte count
                                LDA ($C3),Y     ; read vector byte from (XY)
                                BCC $FD29       ; branch if set vectors
                                
                                LDA $0314,Y     ; else read vector byte from vectors
                                STA ($C3),Y     ; save byte to (XY)
                                STA $0314,Y     ; save byte to vector
                                DEY             ; decrement index
                                BPL $FD20       ; loop if more to do
                                
                                RTS

                                *** kernal vectors
.:FD30 31 EA                    $0314 IRQ vector
.:FD32 66 FE                    $0316 BRK vector
.:FD34 47 FE                    $0318 NMI vector
.:FD36 4A F3                    $031A open a logical file
.:FD38 91 F2                    $031C close a specified logical file
.:FD3A 0E F2                    $031E open channel for input
.:FD3C 50 F2                    $0320 open channel for output
.:FD3E 33 F3                    $0322 close input and output channels
.:FD40 57 F1                    $0324 input character from channel
.:FD42 CA F1                    $0326 output character to channel
.:FD44 ED F6                    $0328 scan stop key
.:FD46 3E F1                    $032A get character from the input device
.:FD48 2F F3                    $032C close all channels and files
.:FD4A 66 FE                    $032E user function
                                Vector to user defined command, currently points to BRK.
                                This appears to be a holdover from PET days, when the built-in machine language monitor
                                would jump through the $032E vector when it encountered a command that it did not
                                understand, allowing the user to add new commands to the monitor.
                                Although this vector is initialized to point to the routine called by STOP/RESTORE and
                                the BRK interrupt, and is updated by the kernal vector routine at $FD57, it no longer
                                has any function.
.:FD4C A5 F4                    $0330 load
.:FD4E ED F5                    $0332 save

                                *** test RAM and find RAM end
.,FD50 A9 00    LDA #$00        clear A
.,FD52 A8       TAY             clear index
.,FD53 99 02 00 STA $0002,Y     clear page 0, don't do $0000 or $0001
.,FD56 99 00 02 STA $0200,Y     clear page 2
.,FD59 99 00 03 STA $0300,Y     clear page 3
.,FD5C C8       INY             increment index
.,FD5D D0 F4    BNE $FD53       loop if more to do
.,FD5F A2 3C    LDX #$3C        set cassette buffer pointer low byte
.,FD61 A0 03    LDY #$03        set cassette buffer pointer high byte
.,FD63 86 B2    STX $B2         save tape buffer start pointer low byte
.,FD65 84 B3    STY $B3         save tape buffer start pointer high byte
.,FD67 A8       TAY             clear Y
.,FD68 A9 03    LDA #$03        set RAM test pointer high byte
.,FD6A 85 C2    STA $C2         save RAM test pointer high byte
.,FD6C E6 C2    INC $C2         increment RAM test pointer high byte
.,FD6E B1 C1    LDA ($C1),Y     
.,FD70 AA       TAX             
.,FD71 A9 55    LDA #$55        
.,FD73 91 C1    STA ($C1),Y     
.,FD75 D1 C1    CMP ($C1),Y     
.,FD77 D0 0F    BNE $FD88       
.,FD79 2A       ROL             
.,FD7A 91 C1    STA ($C1),Y     
.,FD7C D1 C1    CMP ($C1),Y     
.,FD7E D0 08    BNE $FD88       
.,FD80 8A       TXA             
.,FD81 91 C1    STA ($C1),Y     
.,FD83 C8       INY             
.,FD84 D0 E8    BNE $FD6E       
.,FD86 F0 E4    BEQ $FD6C       
.,FD88 98       TYA             
.,FD89 AA       TAX             
.,FD8A A4 C2    LDY $C2         
.,FD8C 18       CLC             
.,FD8D 20 2D FE JSR $FE2D       set the top of memory
.,FD90 A9 08    LDA #$08        
.,FD92 8D 82 02 STA $0282       save the OS start of memory high byte
.,FD95 A9 04    LDA #$04        
.,FD97 8D 88 02 STA $0288       save the screen memory page
.,FD9A 60       RTS             

                                *** tape IRQ vectors
.:FD9B 6A FC                    $08 write tape leader IRQ routine
.:FD9D CD FB                    $0A tape write IRQ routine
.:FD9F 31 EA                    $0C normal IRQ vector
.:FDA1 2C F9                    $0E read tape bits IRQ routine

                                *** initialise SID, CIA and IRQ
.,FDA3 A9 7F    LDA #$7F        disable all interrupts
.,FDA5 8D 0D DC STA $DC0D       save VIA 1 ICR
.,FDA8 8D 0D DD STA $DD0D       save VIA 2 ICR
.,FDAB 8D 00 DC STA $DC00       save VIA 1 DRA, keyboard column drive
.,FDAE A9 08    LDA #$08        set timer single shot
.,FDB0 8D 0E DC STA $DC0E       save VIA 1 CRA
.,FDB3 8D 0E DD STA $DD0E       save VIA 2 CRA
.,FDB6 8D 0F DC STA $DC0F       save VIA 1 CRB
.,FDB9 8D 0F DD STA $DD0F       save VIA 2 CRB
.,FDBC A2 00    LDX #$00        set all inputs
.,FDBE 8E 03 DC STX $DC03       save VIA 1 DDRB, keyboard row
.,FDC1 8E 03 DD STX $DD03       save VIA 2 DDRB, RS232 port
.,FDC4 8E 18 D4 STX $D418       clear the volume and filter select register
.,FDC7 CA       DEX             set X = $FF
.,FDC8 8E 02 DC STX $DC02       save VIA 1 DDRA, keyboard column
.,FDCB A9 07    LDA #$07        DATA out high, CLK out high, ATN out high, RE232 Tx DATA
                                high, video address 15 = 1, video address 14 = 1
.,FDCD 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,FDD0 A9 3F    LDA #$3F        set serial DATA input, serial CLK input
.,FDD2 8D 02 DD STA $DD02       save VIA 2 DDRA, serial port and video address
.,FDD5 A9 E7    LDA #$E7        set 1110 0111, motor off, enable I/O, enable KERNAL,
                                enable BASIC
.,FDD7 85 01    STA $01         save the 6510 I/O port
.,FDD9 A9 2F    LDA #$2F        set 0010 1111, 0 = input, 1 = output
.,FDDB 85 00    STA $00         save the 6510 I/O port direction register
.,FDDD AD A6 02 LDA $02A6       get the PAL/NTSC flag
.,FDE0 F0 0A    BEQ $FDEC       if NTSC go set NTSC timing
                                else set PAL timing
.,FDE2 A9 25    LDA #$25        
.,FDE4 8D 04 DC STA $DC04       save VIA 1 timer A low byte
.,FDE7 A9 40    LDA #$40        
.,FDE9 4C F3 FD JMP $FDF3       
.,FDEC A9 95    LDA #$95        
.,FDEE 8D 04 DC STA $DC04       save VIA 1 timer A low byte
.,FDF1 A9 42    LDA #$42        
.,FDF3 8D 05 DC STA $DC05       save VIA 1 timer A high byte
.,FDF6 4C 6E FF JMP $FF6E       

                                *** set filename
.,FDF9 85 B7    STA $B7         set file name length
.,FDFB 86 BB    STX $BB         set file name pointer low byte
.,FDFD 84 BC    STY $BC         set file name pointer high byte
.,FDFF 60       RTS             

                                *** set logical, first and second addresses
.,FE00 85 B8    STA $B8         save the logical file
.,FE02 86 BA    STX $BA         save the device number
.,FE04 84 B9    STY $B9         save the secondary address
.,FE06 60       RTS             

                                *** read I/O status word
.,FE07 A5 BA    LDA $BA         get the device number
.,FE09 C9 02    CMP #$02        compare device with RS232 device
.,FE0B D0 0D    BNE $FE1A       if not RS232 device go ??
                                get RS232 device status
.,FE0D AD 97 02 LDA $0297       get the RS232 status register
.,FE10 48       PHA             save the RS232 status value
.,FE11 A9 00    LDA #$00        clear A
.,FE13 8D 97 02 STA $0297       clear the RS232 status register
.,FE16 68       PLA             restore the RS232 status value
.,FE17 60       RTS             

                                *** control kernal messages
.,FE18 85 9D    STA $9D         set message mode flag
.,FE1A A5 90    LDA $90         read the serial status byte

                                *** OR into the serial status byte
.,FE1C 05 90    ORA $90         OR with the serial status byte
.,FE1E 85 90    STA $90         save the serial status byte
.,FE20 60       RTS             

                                *** set timeout on serial bus
.,FE21 8D 85 02 STA $0285       save serial bus timeout flag
.,FE24 60       RTS             

                                *** read/set the top of memory, Cb = 1 to read, Cb = 0 to set
.,FE25 90 06    BCC $FE2D       if Cb clear go set the top of memory

                                *** read the top of memory
.,FE27 AE 83 02 LDX $0283       get memory top low byte
.,FE2A AC 84 02 LDY $0284       get memory top high byte

                                *** set the top of memory
.,FE2D 8E 83 02 STX $0283       set memory top low byte
.,FE30 8C 84 02 STY $0284       set memory top high byte
.,FE33 60       RTS             

                                *** read/set the bottom of memory, Cb = 1 to read, Cb = 0 to set
.,FE34 90 06    BCC $FE3C       if Cb clear go set the bottom of memory
.,FE36 AE 81 02 LDX $0281       get the OS start of memory low byte
.,FE39 AC 82 02 LDY $0282       get the OS start of memory high byte
.,FE3C 8E 81 02 STX $0281       save the OS start of memory low byte
.,FE3F 8C 82 02 STY $0282       save the OS start of memory high byte
.,FE42 60       RTS             

                                *** NMI vector
.,FE43 78       SEI             disable the interrupts
.,FE44 6C 18 03 JMP ($0318)     do NMI vector

                                *** NMI handler
.,FE47 48       PHA             save A
.,FE48 8A       TXA             copy X
.,FE49 48       PHA             save X
.,FE4A 98       TYA             copy Y
.,FE4B 48       PHA             save Y
.,FE4C A9 7F    LDA #$7F        disable all interrupts
.,FE4E 8D 0D DD STA $DD0D       save VIA 2 ICR
.,FE51 AC 0D DD LDY $DD0D       save VIA 2 ICR
.,FE54 30 1C    BMI $FE72       
.,FE56 20 02 FD JSR $FD02       scan for autostart ROM at $8000
.,FE59 D0 03    BNE $FE5E       branch if no autostart ROM
.,FE5B 6C 02 80 JMP ($8002)     else do autostart ROM break entry
.,FE5E 20 BC F6 JSR $F6BC       increment real time clock
.,FE61 20 E1 FF JSR $FFE1       scan stop key
.,FE64 D0 0C    BNE $FE72       if not [STOP] restore registers and exit interrupt

                                *** user function default vector
                                BRK handler
.,FE66 20 15 FD JSR $FD15       restore default I/O vectors
.,FE69 20 A3 FD JSR $FDA3       initialise SID, CIA and IRQ
.,FE6C 20 18 E5 JSR $E518       initialise the screen and keyboard
.,FE6F 6C 02 A0 JMP ($A002)     do BASIC break entry

                                *** RS232 NMI routine
.,FE72 98       TYA             
.,FE73 2D A1 02 AND $02A1       AND with the RS-232 interrupt enable byte
.,FE76 AA       TAX             
.,FE77 29 01    AND #$01        
.,FE79 F0 28    BEQ $FEA3       
.,FE7B AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,FE7E 29 FB    AND #$FB        mask xxxx x0xx, clear RS232 Tx DATA
.,FE80 05 B5    ORA $B5         OR in the RS232 transmit data bit
.,FE82 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,FE85 AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,FE88 8D 0D DD STA $DD0D       save VIA 2 ICR
.,FE8B 8A       TXA             
.,FE8C 29 12    AND #$12        
.,FE8E F0 0D    BEQ $FE9D       
.,FE90 29 02    AND #$02        
.,FE92 F0 06    BEQ $FE9A       
.,FE94 20 D6 FE JSR $FED6       
.,FE97 4C 9D FE JMP $FE9D       
.,FE9A 20 07 FF JSR $FF07       
.,FE9D 20 BB EE JSR $EEBB       
.,FEA0 4C B6 FE JMP $FEB6       
.,FEA3 8A       TXA             get active interrupts back
.,FEA4 29 02    AND #$02        mask ?? interrupt
.,FEA6 F0 06    BEQ $FEAE       branch if not ?? interrupt
                                was ?? interrupt
.,FEA8 20 D6 FE JSR $FED6       
.,FEAB 4C B6 FE JMP $FEB6       
.,FEAE 8A       TXA             get active interrupts back
.,FEAF 29 10    AND #$10        mask CB1 interrupt, Rx data bit transition
.,FEB1 F0 03    BEQ $FEB6       if no bit restore registers and exit interrupt
.,FEB3 20 07 FF JSR $FF07       
.,FEB6 AD A1 02 LDA $02A1       get the RS-232 interrupt enable byte
.,FEB9 8D 0D DD STA $DD0D       save VIA 2 ICR
.,FEBC 68       PLA             pull Y
.,FEBD A8       TAY             restore Y
.,FEBE 68       PLA             pull X
.,FEBF AA       TAX             restore X
.,FEC0 68       PLA             restore A
.,FEC1 40       RTI             

                                *** baud rate word is calculated from ..
                                
                                (system clock / baud rate) / 2 - 100
                                
                                    system clock
                                    ------------
                                PAL        985248 Hz
                                NTSC     1022727 Hz
                                baud rate tables for NTSC C64
.:FEC2 C1 27                      50   baud   1027700
.:FEC4 3E 1A                      75   baud   1022700
.:FEC6 C5 11                     110   baud   1022780
.:FEC8 74 0E                     134.5 baud   1022200
.:FECA ED 0C                     150   baud   1022700
.:FECC 45 06                     300   baud   1023000
.:FECE F0 02                     600   baud   1022400
.:FED0 46 01                    1200   baud   1022400
.:FED2 B8 00                    1800   baud   1022400
.:FED4 71 00                    2400   baud   1022400
