
                                *** perform NEXT
.,AD1E D0 04    BNE $AD24       branch if NEXT variable
.,AD20 A0 00    LDY #$00        else clear Y
.,AD22 F0 03    BEQ $AD27       branch always
                                NEXT variable
.,AD24 20 8B B0 JSR $B08B       get variable address
.,AD27 85 49    STA $49         save FOR/NEXT variable pointer low byte
.,AD29 84 4A    STY $4A         save FOR/NEXT variable pointer high byte
                                (high byte cleared if no variable defined)
.,AD2B 20 8A A3 JSR $A38A       search the stack for FOR or GOSUB activity
.,AD2E F0 05    BEQ $AD35       branch if FOR, this variable, found
.,AD30 A2 0A    LDX #$0A        else set error $0A, next without for error
.,AD32 4C 37 A4 JMP $A437       do error #X then warm start
                                found this FOR variable
.,AD35 9A       TXS             update stack pointer
.,AD36 8A       TXA             copy stack pointer
.,AD37 18       CLC             clear carry for add
.,AD38 69 04    ADC #$04        point to STEP value
.,AD3A 48       PHA             save it
.,AD3B 69 06    ADC #$06        point to TO value
.,AD3D 85 24    STA $24         save pointer to TO variable for compare
.,AD3F 68       PLA             restore pointer to STEP value
.,AD40 A0 01    LDY #$01        point to stack page
.,AD42 20 A2 BB JSR $BBA2       unpack memory (AY) into FAC1
.,AD45 BA       TSX             get stack pointer back
.,AD46 BD 09 01 LDA $0109,X     get step sign
.,AD49 85 66    STA $66         save FAC1 sign (b7)
.,AD4B A5 49    LDA $49         get FOR/NEXT variable pointer low byte
.,AD4D A4 4A    LDY $4A         get FOR/NEXT variable pointer high byte
.,AD4F 20 67 B8 JSR $B867       add FOR variable to FAC1
.,AD52 20 D0 BB JSR $BBD0       pack FAC1 into FOR variable
.,AD55 A0 01    LDY #$01        point to stack page
.,AD57 20 5D BC JSR $BC5D       compare FAC1 with TO value
.,AD5A BA       TSX             get stack pointer back
.,AD5B 38       SEC             set carry for subtract
.,AD5C FD 09 01 SBC $0109,X     subtract step sign
.,AD5F F0 17    BEQ $AD78       branch if =, loop complete
                                loop back and do it all again
.,AD61 BD 0F 01 LDA $010F,X     get FOR line low byte
.,AD64 85 39    STA $39         save current line number low byte
.,AD66 BD 10 01 LDA $0110,X     get FOR line high byte
.,AD69 85 3A    STA $3A         save current line number high byte
.,AD6B BD 12 01 LDA $0112,X     get BASIC execute pointer low byte
.,AD6E 85 7A    STA $7A         save BASIC execute pointer low byte
.,AD70 BD 11 01 LDA $0111,X     get BASIC execute pointer high byte
.,AD73 85 7B    STA $7B         save BASIC execute pointer high byte
.,AD75 4C AE A7 JMP $A7AE       go do interpreter inner loop
                                NEXT loop comlete
.,AD78 8A       TXA             stack copy to A
.,AD79 69 11    ADC #$11        add $12, $11 + carry, to dump FOR structure
.,AD7B AA       TAX             copy back to index
.,AD7C 9A       TXS             copy to stack pointer
.,AD7D 20 79 00 JSR $0079       scan memory
.,AD80 C9 2C    CMP #$2C        compare with ","
.,AD82 D0 F1    BNE $AD75       if not "," go do interpreter inner loop
                                was "," so another NEXT variable to do
.,AD84 20 73 00 JSR $0073       increment and scan memory
.,AD87 20 24 AD JSR $AD24       do NEXT variable

                                *** evaluate expression and check type mismatch
.,AD8A 20 9E AD JSR $AD9E       evaluate expression
                                check if source and destination are numeric
.,AD8D 18       CLC             
.:AD8E 24       .BYTE $24       makes next line BIT $38
                                check if source and destination are string
.,AD8F 38       SEC             destination is string
                                type match check, set C for string, clear C for numeric
.,AD90 24 0D    BIT $0D         test data type flag, $FF = string, $00 = numeric
.,AD92 30 03    BMI $AD97       branch if string
.,AD94 B0 03    BCS $AD99       if destiantion is numeric do type missmatch error
.,AD96 60       RTS             
.,AD97 B0 FD    BCS $AD96       exit if destination is string
                                do type missmatch error
.,AD99 A2 16    LDX #$16        error code $16, type missmatch error
.,AD9B 4C 37 A4 JMP $A437       do error #X then warm start

                                *** evaluate expression
.,AD9E A6 7A    LDX $7A         get BASIC execute pointer low byte
.,ADA0 D0 02    BNE $ADA4       skip next if not zero
.,ADA2 C6 7B    DEC $7B         else decrement BASIC execute pointer high byte
.,ADA4 C6 7A    DEC $7A         decrement BASIC execute pointer low byte
.,ADA6 A2 00    LDX #$00        set null precedence, flag done
.:ADA8 24       .BYTE $24       makes next line BIT $48
.,ADA9 48       PHA             push compare evaluation byte if branch to here
.,ADAA 8A       TXA             copy precedence byte
.,ADAB 48       PHA             push precedence byte
.,ADAC A9 01    LDA #$01        2 bytes
.,ADAE 20 FB A3 JSR $A3FB       check room on stack for A*2 bytes
.,ADB1 20 83 AE JSR $AE83       get value from line
.,ADB4 A9 00    LDA #$00        clear A
.,ADB6 85 4D    STA $4D         clear comparrison evaluation flag
.,ADB8 20 79 00 JSR $0079       scan memory
.,ADBB 38       SEC             set carry for subtract
.,ADBC E9 B1    SBC #$B1        subtract the token for ">"
.,ADBE 90 17    BCC $ADD7       branch if < ">"
.,ADC0 C9 03    CMP #$03        compare with ">" to +3
.,ADC2 B0 13    BCS $ADD7       branch if >= 3
                                was token for ">" "=" or "<"
.,ADC4 C9 01    CMP #$01compare with token for =
.,ADC6 2A       ROL             *2, b0 = carry (=1 if token was = or <)
.,ADC7 49 01    EOR #$01        toggle b0
.,ADC9 45 4D    EOR $4D         EOR with comparrison evaluation flag
.,ADCB C5 4D    CMP $4D         compare with comparrison evaluation flag
.,ADCD 90 61    BCC $AE30       if < saved flag do syntax error then warm start
.,ADCF 85 4D    STA $4D         save new comparrison evaluation flag
.,ADD1 20 73 00 JSR $0073       increment and scan memory
.,ADD4 4C BB AD JMP $ADBB       go do next character
.,ADD7 A6 4D    LDX $4D         get comparrison evaluation flag
.,ADD9 D0 2C    BNE $AE07       branch if compare function
.,ADDB B0 7B    BCS $AE58       go do functions
                                else was < TK_GT so is operator or lower
.,ADDD 69 07    ADC #$07        add # of operators (+, -, *, /, ^, AND or OR)
.,ADDF 90 77    BCC $AE58       branch if < + operator
                                carry was set so token was +, -, *, /, ^, AND or OR
.,ADE1 65 0D    ADC $0D         add data type flag, $FF = string, $00 = numeric
.,ADE3 D0 03    BNE $ADE8       branch if not string or not + token
                                will only be $00 if type is string and token was +
.,ADE5 4C 3D B6 JMP $B63D       add strings, string 1 is in the descriptor, string 2
                                is in line, and return
.,ADE8 69 FF    ADC #$FF        -1 (corrects for carry add)
.,ADEA 85 22    STA $22         save it
.,ADEC 0A       ASL             *2
.,ADED 65 22    ADC $22         *3
.,ADEF A8       TAY             copy to index
.,ADF0 68       PLA             pull previous precedence
.,ADF1 D9 80 A0 CMP $A080,Y     compare with precedence byte
.,ADF4 B0 67    BCS $AE5D       branch if A >=
.,ADF6 20 8D AD JSR $AD8D       check if source is numeric, else do type mismatch
.,ADF9 48       PHA             save precedence
.,ADFA 20 20 AE JSR $AE20       get vector, execute function then continue evaluation
.,ADFD 68       PLArestore precedence
.,ADFE A4 4B    LDY $4B         get precedence stacked flag
.,AE00 10 17    BPL $AE19       branch if stacked values
.,AE02 AA       TAX             copy precedence, set flags
.,AE03 F0 56    BEQ $AE5B       exit if done
.,AE05 D0 5F    BNE $AE66       else pop FAC2 and return, branch always
.,AE07 46 0D    LSR $0D         clear data type flag, $FF = string, $00 = numeric
.,AE09 8A       TXA             copy compare function flag
.,AE0A 2A       ROL             <<1, shift data type flag into b0, 1 = string, 0 = num
.,AE0B A6 7A    LDX $7A         get BASIC execute pointer low byte
.,AE0D D0 02    BNE $AE11       branch if no underflow
.,AE0F C6 7B    DEC $7B         else decrement BASIC execute pointer high byte
.,AE11 C6 7A    DEC $7A         decrement BASIC execute pointer low byte
.,AE13 A0 1B    LDY #$1B        
                                set offset to = operator precedence entry
.,AE15 85 4D    STA $4D         save new comparrison evaluation flag
.,AE17 D0 D7    BNE $ADF0       branch always
.,AE19 D9 80 A0 CMP $A080,Y     compare with stacked function precedence
.,AE1C B0 48    BCS $AE66       if A >=, pop FAC2 and return
.,AE1E 90 D9    BCC $ADF9       else go stack this one and continue, branch always

                                *** get vector, execute function then continue evaluation
.,AE20 B9 82 A0 LDA $A082,Y     get function vector high byte
.,AE23 48       PHA             onto stack
.,AE24 B9 81 A0 LDA $A081,Y     get function vector low byte
.,AE27 48       PHA             onto stack
                                now push sign, round FAC1 and put on stack
.,AE28 20 33 AE JSR $AE33       function will return here, then the next RTS will call
                                the function
.,AE2B A5 4D    LDA $4D         get comparrison evaluation flag
.,AE2D 4C A9 AD JMP $ADA9       continue evaluating expression
.,AE30 4C 08 AF JMP $AF08       do syntax error then warm start
.,AE33 A5 66    LDA $66         get FAC1 sign (b7)
.,AE35 BE 80 A0 LDX $A080,Y     get precedence byte

                                *** push sign, round FAC1 and put on stack
.,AE38 A8       TAY             copy sign
.,AE39 68       PLA             get return address low byte
.,AE3A 85 22    STA $22         save it
.,AE3C E6 22    INC $22         increment it as return-1 is pushed
                                note, no check is made on the high byte so if the calling
                                routine ever assembles to a page edge then this all goes
                                horribly wrong!
.,AE3E 68       PLA             get return address high byte
.,AE3F 85 23    STA $23         save it
.,AE41 98       TYA             restore sign
.,AE42 48       PHA             push sign

                                *** round FAC1 and put on stack
.,AE43 20 1B BC JSR $BC1B       round FAC1
.,AE46 A5 65    LDA $65         get FAC1 mantissa 4
.,AE48 48       PHA             save it
.,AE49 A5 64    LDA $64         get FAC1 mantissa 3
.,AE4B 48       PHA             save it
.,AE4C A5 63    LDA $63         get FAC1 mantissa 2
.,AE4E 48       PHA             save it
.,AE4F A5 62    LDA $62         get FAC1 mantissa 1
.,AE51 48       PHA             save it
.,AE52 A5 61    LDA $61         get FAC1 exponent
.,AE54 48       PHA             save it
.,AE55 6C 22 00 JMP ($0022)     return, sort of

                                *** do functions
.,AE58 A0 FF    LDY #$FF        flag function
.,AE5A 68       PLA             pull precedence byte
.,AE5B F0 23    BEQ $AE80       exit if done
.,AE5D C9 64    CMP #$64        compare previous precedence with $64
.,AE5F F0 03    BEQ $AE64       branch if was $64 (< function)
.,AE61 20 8D AD JSR $AD8D       check if source is numeric, else do type mismatch
.,AE64 84 4B    STY $4B         save precedence stacked flag
                                pop FAC2 and return
.,AE66 68       PLA             pop byte
.,AE67 4A       LSR             shift out comparison evaluation lowest bit
.,AE68 85 12    STA $12         save the comparison evaluation flag
.,AE6A 68       PLA             pop exponent
.,AE6B 85 69    STA $69         save FAC2 exponent
.,AE6D 68       PLA             pop mantissa 1
.,AE6E 85 6A    STA $6A         save FAC2 mantissa 1
.,AE70 68       PLA             pop mantissa 2
.,AE71 85 6B    STA $6B         save FAC2 mantissa 2
.,AE73 68       PLA             pop mantissa 3
.,AE74 85 6C    STA $6C         save FAC2 mantissa 3
.,AE76 68       PLA             pop mantissa 4
.,AE77 85 6D    STA $6D         save FAC2 mantissa 4
.,AE79 68       PLA             pop sign
.,AE7A 85 6E    STA $6E         save FAC2 sign (b7)
.,AE7C 45 66    EOR $66         EOR FAC1 sign (b7)
.,AE7E 85 6F    STA $6F         save sign compare (FAC1 EOR FAC2)
.,AE80 A5 61    LDA $61         get FAC1 exponent
.,AE82 60       RTS             

                                *** get value from line
.,AE83 6C 0A 03 JMP ($030A)     get arithmetic element

                                *** get arithmetic element, the get arithmetic element vector is initialised to point here
.,AE86 A9 00    LDA #$00        clear byte
.,AE88 85 0D    STA $0D         clear data type flag, $FF = string, $00 = numeric
.,AE8A 20 73 00 JSR $0073       increment and scan memory
.,AE8D B0 03    BCS $AE92       branch if not numeric character
                                else numeric string found (e.g. 123)
.,AE8F 4C F3 BC JMP $BCF3       get FAC1 from string and return
                                get value from line .. continued
                                wasn't a number so ...
.,AE92 20 13 B1 JSR $B113       check byte, return Cb = 0 if<"A" or >"Z"
.,AE95 90 03    BCC $AE9A       branch if not variable name
.,AE97 4C 28 AF JMP $AF28       variable name set-up and return
.,AE9A C9 FF    CMP #$FF        compare with token for PI
.,AE9C D0 0F    BNE $AEAD       branch if not PI
.,AE9E A9 A8    LDA #$A8        get PI pointer low byte
.,AEA0 A0 AE    LDY #$AE        get PI pointer high byte
.,AEA2 20 A2 BB JSR $BBA2       unpack memory (AY) into FAC1
.,AEA5 4C 73 00 JMP $0073       increment and scan memory and return

                                *** PI as floating number
.:AEA8 82 49 0F DA A1           3.141592653

                                *** get value from line .. continued
                                wasn't variable name so ...
.,AEAD C9 2E    CMP #$2E        compare with "."
.,AEAF F0 DE    BEQ $AE8F       if so get FAC1 from string and return, e.g. was .123
                                wasn't .123 so ...
.,AEB1 C9 AB    CMP #$AB        compare with token for -
.,AEB3 F0 58    BEQ $AF0D       branch if - token, do set-up for functions
                                wasn't -123 so ...
.,AEB5 C9 AA    CMP #$AA        compare with token for +
.,AEB7 F0 D1    BEQ $AE8A       branch if + token, +1 = 1 so ignore leading +
                                it wasn't any sort of number so ...
.,AEB9 C9 22    CMP #$22        compare with "
.,AEBB D0 0F    BNE $AECC       branch if not open quote
                                was open quote so get the enclosed string
