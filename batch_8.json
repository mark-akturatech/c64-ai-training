[{"id": "map-D003", "address_start": 53251, "address_end": 53251, "hex_start": "$D003", "hex_end": "$D003", "label": "SP1Y", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53251         $D003          SP1Y\nSprite 1 Vertical Position"}, {"id": "map-D004", "address_start": 53252, "address_end": 53252, "hex_start": "$D004", "hex_end": "$D004", "label": "SP2X", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53252         $D004          SP2X\nSprite 2 Horizontal Position"}, {"id": "map-D005", "address_start": 53253, "address_end": 53253, "hex_start": "$D005", "hex_end": "$D005", "label": "SP2Y", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53253         $D005          SP2Y\nSprite 2 Vertical Position"}, {"id": "map-D006", "address_start": 53254, "address_end": 53254, "hex_start": "$D006", "hex_end": "$D006", "label": "SP3X", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53254         $D006          SP3X\nSprite 3 Horizontal Position"}, {"id": "map-D007", "address_start": 53255, "address_end": 53255, "hex_start": "$D007", "hex_end": "$D007", "label": "SP3Y", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53255         $D007          SP3Y\nSprite 3 Vertical Position"}, {"id": "map-D008", "address_start": 53256, "address_end": 53256, "hex_start": "$D008", "hex_end": "$D008", "label": "SP4X", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53256         $D008          SP4X\nSprite 4 Horizontal Position"}, {"id": "map-D009", "address_start": 53257, "address_end": 53257, "hex_start": "$D009", "hex_end": "$D009", "label": "SP4Y", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53257         $D009          SP4Y\nSprite 4 Vertical Position"}, {"id": "map-D00A", "address_start": 53258, "address_end": 53258, "hex_start": "$D00A", "hex_end": "$D00A", "label": "SP5X", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53258         $D00A          SP5X\nSprite 5 Horizontal Position"}, {"id": "map-D00B", "address_start": 53259, "address_end": 53259, "hex_start": "$D00B", "hex_end": "$D00B", "label": "SP5Y", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53259         $D00B          SP5Y\nSprite 5 Vertical Position"}, {"id": "map-D00C", "address_start": 53260, "address_end": 53260, "hex_start": "$D00C", "hex_end": "$D00C", "label": "SP6X", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53260         $D00C          SP6X\nSprite 6 Horizontal Position"}, {"id": "map-D00D", "address_start": 53261, "address_end": 53261, "hex_start": "$D00D", "hex_end": "$D00D", "label": "SP6Y", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53261         $D00D          SP6Y\nSprite 6 Vertical Position"}, {"id": "map-D00E", "address_start": 53262, "address_end": 53262, "hex_start": "$D00E", "hex_end": "$D00E", "label": "SP7X", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53262         $D00E          SP7X\nSprite 7 Horizontal Position"}, {"id": "map-D00F", "address_start": 53263, "address_end": 53263, "hex_start": "$D00F", "hex_end": "$D00F", "label": "SP7Y", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53263         $D00F          SP7Y\nSprite 7 Vertical Position"}, {"id": "map-D010", "address_start": 53264, "address_end": 53264, "hex_start": "$D010", "hex_end": "$D010", "label": "MSIGX", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53264         $D010          MSIGX\nMost Significant Bits of Sprites 0-7 Horizontal Position\n\nBit 0:  Most significant bit of Sprite 0 horizontal position\nBit 1:  Most significant bit of Sprite 1 horizontal position\nBit 2:  Most significant bit of Sprite 2 horizontal position\nBit 3:  Most significant bit of Sprite 3 horizontal position\nBit 4:  Most significant bit of Sprite 4 horizontal position\nBit 5:  Most significant bit of Sprite 5 horizontal position\nBit 6:  Most significant bit of Sprite 6 horizontal position\nBit 7:  Most significant bit of Sprite 7 horizontal position\n\nSetting one of these bites to 1 adds 256 to the horizontal position of\nthe corresponding sprite.  Resetting one of these bits to 0 restricts\nthe horizontal position of the corresponding sprite to a value of 255\nor less"}, {"id": "map-D011", "address_start": 53265, "address_end": 53265, "hex_start": "$D011", "hex_end": "$D011", "label": "SCROLY", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53265         $D011          SCROLY\nVertical Fine Scrolling and Control Register\n\nBits 0-2:  Fine scroll display vertically by X scan lines (0-7)\nBit 3:  Select a 24-row or 25-row text display (1=25 rows, 0=24 rows)\nBit 4:  Blank the entire screen to the same color as the background\n  (0=blank)\nBit 5:  Enable bitmap graphics mode (1=enable)\nBit 6:  Enable extended color text mode (1=enable)\nBit 7:  High bit (Bit 8) of raster compare register at 53266 ($D012)\n\nThis is one of the two important multifunction control registers on\nthe VIC-II chip.  Its defaule value is 155, which sets the high bit of\nthe raster compare to 1, selects a 25-row display, disables the\nblanking feature, and uses a vertical scrolling offset of three scan\nlines.\n\nBits 0-2.  These bits control vertical fine scrolling of the screen\ndisplay.  This feature allows you to move the entire text display\nsmoothly up and down, enabling the display area to act as a window,\nscrolling over a larger text or character graphics display.\n\nSince each row of text is eight scan lines high, if you simply move\neach line of text up one row, the characters travel an appreciable\ndistance each time they move, which gives the motion a jerky quality.\nThis is called coarse scrolling, and you can see an example of it when\nLISTing a program that is too long to fit on the screen all at one\ntime.\n\nBy placing a number from 1 to 7 into these three bits, you can move\nthe whole screen display down by from 1 to 7 dot spaces.  Stepping\nthrough the values 1 to 7 allows you to smoothly make the transition\nfrom having a character appear in one row on the screen to having it\nappear in the next row.  To demonstrate this, type in the following\nsample program, LIST it, and RUN.\n\n10 FOR I= 1 TO 50:FOR J=0 TO 7\n20 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I\n30 FOR I= 1 TO 50:FOR J=7 TO 0 STEP-1\n40 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I\n\nAs you can see, after the display has moved seven dot positions up or\ndown, it starts over at its original position.  In order to continue\nthe scroll, you must do a coarse scroll every time the value of the\nscroll bits goes from 7 to 0, or from 0 to 7.  This is accomplished by\nmoving the display data for each line by 40 bytes in either direction,\noverwriting the data for the last line, and introducing a line of data\nat the opposite end of screen memory to replace it.  Obviously, ony a\nmachine language program can move all of these lines quickly enough to\nmaintain the effect of smooth motion.  The following BASIC program,\nhowever, will give you an iea of what vertical fine scrolling is like:\n\n10 POKE 53281,0:PRINTCHR$(5);CHR$(147)\n20 FORI=1 TO 27:\n30 PRINTTAB(15)CHR$(145)\"            \":POKE 53265,PEEK(53265)AND248\n40 WAIT53265,128:PRINTTAB(15)\"I'M FALLING\"\n50 FOR J=1 TO 7\n60 POKE53265,(PEEK(53265)AND248)+J\n70 FORK=1TO50\n80 NEXT K,J,I:RUN\n\nBit 3.  This bit register allows you to select either the normal\n25-line text display (by setting the bit to 1), or a shortened 24-row\ndisplay (by resetting that bit to 0).  This shortened display is\ncreated by extending the border to overlap the top or bottom row.  The\ncharacters in these rows are still there; they are just covered up.\n\nThe shortened display is designed to aid vertical fine scrolling.  It\ncovers up the line into which new screen data is introduced, so that\nthe viewer does not see the new data being moved into place.\n\nHowever, unlink the register at 53270 ($D016) which shortens the\nscreen by one character space on either side to aid horizontal\nscrolling in either direction, this register can blank only one\nvertical line at a time.  In order to compensate, it blanks the top\nline when the three scroll bits in this register are set to 0, and\nshifts the blanking one scan line at a time as the value of thee bits\nincreases.  Thus the bottom line is totally blanked when these bits\nare set to 7.\n\nBit 4.  Bit 4 of this register controls the screen blanking feature.\nWhen this bit is set to 0, no data can be displayed on the screen.\nInstead, the whole screen will be filled with the color of the frame\n(which is controlled by th eBorder Color Register at 53280 ($D020)).\n\nScreen blanking is useful because of the way in which the VIC-II chip\ninteracts with the 6510 microprocessor.  Since the VIC-II and the 6510\nboth have to address the same memory, they must share the system data\nbus.  Sharing the data bus means that they must take turns whenever\nthey want to address memory.\n\nThe VIC-II chip was designed so that it fetches most of the data it\nneeds during the part of the cycle in which the 6510 is not using the\ndata bus.  But certain operations, such as reading the 40 screen codes\nneeded for each line of text from video mmeory, or fetching sprite\ndata, require that the VIC-II chip get data at a faster rate than is\npossible just by using the off half of the 6510 cycle.\n\nThus, the VIC-II chip must delay the 6510 for a short amount of time\nwhile it is using the data bus to gather display information for text\nor bitmap graphics, and must delay it a little more if sprites are\nalso enabled.  When you set the screen blanking bit to 0, these delays\nare eliminated, and the 6510 processor is allowed to run at its full\nspeed.  This speeds up any processing task a little.\n\nTo demonstrate this, run the following short program.  As you will\nsee, leaving the screen on makes the processor run about 7 percent\nslower than when you turn it off.  If you perform the same timing test\non the VIC-20, you will find that it runs at the same speed with its\nscreen on as the 64 does with its screen off.  And the same test on a\nPET will run substantially slower.\n\n10 PRINT CHR$(147);TAB(13);\"TIMING TEST\":PRINT:TI$=\"000000\":GOTO 30\n20 FOR I=1 TO 10000:NEXT I:RETURN\n30 GOSUB 20:DISPLAY=TI\n40 POKE 53265,11:TI$=\"000000\"\n50 GOSUB 20:NOSCREEN=TI:POKE 53265,27\n60 PRINT \"THE LOOP TOOK\";DISPLAY;\" JIFFIES\"\n70 PRINT \"WITH NO SCREEN BLANKING\":PRINT\n80 PRINT \"THE LOOP TOOK\";NOSCREEN;\" JIFFIES\"\n90 PRINT \"WITH SCREEN BLANKING\":PRINT\n100 PRINT \"SCREEN BLANKING MAKE THE PROCESSOR\"\n110 PRINT \"GO\";DISPLAY/NOSCREEN*100-100;\"PERCENT FASTER\"\n\nThe above explanation accounts for the screen being turned off during\ntape read and write operations.  The timing of these operations is\nrather critical, and would be affected by even the relatively small\ndelay caused by the video chip.  It also explains why the 64 has\ndifficulty loading programs from an unmodified 1540 Disk Drive, since\nthe 1540 was set up to transfer data from the VIC-20, which does not\nhave to contend with these slight delays.\n\nIf you turn off the 64 display with a POKE 53265,PEEEK(53265) AND 239,\nyou will be able to load programs correctly from an old 1540 drive.\nThe new 1541 drive transfers data at a slightly slower rate in the\ndefault setting, and can be set from software to transfer it at the\nhigher rate for the VIC-20.\n\nBit 5.  Setting Bit 5 of this register to 1 enables the bitmap\ngraphics mode.  In this mode, the screen area is broken down into\n64,000 separate dots of light, 320 dots across by 200 dots high.  Each\ndot corresponds to one bit of display memory.  If the bit is set to 1,\nthe dot will be displayed in the foreground color.  If the bit is\nreset to 0, it will be displayed in the background color.  This allows\nthe display of high-resolution graphics images for games, charts, and\ngraphs, etc.\n\nBitmapping is a common technique for implementing high-resolution\ngraphics on a microcomputer.  There are some features of the Commodore\nsystem which are unusual, however.\n\nMost systems display screen memory sequentially; that is, the first\nbyte controls the display of the first eight dots in the upper-left\ncorner of the screen, the second byte controls the eight dots to the\nright of that, etc.  In the Commodore system, display memory is laid\nout more along the lines of how character graphics dot-data is\narranged.\n\nThe first byte controls the row of eight dots in the top-left corner\nof the screen, but the next byte controls the eight dots below that,\nand so on until the ninth byte.  The ninth byte controls the eight\ndots directly to the right of those controlled by the first byte of\ndisplay memory.  It is exactly the same as if the screen were filled\nwith 1000 programmable characters, with display memory taking the\nplace of the character dot-data.\n\nThe 64's bitmap graphics mode also resembles character graphics in\nthat the foreground color of the dots is set by a color map (although\nit does not use the Color RAM for this purpose).  Four bits of each\nbyte of this color memory control the foreground color of one of these\neight-byte groups of display memory (which form an 8 by 8 grid of 64\ndots).  Unlike character graphics, however, the other four bits\ncontrol the background color that will be seen in the eight-byte\ndisplay group where a bit has a value of 0.\n\nSetting up a bitmap graphics screen is somewhat more complicated than\njust setting this register bit to 1.  You must first choose a location\nfor the display memory area, and for the color memory area.  The\ndisplay memory area will be 8192 bytes long (8000 of which are\nactually used for the display) and can occupy only the first or the\nsecond half of the 16K space which the VIC-II chip can address.\n\nEach byte of bitmap graphics color memory uses four bits for the\nbackground color as well as four bits for the foreground color.\nTherefore, the Color RAM nybbles at 55296 ($D800), which are wired for\nfour bits only, cannot be used.  Another RAM location must therefore\nbe found for color memory.\n\nThis color memory area will take up 1K (1000 bytes of which are\nactually used to control the foreground and background colors of the\ndots), and must be in the opposite half of VIC-II memory as the\ndisplay data.  Since bitmap graphics require so much memory for the\ndisplay, you may want to select a different 16K bank for VIC-II memory\n(see the discussion of things to consider in selecting a VIC-II memory\nbank at location 56576 ($DD00)).\n\nTo keep things simple, however, let's assume that you have selected to\nuse the default bank of VIC-II memory, which is the first 16K.  You\nwould have to select locations 8192-16383 ($2000-$3FFF) for screen\nmemory, because the VIC-II chip sees an image of the character ROM in\nthe first half of the 16K block (at locations 4096-8192\n($1000-$1FFF)).  Color memory could be placed at the default location\nof text display memory, at 1024-2047 ($400-$7FF).  Placement of bitmap\ndisplay and color memory is controlled by the VIC Memory Control\nRegister at 53272 ($D018).\n\nWhen in bitmap mode, the lower four bits of this register, which\nnormally control the base address of character dot-data, now control\nthe location of the 8K bitmap.  Only Bit 3 is significant.  If it is\nset to 1, the graphics display memory will be in the second 8K of\nVIC-II memory (in this case, starting at 8192 ($2000)).  If that bit\ncontains a 0, the first 8K will be used for the bitmap.  The upper\nfour bits of this register, which normally control the location of the\nVideo Display Matrix, are used in bitmap mode to establish the\nlocation of the color map within the VIC-II address space.  These four\nbits can hold a number from 0 to 15, which indicates on which 1K\nboundary the color map begins.  For example, if color memory began at\n1024 (1K), the value of these four bits would be 0001.\n\nOnce the bitmap mode has been selected, and the screen and color\nmemory areas set up, you must establish a method for turning each\nindividual dot on and off.  The conventional method for identifying\neach dot is to assign it to a horizontal (X) position coordinate and a\nvertical (Y) coordinate.\n\nHorizontal position values will range from 0 to 319, where dot 0 is at\nthe extreme left-hand side of the screen, and dot 319 at the extreme\nright.  Vertical positions will range from 0 to 199, where dot 0 is on\nthe top line, and dot 199 is on the bottom line.\n\nBecause of the unusual layout of bitmap screen data on the 64, it is\nfairly easy to transfer text characters to a bitmap screen, but it is\nsomewhat awkward finding the bit which affects the screen dot having a\ngiven X-Y coordinate.  First, you must find the byte BY in which the\nbit resides, and then you must POKE a vlue into that byte which turns\nthe desired bit on or off.  Given that the horizontal position of the\ndot is stored in the variable X, its vertical position is in the\nvariable Y, and the base address of the bitmap area is in the variable\nBASE, you can find the desired byte with the formula:\n\nBY=BASE+40*(Y AND 256)+(Y AND 7)+(X AND 504)\n\nTo turn on the desired dot,\n\nPOKE BY, PEEK(BY) OR (2^(NOTX AND 7)\n\nTo turn the dot off,\n\nPOKE BY, PEEK(BY) AND (255-2^(NOTX AND 7))\n\nThe exponentation function takes a lot of time.  To speed things up,\nan array can be created, each of whose elements corresponds to a power\nof two.\n\nFOR I=0 TO 7:BIT(I)=2^1:NEXT\n\nAfter this is done, the expression 2^(I) can be replaced by BI(I).\n\nThe following sample program illustrates the bit-graphics concepts\nexplained above, and serves as a summary of that information.\n\n10 FOR I=0 TO 7:BI(I)=2^I:NEXT: REM SET UP ARRAY OF POWERS OF 2 (BIT VALUE)\n20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192\n30 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE\n40 A$=\"\":FOR I=1 TO 37:A$=A$+\"C\":NEXT:PRINT CHR$(19);\n50 FOR I=1 TO 27:PRINTA$;:NEXT:POKE2023,PEEK(2022): REM SET COLOR MAP\n60 A$=\"\":FOR I=1 TO 27:A$=A$+\"@\":NEXT:FOR I=32 TO 63 STEP 2\n70 POKE648,I:PRINT CHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLEAR HI-RES SCREEN\n80 FORY=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM\n90 X=INT(160+40*SIN(Y/10)): REM SINE WAVE SHAPE\n100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504): REM FIND HI-RES BYTE\n110 POKEBY,PEEK(BY)OR(BI(NOT X AND 7)):NEXT Y:REM POKE IN BIT VALUE\n120 GOTO 120: REM LET IT STAY ON SCREEN\n\nAs you can see, using BASIC to draw in bit-graphics mode is somewhat\nslow and tedious.  Machine language is much more suiable for\nbit-graphics plotting.  For a program that lets you replace some BASIC\nommands with high-res drawing commands, see the article \"Hi-Res\nGraphics Made Simple,\" by Paul F. Schatz, in COMPUTE!'s First Book of\nCommodore 64 Sound and Graphics.\n\nThere is a slightly lower resolution bitmap graphics mode available\nwhich offers up to four colors per 8 by 8 dot matrix.  To enable this\nmode, you must set the multicolor bit (Bit 4 of 53270 ($D016)) while\nin bitmap graphics mode.  For more information on this mode, see the\nentry for the multicolor enable bit.\n\nBit 6.  This bit of this register enables extended background color\nmode.  This mode lets you select the background color of each text\ncharacter, as well as its foreground color.  It is able to increase\nthe number of background colors displayed, by reducing the number of\ncharacters that can be shown on the screen.\n\nNormally, 256 character shapes can be displayed on the screen.  You\ncan use them either by using the PRINT statement or by POKEing a\ndisplay code from 0 to 255 into screen memory.  If the POKEing method\nis used, you must also POKE a color code from 0 to 15 into color\nmemory (for example, if you POKE 1024,1, and POKE 55296,1, a white A\nappears in the top-left corner of the screen).\n\nThe background color of the screen is determined by Background Color\nRegister 0, and you can change this color by POKEing a new value to\nthat register, which is located at 53281 ($D021).  For example, POKE\n53281,0 creates a black background.\n\nWhen extended background color mode is activated, however, only the\nfirst 64 shapes found in the table of the screen display codes can be\ndisplayed on the screen.  This group includes the letters of the\nalphabet, numerals, and punctuation marks.  If you try to print on the\nscreen a character having a higher display code, the shape displayed\nwill be from the first group of 64, but that character's background\nwill no longer be determined by the register at 53281 ($D021).\nInstead, it will be determined by one of the other background color\nregisters.\n\nWhen in extended background color mode, characters having display\ncodes 64- 127 will take their background color from register 1, and\nlocation 53282 ($D022).  These characters include various SHIFTed\ncharacters.  Those with codes 128-191 will have their background\ncolors determined by register 2, at 53283 ($D023).  These include the\nreversed numbers, letters, and punctuation marks.  Finally, characters\nwith codes 192-255 will use register 4, at 53284 ($D024).  These are\nthe reversed graphics characters.\n\nLet's try an experiment to see just how this works.  First, we will\nput the codes for four different letters in screen memory:\n\nFOR I=0 TO 3:POKE 1230+(I*8),I*64+I:POKE 55502+(I*8),1:NEXT\n\nFour white letters should appear on the screen, an A, a shifted A, a\nreversed A, and a reversed, shifted A, all on a blue background.\nNext, we will put colors in the other background color registers:\n\nPOKE 53282,0:POKE53283,2:POKE53284,5\n\nThis sets the registers to black, red, and green, respectively.\nFinally, we will activate extended color mode by setting Bit 6 of the\nVIC-II register at location 53265 to a 1.  The BASIC statement that\nturns this mode on is:\n\nPOKE 53265,PEEK(53265) OR 64\n\nNotice that two things happened.  First, all of the letters took on\nthe same shape, that of the letter A.  Second, each took on the\nbackground color of a different color register.  To get things back to\nnormal, turn off extended color mode with this statement:\n\nPOKE 53265,PEEK(53265) AND 191\n\nExtended color mode can be a very useful enhancement for your text\ndisplays.  It allows the creation of windows.  These windows, because\nof their different background colors, make different bodies of text\nstand out as visually distinct from one another.  For example, a text\nadventure program could have one window to display the player's\ncurrent location, one to show an inventory of possessions, and one to\naccept commands for the next move.\n\nIn this mode the background color of these windows can be changed\ninstantly, just by POKEing a new value to the color register.  This\ntechnique lends itself to some dramatic effects.  A window can be\nflashed to draw attention to a particular message at certain times.\nAnd varying the foreground color can make either the window or the\nmessage vanish and reappear later.\n\nThere are, however, a couple of problems involved in using these\nwindows.  The character shape that you want to use might not have a\nscreen code of less than 64.  In that case, the only solution is to\ndefine your own character set, with the shape you want in one of the\nfirst 64 characters.\n\nAnother problem is that characters within a PRINT statement in your\nprogram listing are not always going to look the same on the screen.\nHaving to figure out what letter to print to get the number 4 with a\ncertain background color can be very inconvenient.  The easiest\nsolution to this problem is to have a subroutine to the translation\nfor you.  Since letters will appear normally in window 1, and window 3\ncharacters are simply window 1 characters reversed, you will only have\nproblems with characters in windows 2 and 4.  To conver these\ncharacters, put your message in A$, and use the following subroutine:\n\n500 B$=\"\":FOR I=1 TO LEN(A$):B=ASC(MID$(A$,I,1))\n510 B=B+32:IF B<96 THEN B=B+96\n520 B$=B$+CHR$(B):NEXT I:RETURN\n\nThis subroutine converts each letter to its ASCII equivalent, adds the\nproper offset, and converts it back to part of the new string, B$.\nWhen the conversion is complete, B$ will hold the characters necessary\nto PRINT that message in window 2.  For window 4, PRINT\nCHR$(18);B$;CHR$(146).  This will turn reverse video on before\nprinting the string, and turn it off afterwards.\n\nA practical demonstration of the technique for setting up windows is\ngiven in the sample program below.  The program sets up three windows,\nand shows them flashing, appearing and disappearing.\n\n5 DIM RO$(25):RO$(0)=CHR$(19):FOR I=1 TO 24:RO$(I)=RO$(I-1)+CHR$(17):NEXT\n10 POKE 53265,PEEK(53265) OR 64\n20 POKE 53280,0:POKE 53281,0:POKE 53282,1:POKE 53283,2:POKE 53284,13\n25 OP$=CHR$(160):FOR I=1 TO 4:OP$=OP$:NEXTI:PRINTCHR$(147);RO$(3);\n30 FOR I=1 TO10:PRINTTAB(1);CHR$(18);\"               \";TAB(23);OP$:NEXT\n40 PRINT CHR$(146):PRINT:PRINT:FOR I=1 TO 4:PRINTOP$;OP$;OP$;OP$;OP$;:NEXTI\n50 PRINT RO$(5);CHR$(5);CHR$(18);TAB(2);\"A RED WINDOW\"\n60 PRINT CHR$(18);TAB(2);\"COULD BE USED\"\n70 PRINT CHR$(18);TAB(2);\"FOR ERROR\"\n80 PRINT CHR$(18);TAB(2);\"MESSAGES\"\n100 A$=\"A GREEN WINDOW\":GOSUB 300:PRINT RO$(5);CHR$(144);CHR$(18);TAB(24);B$\n110 A$=\"COULD BE USED\":GOSUB 300:PRINTTAB(24);CHR$(18);B$\n120 A$=\"TO GIVE\":GOSUB 300:PRINTTAB(24);CHR$(18);B$\n130 A$=\"INSTRUCTIONS\":GOSUB 300:PRINTTAB(24);CHR$(18);B\n140 PRINT CHR$(31);RO$(19);\n150 A$=\"  WHILE THE MAIN WINDOW COULD BE USED\":GOSUB 300:PRINT B$\n160 A$=\"  FOR ACCEPTING COMMANDS.\":GOSUB 300:PRINT B$\n170 FOR I=1 TO 5000:NEXT I:POKE 53284,0\n180 FOR I=1 TO 5:FOR J=1 TO 300:NEXT J:POKE 53282,15\n190 FOR J=1 TO 300:NEXT J:POKE 53282,1\n200 NEXT I:POKE 53283,-2*(PEEK(53283)=240):POKE 53284,-13*(PEEK(53284)=240)\n210 GOTO 180\n300 B$=\"\":FOR I=1TOLEN(A$):B=ASC(MID$(A$,I,1))\n310 B=B+32:IFB<96THENB=B+96\n320 B$=B$+CHR$(B):NEXTI:RETURN\n\nBit 7.  Bit 7 of this register is the high-order bit (Bit 8) of the\nRaster Compare register at 53266 ($D012).  Even though it is located\nhere, it functions as part of that register (see the description below\nfor more information on the Raster Compare register).\n\nMachine language programmers should note that its position here at Bit\n7 allows testing this bit with the Negative flag.  Since scan lines\nabove number 256 are all off the screen, this provides an easy way to\ndelay changing the graphics display until the scan is in the vertical\nblanking interval and the display is no longer being drawn:\n\nLOOP  LDA $D011\n      BPL LOOP\n\nSprites should always be moved when the raster is scanning off-screen,\nbecause if they are moved while they are being scanned, their shapes\nwill waver slightly.\n\nThe BASIC equivalent of the program fragment above is the statement\nWAIT 53265,128, but BASIC is usually not fast enough to execute the\nnext statement while still in the blanking interval."}, {"id": "map-D012", "address_start": 53266, "address_end": 53266, "hex_start": "$D012", "hex_end": "$D012", "label": "RASTER", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53266          $D012         RASTER\nRead Current Raster Scan Line/Write Line to Compare for Raster IRQ\n\nThe Raster Compare register has two different functions, depending on\nwhether you are reading from it or writing to it.  When this register\nis read, it tells which screen line the electron beam is currently\nscanning.\n\nThere are 262 horizontal lines which make up the American (NTSC)\nstandard display screen (312 lines in the European or PAL standard\nscreen).  Every one of these lines is scanned and updated 60 times per\nsecond.  Only 200 of these lines (numbers 50-249) are part of the\nvisible display.\n\nIt is sometimes helpful to know just what line is being scanned,\nbecause changing screen graphics on a particular line while that line\nis being scanned may cause a slight disruption on the screen.  By\nreading this register, it is possible for a machine language program\nto wait until the scan is off the bottom of the screen before changing\nthe graphics display.\n\nIt is even possible for a machine language program to read this\nregister, and change the screen display when a certain scan line is\nreached.  The program below uses this technique to change the\nbackground color in midscreen, in order to show all 256 combinations\nof foreground and background text colors at once.\n\n40 FOR I=49152 TO 49188:READ A:POKE I,A:NEXT:POKE 53280,11\n50 PRINT CHR$(147):FOR I=1024 TO I+1000:POKE I,160:POKE I+54272,11:NEXT I\n60 FOR I=0 TO 15:FOR J=0 TO 15\n70 P=1196+(48*I)+J:POKE P,J+I:POKE P+54272,J:NEXT J,I\n80 PRINT TAB(15)CHR$(5)\"COLOR CHART\":FOR I=1 TO 19:PRINT:NEXT\n85 PRINT \"THIS CHART SHOWS ALL COMBINATIONS OF   \"\n86 PRINT \"FOREGROUND AND BACKGROUND COLORS.      \"\n87 PRINT \"FOREGROUND INCREASES FROM LEFT TO RIGHT\"\n88 PRINT \"BACKGROUND INCREASES FROM TOP TO BOTTOM\"\n90 SYS 12*4096\n100 DATA 169,90,133,251,169,0,141,33,208,162,15,120,173,17,208,48\n105 DATA 251,173,18,208\n110 DATA 197,251,208,249,238,33,208,24,105,8,133,251,202,16,233,48,219\n\nWriting to this register designates the comparison value for the\nRaster Compare Interrupt.  When that interrupt is enabled, a maskable\ninterrupt request will be issued every time the electron beam scan\nreaches the scan line whose number was written here.  This is a much\nmore flexible technique for changing the display in midscreen than\nreading this register as the sample program above does.  That\ntechnique requires that the program continuously watch the Raster\nRegister, while the interrupt method will call the program when the\ntime is right to act.  For more information on raster interrupts, see\nthe entry for the Interrupt Mask Register (53274, $D01A).\n\nIt is very important to remember that this register requires nine\nbits, and that this location only holds eight of those bits (the ninth\nis Bit 7 of 53265 ($D011)).  If you forget to read or write to the\nninth bit, your results could be in error by a factor of 256.\n\nFor example, some early programs written to demonstrate the raster\ninterrupt took for granted that the ninth bit of this register would\nbe set to 0 on power-up.  When a later version of the Kernal changed\nthis initial value to a 1, their interrupt routines, which were\nsupposed to set the raster interrupt to occur at scan line number 150,\nended up setting it for line number 406 instead.  Since the scan line\nnumbers do not go up that high, no interrupt request was ever issued\nand the program did not work."}, {"id": "map-D013-D014", "address_start": 53267, "address_end": 53268, "hex_start": "$D013", "hex_end": "$D014", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 53267-53268 ($D013-$D014)\nLight Pen Registers\n\nA light pen is an input device that can be plugged into joystick\nControl Port #1.  It is shaped like a pen and has a light-sensitive\ndevice at its tip that causes the trigger switch of the joystick port\nto close at the moment the electron beam that updates the screen\ndisplay strikes it.  The VIC-II chip keeps track of where the beam is\nwhen that happens, and records the corresponding horizontal and\nvertical screen coordinates in the registers at these locations.\n\nA program can read the position at which the light pen is held up to\nthe screen.  The values in these registers are updated once every\nscreen frame (60 times per second).  Once the switch is closed and a\nvalue written to these registers, the registers are latched, and\nsubsequent switch closings during the same screen frame will not be\nrecorded.\n\nA given light pen may not be entirely accurate (and the operator may\nnot have a steady hand).  It is probably wise to average the positions\nreturned from a number of samplings, particularly when using a machine\nlanguage driver."}, {"id": "map-D013", "address_start": 53267, "address_end": 53267, "hex_start": "$D013", "hex_end": "$D013", "label": "LPENX", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53267         $D013          LPENX\nLight Pen Horizontal Position\n\nThis location holds the horizontal position of the light pen.  Since\nthere are only eight bits available (which give a range of 256 values)\nfor 320 possible horizontal screen positions, the value here is\naccurate only to every second dot position.  The number here will\nrange from 0 to 160 and must be multiplied by 2 in order to get a\nclose approximation of the actual horizontal dot position of the light\npen."}, {"id": "map-D014", "address_start": 53268, "address_end": 53268, "hex_start": "$D014", "hex_end": "$D014", "label": "LPENY", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53268         $D014          LPENY\nLight Pen Vertical Position\n\nThis location holds the vertical position of the light pen.  Since\nthere are only 200 visible scan lines on the screen, the value in this\nregister corresponds exactly to the current raster scan line."}, {"id": "map-D015", "address_start": 53269, "address_end": 53269, "hex_start": "$D015", "hex_end": "$D015", "label": "SPENA", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53269         $D015          SPENA\nSprite Enable Register\n\nBit 0:  Enable Sprite 0 (1=sprite is on, 0=sprite is off)\nBit 1:  Enable Sprite 1 (1=sprite is on, 0=sprite is off)\nBit 2:  Enable Sprite 2 (1=sprite is on, 0=sprite is off)\nBit 3:  Enable Sprite 3 (1=sprite is on, 0=sprite is off)\nBit 4:  Enable Sprite 4 (1=sprite is on, 0=sprite is off)\nBit 5:  Enable Sprite 5 (1=sprite is on, 0=sprite is off)\nBit 6:  Enable Sprite 6 (1=sprite is on, 0=sprite is off)\nBit 7:  Enable Sprite 7 (1=sprite is on, 0=sprite is off)\n\nIn order for any sprite to be displayed, the corresponding bit in this\nregister must be set to 1 (the default for this location is 0).  Of\ncourse, just setting this bit along will not guarantee that a sprite\nwill be shown on the screen.  The Sprite Data Pointer must indicate a\ndata area that holds some values other than 0.  The Sprite Color\nRegister must also contain a value other than that of the background\ncolor.  In addition, the Sprite Horizontal and Vertical Position\nRegisters must be set for positions that lie within the visible screen\nrange in order for a sprite to appear on screen."}, {"id": "map-D016", "address_start": 53270, "address_end": 53270, "hex_start": "$D016", "hex_end": "$D016", "label": "SCROLX", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53270         $D016          SCROLX\nHorizontal Fine Scrolling and Control Register\n\nBits 0-2:  Fine scroll display horizontally by X dot positions (0-7)\nBit 3:  Select a 38-column or 40-column text display (1=40 columns,\n  0=38 columns)\nBit 4:  Enable multicolor text or multicolor bitmap mode (1=multicolor on,\n  0=multicolor off)\nBit 5:  Video chip reset (0=normal operations, 1=video completely off)\nBits 6-7:  Unused\n\nThis is one of the two important multifunction control registers on\nthe VIC-II chip.  On power-up, it is set to a default value of 8,\nwhich means that the VIC chip Reset line is set for a normal display,\nMulticolor Mode is disabled, a 40-column text display is selected, and\nno horizontal fine-scroll offset is used.\n\nBits 0-2.  The first three bits of this chip control vertical fine\nscrolling of the screen display.  This feature allows you to smoothly\nmove the entire text display back and forth, enabling the display area\nto act as a window, scrolling over a larger text or character graphics\ndisplay.\n\nSince each text character is eight dots wide, moving each character\nover one whole character position (known as coarse scrolling) is a\nrelatively big jump, and the motion looks jerky.  By placing a number\nfrom 1 to 7 into these three bits, you can move the whole screen\ndisplay from one to seven dot spaces to the right.\n\nStepping through values 1 to 7 allows you to smoothly make the\ntransition from having a character appear at one screen column to\nhaving it appear at the next one over.  To demonstrate this, type in\nthe following program, LIST, and RUN it.\n\n10 FOR I=1 TO 50:FOR J=0 TO 7\n20 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I\n30 FOR I=1 TO 50:FOR J=7 TO 0 STEP-1\n40 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I\n\nAs you can see, after the display has moved over seven dots, it starts\nover at its original position.  In order to continue with the scroll,\nyou must do a coarse scroll every time the value of the scroll bits\ngoes from 7 to 0, or from 0 to 7.  This is accomplished by moving each\nbyte of display data on each line over one position, overwriting the\nlast character, and introducing a new byte of data on the opposite end\nof the screen line to replace it.\n\nObviously, only a machine language program can move all of these bytes\nquickly enough to maintain the effect of smooth motion.  The following\nBASIC program, however, will give you an idea of what the combination\nof fine and coarse scrolling looks like.\n\n10 POKE 53281,0:PRINT CHR$(5);CHR$(147):FOR I=1 TO 5:PRINT CHR$(17):NEXT\n20 FOR I=1 TO 30\n30 PRINT TAB(I-1)\"{UP}{10 SPACES}{UP}\"\n40 WAIT53265,128:POKE53270,PEEK(53270)AND248:PRINTTAB(I)\"AWAY WE GO\"\n50 FOR J=1 TO 7\n60 POKE 53270,(PEEK(53270)AND248)+J\n70 FORK=1TO30-I\n80 NEXT K,J,I:RUN\n\nChanging the value of the three horizontal scroll bits will affect the\nentire screen display.  If you wish to scroll only a portion of the\nscreen, you will have to use raster interrupts (see 53274 ($D01A)\nbelow) to establish a scroll zone, change the value of these scroll\nbits only when that zone is being displayed, and change it back to 0\nafterward.\n\nBit 3.  Bit 3 of this register allows you to cover up the first and\nlast columns of the screen display with the border.  Since the viewers\ncannot see the characters there, they will not be able to see you\ninsert a new character on the end of the line when you do coarse\nscrolling (see explanation of Bits 0-2 above).\n\nSetting this bit to 1 enables the normal 40-column display, while\nresetting it to 0 changes the display to 38 columns.  This is a purely\ncosmetic aid, and it is not necessary to change the screen to the\nsmaller size to use the scrolling feature.\n\nBit 4.  This bit selects multicolor graphics.  The effect of setting\nthis bit to 1 depends on whether or not the bitmap graphics mode is\nalso enabled.\n\nIf you are not in bitmap mode, and you select multicolor text\ncharacter mode by setting this bit to 1, characters with a color\nnybble whose value is less than 8 are displyed normally.  There will\nbe one background color and one foreground color.  But each dot of a\ncharacter with a color nybble whose value is over 7 can have any one\nof four different colors.\n\nThe two colors in the Background Control Registers 1 and 2 (53282-3,\n$D022-3) are available in addition to the colors supplied by the Color\nRAM.  The price of these extra colors is a reduction in horizontal\nresolution.  Instead of each bit controlling one dot, in multicolor\nmode a pair of bits control the color of a larger dot.  A pattern of\n11 will light it with the color from the lower three bits of color\nRAM.  Patterns of 01 and 10 will select the colors from Background\nColor Registers 1 and 2, respectively, for the double-width dot.\n\nYou can see the effect that setting this bit has by typing in the\nfollowing BASIC command line:\n\nPOKE 53270,PEEK(53280)OR16:PRINT CHR$(149)\"THIS IS MULTICOLOR MODE\"\n\nIt is obvious from this example that the normal set of text characters\nwas not made to be used in multicolor mode.  In order to take\nadvantage of this mode, you will need to design custom four-color\ncharacters.  For more information, see the alternate entry for 53248\n($D000), the Character Generator ROM.\n\nIf the multicolor and bitmap enable bits are both set to 1, the result\nis a multicolor bitmap mode.  As in multicolor text mode, pairs of\ngraphics data bits are used to set each dot in a 4 by 8 matrix to one\nof four colors.  This results in a reduction of the horizontal\nresolution to 160 double-wide dots across.  But while text multicolor\nmode allows only one of the four colors to be set individually for\neach 4 by 8 dot area, bitmap multicolor mode allows up to three\ndifferent colors to be individually selected in each 4 by 8 dot area.\nThe source of the dot color for each bit-pair combination is shown\nbelow:\n\n00 Background Color Register 0 (53281, $D021)\n01 Upper four bits of Video Matrix\n10 Lower four bits of Video Matrix\n11 Color RAM nybble (area starts at 55296 ($D800))\n\nThe fact that bit-pairs are used in this mode changes the strategy for\nplotting somewhat.  In order to find the byte BY in which the desired\nbit-pair resides, you must multiply the horizontal position X, which\nhas a value of 0- 159, by 2, and then use the same formula as for\nhi-res bitmap mode.\n\nGiven that the horizontal position (0-159) of the dot is stored in the\nvariable X, its vertical position is in the variable Y, and the base\naddress of the bitmap area ia in the variable BASE, you can find the\ndesired byte with the formula:\n\nBY=BASE+(Y AND 248)*40+(Y AND 7)+(2*X AND 504)\n\nSetting the desired bit-pair will depend on what color you chose.\nFirst, you must set up an array of bit masks.\n\nCA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64\n\nTo turn on the desired dot, select a color CO from 0 to 3\n(representing the color selected by the corresponding bit pattern) and\nexecute the following statement:\n\nBI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR (CO*CA(BI))\n\nThe following program will demonstrate this technique:\n\n10 CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64:REM ARRAY FOR BIT PAIRS\n20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192\n30 POKE53265,PEEK(53265)OR32:POKE53270,PEEK(53270)OR16:REM MULTI-COLOR BIT MAP\n40 A$=\"\":FOR I=1 TO 37:A$=A$+\"C\":NEXT:PRINT CHR$(19);\n50 FOR I=1 TO 27:PRINT A$;:NEXT:POKE 2023,PEEK(2022): REM SET COLOR MAP\n60 A$=\"\":FOR I=1 TO 128:A$=A$+\"@\":NEXT:FOR I=32 TO 63 STEP 2\n70 POKE648,I:PRINTCHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLR HI-RES SCREEN\n80 FOR CO=1TO3:FOR Y=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM\n90 X=INT(10*CO+15*SIN(CO*45+Y/10)): REM SINE WAVE SHAPE\n100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X*2 AND 504): REM FIND HI-RES BYTE\n110 BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR(CO*CA(BI))\n120 NEXT Y,CO\n130 GOTO 130: REM LET IT STAY ON SCREEN\n\nBit 5:  Bit 5 controls the VIC-II chip Reset line.  Setting this bit\nto 1 will completely stop the video chip from operating.  On older\n64s, the screen will go black.  It should always be set to 0 to insure\nnormal operation of the chip.\n\nBits 6 and 7.  These bits are not used."}, {"id": "map-D017", "address_start": 53271, "address_end": 53271, "hex_start": "$D017", "hex_end": "$D017", "label": "YXPAND", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53271         $D017          YXPAND\nSprite Vertical Expansion Register\n\nBit 0:  Expand Sprite 0 vertically (1=double height, 0=normal height)\nBit 1:  Expand Sprite 1 vertically (1=double height, 0=normal height)\nBit 2:  Expand Sprite 2 vertically (1=double height, 0=normal height)\nBit 3:  Expand Sprite 3 vertically (1=double height, 0=normal height)\nBit 4:  Expand Sprite 4 vertically (1=double height, 0=normal height)\nBit 5:  Expand Sprite 5 vertically (1=double height, 0=normal height)\nBit 6:  Expand Sprite 6 vertically (1=double height, 0=normal height)\nBit 7:  Expand Sprite 7 vertically (1=double height, 0=normal height)\n\nThis register can be used to double the height of any sprite.  When\nthe bit in this register that corresponds to a particular sprite is\nset to 1, each dot of the 24 by 21 sprite dot matrix will become two\nraster scan lines high instead of one."}, {"id": "map-D018", "address_start": 53272, "address_end": 53272, "hex_start": "$D018", "hex_end": "$D018", "label": "VMCSB", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53272         $D018          VMCSB\nVIC-II Chip Memory Control Register\n\nBit 0:  Unused\nBits 1-3:  Text character dot-data base address within VIC-II address\n  space\nBits 4-7:  Video matrix base address within VIC-II address space\n\nThis register affects virtually all graphics operations.  It\ndetermines the vase address of two very important data areas, the\nVideo Matrix, and the Character Dot-Data area.\n\nBits 1-3.  These bits are used to set the location of the Character\nDot-Data area.  This area is where the data is stored (for more\ninformation on character shape data, see the alternate entry for\nlocation 53248 ($D000), the Character Generator ROM).\n\nBits 1-3 can represent any even number from 0 to 14.  That numer\nstands for the even 1K offset of the character data area from the\nbeginning of VIC-II memory.  For example, if these bits are all set to\n0, it means that the character memory occupies the first 2K of VIC-II\nmemory.  If they equal 2, the data area starts 2*1K (2*1024) or 2048\nbytes from the beginning of VIC memory.\n\nThe default value of this nybble is 4.  This sets the address of the\nCharacter Dot-Data area to 4096 ($1000), which is the starting address\nof where the VIC-II chip addresses the Character ROM.  The normal\ncharacter set which contains uppercase and graphics occupies the first\n2K of that ROM.  The alternate character set which contains both\nupper- and lowercase letters use the second 2K.  Therefore, to shift\nto the alternate character set, you must change the value of this\nnybble to 6, with a POKE 53272,PEEK(53272)OR2.  To change it back,\nPOKE 53272,PEEK(53272)AND253.\n\nIn bitmap mode, the lower nybble controls the location of the bitmap\nscreen data.  Since this data area can start only at an offset of 0 or\n8K from the beginning of VIC-II memory, only Bit 3 of the Memory\nControl Register is significant in bitmap mode.  If Bit 3 holds a 0,\nthe offset is 0, and if it holds a 1, the offset is 8192 (8K).\n\nBits 4-7.  This nybble determines the starting address of the Video\nMatrix area.  This is the 1024-byte area of memory which contains the\nscreen codes for the text characters that are displayed on the screen.\nIn addition, the last eight bytes of this area are used as pointers\nwhich designate which 64- byte block of VIC-II memory will be used as\nshape data for each sprite.\n\nThese four bits can represent numbers from 0 to 15.  These numbers\nstand for the offset (in 1K increments) from the beginning of VIC-II\nmemory to the Video Matrix.\n\nFor example, the default bit pattern is 0001.  This indicates that the\nVideo Matrix is offset by 1K from the beginning of VIC-II memory, the\nnormal starting place for screen memory.  Remember, though, the bit\nvalue of this number will be 16 times what the bit pattern indicates,\nbecause we are dealing with Bits 4-7.  Therefore, the 0001 in the\nupper nybble has a value of 16.\n\nUsing this register, we can move the start of screen memory to any 1K\nboundary within the 16K VIC-II memory area.  Just changing this\nregister, however, is not enough if you want to use the BASIC line\neditor.  The editor looks to location 648 ($288) to determine where to\nprint screen characters.\n\nIf you just change the location of the Video Matrix without changing\nthe value in 648, BASIC will continue to print characters in the\nmemory area starting at 1024, even though that area is no longer being\ndisplayed.  The result is that you will not be able to see anything\nthat you type in on the keyboard.  To fix this, you must POKE 648 with\nthe page number of the starting address of screen memory (page\nnumber=location/256).  Remember, the actual starting address of screen\nmemory depends not only on the offset from the beginning of VIC-II\nmemory in the register, but also on which bank of 16K is used for\nVIC-II memory.\n\nFor example, if the screen area starts 1024 bytes from the beginning\nof VIC- II memory, and the video chip is using Bank 2 (32768-49151),\nthe actual starting address of screen memory is 32768+1024=33792\n($8400).  For examples of how to change the video memory area, and of\nhow to relocate the screen, see the entro for 56576 ($DD00)."}, {"id": "map-D019", "address_start": 53273, "address_end": 53273, "hex_start": "$D019", "hex_end": "$D019", "label": "VICIRQ", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53273         $D019          VICIRQ\nVIC Interrupt Flag Register\n\nBit 0:  Flag:  Is the Raster Compare a possible source of an IRQ?\n        (1=yes)\nBit 1:  Flag:  Is a collision between a sprite and the normal graphics\n        display a possible source of an IRQ?  (1=yes)\nBit 2:  Flag:  Is a collision between two sprites a possible source of\n        an IRQ?  (1=yes)\nBit 3:  Flag:  Is the light pen trigger a possible source of an IRQ?\n        (1=yes)\nBits 4-6:  Not used\nBit 7:  Flag:  Is there any VIC-II chip IRQ source which could cause\n        an IRQ?  (1=yes)\n\nThe VIC-II chip is capable of generating a maskable request (IRQ) when\ncertain conditions relating to the video display are fulfilled.\nBriefly, the conditions that can cause a VIC-II chip IRQ are:\n\n1.  The line number of the current screen line being scanned by the\nraster is the same as the line number value written to the Raster\nRegister (53266, $D012).\n\n2.  A sprite is positioned at the same location where normal graphics\ndata are being displayed.\n\n3.  Two sprites are positioned so that they are touching.\n\n4.  The light sensor on the light pen has been struck by the raster\nbeam, causing the fire button switch on joystick Control Port #1 to\nclose (pressing the joystick fire button can have the same effect).\n\nWhen one of these conditions is met, the corresponding bit in this\nstatus register is set to 1 and latched.  That means that as long as\nthe corresponding enable bit in the VIC IRQ Mask register is set to 1,\nand IRQ requested will be generated, and any subsequent fulfillment of\nthe same condition will be ignored until the latch is cleared.\n\nThis allows you to preserve multiple interrupt requests if more than\none of the interrupt conditions is met at a time.  In order to keep an\nIRQ source from generating another request after it has been serviced,\nand to enable subsequent interrupt conditions to be detected, the\ninterrupt service routine must write a 1 to the corresponding bit.\nThis will clear the latch for that bit.  The default value written to\nthis register is 15, which clears all interrupts.\n\nThere is only 1 IRQ vector that points to the address of the routine\nthat will be executed when an IRQ interrupt occurs.  The same routine\nwill therefore be executed regardless of the source of the interrupt.\nThis status register provides a method for that routine to check what\nthe source of the IRQ was, so that the routine can take appropriate\naction.  First, the routine can check Bit 7.  Anytime that any of the\nother bits in the status register is set to 1, Bit 7 will also be set.\nTherefore, if that bit holds a 1, you know that the VIC-II chip\nrequested an IRQ (the two CIA chips which are the other sources of IRQ\ninterrupts can be checked in a similar manner).  Once it has been\ndetermined that the VIC chip is responsible for the IRQ, the\nindividual bits can be tested to see which of the IRQ conditions have\nbeen met.\n\nFor more information, and a sample VIC IRQ program, see the following\nentry."}, {"id": "map-D01A", "address_start": 53274, "address_end": 53274, "hex_start": "$D01A", "hex_end": "$D01A", "label": "IRQMASK", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53274         $D01A          IRQMASK\nIRQ Mask Register\n\nBit 0:  Enable Raster Compare IRQ (1=interrupt enabled)\nBit 1:  Enable IRQ to occure when sprite collides with display of\n  normal\n        graphics data (1=interrupt enabled)\nBit 2:  Enable IRQ to occur when two sprites collide (1=interrupt\n  enabled)\nBit 3:  Enable light pen to trigger an IRQ (1=interrupt enabled)\nBits 4-7:  Not used\n\nThis register is used to enable an IRQ request to occur when one of\nthe VIC-II chip interrupt conditions is met.  In order to understand\nwhat that means, and how these interrupts can extend the range of\noptions available to a programmer, you must first understand what an\ninterrupt is.\n\nAn interrupt is a signal given to the microprocessor (the brains of\nthe computer) that tells it to stop executing its machine language\nprogram (for example, BASIC), and to work on another program for a\nshort time, perhaps only a fraction of a second.  After finishing the\ninterrupt program, the computer goes back to executing the main\nprogram, just as if there had never been a detour.\n\nBit 0.  This bit enables the Raster Compare IRQ.  The conditions for\nthis IRQ are met when the raster scan reaches the video line indicated\nby the value written to the Raster Register at 53266 ($D012) and Bit 7\nof 53265 ($D011).  Again, an explanation of the terminology is in\norder.\n\nIn the normal TV display, a beam of electrons (raster) scans the\nscreen, starting in the top-left corner, and moving in a straight line\nto the right, lighting up appropriate parts of the screen line on the\nway.  When it comes to the right edge, the beam moves down a line, and\nstarts again from the left.  There are 262 such line that are scanned\nby the 64 display, 200 of which form the visible screen area.  This\nscan updates the complete screen display 60 times every second.\n\nThe VIC-II chip keeps track of which line is being scanned, and stores\nthe scan number in the Raster Register at 53266 and 53265 ($D012 and\n$D011).  The Raster Register has two functions.  When read, it tells\nwhat line is presently being scanned.  But when written to, it\ndesignates a particular scan line as the place where a raster\ninterrupt will occur.\n\nAt the exact moment that the raster beam line number equals the number\nwritten to the register, Bit 0 of the status register will be set to\n1, showing that the conditions for a Raster Compare Interrupt have\nbeen fulfulled.  If the raster interrupt is enabled then,\nsimultaneously, the interrupt program will be executed.  This allows\nthe user to reset any of the VIC-II registers at any point in the\ndisplay, and thus change character sets, background color, or graphics\nmode for only a part of the screen display.\n\nThe interrupt routine will first check if the desired condition is the\nsource of the interrupt (see above entry) and then make the changes to\nthe screen display.  Once you have written this interrupt routine, you\nmust take the following steps to install it.\n\n1.  Set the interrupt disable flag in the status register with an SEI\ninstruction.  This will disable all interrupts and prevent th system\nfrom crashing while you are changing the interrupt vectors.\n\n2.  Enable the raster interrupt.  This is done by setting Bit 0 of the\nVIC- II chip interrupt enable register at location 53274 ($D01A) to 1.\n\n3.  Indicate the scan line on which you want the interrupt to occur by\nwriting to the raster registers.  Don't forget that this is a nine-bit\nvalue, and you must set both the low byte (in location 53266 ($D012))\nand the high bit (in the register at 53265 ($D011)) in order to insure\nthat the interrupt will start at the scan line you want it to, and not\n256 lines earlier or later.\n\n4.  Let the computer know where the machine language routine that you\nwant the interrupt to execute starts.  This is done by placing the\naddress in the interrupt vector at locations 788-789 ($314-$315).\nThis address is split into two parts, a low byte and a high byte, with\nthe low byte stored at 788.\n\nTo calculate the two values for a given address AD, you may use the\nformula HIBYTE=INT(AD/156) and LOWBYTE=AD-(HIBYTE*256).  The value\nLOWBYTE would go into location 788, and the value HIBYTE would go into\nlocation 789.\n\n5.  Reenable interrupts with a CLI instruction, which clears the\ninterrupt disable flag on the status register.\n\nWhen the computer is first turned on, the interrupt vector is set to\npoint to the normal hardware timer interrupt routine, the one that\nadvances the jiffy clock and reads the keyboard.  Since this interrupt\nroutine uses the same vector as the raster interrupt routine, it is\nbest to turn off the hardware timer interrupt by putting a value of\n127 in location 56333 ($DC0D).\n\nIf you want the keyboard and jiffy clock to function normally while\nyour interrupt is enabled, you must preserve the contents of locations\n788 and 789 before you change them to point to your new routine.  Then\nyou must have your interrupt routine jump to the old interrupt routine\nexactly once per screen refresh (every 1/60 second).\n\nAnother thing that you should keep in mind is that at least two raster\ninterrupts are required if you want to change only a part of the\nscreen.  Not only must the interrupt routine change the display, but\nit must also set up another raster interrput that will change it back.\n\nThe sample program below uses a raster-scan interrupt to divide the\ndisplay into three sections.  The first 80 scan lines are in\nhigh-resolution bitmap mode, the next 40 are regular text, and the\nlast 80 are in multicolor bitmap mode.  The screen will split this way\nas soon as a SYS to the routine that turns on the interrupt occurs.\nThe display will stay split even after the program ends.  Only if you\nhit the STOP and RESTORE keys together will the display return to\nnormal.\n\nThe interrupt uses a table of values that are POKEd into four key\nlocations during each of the three interrupts, as well as values to\ndetermine at what scan lines the interrupt will occur.  The locations\naffected are Control Register 1 (53265, $D011), Control Register 2\n(53270, $D016), the Memory Control Register (53272, $D018), and\nBackground Color 0 (53281, $D021).  The data for the interrupt routine\nis contained in lines 49152-49276.  Each of these line numbers\ncorresponds to the locations where the first data byte in the\nstatement is POKEd into memory.\n\nIf you look at lines 49264-49276 of the BASIC program, you will see\nREMark statements that explain which VIC-II registers are affected by\nthe DATA statements in each line.  The number in these DATA\nstartements appear in the reverse order in which they are put into the\nVIC register.  For example, line 49273 holds the data that will go\ninto Control Register 2.  The last number, 8, is the one that will be\nplaced into Control Register 2 while the top part of the screen is\ndisplayed.  The first number, 24, is placed into Control Register 2\nduring the bottom part of the screen display, and changes that portion\nof the display to multicolor mode.\n\nThe only tricky part in determining which data byte affects which\ninterrupt comes in line 49264, which holds the data that determines\nthe scan line at which each interrupt will occur.  Each DATA statement\nentry reflects the scan line at which the next interrupt will occur.\nThe first item in line 49264 is 49.  Even though this is the entry for\nthe third interrupt, the next to be generates is the first interrupt,\nwhich occurs at the top of the screen.  Likewise, the last data item\nof 129 is used during the first interrupt to start the next interrupt\nat scan line 129.\n\nTry experimenting with these values to see what results you come up\nwith.  For example, if you change the number 170 to 210, you will\nincrease the text area by five lines (40 scan lines).\n\nBy changing the values in the data tables, you can alter the effect of\neach interrupt.  Change the 20 in line 49276 to 22, and you will get\nlowercase text in the middle of the screen.  Change the first 8 in\nline 49273 to 24, and you'll get multicolor text in the center window.\nEach of these table items may be used exactly like you would use the\ncorresponding register, in order to change background color, to obtain\ntext or bitmap graphics, regular or multicolor modes, screen blanking\nor extended background color mode.\n\nIt is even possible to change the table values during a program, by\nPOKEing the new value into the memory location where those table\nvalues are stored.  In that way, you can, for example, change the\nbackground color of any of the screen parts while the program is\nrunning.\n\n5 FOR I=0 TO 7:BI(I)=2^I:NEXT\n10 FOR I=49152 TO 49278:READ A:POKE I,A:NEXT:SYS12*4096\n20 PRINT CHR$(147):FOR I=0 TO 8:PRINT:NEXT\n30 PRINT\"THE TOP AREA IS HIGH-RES BIT MAP MODE\"\n40 PRINT:PRINT\"THE MIDDLE AREA IS ORDINARY TEXT \"\n50 PRINT:PRINT\"THE BOTTOM AREA IS MULTI-COLOR BIT MAP\"\n60 FORG=1384 TO 1423:POKE G,6:NEXT\n70 FORG=1024 TO 1383:POKEG,114:POKE G+640,234:NEXT\n80 A$=\"\":FOR I=1 TO 128:A$=A$+\"@\":NEXT:FOR I=32 TO 63 STEP 2\n90 POKE 648,I:PRINT CHR$(19)CHR$(153);A$;A$;A$;A$:NEXT:POKE 648,4\n100 BASE=2*4096:BK=49267\n110 H=40:C=0:FORX=0TO319:GOSUB150:NEXT\n120 H=160:C=0:FORX=0TO319STEP2:GOSUB150:NEXT:C=40\n125 FORX=1TO319STEP2:GOSUB150:NEXT\n130 C=80:FOR X=0 TO 319 STEP2:W=0:GOSUB150:W=1:GOSUB150:NEXT\n140 GOTO 140\n150 Y=INT(H+20*SIN(X/10+C)):BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504)\n160 POKE BY,PEEK(BY) OR (BI(ABS(7-(XAND7)-W))):RETURN\n49152 DATA 120, 169, 127, 141, 13, 220\n49158 DATA 169, 1, 141, 26, 208, 169\n49164 DATA 3, 133, 251, 173, 112, 192\n49170 DATA 141, 18, 208, 169, 24, 141\n49176 DATA 17, 208, 173, 20, 3, 141\n49182 DATA 110, 192, 173, 21, 3, 141\n49188 DATA 111, 192, 169, 50, 141, 20\n49194 DATA 3, 169, 192, 141, 21, 3\n49200 DATA 88, 96, 173, 25, 208, 141\n49206 DATA 25, 208, 41, 1, 240, 43\n49212 DATA 190, 251, 16, 4, 169, 2\n49218 DATA 133, 251, 166, 251, 189, 115\n49224 DATA 192, 141, 33, 208, 189, 118\n49230 DATA 192, 141, 17, 208, 189, 121\n49236 DATA 192, 141, 22, 208, 189, 124\n49242 DATA 192, 141, 24, 208, 189, 112\n49248 DATA 192, 141, 18, 208, 138, 240\n49254 DATA 6, 104, 168, 104, 170, 104\n49260 DATA 64, 76, 49, 234\n49264 DATA 49, 170, 129 :REM SCAN LINES\n49267 DATA 0, 6, 0:REM BACKGROUND COLOR\n49270 DATA 59, 27,59:REM CONTROL REG. 1\n49273 DATA 24, 8, 8:REM CONTROL REG. 2\n49276 DATA 24, 20, 24:REM MEMORY CONTROLRUN\n\nBesides enabling the creation of mixed graphics-modes screens, the\nRaster Compare Interrupt is also useful for creating scrolling zones,\nso that some parts of the screen can be fine-scrolled while the rest\nremains stationary.\n\nBit 1 enables the light pen interrupt.  This interrupt can occur when\nthe light of the raster beam strikes the light-sensitive device in the\npen's tip, causing it to close the fire button switch on joystick\nController Port #1.\n\nThe light pen interrupt affords a method of signaling to a program\nthat the pen is being held to the screen, and that its position can be\nread.  Some light pens provide a push-button switch which grounds one\nof the other lines on the joystick port.  This switch can be pressed\nby the user as an additional signal that the pen is properly\npositioned.  Its location can then be read in the light pen position\nregisters (53267-8, $D013-4).\n\nBit 2 enables the sprite-foreground collision interrupt.  This\ninterrupt can occur if one of the srpte character's dots is touching\none of the dots from the foreground display of either text character\nor bitmap graphics.\n\nBit 3 enables the sprite-sprite collision interrupt, which can occur\nif one of the sprite character's dots is touching one of the dots of\nanother sprite character.\n\nThese two interrupts are useful for games, where such collisions often\nrequire that some action be taken immediately.  Once the interrupt\nsignals that a collision has occurred, the interrupt routine can check\nthe Sprite- Foreground Collision Register at 53279 ($D01F), or the\nSprite-Sprite Collision Register at 53278 ($D01E), to see which sprite\nor sprites are involved in the collision.  See the entry for those\nlocations for more details on collisions."}, {"id": "map-D01B", "address_start": 53275, "address_end": 53275, "hex_start": "$D01B", "hex_end": "$D01B", "label": "SPBGPR", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53275         $D01B          SPBGPR\nSprite to Foreground Display Priority Register\n\nBit 0:  Select display priority of Sprite 0 to foreground (0=sprite\n        appears in front of foreground)\nBit 1:  Select display priority of Sprite 1 to foreground (0=sprite\n        appears in front of foreground)\nBit 2:  Select display priority of Sprite 2 to foreground (0=sprite\n        appears in front of foreground)\nBit 3:  Select display priority of Sprite 3 to foreground (0=sprite\n        appears in front of foreground)\nBit 4:  Select display priority of Sprite 4 to foreground (0=sprite\n        appears in front of foreground)\nBit 5:  Select display priority of Sprite 5 to foreground (0=sprite\n        appears in front of foreground)\nBit 6:  Select display priority of Sprite 6 to foreground (0=sprite\n        appears in front of foreground)\nBit 7:  Select display priority of Sprite 7 to foreground (0=sprite\n        appears in front of foreground)\n\nIf a sprite is positioned to appear at a spot on the screen that is\nalready occupied by text or bitmap graphics, a conflict arises.  The\ncontents of this register determines which one will be displayed in\nsuch a situation.  If the bit that corresponds to a particular sprite\nis set to 0, the sprite will be displayed in front of the foreground\ngraphics data.  If that bit is set to 1, the foreground data will be\ndisplayed in front of the sprite.  The default value that this\nregister is set to at power-on is 0, so all sprites start out with\npriority over foreground graphics.\n\nNote that for the purpose of priority, the 01 bit-pair of multicolor\ngraphics modes is considered to display a background color, and\ntherefore will be shown behind sprite graphics even if the foreground\ngraphics data takes priority.  Also, between the sprites themselves\nthere is a fixed priority.  Each sprite has priority over all\nhigher-number sprites, so that Sprite 0 is displayed in front of all\nthe others.\n\nThe use of priority can aid in creating three-dimensional effects, by\nallowing some objects on the screen to pass in front of or behind\nother objects."}, {"id": "map-D01C", "address_start": 53276, "address_end": 53276, "hex_start": "$D01C", "hex_end": "$D01C", "label": "SPMC", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53276         $D01C          SPMC\nSprite Multicolor Registers\n\nBit 0:  Select multicolor mode for Sprite 0 (1=multicolor, 0=hi-res)\nBit 1:  Select multicolor mode for Sprite 1 (1=multicolor, 0=hi-res)\nBit 2:  Select multicolor mode for Sprite 2 (1=multicolor, 0=hi-res)\nBit 3:  Select multicolor mode for Sprite 3 (1=multicolor, 0=hi-res)\nBit 4:  Select multicolor mode for Sprite 4 (1=multicolor, 0=hi-res)\nBit 5:  Select multicolor mode for Sprite 5 (1=multicolor, 0=hi-res)\nBit 6:  Select multicolor mode for Sprite 6 (1=multicolor, 0=hi-res)\nBit 7:  Select multicolor mode for Sprite 7 (1=multicolor, 0=hi-res)\n\nSprite multicolor mode is very similar to text and bitmap multicolor\nmodes (see Bit 4 of 53270, $D016).  Normally, the color of each dot of\nthe sprite is controlled by a single bit of sprite shape data.  When\nthi mode is enabled for a sprite, by setting the corresponding bit of\nthis register to 1, the bits of sprite shape data are grouped together\nin pairs, with each pair of bits controlling a double-wide dot of the\nsprite display.  By sacrificing some of the horizontal resolution (the\nsprite, although the same size, is now only 12 dots wide), you gain\nthe use of two additional colors.  The four possible combinations of\nthese bit-pairs display dot colors from the following sources:\n\n00 Background Color Register 0 (transparent)\n01 Sprite Multicolor Register 0 (53285, $D025)\n10 Sprite Color Registers (53287-94, $D027-E)\n11 Sprite Multicolor Register 1 (53286, $D026)\n\nLike multicolor text characters, multicolor sprites all share two\ncolor registers.  While each sprite can display three foreground\ncolors, only one of these colors in unique to that sprite.  The number\nof unique colors may be increated by combining more than one sprite\ninto a single character."}, {"id": "map-D01D", "address_start": 53277, "address_end": 53277, "hex_start": "$D01D", "hex_end": "$D01D", "label": "XXPAND", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53277         $D01D          XXPAND\nSprite Horizontal Expansion Register\n\nBit 0:  Expand Sprite 0 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 1:  Expand Sprite 1 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 2:  Expand Sprite 2 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 3:  Expand Sprite 3 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 4:  Expand Sprite 4 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 5:  Expand Sprite 5 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 6:  Expand Sprite 6 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 7:  Expand Sprite 7 horizontally (1=double-width sprite, 0=normal\n        width)\n\nThis register can be used to double the width of any sprite.  Setting\nany bit of this register to 1 will cause each dot of the corresponding\nsprite shape to be displayed twice as wide as normal, so that without\nchanging its horizontal resolution, the sprite takes up twice as much\nspace.  The horizontal expansion feature can be used alone, or in\ncombination with the vertical expansion register at 53271 ($D017)."}, {"id": "map-D01E-D01F", "address_start": 53278, "address_end": 53279, "hex_start": "$D01E", "hex_end": "$D01F", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 53278-53279 ($D01E-$D01F)\nSprite Collision Detection Registers\n\nWhile Bit 2 of the VIC IRQ Register at 53273 ($D019) is set to 1\nanytime two sprites overlap, and Bit 1 is set to 1, when a sprite\nshape is touching the foreground text or bit-graphics display, these\nregisters specify which sprites were involved in the collision.  Every\nbit that is set to 1 indicates that the corresponding sprite was\ninvolved in the collision.  Reading these registers clears them so\nthat they can detect the next collision.  Therefore, if you plan to\nmake multiple tests on the values stored here, it may be necessary to\ncopy it to a RAM variable for further reference.\n\nNote that while these registers tell you what sprites were involved in\na collision, they do not necessarily tell you what objects have\ncollided with each other.  It is quite possible to have three sprites\nlined up in a row, where Sprite A is on the left, Sprite B is in the\nmiddle, touching Sprite A, and Sprite C is on the right, touching\nSprite B but not touching Sprite A.  The Sprite-Sprite Collision\nregister would show that all three are involved.  The only way to make\nabsolutely certain which collided with which is to check the position\nof each sprite, and calculate for each sprite display line if a sprite\nof that size would touch either of the others.  As you can imagine,\nthis is no easy task.\n\nThere are a few simple rules concerning what does or does not cause a\ncollision.  Though the sprite character consists of 504 dots in a 24\nby 21 matrix, does which represent data bits that are equal to 0 (or\nmulticolor bit- pairs equal to 00), and therefore always displayed in\nthe background color, do not count when it comes to collision.\n\nA collision can occur only if a dot which represents a sprite shape\ndata bit of 1 touches another dot of nonzero graphics data.  Consider\nthe case of two invisible sprites.  The first sprite is enabled, its\ncolor set to contrast the background, and it is positioned on the\nscreen, but its shape data bytes are all 0.  This sprite can never be\ninvolved in a collision, because it displays no nonzero data.  The\nsecond sprite is enabled, positioned on the screen, and its shape\npointer set for a data read that is filled with bytes having a value\nof 255.  Even if that sprite's color is set to the same value as the\nbackground color, making the sprite invisible, it can still be\ninvolved in collisions.  The only exception to this rule is the 01\nbit-pair of multicolor graphics data.  This bit-pair is considered\npart of the background, and the dot it displays can never be involved\nin a collision.\n\nThe other rule to remember about collisions is that they can occur in\nareas that are covered by the screen border.  Collision between\nsprites can occur when the sprites are offscreen, and collisions\nbetween sprites and foreground display data can occur when that data\nis in an area that is covered by the border due to the reduction of\nthe display to 38 columns or 24 rows."}, {"id": "map-D01E", "address_start": 53278, "address_end": 53278, "hex_start": "$D01E", "hex_end": "$D01E", "label": "SPSPCL", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53278         $D01E          SPSPCL\nSprite to Sprite Collision Register\n\nBit 0:  Did Sprite 0 collide with another sprite?  (1=yes)\nBit 1:  Did Sprite 1 collide with another sprite?  (1=yes)\nBit 2:  Did Sprite 2 collide with another sprite?  (1=yes)\nBit 3:  Did Sprite 3 collide with another sprite?  (1=yes)\nBit 4:  Did Sprite 4 collide with another sprite?  (1=yes)\nBit 5:  Did Sprite 5 collide with another sprite?  (1=yes)\nBit 6:  Did Sprite 6 collide with another sprite?  (1=yes)\nBit 7:  Did Sprite 7 collide with another sprite?  (1=yes)"}, {"id": "map-D01F", "address_start": 53279, "address_end": 53279, "hex_start": "$D01F", "hex_end": "$D01F", "label": "SPBGCL", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53279         $D01F          SPBGCL\nSprite to Foreground Collision Register\n\nBit 0:  Did Sprite 0 collide with the foreground display?  (1=yes)\nBit 1:  Did Sprite 1 collide with the foreground display?  (1=yes)\nBit 2:  Did Sprite 2 collide with the foreground display?  (1=yes)\nBit 3:  Did Sprite 3 collide with the foreground display?  (1=yes)\nBit 4:  Did Sprite 4 collide with the foreground display?  (1=yes)\nBit 5:  Did Sprite 5 collide with the foreground display?  (1=yes)\nBit 6:  Did Sprite 6 collide with the foreground display?  (1=yes)\nBit 7:  Did Sprite 7 collide with the foreground display?  (1=yes)"}, {"id": "map-D020-D02E", "address_start": 53280, "address_end": 53294, "hex_start": "$D020", "hex_end": "$D02E", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 53280-53294 ($D020-$D02E)\nVIC-II Color Register\n\nAlthough these color registers are used for various purposes, all of\nthem have one thing in common.  Like the Color RAM Nybbles, only the\nlower four bits are connected.  Therefore, when reading these\nregisters, you must mask out the upper four bits (that is,\nBORDERCOLOR=PEEK(53280)AND15) in order to get a true reading."}, {"id": "map-D020", "address_start": 53280, "address_end": 53280, "hex_start": "$D020", "hex_end": "$D020", "label": "EXTCOL", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53280         $D020          EXTCOL\nBorder Color Register\n\nThe color value here determines the color of the border or frame\naround the central display area.  The entire screen is set to this\ncolor when the blanking feature of Bit 4 of 53265 ($D011) is enabled.\nThe default color value is 14 (light blue)."}, {"id": "map-D021", "address_start": 53281, "address_end": 53281, "hex_start": "$D021", "hex_end": "$D021", "label": "BGCOL0", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53281         $D021          BGCOL0\nBackground Color 0\n\nThis register sets the background color for all text modes, sprite\ngraphics, and multicolor bitmap graphics.  The default color value is\n6 (blue)."}, {"id": "map-D022", "address_start": 53282, "address_end": 53282, "hex_start": "$D022", "hex_end": "$D022", "label": "BGCOL1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53282         $D022          BGCOL1\nBackground Color 1\n\nThis register sets the color for the 01 bit-pair of multicolor\ncharacter graphics, and the background color for characters having\nscreen codes 64-127 in extended background color text mode.  The\ndefault color value is 1 (white)."}, {"id": "map-D023", "address_start": 53283, "address_end": 53283, "hex_start": "$D023", "hex_end": "$D023", "label": "BGCOL2", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53283         $D023          BGCOL2\nBackground Color 2\n\nThis register sets the color for the 10 bit-pair of multicolor\ncharacter graphics, and the background color for characters habing\nscreen codes 128-191 in extended background color text mode.  The\ndefault color value is 2 (red).\n\n53285         $D024          BGCOL3\nBackground Color 3\n\nThis register sets the background color for characters having screen\ncodes between 192 and 255 in extended background color text mode.  The\ndefault color value is 3 (cyan)."}, {"id": "map-D025", "address_start": 53285, "address_end": 53285, "hex_start": "$D025", "hex_end": "$D025", "label": "SPMC0", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53285         $D025          SPMC0\nSprite Multicolor Register 0\n\nThis register sets the color that is displayed by the 01 bit-pair in\nmulticolor sprite graphics.  The default color value is 4 (purple)."}, {"id": "map-D026", "address_start": 53286, "address_end": 53286, "hex_start": "$D026", "hex_end": "$D026", "label": "SPMC1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53286         $D026          SPMC1\nSprite Multicolor Register 1\n\nThis register sets the color that is displayed by the 11 bit-pair in\nmulticolor sprite graphics.  The default color value is 0 (black)."}, {"id": "map-D027-D02E", "address_start": 53287, "address_end": 53294, "hex_start": "$D027", "hex_end": "$D02E", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 53287-53294 ($D027-$D02E)\nSprite Color Registers\n\nThese registers are used to set the color to be displayed by bits of\nhi-res sprite data having a value of 1, and by bit-pairs of multicolor\nsprite data having a value of 10.  The color of each sprite is\ndetermined by its own individual color register."}, {"id": "map-D027", "address_start": 53287, "address_end": 53287, "hex_start": "$D027", "hex_end": "$D027", "label": "SP0COL", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53287         $D027          SP0COL\nSprite 0 Color Register (the default color value is 1, white)"}, {"id": "map-D028", "address_start": 53288, "address_end": 53288, "hex_start": "$D028", "hex_end": "$D028", "label": "SP1COL", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53288         $D028          SP1COL\nSprite 1 Color Register (the default color value is 2, red)"}, {"id": "map-D029", "address_start": 53289, "address_end": 53289, "hex_start": "$D029", "hex_end": "$D029", "label": "SP2COL", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53289         $D029          SP2COL\nSprite 2 Color Register (the default color value is 3, cyan)\n\n53290         $D01A          SP3COL\nSprite 3 Color Register (the default color value is 4, purple)\n\n53291         $D01B          SP4COL\nSprite 4 Color Register (the default color value is 5, green)\n\n53292         $D01C          SP5COL\nSprite 5 Color Register (the default color value is 6, blue)\n\n53293         $D01D          SP6COL\nSprite 6 Color Register (the default color value is 7, yellow)\n\n53294         $D01E          SP7COL\nSprite 7 Color Register (the default color value is 12, medium gray)"}, {"id": "map-D02F-D03F", "address_start": 53295, "address_end": 53311, "hex_start": "$D02F", "hex_end": "$D03F", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 53295-53311 ($D02F-$D03F)\nNot Connected\n\nThe VIC-II chip has only 47 registers for 64 bytes of possible address\nspace.  Therefore, the remaining 17 addresses do not access any\nmemory.  When read, they will always give a value of 255 ($FF).  This\nvalue will not change after writing to them."}, {"id": "map-D040-D3FF", "address_start": 53312, "address_end": 54271, "hex_start": "$D040", "hex_end": "$D3FF", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 53312-54271 ($D040-$D3FF)\nVIC-II Register Images\n\nSince the VIC-II requires only enough addressing lines to handle 64\nlocations (the minimum possible for its 47 registers), none of the\nhigher bits are decoded when addressing this 1K area.  The result is\nthat every 64 byte area in this 1K block is a mirror of every other.\nPOKE53281+64,1 has the same effect as POKE53281,1 or\nPOKE53281+10*64,1; they all turn the screen background to white.  For\nthe sake of clarity in your programs it is advisable to use the base\naddress of the chip."}, {"id": "map-D400-D41C", "address_start": 54272, "address_end": 54300, "hex_start": "$D400", "hex_end": "$D41C", "label": "", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54272-54300   $D400-$D41C\nSound Interface Device (SID) Registers\n\nMmeory locations 54272-54300 ($D400-$D41C) are used to address the\n6581 Sound Interface Device (SID).\n\nSID is a custom music synthesizer and sound effects generator chip\nthat gives the 64 its impressive musical capabilities.  It provides\nthree separate music channels, or voices, as they are called.  Each\nvoice has 16-bit frequency resolution, waveform control, envelope\nshaping, oscillator synchronization, and ring modulation.  In\naddition, programmable high-pass, low-pass, and band-pass filters can\nbe set and enabled or disabled for each sound channel.\n\nSince quite a few of these locations must be used in concert to\nproduce sound, a brief summary of the interplay between some of these\nregisters may be helpful.\n\nOften the first step is to select an overall volume level using the\nVolume Register.  Then, the desired frequency or pitch of the note is\nchosen by writing to each of the two bytes which make up the 16-bit\nFrequency Register.\n\nAn ADSR envelope setting must be chosen by writing values to the\nAttack/ Decay and Sustain/Release Register.  These determine the rate\nof the rise and fall of the volume of the note from zero volume to\npeak volume and back again.  These rates have a great influence on the\ncharacter of the sound.\n\nFinally, the waveform must be selected, and the note started (or the\noscillator gated, as we say).  This is done by writing certain bits to\nthe Control Register.  The waveform control lets you select one of\nfour different waveforms, each of which has varying harmonic content\nthat affects the tone quality of the sound.  By writing a 1 to the\ngate bit, you start the Attack/ Delay/Sustain cycle.  Afer rising to a\npeak and declining to the Sustain volume, the volume will continue at\nthe same level until you write a 0 to the gate bit.  Then, the Release\ncycle will start.  Make sure that you keep the same waveform bit set\nto 1 while you write the 0 to the gate bit, so that the Release cycle\nstarts.  Otherwise, the sound will stop entirely, as it also will if\nthe Volume Register or the Frequency Register is set to 0.\n\nIt should be noted that except for the last four SID chip registers,\nthese addresses are write-only.  That means that their values cannot\nbe determined by PEEKing these locations."}, {"id": "map-D400-D401", "address_start": 54272, "address_end": 54273, "hex_start": "$D400", "hex_end": "$D401", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 54272-54273 ($D400-$D401)\nVoice 1 Frequency Control\n\nTogether, these two locations control the frequency or pitch of the\nmusical output of voice 1.  Some frequency must be selected in order\nfor voice 1 to be heard.  This frequency may be changed in the middle\nof a note to achieve special effects.  The 16-bit range of the\nFrequency Control Register covers over eight full octaves, and allows\nyou to vary the pitch from 0 (very low) to about 4000 Hz (very high),\nin 65536 steps.  The exact frequency of the output can be determined\nby the equation\n\nFREQUENCY=(REGISTER VALUE*CLOCK/16777216)Hz\n\nwhere CLOCK equals the system clock frequency, 1022730 for American\n(NTSC) systems, 985250 for European (PAL), and REGISTER VALUE is the\ncombined value of these frequency registers.  That combined value\nequals the value of the low byte plus 256 times the value of the high\nbyte.  Using the American (NTSC) clock value, the equation works out\nto\n\nFREQUENCY=REGISTER VALUE*.060959458 Hz"}, {"id": "map-D400", "address_start": 54272, "address_end": 54272, "hex_start": "$D400", "hex_end": "$D400", "label": "FRELO1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54272         $D400          FRELO1\nVoice 1 Frequency Control (low byte)"}, {"id": "map-D401", "address_start": 54273, "address_end": 54273, "hex_start": "$D401", "hex_end": "$D401", "label": "FREHI1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54273         $D401          FREHI1\nVoice 1 Frequency Control (high byte)"}, {"id": "map-D402-D403", "address_start": 54274, "address_end": 54275, "hex_start": "$D402", "hex_end": "$D403", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 54274-54275 ($D402-$D403)\nVoice 1 Pulse Waveform Width Control\n\nAs you will see below under the description of the Control Register at\n54276 ($D404), you can select one of four different waveforms for the\noutput of each voice.  If the pulse waveform is selected, these\nregisters must be set to establish the pulse width.\n\nThe pulse width has a 12-bit resolution, being made up of the value in\nthe first register and the value in the lower nybble of the second\nregister.  The pulse width determines the duty cycle, or proportion of\nthe time that the rectangular wave will stay at the high part of the\ncycle.\n\nThe following formula shows the relationship between the value in the\nPulse Width Register and the proportion of time that the wave stays at\nthe high part of the cycle:\n\nPULSE WIDTH=(REGISTER VALUE/40.95)%\n\nThe possible range of the register values (0-4095) covers the range of\nthe duty cycles from 0 to 100 percent in 4096 steps.  Changing the\npulse width will vastly change the sound created with the pulse\nwaveform."}, {"id": "map-D402", "address_start": 54274, "address_end": 54274, "hex_start": "$D402", "hex_end": "$D402", "label": "PWLO1", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "54274         $D402          PWLO1\nVoice 1 Pulse Waveform Width (low byte)"}]