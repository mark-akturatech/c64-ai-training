[{"id": "map-A9", "address_start": 169, "address_end": 169, "hex_start": "$A9", "hex_end": "$A9", "label": "RINONE", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "169           $A9            RINONE\nRS-232 Flag: Check for Start Bit\n\nThis flag is used when checking for a start bit.  A 144 ($90) here\nindicates that no start bit was received, while a 0 means that a start\nbit was received."}, {"id": "map-AA", "address_start": 170, "address_end": 170, "hex_start": "$AA", "hex_end": "$AA", "label": "RIDATA", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "170           $AA            RIDATA\nRS-232 Input Byte Buffer/Cassette Temporary Storage\n\nSerial routines use this area to reassemble the bits received into a\nbyte that will be stored in the receiving buffer pointer to by 247\n($F7).  Tape routines use this as a flag to help determine whether a\nreceived character should be treated as data or as a synchronization\ncharacter."}, {"id": "map-AB", "address_start": 171, "address_end": 171, "hex_start": "$AB", "hex_end": "$AB", "label": "RIPRTY", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "171           $AB            RIPRTY\nRS-232 Input Parity/Cassete Leader Counter\n\nThis location is used to help detect if data was lost during RS-232\ntransmission, or if a tape leader is completed."}, {"id": "map-AC-AD", "address_start": 172, "address_end": 173, "hex_start": "$AC", "hex_end": "$AD", "label": "SAL", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "172-173       $AC-$AD        SAL\nPointer to the Starting Address of a Load/Screen Scrolling\n\nThe pointer to the start of the RAM area to be SAVEd or LOADed at 193\n($C1) is copied here.  This pointer is used as a working version, to\nbe increased as the data is received or transmitted.  At the end of\nthe operation, the initial value is restored here.  Screen management\nroutines temporarily use this as a work pointer."}, {"id": "map-AE-AF", "address_start": 174, "address_end": 175, "hex_start": "$AE", "hex_end": "$AF", "label": "EAL", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "174-175       $AE-$AF        EAL\nPointer to Ending Address of Load (End of Program)\n\nThis location is set by the Kernal routine SAVE to point to the ending\naddress for SAVE, LOAD, or VERIFY."}, {"id": "map-B0-B1", "address_start": 176, "address_end": 177, "hex_start": "$B0", "hex_end": "$B1", "label": "CMP0", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "176-177       $B0-$B1        CMP0\nTape Timing\n\nLocation 176 ($B0) is used to determine the value of the adjustable\ntiming constant at 146 ($92).  Location 199 is also used in the timing\nof tape reads."}, {"id": "map-B2-B3", "address_start": 178, "address_end": 179, "hex_start": "$B2", "hex_end": "$B3", "label": "TAPE1", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "178-179       $B2-$B3        TAPE1\nPointer: Start of Tape Buffer\n\nOn power-on, this pointer is set to the address of the cassette buffer\n(828, $33C).  This pointer must contain an address greater than or\nequal to 512 ($200), or an ILLEGAL DEVICE NUMBER error will be sent\nwhen tape I/O is tried."}, {"id": "map-B4", "address_start": 180, "address_end": 180, "hex_start": "$B4", "hex_end": "$B4", "label": "BITTS", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "180           $B4            BITTS\nRS-232 Output Bit Count/Cassette Temporary Storage\n\nRS-232 routines use this to count the number of bits transmitted, and\nfor parity and stop bit manipulation.  Tape load routines use this\nlocation to flag when they are ready to receive data bytes."}, {"id": "map-B5", "address_start": 181, "address_end": 181, "hex_start": "$B5", "hex_end": "$B5", "label": "NXTBIT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "181           $B5            NXTBIT\nRS-232 Next Bit to Send/Tape EOT Flag\n\nThis location is used by the RS-232 routines to hold the next bit to\nbe sent, and by the tape routines to indicate what part of a block the\nread routine is currently reading."}, {"id": "map-B6", "address_start": 182, "address_end": 182, "hex_start": "$B6", "hex_end": "$B6", "label": "RODATA", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "182           $B6            RODATA\nRS-232 Output Byte Buffer\n\nRS-232 routines use this area to disassemble each byte to be sent from\nthe transmission buffer pointed to by 249 ($F9)."}, {"id": "map-B7", "address_start": 183, "address_end": 183, "hex_start": "$B7", "hex_end": "$B7", "label": "FNLEN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "183           $B7            FNLEN\nLength of Current Filename\n\nThis location holds the number of characters in the current filename.\nDisk filenames may have from 1 to 16 characters, while tape filenames\nrange from 0 to 187 characters in length.\n\nIf the tape name is longer than 16 characters, the excess will be\ntruncated by the SEARCHING and FOUND messages, but will still be\npresent on the tape.  This means that machine language programs meant\nto run in the cassette buffer may be saved as tape filenames.\n\nA disk file is always referred to be a name, whether full or generic\n(containing the wildcard characters * or ?).  This location will\nalways be greater than 0 if the current file is a disk file.  Tape\nLOAD, SAVE, and VERIFY operations do not require that a name be\nspecified, and this location can therefore contain a 0.  If this is\nthe case, the contents of the pointer to the filename at 187 will be\nirrelevant.\n\nAn RS-232 OPEN command may specify a filename of up to four\ncharacters.  These characters are copied to locations 659-662\n($293-$296), and determine baud rate, word length, and parity."}, {"id": "map-B8", "address_start": 184, "address_end": 184, "hex_start": "$B8", "hex_end": "$B8", "label": "LA", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "184           $B8            LA\nCurrent Logical File Number\n\nThis location holds the logical file number of the device currently\nbeing used.  A maximum of five disk files, and ten files in total, may\nbe open at any one time.\n\nFile numbers range from 1 to 255 (a 0 is used to indicate system\ndefaults).  When printing to a device with a file number greater than\n127, an ASCII linefeed character will be sent following each carriage\nreturn, which is useful for devices like serial printers that require\nlinefeeds in addition to carriage returns.\n\nThe BASIC OPEN command calls the Kernal OPEN routine, which sets the\nvalue of this location.  In the BASIC statement OPEN 4,8,15, the\nlogical file number corresponds to the first parameter 4."}, {"id": "map-B9", "address_start": 185, "address_end": 185, "hex_start": "$B9", "hex_end": "$B9", "label": "SA", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "185           $B9            SA\nCurrent Secondary Address\n\nThis location holds the secondary address of the device currently\nbeing used.  The range of valid secondary address numbers is 0 through\n31 for serial devices, and 0 through 127 for other devices.\n\nSecondary device numbers mean something different to each device that\nthey are used with.  The keyboard and screen devices ignore the\nsecondary address completely.  But any device which can have more than\none file open at the same time, such as the disk drive, distinguishes\nbetween these files by using the secondary address when opening a disk\nfile.  Secondary address numbers 0, 1, and 15-31 have a special\nsignificance to the disk drive, and therefore device numbers 2-14 only\nshould be used as secondary addresses when opening a disk file.\n\nOPENing a disk file with a secondary address of 15 enables the user to\ncommunicate with the Disk Operating System through that channel.  A\nLOAD command which specifies a secondary address of 0 (for example,\nLOAD \"AT BASIC\",8,0) results in the program being loaded not to the\naddress specified on the file as the starting address, but rather to\nthe address pointed to by the start of BASIC pointer (43, $2B).\n\nA LOAD with a secondary address of 1 (for example, LOAD \"HERE\",8,1)\nresults in the contents of the file being loaded to the address\nspecified in the file.  A disk file that has been LOADed using a\nsecondary address of 1 can be successfully SAVEd in the same manner\n(SAVE \"DOS 5.1\",8,1).\n\nLOADs and SAVEs that do not specify a secondary address will default\nto a secondary address of 0.\n\nWhen OPENing a Datasette recorder file, a secondary address of 0\nsignifies that the file will be read, while a secondary address of 1\nsignifies that the file will be written to.  A value of 2 can be added\nto indicate that an End of Tape marker should be written as well.\nThis marker tells the Datasette not to search past it for any more\nfiles on the tape, though more files can be written to the tape if\ndesired.\n\nAs with the disk drive, the LOAD and SAVE commands use secondary\naddresses of 0 and 1 respectively to indicate whether the operation\nshould be relocating or nonrelocating.\n\nWhen the 1515 or 1525 Printer is opened with a secondary address of 7,\nthe uppercase/lowercase character set is used.  If it is openend with\na secondary address of 0, or without a secondary address, the\nuppercase/graphics character set will be used."}, {"id": "map-BA", "address_start": 186, "address_end": 186, "hex_start": "$BA", "hex_end": "$BA", "label": "FA", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "186           $BA            FA\nCurrent Device Number\n\nThis location holds the number of the device that is currently being\nused.  Device number assignments are as follows:\n\n0    = Keyboard\n1    = Datasette Recorder\n2    = RS-232/User Port\n3    = Screen\n4-5  = Printer\n8-11 = Disk"}, {"id": "map-BB-BC", "address_start": 187, "address_end": 188, "hex_start": "$BB", "hex_end": "$BC", "label": "FNADR", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "187-188       $BB-$BC        FNADR\nPointer: Current Filename\n\nThis location holds a pointer to the address of the current filename.\nIf an operation which OPENs a tape file does not specify a filename,\nthis pointer is not used.\n\nWhen a disk filename contains a shifted space character, the remainder\nof the name will appear outside the quotes in the directory, and may\nbe used for comments.  For example, if you SAVE \"ML[shifted\nspace]SYS828\", the directory entry will read \"ML\"SYS 828.  You may\nreference the program either by the portion of the name that appears\nwithin quotes, or by the full name, including the shifted space.  A\nprogram appearing later in the directory as \"ML\"SYS 900 would not be\nfound just by reference to \"ML\", however.\n\nA filename of up to four characters may be used when opening the\nRS-232 device.  These four characters will be copied to 659-662\n($293-$296), where they are used to control such parameters as baud\nrate, parity, and word length."}, {"id": "map-BD", "address_start": 189, "address_end": 189, "hex_start": "$BD", "hex_end": "$BD", "label": "ROPRTY", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "189           $BD            ROPRTY\nRS-232 Output Parity/Cassette Temporary Storage\n\nThis location is used by the RS-232 routines as an output parity work\nbyte, and by the tape as temporary storage for the current character\nbeing read or sent."}, {"id": "map-BE", "address_start": 190, "address_end": 190, "hex_start": "$BE", "hex_end": "$BE", "label": "FSBLK", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "190           $BE            FSBLK\nCassette Read/Write Block Count\n\nUsed by the tape routines to count the number of copies of a data\nblock remaining to be read or written."}, {"id": "map-BF", "address_start": 191, "address_end": 191, "hex_start": "$BF", "hex_end": "$BF", "label": "MYCH", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "191           $BF            MYCH\nTape Input Byte Buffer\n\nThis is used by the tape routines as a work area in which incoming\ncharacters area assembled."}, {"id": "map-C0", "address_start": 192, "address_end": 192, "hex_start": "$C0", "hex_end": "$C0", "label": "CAS1", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "192           $C0            CAS1\nTape Motor Interlock\n\nThis location is maintained by the IRQ interrupt routine that scans\nthe keyboard.  Whenever a button is pressed on the recorder, this\nlocation is checked.  If it contains a 0, the motor is turned on by\nsetting Bit 5 of location 1 to 0.  When the button is let up, the tape\nmotor is turned off, and this location is set to 0.\n\nSince the interrupt routine is executed 60 times per second, you will\nnot be able to keep the motor bit set to keep the motor on if no\nbuttons are pushed.  Likewise, if you try to turn the motor off when a\nbutton is pressed and this location is set to 0, the interrupt routine\nwill turn it back on.\n\nTo control the motor via software, you must set this location to a\nnonzero value after one of the buttons on the recorder has been\npressed."}, {"id": "map-C1-C2", "address_start": 193, "address_end": 194, "hex_start": "$C1", "hex_end": "$C2", "label": "STAL", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "193-194       $C1-$C2        STAL\nI/O Start Address\n\nThis location points to the beginning address of the area in RAM which\nis currently being LOADed or SAVEd.  For tape I/O, it will point to\nthe cassette buffer, and the rest of the data is LOADed or SAVEd\ndirectly to or from RAM.  This location points to the beginning\naddress of the area of RAM to be used for the blocks of data that come\nafter the initial header."}, {"id": "map-C5", "address_start": 197, "address_end": 197, "hex_start": "$C5", "hex_end": "$C5", "label": "LSTX", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "197           $C5            LSTX\nMatrix Coordinate of Last Key Pressed, 64=None Pressed\n\nDuring every normal IRQ interrput this location is set with the value\nof the last keypress, to be used in keyboard debouncing.  The\nOperating System can check if the current keypress is the same as the\nlast one, and will not repeat the character if it is.\n\nThe value returned here is based on the keyboard matrix values as set\nforth in the explanation of location 56320 ($DC00).  The values\nreturned for each key pressed are shown at the entry for location 203\n($CB)."}, {"id": "map-C6", "address_start": 198, "address_end": 198, "hex_start": "$C6", "hex_end": "$C6", "label": "NDX", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "198           $C6            NDX\nNumber of Characters in Keyboard Buffer (Queue)\n\nThe value here indicates the number of charracters waiting in the\nkeyboard buffer at 631 ($277).  The maximum number of characters in\nthe keyboard buffer at any one time is determined by the value in\nlocation 649 ($289), which defaults to 10.\n\nIf INPUT or GET is executed while there are already characters in the\nbuffer, those characters will be read as part of the data stream.  You\ncan prevent this by POKEing a 0 to this location before those\noperations, which will always cause any character in the buffer to be\nignored.  This technique can be handy when using the joystick in\nController Port #1, which sometimes causes fake keypresses to be\nregistered, placing unwanted characters in the keyboard buffer.\n\nNot only is this location handy for taking unwanted characters out of\nthe keyboard buffer, but it can also be used to put desired characters\ninto the buffer, and thus to program the keyboard buffer.  This\ntechnique (dynamic keyboard) allows you to simulate keyboard input in\ndirect mode from a program.\n\nThe dynamic keyboard technique is an extremely useful one, as it\nenables you to add, delete, or modify program lines while the program\nis running.  The basic scheme is to POKE the PETASCII character values\nthat you wish to be printed (including cursor control characters and\ncarriage returns) into the buffer.  Then, when an END statement is\nexecuted, the characters in the buffer will be printed, and entered by\nthe carriage return.\n\nThis technique can help with the problem of trying to use data\nseparation and terminator characters with INPUT statements.  If you\ntry to INPUT a string that has a comma or colon, the INPUT will read\nonly up to that character and issue an EXTRA IGNORED error message.\nYou can avoid this by entering the input string in quotes, but this\nplaces on the user the burder of remembering the quote marks.  One\nsolution is to use the statements:\n\nPOKE 198,3:POKE 631,34: POKE 632,34: POKE 633,20\n\nbefore the input.  This will force two quote marks and a delete into\nthe buffer.  The first quote mark allows the comma or colon to be\nINPUT, the second is used to get the editor out of quote mode, and the\ndelete removes that second quote.\n\nFor more specific information and programming examples, see the\ndescription of location 631 ($277), the keyboard buffer."}, {"id": "map-C7", "address_start": 199, "address_end": 199, "hex_start": "$C7", "hex_end": "$C7", "label": "RVS", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "199           $C7            RVS\nFlag: Print Reverse Characters? 0=No\n\nWhen the [CTRL][RVS-ON] characters are printer (CHR$(18)), this flag\nis set to 18 ($12), and the print routines will add 128 ($80) to the\nscreen code of each character which is printed, so that the caracter\nwill appear on the screen with its colors reversed.\n\nPOKEing this location directly with a nonzero number will achieve the\nsame results.  You should remember, however, that the contents of this\nlocation are returned to 0 not only upon entry of a [CTRL][RVS-OFF]\ncharacter (CHR$(146)), but also at every carriage return.  When this\nhappens, characters printed thereafter appear with the normal\ncomination of colors."}, {"id": "map-C8", "address_start": 200, "address_end": 200, "hex_start": "$C8", "hex_end": "$C8", "label": "INDX", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "200           $C8            INDX\nPointer: End of Logical Line for Input\n\nThis pointer indicates the column number of the last nonblank\ncharacter on the logical line that is to be input.  Since a logical\nline can be up to 80 characters long, this number can range from 0-79."}, {"id": "map-C9-CA", "address_start": 201, "address_end": 202, "hex_start": "$C9", "hex_end": "$CA", "label": "LXSP", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "201-202       $C9-$CA        LXSP\nCursor X,Y Position at Start of Input\n\nThese locations keep track of the logical line that the cursor is on,\nand its column position on that logical line (in line, column format).\n\nEach logical line may contain one or two 40-column physical lines.\nThus there may be as many as 25 logical lines, or as few as 13 at any\none time.  Therefore, the logical line number might be anywhere from\n1-25.  Depending on the length of the logical line, the cursor column\nmay be from 1-40 or 1-80.\n\nFor a more detailed exaplanation of logical lines, see the description\nof the screen line link talbe, 217 ($D9)."}, {"id": "map-CB", "address_start": 203, "address_end": 203, "hex_start": "$CB", "hex_end": "$CB", "label": "SFDX", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "203           $CB            SFDX\nMatrix Coordinate of Current Key Pressed\n\nThe keyscan interrupt routine uses this location to indicate which key\nis currently being pressed.  The value here is then used as an index\ninto the appropriate keyboard table to determine which character to\nprint when a key is struck.\n\nThe correspondence between the key pressed and the number stored here\nis as follows:\n\n0  = INST/DEL                34 = J\n1  = RETURN                  35 = 0\n2  = CRSR RIGHT              36 = M\n3  = F7                      37 = K\n4  = F1                      38 = O\n5  = F3                      39 = N\n6  = F5                      40 = +\n7  = CRSR DOWN               41 = P\n8  = 3                       42 = L\n9  = W                       43 = -\n10 = A                       44 = .\n11 = 4                       45 = :\n12 = Z                       46 = @\n13 = S                       47 = ,\n14 = E                       48 = LIRA (BRITISH POUND SIGN)\n15 = NOT USED                49 = *\n  (WOULD BE LEFT SHIFT)      50 = ;\n16 = 5                       51 = CLR/HOME\n17 = R                       52 = NOT USED\n18 = D                         (WOULD BE RIGHT SHIFT)\n19 = 6                       53 = =\n20 = C                       54 = UP ARROW\n21 = F                         (EXPONENTATION SIGN)\n22 = T                       55 = /\n23 = X                       56 = 1\n24 = 7                       57 = LEFT ARROW\n25 = Y                       58 = NOT USED\n26 = G                         (WOULD BE CTRL)\n27 = 8                       59 = 2\n28 = B                       60 = SPACE BAR\n29 = H                       61 = NOT USED\n30 = U                         (WOULD BE COMMODORE LOGO)\n31 = V                       62 = Q\n32 = 9                       63 = RUN/STOP\n33 = I                       64 = NO KEY PRESSED\n\nThe RESTORE key is not accounted for, because it is not part of the\nnormal keyboard matrix.  Instead, it is connected directly to the\nmicroprocessor NMI line, and causes an NMI interrupt whenever it is\npressed."}, {"id": "map-CC", "address_start": 204, "address_end": 204, "hex_start": "$CC", "hex_end": "$CC", "label": "BLNSW", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "204           $CC            BLNSW\nCursor Blink Enable: 0=Flash Cursor\n\nWhen this flag is set to a nonzero value, it indicates to the routine\nthat normally flashes the cursor not to do so.  The cursor blink is\nturned off when there are characters in the keyboard buffer, or when\nthe program is running.\n\nYou can use this location to turn the cursor on during a program (for\na series of GET operations, for example, to show the user that input\nis expected) by using the statement POKE 204,0."}, {"id": "map-CD", "address_start": 205, "address_end": 205, "hex_start": "$CD", "hex_end": "$CD", "label": "BLNCT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "205           $CD            BLNCT\nTimer: Countdown to Blink Cursor\n\nThe interrupt routine that blinks the cursor uses this location to\ntell when it's time for a blink.  First the number 20 is put here, and\nevery jiffy (1/60 second) the value here is decreased by one, until it\nreaches zero.  Then the cursor is blinked, the number 20 is put back\nhere, and the cycle starts all over again.  Thus, under normal\ncircumstances, the cursor blinks three times per second."}, {"id": "map-CE", "address_start": 206, "address_end": 206, "hex_start": "$CE", "hex_end": "$CE", "label": "GDBLN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "206           $CE            GDBLN\nCharacter Under Cursor\n\nThe cursor is formed by printing the inverse of the character that\noccupies the cursor position.  If that characters is the letter A, for\nexample, the flashing cursor merely alternates between printing an A\nand a reverse-A.  This location keeps track of the normal screen code\nof the character that is located at the cursor position, so that it\nmay be restored when the cursor moves on."}, {"id": "map-CF", "address_start": 207, "address_end": 207, "hex_start": "$CF", "hex_end": "$CF", "label": "BLNON", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "207           $CF            BLNON\nFlag: Was Last Curson Blink on or off?\n\nThis location keeps track of whether, during the current cursor blink,\nthe character under the cursor was reversed, or was restored to\nnormal.  This location will contain a 0 if the character is reversed,\nand a 1 if the character is restored to its nonreversed status."}, {"id": "map-D0", "address_start": 208, "address_end": 208, "hex_start": "$D0", "hex_end": "$D0", "label": "CRSW", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "208           $D0            CRSW\nFlag: Input from Keyboard or Screen\n\nThis flag is used by the Kernal CHRIN (61783, $F157) routine to\nindicate whether input is available from the screen (3), or whether a\nnew line should be obtained from the keyboard (0)."}, {"id": "map-D1-D2", "address_start": 209, "address_end": 210, "hex_start": "$D1", "hex_end": "$D2", "label": "PNT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "209-210       $D1-$D2        PNT\nPointer to the Address of the Current Screen Line\n\nThis location points to the address in screen RAM of the first column\nof the logical line upon which the cursor is currently positioned."}, {"id": "map-D3", "address_start": 211, "address_end": 211, "hex_start": "$D3", "hex_end": "$D3", "label": "PNTR", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "211           $D3            PNTR\nCursor Column on Current Line\n\nThe number contained here is the cursor column position within the\nlogical line pointed to by 209 ($D1).  Since a logical line can\ncontain up to two physical lines, this value may be from 0 to 79 (the\nnumber here is the value returned by the POS function)."}, {"id": "map-D4", "address_start": 212, "address_end": 212, "hex_start": "$D4", "hex_end": "$D4", "label": "QTSW", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "212           $D4            QTSW\nFlag: Editor in Quote Mode? 0=No\n\nA nonzero value in this location indicates that the editor is in quote\nmode.  Quote mode is toggled every time that you type in a quotation\nmark on a given line--the first quote mark turns it on, the second\nturns it off, the third turns it back on, etc.\n\nIf the editor is in this mode when a cursor control character or other\nnonprinting character is entered, a printed equivalent will appear on\nthe screen instead of the cursor movement or other control operation\ntaking place.  Instead, that action is deferred until the string is\nsent to the string by a PRINT statement, at which time the cursor\nmovement or other control operation will take place.\n\nThe exception to this rule is the DELETE key, which will function\nnormally within quote mode.  The only way to print a character which\nis equivalent to the DELETE key is by entering insert mode (see\nloctaion 216 ($D8)).  Quote mode may be exited by printing a closing\nquote, or by hitting the RETURN or SHIFT-RETURN keys.\n\nSometimes, it would be handy to be able to escape from quote mode or\ninsert mode without skipping to a new line.  The machine language\nprogram below hooks into the keyscan interrupt routine, and allows you\nto escape quote mode by changing this flag to 0 when you press the f1\nkey:\n\n10 FOR I=850 TO I+41:READ A:POKE I,A:NEXT\n20 PRINTCHR$(147)\"PRESS F1 KEY TO ESCAPE QUOTE MODE\"\n30 PRINT\"TO RESTART AFTER RESTORE ONLY, SYS 850\":SYS850:NEW\n40 DATA  173 , 143 , 2 , 141 , 46 , 3 , 173 , 144 , 2 , 141\n50 DATA 47 , 3 , 120 , 169 , 107 , 141 , 143 , 2 , 169 , 3\n60 DATA 141 , 144 , 2 , 88 , 96 , 165 , 203 , 201 , 4 , 208\n70 DATA 8 , 169 , 0 , 133 , 212 , 133 , 216 , 133 , 199 , 108 , 46 , 3"}, {"id": "map-D5", "address_start": 213, "address_end": 213, "hex_start": "$D5", "hex_end": "$D5", "label": "LNMX", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "213           $D5            LNMX\nMaximum Length of Physical Screen Line\n\nThe line editor uses this location when the end of a line has been\nreached to determine whether another physical line can be added to the\ncurrent logical line, or if a new logical line must be started."}, {"id": "map-D6", "address_start": 214, "address_end": 214, "hex_start": "$D6", "hex_end": "$D6", "label": "TBLX", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "214           $D6            TBLX\nCurrent Cursor Physical Line Number\n\nThis location contains the current physical screen line position of\nthe cursor (0-24).  It can be used in a fashion to move the cursor\nvertically, by POKEing the target screen line (1-25) minus 1 here,\nfollowed by a PRINT command.  For example,\n\nPOKE 214,9:PRINT:PRINT \"WE'RE ON LINE ELEVEN\"\n\nprints the message on line 11.  The first PRINT statement allows the\nsystem to update the other screen editor variables so that they will\nalso show the new line.  The cursor can also be set or read using the\nKernal PLOT routine (58634, $E50A) as explained in the entry from\nlocations 780-783 ($30C-$30F)."}, {"id": "map-D7", "address_start": 215, "address_end": 215, "hex_start": "$D7", "hex_end": "$D7", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "215           $D7\nTemporary Storage Area for ASCII Value of Last Character Printed\n\nThe ASCII value of the last character printed to the screen is held\nhere temporarily."}, {"id": "map-D8", "address_start": 216, "address_end": 216, "hex_start": "$D8", "hex_end": "$D8", "label": "INSRT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "216           $D8            INSRT\nFlag: Insert Mode (Any Number Greater Than 0 Is the Number of Inserts)\n\nWhen the INST key is pressed, the screen editor shifts the line to the\nright, allocates another physical line to the logical line if\nnecessary (and possible), updates the screen line length in 213 ($D5),\nand adjusts the screen line link table at 217 ($D9).  This location is\nused to keep track of the number of spaces that has been opened up in\nthis way.\n\nUntil the spaces that have been opened up are filled, the editor acts\nas if in quote mode (see location 212 ($D4), the quote mode flag).\nThis means that cursor control characters that are normally\nnonprinting will leave a printed equivalent on the screen when\nentered, instead of having their normal effect on cursor movement,\netc.  The only difference between insert and quote mode is that the\nDELETE key will leave a printed equivalent in insert mode, while the\nINST key will insert spaces as normal."}, {"id": "map-D9-F2", "address_start": 217, "address_end": 242, "hex_start": "$D9", "hex_end": "$F2", "label": "LDTB1", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "217-242       $D9-$F2        LDTB1\nScreen Line Link Table/Editor Temporary Storage\n\nThis table contains 25 entries, one for each row of the screen\ndisplay.  Each entry has two functions.  Bits 0-3 indicate on which of\nthe four pages of screen memory  the first byte of memory for that row\nis located.  This is used in calculating the pointer to the starting\naddress of a screen line at 209 ($D1).\n\nWhile earlier PETs used one table for the low bytes of screen rows and\nanother for the high bytes, this is not possible on the 64, where\nscreen memory is not fixed in any one spot.  Therefore, the Operating\nSystem uses a table of low bytes at 60656 ($ECF0), but calculates the\nhigh byte by adding the value of the starting page of screen memory\nheld in 648 ($288) to the displacement page held here.\n\nThe other function of this table is to establish the makeup of logical\nlines on the screen.  While each screen line is only 40 characters\nlong, BASIC allows the entry of program lines that contain up to 80\ncharacters.  Therefore, some method must be used to determine which\npairs of physical lines are linked into a longer logical line, so that\nthis longer logical line may be edited as a unit.\n\nThe high bit of each byte here is used as a flag by the screen editor.\nThat bit is set (leaving the value of the byte over 128 ($80)) when a\nline is the first or only physical line in a logical line.  The high\nbit is reset to 0 only when a line is the second half of a logical\nline."}, {"id": "map-F3-F4", "address_start": 243, "address_end": 244, "hex_start": "$F3", "hex_end": "$F4", "label": "USER", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "243-244       $F3-$F4        USER\nPointer to the Address of the Current Screen Color RAM Location\n\nThis poitner is synchronized with the pointer to the address of the\nfirst byte of screen RAM for the current line kept in location 209\n($D1).  It holds the address of the first byte of color RAM for the\ncorresponding screen line."}, {"id": "map-F5-F6", "address_start": 245, "address_end": 246, "hex_start": "$F5", "hex_end": "$F6", "label": "KEYTAB", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "245-246       $F5-$F6        KEYTAB\nVector: Keyboard Decode Table\n\nKEYTAB points to the address of the keyboard matrix lookup table\ncurrently being used.  Although there are only 64 keys on the keyboard\nmatrix, each key can be used to print up to four different characters,\ndepending on whether it is struck by itself or in combination with the\nSHIFT, CTRL, or Commodore logo keys.\n\nThe tables pointed to y this address hold the ASCII value of each of\nthe 64 keys for one of these possible combinations of keypresses.\nWhen it comes time to print the character, the table that is used\ndetermines which character is printed.\n\nThe addresses of the four tables are:\n\n60289 ($EB81) = default uppercase/graphics characters (unshifted)\n60354 ($EBC2) = shifted characters\n60419 ($EC03) = Commodore logo key characters\n60536 ($EC78) = CTRL characters\n\nThe concept of the keyboard matrix tables should not be confused with\nchanging the character sets from uppercase/graphics to\nupper/lowercase.  The former involves determining what character is to\nbe placed into screen memory, while the latter involves determining\nwhich character data table is to be used to decode the screen memory\ninto individual dots for the display of characters on the screen.\nThat character base is determined by location 53272 ($D018) of the\nVIC-II chip."}, {"id": "map-F7-F8", "address_start": 247, "address_end": 248, "hex_start": "$F7", "hex_end": "$F8", "label": "RIBUF", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "247-248       $F7-$F8        RIBUF\nPointer: RS-232 Input Buffer\n\nWhen device number 2 (the RS-232 channel) is opened, two buffers of\n256 bytes each are created at the top of memory.  This location points\nto the address of the one which is used to store characters as they\nare received.  A BASIC program should always OPEN device 2 before\nassigning any variables to avoid the consequences of overwriting\nvariables which were previously located at the top of memory, as BASIC\nexecutes a CLR after opening this device."}, {"id": "map-F9-FA", "address_start": 249, "address_end": 250, "hex_start": "$F9", "hex_end": "$FA", "label": "ROBUF", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "249-250       $F9-$FA        ROBUF\nPointer: RS-232 Output Buffer\n\nThis location points to the address of the 256-byte output buffer\nwhich is used for transmitting data to RS-232 devices (device number\n2)l"}, {"id": "map-FB-FE", "address_start": 251, "address_end": 254, "hex_start": "$FB", "hex_end": "$FE", "label": "FREEZP", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "251-254       $FB-$FE        FREEZP\nFour Free Bytes of Zero Page for User Programs\n\nThese locations were specifically set aside for user-written ML\nroutines that require zero-page addressing.  While other zero-page\nlocations can be used on a noninterference basis, it is guaranteed\nthat BASIC will not alter these locations."}, {"id": "map-FF", "address_start": 255, "address_end": 255, "hex_start": "$FF", "hex_end": "$FF", "label": "BASZPT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "255           $FF            BASZPT\nBASIC Temporary Data for Floating Point to ASCII Conversion\n\nThis location is used for temporary storage in the process of\nconverting floating point numbers to ASCII characters..\n\n\n:::::::::::::\n::         ::\n:: Page 1  ::\n:::::::::::::"}, {"id": "map-100-1FF", "address_start": 256, "address_end": 511, "hex_start": "$100", "hex_end": "$1FF", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 2::", "type": "location", "text": "256-511       $100-$1FF\nMicroprocessor Stack Area\n\nLocations 256-511 are reserved for the 6510 microprocessor hardware\nstack.  The organization of this temporary storage area has often been\ncompared to that of a push-down stack of trays at a cafeteria.  The\nfirst number placed on the stack goes to the bottom, and subsequent\nentries are placed on top of it.  Then you pull a number off the\nstack, you come up with the last number that was pushed on (such a\nstack is called a Last In, First Out, or LIFO stack).\n\nThe stack is controlled by one of the microprocessor registers called\nthe Stack Pointer, which keeps track of the last stack location used.\nThe first number placed on the stack goes to location 511 ($1FF), and\nsubsequent entries are built downward toward 256 ($100).  If more than\n256 numbers are pushed onto the stack, the Stack Pointer will start\ncounting from 0 again, and an overflow error will result.  Likewise,\nif you try to pull more items off the stack than have been pushed on,\nan underflow error will result.  Most often, such errors will cause\nthe system to go haywire, and nothing will operate until you turn the\npower off and on again.\n\nThe stack is used by the system to keep track of the return addresses\nof machine language subroutines and interrupt calls and to save the\ncontents of internal registers.  The stack can also be used by the\nprogrammer for temporary storage.  BASIC and the Kernal make heavy use\nof the stack.\n\nMicrosoft BASIC uses part of the stack for a temporary work area.\nTherefore, the stack may be broken down into the following subregions:"}, {"id": "map-100-10A", "address_start": 256, "address_end": 266, "hex_start": "$100", "hex_end": "$10A", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 2::", "type": "location", "text": "256-266       $100-$10A\nWork Area for Floating Point to String Conversions\n\nUsed in the conversion of numbers to the equivalent ASCII digits, and\nin scanning strings."}, {"id": "map-100-13E", "address_start": 256, "address_end": 318, "hex_start": "$100", "hex_end": "$13E", "label": "BAD", "source": "mapping-c64.txt", "chapter": "::Chapter 2::", "type": "location", "text": "256-318       $100-$13E      BAD\nTape Input Error Log\n\nEach tape block is saved twice consecutively, in order to minimize\nloss of data from transmission errors.  These 62 bytes serve as\nindices of which bytes in the tape block were not received corectly\nduring the first transmission, so that corrections might be made on\nthe second pass."}, {"id": "map-13F-1FF", "address_start": 319, "address_end": 511, "hex_start": "$13F", "hex_end": "$1FF", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 2::", "type": "location", "text": "319-511       $13F-$1FF\n\nThis area is exclusively for the microprocessor stack.  Some BASIC\ncommands, such as FOR-NEXT loops require many stack entries at a time.\nTherefore, BASIC frequently checks the stack before pushing entries\non, and returns an OUT OF MEMORY error if an operation would result in\nless than 62 bytes of available stack memory.\n\nEach FOR statement causes 18 bytes to be pushed onto the stack, which\ncome off in the following order:\n\nFirst comes a one-byte constant of 129 ($81).  Next is a two-byte\npointer to the address of the subject variable (the X of FOR X=1 to\n10).  This is followed by the five-byte floating point representation\nof the TO value.  Finally comes the two-byte line number of the line\nto which the program returns after a NEXT, and the two-byte address of\nthe next character to read in that line after the FOR statement.\n\nEach GOSUB call places five bytes on the stack.  The first byte to\ncome off is a one-byte constant of 141 ($8D).  The next two bytes\ncontain the line number of the statement to which the program will\nRETURN after the subroutine ends.  And the final two bytes are a\npointer to the address of the BASIC program text for that statement in\nwhich the program RETURNs.\n\nDEF also leaves a five-byte entry on the stack.  It is the same as\nthat described for GOSUB, except that instead of a constant byte of\n141, the first number is a dummy byte, whose value has no\nsignificance.\n\n\n::::::::::::::::::::::::\n::                    ::\n::   Pages 2 and 3    ::\n::                    ::\n::BASIC and the Kernal::\n::  Working Storage   ::\n::::::::::::::::::::::::\n\nThis area is used to store important information for the Operating\nSystem and BASIC.  It contains vectors to certain BASIC routines as\nwell as Operating System Kernal routines.  Registers for RS-232 serial\nI/O are located here.  Buffer space is allocated in this area for tape\nI/O, BASIC text input, and the keyboard queue.  In addition, there are\na number of Operating System variables and pointers here which the\nprogrammer can utilize."}, {"id": "map-200-258", "address_start": 512, "address_end": 600, "hex_start": "$200", "hex_end": "$258", "label": "BUF", "source": "mapping-c64.txt", "chapter": "::     Chapter 3      ::", "type": "location", "text": "512-600       $200-$258      BUF\nBASIC Line Editor Input Buffer\n\nWhen you are in the BASIC immediate mode, and type in a line of\ncharacters, those characters are stored here.  BASIC then scans the\nstring of characters, converts the text to tokenized BASIC program\nformat, and either stores it or executes the line, depending on\nwhether or not it started with a line number.\n\nThis same area is also used to store data which is received via the\nINPUT and GET commands.  This explains why these commands are illegal\nin immediate mode--they must use the same buffer space that is\nrequired by the immediate mode statement itself.\n\nIt is interesting to note that this buffer is 89 bytes long.  The\nscreen editor will allow a maximum of only 80 characters in a program\nline, with one extra byte required for a 0 character, marking the end\nof the line.  This presumable is a carry over from the VIC, which\nallows a line length of up to 88 characters.  The last eight bytes of\nthis buffer are therefore normally not used, and can be considered\nfree space for the programmer to use as he or she sees fit."}]