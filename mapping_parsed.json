[
  {
    "id": "map-0-8F",
    "address_start": 0,
    "address_end": 143,
    "hex_start": "$0",
    "hex_end": "$8F",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location_range",
    "text": "Location Range: 0-143 ($0-$8F)\nBASIC Working Storage\n\nThis portion of zero page is used by BASIC only.  Therefore, a program\nwritten entirely in machine language that does not interact with BASIC\ncan freely use this area."
  },
  {
    "id": "map-0",
    "address_start": 0,
    "address_end": 0,
    "hex_start": "$0",
    "hex_end": "$0",
    "label": "D6510",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "0             $0             D6510\n6510 On-Chip I/O DATA Direction Register\n\nBit 0: Direction of Bit 0 I/O on port at next address.  Default = 1 (output)\nBit 1: Direction of Bit 1 I/O on port at next address.  Default = 1 (output)\nBit 2: Direction of Bit 2 I/O on port at next address.  Default = 1 (output)\nBit 3: Direction of Bit 3 I/O on port at next address.  Default = 1 (output)\nBit 4: Direction of Bit 4 I/O on port at next address.  Default = 0 (input)\nBit 5: Direction of Bit 5 I/O on port at next address.  Default = 1 (output)\nBit 6: Direction of Bit 6 I/O on port at next address.  Not used.\nBit 7: Direction of Bit 7 I/O on port at next address.  Not used.\n\nThis location is the first of a number of hardware registers that we\nwill discuss.  Although they can be written to and/or read like RAM,\nthey are connected to hardware devices, and their contents affect the\noperation of the devices.\n\nEach bit of this Data Direction Register determines whether the\ncontents of the corresponding bit on the Internal I/O Port (see\nlocation 1) can be written to by peripheral devices.  If the bit is\nset to 0, it indicates the direction of data flow as Input, which\nmeans that the corresponding bit of the I/O port will be affected by\nperipheral defices.  If the bit is set to 1, it indicates Output.  On\nthe 64, only Bits 0-5 are significant.  On power-up, this register is\nset to 239 ($EF), which indicates that all bits, except for Bit 4\n(which senses the cassette switch), are set up for Output."
  },
  {
    "id": "map-1",
    "address_start": 1,
    "address_end": 1,
    "hex_start": "$1",
    "hex_end": "$1",
    "label": "R6510",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "1             $1             R6510\n\nBit 0: LORAM signal.  Selects ROM or RAM at 40960 ($A000).  1=BASIC, 0=RAM\nBit 1: HIRAM signal.  Selects ROM or RAM at 57344 ($E000).  1=Kernal, 0=RAM\nBit 2: CHAREN signal.  Selects character ROM or I/O devices.  1=I/O, 0=ROM\nBit 3: Cassette Data Output line.\nBit 4: Cassette Switch Sense.  Reads 0 if a button is pressed, 1 if not.\nBit 5: Cassette Motor Switch Control.  A 1 turns the motor on, 0 turns it off.\nBits 6-7: Not connected--no function presently defined.\n\nThe chief function of this register is to determine which blocks of\nRAM and ROM the 6510 microprocessor will address.  The Commodore 64\ncomes with 64K RAM, even though it normally does not use all of that\nRAM at once.  In addition, it has an 8K BASIC Interpreter ROM, an 8K\nOperating System Kernal ROM, a 4K Character Generator ROM, a Sound\nInterface Device (SID), a 6566 Video Interface Controller (VIC-II),\nand two 6526 Complex Interface adapter chips.\n\nTo address all of these at once would require 88K, 24K past the\naddressing limit of the 6510 microprocessor.  In order to allocate\naddress space, the I/O Port is used to affect the addressing lines,\nand thus determine which segments of RAM and ROM will be addressed at\nany one time.\n\nBit 0.  This bit controls the LORAM signal.  A 0 in this bit position\nswitches the BASIC ROM out, and replaces it with RAM at addresses\n40960-49151 ($A000-$BFFF).  The default value of this bit is 1.\n\nBit 1.  Bit 1 controls the HIRAM signal.  A 0 in this bit position\nswitches the Kernal ROM out, and replaces it with RAM at 57344-65535\n($E000-$FFFF).  As the BASIC interpreter uses the Kernal, it is also\nswitched out and replaced by RAM.  The default value of this bit is 1.\n\nThe system allows a wide range of combinations of RAM and ROM to be\nutilized.  Of course, the BASIC programmer will have little need, in\nthe ordinary course of events, to switch out the BASIC ROM and the\nKernal.  To do so would just hang the system up.  But one way to make\nuse of this feature is to move the contents of ROM to the\ncorresponding RAM addresses.  That way, you can easily modify and\ncustomize the BASIC interpreter and OS Kernal routines, which are\nordinarily fixed in ROM.  For examples, to move BASIC into RAM, just\ntype:\n\nFOR I=40960 TO 49151:POKE I,PEEK(I):NEXT\n\nThough it appears that such a program would not do anything, it in\nfact copies bytes from ROM to RAM.  This is because any data which is\nwritten to a ROM location is stored in the RAM which resides at the\nsame address.  So while you are PEEKing ROM, you are POKEing RAM.  To\nswitch to your RAM copy of BASIC, type in:\n\nPOKE 1,PEEK(1) AND 254.\n\nNow you are ready to make modifications.  Examples of simple\nmodifications include changing the text which the interpreter prints,\nsuch as the READY prompt, the power-up message, or the keyword table.\n\nAn example of the latter would be POKE 41122,69.  This changes the FOR\nkeyword to FER, so that BASIC would respond normally to a FER-NEXT\nloop, but fail to recognize FOR as syntactically correct.\n\nOn the more practical side, you could change the prompt that INPUT\nissues to a colon, rather than a question mark:\n\nPOKE 43846,58\n\nYou are not limited to just cosmetic changes of text.  Jim Butterfield\nhas given an example in COMPUTE! magazine of changing the interpreter\nso that it assigns a null string the ASCII value 0.  In the ROM\nversion, the command PRINT ASC(\"\") will return ?ILLEGAL QUANTITY\nERROR.  This is inconvenient when INPUTting a string, because if the\nuser presses RETURN and you try to check the ASCII value of the string\nthat has been entered, you will get this error.  By entering POKE\n46991,5, this is changed so that PRINT ASC(\"\") now responds with a\nzero.\n\nFor the more serious machine language programmer, it is quite feasible\nto add new commands or modify existing ones by diverting the vectors\nwhich are discussed in the section covering the BASIC interpreter ROM.\nFor a good example of this technique, see the article \"Hi-Res Graphics\nMade Simple\" by Paul Schatz in COMPUTE!'s First Book of Commodore 64\nSound and Graphics.  The program example there inserts new graphics\ncommands into a RAM version of BASIC.  When you want to switch back to\nthe ROM BASIC, enter POKE 1,PEEK(1) OR 1.\n\nFor machine language applications, it would be possible to replace the\nROM programs with an entirely different operating system, or an\napplication that has its own screen editing and I/O functions\nincluded.  Such an application would first have to be loaded from disk\ninto RAM.  A language other than BASIC could be loaded, and could then\njust switch out the BASIC ROM, while still using the OS Kernal.\n\nOr a spreadsheet application that contained its own I/O routines could\nswitch out all ROMs and have the use of all of RAM that is not\nactually needed for the program itself, for data.  It should be\nremembered, however, that before switching the Kernal out, it is\nnecessary to disable interrupts, as the vectors for these interrupts\nare contained in the Kernal.\n\nBit 2.  This bit controls the CHAREN signal.  A 0 in this position\nswitches the character generator ROM in, so that it can be read by the\n6510 at addresses 53248-57343 ($D000-$DFFF).  Normally, this bit is\nset to 1, so that while the VIC-II chip has access to the character\ngenerator ROM for purposes of creating the screen display, the user\ncannot PEEK into it.  Since this ROM is switched into the system in\nthe same location as the I/O devices (SID chip, VIC-II chip, and 6526\nCIA's), o I/O can occur when this ROM is switched in.\n\nThe ability to switch in the character generator ROM is very useful to\nthe programmer who wishes to expirement with user-defined characters.\nModified character graphics is one of the  more powerful graphics\ntools available, but often the user will not want to redefine a whole\ncharacter set at one time.  By reading the character ROM and\nduplicating its contents in RAM, the user can replace only a few\ncharacters in the set.  The method for reading this ROM into RAM from\nBASIC is as follows:\n\n10 POKE 56333,127:POKE1,PEEK(1) AND 251:FOR I=0 TO 2048\n20 POKE BASE+I,PEEK(53248+I):NEXT:POKE 1,PEEK(1) OR 4:POKE 56333,129\n\nThe first POKE is necessary to turn off the system timer interrupt.\nSince the I/O devices are addressed in the same space as the character\nROM, switching that ROM in switches all I/O out, making it necessary\nto turn off any interrupts which use these devices.\n\nThe second POKE is the one which switches in the character ROM.  The\nprogram loop then reads this ROM memory into RAM, starting with the\naddress BASE.  Note that this address should start on an even 2K\nboundary (an address evenly divisible by 2048) within the block of\nmemory presently being addresses by the VIC-II chip (for more\ninformation on where to put user-defined character sets, and how to\nuse them, see the section on the VIC-II chip, under location 53272\n($D018), the section on the character ROM at 49152 ($C000), and the\nsection on banking VIC-II memory at 56576 ($DD00)).  After reading the\ncontents of ROM into RAM, the next POKEs switch out the character ROM\nand restore the interrupt.\n\nIt should be noted that while Bits 0-2 of this register allow software\ncontrol of some signals that determine the memory configuration that\nis used by the Commodore 64 at any given time, they are not the only\ndetermining factor.  Signals can also be generated by means of plug-in\nexpansion cartridges which are connected to the expansion port, and\nthese can change the memory map.\n\nTwo lines located on the exapansion port are called GAME and EXROM.\nWhen used in conjunction with the software-controlled lines noted\nabove, these two hardware lines can enable cartridge ROM to replace\nvarious segments of ROM and/or RAM.\n\nPossible configurations include 8K of cartridge ROM to be switched in\nat $8000-$9FFF, for a BASIC enhancement program; an 8K cartridge ROM\nat $A000-$BFFF, replacing BASIC, or at $E000-$FFFF, replacing the\nKernal, or a 16k cartridge at $8000-$C000.\n\nWhen cartridge ROM is selected to replace the Kernal, a Max emulator\nmode is entered, which mimics the specification of the ill-fated Max\nMachine, a game machine which Commodore never produced for sale int he\nU.S.  In this mode, only the first 6K of RAM are used, there is no\naccess to the character ROM, and graphics data such as charactger\ndot-data is mapped down from 57344 ($E000) to 8192 ($2000).  Further\nhardware information may be obtained from the Commodore 64\nProgrammer's Reference Guide.\n\nBits 3-5 of this register have functions connected with the Datasette\nrecorder.  These are as follows:\n\nBit 3.  This is the Cassette Data Output line.  This line is connected\nto the Cassette Data Write line on the cassette port, and is used to\nsend the data which is written to tape.\n\nBit 4.  This bit is the Cassette Switch Sense line.  This bit enables\na program to tell whether or not one of the buttons that moves the\nrecorder is pressed down.  If the switch on the recorder is down, this\nbit will have a value of 1.  Remember that Bit 4 of the data direction\nregister at location 0 must contain a 0 for this bit to properly\nreflect the status of the switch.\n\nBit 5.  Bit 5 is the Cassette Motor Control.  Setting this bit to zero\nallows the motor to turn when you press one of the buttons on the\nrecorder, while setting it to one disables it from turning.\n\nMost of the time, the setting of this bit will be controlled by the\ninterrupt routine that is used to read the keyboard every sixtieth of\na second.  If none of the buttons on the recorder is pressed, that\ninterrupt routine shuts the motor off and sets the interlock at\nlocation 192 ($C0) to zero.  When a button is pressed, if the\ninterlock location is zero, Bit 5 of this register is set to zero to\nturn the motor on.\n\nWhen the interlock location contains a zero, the keyscan routine will\nnot let you control the setting of this bit of the register (and the\ninterlock is always set to zero when no buttons are pressed).  In\norder for you to gain control of the motor, you must POKE a nonzero\nvalue into 192 after a button on the recorder has been pressed.  You\ncan then shut off the motor and turn it back on as you please, by\nmanipulating this bit, so long as a button stays pressed."
  },
  {
    "id": "map-3-4",
    "address_start": 3,
    "address_end": 4,
    "hex_start": "$3",
    "hex_end": "$4",
    "label": "ADRAY1",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "3-4           $3-$4          ADRAY1\nVector: Routine to Convert a Number from Floating Point to Signed\nInteger\n\nThis vector points to the address of the BASIC routine which converts\na floating point number to an integer.  In the current Kernal version,\nthe address that it points to is 45482 ($B1AA).  Disassembly of the\nROMs indicates that BASIC does not use this vector.  However, it may\nbe of real assistance to the programmer who wishes to use data that is\nstored in floating point format.  The parameter that is passed by the\nUSR command is available only in that format, for example.\n\nSince it is extremely difficult to decipher and use a floating point\nnumber, the simplest way to deal with such data is to use the\nconversion routines that are built into BASIC to change it into a\ntwo-byte signed integer.  This could be accomplished by jumping\ndirectly into the BASIC ROM, if you know the location of the routine.\nTherefore, if the address changes in future versions of the 64 or\nfuture Commodore computers, you won't have to modify your program to\nmake it work with them.\n\nSee the entry for the USR vector at 785 ($311) for an explanation of\nhow to use this routine in connection with the USR command."
  },
  {
    "id": "map-5-6",
    "address_start": 5,
    "address_end": 6,
    "hex_start": "$5",
    "hex_end": "$6",
    "label": "ADRAY2",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "5-6           $5-$6          ADRAY2\nVector: Routine to Convert a Number from Integer to Floating Point\n\nThis vector points to the address of the BASIC routine which converts\nan integer to a floating point number.  This routine is currently\nlocated at 45969 ($B391).  BASIC does not appear to reference this\nlocation.  It is available for use by the programmer who needs to make\nsuch a conversion for a machine language program that interacts with\nBASIC.  For an explanation of how to use this routine in connection\nwith the USR command, see the entry for the USR vector at 785 ($311)."
  },
  {
    "id": "map-7",
    "address_start": 7,
    "address_end": 7,
    "hex_start": "$7",
    "hex_end": "$7",
    "label": "CHARAC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "7             $7             CHARAC\nSearch Character for Scanning BASIC Text Input\n\nThis location and the next are used heavily by the BASIC routines that\nscan the text that comes into the buffer at 512 ($200), in order to\ndetect significant characters such as quotes, comma, the colon which\nseparates BASIC statements, and end-of-line.  The ASCII values of such\nspecial characters are usually stored here.\n\nThis location is also used as a work area by other BASIC routines that\ndo not involve scanning text."
  },
  {
    "id": "map-8",
    "address_start": 8,
    "address_end": 8,
    "hex_start": "$8",
    "hex_end": "$8",
    "label": "ENDCHR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "8             $8             ENDCHR\nSearch Character for Statement Termination or Quote\n\nLike location 7, this location is used as a work byte during the\ntokenization of a BASIC statement.  Most of the time, its value is 0\nor 34."
  },
  {
    "id": "map-9",
    "address_start": 9,
    "address_end": 9,
    "hex_start": "$9",
    "hex_end": "$9",
    "label": "TRMPOS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "9             $9             TRMPOS\nColumn position of the Cursor before the Last TAB or SPC\n\nTRMPOS is used by TAB and SPC.  The cursor column position prior to\nthe TAB or SPC is moved here from 211 ($D3), and is used to calculate\nwhere the cursor ends up after one of these functions is invoked.\nNote that the value contained here shows the position of the cursor on\na logical line.  Since one logical line can be up to two physical\nlines long, the value stored here can range from 0 to 79."
  },
  {
    "id": "map-A",
    "address_start": 10,
    "address_end": 10,
    "hex_start": "$A",
    "hex_end": "$A",
    "label": "VERCK",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "10            $A             VERCK\nFlag: LOAD or VERIFY\n\nBASIC uses one Kernal routine to perform either the LOAD or VERIFY\nfunction, depending on whether the Accumulator (.A) is set to 0 or 1\nupon entry to the routine.  BASIC sets the value of VERCK to 0 for a\nLOAD, or 1 for a VERIFY.  Its contents are passed to the Kernal LOAD\nroutine, which in turn stores it in location 147 ($93)."
  },
  {
    "id": "map-B",
    "address_start": 11,
    "address_end": 11,
    "hex_start": "$B",
    "hex_end": "$B",
    "label": "COUNT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "11            $B             COUNT\nIndex into the Text Input Buffer/Number of Array Subscripts\n\nThe routines that convert the text in the input buffer at 512 ($200)\ninto lines of executable program tokes, and the routines that link\nthese program lines together, use this location as an index into the\ninput buffer area.  When the job of converting text to tokens is\nfinished, the value in this location is equal to the length of the\ntokenized line.\n\nThe routines which build an array or locate an element in an array use\nthis location to calculate the number of DIMensions called for and the\namount of storage required for a newly created array, or the number of\nsubscripts specified when referencing an array element."
  },
  {
    "id": "map-C",
    "address_start": 12,
    "address_end": 12,
    "hex_start": "$C",
    "hex_end": "$C",
    "label": "DIMFLG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "12            $C             DIMFLG\nFlags for the Routines That Locate or Build an Array\n\nThis location is used as a flag by the routines that build an array or\nreference an existing array.  It is used to determine whether a\nvariable is in an array, whether the array has already been\nDIMensioned, and whether a new array should assume the default\ndimensions."
  },
  {
    "id": "map-D",
    "address_start": 13,
    "address_end": 13,
    "hex_start": "$D",
    "hex_end": "$D",
    "label": "VALTYP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "13            $D             VALTYP\nFlag: Type of Data (String or Numeric)\n\nThis flag is used internally to indicate whether data being operated\nupon is string or numeric.  A value of 255 ($FF) in this location\nindicates string data, while a 0 indicates numeric data.  This\ndetermination is made every time a variable is located or created."
  },
  {
    "id": "map-E",
    "address_start": 14,
    "address_end": 14,
    "hex_start": "$E",
    "hex_end": "$E",
    "label": "INTFLG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "14            $E             INTFLG\nFlat: Type of Numeric Data (Integer or Floating Point)\n\nIf data which BASIC is using is determined to be numeric, it is\nfurther classified here as either a floating point number or as an\ninteger.  A 128 ($80) in this location identifies the number as an\ninteger, and a 0 indicates a floating point number."
  },
  {
    "id": "map-F",
    "address_start": 15,
    "address_end": 15,
    "hex_start": "$F",
    "hex_end": "$F",
    "label": "GARBFL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "15            $F             GARBFL\nFlag for LIST, Garbage Collection, and Program Tokenization\n\nThe LIST routine uses this byte as a flag to let it know when it has\ncome to a character string in quotes.  It will then print the string,\nrather than search it for BASIC keyword tokens.\n\nThe garbage collection routine uses this location as a flag to\nindicate that garbage collection has already been tried before adding\na new string.  If there is still not enough memory, an OUT OF MEMORY\nmessage will result.\n\nThis location is also used as a work byte for the process of\nconverting a line of text in the BASIC input buffer (512, $200) into a\nlinked program line of BASIC keyword tokens."
  },
  {
    "id": "map-10",
    "address_start": 16,
    "address_end": 16,
    "hex_start": "$10",
    "hex_end": "$10",
    "label": "SUBFLG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "16            $10            SUBFLG\nFlag: Subscript Reference to an Array or User-Defined Function Call (FN)\n\nThis flag is used by the PTRGET routine which finds or creates a\nvariable, at the time it checks whether the name of a variable is\nvalid.  If an opening parenthesis is found, this flag is set to\nindicate that the variable in question is either an array variable or\na user-defined function.\n\nYou should note that it is perfectly legal for a user-defined function\n(FN) to have the same name as a floating point variable.  Moreover, it\nis also legal to redefine a function.  Using a FN name in an already\ndefined function results in the new definition of the function."
  },
  {
    "id": "map-11",
    "address_start": 17,
    "address_end": 17,
    "hex_start": "$11",
    "hex_end": "$11",
    "label": "INPFLG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "17            $11            INPFLG\nFlag: Is Data Input to GET, READ or INPUT?\n\nSince the keywords GET, INPUT, and READ perform similar functions,\nBASIC executes some of the same instructions for all three.  There are\nalso many areas of difference, however, and this flag indicates which\nof the three keywords is currently being executed, so that BASIC will\nknow whether or not to execute the instructions which relate to the\nareas in which the commands differ (152 ($98)=READ, 64 ($40)=GET,\n0=INPUT).\n\nAs a result, INPUT will show the ? prompt, will echo characters back\nto the screen, and will wait for a whole line of text ended by a\ncarriage return.  GET gives no prompt and accepts one character\nwithout waiting.  The colon character and the comma are valid data for\nGET, but are treated as delimiters between data by INPUT and READ.\n\nAs each command has its own error messages, this flag is used to\ndetermine the appropriate message to issue in case of an error."
  },
  {
    "id": "map-12",
    "address_start": 18,
    "address_end": 18,
    "hex_start": "$12",
    "hex_end": "$12",
    "label": "TANSGN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "18            $12            TANSGN\nFlag: Sign of the Result of the TAN or SIN Function\n\nThis location is used to determine whether the sign of the value\nreturned by the functions SIN or TAN is positive or negative.\n\nAdditionally, the string and numeric comparison routines use this\nlocation to indicate the outcome of the comparison.  For a comparison\nof variable A to variable B, the value here will be 1 if A is greater\nthan B, 2 if A equals B, and 4 if a is less than B.  If more than one\ncomparison operator was used to compare the two variables (e.g., >= or\n<=), the value here will be a combination of the above values."
  },
  {
    "id": "map-13",
    "address_start": 19,
    "address_end": 19,
    "hex_start": "$13",
    "hex_end": "$13",
    "label": "CHANNL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "19            $13            CHANNL\nCurrent I/O Channel (CMD Logical File) Number\n\nWhenever BASIC inputs or outputs data, it looks here to determine\nwhich I/O device is currently active for the purpose of prompting or\noutput control.  It uses location 184 ($B8) for purposes of deciding\nwhat device actually to put input from or output to.\n\nWhen the default input device (number 0, the keyboard) or output\ndevice (number 3, the display screen) is used, the value here will be\na zero, and the format of prompting and output will be the standard\nscreen output format.\n\nWhen another device is used, the logical file number (CMD channel\nnumber) will be placed here.  This lets the system now that it may\nhave to make some subtle changes in the way it performs the I/O\noperation.  For example, if TAB is used with the PRINT command, cursor\nright characters are used if the device PRINTed to is the screen.\nOtherwise, spaces are output when the number here is other than zero\n(the assumption being that you can't tab a printer like you can the\nscreen).\n\nLikewise, the ? prompt for INPUT is suppressed if the file number here\nis nonzero, as is the EXTRA IGNORED message, and input of a carriage\nreturn by itself is ignored, rather than being treated as a null\nstring (\"\").  Therefore, by OPENing the screen as a device, and\nissuing the CMD statement, you can force the suppression of the ?\nprompt, and the other effects above.\n\nCMD places the new output file number here, and calls the Kernal to\nopen the device for output, leaving it LISTENing for output (such as\nthe READY prompt, which is diverted to the new device).\n\nMany routines reset this location and UNLISTEN the device, defeating\nthe CMD and once again sending the output to the screen.  If an error\nmessage has to be displayed, for example, this location will be reset\nand the message will be displayed on the screen.  GET, GET#, INPUT,\nINPUT#, and PRINT# all will reset this location after the I/O is\ncompleted, effectively redirecting output back to the screen.  PRINT\nand LIST are the only I/O operations that will not undo the CMD.\n\nThis location can also be used to fool BASIC into thinking that data\nit is reading from the tape is actually being entered into the\nkeyboard in immediate mode.\n\nFor a look at a technique that uses a different approach to accomplish\nthe same thing for disk or tape users, see location 512 ($200), the\nkeyboard buffer."
  },
  {
    "id": "map-14-15",
    "address_start": 20,
    "address_end": 21,
    "hex_start": "$14",
    "hex_end": "$15",
    "label": "LINNUM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "20-21         $14-$15        LINNUM\nInteger Line Number Value\n\nThe target line number for GOTO, LIST, ON, and GOSUB is stored here in\nlow- byte, high-byte integer format, as is the number of a BASIC line\nthat is to be added or replaced.\n\nLIST saves the highest line number to list (or 65535 ($FFFF) if\nprogram is to be listed to the end) at this location.\n\nGOTO tests the target line number to see if it is greater than the\nline number currently being executed.  If it is greater, GOTO starts\nits search for the target line at the current line number.  If it is\nnot greater, GOTO must search for the target line from the first line\nof the program.  It is interesting to note that the test is of the\nmost significant byte only.  Therefore, INT(TARGETLINE/256) must be\ngreater than INT(CURRENTLINE/256) in order for the search to start\nwith the current line, instead of at the beginning of the program.\n\nPEEK, POKE, WAIT, and SYS use this location as a pointer to the\naddress which is the subject of the command."
  },
  {
    "id": "map-16",
    "address_start": 22,
    "address_end": 22,
    "hex_start": "$16",
    "hex_end": "$16",
    "label": "TEMPPT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "22            $16            TEMPPT\nPointer to the Next Available Space in the Temporary String Stack\n\nThis location points to the next available slot in the temporary\nstring descriptor stack located at 25-33 ($19-$21).  Since that stack\nhas room for three descriptors of three bytes each, this location will\npoint to 25 ($19) if the stack is empty, to 28 ($1C) if there is one\nentry, to 31 ($1F) if there are two entries, and to 34 ($22) if the\nstack is full.\n\nIf BASIC needs to add an entry to the temporary string descriptor\nstack, and this location holds a 34, indicating that the stack is\nfull, the FORMULA TOO COMPLEX error message is issued.  Otherwise, the\nentry is added, and three is added to this pointer."
  },
  {
    "id": "map-17-18",
    "address_start": 23,
    "address_end": 24,
    "hex_start": "$17",
    "hex_end": "$18",
    "label": "LASTPT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "23-24         $17-$18        LASTPT\nPointer to the Address of the Last String in the Temporary String\nStack\n\nThis pointer indicates the last slot used in the temporary string\ndescriptor stack.  Therefore, the value stored at 23 ($17) should be 3\nless than that stored at 22 ($16), while 24 ($18) will contain a 0."
  },
  {
    "id": "map-19-21",
    "address_start": 25,
    "address_end": 33,
    "hex_start": "$19",
    "hex_end": "$21",
    "label": "TEMPST",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "25-33         $19-$21        TEMPST\nDescriptor Stack for Temporary Strings\n\nThe temporary string descriptor stack contains information about\ntemporary strings which hve not yet been assigned to a string\nvariable.  An examples of such a temporary string is the literal\nstring \"HELLO\" in the statement PRINT \"HELLO\".\n\nEach three-byte descriptor in this stack contains the length of the\nstring, and its starting and ending locations, expresses as\ndisplacements within the BASIC storage area."
  },
  {
    "id": "map-22-25",
    "address_start": 34,
    "address_end": 37,
    "hex_start": "$22",
    "hex_end": "$25",
    "label": "INDEX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "34-37         $22-$25        INDEX\nMiscellaneous Temporary Pointers and Save Area\n\nThis area is used by many BASIC routines to hold temporary pointers\nand calculation results."
  },
  {
    "id": "map-26-2A",
    "address_start": 38,
    "address_end": 42,
    "hex_start": "$26",
    "hex_end": "$2A",
    "label": "RESHO",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "38-42         $26-$2A        RESHO\nFloating Point Multiplication Work Area\n\nThis location is used by BASIC multiplication and division routines.\nIt is also used by the routines which compute the size of the area\nrequired to store an array which is being created."
  },
  {
    "id": "map-2B-2C",
    "address_start": 43,
    "address_end": 44,
    "hex_start": "$2B",
    "hex_end": "$2C",
    "label": "TXTTAB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "43-44         $2B-$2C        TXTTAB\nPointer to the Start of BASIC Program Text\n\nThis two-byte pointer lets BASIC know where program text is stored.\nOrdinarily, such text is located beginning at 2049 ($801).  Using this\npointer, it is possible to change the program text area.  Typical\nreasons for doing this include:\n\n1.  Conforming the memory configuration to that of other Commodore\ncomputers.  On 32K PET and CBM computers, for example, screen memory\nstarts at 32768 ($8000), and BASIC text begins at 1025 ($401).  You\ncan emulate this configuration with the 64 with the following short\nprogram:\n\n10 POKE 55,0:POKE 56,128: CLR: REM LOWER TOP OF MEMORY TO 32768\n20 POKE 56576,PEEK(56576) AND 253: REM ENABLE BANK 2\n30 POKE 53272,4: REM TEXT DISPLAY MEMORY NOW STARTS AT 32768\n40 POKE 648,128:REM OPERATING SYSTEM PRINTS TO SCREEN AT 32768 (128*256)\n50 POKE 44,4:POKE 1024,0: REM MOVE START OF BASIC TO 1025 (4*256+1)\n60 POKE 792,193: REM DISABLE RESTORE KEY\n70 PRINT CHR$(147);\"NOW CONFIGURED LIKE PET\":NEW\n80 REM ALSO SEE ENTRIES FOR LOCATION 55, 56576, AND 648\n\nSuch reconfiguring can be helpful in transferring programs from the 64\nto the PET, or vice versa.  Since the 64 automatically relocates BASIC\nprogram text, it can load and list PET programs even though the\nprogram file indicates a loading addresss that is different from the\n64 start of BASIC.  The PET does not have this automatic relocation\nfeature, however, and it loads all BASIC programs at the two-byte\naddress indicated at the beginning of the disk or tape file.\n\nSo if the PET loads a 64 program at its normal starting address of\n2049 ($801), it will not recognize its presence because it expects a\nBASIC program to start at 1025 ($401).  Therefore, if you want to let\na PET and 64 share a program, you must either reconfigure the 64 to\nstart BASIC where the PET does, or reconfigure the PET to start BASIC\nwhere the 64 does (with a POKE 41,8:POKE 2048,0).\n\n2.  Raising the lowest location used for BASIC text in order to create\na safe area in low memory.  For example, if you wish to use the\nhigh-resolution graphics mode, you may want to put the start of screen\nmemory at 8192 ($2000).  The high-resolution moe requires 8K of\nmemory, and you cannot use the lowest 8K for this purpose because it\nis already being used for the zero-page assignments.\n\nSince BASIC program text normally starts at 2048 ($801), this means\nthat you only have 6k for program text before your program runs over\ninto screen memory.  One way around this is by moving the start of\nbasic to 16385 ($4001) by typing in direct entry mode:\n\nPOKE 44,64: POKE 64*256,0:NEW\n\nOther uses might include setting aside a storage area for sprite shape\ndata, or user-defined character sets.\n\n3.  Keeping two or more programs in memory simultaneously.  By\nchanging this pointer, you can keep more than one BASIC program in\nmemory at one time, and switch back and forth betwenn them.  Examples\nof this application can be found in COMPUTE!'s First Book of PET/CBM,\npages 66 and 163.\n\nThis technique has a number of offshoots that are perhaps of more\npractical use.\n\na) You can store two programs in memory simultaneously for the purpose\nof appending one to the other.  This technique requires that the line\nnumbers of the two programs do not overlap.  (See Programming the\nPET/CBM by Raeto Collin West, pages 41-42, for a discussion of this\ntechnique).\n\nb) You can have two programs in memory at once and use the concept in\n(2) above to allow an easier way to create a safe area in low memory.\nThe first program is just onw line that sets the start of BASIC\npointer to the address of the second program which is located higher\nin memory, and then runs that second program.\n\n4. Since this address is used as the address of the first byte to\nSAVE, you can save any section of memory by changing this pointer to\nindicate the starting address, and the pointer 45-46 ($2D-$2D) to\nindicate the address of the byte after the last byte that you wish to\nsave."
  },
  {
    "id": "map-2D-2E",
    "address_start": 45,
    "address_end": 46,
    "hex_start": "$2D",
    "hex_end": "$2E",
    "label": "VARTAB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "45-46         $2D-$2E        VARTAB\nPointer to the Start of the BASIC Variable Storage Area\n\nThis location points to the address which marks the end of the BASIC\nprogram text area, and the beginning of the variable storage area.\nAll nonarray variables are stored here, as are string descriptors (for\nthe address of the area where the actual text of strings is stored,\nsee location 51 ($33)).\n\nSeven bytes of memory are allocated for each variable.  The first two\nbytes are used for the variable name, which consists of the ASCII\nvalue of the first two letters of the variable name.  If the variable\nname is a single letter, the second byte will contain a zero.\n\nThe seventh bit of one or both of these bytes can be set (which would\nadd 128 to the ASCII value of the letter).  This indicates the\nvariable type.  If neither byte has the seventh bit set, the variable\nis the regular floating point type.  If only the first byte has its\nseventh bit set, the variable is a string.  If only the second byte\nhas its seventh bit set, the variable is a defined function (FN).  If\nboth bytes have the seventh bit set, the variable is an integer.\n\nThe use of the other five bytes depends on the type of variable.  A\nfloating point variable will use the five bytes to store the value of\nthe variable in floating point format.  An integer will have its value\nstored in the third and fourth bytes, high byte first, and the other\nthree will be unused.\n\nA string variable will use the third byte for its length, and the\nfourth and fifth bytes for a pointer to the address of the string\ntext, leaving the last two bytes unused.  Note that the acrual string\ntext that is pointed to is located either in the part of the BASIC\nprogram where the string is first assigned a value, or in the string\ntext storage area pointed to by location 51 ($33).\n\nA function definition will use the third and fourth bytes for a\npointer to the address in the BASIC program text where the function\ndefinition starts.  It uses the fifth and sixth bytes for a pointer to\nthe dependent variable (the X of FN A(X)).  The final byte is not\nused.\n\nKnowing something about how variables are created can help your BASIC\nprogramming.  For example, you can see that nonarray integer variables\ntake up no less space than floating point variables, and since most\nBASIC commands convert the integers to floating point, they do not\noffer a speed advantage either, and in many cases will actually slow\nthe program down.  As will be seen below, however, integer arrays can\nsave a considerable amount of space.\n\nVariables are stored in the order in which they are created.\nLikewise, when BASIC goes looking for a variable, it starts its search\nat the beginning of this area.  If commonly used variables are defined\nat the end of the program, and are thus at the back of this area, it\nwill take longer to find them.  It may help program execution speed to\ndefine the variables that will be used most frequently right at the\nbeginning of the program.\n\nAlso, remember that once created, variables do not go away during\nprogram execution.  Even if they are never used again, they still take\nup space in the variable storage area, and they slow down the routine\nthat is used to search for variables that are referenced.\n\nAnother point to consider about the order in which to define variables\nis that arrays are created in a separate area of memory which starts\nat the end of the nonarray variable area.  Therefore, every time a\nnonarray variable is created, all of the arrays must be moved seven\nbytes higher in memory in order to make room for the new variable.\nTherefore, it may help performance to avoid defining nonarray\nvariables after defining arrays.\n\nThis pointer will be reset to one byte past the end of the BASIC\nprogram text whenever you execute the statements CLR, NEW, RUN, or\nLOAD.  Adding or modifying a BASIC statement will have the same\neffect, because the higher numbered BASIC statements have to be moved\nup into memory to make room for the new statements, and can therefore\noverwrite the variable storage area.  This means that if you wish to\ncheck the value of a variable after stopping a program, you can only\ndo so before modifying the program.\n\nThe exception to the above is when the LOAD command is issued from a\nprogram.  The purpose of not resetting this pointer in such a case is\nto allow the chaining of programs by having one program load and then\nrun the next (that is also why a LOAD issued from a program causes a\nRUN from the beginning of the program).  This allows the second\nprogram to share variables with the first.  There are problems with\nthis, however.  Some string variable descriptors and function\ndefinitions have their pointers set to areas within the program text.\nWhen this text is replaced by a load, these pointers are no longer\nvalid, which will lead to errors if the FN or string value is\nreferenced.  And if the second program text area is larger than that\nof the first, the second program will overwrite some of the first\nprogram's variables, and their values will be lost.\n\nThe ability to chain short programs is a holdover from the days of the\n8K PET, for which this BASIC was written, but with the vastly\nincreased memory of the 64, program chaining should not be necessary.\n\nYou should also note that SAVE uses this pointer as the address of the\nbyte after the last byte to SAVE."
  },
  {
    "id": "map-2F-30",
    "address_start": 47,
    "address_end": 48,
    "hex_start": "$2F",
    "hex_end": "$30",
    "label": "ARYTAB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "47-48          $2F-$30       ARYTAB\nPointer to the Start of the BASIC Array Storage Area\n\nThis location points to the address of the end of nonarray variable\nstorage, and the beginning of array variable storage.  The format for\narray storage is as follows:\n\nThe first two bytes hold the array name.  The format and high-bit\npatterns are the same as for nonarray variables (see 45 ($2D) above),\nexcept that there is no equivalent to the function definition.\n\nNext comes a two-byte offset to the start of the next array, low byte\nfirst.  Then there is a one-byte value for the number of array\ndimensions (e.g., 2 for a two-dimensional array like A(x,y)).  That\nbyte is followed by pairs of bytes which hold the value of each array\ndimension+1 (DIMensioning an array always makes space for 0, so A(0)\ncan be used).\n\nFinally come the values of the variables themselves.  The format for\nthese values is the same as with nonarray values, but each value only\ntakes up the space required; that is, floating point variables use\nfive bytes each, integers two bytes, and string descriptors three\nbytes each.\n\nRemember that as with nonarray string, the actual string text is\nstored elsewhere, in the area which starts at the location pointed to\nin 51-52 ($33- $34)."
  },
  {
    "id": "map-31-32",
    "address_start": 49,
    "address_end": 50,
    "hex_start": "$31",
    "hex_end": "$32",
    "label": "STREND",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "49-50         $31-$32        STREND\nPointer to End of the BASIC Array Storage Area (+1), and the Start of\nFree RAM\n\nThis location points to the address of the end of BASIC array storage\nspace and the start of free RAM.  Since string text starts at the top\nof memory and builds downwards, this location can also be thought of\nas the last possible address of the string storage area.  Defining new\nvariables pushes this pointer upward, toward the last string text.\n\nIf a string for which space is being allocated would cross over this\nboundary into the array storage area, garbage collection is performed,\nand if there still is not enough room, an OUT OF MEMORY error occurs.\nFRE performs garbage collection, and returns the difference between\nthe addresses pointed to here and the address of the end of string\ntext storage pointed to by location 51 ($33)."
  },
  {
    "id": "map-33-34",
    "address_start": 51,
    "address_end": 52,
    "hex_start": "$33",
    "hex_end": "$34",
    "label": "FREETOP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "51-52         $33-$34        FREETOP\nPointer to the Bottom of the String Text Storage Area\n\nThis pointer marks the current end of the string text area, and the\ntop of free RAM (strings are built from the top of memory downward).\nAdditional string texts are added, to the area below the address\npointed to here.  After they are added, this pointer is lowered to\npoint below the newly added string text.  The garbage collection\nroutine (which is also called by FRE) readjusts this pointer upward.\n\nWhile the power-on/reset routines set this pointer to the top of RAM,\nthe CLR command sets this pointer to the end of BASIC memory, as\nindicated in location 55 ($37).  This allows the user to set aside an\narea of BASIC memory that will not be disturbed by the program, as\ndetailed at location 55 ($37)."
  },
  {
    "id": "map-35-36",
    "address_start": 53,
    "address_end": 54,
    "hex_start": "$35",
    "hex_end": "$36",
    "label": "FRESPC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "53-54         $35-$36        FRESPC\nTemporary Pointer for Strings\n\nThis is used as a temporary pointer to the most current string added\nby the routines which build strings or move them in memory."
  },
  {
    "id": "map-37-38",
    "address_start": 55,
    "address_end": 56,
    "hex_start": "$37",
    "hex_end": "$38",
    "label": "MEMSIZ",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "55-56         $37-$38        MEMSIZ\nPointer to the Highest Address Used by BASIC\n\nThe power-on/reset routine tests each byte of RAM until it comes to\nthe BASIC ROM, and sets this pointer to the adress of the highest byte\nof consecutive RAM found (40959, $9FFF).\n\nThere are two circumstances under which this pointer may be changed\nafter power-up to reflect an address lower than the actual top of\nconsecutive RAM:\n\n1.  Users may wish to lower this pointer themselves, in order to set\naside an area of free RAM that will not be disturbed by BASIC.  For\nexample, to set aside a 1K area at the top of BASIC, start your\nprogram with the line:\n\nPOKE 56,PEEK(56)-4:CLR\n\nThe CLR is necessary to insure that the string text will start below\nyour safe area.\n\nYou may wish to store machine language programs, sprites, or alternate\ncharacter sets in such an area.  For the latter two applications,\nhowever, keep in mind the 16K addressing range limitation of the\nVIC-II chip.  If you do not assign the VIC-II to a bank other than the\ndefault memory bank of 0-16383 ($0-$3FFF), you must lower the top of\nmemory below 16383 ($3FFF) if you wish your sprite or character data\narea to be within its addressing range.\n\n2.  Then the RS-232 device (number 2) is opened, this pointer and the\npointer to the end of user RAM at 643 are lowered by 512 bytes in\norder to create two 256-byte buffers, one for input and the other for\noutput.\n\nSince the contents of these buffers will overwrite any variables at\nthe top of memory, a CLR command is issued at the time device 2 is\nopened.  Therefore, the RS-232 device should be opened before defining\nany variables, and before setting aside a safe area for machine\nlanguage programs or other uses, as described above."
  },
  {
    "id": "map-39-3A",
    "address_start": 57,
    "address_end": 58,
    "hex_start": "$39",
    "hex_end": "$3A",
    "label": "CURLIN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "57-58         $39-$3A        CURLIN\nCurrent BASIC Line Number\n\nThis location contains the line number of the BASIC statement which is\ncurrently being executed, in LSB/MSB format.  A value of 255 ($FF) in\nlocation 58 ($3A), which translates to a line number of 65280 or above\n(well over the 63999 limit for a program line), means that BASIC is\ncurrently in immediate mode, rather than RUN mode.\n\nBASIC keywords that are illegal in direct mode check 58 ($3A) to\ndetermine whether or not this is the current mode.\n\nWhen in RUN mode, this location is updated as each new BASIC line is\nfetched for execution.  Therefore, a TRACE function could be added by\ndiverting the vector at 776 ($308), which points to the routine that\nexecutes the next token, to a user-written routine which prints the\nline number indicated by this location before jumping to the token\nexecution routine.  (LISTing the line itself would be somewhat harder,\nbecause LIST uses many Page 0 locations that would have to be\npreserved and restored afterwards.)\n\nThis line number is used by BREAK and error messages to show where\nprogram execution stopped.  The value here is copied to 59 ($3B) by\nSTOP, END, and the stop-key BREAK, and copied back by CONT."
  },
  {
    "id": "map-3B-3C",
    "address_start": 59,
    "address_end": 60,
    "hex_start": "$3B",
    "hex_end": "$3C",
    "label": "OLDLIN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "59-60         $3B-$3C        OLDLIN\nPrevious BASIC Line Number\n\nWhen program execution ends, the last line number executed is stored\nhere, and restored to location 57 ($39) by CONT."
  },
  {
    "id": "map-3D-3E",
    "address_start": 61,
    "address_end": 62,
    "hex_start": "$3D",
    "hex_end": "$3E",
    "label": "OLDTXT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "61-62         $3D-$3E        OLDTXT\nPointer to the Address of the Current BASIC Statement\n\nThis location contains the address (not the line number) of the text\nof the BASIC statement that is being executed.  The value of TXTPTR\n(122, $7A), the pointer tot he address of the BASIC text character\ncurrently being scanned, is stored here each time a new BASIC line\nbegins execution.\n\nEND, STOP, and the STOP-key BREAK save the value of TXTPTR here, and\nCONT restores this value to TXTPTR.  CONT will not continue if 62\n($3E) has been changed to a zero by a LOAD, a modification to the\nprogram text, or by error routines."
  },
  {
    "id": "map-3F-40",
    "address_start": 63,
    "address_end": 64,
    "hex_start": "$3F",
    "hex_end": "$40",
    "label": "DATLIN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "63-64         $3F-$40        DATLIN\nCurrent DATA Line Number\n\nThis location holds the line number of the current DATA statement\nbeing READ.  It should be noted that this information is not used to\ndetermine where the next DATA item is read from (that is the job of\nthe pointer at 65-66 ($41-$42) below).  But if an error concerning the\nDATA occurs, this number will be moved to 57 ($39), so that the error\nmessage will show that the error occurred in the line that contains\nthe DATA statement, rather than in the line that contains the READ\nstatement."
  },
  {
    "id": "map-41-42",
    "address_start": 65,
    "address_end": 66,
    "hex_start": "$41",
    "hex_end": "$42",
    "label": "DATPTR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "65-66         $41-$42        DATPTR\nPointer to the Address of the Current DATA Item\n\nThis location points to the address (not the line number) within the\nBASIC program text area where DATA is currently being READ.  RESTORE\nsets this pointer back to the address indicated by the start of BASIC\npointer at location 43 ($2B).\n\nThe sample program below shows how the order in which DATA statements\nare READ can be changed using this pointer.  The current address of\nthe statement before the DATA statement is stored in a variable, and\nthen used to change this pointer.\n\n10 A1=PEEK(61):A2=PEEK(62)\n20 DATA THIS DATA WILL BE USED SECOND\n30 B1=PEEK(61):B2=PEEK(62)\n40 DATA THIS DATA WILL BE USED FIRST\n50 C1=PEEK(61):C2=PEEK(62)\n60 DATA THIS DATA WILL BE USED THIRD\n70 POKE 65,B1:POKE 66,B2:READ A$:PRINT A$\n80 POKE 65,A1:POKE 66,A2:READ A$:PRINT A$\n90 POKE 65,C1:POKE 66,C2:READ A$:PRINT A$"
  },
  {
    "id": "map-43-44",
    "address_start": 67,
    "address_end": 68,
    "hex_start": "$43",
    "hex_end": "$44",
    "label": "INPPTR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "67-68         $43-$44        INPPTR\nPointer in the Source of GET, READ, or INPUT Information\n\nREAD, INPUT and GET all use this as a pointer to the address of the\nsource of incoming data, such as DATA statements, or the text input\nbuffer at 512 ($200)."
  },
  {
    "id": "map-45-46",
    "address_start": 69,
    "address_end": 70,
    "hex_start": "$45",
    "hex_end": "$46",
    "label": "VARNAM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "69-70         $45-$46        VARNAM\nCurrent BASIC Variable Name\n\nThe current variable name being searched for is stored here, in the\nsame two- byte format as in the variable value storage area located at\nthe address pointed to by 45 ($2D).  See that location for an\nexplanation of the format."
  },
  {
    "id": "map-47-48",
    "address_start": 71,
    "address_end": 72,
    "hex_start": "$47",
    "hex_end": "$48",
    "label": "VARPNT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "71-72         $47-$48        VARPNT\nPointer to the Current BASIC Variable Value\n\nThis location points to the address of the descriptor of the current\nBASIC variable (see location 45 ($2D) for the format of a variable\ndescriptor).  Specifically, it points to the byte just after the\ntwo-character variable name.\n\nDuring a FN call, this location does not point to the dependent\nvariable (the A of FN A), so that a real variable of the same name\nwill not have its value changed by the call."
  },
  {
    "id": "map-49-4A",
    "address_start": 73,
    "address_end": 74,
    "hex_start": "$49",
    "hex_end": "$4A",
    "label": "FORPNT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "73-74         $49-$4A        FORPNT\nTemporary Pointer to the Index Variable Used by FOR\n\nThe address of the BASIC variable which is the subject of a FOR/NEXT\nloop is first stored here, but is then pushed onto the stack.  That\nleaves this location free to be used as a work area by such statements\nas INPUT, GET, READ, LIST, WAIT, CLOSE, LOAD, SAVE, RETURN, and GOSUB.\n\nFor a description of the stack entries made by FOR, see location 256\n($100)."
  },
  {
    "id": "map-4B-4C",
    "address_start": 75,
    "address_end": 76,
    "hex_start": "$4B",
    "hex_end": "$4C",
    "label": "OPPTR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "75-76         $4B-$4C        OPPTR\nMath Operator Table Displacement\n\nThis location is used during the evaluation of mathematical\nexpressions to hold the displacement of the current math operator in\nan operator table.  It is also used as a save area for the pointer to\nthe address of program text which is currently being read."
  },
  {
    "id": "map-4D",
    "address_start": 77,
    "address_end": 77,
    "hex_start": "$4D",
    "hex_end": "$4D",
    "label": "OPMASK",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "77            $4D            OPMASK\nMask for Comparison Operation\n\nThe expression evaluation routine creates a mask here which lets it\nknow whether the current comparieson operation is a less-than (1),\nequals (2), or greater-than (4) comparison."
  },
  {
    "id": "map-4E-4F",
    "address_start": 78,
    "address_end": 79,
    "hex_start": "$4E",
    "hex_end": "$4F",
    "label": "DEFPNT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "78-79         $4E-$4F        DEFPNT\nPointer to the Current FN Descriptor\n\nDuring function definition (DEF FN) this location is used as a pointer\nto the descriptor that is created.  During function execution (FN) it\npoints to the FN descriptor in which the evaluation results should be\nsaved."
  },
  {
    "id": "map-50-52",
    "address_start": 80,
    "address_end": 82,
    "hex_start": "$50",
    "hex_end": "$52",
    "label": "DSCPNT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "80-82         $50-$52        DSCPNT\nTemporary Pointer to the Current String Descriptor\n\nThe string assignment and handling routines use the first two bytes as\na temporary pointer to the current string descriptor, and the third to\nhold the value of the string length."
  },
  {
    "id": "map-53",
    "address_start": 83,
    "address_end": 83,
    "hex_start": "$53",
    "hex_end": "$53",
    "label": "FOUR6",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "83            $53            FOUR6\nConstant for Garbage Collection\n\nThe constant contained here lets the garbage collection routines know\nwhether a three- or seven-byte string descriptor is being collected."
  },
  {
    "id": "map-54-56",
    "address_start": 84,
    "address_end": 86,
    "hex_start": "$54",
    "hex_end": "$56",
    "label": "JMPER",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "84-86         $54-$56        JMPER\nJump to Function Instruction\n\nThe first byte is the 6502 JMP instruction ($4C), followed by the\naddress of the required function taken from the table at 41042\n($A052)."
  },
  {
    "id": "map-57-60",
    "address_start": 87,
    "address_end": 96,
    "hex_start": "$57",
    "hex_end": "$60",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "87-96         $57-$60\nBASIC Numeric Work Area\n\nThis is a very busy work area, used by many routines."
  },
  {
    "id": "map-61-66",
    "address_start": 97,
    "address_end": 102,
    "hex_start": "$61",
    "hex_end": "$66",
    "label": "FAC1",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "97-102        $61-$66        FAC1\nFloating Point Accumulator #1\n\nThe Floating Point Accumulator is central to the execution of any\nBASIC mathematical operation.  It is used in the conversion of\nintegers to floating point numbers, strings to floating point numbers,\nand vice versa.  The results of most evaluations are stored in this\nlocation.\n\nThe internal format of floating point numbers is not particularly easy\nto understand (or explain).  Generally speaking, the number is broken\ninto the normalized mantissa, which represents a number between 1 and\n1.99999..., and an exponent value, which represents a power of 2.\nMultiplying the mantissa by 2 raised to the value of the exponent\ngives you the value of the floating point number.\n\nFortunately, the BASIC interpreter contains many routines for the\nmanipulation and conversion of floating point number, and these\nroutines can be called by the user.  See the entries for locations 3\nand 5\n\nFloating Point Accumulator #1 can be further divided into the\nfollowing locations:"
  },
  {
    "id": "map-61",
    "address_start": 97,
    "address_end": 97,
    "hex_start": "$61",
    "hex_end": "$61",
    "label": "FACEXP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "97            $61            FACEXP\nFloating Point Accumulator #1: Exponent\n\nThis exponent represents the closest power of two to the number, with\n129 added to take care of the sign problem for negative exponents.  An\nexponent of 128 is used for the value 0; an exponent of 129 represents\n2 to the 0 power, or 1; an exponent of 130 represents 2 to the first\npower, or 2; 131 is 2 squared, or 4; 132 is 2 cubed, or 8; and so on."
  },
  {
    "id": "map-62-65",
    "address_start": 98,
    "address_end": 101,
    "hex_start": "$62",
    "hex_end": "$65",
    "label": "FACHO",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "98-101        $62-$65        FACHO\nFloating Point Accumulator #1: Mantissa\n\nThe most significant digit can be assumed to be a 1 (remember that the\nrange of the mantissa is from 1 to 1.99999...) when a floating point\nnumber is stored to a variable.  The first bit is used for the sign of\nthe number, and the other 31 bits of the four-byte mantissa hold the\nother significant digits.\n\nThe first two bytes (98-99, $62-$63) of this location will hold the\nsigned integer result of a floating point to integer conversion, in\nhigh-byte, low- byte order."
  },
  {
    "id": "map-66",
    "address_start": 102,
    "address_end": 102,
    "hex_start": "$66",
    "hex_end": "$66",
    "label": "FACSGN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "102           $66            FACSGN\nFloating Point Accumulator #1: Sign\n\nA value of 0 here indicates a positive number, while a value of 255\n($FF) indicates a negative number."
  },
  {
    "id": "map-67",
    "address_start": 103,
    "address_end": 103,
    "hex_start": "$67",
    "hex_end": "$67",
    "label": "SGNFLG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "103           $67            SGNFLG\nNumber of Terms in a Series Evaluation\n\nThis location is used by mathematical formula evaluation routines.  It\nindicates the number of separate evaluations that must be done to\nresolve a complex expression down to a single term."
  },
  {
    "id": "map-68",
    "address_start": 104,
    "address_end": 104,
    "hex_start": "$68",
    "hex_end": "$68",
    "label": "BITS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "104           $68            BITS\nFloating Point Accumulator #1: Overflow Digit\n\nThis location contains the overflow byte.  The overflow byte is used\nin an intermediate step of conversion from an integer or text string\nto a floating point number."
  },
  {
    "id": "map-69-6E",
    "address_start": 105,
    "address_end": 110,
    "hex_start": "$69",
    "hex_end": "$6E",
    "label": "FAC2",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "105-110       $69-$6E        FAC2\nFloating Point Accumulator #2\n\nA second Floating Point Accumulator, used in conjunction with Floating\nPoint Accumulator #1 in the evaluation of products, sums,\ndifferences--in short, any operation requiring more than one value.\nThe format of this accumulator is the same as FAC1."
  },
  {
    "id": "map-69",
    "address_start": 105,
    "address_end": 105,
    "hex_start": "$69",
    "hex_end": "$69",
    "label": "ARGEXP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "105           $69            ARGEXP\nFloating Point Accumulator #2: Exponent"
  },
  {
    "id": "map-6A-6D",
    "address_start": 106,
    "address_end": 109,
    "hex_start": "$6A",
    "hex_end": "$6D",
    "label": "ARGHO",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "106-109       $6A-$6D        ARGHO\nFloating Point Accumulator #2: Mantissa"
  },
  {
    "id": "map-6E",
    "address_start": 110,
    "address_end": 110,
    "hex_start": "$6E",
    "hex_end": "$6E",
    "label": "ARGSGN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "110           $6E            ARGSGN\nFloating Point Accumulator #2: Sign"
  },
  {
    "id": "map-6F",
    "address_start": 111,
    "address_end": 111,
    "hex_start": "$6F",
    "hex_end": "$6F",
    "label": "ARISGN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "111           $6F            ARISGN\nResult of a Signed Comparison of Accumulator #1 to Accumulator #2\n\nUsed to indicate whether the two Floating Point Accumulators have like\nor unlike signs.  A 0 indicates like signs, a 255 ($FF) indicates\nunlike signs."
  },
  {
    "id": "map-70",
    "address_start": 112,
    "address_end": 112,
    "hex_start": "$70",
    "hex_end": "$70",
    "label": "FACOV",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "112           $70            FACOV\nLow Order Mantissa Byte of Floating Point Accumulator #1 (For\nRounding)\n\nIf the mantissa of the floating point number has more significant\nfigures than can be held in four bytes, the least significant figures\nare placed here.  They are used to extend the accuracy of intermediate\nmathematical operations and to round to the final figure."
  },
  {
    "id": "map-71-72",
    "address_start": 113,
    "address_end": 114,
    "hex_start": "$71",
    "hex_end": "$72",
    "label": "FBUFPT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "113-114       $71-$72        FBUFPT\nSeries Evaluation Pointer\n\nThis location points to the address of a temporary table of values\nbuilt in the free RAM area for the evaluation of formulas.  It is also\nused for such various purposes as a TI$ work area, string setup\npointer, and work space for the evaluation of the size of an array.\n\nAlthough this is labeled a pointer to the tape buffer in the\nProgrammer's Reference Guide, disassembly of the BASIC ROM reveals no\nreference to this location for that purpose (see 178 ($B2) for pointer\nto tape buffer)."
  },
  {
    "id": "map-73-8A",
    "address_start": 115,
    "address_end": 138,
    "hex_start": "$73",
    "hex_end": "$8A",
    "label": "CHRGET",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "115-138       $73-$8A        CHRGET\nSubroutine: Get Next BASIC Text Character\n\nThis is actually a machine language subroutine, which at the time of a\nBASIC cold start (such as when the power is turned on) is copied from\nMOVCHG (58274, $E3A2) in the ROM to this zero page location.\n\nCHRGET is a crucial routine which BASIC uses to read text characters,\nsuch as the text of the BASIC program which is being interpreted.  It\nis placed on zero page to make the routine run faster.  Since it keeps\ntrack of the address of the character being read within the routine\nitself, the routine must be in RAM in order to update that pointer.\nThe pointer to the address of the byte currently being read is really\nthe operand of a LDA instruction.  When entered from CHRGET, the\nroutine increments the pointer by modifying the operand at TXTPTR\n(122, $7A), thus allowing the next character to be read.\n\nEntry at CHRGOT (121, $79) allows the current character to be read\nagain.  The CHRGET routine skips spaces, sets the various flags or the\nstatus register (.P) to indicate whether the character read was a\ndigit, statement terminator, or other type of character, and returns\nwith the retrieved character in the Accumulator (.A).\n\nSince CHRGET is used to read every BASIC statement before it is\nexecuted, and since it is in RAM, and therefore changeable, it makes a\nhandy place to intercept BASIC to add new features and commands (and\nin the older PET line, it was the only way to add such features).\nDiversion of the CHRGET routine for this purpose is generally referred\nto as a wedge.\n\nSince a wedge can greatly slow down execution speed, mose of the time\nit is set up so that it performs its preprocessing functions only when\nin direct or immediate mode.  The most well-known example of such a\nwedge is the \"Universal DOS Support\" program that allows easier\ncommunication with the disk drive command channel.\n\nAs this is such a central routine, a disassembly listing is given\nbelow to provide a better understanding of how it works."
  },
  {
    "id": "map-73",
    "address_start": 115,
    "address_end": 115,
    "hex_start": "$73",
    "hex_end": "$73",
    "label": "CHRGET",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "115 $73   CHRGET  INC TXTPTR   ; increment low byte of TXTPTR"
  },
  {
    "id": "map-75",
    "address_start": 117,
    "address_end": 117,
    "hex_start": "$75",
    "hex_end": "$75",
    "label": "BNE",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "117 $75           BNE CHRGOT   ; if low byte isn't 0, skip next"
  },
  {
    "id": "map-77",
    "address_start": 119,
    "address_end": 119,
    "hex_start": "$77",
    "hex_end": "$77",
    "label": "INC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "119 $77           INC TXTPTR+1 ; increment high byte of TXTPTR"
  },
  {
    "id": "map-79",
    "address_start": 121,
    "address_end": 121,
    "hex_start": "$79",
    "hex_end": "$79",
    "label": "CHRGOT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "121 $79   CHRGOT  LDA          ; load byte from where TXTPTR points\n                               ; entry here does not update TXTPTR,\n                               ; allowing you to readl the old byte again"
  },
  {
    "id": "map-7A",
    "address_start": 122,
    "address_end": 122,
    "hex_start": "$7A",
    "hex_end": "$7A",
    "label": "TXTPTR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "122 $7A   TXTPTR  $0207        ; pointer is really the LDA operand\n                               ; TXTPTR+1 points to 512-580 ($200-$250)\n                               ; when reading from the input buffer\n                               ; in direct mode"
  },
  {
    "id": "map-7C",
    "address_start": 124,
    "address_end": 124,
    "hex_start": "$7C",
    "hex_end": "$7C",
    "label": "POINTB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "124 $7C   POINTB  CMP #$3A     ; carry flag set if > ASCII numeral 9"
  },
  {
    "id": "map-7E",
    "address_start": 126,
    "address_end": 126,
    "hex_start": "$7E",
    "hex_end": "$7E",
    "label": "BCS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "126 $7E           BCS EXIT     ; character is not a numeral--exit"
  },
  {
    "id": "map-80",
    "address_start": 128,
    "address_end": 128,
    "hex_start": "$80",
    "hex_end": "$80",
    "label": "CMP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "128 $80           CMP #$20     ; if it is an ASCI space..."
  },
  {
    "id": "map-82",
    "address_start": 130,
    "address_end": 130,
    "hex_start": "$82",
    "hex_end": "$82",
    "label": "BEQ",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "130 $82           BEQ CHRGET   ; ignore it and get next character"
  },
  {
    "id": "map-84",
    "address_start": 132,
    "address_end": 132,
    "hex_start": "$84",
    "hex_end": "$84",
    "label": "SEC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "132 $84           SEC          ; prepare to subtract"
  },
  {
    "id": "map-85",
    "address_start": 133,
    "address_end": 133,
    "hex_start": "$85",
    "hex_end": "$85",
    "label": "SBC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "133 $85           SBC #$30     ; ASCII 0-9 are between 48-57 ($30-$39)"
  },
  {
    "id": "map-87",
    "address_start": 135,
    "address_end": 135,
    "hex_start": "$87",
    "hex_end": "$87",
    "label": "SEC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "135 $87           SEC          ; prepare to subtract again"
  },
  {
    "id": "map-88",
    "address_start": 136,
    "address_end": 136,
    "hex_start": "$88",
    "hex_end": "$88",
    "label": "SBC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "136 $88           SBC #$D0     ; if < ASCII 0 (57, $39) then carry is set"
  },
  {
    "id": "map-8A",
    "address_start": 138,
    "address_end": 138,
    "hex_start": "$8A",
    "hex_end": "$8A",
    "label": "EXIT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "138 $8A   EXIT    RTS          ; carry is clear only for numeral on return\n\nThe Accumulator (.A register) holds the character that was read on\nexit from the routine.  Status register (.P) bits which can be tested\nfor on exit are:\n\n  Carry Clear if the character was an ASCII digit 0-9.\n  Carry Set, otherwise.\n  Zero Set only if the character was a statement terminator 0 or an\nASCII colon, 58 ($3A).\n  Zero Clear, otherwise.\n\n\nOne wedge insertion technique is to change CHRGET's INC $7A to a JMP\nWEDGE, have your wedge update TXTPTR itself, and then JSR CHRGOT.\nAnother is to change the CMP #$3A at location 124 ($7C), which I have\nlabeled POINTB, to a JMP WEDGE, do your wedge processing, and then\nexit through the ROM version of POINTB, which is located at 48283\n($E3AB).  For more detailed information about wedges, see Programming\nthe PET/CBM, Raeto Collin West, pages 365-68.\n\nWhile the wedge is a good, quick technique for adding new commands, a\nmuch more elegant method exists for accomplishing this task on the\nVIC-20 and 64 withouth slowing BASIC down to the extent that the wedge\ndoes.  See the entries for the BASIC RAM vector area at 768-779\n($300-$30B) for more details."
  },
  {
    "id": "map-8B-8F",
    "address_start": 139,
    "address_end": 143,
    "hex_start": "$8B",
    "hex_end": "$8F",
    "label": "RNDX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "139-143       $8B-$8F        RNDX\nRND Function Seed Value\n\nThis location holds the five-byte floating point value returned by the\nRND function.  It is initially set to a seed value copied from ROM\n(the five bytes are 128, 79, 199, 82, 88--$80, $4F, $C7, $52, $58).\n\nWhen the function RND(X) is called, the numeric value of X does not\naffect the number returned, but its sign does.  If X is equal to 0,\nRND generates a seed value from chip-level hardware timers.  If X is a\npositive number, RND(X) will return the next number in an arithmetic\nsequence.  This sequence continues for such a long time without\nrepeating itself, and gives such an even distribution of numbers, that\nit can be considered random.  If X is negative, the seed value is\nchanged to a number that corresponds to a scrambled floating point\nrepresentation of the number X itself.\n\nGiven a particular seed value, the same pseudorandom series of numbers\nwill always be returned.  This can be handy for debugging purposes,\nbut not where you wish to have truly random numbers.\n\nThe traditional Commodore method of selecting a random seed is by\nusing the expression RND(-TI), mostly because RND(0) didn't function\ncorrectly on early PETs.  While the RND(0) form doesn't really work\nright on the 64 either (see location 57495 ($E097)), the expression\nRND(-RND(0)) may produce a more random seed value."
  },
  {
    "id": "map-90-FF",
    "address_start": 144,
    "address_end": 255,
    "hex_start": "$90",
    "hex_end": "$FF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location_range",
    "text": "Location Range: 144-255 ($90-$FF)\nKernal Work Storage Area\n\nThis is the zero-page storage area for the Kernal.  The user should\ntake into account what effect changing a location here will have on\nthe operation of the Kernal functions before making any such changes.\n\nAt power-on, this range of locations is first filled with zeros, and\nthen initialized from values stored in ROM as needed."
  },
  {
    "id": "map-90",
    "address_start": 144,
    "address_end": 144,
    "hex_start": "$90",
    "hex_end": "$90",
    "label": "STATUS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "144           $90            STATUS\nKernal I/O Status Word (ST)\n\nThe Kernal routines which open I/O channels or perform input/output\nfunctions check and update this location.  The value here is almost\nalways the same as that returned to BASIC by use of the reserved\nvariable ST.  Note that BASIC syntax will not allow an assignment such\nas ST=4.  A table of status codes for cassette and serial devices\nfollows below:\n\nCassette:\nBit 2 (Bit Value of 4) = Short Block\nBit 3 (Bit Value of 8) = Long Block\nBit 4 (Bit Value of 16) = Unrecoverable error (Read), mismatch\nBit 5 (Bit Value of 32) = Checksum error\nBit 6 (Bit Value of 64) = End of file\n\nSerial Devices:\nBit 0 (Bit Value of 1) = Time out (Write)\nBit 1 (Bit Value of 2) = Time out (Read)\nBit 6 (Bit Value of 64) = EOI (End or Identify)\nBit 7 (Bit Value of 128) = Device not present\n\nProbably the most useful bit to test is Bit 6 (end of file).  When\nusing the GET statement to read in individual bytes from a file, the\nstatement IF ST AND 64 will be true if you have got to the end of the\nfile.\n\nFor status codes for the RS-232 device, see the entry for location 663\n($297)."
  },
  {
    "id": "map-91",
    "address_start": 145,
    "address_end": 145,
    "hex_start": "$91",
    "hex_end": "$91",
    "label": "STKEY",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "145           $91            STKEY\nFlag: Was STOP Key Pressed?\n\nThis location is updated every 1/60 second during the execution of the\nIRQ routine that reads the keyboard and updates the jiffy clock.\n\nThe value of the last row of the keyboard matrix is placed here.  That\nrow contains the STOP key, and although this location is used\nprimarily to detect when that key has been pressed, it can also detect\nwhen any of the other keys in that row of the matrix have been\npressed.\n\nIn reading the keyboard matrix, a bit set to 1 means that no key has\nbeen pressed, while a bit reset to 0 indicates that a key is pressed.\nTherefore, the following values indicate the keystrokes detailed\nbelow:"
  },
  {
    "id": "map-7F",
    "address_start": 127,
    "address_end": 127,
    "hex_start": "$7F",
    "hex_end": "$7F",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "127 $7F  = STOP key pressed\n\nVIC owners will notice that the 64's keyboard matrix is very different\nfrom the VIC's.  One of the advantages of this difference is that you\ncan test for the STOP key by following a read of this location with a\nBPL instruction, which will cause a branch to occur anytime that the\nSTOP key is pressed."
  },
  {
    "id": "map-92",
    "address_start": 146,
    "address_end": 146,
    "hex_start": "$92",
    "hex_end": "$92",
    "label": "SVXT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "146           $92            SVXT\nTiming Constant for Tape Reads\n\nThis location is used as an adjustable timing constant for tape reads,\nwhich can be changed to allow for the slight speed variation between\ntapes."
  },
  {
    "id": "map-93",
    "address_start": 147,
    "address_end": 147,
    "hex_start": "$93",
    "hex_end": "$93",
    "label": "VERCK",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "147           $93            VERCK\nFlag for Load Routine: 0=LOAD, 1=VERIFY\n\nThe same Kernal routine can perform either a LOAD or VERIFY, depending\non the value stored in the Accumulator (.A) on entry to the routine.\nThis location is used to determine which operation to perform."
  },
  {
    "id": "map-94",
    "address_start": 148,
    "address_end": 148,
    "hex_start": "$94",
    "hex_end": "$94",
    "label": "C3PO",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "148           $94            C3PO\nFlag: Serial Bus--Output Character Was Buffered\n\nThis location is used by the serial output routines to indicate that a\ncharacter has been placed in the output buffer and is waiting to be\nsent."
  },
  {
    "id": "map-95",
    "address_start": 149,
    "address_end": 149,
    "hex_start": "$95",
    "hex_end": "$95",
    "label": "BSOUR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "149           $95            BSOUR\nBuffered Character for Serial Bus\n\nThis is the character waiting to be sent.  A 255 ($FF) indicates that\nno character is waiting for serial output."
  },
  {
    "id": "map-96",
    "address_start": 150,
    "address_end": 150,
    "hex_start": "$96",
    "hex_end": "$96",
    "label": "SYNO",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "150           $96            SYNO\nCassette Block Synchronization Number"
  },
  {
    "id": "map-97",
    "address_start": 151,
    "address_end": 151,
    "hex_start": "$97",
    "hex_end": "$97",
    "label": "XSAV",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "151           $97            XSAV\nTemporary .X Register Save Area\n\nThis .X register save area is used by the routines that get and put an\nASCII character."
  },
  {
    "id": "map-98",
    "address_start": 152,
    "address_end": 152,
    "hex_start": "$98",
    "hex_end": "$98",
    "label": "LDTND",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "152           $98            LDTND\nNumber of Open I/O Files/Index to the End of File Tables\n\nThe number of currently open I/O files is stored here.  The maximum\nnumber that can be open at one time is ten.  The number stored here is\nused as the index to the end of the tables that hold the file numbers,\ndevice numbers, and secondary address numbers (see locations 601-631\n($259-$277) for more information about these tables).\n\nCLOSE decreases this number and removes entries from the tables\nreferred to above, while OPEN increases it and adds the appropriate\ninformation to the end of the tables.  The Kernal routine CLALL closes\nall files by setting this number to 0, which effectively empties the\ntable."
  },
  {
    "id": "map-99",
    "address_start": 153,
    "address_end": 153,
    "hex_start": "$99",
    "hex_end": "$99",
    "label": "DFLTN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "153           $99            DFLTN\nDefault Input Device (Set to 0 for Keyboard)\n\nThe default value of this location is 0, which designates the keyboard\nas the current input device.  That value can be changed by the Kernal\nroutine CHKIN (61966, $F20E), which uses this location to store the\ndevice number of the device whose file it defines as an input channel.\n\nBASIC calls CHKIN whenever the command INPUT# or GET# is executed, but\nclears the channel after the input operation has been completed."
  },
  {
    "id": "map-9A",
    "address_start": 154,
    "address_end": 154,
    "hex_start": "$9A",
    "hex_end": "$9A",
    "label": "DFLTO",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "154           $9A            DFLTO\nDefault Output (CMD) Device (Set to 3 for the Screen)\n\nThe default value of this location is 3, which designates the screen\nas the current output device.  That value can be changed by the Kernal\nroutine CHKOUT (62032, $F250), which uses this location to store the\ndevice number of the device whose file it defines as an output\nchannel.\n\nBASIC calls CHKOUT whenever the command PRINT# or CMD is executed, but\nclears the channel after the PRINT# operation has been completed."
  },
  {
    "id": "map-9B",
    "address_start": 155,
    "address_end": 155,
    "hex_start": "$9B",
    "hex_end": "$9B",
    "label": "PRTY",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "155           $9B            PRTY\nTape Character Parity\n\nThis location is used to help detect when bits of information have\nbeen lost during transmission of tape data."
  },
  {
    "id": "map-9C",
    "address_start": 156,
    "address_end": 156,
    "hex_start": "$9C",
    "hex_end": "$9C",
    "label": "DPSW",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "156           $9C            DPSW\nFlag: Tape Byte Received\n\nThis location is used as a flag to indicate whether a complete byte of\ntape data has been received, or whether it has only been partially\nreceived."
  },
  {
    "id": "map-9D",
    "address_start": 157,
    "address_end": 157,
    "hex_start": "$9D",
    "hex_end": "$9D",
    "label": "MSGFLG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "157           $9D            MSGFLG\nFlag: Kernal Message Control\n\nThis flag is set by the Kernal routine SETMSG (65048, $FE18), and it\ncontrols whether or not Kernal error messages or control messages will\nbe displayed.\n\nA value of 192 ($C0) here means that both Kernal error and control\nmessages will be displayed.  This will never normally occur when using\nBASIC, which prefers its own plain text error messages over the\nKernal's perfunctory I/O ERROR (number).  The Kernal error messages\nmight be used, however, when you are SAVEing or LOADing with a machine\nlanguage monitor.\n\nA 128 ($80) means that control messages only will be displayed.  Such\nwill be the case when you are in the BASIC direct or immediate mode.\nThese messages include SEARCHING, SAVING, FOUND, etc.\n\nA value of 64 means that Kernal error messages only are on.  A 0 here\nsuppresses the display of all Kernal messages.  This is the value\nplaced here when BASIC enters the program or RUN mode."
  },
  {
    "id": "map-9E",
    "address_start": 158,
    "address_end": 158,
    "hex_start": "$9E",
    "hex_end": "$9E",
    "label": "PTR1",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "158           $9E            PTR1\nTape Pass 1 Error Log Index\n\nThis location is used in setting up an error log of bytes in which\ntransmission parity errors occur the first time that the block is\nreceived (each tape block is sent twice to minimize data loss from\ntransmission error)."
  },
  {
    "id": "map-9F",
    "address_start": 159,
    "address_end": 159,
    "hex_start": "$9F",
    "hex_end": "$9F",
    "label": "PTR2",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "159           $9F            PTR2\nTape Pass 2 Error Log Correction Index\n\nThis location is used in correcting bytes of tape data which were\ntransmitted incorrectly on the first pass."
  },
  {
    "id": "map-A0-A2",
    "address_start": 160,
    "address_end": 162,
    "hex_start": "$A0",
    "hex_end": "$A2",
    "label": "TIME",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "160-162       $A0-$A2        TIME\nSoftware Jiffy Clock\n\nThese three locations are updated 60 times a second, and serve as a\nsoftware clock which counts the number of jiffies (sixtieths of a\nsecond) that have elapsed since the computer was turned on.\n\nThe value of location 162 ($A2) is increased every jiffy (0.1667\nsecond), 161 ($A1) is updated every 256 jiffies (4.2267 seconds), and\n160 ($A0) changes every 65536 jiffies (or every 18.2044 minutes).\nAfter 24 hours, these locations are set back to 0.\n\nThe jiffy clock is used by the BASIC reserved variables TI and TI$.\nThese are not ordinary variables that are stored in the RAM variable\narea, but are functions that call the Kernal routines RDTIM (63197,\n$F6DD), and SETTIM (63204, $F6E4).  Assigning the value of TI or TI$\nto another variable reads these locations, while assigning a given\nvalue to TI$ alters these locations.\n\nTo illustrate the relationship between these locations and TI$, try\nthe following program.  The program sets the jiffy clock to 23 hours,\n50 minutes.  After the program has been running for one minute, all\nthese locations will be reset to 0.\n\n100 TI$=\"235900\"\n110 PRINT TI$,PEEK(160),PEEK(161),PEEK(162)\n120 GOTO 110\n\nSince updating is done by the IRQ interrupt that reads the keyboard,\nanything which affects the operation of that interrupt routine will\nalso interfere with this clock.  A typical example is tape I/O\noperations, which steal the IRQ vector for their own use, and restore\nit afterwards.  Obviously, user routines which redirect the IRQ and do\nnot send it back to the normal routine will upset software clock\noperation as well."
  },
  {
    "id": "map-A3-A4",
    "address_start": 163,
    "address_end": 164,
    "hex_start": "$A3",
    "hex_end": "$A4",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "163-164       $A3-$A4\nTemporary Data Storage Area\n\nThese locations are used temporarily by the tape and serial I/O\nroutines."
  },
  {
    "id": "map-A5",
    "address_start": 165,
    "address_end": 165,
    "hex_start": "$A5",
    "hex_end": "$A5",
    "label": "CNTDN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "165           $A5            CNTDN\nCassette Synchronization Character Countdown\n\nUsed to count down the number of synchronization characters that are\nsent before the actual data in a tape block."
  },
  {
    "id": "map-A6",
    "address_start": 166,
    "address_end": 166,
    "hex_start": "$A6",
    "hex_end": "$A6",
    "label": "BUFPNT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "166           $A6            BUFPNT\nCount of Characters in Tape I/O Buffer\n\nThis location is used to count the number of bytes that have been read\nin or written to the tape buffer.  Since on a tape write, no data is\nsent until the 192 byte buffer is full, you can force output of the\nbuffer with the statement POKE 166,191."
  },
  {
    "id": "map-A7",
    "address_start": 167,
    "address_end": 167,
    "hex_start": "$A7",
    "hex_end": "$A7",
    "label": "INBIT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "167           $A7            INBIT\nRS-232 Input Bits/Cassette Temporary Storage Area\n\nThis location is used to temporarily store each bit of serial data\nthat is received, as well as for miscellaneous tasks by tape I/O."
  },
  {
    "id": "map-A8",
    "address_start": 168,
    "address_end": 168,
    "hex_start": "$A8",
    "hex_end": "$A8",
    "label": "BITCI",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "168           $A8            BITCI\nRS-232 Input Bit Count/Cassete Temporary Storage\n\nThis location is used to count the number of bits of serial data that\nhas been received.  This is necessary so that the serial routines will\nknow when a full word has been received.  It is also used as an error\nflag during tape loads."
  },
  {
    "id": "map-A9",
    "address_start": 169,
    "address_end": 169,
    "hex_start": "$A9",
    "hex_end": "$A9",
    "label": "RINONE",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "169           $A9            RINONE\nRS-232 Flag: Check for Start Bit\n\nThis flag is used when checking for a start bit.  A 144 ($90) here\nindicates that no start bit was received, while a 0 means that a start\nbit was received."
  },
  {
    "id": "map-AA",
    "address_start": 170,
    "address_end": 170,
    "hex_start": "$AA",
    "hex_end": "$AA",
    "label": "RIDATA",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "170           $AA            RIDATA\nRS-232 Input Byte Buffer/Cassette Temporary Storage\n\nSerial routines use this area to reassemble the bits received into a\nbyte that will be stored in the receiving buffer pointer to by 247\n($F7).  Tape routines use this as a flag to help determine whether a\nreceived character should be treated as data or as a synchronization\ncharacter."
  },
  {
    "id": "map-AB",
    "address_start": 171,
    "address_end": 171,
    "hex_start": "$AB",
    "hex_end": "$AB",
    "label": "RIPRTY",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "171           $AB            RIPRTY\nRS-232 Input Parity/Cassete Leader Counter\n\nThis location is used to help detect if data was lost during RS-232\ntransmission, or if a tape leader is completed."
  },
  {
    "id": "map-AC-AD",
    "address_start": 172,
    "address_end": 173,
    "hex_start": "$AC",
    "hex_end": "$AD",
    "label": "SAL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "172-173       $AC-$AD        SAL\nPointer to the Starting Address of a Load/Screen Scrolling\n\nThe pointer to the start of the RAM area to be SAVEd or LOADed at 193\n($C1) is copied here.  This pointer is used as a working version, to\nbe increased as the data is received or transmitted.  At the end of\nthe operation, the initial value is restored here.  Screen management\nroutines temporarily use this as a work pointer."
  },
  {
    "id": "map-AE-AF",
    "address_start": 174,
    "address_end": 175,
    "hex_start": "$AE",
    "hex_end": "$AF",
    "label": "EAL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "174-175       $AE-$AF        EAL\nPointer to Ending Address of Load (End of Program)\n\nThis location is set by the Kernal routine SAVE to point to the ending\naddress for SAVE, LOAD, or VERIFY."
  },
  {
    "id": "map-B0-B1",
    "address_start": 176,
    "address_end": 177,
    "hex_start": "$B0",
    "hex_end": "$B1",
    "label": "CMP0",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "176-177       $B0-$B1        CMP0\nTape Timing\n\nLocation 176 ($B0) is used to determine the value of the adjustable\ntiming constant at 146 ($92).  Location 199 is also used in the timing\nof tape reads."
  },
  {
    "id": "map-B2-B3",
    "address_start": 178,
    "address_end": 179,
    "hex_start": "$B2",
    "hex_end": "$B3",
    "label": "TAPE1",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "178-179       $B2-$B3        TAPE1\nPointer: Start of Tape Buffer\n\nOn power-on, this pointer is set to the address of the cassette buffer\n(828, $33C).  This pointer must contain an address greater than or\nequal to 512 ($200), or an ILLEGAL DEVICE NUMBER error will be sent\nwhen tape I/O is tried."
  },
  {
    "id": "map-B4",
    "address_start": 180,
    "address_end": 180,
    "hex_start": "$B4",
    "hex_end": "$B4",
    "label": "BITTS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "180           $B4            BITTS\nRS-232 Output Bit Count/Cassette Temporary Storage\n\nRS-232 routines use this to count the number of bits transmitted, and\nfor parity and stop bit manipulation.  Tape load routines use this\nlocation to flag when they are ready to receive data bytes."
  },
  {
    "id": "map-B5",
    "address_start": 181,
    "address_end": 181,
    "hex_start": "$B5",
    "hex_end": "$B5",
    "label": "NXTBIT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "181           $B5            NXTBIT\nRS-232 Next Bit to Send/Tape EOT Flag\n\nThis location is used by the RS-232 routines to hold the next bit to\nbe sent, and by the tape routines to indicate what part of a block the\nread routine is currently reading."
  },
  {
    "id": "map-B6",
    "address_start": 182,
    "address_end": 182,
    "hex_start": "$B6",
    "hex_end": "$B6",
    "label": "RODATA",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "182           $B6            RODATA\nRS-232 Output Byte Buffer\n\nRS-232 routines use this area to disassemble each byte to be sent from\nthe transmission buffer pointed to by 249 ($F9)."
  },
  {
    "id": "map-B7",
    "address_start": 183,
    "address_end": 183,
    "hex_start": "$B7",
    "hex_end": "$B7",
    "label": "FNLEN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "183           $B7            FNLEN\nLength of Current Filename\n\nThis location holds the number of characters in the current filename.\nDisk filenames may have from 1 to 16 characters, while tape filenames\nrange from 0 to 187 characters in length.\n\nIf the tape name is longer than 16 characters, the excess will be\ntruncated by the SEARCHING and FOUND messages, but will still be\npresent on the tape.  This means that machine language programs meant\nto run in the cassette buffer may be saved as tape filenames.\n\nA disk file is always referred to be a name, whether full or generic\n(containing the wildcard characters * or ?).  This location will\nalways be greater than 0 if the current file is a disk file.  Tape\nLOAD, SAVE, and VERIFY operations do not require that a name be\nspecified, and this location can therefore contain a 0.  If this is\nthe case, the contents of the pointer to the filename at 187 will be\nirrelevant.\n\nAn RS-232 OPEN command may specify a filename of up to four\ncharacters.  These characters are copied to locations 659-662\n($293-$296), and determine baud rate, word length, and parity."
  },
  {
    "id": "map-B8",
    "address_start": 184,
    "address_end": 184,
    "hex_start": "$B8",
    "hex_end": "$B8",
    "label": "LA",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "184           $B8            LA\nCurrent Logical File Number\n\nThis location holds the logical file number of the device currently\nbeing used.  A maximum of five disk files, and ten files in total, may\nbe open at any one time.\n\nFile numbers range from 1 to 255 (a 0 is used to indicate system\ndefaults).  When printing to a device with a file number greater than\n127, an ASCII linefeed character will be sent following each carriage\nreturn, which is useful for devices like serial printers that require\nlinefeeds in addition to carriage returns.\n\nThe BASIC OPEN command calls the Kernal OPEN routine, which sets the\nvalue of this location.  In the BASIC statement OPEN 4,8,15, the\nlogical file number corresponds to the first parameter 4."
  },
  {
    "id": "map-B9",
    "address_start": 185,
    "address_end": 185,
    "hex_start": "$B9",
    "hex_end": "$B9",
    "label": "SA",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "185           $B9            SA\nCurrent Secondary Address\n\nThis location holds the secondary address of the device currently\nbeing used.  The range of valid secondary address numbers is 0 through\n31 for serial devices, and 0 through 127 for other devices.\n\nSecondary device numbers mean something different to each device that\nthey are used with.  The keyboard and screen devices ignore the\nsecondary address completely.  But any device which can have more than\none file open at the same time, such as the disk drive, distinguishes\nbetween these files by using the secondary address when opening a disk\nfile.  Secondary address numbers 0, 1, and 15-31 have a special\nsignificance to the disk drive, and therefore device numbers 2-14 only\nshould be used as secondary addresses when opening a disk file.\n\nOPENing a disk file with a secondary address of 15 enables the user to\ncommunicate with the Disk Operating System through that channel.  A\nLOAD command which specifies a secondary address of 0 (for example,\nLOAD \"AT BASIC\",8,0) results in the program being loaded not to the\naddress specified on the file as the starting address, but rather to\nthe address pointed to by the start of BASIC pointer (43, $2B).\n\nA LOAD with a secondary address of 1 (for example, LOAD \"HERE\",8,1)\nresults in the contents of the file being loaded to the address\nspecified in the file.  A disk file that has been LOADed using a\nsecondary address of 1 can be successfully SAVEd in the same manner\n(SAVE \"DOS 5.1\",8,1).\n\nLOADs and SAVEs that do not specify a secondary address will default\nto a secondary address of 0.\n\nWhen OPENing a Datasette recorder file, a secondary address of 0\nsignifies that the file will be read, while a secondary address of 1\nsignifies that the file will be written to.  A value of 2 can be added\nto indicate that an End of Tape marker should be written as well.\nThis marker tells the Datasette not to search past it for any more\nfiles on the tape, though more files can be written to the tape if\ndesired.\n\nAs with the disk drive, the LOAD and SAVE commands use secondary\naddresses of 0 and 1 respectively to indicate whether the operation\nshould be relocating or nonrelocating.\n\nWhen the 1515 or 1525 Printer is opened with a secondary address of 7,\nthe uppercase/lowercase character set is used.  If it is openend with\na secondary address of 0, or without a secondary address, the\nuppercase/graphics character set will be used."
  },
  {
    "id": "map-BA",
    "address_start": 186,
    "address_end": 186,
    "hex_start": "$BA",
    "hex_end": "$BA",
    "label": "FA",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "186           $BA            FA\nCurrent Device Number\n\nThis location holds the number of the device that is currently being\nused.  Device number assignments are as follows:\n\n0    = Keyboard\n1    = Datasette Recorder\n2    = RS-232/User Port\n3    = Screen\n4-5  = Printer\n8-11 = Disk"
  },
  {
    "id": "map-BB-BC",
    "address_start": 187,
    "address_end": 188,
    "hex_start": "$BB",
    "hex_end": "$BC",
    "label": "FNADR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "187-188       $BB-$BC        FNADR\nPointer: Current Filename\n\nThis location holds a pointer to the address of the current filename.\nIf an operation which OPENs a tape file does not specify a filename,\nthis pointer is not used.\n\nWhen a disk filename contains a shifted space character, the remainder\nof the name will appear outside the quotes in the directory, and may\nbe used for comments.  For example, if you SAVE \"ML[shifted\nspace]SYS828\", the directory entry will read \"ML\"SYS 828.  You may\nreference the program either by the portion of the name that appears\nwithin quotes, or by the full name, including the shifted space.  A\nprogram appearing later in the directory as \"ML\"SYS 900 would not be\nfound just by reference to \"ML\", however.\n\nA filename of up to four characters may be used when opening the\nRS-232 device.  These four characters will be copied to 659-662\n($293-$296), where they are used to control such parameters as baud\nrate, parity, and word length."
  },
  {
    "id": "map-BD",
    "address_start": 189,
    "address_end": 189,
    "hex_start": "$BD",
    "hex_end": "$BD",
    "label": "ROPRTY",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "189           $BD            ROPRTY\nRS-232 Output Parity/Cassette Temporary Storage\n\nThis location is used by the RS-232 routines as an output parity work\nbyte, and by the tape as temporary storage for the current character\nbeing read or sent."
  },
  {
    "id": "map-BE",
    "address_start": 190,
    "address_end": 190,
    "hex_start": "$BE",
    "hex_end": "$BE",
    "label": "FSBLK",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "190           $BE            FSBLK\nCassette Read/Write Block Count\n\nUsed by the tape routines to count the number of copies of a data\nblock remaining to be read or written."
  },
  {
    "id": "map-BF",
    "address_start": 191,
    "address_end": 191,
    "hex_start": "$BF",
    "hex_end": "$BF",
    "label": "MYCH",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "191           $BF            MYCH\nTape Input Byte Buffer\n\nThis is used by the tape routines as a work area in which incoming\ncharacters area assembled."
  },
  {
    "id": "map-C0",
    "address_start": 192,
    "address_end": 192,
    "hex_start": "$C0",
    "hex_end": "$C0",
    "label": "CAS1",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "192           $C0            CAS1\nTape Motor Interlock\n\nThis location is maintained by the IRQ interrupt routine that scans\nthe keyboard.  Whenever a button is pressed on the recorder, this\nlocation is checked.  If it contains a 0, the motor is turned on by\nsetting Bit 5 of location 1 to 0.  When the button is let up, the tape\nmotor is turned off, and this location is set to 0.\n\nSince the interrupt routine is executed 60 times per second, you will\nnot be able to keep the motor bit set to keep the motor on if no\nbuttons are pushed.  Likewise, if you try to turn the motor off when a\nbutton is pressed and this location is set to 0, the interrupt routine\nwill turn it back on.\n\nTo control the motor via software, you must set this location to a\nnonzero value after one of the buttons on the recorder has been\npressed."
  },
  {
    "id": "map-C1-C2",
    "address_start": 193,
    "address_end": 194,
    "hex_start": "$C1",
    "hex_end": "$C2",
    "label": "STAL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "193-194       $C1-$C2        STAL\nI/O Start Address\n\nThis location points to the beginning address of the area in RAM which\nis currently being LOADed or SAVEd.  For tape I/O, it will point to\nthe cassette buffer, and the rest of the data is LOADed or SAVEd\ndirectly to or from RAM.  This location points to the beginning\naddress of the area of RAM to be used for the blocks of data that come\nafter the initial header."
  },
  {
    "id": "map-C5",
    "address_start": 197,
    "address_end": 197,
    "hex_start": "$C5",
    "hex_end": "$C5",
    "label": "LSTX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "197           $C5            LSTX\nMatrix Coordinate of Last Key Pressed, 64=None Pressed\n\nDuring every normal IRQ interrput this location is set with the value\nof the last keypress, to be used in keyboard debouncing.  The\nOperating System can check if the current keypress is the same as the\nlast one, and will not repeat the character if it is.\n\nThe value returned here is based on the keyboard matrix values as set\nforth in the explanation of location 56320 ($DC00).  The values\nreturned for each key pressed are shown at the entry for location 203\n($CB)."
  },
  {
    "id": "map-C6",
    "address_start": 198,
    "address_end": 198,
    "hex_start": "$C6",
    "hex_end": "$C6",
    "label": "NDX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "198           $C6            NDX\nNumber of Characters in Keyboard Buffer (Queue)\n\nThe value here indicates the number of charracters waiting in the\nkeyboard buffer at 631 ($277).  The maximum number of characters in\nthe keyboard buffer at any one time is determined by the value in\nlocation 649 ($289), which defaults to 10.\n\nIf INPUT or GET is executed while there are already characters in the\nbuffer, those characters will be read as part of the data stream.  You\ncan prevent this by POKEing a 0 to this location before those\noperations, which will always cause any character in the buffer to be\nignored.  This technique can be handy when using the joystick in\nController Port #1, which sometimes causes fake keypresses to be\nregistered, placing unwanted characters in the keyboard buffer.\n\nNot only is this location handy for taking unwanted characters out of\nthe keyboard buffer, but it can also be used to put desired characters\ninto the buffer, and thus to program the keyboard buffer.  This\ntechnique (dynamic keyboard) allows you to simulate keyboard input in\ndirect mode from a program.\n\nThe dynamic keyboard technique is an extremely useful one, as it\nenables you to add, delete, or modify program lines while the program\nis running.  The basic scheme is to POKE the PETASCII character values\nthat you wish to be printed (including cursor control characters and\ncarriage returns) into the buffer.  Then, when an END statement is\nexecuted, the characters in the buffer will be printed, and entered by\nthe carriage return.\n\nThis technique can help with the problem of trying to use data\nseparation and terminator characters with INPUT statements.  If you\ntry to INPUT a string that has a comma or colon, the INPUT will read\nonly up to that character and issue an EXTRA IGNORED error message.\nYou can avoid this by entering the input string in quotes, but this\nplaces on the user the burder of remembering the quote marks.  One\nsolution is to use the statements:\n\nPOKE 198,3:POKE 631,34: POKE 632,34: POKE 633,20\n\nbefore the input.  This will force two quote marks and a delete into\nthe buffer.  The first quote mark allows the comma or colon to be\nINPUT, the second is used to get the editor out of quote mode, and the\ndelete removes that second quote.\n\nFor more specific information and programming examples, see the\ndescription of location 631 ($277), the keyboard buffer."
  },
  {
    "id": "map-C7",
    "address_start": 199,
    "address_end": 199,
    "hex_start": "$C7",
    "hex_end": "$C7",
    "label": "RVS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "199           $C7            RVS\nFlag: Print Reverse Characters? 0=No\n\nWhen the [CTRL][RVS-ON] characters are printer (CHR$(18)), this flag\nis set to 18 ($12), and the print routines will add 128 ($80) to the\nscreen code of each character which is printed, so that the caracter\nwill appear on the screen with its colors reversed.\n\nPOKEing this location directly with a nonzero number will achieve the\nsame results.  You should remember, however, that the contents of this\nlocation are returned to 0 not only upon entry of a [CTRL][RVS-OFF]\ncharacter (CHR$(146)), but also at every carriage return.  When this\nhappens, characters printed thereafter appear with the normal\ncomination of colors."
  },
  {
    "id": "map-C8",
    "address_start": 200,
    "address_end": 200,
    "hex_start": "$C8",
    "hex_end": "$C8",
    "label": "INDX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "200           $C8            INDX\nPointer: End of Logical Line for Input\n\nThis pointer indicates the column number of the last nonblank\ncharacter on the logical line that is to be input.  Since a logical\nline can be up to 80 characters long, this number can range from 0-79."
  },
  {
    "id": "map-C9-CA",
    "address_start": 201,
    "address_end": 202,
    "hex_start": "$C9",
    "hex_end": "$CA",
    "label": "LXSP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "201-202       $C9-$CA        LXSP\nCursor X,Y Position at Start of Input\n\nThese locations keep track of the logical line that the cursor is on,\nand its column position on that logical line (in line, column format).\n\nEach logical line may contain one or two 40-column physical lines.\nThus there may be as many as 25 logical lines, or as few as 13 at any\none time.  Therefore, the logical line number might be anywhere from\n1-25.  Depending on the length of the logical line, the cursor column\nmay be from 1-40 or 1-80.\n\nFor a more detailed exaplanation of logical lines, see the description\nof the screen line link talbe, 217 ($D9)."
  },
  {
    "id": "map-CB",
    "address_start": 203,
    "address_end": 203,
    "hex_start": "$CB",
    "hex_end": "$CB",
    "label": "SFDX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "203           $CB            SFDX\nMatrix Coordinate of Current Key Pressed\n\nThe keyscan interrupt routine uses this location to indicate which key\nis currently being pressed.  The value here is then used as an index\ninto the appropriate keyboard table to determine which character to\nprint when a key is struck.\n\nThe correspondence between the key pressed and the number stored here\nis as follows:\n\n0  = INST/DEL                34 = J\n1  = RETURN                  35 = 0\n2  = CRSR RIGHT              36 = M\n3  = F7                      37 = K\n4  = F1                      38 = O\n5  = F3                      39 = N\n6  = F5                      40 = +\n7  = CRSR DOWN               41 = P\n8  = 3                       42 = L\n9  = W                       43 = -\n10 = A                       44 = .\n11 = 4                       45 = :\n12 = Z                       46 = @\n13 = S                       47 = ,\n14 = E                       48 = LIRA (BRITISH POUND SIGN)\n15 = NOT USED                49 = *\n  (WOULD BE LEFT SHIFT)      50 = ;\n16 = 5                       51 = CLR/HOME\n17 = R                       52 = NOT USED\n18 = D                         (WOULD BE RIGHT SHIFT)\n19 = 6                       53 = =\n20 = C                       54 = UP ARROW\n21 = F                         (EXPONENTATION SIGN)\n22 = T                       55 = /\n23 = X                       56 = 1\n24 = 7                       57 = LEFT ARROW\n25 = Y                       58 = NOT USED\n26 = G                         (WOULD BE CTRL)\n27 = 8                       59 = 2\n28 = B                       60 = SPACE BAR\n29 = H                       61 = NOT USED\n30 = U                         (WOULD BE COMMODORE LOGO)\n31 = V                       62 = Q\n32 = 9                       63 = RUN/STOP\n33 = I                       64 = NO KEY PRESSED\n\nThe RESTORE key is not accounted for, because it is not part of the\nnormal keyboard matrix.  Instead, it is connected directly to the\nmicroprocessor NMI line, and causes an NMI interrupt whenever it is\npressed."
  },
  {
    "id": "map-CC",
    "address_start": 204,
    "address_end": 204,
    "hex_start": "$CC",
    "hex_end": "$CC",
    "label": "BLNSW",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "204           $CC            BLNSW\nCursor Blink Enable: 0=Flash Cursor\n\nWhen this flag is set to a nonzero value, it indicates to the routine\nthat normally flashes the cursor not to do so.  The cursor blink is\nturned off when there are characters in the keyboard buffer, or when\nthe program is running.\n\nYou can use this location to turn the cursor on during a program (for\na series of GET operations, for example, to show the user that input\nis expected) by using the statement POKE 204,0."
  },
  {
    "id": "map-CD",
    "address_start": 205,
    "address_end": 205,
    "hex_start": "$CD",
    "hex_end": "$CD",
    "label": "BLNCT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "205           $CD            BLNCT\nTimer: Countdown to Blink Cursor\n\nThe interrupt routine that blinks the cursor uses this location to\ntell when it's time for a blink.  First the number 20 is put here, and\nevery jiffy (1/60 second) the value here is decreased by one, until it\nreaches zero.  Then the cursor is blinked, the number 20 is put back\nhere, and the cycle starts all over again.  Thus, under normal\ncircumstances, the cursor blinks three times per second."
  },
  {
    "id": "map-CE",
    "address_start": 206,
    "address_end": 206,
    "hex_start": "$CE",
    "hex_end": "$CE",
    "label": "GDBLN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "206           $CE            GDBLN\nCharacter Under Cursor\n\nThe cursor is formed by printing the inverse of the character that\noccupies the cursor position.  If that characters is the letter A, for\nexample, the flashing cursor merely alternates between printing an A\nand a reverse-A.  This location keeps track of the normal screen code\nof the character that is located at the cursor position, so that it\nmay be restored when the cursor moves on."
  },
  {
    "id": "map-CF",
    "address_start": 207,
    "address_end": 207,
    "hex_start": "$CF",
    "hex_end": "$CF",
    "label": "BLNON",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "207           $CF            BLNON\nFlag: Was Last Curson Blink on or off?\n\nThis location keeps track of whether, during the current cursor blink,\nthe character under the cursor was reversed, or was restored to\nnormal.  This location will contain a 0 if the character is reversed,\nand a 1 if the character is restored to its nonreversed status."
  },
  {
    "id": "map-D0",
    "address_start": 208,
    "address_end": 208,
    "hex_start": "$D0",
    "hex_end": "$D0",
    "label": "CRSW",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "208           $D0            CRSW\nFlag: Input from Keyboard or Screen\n\nThis flag is used by the Kernal CHRIN (61783, $F157) routine to\nindicate whether input is available from the screen (3), or whether a\nnew line should be obtained from the keyboard (0)."
  },
  {
    "id": "map-D1-D2",
    "address_start": 209,
    "address_end": 210,
    "hex_start": "$D1",
    "hex_end": "$D2",
    "label": "PNT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "209-210       $D1-$D2        PNT\nPointer to the Address of the Current Screen Line\n\nThis location points to the address in screen RAM of the first column\nof the logical line upon which the cursor is currently positioned."
  },
  {
    "id": "map-D3",
    "address_start": 211,
    "address_end": 211,
    "hex_start": "$D3",
    "hex_end": "$D3",
    "label": "PNTR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "211           $D3            PNTR\nCursor Column on Current Line\n\nThe number contained here is the cursor column position within the\nlogical line pointed to by 209 ($D1).  Since a logical line can\ncontain up to two physical lines, this value may be from 0 to 79 (the\nnumber here is the value returned by the POS function)."
  },
  {
    "id": "map-D4",
    "address_start": 212,
    "address_end": 212,
    "hex_start": "$D4",
    "hex_end": "$D4",
    "label": "QTSW",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "212           $D4            QTSW\nFlag: Editor in Quote Mode? 0=No\n\nA nonzero value in this location indicates that the editor is in quote\nmode.  Quote mode is toggled every time that you type in a quotation\nmark on a given line--the first quote mark turns it on, the second\nturns it off, the third turns it back on, etc.\n\nIf the editor is in this mode when a cursor control character or other\nnonprinting character is entered, a printed equivalent will appear on\nthe screen instead of the cursor movement or other control operation\ntaking place.  Instead, that action is deferred until the string is\nsent to the string by a PRINT statement, at which time the cursor\nmovement or other control operation will take place.\n\nThe exception to this rule is the DELETE key, which will function\nnormally within quote mode.  The only way to print a character which\nis equivalent to the DELETE key is by entering insert mode (see\nloctaion 216 ($D8)).  Quote mode may be exited by printing a closing\nquote, or by hitting the RETURN or SHIFT-RETURN keys.\n\nSometimes, it would be handy to be able to escape from quote mode or\ninsert mode without skipping to a new line.  The machine language\nprogram below hooks into the keyscan interrupt routine, and allows you\nto escape quote mode by changing this flag to 0 when you press the f1\nkey:\n\n10 FOR I=850 TO I+41:READ A:POKE I,A:NEXT\n20 PRINTCHR$(147)\"PRESS F1 KEY TO ESCAPE QUOTE MODE\"\n30 PRINT\"TO RESTART AFTER RESTORE ONLY, SYS 850\":SYS850:NEW\n40 DATA  173 , 143 , 2 , 141 , 46 , 3 , 173 , 144 , 2 , 141\n50 DATA 47 , 3 , 120 , 169 , 107 , 141 , 143 , 2 , 169 , 3\n60 DATA 141 , 144 , 2 , 88 , 96 , 165 , 203 , 201 , 4 , 208\n70 DATA 8 , 169 , 0 , 133 , 212 , 133 , 216 , 133 , 199 , 108 , 46 , 3"
  },
  {
    "id": "map-D5",
    "address_start": 213,
    "address_end": 213,
    "hex_start": "$D5",
    "hex_end": "$D5",
    "label": "LNMX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "213           $D5            LNMX\nMaximum Length of Physical Screen Line\n\nThe line editor uses this location when the end of a line has been\nreached to determine whether another physical line can be added to the\ncurrent logical line, or if a new logical line must be started."
  },
  {
    "id": "map-D6",
    "address_start": 214,
    "address_end": 214,
    "hex_start": "$D6",
    "hex_end": "$D6",
    "label": "TBLX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "214           $D6            TBLX\nCurrent Cursor Physical Line Number\n\nThis location contains the current physical screen line position of\nthe cursor (0-24).  It can be used in a fashion to move the cursor\nvertically, by POKEing the target screen line (1-25) minus 1 here,\nfollowed by a PRINT command.  For example,\n\nPOKE 214,9:PRINT:PRINT \"WE'RE ON LINE ELEVEN\"\n\nprints the message on line 11.  The first PRINT statement allows the\nsystem to update the other screen editor variables so that they will\nalso show the new line.  The cursor can also be set or read using the\nKernal PLOT routine (58634, $E50A) as explained in the entry from\nlocations 780-783 ($30C-$30F)."
  },
  {
    "id": "map-D7",
    "address_start": 215,
    "address_end": 215,
    "hex_start": "$D7",
    "hex_end": "$D7",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "215           $D7\nTemporary Storage Area for ASCII Value of Last Character Printed\n\nThe ASCII value of the last character printed to the screen is held\nhere temporarily."
  },
  {
    "id": "map-D8",
    "address_start": 216,
    "address_end": 216,
    "hex_start": "$D8",
    "hex_end": "$D8",
    "label": "INSRT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "216           $D8            INSRT\nFlag: Insert Mode (Any Number Greater Than 0 Is the Number of Inserts)\n\nWhen the INST key is pressed, the screen editor shifts the line to the\nright, allocates another physical line to the logical line if\nnecessary (and possible), updates the screen line length in 213 ($D5),\nand adjusts the screen line link table at 217 ($D9).  This location is\nused to keep track of the number of spaces that has been opened up in\nthis way.\n\nUntil the spaces that have been opened up are filled, the editor acts\nas if in quote mode (see location 212 ($D4), the quote mode flag).\nThis means that cursor control characters that are normally\nnonprinting will leave a printed equivalent on the screen when\nentered, instead of having their normal effect on cursor movement,\netc.  The only difference between insert and quote mode is that the\nDELETE key will leave a printed equivalent in insert mode, while the\nINST key will insert spaces as normal."
  },
  {
    "id": "map-D9-F2",
    "address_start": 217,
    "address_end": 242,
    "hex_start": "$D9",
    "hex_end": "$F2",
    "label": "LDTB1",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "217-242       $D9-$F2        LDTB1\nScreen Line Link Table/Editor Temporary Storage\n\nThis table contains 25 entries, one for each row of the screen\ndisplay.  Each entry has two functions.  Bits 0-3 indicate on which of\nthe four pages of screen memory  the first byte of memory for that row\nis located.  This is used in calculating the pointer to the starting\naddress of a screen line at 209 ($D1).\n\nWhile earlier PETs used one table for the low bytes of screen rows and\nanother for the high bytes, this is not possible on the 64, where\nscreen memory is not fixed in any one spot.  Therefore, the Operating\nSystem uses a table of low bytes at 60656 ($ECF0), but calculates the\nhigh byte by adding the value of the starting page of screen memory\nheld in 648 ($288) to the displacement page held here.\n\nThe other function of this table is to establish the makeup of logical\nlines on the screen.  While each screen line is only 40 characters\nlong, BASIC allows the entry of program lines that contain up to 80\ncharacters.  Therefore, some method must be used to determine which\npairs of physical lines are linked into a longer logical line, so that\nthis longer logical line may be edited as a unit.\n\nThe high bit of each byte here is used as a flag by the screen editor.\nThat bit is set (leaving the value of the byte over 128 ($80)) when a\nline is the first or only physical line in a logical line.  The high\nbit is reset to 0 only when a line is the second half of a logical\nline."
  },
  {
    "id": "map-F3-F4",
    "address_start": 243,
    "address_end": 244,
    "hex_start": "$F3",
    "hex_end": "$F4",
    "label": "USER",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "243-244       $F3-$F4        USER\nPointer to the Address of the Current Screen Color RAM Location\n\nThis poitner is synchronized with the pointer to the address of the\nfirst byte of screen RAM for the current line kept in location 209\n($D1).  It holds the address of the first byte of color RAM for the\ncorresponding screen line."
  },
  {
    "id": "map-F5-F6",
    "address_start": 245,
    "address_end": 246,
    "hex_start": "$F5",
    "hex_end": "$F6",
    "label": "KEYTAB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "245-246       $F5-$F6        KEYTAB\nVector: Keyboard Decode Table\n\nKEYTAB points to the address of the keyboard matrix lookup table\ncurrently being used.  Although there are only 64 keys on the keyboard\nmatrix, each key can be used to print up to four different characters,\ndepending on whether it is struck by itself or in combination with the\nSHIFT, CTRL, or Commodore logo keys.\n\nThe tables pointed to y this address hold the ASCII value of each of\nthe 64 keys for one of these possible combinations of keypresses.\nWhen it comes time to print the character, the table that is used\ndetermines which character is printed.\n\nThe addresses of the four tables are:\n\n60289 ($EB81) = default uppercase/graphics characters (unshifted)\n60354 ($EBC2) = shifted characters\n60419 ($EC03) = Commodore logo key characters\n60536 ($EC78) = CTRL characters\n\nThe concept of the keyboard matrix tables should not be confused with\nchanging the character sets from uppercase/graphics to\nupper/lowercase.  The former involves determining what character is to\nbe placed into screen memory, while the latter involves determining\nwhich character data table is to be used to decode the screen memory\ninto individual dots for the display of characters on the screen.\nThat character base is determined by location 53272 ($D018) of the\nVIC-II chip."
  },
  {
    "id": "map-F7-F8",
    "address_start": 247,
    "address_end": 248,
    "hex_start": "$F7",
    "hex_end": "$F8",
    "label": "RIBUF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "247-248       $F7-$F8        RIBUF\nPointer: RS-232 Input Buffer\n\nWhen device number 2 (the RS-232 channel) is opened, two buffers of\n256 bytes each are created at the top of memory.  This location points\nto the address of the one which is used to store characters as they\nare received.  A BASIC program should always OPEN device 2 before\nassigning any variables to avoid the consequences of overwriting\nvariables which were previously located at the top of memory, as BASIC\nexecutes a CLR after opening this device."
  },
  {
    "id": "map-F9-FA",
    "address_start": 249,
    "address_end": 250,
    "hex_start": "$F9",
    "hex_end": "$FA",
    "label": "ROBUF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "249-250       $F9-$FA        ROBUF\nPointer: RS-232 Output Buffer\n\nThis location points to the address of the 256-byte output buffer\nwhich is used for transmitting data to RS-232 devices (device number\n2)l"
  },
  {
    "id": "map-FB-FE",
    "address_start": 251,
    "address_end": 254,
    "hex_start": "$FB",
    "hex_end": "$FE",
    "label": "FREEZP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "251-254       $FB-$FE        FREEZP\nFour Free Bytes of Zero Page for User Programs\n\nThese locations were specifically set aside for user-written ML\nroutines that require zero-page addressing.  While other zero-page\nlocations can be used on a noninterference basis, it is guaranteed\nthat BASIC will not alter these locations."
  },
  {
    "id": "map-FF",
    "address_start": 255,
    "address_end": 255,
    "hex_start": "$FF",
    "hex_end": "$FF",
    "label": "BASZPT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 1::",
    "type": "location",
    "text": "255           $FF            BASZPT\nBASIC Temporary Data for Floating Point to ASCII Conversion\n\nThis location is used for temporary storage in the process of\nconverting floating point numbers to ASCII characters..\n\n\n:::::::::::::\n::         ::\n:: Page 1  ::\n:::::::::::::"
  },
  {
    "id": "map-100-1FF",
    "address_start": 256,
    "address_end": 511,
    "hex_start": "$100",
    "hex_end": "$1FF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 2::",
    "type": "location",
    "text": "256-511       $100-$1FF\nMicroprocessor Stack Area\n\nLocations 256-511 are reserved for the 6510 microprocessor hardware\nstack.  The organization of this temporary storage area has often been\ncompared to that of a push-down stack of trays at a cafeteria.  The\nfirst number placed on the stack goes to the bottom, and subsequent\nentries are placed on top of it.  Then you pull a number off the\nstack, you come up with the last number that was pushed on (such a\nstack is called a Last In, First Out, or LIFO stack).\n\nThe stack is controlled by one of the microprocessor registers called\nthe Stack Pointer, which keeps track of the last stack location used.\nThe first number placed on the stack goes to location 511 ($1FF), and\nsubsequent entries are built downward toward 256 ($100).  If more than\n256 numbers are pushed onto the stack, the Stack Pointer will start\ncounting from 0 again, and an overflow error will result.  Likewise,\nif you try to pull more items off the stack than have been pushed on,\nan underflow error will result.  Most often, such errors will cause\nthe system to go haywire, and nothing will operate until you turn the\npower off and on again.\n\nThe stack is used by the system to keep track of the return addresses\nof machine language subroutines and interrupt calls and to save the\ncontents of internal registers.  The stack can also be used by the\nprogrammer for temporary storage.  BASIC and the Kernal make heavy use\nof the stack.\n\nMicrosoft BASIC uses part of the stack for a temporary work area.\nTherefore, the stack may be broken down into the following subregions:"
  },
  {
    "id": "map-100-10A",
    "address_start": 256,
    "address_end": 266,
    "hex_start": "$100",
    "hex_end": "$10A",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 2::",
    "type": "location",
    "text": "256-266       $100-$10A\nWork Area for Floating Point to String Conversions\n\nUsed in the conversion of numbers to the equivalent ASCII digits, and\nin scanning strings."
  },
  {
    "id": "map-100-13E",
    "address_start": 256,
    "address_end": 318,
    "hex_start": "$100",
    "hex_end": "$13E",
    "label": "BAD",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 2::",
    "type": "location",
    "text": "256-318       $100-$13E      BAD\nTape Input Error Log\n\nEach tape block is saved twice consecutively, in order to minimize\nloss of data from transmission errors.  These 62 bytes serve as\nindices of which bytes in the tape block were not received corectly\nduring the first transmission, so that corrections might be made on\nthe second pass."
  },
  {
    "id": "map-13F-1FF",
    "address_start": 319,
    "address_end": 511,
    "hex_start": "$13F",
    "hex_end": "$1FF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 2::",
    "type": "location",
    "text": "319-511       $13F-$1FF\n\nThis area is exclusively for the microprocessor stack.  Some BASIC\ncommands, such as FOR-NEXT loops require many stack entries at a time.\nTherefore, BASIC frequently checks the stack before pushing entries\non, and returns an OUT OF MEMORY error if an operation would result in\nless than 62 bytes of available stack memory.\n\nEach FOR statement causes 18 bytes to be pushed onto the stack, which\ncome off in the following order:\n\nFirst comes a one-byte constant of 129 ($81).  Next is a two-byte\npointer to the address of the subject variable (the X of FOR X=1 to\n10).  This is followed by the five-byte floating point representation\nof the TO value.  Finally comes the two-byte line number of the line\nto which the program returns after a NEXT, and the two-byte address of\nthe next character to read in that line after the FOR statement.\n\nEach GOSUB call places five bytes on the stack.  The first byte to\ncome off is a one-byte constant of 141 ($8D).  The next two bytes\ncontain the line number of the statement to which the program will\nRETURN after the subroutine ends.  And the final two bytes are a\npointer to the address of the BASIC program text for that statement in\nwhich the program RETURNs.\n\nDEF also leaves a five-byte entry on the stack.  It is the same as\nthat described for GOSUB, except that instead of a constant byte of\n141, the first number is a dummy byte, whose value has no\nsignificance.\n\n\n::::::::::::::::::::::::\n::                    ::\n::   Pages 2 and 3    ::\n::                    ::\n::BASIC and the Kernal::\n::  Working Storage   ::\n::::::::::::::::::::::::\n\nThis area is used to store important information for the Operating\nSystem and BASIC.  It contains vectors to certain BASIC routines as\nwell as Operating System Kernal routines.  Registers for RS-232 serial\nI/O are located here.  Buffer space is allocated in this area for tape\nI/O, BASIC text input, and the keyboard queue.  In addition, there are\na number of Operating System variables and pointers here which the\nprogrammer can utilize."
  },
  {
    "id": "map-200-258",
    "address_start": 512,
    "address_end": 600,
    "hex_start": "$200",
    "hex_end": "$258",
    "label": "BUF",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "512-600       $200-$258      BUF\nBASIC Line Editor Input Buffer\n\nWhen you are in the BASIC immediate mode, and type in a line of\ncharacters, those characters are stored here.  BASIC then scans the\nstring of characters, converts the text to tokenized BASIC program\nformat, and either stores it or executes the line, depending on\nwhether or not it started with a line number.\n\nThis same area is also used to store data which is received via the\nINPUT and GET commands.  This explains why these commands are illegal\nin immediate mode--they must use the same buffer space that is\nrequired by the immediate mode statement itself.\n\nIt is interesting to note that this buffer is 89 bytes long.  The\nscreen editor will allow a maximum of only 80 characters in a program\nline, with one extra byte required for a 0 character, marking the end\nof the line.  This presumable is a carry over from the VIC, which\nallows a line length of up to 88 characters.  The last eight bytes of\nthis buffer are therefore normally not used, and can be considered\nfree space for the programmer to use as he or she sees fit."
  },
  {
    "id": "map-259-276",
    "address_start": 601,
    "address_end": 630,
    "hex_start": "$259",
    "hex_end": "$276",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location_range",
    "text": "Location Range: 601-630 ($259-$276)\nTables for File Numbers, Device Numbers, and Secondary Addresses\n\nAll three of the tables here have room for ten one-byte entries, each\nof which represents an active Input/Output file.  When an I/O file is\nopened, its logical file number is put into the table at 601 ($259),\nthe device number of the I/O device is put into the table at 611\n($263), and its secondary address is put into the table at 621 ($26D).\n\nThe entry for any particular I/O file will occupy the same position in\neach of the three tables.  That is, if logical file number 2 is the\nthird entry in the file number table, its secondary address will be\nthe third entry in the secondary address table, and its corresponding\ndevice number will occupy the third spot in the device number table.\n\nEvery time a device is OPENed, its information is added as the last\nentry in each table, and the value at location 152 ($98) is increased\nby one, indicating that there is one more active I/O file.  When a\ndevice is CLOSEd, the value at location 152 is decreased by one, and\nall entries that occupy a position in the tables that is higher than\nthat of the closed device are moved down one position, thus\neliminating the entry for that device.  The Kernal CLALL routine\n(62255, $F32F) simply zeros location 152, which has the effect of\nemptying these tables."
  },
  {
    "id": "map-259-262",
    "address_start": 601,
    "address_end": 610,
    "hex_start": "$259",
    "hex_end": "$262",
    "label": "LAT",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "601-610       $259-$262      LAT\nKernal Table of Active Logical File Numbers"
  },
  {
    "id": "map-263-26C",
    "address_start": 611,
    "address_end": 620,
    "hex_start": "$263",
    "hex_end": "$26C",
    "label": "FAT",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "611-620       $263-$26C      FAT\nKernal Table of Device Numbers for Each Logical File"
  },
  {
    "id": "map-26D-276",
    "address_start": 621,
    "address_end": 630,
    "hex_start": "$26D",
    "hex_end": "$276",
    "label": "SAT",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "621-630       $26D-$276      SAT\nKernal Table of Secondary Addresses for Each Logical File"
  },
  {
    "id": "map-277-280",
    "address_start": 631,
    "address_end": 640,
    "hex_start": "$277",
    "hex_end": "$280",
    "label": "KEYD",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "631-640       $277-$280      KEYD\nKeyboard Buffer (Queue)\n\nThis buffer, sometimes also referred to as the keyboard queue, holds\nthe ASCII values of the characters entered from the keyboard.  The\ninterrupt routine which scans the keyboard deposits a character here\neach time a key is pressed.  When BASIC sees that there are characters\nwaiting, it removes and prints them, one by one, in the order in which\nthey were entered.\n\nThis kind of a buffer is known as FIFO, for First In, First Out.  The\nbuffer will hold up to ten characters, allowing you to type faster\nthan the computer prints characters, without losing characters.  The\nmaximum number of characters this buffer can hold at one time is ten\n(as determined by the value at 649 ($289)).  Characters entered after\nthe buffer is full will be ignored.\n\nThe commands GET and INPUT retrieve characters from this buffer.  If\none of these is executed while there are already characters waiting in\nthe buffer, those characters will be fetched as if they were part of\nthe data being input.  To prevent this from happening, you can clear\nthe buffer by POKEing a 0 into location 198 ($C6), which holds the\nnumber of characters that are waiting in the buffer.\n\nOne of the most interesting and useful techniques for programming\nCommodore computers is to have a program simulate direct entry of\ncommands from the keyboard.  This dynamic keyboard trick is achieved\nby first POKEing PETASCII characters, usually cursor movement\ncharacters and carriage returns, into the buffer, and setting location\n198 ($C6) to show how many characters are waiting in the buffer.\n\nNext, you clear the screen, and PRINT the statements that you wish to\nhave executed on the screen, carefully positioning them so that the\nfirst statement to be entered is on the fourth line of the screen.\n\nYou then home the cursor and execute an END statement.  This causes\nthe keyboard buffer to be read, and the carriage returns to be\nexecuted, thus entering the printed lines as if they had been typed in\nimmediate or direct mode.  The program can be continued by including a\nGOTO statement in the last line entered.\n\nMany interesting effects can be achieved using this method.  Examples\nof a few of these are included below.  For example, program lines can\nbe added, modified, or deleted, while the program is running.  The\nfollowing example shows how this is done:\n\n10 REM THIS LINE WILL BE DELETED\n20 REM A NEW LINE 30 WILL BE CREATED\n40 PRINT CHR$(147):PRINT:PRINT\n50 PRINT \"80 LIST\":PRINT\"30 REM THIS LINE WASN'T HERE BEFORE\"\n60 PRINT \"10\":PRINT \"GOTO 80\"CHR$(19)\n70 FOR I=631 TO 634:POKE I,13:NEXT:POKE 198,4:END\n80 REM THIS LINE WILL BE REPLACED\n\nYou can use this technique to enter numbered DATA statements\nautomatically, using values in memory.  These statements become a\npermanent part of the program.\n\nAnother interesting application is taking ASCII program lines from a\ntape data file, or sequential disk file, and having them entered\nautomatically.  This can be used for merging programs, or for\ntransferring programs between computers with a modem and a terminal\nprogram.  To create the ASCII program file, you use CMD to direct a\nLISTing to the desired device as follows:\n\nFor tape: OPEN 1,1,1,\"ASCII\":CMD 1:LIST\nAfter the listing has ended: PRINT #1:CLOSE 1\n\nFor disk: OPEN 8,8,8,\"ASCII,S,W\":CMD 8:LIST\nAfter the listing has ended: PRINT #8:CLOSE 8\n\nThis file can then be uploaded using a modem and appropriate terminal\nsoftware, entered by itself or merged with another program by using\nthe following program.  Be sure to save this program before you run\nit, because it will erase itself when it is done.\n\n60000 OPEN 1,8,8,\"ASCII\"\n60010 POKE 152,1:B=0:GOSUB 60170\n60020 GET #1,A$:IF A$=\"\"THEN60020\n60030 IF ST AND 64 THEN 60120\n60040 IF A$=CHR$(13)AND B=0THEN60020\n60050 PRINT A$;:B=1:IF A$=CHR$(34)THEN POKE 212,0\n60060 IF A$<>CHR$(13) THEN 60020\n60070 PRINT CHR$(5);\"GOTO 60010\";CHR$(5):PRINT:PRINT:POKE 198,0\n60080 PRINT \"RETURN=KEEP LINE    S=SKIP LINE\":B=0\n60090 GET A$:IF A$=\"\"THEN 60090\n60100 IF A$=\"S\" THEN 60010\n60110 GOTO 60180\n60120 PRINT \"END OF FILE--HIT RETURN TO FINISH MERGE\"\n60130 IF PEEK(197)<>1THEN60130\n60140 A=60000\n60150 GOSUB 60170:FOR I=A TO A+60 STEP10:PRINTI:NEXT\n60160 PRINT \"A=\"I\":GOTO 60150\":GOTO 60180\n60170 PRINT CHR$(147):PRINT:PRINT:RETURN\n60180 FOR I=631TO640:POKEI,13:NEXT:POKE198,10:PRINTCHR$(19);:END\n\nIf you wish to merge additional programs at the same time, when it\nindicates that the file has ended, press the STOP key rather than\nRETURN, enter the name of the new file in line 60000, and RUN 60000"
  },
  {
    "id": "map-281",
    "address_start": 641,
    "address_end": 642,
    "hex_start": "$281",
    "hex_end": "$281",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "641-642       $281-282       MEMSTR\nPointer: O.S. Start of Memory\n\nWhen the power is first turned on, or a cold start RESET is performed,\nthe Kernal routine RAMTAS (64848, $FD50) sets this location to point\nto address 2048 ($800).  This indicates that this is the starting\naddress of user RAM.  BASIC uses this location to set its own start of\nmemory pointer at location 43 ($2B), and thereafter uses only its own\npointer.\n\nThe Kernal routine MEMBOT (65076, $FE34) may be used to read or set\nthis pointer, or these locations may be directly PEEKed or POKEd from\nBASIC."
  },
  {
    "id": "map-283",
    "address_start": 643,
    "address_end": 644,
    "hex_start": "$283",
    "hex_end": "$283",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "643-644       $283-284       MEMSIZ\nPointer: O.S. End of Memory\n\nWhen the power is first turned on, or a cold start RESET is performed,\nthe Kernal routine RAMTAS (64848, $FD50) performs a nondestructive\ntest of RAM from 1024 ($400) up, stopping when the test fails,\nindicating the presence of ROM.  This will normally occur at 40960\n($A000), the location of the BASIC ROM.  The top of user RAM pointer\nis then set to point to that first ROM location.\n\nAfter BASIC has been started, the system will alter this location only\nwhen an RS-232 channel (device number 2) is OPENed or CLOSEd.  As 512\nbytes of memory are required for the RS-232 transmission and reception\nbuffers, this pointer, as well as the end of BASIC pointer at 55\n($37), is lowered to create room for those buffers when the device is\nopened.  CLOSing the device resets these pointers.\n\nThe Kernal routine MEMTOP (65061, $FE25) may be used to read or set\nthis pointer."
  },
  {
    "id": "map-285",
    "address_start": 645,
    "address_end": 645,
    "hex_start": "$285",
    "hex_end": "$285",
    "label": "TIMOUT",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "645           $285           TIMOUT\nFlag: Kernal Variable for IEEE Time-Out\n\nThis location is used only with the external IEEE interface card\n(which was not yet available from Commodore at the time of writing).\nFor more information, see the entry for the Kernal SETTMO routine at\n65057 ($FE21)."
  },
  {
    "id": "map-286",
    "address_start": 646,
    "address_end": 646,
    "hex_start": "$286",
    "hex_end": "$286",
    "label": "COLOR",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "646           $286           COLOR\nCurrent Foreground Color for Text\n\nThe process of PRINTing a character to the screen consists of both\nplacing the screen code value for the character in screen memory and\nplacing a foreground color value in the corresponding location in\ncolor RAM.  Whenever a character is PRINTed, the Operating System\nfetches the value to be put in color RAM from this location.\n\nThe foreground color may be changed in a number of ways.  Pressing the\nCTRL or Commodore logo key and numbers 1-8 at the same time will\nchange the value stored here, and thus the color being printed.\nPRINTing the PETASCII equivalent character with the CHR$ command will\nhave the same effect.  But probably the easiest method is to POKE the\ncolor value directly to this location.  The table below lists the\npossible colors that may be produced, and shows how to produce them\nusing all three methods.\n\nPOKE\nCOLOR #   COLOR     CHR$   KEYS TO PRESS\n 0        Black     144    CTRL-1\n 1        White       5    CTRL-2\n 2        Red        28    CTRL-3\n 3        Cyan      159    CTRL-4\n 4        Purple    156    CTRL-5\n 5        Green      30    CTRL-6\n 6        Blue       31    CTRL-7\n 7        Yellow    158    CTRL-8\n 8        Orange    129    Logo-1\n 9        Brown     149    Logo-2\n10        Lt Red    150    Logo-3\n11        Dark Gray 151    Logo-4\n12        Med Gray  152    Logo-5\n13        Lt Green  153    Logo-6\n14        Lt Blue   154    Logo-7\n15        Lt Gray   155    Logo-8"
  },
  {
    "id": "map-287",
    "address_start": 647,
    "address_end": 647,
    "hex_start": "$287",
    "hex_end": "$287",
    "label": "GDCOL",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "647           $287           GDCOL\nColor of Character under Cursor\n\nThis location is used to keep track of the original color code of the\ncharacter stored at the present cursor location.  Since the blinking\ncursor uses the current foreground color at 646 ($286), the original\nvalue must be stored here so that if the cursor moves on without\nchanging that character, its color code can be restored to its\noriginal value."
  },
  {
    "id": "map-288",
    "address_start": 648,
    "address_end": 648,
    "hex_start": "$288",
    "hex_end": "$288",
    "label": "HIBASE",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "648           $288           HIBASE\nTop Page of Screen Memory\n\nThis location contains the value used by the Operating System routines\nthat print to the screen as the base address for screen RAM.  The top\nof screen memory can be found by multiplying this location by 256.\nThe default value for screen RAM is set on power-up to location 1024\n($400), and this location therefore usually contains a 4.\n\nScreen display memory on the Commodore 64 can be moved to start on any\n1K boundary (location evenly divisible by 1024).  This is done by\nmanipulating the VIC-II chip memory bank select at location 56576\n($DD00).\n\nIt is important to note, however, that while any area may be\ndisplayed, the Operating System will look here to find out where it\nshould PRINT characters.  Therefore, if you change the screen location\nby altering the contents of one of the two addresses listed above, the\nOperating System will still not know where to PRINT characters unless\nyou also change this address as well.  The result will be that\ncharacters entered from the keyboard or PRINTed will not appear on the\nscreen.\n\nExamples of how to properly relocate the screen can be found at the\nentries for location 53272 ($D018) and 43 ($2B).\n\nSince the PRINT command in essence just POKEs a lot of values to\nscreen and color memory, by changing this pointer you can print a\nstring of characters to memory locations other than screen RAM.  For\nexample, you could PRINT a sprite shape to memory without having to\nREAD a lot of DATA statements.  The program below PRINTs different\nsprite shapes into the sprite data area:\n\n10 SP=53248:POKESP,170:POKESP+1,125:POKESP+21,1:POKE 2040,13:PRINT CHR$(147)\n20 A$=\"THIS TEXT WILL BE PRINTED TO THE SPRITE SHAPE DATA AREA AND DISPLAYED\"\n30 GOSUB 100\n40 A$=\"THIS IS SOME DIFFERENT TEXT TO BE PRINTED TO THE SPRITE SHAPE AREA\"\n50 GOSUB 100\n60 COUNT=COUNT+1:IF COUNT<15 THEN 20\n70 END\n100 POKE 648,3:PRINT CHR$(19);CHR$(17);SPC$(24);A$;:POKE 648,4:RETURN\n\nSince PRINTing also changes color memory, you can change the pointer\nto print the characters harmlessly to ROM, while changing a lot of\nscreen RAM at one time, as the following program demonstrates:\n\n10 D$=CHR(94):FOR I=1 TO 4:D$=D$+D$:NEXT\n20 PRINT CHR$(147);:FOR I=1 TO 7:PRINT TAB(10) D$:NEXT:PRINT:PRINT:PRINT:PRINT\n30 PRINT TAB(9);CHR$(5);\"HIT ANY KEY TO STOP\"\n40 DIM C(15):FOR I=0TO14:READ A:C(I)=A:NEXT:DATA2,8,7,5,6,4,1,2,8,7,5,6,4,1,2\n50 POKE 53281,0:POKE 648,212:FOR J=0 TO 6:PRINT CHR$(19);\n60 FOR I=J TO J+6:POKE 646,C(I):PRINT TAB(10) D$:NEXT I,J\n70 GET A$:IF A$=\"\" THEN 50\n80 POKE 648,4:POKE 646,1"
  },
  {
    "id": "map-289",
    "address_start": 649,
    "address_end": 649,
    "hex_start": "$289",
    "hex_end": "$289",
    "label": "XMAX",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "649           $289           XMAX\nMaximum Keyboard Buffer Size\n\nThe value here indicates the maximum number of characters that the\nkeyboard buffer at 631 ($277) may hold at any one time.  Anytime that\nthe current buffer length in location 198 ($C6) matches the value\nhere, further keypresses will be ignored.\n\nAlthough the maximum size of the keyboard buffer is usually 10\ncharacters, it may be possible to extend it up to 15 characters by\nchanging the number here.  This could cause the Operating System\npointers to the bottom and top of memory at 641-644 ($281-$284) to be\noverwritten, but no real harm should result."
  },
  {
    "id": "map-28A",
    "address_start": 650,
    "address_end": 650,
    "hex_start": "$28A",
    "hex_end": "$28A",
    "label": "RPTFLAG",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "650           $28A           RPTFLAG\nFlag: Which Keys Will Repeat?\n\nThe flag at this location is used to determine whether to continue\nprinting a character as long as its key is held down, or whether to\nwait until the key is let up before allowing it to be printed again.\nThe default value here is 0, which allows only the cursor movement\nkeys, insert/delete key, and the space bar to repeat.\n\nPOKEing this location with 128 ($80) will make all keys repeating,\nwhile a value of 64 ($40) will disable all keys from repeating."
  },
  {
    "id": "map-28B",
    "address_start": 651,
    "address_end": 651,
    "hex_start": "$28B",
    "hex_end": "$28B",
    "label": "KOUNT",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "651           $28B           KOUNT\nCounter for Timing the Delay Between Key Repeats\n\nThis location is used as a delay counter to determine how long to wait\nwhile a key is being held down until the next repeat printing of that\nkey.\n\nThe value here starts at 6.  If location 652 ($28C) contains a 0, the\nvalue in this location is counted down once every 1/60 second, so long\nas the same key is held down.  When this counter gets to 0, and if the\nrepeat flag at 650 ($28A) allows that key to repeat, its ASCII\nequivalent will once again be placed in the keyboard buffer.  A value\nof 4 is then placed in location 651, allowing subsequent repeats to\noccur at a rate of 15 per second."
  },
  {
    "id": "map-28C",
    "address_start": 652,
    "address_end": 652,
    "hex_start": "$28C",
    "hex_end": "$28C",
    "label": "DELAY",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "652           $28C           DELAY\nCounter for Timing the Delay Until the First Key Repeat Begins\n\nThis location is used as a delay counter to determine how long a key\nmust be held down before the entry of that key should be repeated.\n\nThe initial value of 16 is counted down every 1/60 second, as long as\nthe same key remains pressed.  When the value gets to 0, location 651\n($28B) is counted down from 6, and the key is repeated when the value\nthere reaches 0.  Thus a total of 22/60, or approximately 1/3, second\nwill elapse before the first repeat of a key.  The value here will be\nheld to 0 after the first repeat, so that subsequent keystroke\nrepititions occur much more quickly."
  },
  {
    "id": "map-28D",
    "address_start": 653,
    "address_end": 653,
    "hex_start": "$28D",
    "hex_end": "$28D",
    "label": "SHFLAG",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "653           $28D           SHFLAG\nFlag: SHIFT/CTRL/Logo Keypress\n\nThis flag signals which of the SHIFT, CTRL, or Commodore logo keys are\ncurrently being pressed, if any.\n\nA value of 1 signifies that one of the SHIFT keys is being pressed, a\n2 shows that the Commodore logo key is down, and 4 means that the CTRL\nkey is being pressed.  If more than one key is held down, these values\nwill be added; for example, a 3 indicates that SHIFT and logo are both\nheld down.\n\nThe value here is used by the Operating System when determining how to\nconvert a keypress into a PETASCII character.  There are four\ndifferent tables used to translate one of the 64 keys on the keyboard\nmatrix into a PETASCII character, and the combination of special SHIFT\nkeys determines which of these tables will be used (see the entry for\nlocation 245 ($F5) for more details on the keyboard tables).\n\nPressing the SHIFT and Commodore logo keys at the same time will\ntoggle the character set that is presently being used between the\nuppercase/graphics set, and the lowercase/uppercase set (provided that\nthe flag at 657 ($291) has not been set to disable this switch).\n\nThis changes the appearance of all of the characters on the screen at\nonce.  It has nothing whatever to do with the keyboard shift tables,\nhowever, and should not be confused with the printing of SHIFTed\ncharacters, which affects only one character at a time.  Rather, it is\nthe result of the value of the character dot data table base address\nin 53272 ($D018) being changed.  The came result may be obtained by\nPOKEing that address directly."
  },
  {
    "id": "map-28E",
    "address_start": 654,
    "address_end": 654,
    "hex_start": "$28E",
    "hex_end": "$28E",
    "label": "LSTSHF",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "654           $28E           LSTSHF\nLast Pattern of SHIFT/CTRL/Logo Keypress\n\nThis location is used in combination with the one above to debounce\nthe special SHIFT keys.  This will keep the SHIFT/logo combination\nfrom changing character sets back and forth during a single pressing\nof both keys."
  },
  {
    "id": "map-28F-290",
    "address_start": 655,
    "address_end": 656,
    "hex_start": "$28F",
    "hex_end": "$290",
    "label": "KEYLOG",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "655-656       $28F-$290      KEYLOG\nVector to Keyboard Table Setup Routine\n\nThis location points to the address of the Operating System routine\nwhich actually determines which keyboard matrix lookup table will be\nused.\n\nThe routine looks at the value of the SHIFT flag at 653 ($28D), and\nbased on what value it finds there, stores the address of the correct\ntable to use at location 245 ($F5).\n\nThe interrupt driven keyboard-scanning routine jumps through this RAM\nvector to get to the table setup routine.  Therefore, it is possible\nto alter the address contained in this vector, and direct the keyscan\nroutine to your own routine, which can check the keypress and SHIFT\ncombination, and act before a character is printed.\n\nSince this routine comes after the keypress, but before it is printed,\nthis is a very good place to have your preprocessor routine check for\na particular keypress.  An excellent example of such a program is the\n\"VICword\" program by Mark Niggemann, COMPUTE!'s Second Book of VIC.\nThis program adds a machine language routine that checks if the SHIFT\nor Commodore logo key is pressed while not in quote mode.  If it finds\none of these keypresses, it substitutes an entire BASIC keyword for\nthe letter (A-Z) of the key that was pressed.  An adaptation of that\nprogram for the 64 appears below.\n\n100 IF PEEK(PEEK(56)*256)<>120THENPOKE56,PEEK(56)-1:CLR\n110 HI=PEEK(56):BASE=HI*256\n120 PRINTCHR$(147)\"READING DATA\"\n130 FOR AD=0 TO 211:READ BY\n140 POKE BASE+AD,BY:NEXT AD\n150 :\n200 REM RELOCATION ADJUSTMENTS\n210 POKE BASE+26,HI:POKE BASE+81,HI\n220 POKE BASE+123,HI:POKE BASE+133,HI\n230 :\n240 PRINT CHR$(147) TAB(15)\"***64WORD***\":PRINT\n250 PRINT\"TO TOGGLE THE PROGRAM ON/OFF:\":PRINT:PRINT:PRINT \"SYS\";BASE;\n260 PRINT CHR$(145);CHR$(145);\n270 DATA 120,173,143,2,201,32\n280 DATA 208,12,169,220,141,143\n290 DATA 2,169,72,141,144,2\n300 DATA 88,96,169,32,141,143\n310 DATA 2,169,0,141,144,2\n320 DATA 88,96,165,212,208,117\n330 DATA 173,141,2,201,3,176\n340 DATA 110,201,0,240,106,169\n350 DATA 194,133,245,169,235,133\n360 DATA 246,165,215,201,193,144\n370 DATA 95,201,219,176,91,56\n380 DATA 233,193,174,141,2,224\n390 DATA 2,208,3,24,105,26\n400 DATA 170,189,159,0,162,0\n410 DATA 134,198,170,160,158,132\n420 DATA 34,160,160,132,35,160\n430 DATA 0,10,240,16,202,16\n440 DATA 12,230,34,208,2,230\n450 DATA 35,177,34,16,246,48\n460 DATA 241,200,177,34,48,17\n470 DATA 8,142,211,0,230,198\n480 DATA 166,198,157,119,2,174\n490 DATA 211,0,40,208,234,230\n500 DATA 198,166,198,41,127,157\n510 DATA 199,2,230,198,169,20\n520 DATA 141,119,2,76,72,235\n530 DATA 76,224,234\n550 REM TOKENS FOR SHIFT KEY\n570 DATA 153,175,199,135,161,129\n580 DATA 141,164,133,137,134,147\n590 DATA 202,181,159,151,163,201\n600 DATA 196,139,192,149,150,155\n610 DATA 191,138\n630 REM TOKENS FOR COMMODORE KEY\n650 DATA 152,165,198,131,128,130\n660 DATA 142,169,132,145,140,148\n670 DATA 195,187,160,194,166,200\n680 DATA 197,167,186,157,165,184\n690 DATA 190,158,0\n\nCommodore 64word: Keys into BASIC Commands\n\nKey   SHIFT   Commodore\nA     PRINT   PRINT#\nB     AND     OR\nC     CHR$    ASC\nD     READ    DATA\nE     GET     END\nF     FOR     NEXT\nG     GOSUB   RETURN\nH     TO      STEP\nI     INPUT   INPUT#\nJ     GOTO    ON\nK     DIM     RESTORE\nL     LOAD    SAVE\nM     MID$    LEN\nN     INT     RND\nO     OPEN    CLOSE\nP     POKE    PEEK\nQ     TAB(    SPC(\nR     RIGHT$  LEFT$\nS     STR$    VAL\nT     IF      THEN\nU     TAN     SQR\nV     VERIFY  CMD\nW     DEF     FN\nX     LIST    FRE\nY     SIN     COS\nZ     RUN     SYS"
  },
  {
    "id": "map-291",
    "address_start": 657,
    "address_end": 657,
    "hex_start": "$291",
    "hex_end": "$291",
    "label": "MODE",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "657           $291           MODE\nFlag: Enable or Disable Changing Character Sets with SHIFT/Logo\nKeypress\n\nThis flag is used to enable or disable the feature which lets you\nswitch between the uppercase/graphics and upper/lowercase character\nsets by pressing the SHIFT and Commodore logo keys simultaneously.\n\nThis flag affects only this special SHIFT key function, and does not\naffect the printing of SHIFTed characters.  POKEing a value of 128\n($80) here will disable this feature, while POKEing a value of 0 will\nenable it once more.  The same effect can be achieved by PRINTing\nCHR$(8) or CTRL-H to disable the switching of character sets, and\nCHR$(9) or CTRL-I to enable it.  See entries for locations 53272\n($D018) and 49152 ($C000) for more information on switching character\nsets."
  },
  {
    "id": "map-292",
    "address_start": 658,
    "address_end": 658,
    "hex_start": "$292",
    "hex_end": "$292",
    "label": "AUTODN",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "658           $292           AUTODN\nFlag: Screen Scrolling Enabled\n\nThis location is used to determine whether moving the cursor past the\nfortieth column of a logical line will cause another physical line to\nbe added to the logical line.\n\nA value of 0 enables the screen to scroll the following lines down in\norder to add that line; any nonzero value will disable the scroll.\nThis flag is set to disable the scroll temporarily when there are\ncharacters waiting in the keyboard buffer (these may include cursor\nmovement characters that would eliminate the need for a scroll)."
  },
  {
    "id": "map-293-297",
    "address_start": 659,
    "address_end": 663,
    "hex_start": "$293",
    "hex_end": "$297",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location_range",
    "text": "Location Range: 659-663 ($293-$297)\nRS-232 Pseudo 6551 Registers\n\nFor serial Input/Output via the RS-232 port, the internal software of\nthe Commodore 64 emulates the operation of a 6551 UART chip (that's\nUniversal Asynchronous Receiver/Transmitter, for you acronym buffs),\nalso known as an ACIA (Asynchronous Communications Interface Adapter).\n\nThese RAM locations are used to mimic the functions of that chip's\nhardware command, control, and status registers.  Although RAM\nlocations are allocated for mimicking the 6551's ability to use either\nan on-board baud rate generator or an external clock crystal, this\nfunction is not implemented by the internal software.\n\nProvisions have been made for the user to communicate with these\nregisters through the RS-232 OPEN command.  When device 2 is opened, a\nfilename of up to four characters may be appended.  These four\ncharacters are copied to locations 659-662 ($293-$296), although the\nlast two, which specify a nonstandard baud rate, are not used because\nthat feature is not implemented."
  },
  {
    "id": "map-293",
    "address_start": 659,
    "address_end": 659,
    "hex_start": "$293",
    "hex_end": "$293",
    "label": "M51CTR",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "659           $293           M51CTR\nRS-232: Mock 6551 Control Register\n\nThis location is used to control the RS-232 serial I/O baud rate\n(speed at which data is transmitted and received), the word length\n(number of bits per data character), and the number of stop bits used\nto mark the end of a transmitted character.  It uses the same format\nas that of the 6551 UART control register to set these parameters,\nalthough, as you will see, some of the 6551 configurations are not\nimplemented by the software that emulates the UART device.  For\nexample, the standard baud rates which are higher than 2400 baud are\nnot implemented, presumably because the software cannot keep up at\nhigher rates.  The meanings of the various bit patterns are as\nfollows:\n\nBit 7: STOP Bits\n0    (bit value of 0)   = 1 STOP Bit\n1    (bit value of 128) = 0 STOP Bits\n\nBits 6-5: WORD LENGTH\n00   (bit value of 0)   = 8 DATA Bits\n01   (bit value of 32)  = 7 DATA Bits\n10   (bit value of 64)  = 6 DATA Bits\n11   (bit value of 96)  = 5 DATA Bits\n\nBit 4: Unused\n\nBits 3-0: BAUD RATE\n0000 (bit value of 0)   = Nonstandard (User-Defined) Rate (Not Implemented)\n0001 (bit value of 1)   = 50 Baud\n0010 (bit value of 2)   = 75 Baud\n0011 (bit value of 3)   = 110 Baud\n0100 (bit value of 4)   = 134.5 Baud\n0101 (bit value of 5)   = 150 Baud\n0110 (bit value of 6)   = 300 Baud\n0111 (bit value of 7)   = 600 Baud\n1000 (bit value of 8)   = 1200 Baud\n1001 (bit value of 9)   = 1800 Baud\n1010 (bit value of 10)  = 2400 Baud\n1011 (bit value of 11)  = 3600 Baud (Not Implemented on the Commodore 64)\n1100 (bit value of 12)  = 4800 Baud (Not Implemented on the Commodore 64)\n1101 (bit value of 13)  = 7200 Baud (Not Implemented on the Commodore 64)\n1110 (bit value of 14)  = 9600 Baud (Not Implemented on the Commodore 64)\n1111 (bit value of 15)  = 19200 Baud (Not Implemented on the Commodore 64)\n\nThis register is the only one which must be set when opening RS-232\ndevice (number 2).  The first character of the filename will be stored\nhere.  For example, the statement OPEN 2,2,0,CHR$(6+32) will set the\nvalue of this location to 38.  As you can see from the above chart,\nthis sets up the RS-232 device for a data transfer rate of 300 baud,\nusing seven data bits per character and one stop bit."
  },
  {
    "id": "map-294",
    "address_start": 660,
    "address_end": 660,
    "hex_start": "$294",
    "hex_end": "$294",
    "label": "M51CDR",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "660           $294           M51CDR\nRS-232: Mock 6551 Command Register\n\nThis location performs the same function as the 6551 UART chip's\ncommand register, which specifies type of parity, duplex mode, and\nhandshaking protocol.\n\nThe type of parity used determines how the 64 will check that RS-232\ndata is received correctly.\n\nThe duplex mode can be either full duplex (the 64 will be able to\ntransmit at the same time it is receiving) or half duplex (it will\ntake turns sending and receiving).\n\nThe handshaking protocol has to do with the manner in which the\nsending device lets the receiver know that it is ready to send data,\nand the receiver lets the sender know that it has gotten the data\ncorrectly.  The meanings of the bit patterns in this register are as\nfollows:\n\nBits 7-5: Parity\nXX0 (bit value of\n     0,64,128, or 192) = No Parity Generated or Received\n001 (bit value of 32)  = Odd Parity Transmitted and Received\n011 (bit value of 96)  = Even Parity Transmitted and Received\n101 (bit value of 160) = Mark Parity Transmitted and Received\n111 (bit value of 224) = Space Parity Transmitted and Received\n\nBit 4: Duplex\n0 (bit value of 0)  = Full Duplex\n1 (bit value of 16) = Half Duplex\n\nBits 3-1: Unused\n\nBit 0: Handshake Protocol\n0 (bit value of 0) = 3 Line\n1 (bit value of 1) = X Line\n\nThis register can be set at the user's option when opening RS-232\ndevice (number 2).  The second character of the filename will be\nstored here.  For example, the statement\n\nOPEN 2,2,0,CHR$(6+32)+CHR$(32+16)\n\nwill set the value of this location to 48, which is the value of the\nsecond character in the filename portion of the statement.  As you can\nsee from the above chart, this configures the RS-232 device for half\nduplex data transfer using odd parity and three-line handshaking."
  },
  {
    "id": "map-295-296",
    "address_start": 661,
    "address_end": 662,
    "hex_start": "$295",
    "hex_end": "$296",
    "label": "M51AJB",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "661-662       $295-$296      M51AJB\nRS-232: Nonstandard Bit Timing\n\nThese locations are provided for storing a nonstandard user-defined\nbaud rate, to be used when the low nybble of the control register at\n659 ($293) is set to 0.  They were presumable provided to conform to\nthe nodel of the 6551 UART device, which allows a nonstandard baud\nrate to be generated from an external reference crystal.  However, the\nsoftware emulation of that feature is not provided in the current\nversion of the Kernal, and thus these locations are currently\nnonfunctional.\n\nNonetheless, Commodore has specified that if the nonstandard baud rate\nfeature is implemented, the value placed here should equal the system\nclock frequency divided by the baud rate divided by 2 minus 100,\nstored in low byte, high byte order.  The system clock frequency for\nAmerican television monitors (NTSC standard) is 1.02273 MHz, and for\nEuropean monitors (PAL standard) .98525 MHz."
  },
  {
    "id": "map-297",
    "address_start": 663,
    "address_end": 663,
    "hex_start": "$297",
    "hex_end": "$297",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "663           $297           $RSSTAT\nRS-232: Mock 6551 Status Register\n\nThe contents of this register indicate the error status of RS-232 data\ntransmission.  That status can be determined by PEEKing this location\ndirectly, by referencing the BASIC reserved variable ST, or by using\nthe Kernal READST (65031, $FE07) routine.\n\nNote that if you use ST or Kernal, this location will be set to 0\nafter it is read.  Therefore, if you need to test more than one bit,\nmake sure that each test preserves the original value, because you\nwon't be able to read it again.  The meaning of each bit value is\nspecified below:\n\nBit 7: 1 (bit value of 128) = Break Detected\nBit 6: 1 (bit value of 64)  = DTR (Data Set Ready) Signal Missing\nBit 5: Unused\nBit 4: 1 (bit value of 16)  = CTS (Clear to Send) Signal Missing\nBit 3: 1 (bit value of 8)   = Receiver Buffer Empty\nBit 2: 1 (bit value of 4)   = Receiver Buffer Overrun\nBit 1: 1 (bit value of 2)   = Framing Error\nBit 0: 1 (bit value of 1)   = Parity Error\n\nThe user is responsible for checking these errors and taking\nappropriate action.  If, for example, you find that Bit 0 or 1 is set\nwhen you are sending, indicating a framing or parity error, you should\nresend the last byte.  If Bit 2 is set, the GET#2 command is not being\nexecuted quickly enough to empty the buffer (BASIC should be able to\nkeep up at 300 baud, but not higher).  If Bit 7 is set, you will want\nto stop sending, and execute a GET#2 to see what is being sent."
  },
  {
    "id": "map-298",
    "address_start": 664,
    "address_end": 664,
    "hex_start": "$298",
    "hex_end": "$298",
    "label": "BITNUM",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "664           $298           BITNUM\nRS-232: Number of Bits Left to be Sent/Received\n\nThis location is used to determine how many zero bits must be added to\nthe data character to pad its length out to the word length specified\nin 659 ($293)."
  },
  {
    "id": "map-299-29A",
    "address_start": 665,
    "address_end": 666,
    "hex_start": "$299",
    "hex_end": "$29A",
    "label": "BAUDOF",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "665-666       $299-$29A      BAUDOF\nTime Required to Send a Bit\n\nThis location holds the prescaler value used by CIA #2 timers A and B.\n\nThese timers cause an NMI interrupt to drive the RS-232 receive and\ntransmit routines CLOCK/PRESCALER times per second each, where CLOCK\nis the system 02 frequency of 1,022,730 Hz (985,250 if you are using\nthe European PAL television standard rather than the American NTSC\nstandard), and PRESCALER is the value stored at 56580-1 ($DD04-5) and\n56582-3 ($DD06-7), in low-byte, high-byte order.  You can use the\nfollowing formula to figure the correct prescaler value for a\nparticular RS-232 baud rate:\n\nPRESCALER=((CLOCK/BAUDRATE)/2)-100\n\nThe American (NTSC standard) prescaler values for the standard RS-232\nbaud rates which the control register at 659 ($293) makes available\nare stored in a table at 65218 ($FEC2), starting with the two-byte\nvalue used for 50 baud.  The European (PAL standard) version of that\ntable is located at 58604 ($E4EC)."
  },
  {
    "id": "map-29B-29E",
    "address_start": 667,
    "address_end": 670,
    "hex_start": "$29B",
    "hex_end": "$29E",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location_range",
    "text": "Location Range: 667-670 ($29B-$29E)\nByte Indices to the Beginning and End of Receive and Transmit Buffers\n\nThe two 256-byte First In, First Out (FIFO) buffers for RS-232 data\nreception and transmission are dynamic wraparound buffers.  This means\nthat the starting point and the ending point of the buffer can change\nover time, and either point can be anywhere withing the buffer.  If,\nfor example, the starting point is at byte 100, the buffer will fill\ntowards byte 255, at which point it will wrap around to byte 0 again.\nTo maintain this system, the following four locations are used as\nindices to the starting and the ending point of each buffer."
  },
  {
    "id": "map-29B",
    "address_start": 667,
    "address_end": 667,
    "hex_start": "$29B",
    "hex_end": "$29B",
    "label": "RIDBE",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "667           $29B           RIDBE\nRS-232: Index to End of Receive Buffer\n\nThis index points to the ending byte within the 256-byte RS-232\nreceive buffer, and is used to add data to that buffer."
  },
  {
    "id": "map-29C",
    "address_start": 668,
    "address_end": 668,
    "hex_start": "$29C",
    "hex_end": "$29C",
    "label": "RIDBS",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "668           $29C           RIDBS\nRS-232: Index to Start of Receive Buffer\n\nThis index points to the starting byte within the 256-byte RS-232\nreceive buffer, and is used to remove data from that buffer."
  },
  {
    "id": "map-29D",
    "address_start": 669,
    "address_end": 669,
    "hex_start": "$29D",
    "hex_end": "$29D",
    "label": "RODBS",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "669           $29D           RODBS\nRS-232: Index to Start of Transmit Buffer\n\nThis index points to the starting byte within the 256-byte RS-232\ntransmit buffer, and is used to remove data from that buffer."
  },
  {
    "id": "map-29E",
    "address_start": 670,
    "address_end": 670,
    "hex_start": "$29E",
    "hex_end": "$29E",
    "label": "RODBE",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "670           $29E           RODBE\nRS-232: Index to End of Transmit Buffer\n\nThis index points to the ending byte within the 256-byte RS-232\ntransmit buffer, and is used to add data to that buffer."
  },
  {
    "id": "map-29F-2A0",
    "address_start": 671,
    "address_end": 672,
    "hex_start": "$29F",
    "hex_end": "$2A0",
    "label": "IRQTMP",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "671-672       $29F-$2A0      IRQTMP\nSAve Area for IRQ Vector During Cassette I/O\n\nThe routines that read and write tape data are driven by an IRQ\ninterrupt.  In order to hook one of these routines into the interrupt,\nthe RAM IRQ vector at 788-789 ($314-$315) must be changed to point to\nthe address at which it starts.  Before that change is made, the old\nIRQ vector address is saved at these locations, so that after the tape\nI/O is finished, the interrupt that is used for scanning the keyboard,\nchecking the stop key, and updating the clock can be restored.\n\nYou will note that all of the above functions will be suspended during\ntape I/O."
  },
  {
    "id": "map-2A1",
    "address_start": 673,
    "address_end": 673,
    "hex_start": "$2A1",
    "hex_end": "$2A1",
    "label": "ENABL",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "673           $2A1           ENABL\nRS-232 Interrupts Enabled\n\nThis location holds the active NMI interrupt flag byte from CIA #2\nInterrupt Control Register (56589, $DD0D).  The bit values for this\nflag are as follows:\n\nBit 4: 1 (bit value of 16) = System is Waiting for Receiver Edge\nBit 1: 1 (bit value of 2)  = System is Receiving Data\nBit 0: 1 (bit value of 1)  = System is Transmitting Data"
  },
  {
    "id": "map-2A2",
    "address_start": 674,
    "address_end": 674,
    "hex_start": "$2A2",
    "hex_end": "$2A2",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "674           $2A2\nIndicator of CIA #1 Control Register B Activity During Cassette I/O"
  },
  {
    "id": "map-2A3",
    "address_start": 675,
    "address_end": 675,
    "hex_start": "$2A3",
    "hex_end": "$2A3",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "675           $2A3\nSave Area for CIA #1 Interrupt Control Register During Cassette Read"
  },
  {
    "id": "map-2A4",
    "address_start": 676,
    "address_end": 676,
    "hex_start": "$2A4",
    "hex_end": "$2A4",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "676           $2A4\nSave Area for CIA #1 Control Register A During Cassette Read"
  },
  {
    "id": "map-2A5",
    "address_start": 677,
    "address_end": 677,
    "hex_start": "$2A5",
    "hex_end": "$2A5",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "677           $2A5\nTemporary Index to the Next 40-Column Line for Screen Scrolling"
  },
  {
    "id": "map-2A6",
    "address_start": 678,
    "address_end": 678,
    "hex_start": "$2A6",
    "hex_end": "$2A6",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "678           $2A6\nPAL/NTSC Flag\n\nAt power-on, a test is performed to see if the monitor uses the NTSC\n(North American) or PAL (European) television standard.\n\nThis test is accomplished by setting a raster interrupt for scan line\n311, and testing if the interrupt occurs.  Since NTSC monitors have\nonly 262 raster scan lines per screen, the interrupt will occur only\nif a PAL monitor is used.  The results of that test are stored here,\nwith a 0 indicating an NTSC system in use, and one signifying a PAL\nsystem.\n\nThis information is used by the routines which set the prescaler\nvalues for the system IRQ timer, so that the IRQ occurs every 1/60\nsecond.  Since the PAL system 02 clock runs a bit slower than the NTSC\nversion, this prescaler value must be adjusted accordingly."
  },
  {
    "id": "map-2A7-2FF",
    "address_start": 679,
    "address_end": 767,
    "hex_start": "$2A7",
    "hex_end": "$2FF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "679-767       $2A7-$2FF\nUnused\n\nThe programmer may use this area for machine language subroutines, or\nfor graphics data storage.\n\nIf the VIC-II ship is using the bottom 16K for graphics and memory\n(the default setting when the system is turned on), this is one of the\nfew free areas available for storing sprite or character data.\nLocaitons 704-767 could be used for sprite data block number 11,\nwithout interfering with BASIC program text or variables."
  },
  {
    "id": "map-300-30B",
    "address_start": 768,
    "address_end": 779,
    "hex_start": "$300",
    "hex_end": "$30B",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location_range",
    "text": "Location Range: 768-779 ($300-$30B)\nBASIC Indirect Vector Table\n\nSeveral important BASIC routines are vectored through RAM.  This means\nthat the first instruction executed by the routine is an indirect jump\nto a location pointed to by one of the vectors in this table.\n\nOn power up, the system sets these vectors to point to the next\ninstruction past the original JuMP instruction.  The routine then\ncontinues with that instruction as if the jump never took place.  For\nexample, the BASIC error message routine starts at 42039 ($A437) with\nthe instruction JMP ($300).  The indirect vector at 768 ($300) points\nto 42042 ($A43A), which is the instruction immediately following JMP\n($300).\n\nAlthough this may seem like a fancy way of accomplishing nothing,\nusing these indirect vectors serves two important purposes.  First, it\nallows you to use these important BASIC routines without knowing their\naddresses in the BASIC ROM.\n\nFor example, the routine to LIST the ASCII text of the single-byte\nBASIC program token that is currently in the Accumulator (.A) is\nlocated at one address in the VIC, and another in the 64.  On future\nCommodore computers it may be found at still another location.  Yet as\nlong as the routine is vectored in RAM at 774 ($306), the statement\nQP=PEEK(774)+256*PEEK(775) would find the address of that routine on\nany of the machines.  Thus, entering such routines through RAM vectors\nrather than a direct jump into the ROMs helps to keep your programs\ncompatible with different machines.\n\nThe other important effect of having these vectors in RAM is that you\ncan alter them.  In that way, you can redirect these important BASIC\nroutines to execute your own preprocessing routines first.\n\nIf you wanted to add commands to BASIC, for example, how would you go\nabout it?  First, you would need to change the BASIC routines that\nconvert ASCII program text to tokenized program format, so that when a\nline of program text was entered, the new keyword would be stored as a\ntoken.\n\nNext, you would need to change the routine that executes tokens, so\nthat when the interpreter comes to your new keyword token, it will\ntake the proper action.\n\nYou would also have to change the routine that converts tokens back to\nASCII text, so that your program would LIST the token out correctly.\nAnd you might want to alter the routine that prints error messages, to\nadd new messages for your keyword.\n\nAs you will see, vectors to all of these routines can be found in the\nfollowing indirect vector table.  Changing these vectors is a much\nmore elegant and efficient solution than the old wedge technique\ndiscussed at location 115 ($73)"
  },
  {
    "id": "map-300-301",
    "address_start": 768,
    "address_end": 769,
    "hex_start": "$300",
    "hex_end": "$301",
    "label": "IERROR",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "768-769       $300-$301      IERROR\nVector to the Print BASIC Error Message Routine\n\nThis vector points to the address of the ERROR routine at 58251\n($E38B)."
  },
  {
    "id": "map-302-303",
    "address_start": 770,
    "address_end": 771,
    "hex_start": "$302",
    "hex_end": "$303",
    "label": "IMAIN",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "770-771       $302-$303      IMAIN\nVector to the Main BASIC Program Loop\n\nThis vector points to the address of the main BASIC program loop at\n42115 ($A483).  This is the routine that is operating when you are in\nthe direct mode (READY).  It executes statements, or stores them as\nprogram lines."
  },
  {
    "id": "map-304-305",
    "address_start": 772,
    "address_end": 773,
    "hex_start": "$304",
    "hex_end": "$305",
    "label": "ICRNCH",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "772-773       $304-$305      ICRNCH\nVector to the Routine That Crunches the ASCII Text of Keywords into\nTokens\n\nThis vector points to the address of the CRUNCH routine at 42364\n($A57C)."
  },
  {
    "id": "map-306-307",
    "address_start": 774,
    "address_end": 775,
    "hex_start": "$306",
    "hex_end": "$307",
    "label": "IQPLOP",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "774-775       $306-$307      IQPLOP\nVector to the Routine That Lists BASIC Program Token as ASCII Text\n\nThis vector points to the address of the QPLOP routine at 42778\n($A71A)."
  },
  {
    "id": "map-308-309",
    "address_start": 776,
    "address_end": 777,
    "hex_start": "$308",
    "hex_end": "$309",
    "label": "IGONE",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "776-777       $308-$309      IGONE\nVector to the Routine That Executes the Next BASIC Program Token\n\nThis vector points to the address of the GONE routine at 42980 ($A7E4)\nthat executes the next program token."
  },
  {
    "id": "map-30A-30B",
    "address_start": 778,
    "address_end": 779,
    "hex_start": "$30A",
    "hex_end": "$30B",
    "label": "IEVAL",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "778-779       $30A-$30B      IEVAL\nVector to the Routine That Evaluates a Single-Term Arithmetic\nExpression\n\nThis vector points to the address of the EVAL routinea t 44678 ($AE86)\nwhich, among other things, is used to evaluate BASIC functions such as\nINT and ABS."
  },
  {
    "id": "map-30C-30F",
    "address_start": 780,
    "address_end": 783,
    "hex_start": "$30C",
    "hex_end": "$30F",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location_range",
    "text": "Location Range: 780-783 ($30C-$30F)\nRegister Storage Area\n\nThe BASIC SYS command uses this area to store 6510 internal\nregisters--the Accumulator (.A), the .X and .Y index registers, and\nthe status register, .P.\n\nBefore every SYS command, each of the registers is loaded with the\nvalue found in the corresponding storage address.  After the ML\nprogram finished executing, and returns to BASIC with an RTS\ninstruction, the new value of each register is stored in the\nappropriate storage address.  This is only true of SYS, not of the\nsimilar USR command.\n\nThis feature allows you to place the necessary preentry values into\nthe registers from BASIC before you SYS to a Kernal or BASIC ML\nroutine.  It also enables you to examine the resulting effect of the\nroutine on the registers, and to preserve the condition of the\nregisters on exit for subsequent SYS calls.\n\nAn extremely practical application comes immediately to mind.\nAlthough the 64's BASIC 2 has many commands for formatting printed\ncharacters on the monitor screen (for example, TAB, SPC, PRINT A$,B),\nthere is none to adjust the vertical cursor position.\n\nThere is a Kernal routine, PLOT (58634, $E50A), which will allow you\nto position the cursor anywhere on the screen.  In order to use it,\nyou must first clear the carry flag (set it to 0), and then place the\ndesired horizontal column number in the .Y register and the vertical\nrow number in the .X register before entering the routine with a SYS\n65520.  Using the register storage area, we can print the work HELLO\nat row 10, column 5 with the following BASIC line:\n\nPOKE 781,10:POKE 782,5:POKE 783,0:SYS 65520:PRINT \"HELLO\"\n\nYou can also use these locations to help you take advantage of Kernal\nroutines that return information in the register.  For example, the\nSCREEN routine (58629,$E505) returns the number of screen rows int he\n.Y register, and the number of columns in the .X register.  Using this\nroutine, a BASIC program could be written to run on machines with\ndifferent screen formats (for example, the 64 and the VIC-20).  Just\nPEEK(781) after a SYS 65517 to see how many screen columns the\ncomputer display has."
  },
  {
    "id": "map-30C",
    "address_start": 780,
    "address_end": 780,
    "hex_start": "$30C",
    "hex_end": "$30C",
    "label": "SAREG",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "780           $30C           SAREG\nStorage Area for .A Register (Accumulator)"
  },
  {
    "id": "map-30D",
    "address_start": 781,
    "address_end": 781,
    "hex_start": "$30D",
    "hex_end": "$30D",
    "label": "SXREG",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "781           $30D           SXREG\nStorage Area for .X Index Register"
  },
  {
    "id": "map-30E",
    "address_start": 782,
    "address_end": 782,
    "hex_start": "$30E",
    "hex_end": "$30E",
    "label": "SYREG",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "782           $30E           SYREG\nStorage Area for .Y Index Register"
  },
  {
    "id": "map-30F",
    "address_start": 783,
    "address_end": 783,
    "hex_start": "$30F",
    "hex_end": "$30F",
    "label": "SPREG",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "783           $30F           SPREG\nStorage Area for .P (Status) Register\n\nThe Status (.P) register has seven different flags.  Their bit\nassignments are as follows:\n\nBit 7 (bit value of 128) = Negative\nBit 6 (bit value of 64)  = Overflow\nBit 5 (bit value of 32)  = Not Used\nBit 4 (bit value of 16)  = BREAK\nBit 3 (bit value of 8)   = Decimal\nBit 2 (bit value of 4)   = Interrupt Disable\nBit 1 (bit value of 2)   = Zero\nBit 0 (bit value of 1)   = Carry\n\nIf you wish to clear any flag before a SYS, it is safe to clear them\nall with a POKE 783,0.  The reverse is not true, however, as you must\nwatch out for the Interrupt disable flag.\n\nA 1 in this flag bit is equal to an SEI instruction, which turns off\nall IRQ interrupts (like the one that reads the keyboard, for\nexample).  Turning off the keyboard could make the computer very\ndifficult to operate!  To set all flags except for Interrupt disable\nto 1, POKE 783,247."
  },
  {
    "id": "map-310",
    "address_start": 784,
    "address_end": 784,
    "hex_start": "$310",
    "hex_end": "$310",
    "label": "USRPOK",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "784           $310           USRPOK\nJump Instruction for User Function ($4C)\n\nThe value here (67, $4C) is first part of the 6510 machine language\nJuMP instruction for the USR command."
  },
  {
    "id": "map-311-312",
    "address_start": 785,
    "address_end": 786,
    "hex_start": "$311",
    "hex_end": "$312",
    "label": "USRADD",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "785-786       $311-$312      USRADD\nAddress of USR Routine (Low Byte First)\n\nThese locations contain the target address of the USR command.  They\nare initialized by the Operating System to point to the BASIC error\nmessage handler routine, so that if you try to execute a USR call\nwithout changing these values, you wil receive an ILLEGAL QUANTITY\nerror message.\n\nIn order to successfully execute a USR call, you must first POKE in\nthe target address in low-byte, high-byte order.  You can calculate\nthese two values for any address with the formula:\n\nHI=INT(AD/256):LO=AD-(HI*256)\n\nFor example, if the USR routine started at 49152 ($C000), you would\nPOKE 786, INT(49152/256):POKE 785,49152-(PEEK(786)*256 before\nexecuting the USR command.\n\nWhat makes the USR command different from SYS is that you can pass a\nparameter into the machine language routine by placing it in\nparenthesis after the USR keyword, and you can pass a parameter back\nto a variable by assigning its value to the USR function.\n\nIn other words, the statement X=USR(50) will first put the number 50\nin floating point format into the Floating Point Accumulator (FAC1) at\n97-102 ($61-$66).  Then, the machine language program designated by\nthe address at this vector will be executed.  Finally, the variable X\nwill be assigned the floating point value which ends up in FAC1 after\nthe user-written routine is finished.\n\nSince floating point representation is difficult to work with, it is\nhandy to change these floating point parameters into integers before\nworking with them.  Fortunately, there are vectored routines which\nwill do the conversions for you.  The routine vectored at locations\n3-4 converts the number in FAC1 to a two-byte signed integer, with the\nlow byte in the .Y register (and location 101 ($65)) and the high byte\nin the Accumulator (.A).  Remember, that number is converted to a\nsigned integer in the range between 32767 and -32768, with Bit 7 of\nthe high byte used to indicate the sign.\n\nTo pass a value back through the USR function, you need to place the\nnumber into FAC1.  To conert a signed integer to floating point\nformat, place the high byte into the Accumulator (.A), the low byte\ninto the .Y register, and jump through the vector at locations 5-6\nwith a JMP ($0005) instruction.  The floating point result will be\nleft in FAC1."
  },
  {
    "id": "map-314-315",
    "address_start": 788,
    "address_end": 789,
    "hex_start": "$314",
    "hex_end": "$315",
    "label": "CINV",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "788-789       $314-$315      CINV\nVector to IRQ Interrupt Routine\n\nThis vector points to the address of the routine that is executed when\nan IRQ interrupt occurs (normally 59953 ($FA31)).\n\nAt power on, the CIA #1 Timer B is set to cause an IRQ interrupt to\noccur every 1/60 second.  This vector is set to point to the routine\nwhich updates the software clock and STOP key check, blinks the\ncursor, maintains the tape interlock, and reads the keyboard.  By\nchanging this vector, the user can add or substitute a machine\nlanguage routine that will likewise execute every 1/60 second.  The\nuser who is writing IRQ interrupt routines should consider the\nfollowing:\n\n1.  It is possible for an IRQ interrupt to occur while you are\nchanging this vector, which would cause an error from which no\nrecovery could be made.  Therefore, you must disable all IRQ\ninterrupts before changing the contents of this location, and reenable\nthem afterwards, by using the 6510 SEI and CLI instructions, or by\nusing the Kernal VECTOR routine (64794, $FD1A) to set this vector.\n\n2.  There is some code in ROM that is executed before the interrupt\nroutine is directed through this vector.  This code checks whether the\nsource of the interrupt was an IRQ or BRK instruction.  If first\npreserves the contents of all the registers by pushing them onto the\nstack in the following sequence:  PHA, TXA, PHA, TYA, PHA.  It is up\nto the user to restore the stack at the end of his routine, either by\nexiting through the normal IRQ, or with the sequence:  PLA, TAY, PLA,\nTAX, PLA, RTI.\n\n3.  There is only one IRQ vector, but there are many sources for IRQ\ninterrupts (two CIA chips, and several VIC chip IRQs).  If you plan to\nenable IRQs from more than one source, the IRQ routine here must\ndetermine the source, and continue the routine in the appropriate\nplace for an IRQ from that source.\n\nIn the same vein, if you replace the normal IRQ routine with your own,\nyou should be aware that the keyboard's scanning and clock update will\nnot occur unless you call the old interrupt routine once every 1/60\nsecond.  It is suggested that if you plan to use that routine, you\nsave the old vector address in some other location.  In that way, you\ncan JuMP to the keyboard interrupt routine through this alternate\nvector, rather than assuming that the ROM address will never change\nand that it is safe to jump into the ROM directly."
  },
  {
    "id": "map-316-317",
    "address_start": 790,
    "address_end": 791,
    "hex_start": "$316",
    "hex_end": "$317",
    "label": "CBINV",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "790-791       $316-$317      CBINV\nVector: BRK Instruction Interrupt\n\nThis vector points to the address of the routine which will be\nexecuted anytime that a 6510 BRK instruction (00) is encountered.\n\nThe default value points to a routine that calls several of the Kernal\ninitialization routines such as RESTOR, IOINIT and part of CINT, and\nthen jumps through the BASIC warm start vector at 40962.  This is the\nsame routine that is used when the STOP and RESTORE keys are pressed\nsimultaneously, and is currently located at 65126 ($Fe66).\n\nA machine language monitor program will usually change this vector to\npoint to the monitor warm start address, so that break points may be\nset that will return control to the monitor for debugging purposes."
  },
  {
    "id": "map-318-319",
    "address_start": 792,
    "address_end": 793,
    "hex_start": "$318",
    "hex_end": "$319",
    "label": "NMINV",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "792-793       $318-$319      NMINV\nVector: Non-Maskable Interrupt\n\nThis vector points to the address of the routine that will be executed\nwhen a Non-Maskable Interrupt (NMI) occurs (currently at 65095\n($FE47)).\n\nThere are two possible sources for an NMI interrupt.  The first is the\nRESTORE key, which is connected directly to the 6510 NMI line.  The\nsecond is CIA #2, the interrupt line of which is connected to the 6510\nNMI line.\n\nWhen an NMI interrupt occurs, a ROM routine sets the Interrupt disable\nflag, and then jumps through this RAM vector.  The default vector\npoints to an interrupt routine which checks to see what the cause of\nthe NMI was.\n\nIf the cause was CIA #2, the routine checks to see if one of the\nRS-232 routines should be called.  If the source was the RESTORE key,\nit checks for a cartridge, and if present, the cartridge is entered at\nthe warm start entry point.  If there is no cartridge, the STOP key is\ntested.  If the STOP key was pressed at the same time as the RESTORE\nkey, several of the Kernal initialization routines such as RESTOR,\nIOINIT and part of CINT are executed, and BASIC is entered through its\nwarm start vector at 40962.  If the STOP key was not pressed\nsimultaneously with the RESTORE, the interrupt will end without\nletting the user know that anything happened at all when the RESTORE\nkey was pressed.\n\nSince this vector controls the outcome of pressing the RESTORE key, it\ncan be used to disable the STOP/RESTORE sequence.  A simple way to do\nthis is to change this vector to point to the RTI instruction.  A\nsimple POKE 792,193 will accomplish this.  To set the vector back,\nPOKE 792,71.  Note that this will cut out all NMIs, including those\nrequired for RS-232 I/O."
  },
  {
    "id": "map-31A-32D",
    "address_start": 794,
    "address_end": 813,
    "hex_start": "$31A",
    "hex_end": "$32D",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location_range",
    "text": "Location Range: 794-813 ($31A-$32D)\nKernal Indirect Vectors\n\nThere are 39 Kernal routines for which there are vectors in the jump\ntable located at the top of the ROM (65409, $FF81).  For ten of these\nroutines, the jump table entry contains a machine language instruction\nto jump to the address pointed to by the RAM vector in this table.\nThe addresses in this table are initialized to point to the\ncorresponding routines in the Kernal ROM.  Since these addresses are\nin RAM, however, any entry in this table may be changed.  This enables\nthe user to add to these routines, or to replace them completely.\n\nYou will notice, for example, that many of these routines involve\nInput/ Output functions.  By changing the vectors  to these routines,\nit is possible to support new I/O devices, such as an IEEE disk drive\nused through an adapter.\n\nThe user should be cautioned that since some of these routines are\ninterrupt-driven, it is dangerous to change these vectors without\nfirst turning off all interrupts.  For a safe method of changing all\nof these vectors at one time, along with the interrupt vectors above,\nsee the entry for the Kernal VECTOR routine at 64794 ($FD1A).\n\nMore specific information about the individual routines can be found\nin the descriptions given for their ROM locations."
  },
  {
    "id": "map-31A-31B",
    "address_start": 794,
    "address_end": 795,
    "hex_start": "$31A",
    "hex_end": "$31B",
    "label": "IOPEN",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "794-795       $31A-$31B      IOPEN\nVector to Kernal OPEN Routine (Currently at 62282 ($F34A))"
  },
  {
    "id": "map-31C-31D",
    "address_start": 796,
    "address_end": 797,
    "hex_start": "$31C",
    "hex_end": "$31D",
    "label": "ICLOSE",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "796-797       $31C-$31D      ICLOSE\nVector to Kernal CLOSE Routine (Currently at 62097 ($F291))"
  },
  {
    "id": "map-31E-31F",
    "address_start": 798,
    "address_end": 799,
    "hex_start": "$31E",
    "hex_end": "$31F",
    "label": "ICHKIN",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "798-799       $31E-$31F      ICHKIN\nVector to Kernal CHKIN Routine (Currently at 61966 ($F20E))"
  },
  {
    "id": "map-320-321",
    "address_start": 800,
    "address_end": 801,
    "hex_start": "$320",
    "hex_end": "$321",
    "label": "ICKOUT",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "800-801       $320-$321      ICKOUT\nVector to Kernal CKOUT Routine (Currently at 62032 ($F250))"
  },
  {
    "id": "map-322-323",
    "address_start": 802,
    "address_end": 803,
    "hex_start": "$322",
    "hex_end": "$323",
    "label": "ICLRCH",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "802-803       $322-$323      ICLRCH\nVector to Kernal CLRCHN Routine (Currently at 62259 ($F333))"
  },
  {
    "id": "map-324-325",
    "address_start": 804,
    "address_end": 805,
    "hex_start": "$324",
    "hex_end": "$325",
    "label": "IBASIN",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "804-805       $324-$325      IBASIN\nVector to Kernal CHRIN Routine (Currently at 61783 ($F157))"
  },
  {
    "id": "map-326-327",
    "address_start": 806,
    "address_end": 807,
    "hex_start": "$326",
    "hex_end": "$327",
    "label": "IBSOUT",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "806-807       $326-$327      IBSOUT\nVector to Kernal CHROUT Routine (Currently at 61898 ($F1CA))"
  },
  {
    "id": "map-328-329",
    "address_start": 808,
    "address_end": 809,
    "hex_start": "$328",
    "hex_end": "$329",
    "label": "ISTOP",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "808-809       $328-$329      ISTOP\nVector to Kernal STOP Routine (Currently at 63213 ($F6ED))\n\nThis vector points to the address of the routine that tests the STOP\nkey.  The STOP key can be disabled by changing this with a POKE\n808,239.  This will not disable the STOP/RESTORE combination, however.\nTo disable both STOP and STOP/ RESTORE, POKE 808,234 (POKEing 234 here\nwill cause the LIST command not to function properly).  To bring\nthings back to normal in either case, POKE 808, 237."
  },
  {
    "id": "map-32A-32B",
    "address_start": 810,
    "address_end": 811,
    "hex_start": "$32A",
    "hex_end": "$32B",
    "label": "IGETIN",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "810-811       $32A-$32B      IGETIN\nVector to Kernal GETIN Routine (Currently at 61758 ($F13E))"
  },
  {
    "id": "map-32C-32D",
    "address_start": 812,
    "address_end": 813,
    "hex_start": "$32C",
    "hex_end": "$32D",
    "label": "ICLALL",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "812-813       $32C-$32D      ICLALL\nVector to Kernal CLALL Routine (Currently at 62255 ($F32F))"
  },
  {
    "id": "map-32E-32F",
    "address_start": 814,
    "address_end": 815,
    "hex_start": "$32E",
    "hex_end": "$32F",
    "label": "USRCMD",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "814-815       $32E-$32F      USRCMD\nVector to User-Defined Command (Currently Points to BRK at 65126\n($FE66))\n\nThis appears to be a holdover from PET days, when the built-in machine\nlanguage monitor would JuMP through the USRCMD vector when it\nencountered a command that it did not understand, allowing the user to\nadd new commands to the monitor.\n\nAlthough this vector is initialized to point to the routine called by\nSTOP/ RESTORE and the BRK interrupt, and is updated by the Kernal\nVECTOR routine (64794, $FD1A), it does not seem to have the function\nof aiding in the addition of new commands."
  },
  {
    "id": "map-330-331",
    "address_start": 816,
    "address_end": 817,
    "hex_start": "$330",
    "hex_end": "$331",
    "label": "ILOAD",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "816-817       $330-$331      ILOAD\nVector to Kernal LOAD Routine (Currently at 62622 ($F49E))"
  },
  {
    "id": "map-332-333",
    "address_start": 818,
    "address_end": 819,
    "hex_start": "$332",
    "hex_end": "$333",
    "label": "ISAVE",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "818-819       $332-$333      ISAVE\nVector: Kernal SAVE Routine (Currently at 62941 ($F5DD))"
  },
  {
    "id": "map-334-33B",
    "address_start": 820,
    "address_end": 827,
    "hex_start": "$334",
    "hex_end": "$33B",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "820-827       $334-$33B\nUnused\n\nEight free bytes for user vectors or other data."
  },
  {
    "id": "map-33C-3FB",
    "address_start": 828,
    "address_end": 1019,
    "hex_start": "$33C",
    "hex_end": "$3FB",
    "label": "TBUFFER",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "828-1019      $33C-$3FB      TBUFFER\nCassette I/O Buffer\n\nThis 192-byte buffer area is used to temporarily hold data that is\nread from or written to the tape device (device number 1).\n\nWhen not being used for tape I/O, the cassette buffer has long been a\nfavorite place for Commodore programmers to place short machine\nlanguage routines (although the 64 has 4K of unused RAM above the\nBASIC ROM at 49152 ($C000) that would probably better serve the\npurpose).\n\nOf more practical interest to the 64 programmer is the possible use of\nthis area for VIC-II chip graphics memory (for example, sprite shape\ndata or text character dot data).  If the VIC-II chip is banked to the\nlowest 16K of memory (as is the default selection), there is very\nlittle memory space which can be used for such things as sprite shape\ndata without conflict.  If the tape is not in use, locations 832-895\n($340-$37F) can be used as sprite data block number 13, and locations\n896-959 ($380-$3BF) can be used as sprite data block number 14.\n\nThe types of tape blocks that can be stored here are program header\nblocks, data header blocks, and data storage blocks.\n\nThe first byte of any kind of block (which is stored at location 828\n($33C)) identifies the block type.  Header blocks follow this\nidentifier byte with the two-byte starting RAM address of the tape\ndata, the two-byte ending RAM address, and the filename, padded with\nblanks so that the total length of the name portion equals 187 bytes.\nData storage blocks have 191 bytes of data following the identifier\nbyte.  The meanings of the various identifier blocks are as follows:\n\nA value of 1 signifies that the block is the header for a relocatable\nprogram file, while a value of 3 indicates that the block is the\nheader for a nonrelocatable program file.\n\nA relocatable file is created when a program is SAVEd with a secondary\naddress of 0 (or any even number), while a nonrelocatable program file\nis created if the secondary SAVE address is 1 (or any odd number).\nThe difference between the two types of files is that a nonrelocatable\nprogram will always load at the address specified in the header.  A\nrelocatable program will load at the current start of BASIC address\nunless the LOAD statement uses a secondary address of 1, in which case\nit will also be loaded at the addrss specified in the header.\n\nYou should note that a program file uses the cassette buffer only to\nstore the header block.  Actual program data is transferred directly\nto or from RAM, without first being buffered.\n\nAn identifier value of 4 means that the block is a data file header.\nSuch a header block is stored in the cassette buffer whenever a BASIC\nprogram OPENs a tape data file for reading or writing.  Subsequent\ndata blocks start with an identifier byte of 2.  These blocks contain\nthe actual data byte written by the PRINT #1 command, and read by the\nGET #1 and INPUT #1 commands.  Unlike the body of a program file,\nthese blocks are temporarily stored in the cassette byffer when being\nwritten or read.\n\nAn identifier byte of 5 indicates that this block is the logical end\nof the tape.  This signals the Kernal not to search past this point,\neven if there are additional tape blocks physically present on the\ntape."
  },
  {
    "id": "map-3FC-3FF",
    "address_start": 1020,
    "address_end": 1023,
    "hex_start": "$3FC",
    "hex_end": "$3FF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 3      ::",
    "type": "location",
    "text": "1020-1023     $3FC-$3FF\nUnused\n\nFour more free bytes.\n\n\n::::::::::::::::::::::::\n::                    ::\n::     1K to 40K      ::\n::                    ::\n::   Screen Memory,   ::\n::Sprite Pointers, and::\n:: BASIC Program Text ::\n::::::::::::::::::::::::"
  },
  {
    "id": "map-400-7FF",
    "address_start": 1024,
    "address_end": 2047,
    "hex_start": "$400",
    "hex_end": "$7FF",
    "label": "VICSCN",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 4      ::",
    "type": "location",
    "text": "1024-2047     $400-$7FF      VICSCN\nVideo Screen Memory Area\n\nThis is the default location of the video screen memory area, which\ncontains the video matrix and the sprite data pointers.  Keep in mind,\nhowever, that the video screen memory area can be relocated to start\non any even 1K boundary.  Its location at any given moment is\ngetermined by the VIC-II chip memory control register at 53272\n($D018), and the VIC-II memory bank select bits on CIA #2 Data Port A\n(56576, $DD00)."
  },
  {
    "id": "map-400-7E7",
    "address_start": 1024,
    "address_end": 2023,
    "hex_start": "$400",
    "hex_end": "$7E7",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 4      ::",
    "type": "location",
    "text": "1024-2023     $400-$7E7\nVideo Matrix: 25 Lines by 40 Columns\n\nThe video matrix is where thext screen characters are stored in RAM.\nNormally, the VIC-II chip will treat each byte of memory here as a\nscreen display code and will display the text character that\ncorresponds to that byte of code.  The first byte of memory here will\nbe displayed in the top-left corner of the screen, and subsequent\nbytes will be displayed in the columns to the right and the rows below\nthat character.\n\nIt is possible to make text or graphics characters appear on the\nscreen by POKEing their screen codes directly into this area of RAM.\nFor example, the letter A has a screen code value of 1.  Therefore,\nPOKE 1024,1 should make the letter A appear in the top-left corner of\nthe screen.\n\nHowever, you should be aware that the most current version of the\nOperating System initializes the color RAM which is used for the\nforeground color of text characters to the same value as the\nbackground color every time that the screen is cleared.  The result is\nthat although the POKE will put a blue A on the screen, you won't be\nable to see it because it is the same color blue as the background.\nThis can be remedied by POKEing a different value into color RAM\n(which starts at 55296 ($D800)).\n\nA POKE 1024,1:POKE 1024+54272,1 will put a white A in the upper-left\ncorner of the screen.  The loop\n\nFOR I=0 TO 255:POKE 1024+I,I:POKE 1024+54272+I,1:NEXT\n\nwill display all of the characters in white at the top of the screen.\nAnother solution to the color RAM problem is to fool the Operating\nSystem into initializing the color RAM for you.  If you change the\nbackground color to the desired foreground color before you clear the\nscreen, color RAM will be set to that color.  Then, all you have to do\nis change the background color back to what it was.  This example will\nshow how it's done:\n\n10 POKE 53281,2:REM BACKGROUND IS RED\n20 PRINT CHR$(147):REM CLEAR SCREEN\n30 POKE 53281,1:REM BACKGROUND IS WHITE\n40 POKE 1024,1:REM RED \"A\" APPEARS IN TOP LEFT CORNER"
  },
  {
    "id": "map-7F8-7FF",
    "address_start": 2040,
    "address_end": 2047,
    "hex_start": "$7F8",
    "hex_end": "$7FF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 4      ::",
    "type": "location",
    "text": "2040-2047     $7F8-$7FF\nSprite Shape Data Pointers\n\nThe last eight bytes of the video matrix (whether it is here at the\ndefault location, or has been relocated elsewhere) are used as\npointers to the data blocks used to define the sprite shapes.\n\nEach sprite is 3 bytes wide (24 bits) by 21 lines high.  It therefore\nrequires 63 bytes for its shape definition, but it actually uses 64\nbytes in order to arrive at an even 256 shape blocks in the 16K area\nof RAM which the VIC-II chip addresses.\n\nEach pointer holds the current data block being used to define the\nshape of one sprite.  The block numver used to define the shape of\nSprite 0 is held in location 2040 ($7F8), the Sprite 1 shape block is\ndesignated by location 2041 ($7F9), etc.  The value in the pointer\ntimes 64 equals the starting location of the sprite shape data table.\nFor example, a value of 11 in location 2040 indicates that the shape\ndata for Sprite 0 starts at address 704 (11*64), and continues for 63\nmore bytes to 767.\n\nFor additional information on sprite graphics, see the entries for\nindividual VIC-II chip sprite graphics locations, and the summary at\nthe beginning of the VIC-II chip section, at 53248 ($D000)."
  },
  {
    "id": "map-800-9FFF",
    "address_start": 2048,
    "address_end": 40959,
    "hex_start": "$800",
    "hex_end": "$9FFF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 4      ::",
    "type": "location",
    "text": "2048-40959    $800-$9FFF\nBASIC Program Text\n\nThis is the area where the actual BASIC program text is stored.  The\ntext of a BASIC program consists of linked lines of program tokens.\nEach line contains the following:\n\n1.  A two-byte pointer to the address of the next program line (in\nstandard low-byte, high-byte order).  After the last program line, a\nlink pointer consisting of two zeros marks the end of the program.\n\n2.  A two-byte line number (also in low-byte, high-byte order).\n\n3.  The program commands.  Each keyword is stored as a one-byte\ncharacter whose value is equal to or greater than 128.  Print, for\nexample, is stored as the number 151.  Other elements of the BASIC\ncommand, such as the variable names, string literals (\"HELLO\"), and\nnumbers, are stored using their ASCII equivalents.\n\n4.  A 0 character, which acts as a line terminator.  In order for\nBASIC to work correctly, the first character of the BASIC text area\nmust be 0.\n\nA quick review of the BASIC pointers starting at 43 ($2B) reveals that\nthe layout of the BASIC program area (going from lower memory\naddresses to higher) is as follows:\n\nBASIC Program Text\nNon-Array Variables and String Descriptors\nArray Variables\nFree Area (Reported by FRE(0))\nString Text Area (Strings build from top of memory down into free area)\nBASIC ROM\n\nIt is interesting to note that the NEW command does not zero out the\ntext area but rather replaces the first link address in the BASIC\nprogram with two zeros, indicating the end of the program.  Therefore,\nyou can recover a program from a NEW by replacing the first link\nadress, finding the address of the two zeros that actually mark the\nend of the program, and setting the pointers at 45, 47, and 49 (which\nall point to the end of a BASIC program before the program is RUN) to\nthe byte following these zeros."
  },
  {
    "id": "map-1000-1FFF",
    "address_start": 4096,
    "address_end": 8191,
    "hex_start": "$1000",
    "hex_end": "$1FFF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 4      ::",
    "type": "location",
    "text": "4096-8191     $1000-$1FFF\nCharacter ROM Image for VIC-II Chip When Using Memory Bank 0 (Default)\n\nThough the VIC-II chip shares memory with the 6510 processor chip, it\ndoes not always see that memory in exactly the same way as the main\nmicroprocessor.\n\nAlthough the 6510 accesses RAM at these locations, when the VIC-II is\nbanked to use the first 16K of RAM (which is the default condition),\nit sees the character ROM here (the 6510 cannot access this ROM unless\nit is switched into its memory at 49152 ($C000)).  This solves the\nriddle of how the VIC-II chip can use the character ROM at 49152\n($C000) for character shape data and RAM at 1024 ($400), when it can\nonly address memory within a 16K range.  It also means that the RAM at\n4096-8191 cannot be used for screen display memory or user-defined\ncharacter dot data, and sprite data blocks 64-127 are not accessible.\n\nYou can verify this by turning on bitmap graphics with the screen\nmemory set to display addresses from 0 to 8192.  You will see that the\nbottom portion of the screen shows all of the text character shapes\nstored in the ROM.  For more information on the format of text\ncharacter data storage, see the description of the Character ROM at\n49152 ($C000)."
  },
  {
    "id": "map-8000",
    "address_start": 32768,
    "address_end": 32768,
    "hex_start": "$8000",
    "hex_end": "$8000",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 4      ::",
    "type": "location",
    "text": "32768         $8000\nAutostart ROM Cartridge\n\nAn 8K or 16K autostart ROM cartridge designed to use this as a\nstarting memory address may be plugged into the Expansion Port on the\nback.  If the cartridge ROM at locations 32772-32776 ($8004-$8008)\ncontains the numbers 195, 194, 205, 56, 48 ($C3, $C2, $CD, $38, $30)\nwhen the computer powers up, it will start the program pointed to by\nthe vector at locations 32768-32769 ($8000-$8001), and will use\n32770-32771 ($8002-$8003) for a warm start vector when the RESTORE key\nis pressed.  These characters are PETASCII for the inverse letters\nCBM, followed by the digits 80.  An autostart cartridge may also be\naddressed at 40960 ($A000), where it would replace BASIC, or at 61440\n($F000), where it would replace the Kernal.\n\nIt is possible to have a 16K cartridge sitting at 32768 ($8000), such\nas Simon's BASIC, which can be turned on and off so that the BASIC ROM\nunderneath can also be used.  Finally, it is even possible to have\nbank-selected cartridges, which turn banks of memory in the cartidge\non and off alternately, so that a 32K program could fit into only 16K\nof addressing space."
  },
  {
    "id": "map-9000-9FFF",
    "address_start": 36864,
    "address_end": 40959,
    "hex_start": "$9000",
    "hex_end": "$9FFF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::     Chapter 4      ::",
    "type": "location",
    "text": "36864-40959   $9000-$9FFF\nCharacter ROM Image for VIC-II Chip When Using Memory Bank 2\n\nWhen the VIC-II chip is set up to use the third 16K block of memory\nfor graphics (as would be the case when the 64 is set up to emulate\nthe PET, which has its text screen memory at 32768 ($8000), it sees\nthe character generator ROM at this address (see entry at 4096 ($1000)\nabove for more details).\n\nIt should be noted that the character ROM is available only when the\nVIC-II chip is using banks 0 or 2.  When using one of the other two\nbanks, the user must supply all of the character shape data in a RAM\ntable.\n\n\n::::::::::::::\n::          ::\n:: 8K BASIC ::\n::ROM and 4K::\n:: Free RAM ::\n::::::::::::::\n\nLocations 40960 to 49152 ($A000 to $BFFF) are used by the BASIC ROM\nwhen it is selected (which is the default condition).  BASIC is the\n64's main program, which is always run if there is no autostart\ncartridge inserted at power-up time.  When the 64 tells you READY,\nthat's BASIC talking.\n\nThe BASIC interpreter that comes with the 64 is, aside from being\nlocated in a different memory space, almost identical to the Microsoft\nBASIC interpreter found on the VIC-20.  Both of these interpreters are\nslightly modified versions of PET BASIC 2.0, also known as PET BASIC\n3.0 or Upgrade BASIC, because it was an upgraded version of the BASIC\nfound on the original PET.\n\nThis is a somewhat mixed blessing, because while PET BASIC was, in its\nday, quote an advanced language for use with an eight-bit\nmicroprocessor, it lacks several of the features (such as error\ntrapping) which are now standard on most home computers.  And, of\ncourse, it makes no provision whatever for easy use of the many\ngraphics and sound capabilities made available by the new dedicated\nvideo and sound support chips.\n\nOn the other hand, its faithfulness to the original Commodore BASIC\nallows a large body of software to be translated for the 64 with\nlittle change (in most cases, the PET Emulator program from Commodore\nwill allow you to run PET programs with no changes).  Programming aids\nand tricks developed for the PET and VIC will, for the most part,\ncarry over quite nicely to the 64.  Although there is no official\nsource code listing of the ROM available from Commodore, this version\nof BASIC has been around long enough that it has been thoroughly\ndisassembled, dissected, and documented by PET users.\n\nThe labels used here correspond to those used by Jim Butterfield in\nhis PET memory maps, which are well-known among PET BASIC users.  They\nshould, therefore, provide some assistance in locating equivalent\nroutines on the two machines.  A good description of the workings of\nPET BASIC can be found in Programming the PET/CBM by Raeto West.\n\nIt is beyond the scope of this book to detail the inner workings of\neach routine in the BASIC interpreter.  However, the following summary\nof routines and their functions should aid the user who is interested\nin calling BASIC routines from his or her own program, or in modifying\nthe BASIC.\n\nPlease keep in mind that the entry and exit points listed for routines\nthat perform a particular function are to be used as guideposts, and\nnot absolutes.  In fact, BASIC enters many of these routines from\nslightly different places to accomplish different tasks.  Some\nsubroutines are called by so many commands that it is hard to say\nwhich they belong to.  You will even find that some whole commands are\npart of other commands.  Where it is important for you to know the\ndetails of a particular routine, you will need to obtain a disassembly\nof that section and look at the machine language program itself.\n\nIt should be noted that when BASIC is not neede,d it can be switched\nout and the RAM underneath can be accessed by the VIC-II chip and used\nfor screen graphics.  See location 56576 ($DD00) for more information."
  },
  {
    "id": "map-A000-A001",
    "address_start": 40960,
    "address_end": 40961,
    "hex_start": "$A000",
    "hex_end": "$A001",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "40960-40961   $A000-$A001\nCold Start Vector\n\nThis vector points to the address of the routine used to initialize\nBASIC.  After the Operating System finishes its power-on activities,\nit enters the BASIC program through this vector.  The most visible\neffect of the BASIC initialization routine is that the screen is\ncleared, and the words:\n\n     **** COMMODORE 64 BASIC V2 ****\n\nare printed along with the BYTES FREE message.  For details of the\nsteps taken during the initialization of BASIC, see the entry for\n58260 ($E394), the current cold start entry point."
  },
  {
    "id": "map-A002-A003",
    "address_start": 40962,
    "address_end": 40963,
    "hex_start": "$A002",
    "hex_end": "$A003",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "40962-40963   $A002-$A003\nWarm Start Vector\n\nThe warm start vector points to the address of the routines used to\nreset BASIC after the STOP/RESTORE key combination is pressed.  This\nis the same address to which the BRK instruction is vectored.  When\nBASIC is entered through this vector, the program in memory is not\ndisturbed.  For more information, see the entry for 58235 ($E37B), the\ncurrent warm start entry point."
  },
  {
    "id": "map-A004-A00B",
    "address_start": 40964,
    "address_end": 40971,
    "hex_start": "$A004",
    "hex_end": "$A00B",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "40964-40971   $A004-$A00B\nASCII Text characters CBMBASIC\n\nThe ASCII characters for the letters CBMBASIC are located here.\nPossibly an identifier, this text is not referenced elsewhere in the\nprogram.\n\n40972041941   $A00C-$A051    STMDSP\nStatement Dispatch Vector Table\n\nThis table contains two-byte vectors, each of which points to an\naddress which is one byte before the address of one of the routines\nthat perform a BASIC statement.\n\nThe statements are in token number order.  When it comes time to\nexecute a statement, the NEWSTT routine at 42926 ($A7AE) places this\naddress-1 on the stack and jumps to the CHRGET routine.  The RTS\ninstruction at the end of that routine causes the statement address to\nbe pulled off the stack, incremented, and placed in the Program\nCounter, just as if it were the actual return address.\n\nThis table is handy for locating the address of the routine that\nperforms a BASIC statement, so that the routine can be disassembled\nand examined.  To aid in this purpose, the table is reproduced below\nwith the actual target address, and not in the address-1 format used\nby BASIC.\n\nToken #   Statement   Routine Address"
  },
  {
    "id": "map-A052-A07F",
    "address_start": 41042,
    "address_end": 41087,
    "hex_start": "$A052",
    "hex_end": "$A07F",
    "label": "FUNDSP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41042-41087   $A052-$A07F    FUNDSP\n                             TABLE\nFunction Dispatch Vector Table\n\nThis table contains two-byte vectors, each of which points to the\naddress of one of the routines that performs a BASIC function.\n\nA function is distinguished by a following argument, in parentheses.\nThe expression in the parentheses is first evaluated by the routines\nwhich begin at 44446 ($AD9E).  Then this table is used to find the\naddress of the function that corresponds to the token number of the\nfunction to be executed.\n\nThe substance of this table, which can be used for locating the\naddresses of these routines, is reproduced below.  Note that the\naddress for the USR function is 784 ($310), which is the address of\nthe JMP instruction which precedes the user-supplied vector.\n\nToken #   Function     Routine Address"
  },
  {
    "id": "map-BD",
    "address_start": 189,
    "address_end": 189,
    "hex_start": "$BD",
    "hex_end": "$BD",
    "label": "EXP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "189 $BD   EXP          49133 $BFED\n180 $BE   COS          57956 $E264"
  },
  {
    "id": "map-A080-A09D",
    "address_start": 41088,
    "address_end": 41117,
    "hex_start": "$A080",
    "hex_end": "$A09D",
    "label": "OPTAB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41088-41117   $A080-$A09D    OPTAB\nOperator Dispatch Vector Table\n\nThis table contains two-byte vectors, each of which points to an\naddress which is one byte before the address of one of the routines\nthat perform a BASIC math operation.\n\nFor the reasoning behind the one-byte offset to the true address, see\nthe entry for location 40972 ($A00C).  In addition, each entry has a\none-byte number which indicates the degree of precedence that\noperation takes.  Operations with a higher degree of precedence are\nperformed before operations of a lower degree (for example, in the\nexpression A=3+4*6, the 4*6 operation is performed first, and 3 is\nadded to the total).  The order in which they are performed is:\n\n1.  Expressions in parentheses\n2.  Exponentation (raising to a power, using the up-arrow symbol)\n3.  Negation of an expression (-5, -A)\n4.  Multiplication and division\n5.  Addition and subtraction\n6.  Relation tests (=, <>, <, >, <=, >= all have the same precedence)\n7.  NOT (logical operation)\n8.  AND (logical operation)\n9.  OR (logical operation)\n\nThe substance of this table, which can be used to locate the addresses\nof the math routines, is given below.  Note that less that, equal, and\ngreater than operators all use the same routines, though they have\ndifferent token numbers.\n\nToken #   Operator           Routine Address"
  },
  {
    "id": "map-A09E-A19D",
    "address_start": 41118,
    "address_end": 41373,
    "hex_start": "$A09E",
    "hex_end": "$A19D",
    "label": "RESLST",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41118-41373   $A09E-$A19D    RESLST\nList of Keywords\n\nThis table contains a complete list of the reserved BASIC keywords\n(those combinations of ASCII text characters that cause BASIC to do\nsomething).  The ASCII text characters of these words are stored in\ntoken number order.  Bit #7 of the last letter of each word is set to\nindicate the end of the word (the last letter has 128 added to its\ntrue ASCII value).\n\nWhen the BASIC program text is stored, this list of words is used to\nreduce any keywords to a single-byte value called a token.  The\ncommand PRINT, for example, is not stored in a program as five ASCII\nbytes, but rather as the single token 153 ($99).\n\nWhen the BASIC program is listed, this table is used to convert these\ntokens back to ASCII text.  The entries in this table consist of the\nfollowing:\n\n1.  The statements found in STMDSP at 40972 ($A00C), in the token\nnumber order indicated (token numbers 128-162).\n\n2.  Some miscellaneous keywords which never begin a BASIC statement:\n\nToken #    Keyword\n162 $A3    TAB("
  },
  {
    "id": "map-A9",
    "address_start": 169,
    "address_end": 169,
    "hex_start": "$A9",
    "hex_end": "$A9",
    "label": "STEP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "169 $A9    STEP\n\n3.  The math operators found in OPTAB at 41088 ($A080), in the token\nnumber order indicated (token numbers 170-179).\n\n4.  The functions found in FUNDSP at 41042 ($A052), in the token\nnumber order indicated (token numbers 182-202).\n\n5.  The word GO (token number 203 ($CB)).  This word was added to the\ntable to make the statement GO TO legal, to afford some compatibility\nwith the very first PET BASIC, which allowed spaces within keywords."
  },
  {
    "id": "map-A19E-A327",
    "address_start": 41374,
    "address_end": 41767,
    "hex_start": "$A19E",
    "hex_end": "$A327",
    "label": "ERRTAB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41374-41767   $A19E-$A327    ERRTAB\nASCII Text of BASIC Error Messages\n\nThis table contains the ASCII text of all of the BASIC error messages.\nAs in the keyword table, Bit 7 of the last letter of each message is\nset to indicate the end of the message.  Although we've all seen some\nof them at one time or another, it's somewhat daunting to see the\nwhole list at once.  The possible errors you can make include:\n\n 1.  TOO MANY FILES\n 2.  FILE OPEN\n 3.  FILE NOT OPEN\n 4.  FILE NOT FOUND\n 5.  DEVICE NOT PRESENT\n 6.  NOT INPUT FILE\n 7.  NOT OUTPUT FILE\n 8.  MISSING FILENAME\n 9.  ILLEGAL DEVICE NUMBER\n10.  NEXT WITHOUT FOR\n11.  SYNTAX\n12.  RETURN WITHOUT GOSUB\n13.  OUT OF DATA\n14.  ILLEGAL QUANTITY\n15.  OVERFLOW\n16.  OUT OF MEMORY\n17.  UNDEF'D STATEMENT\n18.  BAD SUBSCRIPT\n19.  REDIM'D ARRAY\n20.  DIVISION BY ZERO\n21.  ILLEGAL DIRECT\n22.  TYPE MISMATCH\n23.  STRING TOO LONG\n24.  FILE DATA\n25.  FORMULA TOO COMPLEX\n26.  CAN'T CONTINUE\n27.  UNDEF'D FUNCTION\n28.  VERIFY\n29.  LOAD\n\nMessage number 30, BREAK, is located in the Miscellaneous Messages\ntable below."
  },
  {
    "id": "map-A328-A364",
    "address_start": 41768,
    "address_end": 41828,
    "hex_start": "$A328",
    "hex_end": "$A364",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41768-41828   $A328-$A364\nError Message Vector Table\n\nThis table contains the two-byte address of the first letter of each\nof the 30 error messages."
  },
  {
    "id": "map-A365-A389",
    "address_start": 41829,
    "address_end": 41865,
    "hex_start": "$A365",
    "hex_end": "$A389",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41829-41865   $A365-$A389\nMiscellaneous Messages\n\nThe text of some of the other messages that BASIC can give you is\nstored here.  This text includes cursor movement characters, and each\nmessage ends with a 0 character.  The messages are:\n\n1) Carriage return, OK, carriage return\n2) Space, space, ERROR\n3) Space, IN, space\n4) Carriage return, linefeed, READY., carraige return, linefeed\n5) Carriage return, linefeed, BREAK"
  },
  {
    "id": "map-A38A-A3B7",
    "address_start": 41866,
    "address_end": 41911,
    "hex_start": "$A38A",
    "hex_end": "$A3B7",
    "label": "FNDFOR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41866-41911   $A38A-$A3B7    FNDFOR\nFind FOR on Stack\n\nThis routine searches the stack for the blocks of data entries which\nare stored by each FOR command.  For more information on the data that\nFOR places on the stack, see location 256 ($100)."
  },
  {
    "id": "map-A3B8",
    "address_start": 41912,
    "address_end": 41912,
    "hex_start": "$A3B8",
    "hex_end": "$A3B8",
    "label": "BLTU",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41912         $A3B8          BLTU\nOpen a Space in Memory for a New Program Line or Variable\n\nWhen a new nonarray variable is being created, or when a BASIC program\nline is being added or replaced, this routine is used to make room for\nthe addition.  It first checks to see if space is available, and then\nmoves the program text and/or variables to make room."
  },
  {
    "id": "map-A3FB-A407",
    "address_start": 41979,
    "address_end": 41991,
    "hex_start": "$A3FB",
    "hex_end": "$A407",
    "label": "GETSTK",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41979-41991   $A3FB-$A407    GETSTK\nCheck for Space on Stack\n\nBefore undertaking an operation that requires stack space, this\nroutine is used to check if there is enough room on the stack.  If\nthere is not, an OUT OF MEMORY error is issued."
  },
  {
    "id": "map-A408-A434",
    "address_start": 41992,
    "address_end": 42036,
    "hex_start": "$A408",
    "hex_end": "$A434",
    "label": "REASON",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "41992-42036   $A408-$A434    REASON\nCheck for Space in Memory\n\nThis is the subroutine that checks to see if there is enough space in\nfree memory for proposed additions such as new lines of program text.\nIf not, it calls for garbage collection, and if this still does not\nproduce enough space, an OUT OF MEMORY error is issued."
  },
  {
    "id": "map-A435-A468",
    "address_start": 42037,
    "address_end": 42088,
    "hex_start": "$A435",
    "hex_end": "$A468",
    "label": "OMERR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42037-42088   $A435-$A468    OMERR\nOUT OF MEMORY Error Handler\n\nThis routine just sets the error message code, and falls through to\nthe general error handler."
  },
  {
    "id": "map-A437-A468",
    "address_start": 42039,
    "address_end": 42088,
    "hex_start": "$A437",
    "hex_end": "$A468",
    "label": "ERROR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42039-42088   $A437-$A468    ERROR\nGeneral Error Handler\n\nThe error number is passed to this routine in the .X register, and it\ndisplays the appropriate error message.  Since this routine is\nvectored through RAM at 768 ($300), you can divert this vector to the\naddress of your own routine, which would allow error trapping, or the\naddition of new commands.\n\n42089-42099   $A474-$A47F    READY\nPrint READY\n\nThis routine displays the word READY, sets the Kernal message flag to\nshow that direct mode is operative, and falls through to the main\nBASIC loop."
  },
  {
    "id": "map-A480-A49B",
    "address_start": 42112,
    "address_end": 42139,
    "hex_start": "$A480",
    "hex_end": "$A49B",
    "label": "MAIN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42112-42139   $A480-$A49B    MAIN\nMain Loop, Receives Input and Executes Immediately or Stores as\nProgram Line\n\nThis is the main BASIC program loop.  It jumps through the RAM vector\nat 770 ($302), so this routine can be diverted.  The routine gets a\nline of input from the keyboard, and checks for a line number.  If\nthere is a line number, the program branches to the routine that\nstores a line of program text.  If there is no line number, it\nbranches to the routine that executes statements."
  },
  {
    "id": "map-A49C",
    "address_start": 42140,
    "address_end": 42140,
    "hex_start": "$A49C",
    "hex_end": "$A49C",
    "label": "MAIN1",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42140         $A49C          MAIN1\nAdd or Replace a Line of Program Text\n\nThis routine calls subroutines to get the line number, tokenize\nkeywords, and then looks for a line with the same line number.\n\nIf it finds a line with the same number, the routine deletes that line\nby moving all higher program text and variables down to where it\nstarted.  The new line is then added.  Since the CLR routine is\ncalled, the value of all current program variables is lost."
  },
  {
    "id": "map-A533",
    "address_start": 42291,
    "address_end": 42291,
    "hex_start": "$A533",
    "hex_end": "$A533",
    "label": "LINKPRG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42291         $A533          LINKPRG\nRelink Lines of Tokenized Program Text\n\nEach line of program text starts with a pointer to the address of the\nnext line (link address).  This routine scans each line to the end\n(which is marked with a 0), and calculates the new link address by\nadding the offset to the address of the current statement."
  },
  {
    "id": "map-A560",
    "address_start": 42336,
    "address_end": 42336,
    "hex_start": "$A560",
    "hex_end": "$A560",
    "label": "INLIN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42336         $A560          INLIN\nInput a Line to Buffer from Keyboard\n\nThis subroutine calls the Kernal CHRIN routine (61783, $F157) to\nobtain a line of input from the current input device (usually the\nkeyboard).  It stores the characters in the BASIC text input buffer at\n512 ($200) until a carriage return or 89 characters have been\nreceived.  The keyboard device will never return more than 80\ncharacters before a carriage return, but other devices can output a\nlonger line.  An error will occur if the line goes over 80 characters."
  },
  {
    "id": "map-A579",
    "address_start": 42361,
    "address_end": 42361,
    "hex_start": "$A579",
    "hex_end": "$A579",
    "label": "CRUNCH",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42361         $A579          CRUNCH\nTokenize Line in Input Buffer\n\nWhen a line of program text has been input into the BASIC text buffer\nat 512 ($200), this routine goes through the line and changes any\nkeywords or their abbreviations, which do not appear in quotes, into\ntheir corresponding token.  This command is vectored through RAM at\n772 ($304), so it can be diverted in order to add new commands."
  },
  {
    "id": "map-A613",
    "address_start": 42515,
    "address_end": 42515,
    "hex_start": "$A613",
    "hex_end": "$A613",
    "label": "FINDLN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42515         $A613          FINDLN\nSearch for Line Number\n\nThis routine searches through the program text, trying to match the\ntwo-byte integer line number that is stored in 20-21 ($14-$15).  If it\nis found, 95-96 ($5F-$60) will be set as a pointer to the address of\nthe link field for that line, and the Carry flag will be set.  If it\nis not found, the Carry flag will be cleared."
  },
  {
    "id": "map-A642",
    "address_start": 42562,
    "address_end": 42562,
    "hex_start": "$A642",
    "hex_end": "$A642",
    "label": "SCRTCH",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42562         $A642          SCRTCH\nPerform NEW\n\nThe NEW command stores two zeros in the link address of the first\nprogram line to indicate the end of program, and sets the end of\nprogram pointer at 45-46 ($2D-$2E) to point to the byte past those\nzeros.  It continues through to the CLR command code."
  },
  {
    "id": "map-A65E",
    "address_start": 42590,
    "address_end": 42590,
    "hex_start": "$A65E",
    "hex_end": "$A65E",
    "label": "CLEAR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42590         $A65E          CLEAR\nPerform CLR\n\nThe CLR command closes all I/O files with the Kernal CLALL routine\n(62255, $F32F).  It eliminates string variables by copying the end of\nmemory pointer at 55-56 ($37-$38) to the bottom of strings pointer at\n51-52 ($33-$34).  It also copies the pointer to the end of BASIC\nprogram text at 49-50 ($31-$31) to the pointer to the start of\nnonarray variables at 45-46 ($2D-$2E) and the start of array variables\nat 47-48 ($2F-$30).  This makes these variables unusable (although the\ncontents of these areas are not actually erased).  RESTORE is called\nto set the data pointer back to the beginning, and the stack is\ncleared."
  },
  {
    "id": "map-A68E",
    "address_start": 42638,
    "address_end": 42638,
    "hex_start": "$A68E",
    "hex_end": "$A68E",
    "label": "RUNC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42638         $A68E          RUNC\nReset Pointer to Current Text Character to the Beginning of Program\nText\n\nThis routine resets the CHRGET pointer TXTPTR (122-123, $7A-$7B) so\nthat the next byte of text that the interpreter will read comes from\nthe beginning of program text.\n\n52652         $A69C          LIST\nPerform LIST\n\nThis routine saves the range of lines to be printed in pointers at\n95-96 ($5F- $60) and 20-21 ($14-$15), and then prints them out,\ntranslating any tokens back to their ASCII equivalent."
  },
  {
    "id": "map-A717",
    "address_start": 42775,
    "address_end": 42775,
    "hex_start": "$A717",
    "hex_end": "$A717",
    "label": "QPLOP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42775         $A717          QPLOP\nPrint BASIC Tokens as ASCII Characters\n\nThis is the part of the LIST routine that chagnes one-byte program\ntokens back to their ASCII text characters.  The routine is vectored\nthrough RAM at 774 ($306), so it is possible to list out new command\nwords that you have added by changing this vector to detour through\nyour own routine."
  },
  {
    "id": "map-A742",
    "address_start": 42818,
    "address_end": 42818,
    "hex_start": "$A742",
    "hex_end": "$A742",
    "label": "FOR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42818         $A742          FOR\nPerform FOR\n\nFOR is performed mostly by saving the needed information for the NEXT\npart of the command on the stack (see the entry for 256 ($100) for\ndetails).  This includes the TO termination value, so if the upper\nlimit is a variable, the current value of the variable will be stored,\nand you cannot end the loop early by decreasing the value of the TO\nvariable within the loop (although you can end it early by increasing\nthe value of the FOR variable within the loop).\n\nAlso, since the TO expression is evaluated only once, at the time FOR\nis performed, a statement such as FOR I=1 TO I+100 is valid.  The\nterminating value is not checked until NEXT is executed, so the loop\nstatements always execute at least once.  The variable used by FOR\nmust be a nonarray floating point variable.  Reusing the same FOR\nvariable in a loop that is still active will cause the previous FOR\nloop and all intervening loops to be cancelled."
  },
  {
    "id": "map-A7AE",
    "address_start": 42926,
    "address_end": 42926,
    "hex_start": "$A7AE",
    "hex_end": "$A7AE",
    "label": "NEWSTT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42926         $A7AE          NEWSTT\nSet Up Next Statement for Execution\n\nThis routine tests for the STOP key, updates the pointer to the\ncurrent line number, and positions the text pointer to read the\nbeginning of the statement."
  },
  {
    "id": "map-A7E4",
    "address_start": 42980,
    "address_end": 42980,
    "hex_start": "$A7E4",
    "hex_end": "$A7E4",
    "label": "GONE",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "42980         $A7E4          GONE\nRead and Execute the Next Statement\n\nThis is the routine which gets the next token and executes the\nstatement.  It is vectored through RAM at 776 ($308) to allow the\naddition and execution of new statement tokens.\n\nSince a statement must always start with a token or an implied LET\nstatement, this routine checks to see if the first character is a\nvalid token.  If it is, the address is placed on the stack, so that a\ncall to CHRGET will return to the address of the code that executes\nthe statement (see the table of statement tokens at 40972 ($A00C)).\n\nAn invalid token will cause a SYNTAX ERROR.  A character whose ASCII\nvalue is less that 128 will cause LET to be executed."
  },
  {
    "id": "map-A81D",
    "address_start": 43037,
    "address_end": 43037,
    "hex_start": "$A81D",
    "hex_end": "$A81D",
    "label": "RESTOR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43037         $A81D          RESTOR\nPerform RESTORE\n\nThe RESTORE command simply resetes the DATA pointer at 65-66 ($41-$42)\nfrom the start of BASIC pointer at 43-44 ($2B-$2V)."
  },
  {
    "id": "map-A82C",
    "address_start": 43052,
    "address_end": 43052,
    "hex_start": "$A82C",
    "hex_end": "$A82C",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43052         $A82C\nTest STOP Key for Break in Program\n\nThe Kernal STOP routine is called from here, and if the key is\npressed, the STOP (63213, $F6ED) command, below, is executed.\n\n43055         $A831          END\nPerform END\n\nThe current line number and text pointers are preserved for a possible\nCONT command, and the READY prompt is printed.  If a STOP key break\noccured, the BREAK message is printed first."
  },
  {
    "id": "map-A857",
    "address_start": 43095,
    "address_end": 43095,
    "hex_start": "$A857",
    "hex_end": "$A857",
    "label": "CONT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43095         $A857          CONT\nPerform CONT\n\nThe CONT statement is performed by moving the saved pointers back to\nthe current statement and current text character pointers.  If the\nsaved pointers cannot be retrieved, the CAN'T CONTINUE error statement\nis printed."
  },
  {
    "id": "map-A871",
    "address_start": 43121,
    "address_end": 43121,
    "hex_start": "$A871",
    "hex_end": "$A871",
    "label": "RUN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43121         $A871          RUN\nPerform RUN\n\nRUN is executed by calling the Kernal SETMSG (65048, $FE18) routine to\nset the message flag for RUN mode and performing a CLR to start the\nprogram.  If a line followed RUN, a GOTO is executed after the CLR."
  },
  {
    "id": "map-A883",
    "address_start": 43139,
    "address_end": 43139,
    "hex_start": "$A883",
    "hex_end": "$A883",
    "label": "GOSUB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43139         $A883          GOSUB\nPerform GOSUB\n\nThis statement pushes the pointers to the current text character and\ncurrent line onto the stack, along with a constant 141 ($8D) which\nidentifies the block as saved GOSUB information to be used by RETURN.\nThe GOTO is called."
  },
  {
    "id": "map-A8A0",
    "address_start": 43168,
    "address_end": 43168,
    "hex_start": "$A8A0",
    "hex_end": "$A8A0",
    "label": "GOTO",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43168         $A8A0          GOTO\nPerform GOTO\n\nThis statement scans BASIC for the target line number (the scan starts\nwith the current line if the target line number is higher, otherwise\nit starts with the first line).  When the line is found, the pointers\nto the current statement and text character are changed, so that the\ntarget statement will be executed next."
  },
  {
    "id": "map-A8D2",
    "address_start": 43218,
    "address_end": 43218,
    "hex_start": "$A8D2",
    "hex_end": "$A8D2",
    "label": "RETURN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43218         $A8D2          RETURN\nPerform RETURN\n\nThe RETURN statement finds the saved GOSUB data on the stack, and uses\nit to restore the pointers to the current line and current character.\nThis will cause execution to continue where it left off when GOSUB was\nexecuted."
  },
  {
    "id": "map-A8F8",
    "address_start": 43256,
    "address_end": 43256,
    "hex_start": "$A8F8",
    "hex_end": "$A8F8",
    "label": "DATA",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43256         $A8F8          DATA\nPerform DATA\n\nDATA uses the next subroutine to find the offset to the next\nstatement, and adds the offset to the current pointers so that the\nnext statement will be executed.  If effect, it skips the statement,\nmuch like REM."
  },
  {
    "id": "map-A906",
    "address_start": 43270,
    "address_end": 43270,
    "hex_start": "$A906",
    "hex_end": "$A906",
    "label": "DATAN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43270         $A906          DATAN\nSearch Program Text for the End of the Current BASIC Statement\n\nThis routine starts at the current byte of program text and searches\nuntil it finds a zero character (line delimiter) or a colon character\nthat is not in quotes (statement delimiter)."
  },
  {
    "id": "map-A928",
    "address_start": 43304,
    "address_end": 43304,
    "hex_start": "$A928",
    "hex_end": "$A928",
    "label": "IF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43304         $A928          IF\nPerform IF\n\nIF uses the FRMEVL routine at 44446 ($AD9E) to reduce the expression\nwhich follows to a single term.  If the expression evaluates to 0\n(false), the routine falls through to REM.  If it is not 0, GOTO or\nthe statement following THEN is executed."
  },
  {
    "id": "map-A93B",
    "address_start": 43323,
    "address_end": 43323,
    "hex_start": "$A93B",
    "hex_end": "$A93B",
    "label": "REM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43323         $A93B          REM\nPerform REM\n\nThe REM statement is executed by skipping all program text until the\nbeginning of the next statement.  It is actually a part of the IF\nstatement, which continues for a few bytes after the REM part."
  },
  {
    "id": "map-A94B",
    "address_start": 43339,
    "address_end": 43339,
    "hex_start": "$A94B",
    "hex_end": "$A94B",
    "label": "ONGOTO",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43339         $A94B          ONGOTO\nPerform ON GOTO or ON GOSUB\n\nON is performed by converting the argument to an integer, and then\nskipping a number between commas each time that the integer is\ndecremented until the argument reaches 0.  If a GOTO or GOSUB is the\nnext token, the current number between commas is used to execute one\nof those statements.  If the numbers between commas are used up before\nthe argument reaches 0, the statement has no effect, and the next\nstatement is executed."
  },
  {
    "id": "map-A96B",
    "address_start": 43371,
    "address_end": 43371,
    "hex_start": "$A96B",
    "hex_end": "$A96B",
    "label": "LINGET",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43371         $A96B          LINGET\nConvert an ASCII Decimal Number to a Two-Byte Binary Line Nmumber\n\nThis subroutine is used by several statements to read a decimal\nnumber, convert it to a two-byte integer line number (in low-byte,\nhigh-byte format), and check that it is in the correct range of\n0-63999."
  },
  {
    "id": "map-A9A5",
    "address_start": 43429,
    "address_end": 43429,
    "hex_start": "$A9A5",
    "hex_end": "$A9A5",
    "label": "LET",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43429         $A9A5          LET\nPerform LET\n\nThe LET command causes variables to be created and initialized, or to\nhave a new value assigned.  It handles all types of array or nonarray\nvariables:  strings, floating point, integers, ST, TI, and TI$.  The\nroutine is composed of several subroutines that evaluate the variable,\nevaluate the assigned expression, check that the assigned value is\nsuitable for a variable of that type, and then assign a value to the\nexisting variable, or create a new variable."
  },
  {
    "id": "map-AA80",
    "address_start": 43648,
    "address_end": 43648,
    "hex_start": "$AA80",
    "hex_end": "$AA80",
    "label": "PRINTN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43648         $AA80          PRINTN\nPerform PRINT#\n\nThe PRINT# statement calls CMD and then closes the output channel with\nthe Kernal CLRCHN routine (62259, $F333)."
  },
  {
    "id": "map-AA86",
    "address_start": 43654,
    "address_end": 43654,
    "hex_start": "$AA86",
    "hex_end": "$AA86",
    "label": "CMD",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43654         $AA86          CMD\nPerform CMD\n\nThis routine calls the Kernal CHKOUT routine (62032, $F250), and calls\nPRINT to send any included text to the device.  Unlike PRINT# it\nleaves the output channel open, so that output continues to go to that\ndevice."
  },
  {
    "id": "map-AAA0",
    "address_start": 43680,
    "address_end": 43680,
    "hex_start": "$AAA0",
    "hex_end": "$AAA0",
    "label": "PRINT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43680         $AAA0          PRINT\nPerform PRINT\n\nThe PRINT routine has many segments, which are required for the\nvarious options which can be added to it:  TAB, SPC, comman,\nsemicolon, variables, PI, ST, TI, and TI$.  Eventually, all output is\nconverted to strings, and the Kernal CHROUT routine is called to print\neach character."
  },
  {
    "id": "map-AB1E",
    "address_start": 43806,
    "address_end": 43806,
    "hex_start": "$AB1E",
    "hex_end": "$AB1E",
    "label": "STROUT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43806         $AB1E          STROUT\nPrint Message from a String Whose Address Is in the .Y and .A\nRegisters\n\nThis part of the PRINT routine outputs a string whose address is in\nthe Accumulator (low byte) and .Y register (high byte), and which ends\nin a zero byte."
  },
  {
    "id": "map-AB4D",
    "address_start": 43853,
    "address_end": 43853,
    "hex_start": "$AB4D",
    "hex_end": "$AB4D",
    "label": "DOAGIN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43853         $AB4D          DOAGIN\nError Message Formatting Routines for GET, INPUT, and READ"
  },
  {
    "id": "map-AB7B",
    "address_start": 43899,
    "address_end": 43899,
    "hex_start": "$AB7B",
    "hex_end": "$AB7B",
    "label": "GET",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43899         $AB7B          GET\nPerform GET and GET#\n\nThe GET routine first makes sure that the program is not in direct\nmode.  It opens an input channel using the Kernal CHKIN routine\n(61966, $F20E) if a number sign was added to make GET#.  Then it calls\nthe common I/O routines in READ to get a single character, and causes\nthe input channel to be closed if one was opened."
  },
  {
    "id": "map-ABA5",
    "address_start": 43941,
    "address_end": 43941,
    "hex_start": "$ABA5",
    "hex_end": "$ABA5",
    "label": "INPUTN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43941         $ABA5          INPUTN\nPerform INPUT#\n\nThis routine opens an input channel with the Kernal CHKIN routine,\ncalls INPUT, and then closes the channel with a CHKOUT routine (62032,\n$F250).  Extra data is discarded without an EXTRA IGNORED message, and\na FILE DATA ERROR message is issued when the data type is not suitable\nfor the type of variable used."
  },
  {
    "id": "map-ABBF",
    "address_start": 43967,
    "address_end": 43967,
    "hex_start": "$ABBF",
    "hex_end": "$ABBF",
    "label": "INPUT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "43967         $ABBF          INPUT\nPerform INPUT\n\nThe INPUT routine checks to make sure that direct mode is not active,\nprints prompts, receives a line of input from the device, and jumps to\nthe common code in READ that assigns the input to the variables which\nwere named."
  },
  {
    "id": "map-AC06",
    "address_start": 44038,
    "address_end": 44038,
    "hex_start": "$AC06",
    "hex_end": "$AC06",
    "label": "READ",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44038         $AC06          READ\nPerform READ\n\nThis routine includes the READ command and common code for GET and\nINPUT.  The READ command locates the next piece of DATA, reads the\ntext, and converts it to the appropriate type of data to be assigned\nto a numeric or string variable."
  },
  {
    "id": "map-ACFC",
    "address_start": 44284,
    "address_end": 44284,
    "hex_start": "$ACFC",
    "hex_end": "$ACFC",
    "label": "EXIGNT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44284         $ACFC          EXIGNT\nASCII Text for Input Error Messages\n\nThe text stored here is ?EXTRA IGNORED and ?REDO FROM START, each\nfollowed by a carriage return and a zero byte."
  },
  {
    "id": "map-AD1E",
    "address_start": 44318,
    "address_end": 44318,
    "hex_start": "$AD1E",
    "hex_end": "$AD1E",
    "label": "NEXT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44318         $AD1E          NEXT\nPerform NEXT\n\nNEXT is executed by finding the appropriate FOR data on the stack,\nadding the STEP value to the FOR variable, and comparing the result to\nthe TO value.  If the loop is done, the stack entries for that FOR\ncommand are removed from the stack.  If the loop hasn't reached its\nlimit, the pointers to the current statement and text character are\nupdated from the FOR stack entry, which causes execution to continue\nwith the statement after the FOR statement."
  },
  {
    "id": "map-AD8A",
    "address_start": 44426,
    "address_end": 44426,
    "hex_start": "$AD8A",
    "hex_end": "$AD8A",
    "label": "FRMNUM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44426         $AD8A          FRMNUM\nEvaluate a Numeric Expression and/or Check for Data Type Mismatch\n\nThis routine can be called from different entry points to check the\ncurrent data against the desired data type (string or numeric) to see\nif they match.  If they don't, a TYPE MISMATCH error will result."
  },
  {
    "id": "map-AD9E",
    "address_start": 44446,
    "address_end": 44446,
    "hex_start": "$AD9E",
    "hex_end": "$AD9E",
    "label": "FRMEVAL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44446         $AD9E          FRMEVAL\nEvaluate Expression\n\nThis is the beginning point of a very powerful group of subroutines\nwhich are used extensively by BASIC.\n\nThe main purpose of these routines is to read in the ASCII text of\nBASIC expressions, separate the operators and terms of the expression,\ncheck them for errors, combine the individual terms by performing the\nindicated operations, and obtain a single value which the BASIC\nprogram can use.\n\nThis can be a very complex task, and expressions an be of the string\nor numeric type, and can contain any type of variable, as well as\nconstants.\n\nAt the end, the flag which shows whether the resulting value is string\nor numeric at 13 ($D) is set, and if the value is numeric, the flag at\n14 ($E) is set as well, to show if it is an integer or floating point\nnumer."
  },
  {
    "id": "map-AE83",
    "address_start": 44675,
    "address_end": 44675,
    "hex_start": "$AE83",
    "hex_end": "$AE83",
    "label": "EVAL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44675         $AE83          EVAL\nConvert a Single Numeric Term from ASCII Text to a Floating Point\nNumber\n\nThis routine reduces a single arithmetic term which is part of an\nexpression from ASCII text to its floating point equivalent.\n\nIf the term is a constant, the routine sets the data type flag to\nnumber, sets the text pointer to the first ASCII numeric character,\nand jumps to the routine which converts the ASCII string to a floating\npoint number.\n\nIf the term is a variable, the variable value is retrieved.  If it is\nthe PI character, the value of PI is moved into the Floating Point\nAccumulator.\n\nThis routine is vectored through RAM at 778 ($30A)."
  },
  {
    "id": "map-AEA8",
    "address_start": 44712,
    "address_end": 44712,
    "hex_start": "$AEA8",
    "hex_end": "$AEA8",
    "label": "PIVAL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44712         $AEA8          PIVAL\nPI Expressed as a Five-Byte Floating Point Number\n\nThe value of PI is stored here as a five-byte floating point number."
  },
  {
    "id": "map-AEF1",
    "address_start": 44785,
    "address_end": 44785,
    "hex_start": "$AEF1",
    "hex_end": "$AEF1",
    "label": "PARCHK",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44785         $AEF1          PARCHK\nEvaluate Expression Within Parentheses\n\nThis routine evaluates an expression within parentheses by calling the\nsyntax checking routines that look for opening and closing\nparentheses, and then calling FRMEVL (4446, $AD9E) for each level of\nparentheses."
  },
  {
    "id": "map-AEF7",
    "address_start": 44791,
    "address_end": 44791,
    "hex_start": "$AEF7",
    "hex_end": "$AEF7",
    "label": "CHKCLS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44791         $AEF7          CHKCLS\nCheck for and Skip Closing Parentheses"
  },
  {
    "id": "map-AEFA",
    "address_start": 44794,
    "address_end": 44794,
    "hex_start": "$AEFA",
    "hex_end": "$AEFA",
    "label": "CHKOPN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44794         $AEFA          CHKOPN\nCheck for and Skip Opening Parentheses"
  },
  {
    "id": "map-AEFF",
    "address_start": 44799,
    "address_end": 44799,
    "hex_start": "$AEFF",
    "hex_end": "$AEFF",
    "label": "CHKCOM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44799         $AEFF          CHKCOM\nCheck for and Skip Comma\n\nThis syntax checking device is the same in substance as the two\nchecking routines above.  It is used when the next character should be\na comma.  If it is not, a SYNTAX ERROR retults.  If it is, the\ncharacter is skipped and the next character is read.  Any character\ncan be checked for and skipped this way by loading the character into\nthe Accumulator and entering this routine from SYNCHR at 44799\n($AEFF)."
  },
  {
    "id": "map-AF08",
    "address_start": 44808,
    "address_end": 44808,
    "hex_start": "$AF08",
    "hex_end": "$AF08",
    "label": "SNERR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44808         $AF08          SNERR\nPrint Syntax Error Message"
  },
  {
    "id": "map-AF2B",
    "address_start": 44843,
    "address_end": 44843,
    "hex_start": "$AF2B",
    "hex_end": "$AF2B",
    "label": "ISVAR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44843         $AF2B          ISVAR\nGet the Value of a Variable"
  },
  {
    "id": "map-AFA7",
    "address_start": 44967,
    "address_end": 44967,
    "hex_start": "$AFA7",
    "hex_end": "$AFA7",
    "label": "ISFUN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "44967         $AFA7          ISFUN\nDispatch and Evaluate a Function\n\nIf a BASIC function (like ASC(\"A\")) is part of an expression, this\nroutine will use the function dispatch table at 42242 ($A502) to set\nup the address of th proper function routine, and then branch to that\nroutine."
  },
  {
    "id": "map-AFE6",
    "address_start": 45030,
    "address_end": 45030,
    "hex_start": "$AFE6",
    "hex_end": "$AFE6",
    "label": "OROP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45030         $AFE6          OROP\nPerform OR\n\nThe OR routine sets the .Y register as a flag, and falls through to\nthe AND routine, which also performs OR."
  },
  {
    "id": "map-AFE9",
    "address_start": 45033,
    "address_end": 45033,
    "hex_start": "$AFE9",
    "hex_end": "$AFE9",
    "label": "ANDOP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45033         $AFE9          ANDOP\nPerform AND\n\nThe AND routine changes the parameters to two-byte integer values, and\nperforms the appropriate logical operation (AND or OR).  A result of 0\nsignifies false, while a result of -1 signifies true."
  },
  {
    "id": "map-B016",
    "address_start": 45078,
    "address_end": 45078,
    "hex_start": "$B016",
    "hex_end": "$B016",
    "label": "DORE1",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45078         $B016          DORE1\nPerform Comparisons\n\nThis routine does the greater than (>), less than (<), and equal (=)\ncomparisons for foating point numbers and strings.  The result in the\nFloating Point Accumulator will be 0 if the comparison is false, and\n-1 if it is true.\n\n45185         $B018          DIM\nPerform DIM\n\nThis command calls the next routine to create an array for every\nvariable dimensioned (since a statement can take the form DIM A(12),\nB(13), C(14)...).  If the array element is referenced before a DIM\nstatement (for example, A(3)=4), the array will be dimensioned to 10\n(as if DIM A(10) were executed).  Remember, DIMensioning an array to\n10 really creates 11 elements (10).  The 0 element should always be\nconsidered in calculating the size to DIMension your array."
  },
  {
    "id": "map-B08B",
    "address_start": 45195,
    "address_end": 45195,
    "hex_start": "$B08B",
    "hex_end": "$B08B",
    "label": "PTRGET",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45195         $B08B          PTRGET\nSearch for a Variable and Set It Up If It Is Not Found\n\nThis routine attempts to locate a variable by searching for its name\nin the variable area.  If an existing variable of that name cannot be\nfound, one is created with the NOTFNS routine below."
  },
  {
    "id": "map-B113",
    "address_start": 45331,
    "address_end": 45331,
    "hex_start": "$B113",
    "hex_end": "$B113",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45331         $B113\nCheck If .A Register Holds Alphabetic ASCII Character\n\nThis is part of the check for a valid variable name (it must start\nwith an alphabetic character)."
  },
  {
    "id": "map-B11D",
    "address_start": 45341,
    "address_end": 45341,
    "hex_start": "$B11D",
    "hex_end": "$B11D",
    "label": "NOTFNS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45341         $B11D          NOTFNS\nCreate a New BASIC Variable\n\nThis routine makes space for a seven-byte descriptor by moving the\nvariable storage area seven bytes higher in memory, and then creates\nthe descriptor."
  },
  {
    "id": "map-B185",
    "address_start": 45445,
    "address_end": 45445,
    "hex_start": "$B185",
    "hex_end": "$B185",
    "label": "FINPTR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45445         $B185          FINPTR\nReturn the Address of the Variable That Was Found or Created\n\nThis routine stores the address of the variable that was found or\ncreated by the preceding routines in a pointer at 71-72 ($47-$48)."
  },
  {
    "id": "map-B194",
    "address_start": 45460,
    "address_end": 45460,
    "hex_start": "$B194",
    "hex_end": "$B194",
    "label": "ARYGET",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45460         $B194          ARYGET\nAllocate Space for Array Descriptors\n\nThis routine allocates five bytes plus two bytes for every dimension\nspecified for the array descriptor."
  },
  {
    "id": "map-B1A5",
    "address_start": 45477,
    "address_end": 45477,
    "hex_start": "$B1A5",
    "hex_end": "$B1A5",
    "label": "N32768",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45477         $B1A5          N32768\nThe Constant -32768 in Five-Byte Floating Point Format\n\nThis constant is used for range checking in the conversion of a\nfloating point number to a signed integer (the minimum inter value is\n-32768)."
  },
  {
    "id": "map-B1AA",
    "address_start": 45482,
    "address_end": 45482,
    "hex_start": "$B1AA",
    "hex_end": "$B1AA",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45482         $B1AA\nConvert a Floating Point Number to a Signed Integer in .A and .Y Registers\n\nThis subroutine calls AYINT, below, which checks to make sure that the\nnumber in the Floating Point Accumulator is between 32767 and -32768,\nand converts it to a 16-bit signed integer in 100-101 ($64-$65), high\nbyte first.  It leaves the high byte of the integer in the\nAccumulator, and the low byte in the .Y register.\n\nAlthough this routine does not appear to be referenced anywhere in\nBASIC, the vector at locations 3-4 points to its address.  Presumably,\nit is provided for the benefit of the user who wishes to pass\nparameters in a USR call, or the like."
  },
  {
    "id": "map-B1B2",
    "address_start": 45490,
    "address_end": 45490,
    "hex_start": "$B1B2",
    "hex_end": "$B1B2",
    "label": "INTIDX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45490         $B1B2          INTIDX\nInput and Convert a Floating Point Subscript to a Positive Integer\n\nThis routine converts a floating point subscript value to an integer,\nmaking sure first that it is positive."
  },
  {
    "id": "map-B1BF",
    "address_start": 45503,
    "address_end": 45503,
    "hex_start": "$B1BF",
    "hex_end": "$B1BF",
    "label": "AYINT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45503         $B1BF          AYINT\nConvert a Floating Point Number to a Signed Integer\n\nThis subroutine first checks to make sure that the number in the\nFloating Point Accumulator is between 32767 and -32768.  If it is not,\nan ILLEGAL QUANTITY error results.  If it is, the routine converts it\nto a 16-bit signed integer with the high byte in location 100 ($64),\nand the low byte in location 101 ($65)."
  },
  {
    "id": "map-B1D1",
    "address_start": 45521,
    "address_end": 45521,
    "hex_start": "$B1D1",
    "hex_end": "$B1D1",
    "label": "ISARY",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45521         $B1D1          ISARY\nFind Array Element or Create New Array in RAM\n\nThis routine searches for an array.  If it is found, the subscript\nvalue is checked to see if it is valid, and pointers to the array and\nelement of the array are set.  If it is not found, the array is\ncreated, and the pointers set."
  },
  {
    "id": "map-B245",
    "address_start": 45637,
    "address_end": 45637,
    "hex_start": "$B245",
    "hex_end": "$B245",
    "label": "BSERR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45637         $B245          BSERR\nPrint BAD SUBSCRIPT Error Message"
  },
  {
    "id": "map-B248",
    "address_start": 45640,
    "address_end": 45640,
    "hex_start": "$B248",
    "hex_end": "$B248",
    "label": "FCERR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45640         $B248          FCERR\nPrint ILLEGAL QUANTITY Error Message"
  },
  {
    "id": "map-B34C",
    "address_start": 45900,
    "address_end": 45900,
    "hex_start": "$B34C",
    "hex_end": "$B34C",
    "label": "UMULT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45900         $B34C          UMULT\nCompute the Size of a Multidimensional Array\n\nThis routine calculates the size of a multidimensional array by\nmultiplying the dimensions."
  },
  {
    "id": "map-B37D",
    "address_start": 45949,
    "address_end": 45949,
    "hex_start": "$B37D",
    "hex_end": "$B37D",
    "label": "FRE",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45949         $B37D          FRE\nPerform FRE\n\nThe FRE function calls the garbage collection routine at 46374 ($B526)\nto get rid of unused string text, and calculates the difference\nbetween the bottom of string text and the top of array storage.  It\nthen drops through to the follow routine, which assumes that the free\nmemory value is a 16-bit signed integer, and converts it to floating\npoint accordingly.\n\nOf course, while the free memory space on the PET might have always\nbeen 32767 or less (the maximum value of a signed integer), sich is\ndefinitely not the case on the 64.  Because conversion is from a\nsigned integer, any memory value over 32767 will be regarded as\nnegative (the high bit is treated as a sign bit).  Therefore, for\nthese higher values you must add twice the bit value of the high bit\n(65536) in order to come up with the correct value.  The expression\nFRE(0)-6556*(FRE(0)<0) will always return the correct amount of free\nmemory."
  },
  {
    "id": "map-B391",
    "address_start": 45969,
    "address_end": 45969,
    "hex_start": "$B391",
    "hex_end": "$B391",
    "label": "GIVAYF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45969         $B391          GIVAYF\nConvert 16-Bit Signed Integer to Floating Point\n\nThis routine treats the value in the Accumulator as the high byte of a\n16-bit signed integer, and the value in the .Y register as the low\nbyte, and converts the signed integer into a floating point number in\nthe Floating Point Accumulator.\n\nThe address of this routine is pointed to by the RAM vector at 5-6,\nand the routine can be used to return an argument from the USR call in\nthe Floating Point Accumulator."
  },
  {
    "id": "map-B39E",
    "address_start": 45982,
    "address_end": 45982,
    "hex_start": "$B39E",
    "hex_end": "$B39E",
    "label": "POS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45982         $B39E          POS\nPerform POS\n\nThe POS command calls the Kernal PLOT routine (58634, $E50A) to get\nthe position of the cursor on the logical line.  What it really does\nis an equivalent of PEEK(211).  Remember, since we are dealing with a\nlogical line, this number can be over 39.  The statement \"THIS\nSENTENCE IS LONGER THAN ONE PHYSICAL LINE\";POS(X) will return a value\nof 48 for the POS(X)."
  },
  {
    "id": "map-B3A6",
    "address_start": 45990,
    "address_end": 45990,
    "hex_start": "$B3A6",
    "hex_end": "$B3A6",
    "label": "ERRDIR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "45990         $B3A6          ERRDIR\nCheck If the Program is Running in Direct Mode, and If So Issue an Error\n\nThis routine is called by statements that prohibit execution in direct\nmode.  It checks a flag that is set when a line without a linenumber\nis entered, and causes an ILLEGAL DIRECT error if the flag is set."
  },
  {
    "id": "map-B3B3",
    "address_start": 46003,
    "address_end": 46003,
    "hex_start": "$B3B3",
    "hex_end": "$B3B3",
    "label": "DEF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46003         $B3B3          DEF\nPerform DEF\n\nDEF performs some syntax checking, and pushes five bytes onto the\nstack:  the first byte of the function statement, a two-byte pointer\nto the dependent variable (the X in FN(X)), and the address of the\nfirst character of the definition itself, where it resides in the\nprogram text.\n\nThe DEF statement must fit on one line, but functions can be extended\nby nesting them (having one function call another)."
  },
  {
    "id": "map-B3E1",
    "address_start": 46049,
    "address_end": 46049,
    "hex_start": "$B3E1",
    "hex_end": "$B3E1",
    "label": "GETFNM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46049         $B3E1          GETFNM\nCheck DEF and FN Syntax\n\nThis routine checks to make sure that FN follow SEG, and that the\ndependent variable has a valid floating point variable name.  It calls\nthe routine to find or create a variable to get the pointer to its\naddress."
  },
  {
    "id": "map-B3F4",
    "address_start": 46068,
    "address_end": 46068,
    "hex_start": "$B3F4",
    "hex_end": "$B3F4",
    "label": "FNDOER",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46068         $B3F4          FNDOER\nPerform FN\n\nThe FN evaluation is done by evaluating the FN argument (for example,\nFN(A+B*C/D)) and then getting the rest of the expression from the text\nof the function definition statement.  The function variable\ndescriptor area is used as a work area, and the dependent variable is\nnot disturbed (so that if the definition used FN(X), the value of X\nwill not be changed by the function call)."
  },
  {
    "id": "map-B465",
    "address_start": 46181,
    "address_end": 46181,
    "hex_start": "$B465",
    "hex_end": "$B465",
    "label": "STRD",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46181         $B465          STRD\nPerform STR$\n\nSTR$ first checks to make sure that the parameter is a number, and\nthen calls the routines that convert floating point to ASCII and crate\nthe pointers to a string constant."
  },
  {
    "id": "map-B487",
    "address_start": 46215,
    "address_end": 46215,
    "hex_start": "$B487",
    "hex_end": "$B487",
    "label": "STRLIT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46215         $B487          STRLIT\nScan and Set Up Pointers to a String in Memory\n\nThis routine calculates the length of the string, and calls the\nroutine that allocates space in memory.  It then saves the string, or\ncreates a pointer to its location in the BASIC text input buffer at\n512 ($200)."
  },
  {
    "id": "map-B4F4",
    "address_start": 46324,
    "address_end": 46324,
    "hex_start": "$B4F4",
    "hex_end": "$B4F4",
    "label": "GETSPA",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46324         $B4F4          GETSPA\nAllocate Space in Memory for String\n\nThe amount of space needed for a string is passed to this routine, and\nthe routine checks if there is that amount of space available in free\nmemory.  If not, it does a garbage collection and tries again."
  },
  {
    "id": "map-B526",
    "address_start": 46374,
    "address_end": 46374,
    "hex_start": "$B526",
    "hex_end": "$B526",
    "label": "GARBAG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46374         $B526          GARBAG\nString Garbage Collection\n\nWhenever a string is changed in any way, the revised version of the\ntext is added to the bottom of the string text area, leaving the old\nversion higher up in memory, wasting space.\n\nIn order to reclaim that space, the descriptor for every string whose\ntext is in the string text area (rather than in the program text area)\nmust be searched to find the valid text that is highest in memory.  If\nthat string is not as high as it could be, it is moved up to replace\nany string that is no longer valid.  Then all of the string\ndescriptors must be searched again to find the next highest string and\nmove it up.  This continues until every string that is un use has been\ncovered.  After all have been moved up, the pointer to the bottom of\nstring text at 51-52 ($33-$34) is changed to show the new bottom\nlocation.\n\nIf there are more than a few strings whose text is in the string text\nstorage area, rather than in the body of the program, scanning every\nstring as many times as there are strings can take an awful lot of\ntime.  The computer may seem as if it had died (the STOP key is not\neven checked during the procedure).\n\nThe collection will take about as long whether there is any spare\nspace or not; the full collection will be done even if it is done\nimmediately after the last collection.  Although the increased memory\ncapacity of the 64 helps to forestall the need for garbage collection,\na large program with many string arrays may still experience lengthy\ncollection delays."
  },
  {
    "id": "map-B5BD",
    "address_start": 46525,
    "address_end": 46525,
    "hex_start": "$B5BD",
    "hex_end": "$B5BD",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46525         $B5BD\nCheck for Most Eligible String to Collect\n\nThis part of the garbage collection routine checks to see if the\ncurrent string is the highest in memory."
  },
  {
    "id": "map-B606",
    "address_start": 46598,
    "address_end": 46598,
    "hex_start": "$B606",
    "hex_end": "$B606",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46598         $B606\nCollect a String\n\nThis part of the garbage collection routine moves the string to high\nmemory and updates the descriptor to point to its new location."
  },
  {
    "id": "map-B63D",
    "address_start": 46653,
    "address_end": 46653,
    "hex_start": "$B63D",
    "hex_end": "$B63D",
    "label": "CAT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46653         $B63D          CAT\nConcatenate Two Strings\n\nThis routine is used to add the text of one string onto the end of\nanother (A$+B$).  Error checking is done to see if the length of the\ncombined string is within range, the allocation routine is called to\nallocate space, and the new string is built at the bottom of the\nstring text area."
  },
  {
    "id": "map-B67A",
    "address_start": 46714,
    "address_end": 46714,
    "hex_start": "$B67A",
    "hex_end": "$B67A",
    "label": "MOVINS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46714         $B67A          MOVINS\nMove a String in Memory\n\nThis is the routine which is used to move a string to the bottom of\nthe string text area for the above routine.  It is generally used as a\nutility routine to move strings."
  },
  {
    "id": "map-B6A3",
    "address_start": 46755,
    "address_end": 46755,
    "hex_start": "$B6A3",
    "hex_end": "$B6A3",
    "label": "FRESTR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46755         $B6A3          FRESTR\nDiscard a Temporary String\n\nThis routine calls the following routine which clears an entry from\nthe temporary descriptor stack.  If the descriptor was on the stack,\nit exits after setting pointers to the string and its length.  If it\nwasn't on the temporary stack and is at the bottom of string text\nstorage, the pointer to the bottom is moved up to deallocate the\nstring."
  },
  {
    "id": "map-B6DB",
    "address_start": 46811,
    "address_end": 46811,
    "hex_start": "$B6DB",
    "hex_end": "$B6DB",
    "label": "FRETMS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46811         $B6DB          FRETMS\nRemove an Entry from the String Descriptor Stack\n\nIf the descriptor of a currently valid string is the same as one of\nthe entries on the temporary string descriptor stack, the stack entry\nis removed."
  },
  {
    "id": "map-B6EC",
    "address_start": 46828,
    "address_end": 46828,
    "hex_start": "$B6EC",
    "hex_end": "$B6EC",
    "label": "CHRD",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46828         $B6EC          CHRD\nPerform CHR$\n\nThe CHR$ routine creates a descriptor on the temporary string stack\nfor the one-byte string whose value is specified in the command, and\nsets a pointer to that string."
  },
  {
    "id": "map-B700",
    "address_start": 46848,
    "address_end": 46848,
    "hex_start": "$B700",
    "hex_end": "$B700",
    "label": "LEFTD",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46848         $B700          LEFTD\nPerform LEFT$\n\nLEFT$ creates a temporary string descriptor for a new string which\ncontains the number of characters from the left side of the string\nthat is specified in the command."
  },
  {
    "id": "map-B72C",
    "address_start": 46892,
    "address_end": 46892,
    "hex_start": "$B72C",
    "hex_end": "$B72C",
    "label": "RIGHTD",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46892         $B72C          RIGHTD\nPerform RIGHT$\n\nRIGHT$ manipulates its parameters so that the tail end of LEFT$ can be\nused to create a temporary string descriptor for a new string.  This\nnew string contains the number of characters from the right side of\nthe string that is specified in the command."
  },
  {
    "id": "map-B737",
    "address_start": 46903,
    "address_end": 46903,
    "hex_start": "$B737",
    "hex_end": "$B737",
    "label": "MIDD",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46903         $B737          MIDD\nPerform MID$\n\nMID$ manipulates its parameters so that the tail end of LEFT$ can be\nused to create a temporary string descriptor for a new string.  This\nnew string contains the number of characters from the position in the\nmiddle of the string that is specified in the command."
  },
  {
    "id": "map-B761",
    "address_start": 46945,
    "address_end": 46945,
    "hex_start": "$B761",
    "hex_end": "$B761",
    "label": "PREAM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46945         $B761          PREAM\nPull String Function Parameters from Stack for LEFT$, RIGHT$, and MID$\n\nThis routine is used to obtain the first two parameters for all three\nof these commands."
  },
  {
    "id": "map-B77C",
    "address_start": 46972,
    "address_end": 46972,
    "hex_start": "$B77C",
    "hex_end": "$B77C",
    "label": "LEN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46972         $B77C          LEN\nPerform LEN\n\nThe LEN function is performed by obtaining the string length from the\ndescriptor and converting it to a floating point number."
  },
  {
    "id": "map-B78B",
    "address_start": 46987,
    "address_end": 46987,
    "hex_start": "$B78B",
    "hex_end": "$B78B",
    "label": "ASC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "46987         $B78B          ASC\nPerform ASC\n\nThis routine gets the first character of the string in the .Y register\n(if it's not a null string).  Then it calls the part of POS that\nconverts a one- byte integer in .Y to a floating point number."
  },
  {
    "id": "map-B79B",
    "address_start": 47003,
    "address_end": 47003,
    "hex_start": "$B79B",
    "hex_end": "$B79B",
    "label": "GETBYTC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47003         $B79B          GETBYTC\nInput a Parameter Whose Value Is Between 0 and 255\n\nThis routine reads numeric ASCII program text, converts it to an\ninteger, checks that it is in the range 0-255, and stores it in the .X\nregister.  This routine can be useful for reading parameters from a\nUSR statement or new commands."
  },
  {
    "id": "map-B7AD",
    "address_start": 47021,
    "address_end": 47021,
    "hex_start": "$B7AD",
    "hex_end": "$B7AD",
    "label": "VAL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47021         $B7AD          VAL\nPerform VAL\n\nThe VAL routine obtains the string pointer, and reads the string one\ncharacter at a time until an invalid character is found (ASCII\nnumbers, sign character, a single decimal point, exponent, and spaces\nare all valid).  Then the string is changed to floating point.  If no\nvalid characters are found, a 0 is returned."
  },
  {
    "id": "map-B7EB",
    "address_start": 47083,
    "address_end": 47083,
    "hex_start": "$B7EB",
    "hex_end": "$B7EB",
    "label": "GETNUM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47083         $B7EB          GETNUM\nGet a 16-Bit Address Parameter and an 8-Bit Parameter (for POKE and WAIT)\n\nThis routine gets the next numeric parameter from the current place in\nprogram text.  The routine evaluates it, checks that it is a positive\ninteger within the range 0-65535, and changes it from floating point\nto a two-byte integer in 20-21 ($14-$15).  It checks for and skips a\ncomma, then gets a one-byte integer parameter in the .X register.  The\nroutine is used to get the parameters for POKE an WAIT."
  },
  {
    "id": "map-B7F7",
    "address_start": 47095,
    "address_end": 47095,
    "hex_start": "$B7F7",
    "hex_end": "$B7F7",
    "label": "GETADR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47095         $B7F7          GETADR\nConvert a Floating Point Number to an Unsigned Two-Byte Integer\n\nThis routine checks the number in the Floating Point Accumulator to\nmake sure that it is a positive number less than 65536, and then calls\nthe subroutine which conerts floatin point to integer.  It is used to\nget address parameters, for commands such as PEEK."
  },
  {
    "id": "map-B80D",
    "address_start": 47117,
    "address_end": 47117,
    "hex_start": "$B80D",
    "hex_end": "$B80D",
    "label": "PEEK",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47117         $B80D          PEEK\nPerform PEEK\n\nPEEK reads the address parameter and converts it to a pointer.  Then\nit gets the byte pointed to into the .Y register, and calls the part\nof POS that converts a single integer in .Y to a floating point\nnumber."
  },
  {
    "id": "map-B824",
    "address_start": 47140,
    "address_end": 47140,
    "hex_start": "$B824",
    "hex_end": "$B824",
    "label": "POKE",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47140         $B824          POKE\nPerform POKE\n\nPOKE gets a pointer to the address parameter, and stores the next\nparameter there."
  },
  {
    "id": "map-B82D",
    "address_start": 47149,
    "address_end": 47149,
    "hex_start": "$B82D",
    "hex_end": "$B82D",
    "label": "FUWAIT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47149         $B82D          FUWAIT\nPerform WAIT\n\nWAIT gets an address parameter and an integer parameter to use as a\nmask.  WAIT then looks for an optional parameter to use as a pattern\nfor the exclusive OR.  Then, the address location is read, its value\nis exclusive ORed with the optional pattern value (or 0 if there is\nnone).  This value is ANDed with the mask value.  The command loops\ncontinuously until the result is not- zero.\n\nThe purpose of this command is to allow the program to watch a\nlocation which can be changed by the system or by outside hardware\n(such as the software clock or keycode value locations).\n\nThe AND function lets you check if a bit changes from 0 to 1, while\nthe EOR function allows you to check if a bit changes from 1 to 0.\nFor more information, see the article \"All About the Wait\nInstruction,\" by Louis Sander and Doug Ferguson, in COMPUTE!'s First\nBook of Commodore 64."
  },
  {
    "id": "map-B849",
    "address_start": 47177,
    "address_end": 47177,
    "hex_start": "$B849",
    "hex_end": "$B849",
    "label": "FADDH",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47177         $B849          FADDH\nAdd .5 to Contents of Floating Point Accumulator #1"
  },
  {
    "id": "map-B850",
    "address_start": 47184,
    "address_end": 47184,
    "hex_start": "$B850",
    "hex_end": "$B850",
    "label": "FSUB",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47184         $B850          FSUB\nSubtract FAC1 from a Number in Memory\n\nThis routine is used to subtract the Floating Point Accumulator from a\nnumber in memory.  It moves the number in memory into FAC2, and falls\nthrough to the next routine."
  },
  {
    "id": "map-B853",
    "address_start": 47187,
    "address_end": 47187,
    "hex_start": "$B853",
    "hex_end": "$B853",
    "label": "FSUBT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47187         $B853          FSUBT\nBASIC's Subtraction Operation\n\nThis routine subtracts the contents of FAC2 from FAC1 by complementing\nits sign and adding."
  },
  {
    "id": "map-B867",
    "address_start": 47207,
    "address_end": 47207,
    "hex_start": "$B867",
    "hex_end": "$B867",
    "label": "FADD",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47207         $B867          FADD\nAdd FAC1 to a Number in Memory\n\nThis routine is used to add the contents of the Floating Point\nAccumulator (FAC1) to a number in memory, by moving that number into\nFAC2, and falling through to the next routine."
  },
  {
    "id": "map-B86A",
    "address_start": 47210,
    "address_end": 47210,
    "hex_start": "$B86A",
    "hex_end": "$B86A",
    "label": "FADDT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47210         $B86A          FADDT\nPerform BASIC's Addition Operation\n\nThis routine adds the contents of FAC1 and FAC2 and stores the results\nin FAC1."
  },
  {
    "id": "map-B8A7",
    "address_start": 47271,
    "address_end": 47271,
    "hex_start": "$B8A7",
    "hex_end": "$B8A7",
    "label": "FADD4",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47271         $B8A7          FADD4\nMake the Result Negative If a Borrow Was Done"
  },
  {
    "id": "map-B8FE",
    "address_start": 47358,
    "address_end": 47358,
    "hex_start": "$B8FE",
    "hex_end": "$B8FE",
    "label": "NORMAL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47358         $B8FE          NORMAL\nNormalize Floating Point Accumulator #1"
  },
  {
    "id": "map-B947",
    "address_start": 47431,
    "address_end": 47431,
    "hex_start": "$B947",
    "hex_end": "$B947",
    "label": "NEGFAC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47431         $B947          NEGFAC\nReplace FAC1 with Its 2's Complement"
  },
  {
    "id": "map-B97E",
    "address_start": 47486,
    "address_end": 47486,
    "hex_start": "$B97E",
    "hex_end": "$B97E",
    "label": "OVERR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47486         $B97E          OVERR\nPrint Overflow Error Message"
  },
  {
    "id": "map-B9BC",
    "address_start": 47548,
    "address_end": 47548,
    "hex_start": "$B9BC",
    "hex_end": "$B9BC",
    "label": "FONE",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47548         $B9BC          FONE\nFloating Point Constant with a Value of 1\n\nThis five-byte floating point representation of the number 1 is stored\nhere for use by the floating point routines.  It is also used as the\ndefault STEP value for the FOR statement."
  },
  {
    "id": "map-B9C1",
    "address_start": 47553,
    "address_end": 47553,
    "hex_start": "$B9C1",
    "hex_end": "$B9C1",
    "label": "LOGCN2",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47553         $B9C1          LOGCN2\nTable of Floating Point Constants for the LOG Function\n\nThis table of eight numeric constants in five-byte floating point\nrepresentation is used by the LOG function."
  },
  {
    "id": "map-B9EA",
    "address_start": 47594,
    "address_end": 47594,
    "hex_start": "$B9EA",
    "hex_end": "$B9EA",
    "label": "LOG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47594         $B9EA          LOG\nPerform LOG to Base E\n\nThe LOG to the base e of the number in FAC1 is performed here, and the\nresult left in FAC1."
  },
  {
    "id": "map-BA28",
    "address_start": 47656,
    "address_end": 47656,
    "hex_start": "$BA28",
    "hex_end": "$BA28",
    "label": "FMULT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47656         $BA28          FMULT\nMultiply FAC1 with FAC2\n\nThis routine multiplies the contents of FAC1 by the contents of FAC2\nand stores the result in FAC1"
  },
  {
    "id": "map-BA59",
    "address_start": 47705,
    "address_end": 47705,
    "hex_start": "$BA59",
    "hex_end": "$BA59",
    "label": "MLTPLY",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47705         $BA59          MLTPLY\nMultiply a Byte Subroutine\n\nThis subroutine is used to repetitively add a mantissa byte of FAC2 to\nFAC1 the number of times specified in the .A register."
  },
  {
    "id": "map-BA8C",
    "address_start": 47756,
    "address_end": 47756,
    "hex_start": "$BA8C",
    "hex_end": "$BA8C",
    "label": "CONUPK",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47756         $BA8C          CONUPK\nMove a Floating Point Number from Memory into FAC2\n\nThis subroutine loads FAC2 from the four-byte number (three mantissa\nand one sign) pointed to by the .A and .Y registers."
  },
  {
    "id": "map-BAB7",
    "address_start": 47799,
    "address_end": 47799,
    "hex_start": "$BAB7",
    "hex_end": "$BAB7",
    "label": "MULDIV",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47799         $BAB7          MULDIV\nAdd Exponent of FAC1 to Exponent of FAC2"
  },
  {
    "id": "map-BAD4",
    "address_start": 47828,
    "address_end": 47828,
    "hex_start": "$BAD4",
    "hex_end": "$BAD4",
    "label": "MLDVEX",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47828         $BAD4          MLDVEX\nHandle Underflow or Overflow"
  },
  {
    "id": "map-BAE2",
    "address_start": 47842,
    "address_end": 47842,
    "hex_start": "$BAE2",
    "hex_end": "$BAE2",
    "label": "MUL10",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47842         $BAE2          MUL10\nMultiply FAC1 by 10\n\nThis subroutine is called to help convert a floating point number to a\nseries of ASCII numerals."
  },
  {
    "id": "map-BAF9",
    "address_start": 47865,
    "address_end": 47865,
    "hex_start": "$BAF9",
    "hex_end": "$BAF9",
    "label": "TENC",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47865         $BAF9          TENC\nThe Constant 10 in Five-Byte Floating Format"
  },
  {
    "id": "map-BAFE",
    "address_start": 47870,
    "address_end": 47870,
    "hex_start": "$BAFE",
    "hex_end": "$BAFE",
    "label": "DIV10",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47870         $BAFE          DIV10\nDivide FAC1 by 10"
  },
  {
    "id": "map-BB0F",
    "address_start": 47887,
    "address_end": 47887,
    "hex_start": "$BB0F",
    "hex_end": "$BB0F",
    "label": "FDIV",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47887         $BB0F          FDIV\nDivide a Number in Memory by FAC1\n\nThis number in memory is stored to FAC2, and this routine falls\nthrough to the next."
  },
  {
    "id": "map-BB12",
    "address_start": 47890,
    "address_end": 47890,
    "hex_start": "$BB12",
    "hex_end": "$BB12",
    "label": "FDIVT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "47890         $BB12          FDIVT\nDivide FAC2 by FAC1\n\nThis routine is used to divide the contents of FAC2 by the contents of\nFAC1, with the result being stored in FAC1.  A check for division by 0\nis made before dividing."
  },
  {
    "id": "map-BBA2",
    "address_start": 48034,
    "address_end": 48034,
    "hex_start": "$BBA2",
    "hex_end": "$BBA2",
    "label": "MOVFM",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48034         $BBA2          MOVFM\nMove a Floating Point Number from Memory to FAC1\n\nThis routine loads FAC1 with the five-byte floating point number\npointed to by the address stored in the Accumulator (low byte) and the\n.Y register (high byte)."
  },
  {
    "id": "map-BBC7",
    "address_start": 48071,
    "address_end": 48071,
    "hex_start": "$BBC7",
    "hex_end": "$BBC7",
    "label": "MOV2F",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48071         $BBC7          MOV2F\nMove a Floating Point Number from FAC1 to Memory\n\nThis routine is used to move a number from the Floating Point\nAccumulator (FAC1) to memory at either 92-96 ($5C-$60) or 87-91\n($57-$5B), depending on the entry point to the routine."
  },
  {
    "id": "map-BBFC",
    "address_start": 48124,
    "address_end": 48124,
    "hex_start": "$BBFC",
    "hex_end": "$BBFC",
    "label": "MOVFA",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48124         $BBFC          MOVFA\nMove a Floating Point Number from FAC2 to FAC1"
  },
  {
    "id": "map-BC0C",
    "address_start": 48140,
    "address_end": 48140,
    "hex_start": "$BC0C",
    "hex_end": "$BC0C",
    "label": "MOVAF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48140         $BC0C          MOVAF\nRound and Move a Floating Point Number from FAC1 to FAC2"
  },
  {
    "id": "map-BC0F",
    "address_start": 48143,
    "address_end": 48143,
    "hex_start": "$BC0F",
    "hex_end": "$BC0F",
    "label": "MOVEF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48143         $BC0F          MOVEF\nCopy FAC1 to FAC2 Without Rounding"
  },
  {
    "id": "map-BC1B",
    "address_start": 48155,
    "address_end": 48155,
    "hex_start": "$BC1B",
    "hex_end": "$BC1B",
    "label": "ROUND",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48155         $BC1B          ROUND\nRound Accumulator #1 by Adjusting the Rounding Byte\n\nIf doubling the rounding byte at location 112 ($70) makes it greater\nthan 128, the value of FAC1 is increased by 1."
  },
  {
    "id": "map-BC2B",
    "address_start": 48171,
    "address_end": 48171,
    "hex_start": "$BC2B",
    "hex_end": "$BC2B",
    "label": "SIGN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48171         $BC2B          SIGN\nPut the Sign of Accumulator #1 into .A Register\n\nOn exit from this routine the Accumulator will hold a 0 if FAC1 is 0,\na 1 if it is positive, and a value of 255 ($FF) if it is negative."
  },
  {
    "id": "map-BC39",
    "address_start": 48185,
    "address_end": 48185,
    "hex_start": "$BC39",
    "hex_end": "$BC39",
    "label": "SGN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48185         $BC39          SGN\nPerform SGN\n\nThe SGN routine calls the above routine to put the sign of FAC1 into\n.A, and then converts that value into a floating point number in FAC1."
  },
  {
    "id": "map-BC58",
    "address_start": 48216,
    "address_end": 48216,
    "hex_start": "$BC58",
    "hex_end": "$BC58",
    "label": "ABS",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48216         $BC58          ABS\nPerform ABS\n\nThe FAC1 sign byte at 102 ($66) is shifted right by this command, so\nthat the top bit is a 0 (positive)."
  },
  {
    "id": "map-BC5B",
    "address_start": 48219,
    "address_end": 48219,
    "hex_start": "$BC5B",
    "hex_end": "$BC5B",
    "label": "FCOMP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48219         $BC5B          FCOMP\nCompare FAC1 to Memory\n\nOn entry to this routine, .A and .Y point to a five-byte floating\npoint number to be compared to FAC1.  After the comparison, .A holds 0\nif the two are equal, a 1 if the value of FAC1 is greater than that in\nthe memory location, and 255 ($FF) if the value of FAC1 is less than\nthat in the memory location."
  },
  {
    "id": "map-BC9B",
    "address_start": 48283,
    "address_end": 48283,
    "hex_start": "$BC9B",
    "hex_end": "$BC9B",
    "label": "QINT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48283         $BC9B          QINT\nConvert FAC1 into Integer Within FAC1\n\nThis routine converts the value in FAC1 into a four-byte signed\ninteger in 98- 101 ($62-$65), with the most significant byte first."
  },
  {
    "id": "map-BCCC",
    "address_start": 48332,
    "address_end": 48332,
    "hex_start": "$BCCC",
    "hex_end": "$BCCC",
    "label": "INT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48332         $BCCC          INT\nPerform INT\n\nThis routine removes the fractional part of a floating point number by\ncalling the routine above to change it to an integer, and then\nchanging the integer back to floating point format."
  },
  {
    "id": "map-BCF3",
    "address_start": 48371,
    "address_end": 48371,
    "hex_start": "$BCF3",
    "hex_end": "$BCF3",
    "label": "FIN",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48371         $BCF3          FIN\nConvert an ASCII String to a Floating Point Number FAC1\n\nThis routine is called by VAL to evaluate and convert an ASCII string\nto a floating point number."
  },
  {
    "id": "map-BD7E",
    "address_start": 48510,
    "address_end": 48510,
    "hex_start": "$BD7E",
    "hex_end": "$BD7E",
    "label": "FINLOG",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48510         $BD7E          FINLOG\nAdd Signed Integer to FAC1\n\nThis routine is used to add an ASCII digit that has been converted to\na signed integer to FAC1."
  },
  {
    "id": "map-BDB3",
    "address_start": 48563,
    "address_end": 48563,
    "hex_start": "$BDB3",
    "hex_end": "$BDB3",
    "label": "NO999",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48563         $BDB3          NO999\n\nThis table of three floating point constants holds the values\n99,999,999.5, 999,999,999.5 and 1,000,000,000.  These values are used\nin converting strings to floating point numbers."
  },
  {
    "id": "map-BDC0",
    "address_start": 48576,
    "address_end": 48576,
    "hex_start": "$BDC0",
    "hex_end": "$BDC0",
    "label": "INPRT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48576         $BDC0          INPRT\nPrint IN Followed by a Line Number"
  },
  {
    "id": "map-BDCD",
    "address_start": 48589,
    "address_end": 48589,
    "hex_start": "$BDCD",
    "hex_end": "$BDCD",
    "label": "LINPRT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48589         $BDCD          LINPRT\nOutput a Number in ASCII Decimal Digits\n\nThis routine is used to output the line number for the routine above.\nIt converts thenumber whose high byte is in .A and whose low byte is\nin .X to a floating point number.  It also calls the routine below,\nwhich converts the floating point number to an ASCII string."
  },
  {
    "id": "map-BDDD",
    "address_start": 48605,
    "address_end": 48605,
    "hex_start": "$BDDD",
    "hex_end": "$BDDD",
    "label": "FOUT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48605         $BDDD          FOUT\nConvert Contents of FAC1 to ASCII String\n\nThis routine converts a floating point number to a string of ASCII\ndigits, and sets a pointer to the string in .A and .Y."
  },
  {
    "id": "map-BF11",
    "address_start": 48913,
    "address_end": 48913,
    "hex_start": "$BF11",
    "hex_end": "$BF11",
    "label": "FHALF",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48913         $BF11          FHALF\nThe Constant Value 1/2 in Five-Byte Floating Point Notation\n\nThis constant is used for rounding and SQR."
  },
  {
    "id": "map-BF1C",
    "address_start": 48924,
    "address_end": 48924,
    "hex_start": "$BF1C",
    "hex_end": "$BF1C",
    "label": "FOUTBL",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48924         $BF1C          FOUTBL\nPowers of Minus Ten Constants Table\n\nThis table contains the powers of -10 expressed as four-byte floating\npoint numbers (that is, -1; +10; -100; +1000; -10,000; +100,000;\n-1,000,000; +10,000,000; and -100,000,000)."
  },
  {
    "id": "map-BF3A",
    "address_start": 48954,
    "address_end": 48954,
    "hex_start": "$BF3A",
    "hex_end": "$BF3A",
    "label": "FDCEND",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48954         $BF3A          FDCEND\nTable of Constants for TI$ Conversion\n\nThis table contains the floating point representation of the powers of\n-60 multiplied by 1 or 10.  These constants are used for converting\nTI$ to ASCII."
  },
  {
    "id": "map-BF52",
    "address_start": 48978,
    "address_end": 48978,
    "hex_start": "$BF52",
    "hex_end": "$BF52",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "48978         $BF52\nUnused area\n\nThis unused area is filled with byts of 170 ($AA)."
  },
  {
    "id": "map-BF71",
    "address_start": 49009,
    "address_end": 49009,
    "hex_start": "$BF71",
    "hex_end": "$BF71",
    "label": "SQR",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "49009         $BF71          SQR\nPerform SQR\n\nThis routine moves the contents of FAC1 to FAC2, moves the constant\n0.5 to FAC1, and falls through to the exponentation routine."
  },
  {
    "id": "map-BF7B",
    "address_start": 49019,
    "address_end": 49019,
    "hex_start": "$BF7B",
    "hex_end": "$BF7B",
    "label": "FPWRT",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "49019         $BF7B          FPWRT\nPerforms Exponentation (Power Calculation Called for by UPARROW)\n\nThis routine raises the value in FAC2 to the power in FAC1 and leaves\nthe result in FAC1."
  },
  {
    "id": "map-BFB4",
    "address_start": 49076,
    "address_end": 49076,
    "hex_start": "$BFB4",
    "hex_end": "$BFB4",
    "label": "NEGOP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "49076         $BFB4          NEGOP\nPerform NOT and >\n\nThis negates the Floating Point Accumulator by exclusive ORing the\nsign byte with a constant of 255 ($FF).  Zero is left unchanged.  The\nresults of this command follow rom the formula NOT X=-(X+1).\nTherefore, if you NOT a tatement that is true (-1), you get 0 (false)."
  },
  {
    "id": "map-BFBF",
    "address_start": 49087,
    "address_end": 49087,
    "hex_start": "$BFBF",
    "hex_end": "$BFBF",
    "label": "EXPCON",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "49087         $BFBF          EXPCON\nTable of Constants for EXP and LOG in Five-Byte Floating Point Format\n\nThese tables are used to calculate 2 to the N power."
  },
  {
    "id": "map-BFED",
    "address_start": 49133,
    "address_end": 49133,
    "hex_start": "$BFED",
    "hex_end": "$BFED",
    "label": "EXP",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "49133         $BFED          EXP\nPerform EXP\n\nThis routine calculates the natural logarithm e (2.718281828...)\nraised to the power in FAC1.  The result is left in FAC1.\n\nThis routine is split between the BASIC ROM wich ends at 49151 ($BFFF)\nand the Kernal ROM which begins at 57344 ($E000).  Therefore, a JMP\n$E000 instruction is tacked on to the end, which makes the BASIC\nroutines in the 64 Kernal ROM three bytes higher in memory than the\ncorresponding VIC-20 routines."
  },
  {
    "id": "map-C000-CFFF",
    "address_start": 49152,
    "address_end": 53247,
    "hex_start": "$C000",
    "hex_end": "$CFFF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::Chapter 5 ::",
    "type": "location",
    "text": "49152-53247   $C000-$CFFF\n4K Free RAM\n\nLocations 49152 to 53247 ($C000 to $CFFF) are free RAM.  Since this\narea is not contiguous with the BASIC program text RAM area, it is not\navailable for BASIC program or variable storage (it is not counted in\nthe FRE(0) total).\n\nThis area is fully available for any other use, however, sudh as\nstoring machine language subroutines for use with BASIC, alternate I/O\ndrivers for parallel or IEEE devices, character graphics or sprite\ndata, etc.\n\nThis large free area is such a tempting spot for system additions that\nmany such applications may be competing for the same RAM space.  For\nexample, the Universal Wedge DOS Support program that adds easy access\nto the disk communications channel is usually loaded at 52224 ($CC00).\nPrograms that use that part of RAM will therefore overwrite the DOS\nsupport program, with the result that they may not run correctly, or\neven at all.  Likewise, Simon's BASIC, the extended language which\nCommodore has released on cartridge, uses several locations in this\nrange.  Be aware of this potential problem when you buy hardware\nadditions that use this spot to hook into the system.\n\n\n::::::::::::::::::::\n::                ::\n::VIC-II, SID, I/O::\n:: Devices, Color ::\n::    RAM, and    ::\n:: Character ROM  ::\n::::::::::::::::::::"
  },
  {
    "id": "map-D000-DFFF",
    "address_start": 53248,
    "address_end": 57343,
    "hex_start": "$D000",
    "hex_end": "$DFFF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53248-57343   $D000-$DFFF\n\nThis 4K block of memory is used for several key functions.  Normally,\nthe 6510 microprocessor addresses the two Complex Interface Adapter\n(CIA) Input/Output chips here, along with the VIC-II video controller\nchip, the Sound Interface Device (SID) music synthesizer, and the\nColor RAM.\n\nAlternatively, the 6510 can address the character ROM here (though\nnormally only the VIC-II chip has access to it).  Finally, there is\nalso 4K of RAM here, although to use it may require banking it in only\nwhen necessary, as the I/O devices are needed for such niceties as\nreading he keyboard, and updating the screen display.\n\nIt will appear from the map of the I/O devices below that many of the\nlocations are not accounted for.  That is beause these devices tie up\nmore addressing space than they actually use.  Each of them uses only\na few addresses, mostly on the bit level.\n\nThe missing addresses either consist of images of the hardware\nregisters, or cannot be addressed in this configuration.  In addition,\nsome address space is left open for the use of future hardware devices\nwhich might be plugged into the expansion port, like the CP/M card.\n\nAs mentioned above, memory usage by these I/O devices is to intensive\nthat to work with them often requires that you turn individual bits on\nand off.  Here is a quick reminder of how to manipulate bits.\n\nThe bit values for each bit are:\n\nBit 0 = 1\nBit 1 = 2\nBit 2 = 4\nBit 3 = 8\nBit 4 = 16\nBit 5 = 32\nBit 6 = 64\nBit 7 = 128\n\nTo set a bit to 1 from BASIC, POKE address, PEEK(address) OR Bitvalue.\nTo reset a bit to 0 from BASIC, POKE address, PEEK(address) AND\n255-Bitvalue."
  },
  {
    "id": "map-D000-D02E",
    "address_start": 53248,
    "address_end": 53294,
    "hex_start": "$D000",
    "hex_end": "$D02E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53248-53294   $D000-$D02E\nVIC-II Chip Registers\n\nThe Video Interface Controller (VIC-II chip) is a specially designed\nprocessor that is in charge of the 64's video display.  It is this\nchip which makes possible the 64's wide range of graphics\ncapabilities.\n\nThe VIC-II chip's ability to address memory is independent of the 6510\nmicroprocessor.  It can address only 16K at a time, and any of the\nfour blocks of 16K can be chosen for video memory.  The system default\nis for it to use the first 16K.\n\nAll of the video display memory, character dot data, and sprite shapes\nmust be stored within the chosen 16K block.  Locations 53248-53294\n($D000-$D02E) are registers which allow the user to communicate with\nthe VIC-II chip.  Although for the most part they can be written to\nand read like ordinary memory locations, their contents directly\ncontrol the video display.  Since many of these locations work in\nclose conjunction with others, a general overview of some of the\ndifferent graphics systems on the 64 is in order.\n\nThe most familiar type of graphics display is the ordinary text that\nappears when you turn the machine on.  The area of RAM which is\ndisplayed on the screen is determined by the Video Matrix Base Address\nNybble of the VIC-II Memory Control Register (53272, $D018).  The\naddress of the dot-data which is used to assign a shape to each text\ncharacter based on an 8 by 8 matrix of lit or unlit dots is determined\nby the other half of the Memory Control Register at 53272 ($D018).\nMore information on how the data is used to represent the character\nshapes may be found at the alternate entry for 49152 ($C000), the\nCharacter Generator ROM.\n\nText character graphics may employ one of the two sets of text and\ngraphics characters in the Character Generator ROM, or the user may\nsubstitute a completely different set of graphics or text characters\nin RAM.\n\nNormally, the text graphics screen uses a background color which is\ncommon to all text characters, and that value is stored in Background\nColor Register 0 (53281, $D021).  The color of the frame around the\nscreen is determined by the Border Color Register at 53280 ($D020).\n\nThe color of each character is determined by one nybble of the Color\nRAM which starts at 55296 ($D800).  There are, however, two variations\nwhich alter this scheme somewhat.\n\nThe first is called multicolor text mode, and is set by Bit 4 of 53270\n($D016).  Instead of each bit selecting either the foreground or the\nbackground color for each dot in the character, bit-pairs are used to\nselect one of four colors for each double-width dot.  This results in\nthe horizontal resolution being cut to four dots across per character,\nbut allows two extra colors to be introduced from Background Color\nRegisters 1 and 2 (53282-53283, $D022-$D023).\n\nThe other text mode is called Extended Background Color Mode.  In this\nmode, the foreground color is always selected by the Color RAM.  The\nbackground color depends on the actual screen code of the character.\nIn this mode, only the first 64 character shapes are available, but\neach can have one of four different background colors.\n\nThe background color for each character is determined by its screen\ncode as follows:\n\n1.  If the screen code is from 0-63 (this includes the normal\nalphanumerics), the value in Background Color Register 0 (53281,\n$D021) will determine the background color, as is usual.\n\n2.  Characters with codes 64-255 will have the same shape as the\ncorresponding character in the group with codes 0-63.\n\n3.  For characters with codes 64-127 (SHIFTed characters), the\nbackground colors are deterined by the value in Background Color\nRegister 1 (53282, $D022).\n\n4.  The value in Background Color Register 2 (53283, $D023) is used\nfor characters with codes 128-191 (reversed alphanumerics).\n\n5.  For characters with codes 192-255, the value in Background Color\nRegister 3 (53284, $D024) is used to determine the background color.\n\n\nIn place of the normal text mode, a bitmap graphics mode is also\nabailable by setting Bit 5 of location 53265 ($D011).  In this mode,\neach bit of data determines whether one dot on the screen will be set\nto either the background color or foreground color.  Within an 8 by 8\ndot area, the foreground and background colors may be individually\nselected.\n\nThe bitmap area is 320 dots wide and 200 dots high.  The area which\ncontains the graphics data, the bitmap, is determined by the Character\nDot Data Base Address in the lower nybble of the VIC-II Memory Control\nRegister (53272, $D018).  The Video Matrix Base Address in the upper\nnybble, which normally determines which area of memory will be\ndisplayed, instead determines where the color memory for each 8 by 8\nground of dots will be located.\n\nThe Color RAM is not used for high-resolution bitmap graphics.  But\nmulticolor mode is also available for bitmap graphics, and it uses the\nColor RAM to determine the foreground color of each dot.\n\nAs with multicolor text mode, the horizontal resolution is but in half\n(to 160 dots across), so that in addition to the foreground and\nbackground colors, each dot can be one of two other colors as well.\nThis mode gets the value for the two extra colors from the two nybbles\nof each byte of bitmap color memory, the location of which is\ndetermined by the Video Matrix Base Address.\n\nMulticolor text mode offers four colors, three of which will be common\nto all characters, and one of which can be selected individually.\nMulticolor bitmap mode offers a choice of four colors, three of which\ncan be individually selected within an 8 by 8 dot area.\n\nThe 64 also contains an entirely separate graphics system, whose\ncharacter shapes, colors, and positions are derived and displayed\nwithout any reference to the Video Matrix and Character Dot-Data\naddresses.  Best of all, these characters may be moved quickly and\neasily to any position on the screen, greatly facilitating games and\nanimated graphics of all types.  This system is known as sprite\ngraphics.\n\nSprite graphics takes its name from the graphics characters it\ndisplays, each of which is called a sprite.  There are eight sprites,\nknown as Sprites 0-7.  Each sprite character is 24 dots wide by 21\ndots high.  This is about eight times as large as a regular text\ncharacter, which is only 8 dots wide by 8 dots high.\n\nA sprite takes its shape from 63 bytes of data in one of the 256 data\nblocks, each 64 bytes long, that can fit into the 16K space which the\nVIC-II chip can address.  The block currently assigned to any given\nsprite is determined by the Sprite Data Pointers, which are located at\nthe last eight bytes of the screen memory area (the default locations\nare 2040-2047, $7F8-$7FF).\n\nThe first Sprite Data Pointer determines the data block used for the\nshape of Sprite 0, the second for the shape of Sprite 1, etc.  The\nnumber in the pointer times 64 equals the address of the first byte of\nthe data block within the VIC-II addressing range.\n\nFor example, using the default values for VIC-II addressing area and\nscreen memory, a value of 11 in location 2040 ($7F8) would mean that\nthe shape of Sprite0 is determined by the data in the 63-byte block\nstarting at location 704 (11*64).  It should be noted that it is\npossible for more than one sprite to take its shape data from the same\nblock, so that only 64 bytes of data are required to create eight\nsprites, each having the same shape.\n\nThe dot patterns of each sprite correspond to the bit patterns of the\nsprite shape data.  Each byte of shape data in memory consists of a\nnumber from 0 to 255.  This number can be represented by eight binary\ndigits of 0 or 1.\n\nEach binary digit has a bit value that is two times greater than the\nlast.  If the digit in the zero bit place is a 1, it has a value of 1\n(we count bit places from 0 to 7).  A 1 in the first bit place has a\nvalue of 2, the second bit has a value of 4, the third has a value of\n8, the fourth has a vlue of 16, the fifth a value of 32, the sixth a\nvalue of 64, and the seventh a value of 128.\n\nBy making all of the possible combinations of 0's and 1's in all eight\nbit places, and adding the bit values of every bit place that contains\na 1, we can represent every number from 0 to 255 as a series of 1's\nand 0's.\n\nIf you think of every 0 as a dot having the same color as the\nbackground, and every 1 as a dot which is the color of the sprite, you\ncan see how a series of bytes could be used to represent the sprite\nshape.\n\nSince each line of the sprite is 24 dots wide, it takes 3 bytes of\nmemory (24 bits) per line to portray its shape.  Let's take a look at\na couple of sample sprite lines.\n\n00000000 01111110 00000000 = 0, 126, 0\n\nAs you can see, the first and last bytes are all 0's, so nothing will\nbe displayed there.  The middle byte has six 1's, so it will be\ndisplayed as a line six dots long.  By adding the values of these dix\nbits (64+32+16+8+4+2), we get a byte value of 126.  Let's try another\nline.\n\n00011111 11111111 11111000 = 21, 255, 248\n\nThe first byte has five bits set to 1, having values of 16, 8, 4, 2,\nand 1, for a total of 31.  The second byte has all bits set to 1, so\nit has the maximum value of 255.  The third byte also has five bits\nset to 1, having values of 128, 64, 32, 16, and 8, for a total of 248.\nThe result is that this line of sprite data will display a line that\nis 18 dots long.\n\nWe can put these two kinds of lines together to show how a large cross\nmight be drawn using bytes of sprite data.\n\n000000000000000000000000 = 0, 0, 0\n000000000000000000000000 = 0, 0, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000111111111111111111000 = 21, 255, 248\n000111111111111111111000 = 21, 255, 248\n000111111111111111111000 = 21, 255, 248\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000000000000000000 = 0, 0, 0\n000000000000000000000000 = 0,0,0\n\nThe 63 numbers, displayed three per line opposite the bit patters they\nrepresent, are the values that would have to be put in the sprite\nshape data area in order to display this cross using sprite graphics.\n\nEven after the sprite shape data has been placed in memory, and the\nSprite Data Pointer has been set to display that block of data bytes\nas the sprite shape, there are still several steps that must be taken\nin order to display the sprite on the screen.\n\nThe proper bit of the Sprite Display Enable Register at 53269 ($D015)\nmust be set to 1 in order to turn on the sprite display.  A horizontal\nand vertical screen position must be selected for the sprite by means\nof the horizontal and vertical position registers (53248-53264,\n$D000-$D010).  Finally, the color value of the sprite should be placed\nin the appropriate Sprite Color Register (53287-53294, $D027-$D02E).\n\nOnce you have the sprite on the screen, animation is fairly simple to\nachieve.  Moving the sprite is as easy as changing the values in the\nsprite position registers.  Changing the sprite shape can be\naccomplished by merely changing the Sprite Data Pointer to point to\nanother block of shape data in memory.\n\nThere are also some optional sprite graphics features available which\nenhance its flexibility.  Sprite expand registers allow you to make\neach sprite twice as wide as normal, twice as tall, or both.\nCollision detection registers let you know when a sprite shape\noverlaps a regular text character or bitmap dot, or if two sprites are\ntouching.\n\nIf a sprite is positioned in the same place on the screen as a text\ncharacter or bitmap dot, a Priority Register allows you to choose\nwhether the sprite or the normal graphics will by displayed.  This\nenables three- dimensional effects by letting you choose whether the\nsprite goes in front of or behind other objects on the screen.\n\nFinally, any sprite may be selected for multicolor display, using the\nregister at location 53276 ($D01C).  In this mode, as in multicolor\ntext and bitmap modes, pairs of bits are used to determine the color\nof each double- width dot.  The possible color values which may be\nselected are those of Background Color Register 0, the Sprite Color\nRegister, or the two color values in the Sprite Multicolor Registers\nat 53285-53286 ($D025-$D026)."
  },
  {
    "id": "map-D000-D010",
    "address_start": 53248,
    "address_end": 53264,
    "hex_start": "$D000",
    "hex_end": "$D010",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 53248-53264 ($D000-$D010)\nSprite Horizontal and Vertical Position Registers\n\nThese locations determine the horizontal and vertical position at\nwhich each sprite will be displayed on the screen.  Each sprite has\nits own horizontal and vertical position register.  In addition, all\nof the sprites share a common register which is used to extend the\nrange of horizontal positions.\n\nVertical positions for each sprite range from 0 to 255, and these\nindicate the vertical position of the top line of the sprite's 21-line\nlength.  Since there are only 200 visible scan lines in the screen\ndisplay, some of these vertical positions will result in the sprite\nbeing partially or wholly offscreen.\n\nThe visible viewing area starts at line 50 and extends to line 249.\nTherefore, any sprite whose vertical psition is 29 ($1D) or less will\nbe completely above the visible picture.  At vertical position 30\n($1E), the bottom line of the sprite display becomes visible at the\ntop of the screen.  At position 230 ($E6), the bottom line of the\nsprite is lost from view off the bottom of the screen, and at vertical\nposition 250 ($FA), the entire sprite disappears from view off the\nbottom edge of the screen.\n\nHorizontal positioning is somewhat trickier, because the visible\ndisplay area is 320 dots wide, and one eight-bit register can hold\nonly 256 position values.  Therefore, an additional register is needed\nto hold the ninth bit of each sprite's horizontal position.\n\nEach sprite is assigned a single bit in the Most Significant Bit of\nHorizontal Position register (MSB register) at 53264 ($D010).  If that\nbit is set to 1, the value 256 is added to the horizontal position.\nThis extends the range of possible horizontal positions to 511.\n\nIn order to set a sprite's horizontal position, you must make sure\nthat both the values in the horizontal position register and the MSB\nRegister are correct.  For example, if you wish to set the horizontal\nposition of Sprite 5 to a value of 30, you must place a value of 30 in\nthe Sprite 5 Horizontal Position Register (POKE 53258,30 will do it\nfrom BASIC), and you must also clear Bit 5 of the MSB Register (POKE\n53264,PEEK(53264)AND(255-16)).  If you forget the MSB register, and\nBit 5 is set to 1, you will end up with position 286 instead of 30.\n\nThe horizontal position value indicates the position of the leftmost\ndot of the sprite's 24-dot width.  The visible display is restricted\nto the 320 dot positions between positions 24 and 344.  At position 0\nthe whole sprite is past the left edge of the visible screen.  At\nposition 1 the righmost dot enters the display area, and at position\n24 ($18) the entire sprite is displayed on screen.  At position 321\n($141) the rightmost dot goes past the right edge of the visible\ndisplay area, and a position 355 ($158) the whole sprite has moved out\nof sight, off the right edge of the screen.\n\nThese registers are all intialized to 0 at power-up."
  },
  {
    "id": "map-D000",
    "address_start": 53248,
    "address_end": 53248,
    "hex_start": "$D000",
    "hex_end": "$D000",
    "label": "SP0X",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53248         $D000          SP0X\nSprite 0 Horizontal Position"
  },
  {
    "id": "map-D001",
    "address_start": 53249,
    "address_end": 53249,
    "hex_start": "$D001",
    "hex_end": "$D001",
    "label": "SP0Y",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53249         $D001          SP0Y\nSprite 0 Vertical Position"
  },
  {
    "id": "map-D002",
    "address_start": 53250,
    "address_end": 53250,
    "hex_start": "$D002",
    "hex_end": "$D002",
    "label": "SP1X",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53250         $D002          SP1X\nSprite 1 Horizontal Position"
  },
  {
    "id": "map-D003",
    "address_start": 53251,
    "address_end": 53251,
    "hex_start": "$D003",
    "hex_end": "$D003",
    "label": "SP1Y",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53251         $D003          SP1Y\nSprite 1 Vertical Position"
  },
  {
    "id": "map-D004",
    "address_start": 53252,
    "address_end": 53252,
    "hex_start": "$D004",
    "hex_end": "$D004",
    "label": "SP2X",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53252         $D004          SP2X\nSprite 2 Horizontal Position"
  },
  {
    "id": "map-D005",
    "address_start": 53253,
    "address_end": 53253,
    "hex_start": "$D005",
    "hex_end": "$D005",
    "label": "SP2Y",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53253         $D005          SP2Y\nSprite 2 Vertical Position"
  },
  {
    "id": "map-D006",
    "address_start": 53254,
    "address_end": 53254,
    "hex_start": "$D006",
    "hex_end": "$D006",
    "label": "SP3X",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53254         $D006          SP3X\nSprite 3 Horizontal Position"
  },
  {
    "id": "map-D007",
    "address_start": 53255,
    "address_end": 53255,
    "hex_start": "$D007",
    "hex_end": "$D007",
    "label": "SP3Y",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53255         $D007          SP3Y\nSprite 3 Vertical Position"
  },
  {
    "id": "map-D008",
    "address_start": 53256,
    "address_end": 53256,
    "hex_start": "$D008",
    "hex_end": "$D008",
    "label": "SP4X",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53256         $D008          SP4X\nSprite 4 Horizontal Position"
  },
  {
    "id": "map-D009",
    "address_start": 53257,
    "address_end": 53257,
    "hex_start": "$D009",
    "hex_end": "$D009",
    "label": "SP4Y",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53257         $D009          SP4Y\nSprite 4 Vertical Position"
  },
  {
    "id": "map-D00A",
    "address_start": 53258,
    "address_end": 53258,
    "hex_start": "$D00A",
    "hex_end": "$D00A",
    "label": "SP5X",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53258         $D00A          SP5X\nSprite 5 Horizontal Position"
  },
  {
    "id": "map-D00B",
    "address_start": 53259,
    "address_end": 53259,
    "hex_start": "$D00B",
    "hex_end": "$D00B",
    "label": "SP5Y",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53259         $D00B          SP5Y\nSprite 5 Vertical Position"
  },
  {
    "id": "map-D00C",
    "address_start": 53260,
    "address_end": 53260,
    "hex_start": "$D00C",
    "hex_end": "$D00C",
    "label": "SP6X",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53260         $D00C          SP6X\nSprite 6 Horizontal Position"
  },
  {
    "id": "map-D00D",
    "address_start": 53261,
    "address_end": 53261,
    "hex_start": "$D00D",
    "hex_end": "$D00D",
    "label": "SP6Y",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53261         $D00D          SP6Y\nSprite 6 Vertical Position"
  },
  {
    "id": "map-D00E",
    "address_start": 53262,
    "address_end": 53262,
    "hex_start": "$D00E",
    "hex_end": "$D00E",
    "label": "SP7X",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53262         $D00E          SP7X\nSprite 7 Horizontal Position"
  },
  {
    "id": "map-D00F",
    "address_start": 53263,
    "address_end": 53263,
    "hex_start": "$D00F",
    "hex_end": "$D00F",
    "label": "SP7Y",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53263         $D00F          SP7Y\nSprite 7 Vertical Position"
  },
  {
    "id": "map-D010",
    "address_start": 53264,
    "address_end": 53264,
    "hex_start": "$D010",
    "hex_end": "$D010",
    "label": "MSIGX",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53264         $D010          MSIGX\nMost Significant Bits of Sprites 0-7 Horizontal Position\n\nBit 0:  Most significant bit of Sprite 0 horizontal position\nBit 1:  Most significant bit of Sprite 1 horizontal position\nBit 2:  Most significant bit of Sprite 2 horizontal position\nBit 3:  Most significant bit of Sprite 3 horizontal position\nBit 4:  Most significant bit of Sprite 4 horizontal position\nBit 5:  Most significant bit of Sprite 5 horizontal position\nBit 6:  Most significant bit of Sprite 6 horizontal position\nBit 7:  Most significant bit of Sprite 7 horizontal position\n\nSetting one of these bites to 1 adds 256 to the horizontal position of\nthe corresponding sprite.  Resetting one of these bits to 0 restricts\nthe horizontal position of the corresponding sprite to a value of 255\nor less"
  },
  {
    "id": "map-D011",
    "address_start": 53265,
    "address_end": 53265,
    "hex_start": "$D011",
    "hex_end": "$D011",
    "label": "SCROLY",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53265         $D011          SCROLY\nVertical Fine Scrolling and Control Register\n\nBits 0-2:  Fine scroll display vertically by X scan lines (0-7)\nBit 3:  Select a 24-row or 25-row text display (1=25 rows, 0=24 rows)\nBit 4:  Blank the entire screen to the same color as the background\n  (0=blank)\nBit 5:  Enable bitmap graphics mode (1=enable)\nBit 6:  Enable extended color text mode (1=enable)\nBit 7:  High bit (Bit 8) of raster compare register at 53266 ($D012)\n\nThis is one of the two important multifunction control registers on\nthe VIC-II chip.  Its defaule value is 155, which sets the high bit of\nthe raster compare to 1, selects a 25-row display, disables the\nblanking feature, and uses a vertical scrolling offset of three scan\nlines.\n\nBits 0-2.  These bits control vertical fine scrolling of the screen\ndisplay.  This feature allows you to move the entire text display\nsmoothly up and down, enabling the display area to act as a window,\nscrolling over a larger text or character graphics display.\n\nSince each row of text is eight scan lines high, if you simply move\neach line of text up one row, the characters travel an appreciable\ndistance each time they move, which gives the motion a jerky quality.\nThis is called coarse scrolling, and you can see an example of it when\nLISTing a program that is too long to fit on the screen all at one\ntime.\n\nBy placing a number from 1 to 7 into these three bits, you can move\nthe whole screen display down by from 1 to 7 dot spaces.  Stepping\nthrough the values 1 to 7 allows you to smoothly make the transition\nfrom having a character appear in one row on the screen to having it\nappear in the next row.  To demonstrate this, type in the following\nsample program, LIST it, and RUN.\n\n10 FOR I= 1 TO 50:FOR J=0 TO 7\n20 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I\n30 FOR I= 1 TO 50:FOR J=7 TO 0 STEP-1\n40 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I\n\nAs you can see, after the display has moved seven dot positions up or\ndown, it starts over at its original position.  In order to continue\nthe scroll, you must do a coarse scroll every time the value of the\nscroll bits goes from 7 to 0, or from 0 to 7.  This is accomplished by\nmoving the display data for each line by 40 bytes in either direction,\noverwriting the data for the last line, and introducing a line of data\nat the opposite end of screen memory to replace it.  Obviously, ony a\nmachine language program can move all of these lines quickly enough to\nmaintain the effect of smooth motion.  The following BASIC program,\nhowever, will give you an iea of what vertical fine scrolling is like:\n\n10 POKE 53281,0:PRINTCHR$(5);CHR$(147)\n20 FORI=1 TO 27:\n30 PRINTTAB(15)CHR$(145)\"            \":POKE 53265,PEEK(53265)AND248\n40 WAIT53265,128:PRINTTAB(15)\"I'M FALLING\"\n50 FOR J=1 TO 7\n60 POKE53265,(PEEK(53265)AND248)+J\n70 FORK=1TO50\n80 NEXT K,J,I:RUN\n\nBit 3.  This bit register allows you to select either the normal\n25-line text display (by setting the bit to 1), or a shortened 24-row\ndisplay (by resetting that bit to 0).  This shortened display is\ncreated by extending the border to overlap the top or bottom row.  The\ncharacters in these rows are still there; they are just covered up.\n\nThe shortened display is designed to aid vertical fine scrolling.  It\ncovers up the line into which new screen data is introduced, so that\nthe viewer does not see the new data being moved into place.\n\nHowever, unlink the register at 53270 ($D016) which shortens the\nscreen by one character space on either side to aid horizontal\nscrolling in either direction, this register can blank only one\nvertical line at a time.  In order to compensate, it blanks the top\nline when the three scroll bits in this register are set to 0, and\nshifts the blanking one scan line at a time as the value of thee bits\nincreases.  Thus the bottom line is totally blanked when these bits\nare set to 7.\n\nBit 4.  Bit 4 of this register controls the screen blanking feature.\nWhen this bit is set to 0, no data can be displayed on the screen.\nInstead, the whole screen will be filled with the color of the frame\n(which is controlled by th eBorder Color Register at 53280 ($D020)).\n\nScreen blanking is useful because of the way in which the VIC-II chip\ninteracts with the 6510 microprocessor.  Since the VIC-II and the 6510\nboth have to address the same memory, they must share the system data\nbus.  Sharing the data bus means that they must take turns whenever\nthey want to address memory.\n\nThe VIC-II chip was designed so that it fetches most of the data it\nneeds during the part of the cycle in which the 6510 is not using the\ndata bus.  But certain operations, such as reading the 40 screen codes\nneeded for each line of text from video mmeory, or fetching sprite\ndata, require that the VIC-II chip get data at a faster rate than is\npossible just by using the off half of the 6510 cycle.\n\nThus, the VIC-II chip must delay the 6510 for a short amount of time\nwhile it is using the data bus to gather display information for text\nor bitmap graphics, and must delay it a little more if sprites are\nalso enabled.  When you set the screen blanking bit to 0, these delays\nare eliminated, and the 6510 processor is allowed to run at its full\nspeed.  This speeds up any processing task a little.\n\nTo demonstrate this, run the following short program.  As you will\nsee, leaving the screen on makes the processor run about 7 percent\nslower than when you turn it off.  If you perform the same timing test\non the VIC-20, you will find that it runs at the same speed with its\nscreen on as the 64 does with its screen off.  And the same test on a\nPET will run substantially slower.\n\n10 PRINT CHR$(147);TAB(13);\"TIMING TEST\":PRINT:TI$=\"000000\":GOTO 30\n20 FOR I=1 TO 10000:NEXT I:RETURN\n30 GOSUB 20:DISPLAY=TI\n40 POKE 53265,11:TI$=\"000000\"\n50 GOSUB 20:NOSCREEN=TI:POKE 53265,27\n60 PRINT \"THE LOOP TOOK\";DISPLAY;\" JIFFIES\"\n70 PRINT \"WITH NO SCREEN BLANKING\":PRINT\n80 PRINT \"THE LOOP TOOK\";NOSCREEN;\" JIFFIES\"\n90 PRINT \"WITH SCREEN BLANKING\":PRINT\n100 PRINT \"SCREEN BLANKING MAKE THE PROCESSOR\"\n110 PRINT \"GO\";DISPLAY/NOSCREEN*100-100;\"PERCENT FASTER\"\n\nThe above explanation accounts for the screen being turned off during\ntape read and write operations.  The timing of these operations is\nrather critical, and would be affected by even the relatively small\ndelay caused by the video chip.  It also explains why the 64 has\ndifficulty loading programs from an unmodified 1540 Disk Drive, since\nthe 1540 was set up to transfer data from the VIC-20, which does not\nhave to contend with these slight delays.\n\nIf you turn off the 64 display with a POKE 53265,PEEEK(53265) AND 239,\nyou will be able to load programs correctly from an old 1540 drive.\nThe new 1541 drive transfers data at a slightly slower rate in the\ndefault setting, and can be set from software to transfer it at the\nhigher rate for the VIC-20.\n\nBit 5.  Setting Bit 5 of this register to 1 enables the bitmap\ngraphics mode.  In this mode, the screen area is broken down into\n64,000 separate dots of light, 320 dots across by 200 dots high.  Each\ndot corresponds to one bit of display memory.  If the bit is set to 1,\nthe dot will be displayed in the foreground color.  If the bit is\nreset to 0, it will be displayed in the background color.  This allows\nthe display of high-resolution graphics images for games, charts, and\ngraphs, etc.\n\nBitmapping is a common technique for implementing high-resolution\ngraphics on a microcomputer.  There are some features of the Commodore\nsystem which are unusual, however.\n\nMost systems display screen memory sequentially; that is, the first\nbyte controls the display of the first eight dots in the upper-left\ncorner of the screen, the second byte controls the eight dots to the\nright of that, etc.  In the Commodore system, display memory is laid\nout more along the lines of how character graphics dot-data is\narranged.\n\nThe first byte controls the row of eight dots in the top-left corner\nof the screen, but the next byte controls the eight dots below that,\nand so on until the ninth byte.  The ninth byte controls the eight\ndots directly to the right of those controlled by the first byte of\ndisplay memory.  It is exactly the same as if the screen were filled\nwith 1000 programmable characters, with display memory taking the\nplace of the character dot-data.\n\nThe 64's bitmap graphics mode also resembles character graphics in\nthat the foreground color of the dots is set by a color map (although\nit does not use the Color RAM for this purpose).  Four bits of each\nbyte of this color memory control the foreground color of one of these\neight-byte groups of display memory (which form an 8 by 8 grid of 64\ndots).  Unlike character graphics, however, the other four bits\ncontrol the background color that will be seen in the eight-byte\ndisplay group where a bit has a value of 0.\n\nSetting up a bitmap graphics screen is somewhat more complicated than\njust setting this register bit to 1.  You must first choose a location\nfor the display memory area, and for the color memory area.  The\ndisplay memory area will be 8192 bytes long (8000 of which are\nactually used for the display) and can occupy only the first or the\nsecond half of the 16K space which the VIC-II chip can address.\n\nEach byte of bitmap graphics color memory uses four bits for the\nbackground color as well as four bits for the foreground color.\nTherefore, the Color RAM nybbles at 55296 ($D800), which are wired for\nfour bits only, cannot be used.  Another RAM location must therefore\nbe found for color memory.\n\nThis color memory area will take up 1K (1000 bytes of which are\nactually used to control the foreground and background colors of the\ndots), and must be in the opposite half of VIC-II memory as the\ndisplay data.  Since bitmap graphics require so much memory for the\ndisplay, you may want to select a different 16K bank for VIC-II memory\n(see the discussion of things to consider in selecting a VIC-II memory\nbank at location 56576 ($DD00)).\n\nTo keep things simple, however, let's assume that you have selected to\nuse the default bank of VIC-II memory, which is the first 16K.  You\nwould have to select locations 8192-16383 ($2000-$3FFF) for screen\nmemory, because the VIC-II chip sees an image of the character ROM in\nthe first half of the 16K block (at locations 4096-8192\n($1000-$1FFF)).  Color memory could be placed at the default location\nof text display memory, at 1024-2047 ($400-$7FF).  Placement of bitmap\ndisplay and color memory is controlled by the VIC Memory Control\nRegister at 53272 ($D018).\n\nWhen in bitmap mode, the lower four bits of this register, which\nnormally control the base address of character dot-data, now control\nthe location of the 8K bitmap.  Only Bit 3 is significant.  If it is\nset to 1, the graphics display memory will be in the second 8K of\nVIC-II memory (in this case, starting at 8192 ($2000)).  If that bit\ncontains a 0, the first 8K will be used for the bitmap.  The upper\nfour bits of this register, which normally control the location of the\nVideo Display Matrix, are used in bitmap mode to establish the\nlocation of the color map within the VIC-II address space.  These four\nbits can hold a number from 0 to 15, which indicates on which 1K\nboundary the color map begins.  For example, if color memory began at\n1024 (1K), the value of these four bits would be 0001.\n\nOnce the bitmap mode has been selected, and the screen and color\nmemory areas set up, you must establish a method for turning each\nindividual dot on and off.  The conventional method for identifying\neach dot is to assign it to a horizontal (X) position coordinate and a\nvertical (Y) coordinate.\n\nHorizontal position values will range from 0 to 319, where dot 0 is at\nthe extreme left-hand side of the screen, and dot 319 at the extreme\nright.  Vertical positions will range from 0 to 199, where dot 0 is on\nthe top line, and dot 199 is on the bottom line.\n\nBecause of the unusual layout of bitmap screen data on the 64, it is\nfairly easy to transfer text characters to a bitmap screen, but it is\nsomewhat awkward finding the bit which affects the screen dot having a\ngiven X-Y coordinate.  First, you must find the byte BY in which the\nbit resides, and then you must POKE a vlue into that byte which turns\nthe desired bit on or off.  Given that the horizontal position of the\ndot is stored in the variable X, its vertical position is in the\nvariable Y, and the base address of the bitmap area is in the variable\nBASE, you can find the desired byte with the formula:\n\nBY=BASE+40*(Y AND 256)+(Y AND 7)+(X AND 504)\n\nTo turn on the desired dot,\n\nPOKE BY, PEEK(BY) OR (2^(NOTX AND 7)\n\nTo turn the dot off,\n\nPOKE BY, PEEK(BY) AND (255-2^(NOTX AND 7))\n\nThe exponentation function takes a lot of time.  To speed things up,\nan array can be created, each of whose elements corresponds to a power\nof two.\n\nFOR I=0 TO 7:BIT(I)=2^1:NEXT\n\nAfter this is done, the expression 2^(I) can be replaced by BI(I).\n\nThe following sample program illustrates the bit-graphics concepts\nexplained above, and serves as a summary of that information.\n\n10 FOR I=0 TO 7:BI(I)=2^I:NEXT: REM SET UP ARRAY OF POWERS OF 2 (BIT VALUE)\n20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192\n30 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE\n40 A$=\"\":FOR I=1 TO 37:A$=A$+\"C\":NEXT:PRINT CHR$(19);\n50 FOR I=1 TO 27:PRINTA$;:NEXT:POKE2023,PEEK(2022): REM SET COLOR MAP\n60 A$=\"\":FOR I=1 TO 27:A$=A$+\"@\":NEXT:FOR I=32 TO 63 STEP 2\n70 POKE648,I:PRINT CHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLEAR HI-RES SCREEN\n80 FORY=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM\n90 X=INT(160+40*SIN(Y/10)): REM SINE WAVE SHAPE\n100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504): REM FIND HI-RES BYTE\n110 POKEBY,PEEK(BY)OR(BI(NOT X AND 7)):NEXT Y:REM POKE IN BIT VALUE\n120 GOTO 120: REM LET IT STAY ON SCREEN\n\nAs you can see, using BASIC to draw in bit-graphics mode is somewhat\nslow and tedious.  Machine language is much more suiable for\nbit-graphics plotting.  For a program that lets you replace some BASIC\nommands with high-res drawing commands, see the article \"Hi-Res\nGraphics Made Simple,\" by Paul F. Schatz, in COMPUTE!'s First Book of\nCommodore 64 Sound and Graphics.\n\nThere is a slightly lower resolution bitmap graphics mode available\nwhich offers up to four colors per 8 by 8 dot matrix.  To enable this\nmode, you must set the multicolor bit (Bit 4 of 53270 ($D016)) while\nin bitmap graphics mode.  For more information on this mode, see the\nentry for the multicolor enable bit.\n\nBit 6.  This bit of this register enables extended background color\nmode.  This mode lets you select the background color of each text\ncharacter, as well as its foreground color.  It is able to increase\nthe number of background colors displayed, by reducing the number of\ncharacters that can be shown on the screen.\n\nNormally, 256 character shapes can be displayed on the screen.  You\ncan use them either by using the PRINT statement or by POKEing a\ndisplay code from 0 to 255 into screen memory.  If the POKEing method\nis used, you must also POKE a color code from 0 to 15 into color\nmemory (for example, if you POKE 1024,1, and POKE 55296,1, a white A\nappears in the top-left corner of the screen).\n\nThe background color of the screen is determined by Background Color\nRegister 0, and you can change this color by POKEing a new value to\nthat register, which is located at 53281 ($D021).  For example, POKE\n53281,0 creates a black background.\n\nWhen extended background color mode is activated, however, only the\nfirst 64 shapes found in the table of the screen display codes can be\ndisplayed on the screen.  This group includes the letters of the\nalphabet, numerals, and punctuation marks.  If you try to print on the\nscreen a character having a higher display code, the shape displayed\nwill be from the first group of 64, but that character's background\nwill no longer be determined by the register at 53281 ($D021).\nInstead, it will be determined by one of the other background color\nregisters.\n\nWhen in extended background color mode, characters having display\ncodes 64- 127 will take their background color from register 1, and\nlocation 53282 ($D022).  These characters include various SHIFTed\ncharacters.  Those with codes 128-191 will have their background\ncolors determined by register 2, at 53283 ($D023).  These include the\nreversed numbers, letters, and punctuation marks.  Finally, characters\nwith codes 192-255 will use register 4, at 53284 ($D024).  These are\nthe reversed graphics characters.\n\nLet's try an experiment to see just how this works.  First, we will\nput the codes for four different letters in screen memory:\n\nFOR I=0 TO 3:POKE 1230+(I*8),I*64+I:POKE 55502+(I*8),1:NEXT\n\nFour white letters should appear on the screen, an A, a shifted A, a\nreversed A, and a reversed, shifted A, all on a blue background.\nNext, we will put colors in the other background color registers:\n\nPOKE 53282,0:POKE53283,2:POKE53284,5\n\nThis sets the registers to black, red, and green, respectively.\nFinally, we will activate extended color mode by setting Bit 6 of the\nVIC-II register at location 53265 to a 1.  The BASIC statement that\nturns this mode on is:\n\nPOKE 53265,PEEK(53265) OR 64\n\nNotice that two things happened.  First, all of the letters took on\nthe same shape, that of the letter A.  Second, each took on the\nbackground color of a different color register.  To get things back to\nnormal, turn off extended color mode with this statement:\n\nPOKE 53265,PEEK(53265) AND 191\n\nExtended color mode can be a very useful enhancement for your text\ndisplays.  It allows the creation of windows.  These windows, because\nof their different background colors, make different bodies of text\nstand out as visually distinct from one another.  For example, a text\nadventure program could have one window to display the player's\ncurrent location, one to show an inventory of possessions, and one to\naccept commands for the next move.\n\nIn this mode the background color of these windows can be changed\ninstantly, just by POKEing a new value to the color register.  This\ntechnique lends itself to some dramatic effects.  A window can be\nflashed to draw attention to a particular message at certain times.\nAnd varying the foreground color can make either the window or the\nmessage vanish and reappear later.\n\nThere are, however, a couple of problems involved in using these\nwindows.  The character shape that you want to use might not have a\nscreen code of less than 64.  In that case, the only solution is to\ndefine your own character set, with the shape you want in one of the\nfirst 64 characters.\n\nAnother problem is that characters within a PRINT statement in your\nprogram listing are not always going to look the same on the screen.\nHaving to figure out what letter to print to get the number 4 with a\ncertain background color can be very inconvenient.  The easiest\nsolution to this problem is to have a subroutine to the translation\nfor you.  Since letters will appear normally in window 1, and window 3\ncharacters are simply window 1 characters reversed, you will only have\nproblems with characters in windows 2 and 4.  To conver these\ncharacters, put your message in A$, and use the following subroutine:\n\n500 B$=\"\":FOR I=1 TO LEN(A$):B=ASC(MID$(A$,I,1))\n510 B=B+32:IF B<96 THEN B=B+96\n520 B$=B$+CHR$(B):NEXT I:RETURN\n\nThis subroutine converts each letter to its ASCII equivalent, adds the\nproper offset, and converts it back to part of the new string, B$.\nWhen the conversion is complete, B$ will hold the characters necessary\nto PRINT that message in window 2.  For window 4, PRINT\nCHR$(18);B$;CHR$(146).  This will turn reverse video on before\nprinting the string, and turn it off afterwards.\n\nA practical demonstration of the technique for setting up windows is\ngiven in the sample program below.  The program sets up three windows,\nand shows them flashing, appearing and disappearing.\n\n5 DIM RO$(25):RO$(0)=CHR$(19):FOR I=1 TO 24:RO$(I)=RO$(I-1)+CHR$(17):NEXT\n10 POKE 53265,PEEK(53265) OR 64\n20 POKE 53280,0:POKE 53281,0:POKE 53282,1:POKE 53283,2:POKE 53284,13\n25 OP$=CHR$(160):FOR I=1 TO 4:OP$=OP$:NEXTI:PRINTCHR$(147);RO$(3);\n30 FOR I=1 TO10:PRINTTAB(1);CHR$(18);\"               \";TAB(23);OP$:NEXT\n40 PRINT CHR$(146):PRINT:PRINT:FOR I=1 TO 4:PRINTOP$;OP$;OP$;OP$;OP$;:NEXTI\n50 PRINT RO$(5);CHR$(5);CHR$(18);TAB(2);\"A RED WINDOW\"\n60 PRINT CHR$(18);TAB(2);\"COULD BE USED\"\n70 PRINT CHR$(18);TAB(2);\"FOR ERROR\"\n80 PRINT CHR$(18);TAB(2);\"MESSAGES\"\n100 A$=\"A GREEN WINDOW\":GOSUB 300:PRINT RO$(5);CHR$(144);CHR$(18);TAB(24);B$\n110 A$=\"COULD BE USED\":GOSUB 300:PRINTTAB(24);CHR$(18);B$\n120 A$=\"TO GIVE\":GOSUB 300:PRINTTAB(24);CHR$(18);B$\n130 A$=\"INSTRUCTIONS\":GOSUB 300:PRINTTAB(24);CHR$(18);B\n140 PRINT CHR$(31);RO$(19);\n150 A$=\"  WHILE THE MAIN WINDOW COULD BE USED\":GOSUB 300:PRINT B$\n160 A$=\"  FOR ACCEPTING COMMANDS.\":GOSUB 300:PRINT B$\n170 FOR I=1 TO 5000:NEXT I:POKE 53284,0\n180 FOR I=1 TO 5:FOR J=1 TO 300:NEXT J:POKE 53282,15\n190 FOR J=1 TO 300:NEXT J:POKE 53282,1\n200 NEXT I:POKE 53283,-2*(PEEK(53283)=240):POKE 53284,-13*(PEEK(53284)=240)\n210 GOTO 180\n300 B$=\"\":FOR I=1TOLEN(A$):B=ASC(MID$(A$,I,1))\n310 B=B+32:IFB<96THENB=B+96\n320 B$=B$+CHR$(B):NEXTI:RETURN\n\nBit 7.  Bit 7 of this register is the high-order bit (Bit 8) of the\nRaster Compare register at 53266 ($D012).  Even though it is located\nhere, it functions as part of that register (see the description below\nfor more information on the Raster Compare register).\n\nMachine language programmers should note that its position here at Bit\n7 allows testing this bit with the Negative flag.  Since scan lines\nabove number 256 are all off the screen, this provides an easy way to\ndelay changing the graphics display until the scan is in the vertical\nblanking interval and the display is no longer being drawn:\n\nLOOP  LDA $D011\n      BPL LOOP\n\nSprites should always be moved when the raster is scanning off-screen,\nbecause if they are moved while they are being scanned, their shapes\nwill waver slightly.\n\nThe BASIC equivalent of the program fragment above is the statement\nWAIT 53265,128, but BASIC is usually not fast enough to execute the\nnext statement while still in the blanking interval."
  },
  {
    "id": "map-D012",
    "address_start": 53266,
    "address_end": 53266,
    "hex_start": "$D012",
    "hex_end": "$D012",
    "label": "RASTER",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53266          $D012         RASTER\nRead Current Raster Scan Line/Write Line to Compare for Raster IRQ\n\nThe Raster Compare register has two different functions, depending on\nwhether you are reading from it or writing to it.  When this register\nis read, it tells which screen line the electron beam is currently\nscanning.\n\nThere are 262 horizontal lines which make up the American (NTSC)\nstandard display screen (312 lines in the European or PAL standard\nscreen).  Every one of these lines is scanned and updated 60 times per\nsecond.  Only 200 of these lines (numbers 50-249) are part of the\nvisible display.\n\nIt is sometimes helpful to know just what line is being scanned,\nbecause changing screen graphics on a particular line while that line\nis being scanned may cause a slight disruption on the screen.  By\nreading this register, it is possible for a machine language program\nto wait until the scan is off the bottom of the screen before changing\nthe graphics display.\n\nIt is even possible for a machine language program to read this\nregister, and change the screen display when a certain scan line is\nreached.  The program below uses this technique to change the\nbackground color in midscreen, in order to show all 256 combinations\nof foreground and background text colors at once.\n\n40 FOR I=49152 TO 49188:READ A:POKE I,A:NEXT:POKE 53280,11\n50 PRINT CHR$(147):FOR I=1024 TO I+1000:POKE I,160:POKE I+54272,11:NEXT I\n60 FOR I=0 TO 15:FOR J=0 TO 15\n70 P=1196+(48*I)+J:POKE P,J+I:POKE P+54272,J:NEXT J,I\n80 PRINT TAB(15)CHR$(5)\"COLOR CHART\":FOR I=1 TO 19:PRINT:NEXT\n85 PRINT \"THIS CHART SHOWS ALL COMBINATIONS OF   \"\n86 PRINT \"FOREGROUND AND BACKGROUND COLORS.      \"\n87 PRINT \"FOREGROUND INCREASES FROM LEFT TO RIGHT\"\n88 PRINT \"BACKGROUND INCREASES FROM TOP TO BOTTOM\"\n90 SYS 12*4096\n100 DATA 169,90,133,251,169,0,141,33,208,162,15,120,173,17,208,48\n105 DATA 251,173,18,208\n110 DATA 197,251,208,249,238,33,208,24,105,8,133,251,202,16,233,48,219\n\nWriting to this register designates the comparison value for the\nRaster Compare Interrupt.  When that interrupt is enabled, a maskable\ninterrupt request will be issued every time the electron beam scan\nreaches the scan line whose number was written here.  This is a much\nmore flexible technique for changing the display in midscreen than\nreading this register as the sample program above does.  That\ntechnique requires that the program continuously watch the Raster\nRegister, while the interrupt method will call the program when the\ntime is right to act.  For more information on raster interrupts, see\nthe entry for the Interrupt Mask Register (53274, $D01A).\n\nIt is very important to remember that this register requires nine\nbits, and that this location only holds eight of those bits (the ninth\nis Bit 7 of 53265 ($D011)).  If you forget to read or write to the\nninth bit, your results could be in error by a factor of 256.\n\nFor example, some early programs written to demonstrate the raster\ninterrupt took for granted that the ninth bit of this register would\nbe set to 0 on power-up.  When a later version of the Kernal changed\nthis initial value to a 1, their interrupt routines, which were\nsupposed to set the raster interrupt to occur at scan line number 150,\nended up setting it for line number 406 instead.  Since the scan line\nnumbers do not go up that high, no interrupt request was ever issued\nand the program did not work."
  },
  {
    "id": "map-D013-D014",
    "address_start": 53267,
    "address_end": 53268,
    "hex_start": "$D013",
    "hex_end": "$D014",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 53267-53268 ($D013-$D014)\nLight Pen Registers\n\nA light pen is an input device that can be plugged into joystick\nControl Port #1.  It is shaped like a pen and has a light-sensitive\ndevice at its tip that causes the trigger switch of the joystick port\nto close at the moment the electron beam that updates the screen\ndisplay strikes it.  The VIC-II chip keeps track of where the beam is\nwhen that happens, and records the corresponding horizontal and\nvertical screen coordinates in the registers at these locations.\n\nA program can read the position at which the light pen is held up to\nthe screen.  The values in these registers are updated once every\nscreen frame (60 times per second).  Once the switch is closed and a\nvalue written to these registers, the registers are latched, and\nsubsequent switch closings during the same screen frame will not be\nrecorded.\n\nA given light pen may not be entirely accurate (and the operator may\nnot have a steady hand).  It is probably wise to average the positions\nreturned from a number of samplings, particularly when using a machine\nlanguage driver."
  },
  {
    "id": "map-D013",
    "address_start": 53267,
    "address_end": 53267,
    "hex_start": "$D013",
    "hex_end": "$D013",
    "label": "LPENX",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53267         $D013          LPENX\nLight Pen Horizontal Position\n\nThis location holds the horizontal position of the light pen.  Since\nthere are only eight bits available (which give a range of 256 values)\nfor 320 possible horizontal screen positions, the value here is\naccurate only to every second dot position.  The number here will\nrange from 0 to 160 and must be multiplied by 2 in order to get a\nclose approximation of the actual horizontal dot position of the light\npen."
  },
  {
    "id": "map-D014",
    "address_start": 53268,
    "address_end": 53268,
    "hex_start": "$D014",
    "hex_end": "$D014",
    "label": "LPENY",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53268         $D014          LPENY\nLight Pen Vertical Position\n\nThis location holds the vertical position of the light pen.  Since\nthere are only 200 visible scan lines on the screen, the value in this\nregister corresponds exactly to the current raster scan line."
  },
  {
    "id": "map-D015",
    "address_start": 53269,
    "address_end": 53269,
    "hex_start": "$D015",
    "hex_end": "$D015",
    "label": "SPENA",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53269         $D015          SPENA\nSprite Enable Register\n\nBit 0:  Enable Sprite 0 (1=sprite is on, 0=sprite is off)\nBit 1:  Enable Sprite 1 (1=sprite is on, 0=sprite is off)\nBit 2:  Enable Sprite 2 (1=sprite is on, 0=sprite is off)\nBit 3:  Enable Sprite 3 (1=sprite is on, 0=sprite is off)\nBit 4:  Enable Sprite 4 (1=sprite is on, 0=sprite is off)\nBit 5:  Enable Sprite 5 (1=sprite is on, 0=sprite is off)\nBit 6:  Enable Sprite 6 (1=sprite is on, 0=sprite is off)\nBit 7:  Enable Sprite 7 (1=sprite is on, 0=sprite is off)\n\nIn order for any sprite to be displayed, the corresponding bit in this\nregister must be set to 1 (the default for this location is 0).  Of\ncourse, just setting this bit along will not guarantee that a sprite\nwill be shown on the screen.  The Sprite Data Pointer must indicate a\ndata area that holds some values other than 0.  The Sprite Color\nRegister must also contain a value other than that of the background\ncolor.  In addition, the Sprite Horizontal and Vertical Position\nRegisters must be set for positions that lie within the visible screen\nrange in order for a sprite to appear on screen."
  },
  {
    "id": "map-D016",
    "address_start": 53270,
    "address_end": 53270,
    "hex_start": "$D016",
    "hex_end": "$D016",
    "label": "SCROLX",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53270         $D016          SCROLX\nHorizontal Fine Scrolling and Control Register\n\nBits 0-2:  Fine scroll display horizontally by X dot positions (0-7)\nBit 3:  Select a 38-column or 40-column text display (1=40 columns,\n  0=38 columns)\nBit 4:  Enable multicolor text or multicolor bitmap mode (1=multicolor on,\n  0=multicolor off)\nBit 5:  Video chip reset (0=normal operations, 1=video completely off)\nBits 6-7:  Unused\n\nThis is one of the two important multifunction control registers on\nthe VIC-II chip.  On power-up, it is set to a default value of 8,\nwhich means that the VIC chip Reset line is set for a normal display,\nMulticolor Mode is disabled, a 40-column text display is selected, and\nno horizontal fine-scroll offset is used.\n\nBits 0-2.  The first three bits of this chip control vertical fine\nscrolling of the screen display.  This feature allows you to smoothly\nmove the entire text display back and forth, enabling the display area\nto act as a window, scrolling over a larger text or character graphics\ndisplay.\n\nSince each text character is eight dots wide, moving each character\nover one whole character position (known as coarse scrolling) is a\nrelatively big jump, and the motion looks jerky.  By placing a number\nfrom 1 to 7 into these three bits, you can move the whole screen\ndisplay from one to seven dot spaces to the right.\n\nStepping through values 1 to 7 allows you to smoothly make the\ntransition from having a character appear at one screen column to\nhaving it appear at the next one over.  To demonstrate this, type in\nthe following program, LIST, and RUN it.\n\n10 FOR I=1 TO 50:FOR J=0 TO 7\n20 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I\n30 FOR I=1 TO 50:FOR J=7 TO 0 STEP-1\n40 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I\n\nAs you can see, after the display has moved over seven dots, it starts\nover at its original position.  In order to continue with the scroll,\nyou must do a coarse scroll every time the value of the scroll bits\ngoes from 7 to 0, or from 0 to 7.  This is accomplished by moving each\nbyte of display data on each line over one position, overwriting the\nlast character, and introducing a new byte of data on the opposite end\nof the screen line to replace it.\n\nObviously, only a machine language program can move all of these bytes\nquickly enough to maintain the effect of smooth motion.  The following\nBASIC program, however, will give you an idea of what the combination\nof fine and coarse scrolling looks like.\n\n10 POKE 53281,0:PRINT CHR$(5);CHR$(147):FOR I=1 TO 5:PRINT CHR$(17):NEXT\n20 FOR I=1 TO 30\n30 PRINT TAB(I-1)\"{UP}{10 SPACES}{UP}\"\n40 WAIT53265,128:POKE53270,PEEK(53270)AND248:PRINTTAB(I)\"AWAY WE GO\"\n50 FOR J=1 TO 7\n60 POKE 53270,(PEEK(53270)AND248)+J\n70 FORK=1TO30-I\n80 NEXT K,J,I:RUN\n\nChanging the value of the three horizontal scroll bits will affect the\nentire screen display.  If you wish to scroll only a portion of the\nscreen, you will have to use raster interrupts (see 53274 ($D01A)\nbelow) to establish a scroll zone, change the value of these scroll\nbits only when that zone is being displayed, and change it back to 0\nafterward.\n\nBit 3.  Bit 3 of this register allows you to cover up the first and\nlast columns of the screen display with the border.  Since the viewers\ncannot see the characters there, they will not be able to see you\ninsert a new character on the end of the line when you do coarse\nscrolling (see explanation of Bits 0-2 above).\n\nSetting this bit to 1 enables the normal 40-column display, while\nresetting it to 0 changes the display to 38 columns.  This is a purely\ncosmetic aid, and it is not necessary to change the screen to the\nsmaller size to use the scrolling feature.\n\nBit 4.  This bit selects multicolor graphics.  The effect of setting\nthis bit to 1 depends on whether or not the bitmap graphics mode is\nalso enabled.\n\nIf you are not in bitmap mode, and you select multicolor text\ncharacter mode by setting this bit to 1, characters with a color\nnybble whose value is less than 8 are displyed normally.  There will\nbe one background color and one foreground color.  But each dot of a\ncharacter with a color nybble whose value is over 7 can have any one\nof four different colors.\n\nThe two colors in the Background Control Registers 1 and 2 (53282-3,\n$D022-3) are available in addition to the colors supplied by the Color\nRAM.  The price of these extra colors is a reduction in horizontal\nresolution.  Instead of each bit controlling one dot, in multicolor\nmode a pair of bits control the color of a larger dot.  A pattern of\n11 will light it with the color from the lower three bits of color\nRAM.  Patterns of 01 and 10 will select the colors from Background\nColor Registers 1 and 2, respectively, for the double-width dot.\n\nYou can see the effect that setting this bit has by typing in the\nfollowing BASIC command line:\n\nPOKE 53270,PEEK(53280)OR16:PRINT CHR$(149)\"THIS IS MULTICOLOR MODE\"\n\nIt is obvious from this example that the normal set of text characters\nwas not made to be used in multicolor mode.  In order to take\nadvantage of this mode, you will need to design custom four-color\ncharacters.  For more information, see the alternate entry for 53248\n($D000), the Character Generator ROM.\n\nIf the multicolor and bitmap enable bits are both set to 1, the result\nis a multicolor bitmap mode.  As in multicolor text mode, pairs of\ngraphics data bits are used to set each dot in a 4 by 8 matrix to one\nof four colors.  This results in a reduction of the horizontal\nresolution to 160 double-wide dots across.  But while text multicolor\nmode allows only one of the four colors to be set individually for\neach 4 by 8 dot area, bitmap multicolor mode allows up to three\ndifferent colors to be individually selected in each 4 by 8 dot area.\nThe source of the dot color for each bit-pair combination is shown\nbelow:\n\n00 Background Color Register 0 (53281, $D021)\n01 Upper four bits of Video Matrix\n10 Lower four bits of Video Matrix\n11 Color RAM nybble (area starts at 55296 ($D800))\n\nThe fact that bit-pairs are used in this mode changes the strategy for\nplotting somewhat.  In order to find the byte BY in which the desired\nbit-pair resides, you must multiply the horizontal position X, which\nhas a value of 0- 159, by 2, and then use the same formula as for\nhi-res bitmap mode.\n\nGiven that the horizontal position (0-159) of the dot is stored in the\nvariable X, its vertical position is in the variable Y, and the base\naddress of the bitmap area ia in the variable BASE, you can find the\ndesired byte with the formula:\n\nBY=BASE+(Y AND 248)*40+(Y AND 7)+(2*X AND 504)\n\nSetting the desired bit-pair will depend on what color you chose.\nFirst, you must set up an array of bit masks.\n\nCA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64\n\nTo turn on the desired dot, select a color CO from 0 to 3\n(representing the color selected by the corresponding bit pattern) and\nexecute the following statement:\n\nBI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR (CO*CA(BI))\n\nThe following program will demonstrate this technique:\n\n10 CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64:REM ARRAY FOR BIT PAIRS\n20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192\n30 POKE53265,PEEK(53265)OR32:POKE53270,PEEK(53270)OR16:REM MULTI-COLOR BIT MAP\n40 A$=\"\":FOR I=1 TO 37:A$=A$+\"C\":NEXT:PRINT CHR$(19);\n50 FOR I=1 TO 27:PRINT A$;:NEXT:POKE 2023,PEEK(2022): REM SET COLOR MAP\n60 A$=\"\":FOR I=1 TO 128:A$=A$+\"@\":NEXT:FOR I=32 TO 63 STEP 2\n70 POKE648,I:PRINTCHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLR HI-RES SCREEN\n80 FOR CO=1TO3:FOR Y=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM\n90 X=INT(10*CO+15*SIN(CO*45+Y/10)): REM SINE WAVE SHAPE\n100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X*2 AND 504): REM FIND HI-RES BYTE\n110 BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR(CO*CA(BI))\n120 NEXT Y,CO\n130 GOTO 130: REM LET IT STAY ON SCREEN\n\nBit 5:  Bit 5 controls the VIC-II chip Reset line.  Setting this bit\nto 1 will completely stop the video chip from operating.  On older\n64s, the screen will go black.  It should always be set to 0 to insure\nnormal operation of the chip.\n\nBits 6 and 7.  These bits are not used."
  },
  {
    "id": "map-D017",
    "address_start": 53271,
    "address_end": 53271,
    "hex_start": "$D017",
    "hex_end": "$D017",
    "label": "YXPAND",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53271         $D017          YXPAND\nSprite Vertical Expansion Register\n\nBit 0:  Expand Sprite 0 vertically (1=double height, 0=normal height)\nBit 1:  Expand Sprite 1 vertically (1=double height, 0=normal height)\nBit 2:  Expand Sprite 2 vertically (1=double height, 0=normal height)\nBit 3:  Expand Sprite 3 vertically (1=double height, 0=normal height)\nBit 4:  Expand Sprite 4 vertically (1=double height, 0=normal height)\nBit 5:  Expand Sprite 5 vertically (1=double height, 0=normal height)\nBit 6:  Expand Sprite 6 vertically (1=double height, 0=normal height)\nBit 7:  Expand Sprite 7 vertically (1=double height, 0=normal height)\n\nThis register can be used to double the height of any sprite.  When\nthe bit in this register that corresponds to a particular sprite is\nset to 1, each dot of the 24 by 21 sprite dot matrix will become two\nraster scan lines high instead of one."
  },
  {
    "id": "map-D018",
    "address_start": 53272,
    "address_end": 53272,
    "hex_start": "$D018",
    "hex_end": "$D018",
    "label": "VMCSB",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53272         $D018          VMCSB\nVIC-II Chip Memory Control Register\n\nBit 0:  Unused\nBits 1-3:  Text character dot-data base address within VIC-II address\n  space\nBits 4-7:  Video matrix base address within VIC-II address space\n\nThis register affects virtually all graphics operations.  It\ndetermines the vase address of two very important data areas, the\nVideo Matrix, and the Character Dot-Data area.\n\nBits 1-3.  These bits are used to set the location of the Character\nDot-Data area.  This area is where the data is stored (for more\ninformation on character shape data, see the alternate entry for\nlocation 53248 ($D000), the Character Generator ROM).\n\nBits 1-3 can represent any even number from 0 to 14.  That numer\nstands for the even 1K offset of the character data area from the\nbeginning of VIC-II memory.  For example, if these bits are all set to\n0, it means that the character memory occupies the first 2K of VIC-II\nmemory.  If they equal 2, the data area starts 2*1K (2*1024) or 2048\nbytes from the beginning of VIC memory.\n\nThe default value of this nybble is 4.  This sets the address of the\nCharacter Dot-Data area to 4096 ($1000), which is the starting address\nof where the VIC-II chip addresses the Character ROM.  The normal\ncharacter set which contains uppercase and graphics occupies the first\n2K of that ROM.  The alternate character set which contains both\nupper- and lowercase letters use the second 2K.  Therefore, to shift\nto the alternate character set, you must change the value of this\nnybble to 6, with a POKE 53272,PEEK(53272)OR2.  To change it back,\nPOKE 53272,PEEK(53272)AND253.\n\nIn bitmap mode, the lower nybble controls the location of the bitmap\nscreen data.  Since this data area can start only at an offset of 0 or\n8K from the beginning of VIC-II memory, only Bit 3 of the Memory\nControl Register is significant in bitmap mode.  If Bit 3 holds a 0,\nthe offset is 0, and if it holds a 1, the offset is 8192 (8K).\n\nBits 4-7.  This nybble determines the starting address of the Video\nMatrix area.  This is the 1024-byte area of memory which contains the\nscreen codes for the text characters that are displayed on the screen.\nIn addition, the last eight bytes of this area are used as pointers\nwhich designate which 64- byte block of VIC-II memory will be used as\nshape data for each sprite.\n\nThese four bits can represent numbers from 0 to 15.  These numbers\nstand for the offset (in 1K increments) from the beginning of VIC-II\nmemory to the Video Matrix.\n\nFor example, the default bit pattern is 0001.  This indicates that the\nVideo Matrix is offset by 1K from the beginning of VIC-II memory, the\nnormal starting place for screen memory.  Remember, though, the bit\nvalue of this number will be 16 times what the bit pattern indicates,\nbecause we are dealing with Bits 4-7.  Therefore, the 0001 in the\nupper nybble has a value of 16.\n\nUsing this register, we can move the start of screen memory to any 1K\nboundary within the 16K VIC-II memory area.  Just changing this\nregister, however, is not enough if you want to use the BASIC line\neditor.  The editor looks to location 648 ($288) to determine where to\nprint screen characters.\n\nIf you just change the location of the Video Matrix without changing\nthe value in 648, BASIC will continue to print characters in the\nmemory area starting at 1024, even though that area is no longer being\ndisplayed.  The result is that you will not be able to see anything\nthat you type in on the keyboard.  To fix this, you must POKE 648 with\nthe page number of the starting address of screen memory (page\nnumber=location/256).  Remember, the actual starting address of screen\nmemory depends not only on the offset from the beginning of VIC-II\nmemory in the register, but also on which bank of 16K is used for\nVIC-II memory.\n\nFor example, if the screen area starts 1024 bytes from the beginning\nof VIC- II memory, and the video chip is using Bank 2 (32768-49151),\nthe actual starting address of screen memory is 32768+1024=33792\n($8400).  For examples of how to change the video memory area, and of\nhow to relocate the screen, see the entro for 56576 ($DD00)."
  },
  {
    "id": "map-D019",
    "address_start": 53273,
    "address_end": 53273,
    "hex_start": "$D019",
    "hex_end": "$D019",
    "label": "VICIRQ",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53273         $D019          VICIRQ\nVIC Interrupt Flag Register\n\nBit 0:  Flag:  Is the Raster Compare a possible source of an IRQ?\n        (1=yes)\nBit 1:  Flag:  Is a collision between a sprite and the normal graphics\n        display a possible source of an IRQ?  (1=yes)\nBit 2:  Flag:  Is a collision between two sprites a possible source of\n        an IRQ?  (1=yes)\nBit 3:  Flag:  Is the light pen trigger a possible source of an IRQ?\n        (1=yes)\nBits 4-6:  Not used\nBit 7:  Flag:  Is there any VIC-II chip IRQ source which could cause\n        an IRQ?  (1=yes)\n\nThe VIC-II chip is capable of generating a maskable request (IRQ) when\ncertain conditions relating to the video display are fulfilled.\nBriefly, the conditions that can cause a VIC-II chip IRQ are:\n\n1.  The line number of the current screen line being scanned by the\nraster is the same as the line number value written to the Raster\nRegister (53266, $D012).\n\n2.  A sprite is positioned at the same location where normal graphics\ndata are being displayed.\n\n3.  Two sprites are positioned so that they are touching.\n\n4.  The light sensor on the light pen has been struck by the raster\nbeam, causing the fire button switch on joystick Control Port #1 to\nclose (pressing the joystick fire button can have the same effect).\n\nWhen one of these conditions is met, the corresponding bit in this\nstatus register is set to 1 and latched.  That means that as long as\nthe corresponding enable bit in the VIC IRQ Mask register is set to 1,\nand IRQ requested will be generated, and any subsequent fulfillment of\nthe same condition will be ignored until the latch is cleared.\n\nThis allows you to preserve multiple interrupt requests if more than\none of the interrupt conditions is met at a time.  In order to keep an\nIRQ source from generating another request after it has been serviced,\nand to enable subsequent interrupt conditions to be detected, the\ninterrupt service routine must write a 1 to the corresponding bit.\nThis will clear the latch for that bit.  The default value written to\nthis register is 15, which clears all interrupts.\n\nThere is only 1 IRQ vector that points to the address of the routine\nthat will be executed when an IRQ interrupt occurs.  The same routine\nwill therefore be executed regardless of the source of the interrupt.\nThis status register provides a method for that routine to check what\nthe source of the IRQ was, so that the routine can take appropriate\naction.  First, the routine can check Bit 7.  Anytime that any of the\nother bits in the status register is set to 1, Bit 7 will also be set.\nTherefore, if that bit holds a 1, you know that the VIC-II chip\nrequested an IRQ (the two CIA chips which are the other sources of IRQ\ninterrupts can be checked in a similar manner).  Once it has been\ndetermined that the VIC chip is responsible for the IRQ, the\nindividual bits can be tested to see which of the IRQ conditions have\nbeen met.\n\nFor more information, and a sample VIC IRQ program, see the following\nentry."
  },
  {
    "id": "map-D01A",
    "address_start": 53274,
    "address_end": 53274,
    "hex_start": "$D01A",
    "hex_end": "$D01A",
    "label": "IRQMASK",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53274         $D01A          IRQMASK\nIRQ Mask Register\n\nBit 0:  Enable Raster Compare IRQ (1=interrupt enabled)\nBit 1:  Enable IRQ to occure when sprite collides with display of\n  normal\n        graphics data (1=interrupt enabled)\nBit 2:  Enable IRQ to occur when two sprites collide (1=interrupt\n  enabled)\nBit 3:  Enable light pen to trigger an IRQ (1=interrupt enabled)\nBits 4-7:  Not used\n\nThis register is used to enable an IRQ request to occur when one of\nthe VIC-II chip interrupt conditions is met.  In order to understand\nwhat that means, and how these interrupts can extend the range of\noptions available to a programmer, you must first understand what an\ninterrupt is.\n\nAn interrupt is a signal given to the microprocessor (the brains of\nthe computer) that tells it to stop executing its machine language\nprogram (for example, BASIC), and to work on another program for a\nshort time, perhaps only a fraction of a second.  After finishing the\ninterrupt program, the computer goes back to executing the main\nprogram, just as if there had never been a detour.\n\nBit 0.  This bit enables the Raster Compare IRQ.  The conditions for\nthis IRQ are met when the raster scan reaches the video line indicated\nby the value written to the Raster Register at 53266 ($D012) and Bit 7\nof 53265 ($D011).  Again, an explanation of the terminology is in\norder.\n\nIn the normal TV display, a beam of electrons (raster) scans the\nscreen, starting in the top-left corner, and moving in a straight line\nto the right, lighting up appropriate parts of the screen line on the\nway.  When it comes to the right edge, the beam moves down a line, and\nstarts again from the left.  There are 262 such line that are scanned\nby the 64 display, 200 of which form the visible screen area.  This\nscan updates the complete screen display 60 times every second.\n\nThe VIC-II chip keeps track of which line is being scanned, and stores\nthe scan number in the Raster Register at 53266 and 53265 ($D012 and\n$D011).  The Raster Register has two functions.  When read, it tells\nwhat line is presently being scanned.  But when written to, it\ndesignates a particular scan line as the place where a raster\ninterrupt will occur.\n\nAt the exact moment that the raster beam line number equals the number\nwritten to the register, Bit 0 of the status register will be set to\n1, showing that the conditions for a Raster Compare Interrupt have\nbeen fulfulled.  If the raster interrupt is enabled then,\nsimultaneously, the interrupt program will be executed.  This allows\nthe user to reset any of the VIC-II registers at any point in the\ndisplay, and thus change character sets, background color, or graphics\nmode for only a part of the screen display.\n\nThe interrupt routine will first check if the desired condition is the\nsource of the interrupt (see above entry) and then make the changes to\nthe screen display.  Once you have written this interrupt routine, you\nmust take the following steps to install it.\n\n1.  Set the interrupt disable flag in the status register with an SEI\ninstruction.  This will disable all interrupts and prevent th system\nfrom crashing while you are changing the interrupt vectors.\n\n2.  Enable the raster interrupt.  This is done by setting Bit 0 of the\nVIC- II chip interrupt enable register at location 53274 ($D01A) to 1.\n\n3.  Indicate the scan line on which you want the interrupt to occur by\nwriting to the raster registers.  Don't forget that this is a nine-bit\nvalue, and you must set both the low byte (in location 53266 ($D012))\nand the high bit (in the register at 53265 ($D011)) in order to insure\nthat the interrupt will start at the scan line you want it to, and not\n256 lines earlier or later.\n\n4.  Let the computer know where the machine language routine that you\nwant the interrupt to execute starts.  This is done by placing the\naddress in the interrupt vector at locations 788-789 ($314-$315).\nThis address is split into two parts, a low byte and a high byte, with\nthe low byte stored at 788.\n\nTo calculate the two values for a given address AD, you may use the\nformula HIBYTE=INT(AD/156) and LOWBYTE=AD-(HIBYTE*256).  The value\nLOWBYTE would go into location 788, and the value HIBYTE would go into\nlocation 789.\n\n5.  Reenable interrupts with a CLI instruction, which clears the\ninterrupt disable flag on the status register.\n\nWhen the computer is first turned on, the interrupt vector is set to\npoint to the normal hardware timer interrupt routine, the one that\nadvances the jiffy clock and reads the keyboard.  Since this interrupt\nroutine uses the same vector as the raster interrupt routine, it is\nbest to turn off the hardware timer interrupt by putting a value of\n127 in location 56333 ($DC0D).\n\nIf you want the keyboard and jiffy clock to function normally while\nyour interrupt is enabled, you must preserve the contents of locations\n788 and 789 before you change them to point to your new routine.  Then\nyou must have your interrupt routine jump to the old interrupt routine\nexactly once per screen refresh (every 1/60 second).\n\nAnother thing that you should keep in mind is that at least two raster\ninterrupts are required if you want to change only a part of the\nscreen.  Not only must the interrupt routine change the display, but\nit must also set up another raster interrput that will change it back.\n\nThe sample program below uses a raster-scan interrupt to divide the\ndisplay into three sections.  The first 80 scan lines are in\nhigh-resolution bitmap mode, the next 40 are regular text, and the\nlast 80 are in multicolor bitmap mode.  The screen will split this way\nas soon as a SYS to the routine that turns on the interrupt occurs.\nThe display will stay split even after the program ends.  Only if you\nhit the STOP and RESTORE keys together will the display return to\nnormal.\n\nThe interrupt uses a table of values that are POKEd into four key\nlocations during each of the three interrupts, as well as values to\ndetermine at what scan lines the interrupt will occur.  The locations\naffected are Control Register 1 (53265, $D011), Control Register 2\n(53270, $D016), the Memory Control Register (53272, $D018), and\nBackground Color 0 (53281, $D021).  The data for the interrupt routine\nis contained in lines 49152-49276.  Each of these line numbers\ncorresponds to the locations where the first data byte in the\nstatement is POKEd into memory.\n\nIf you look at lines 49264-49276 of the BASIC program, you will see\nREMark statements that explain which VIC-II registers are affected by\nthe DATA statements in each line.  The number in these DATA\nstartements appear in the reverse order in which they are put into the\nVIC register.  For example, line 49273 holds the data that will go\ninto Control Register 2.  The last number, 8, is the one that will be\nplaced into Control Register 2 while the top part of the screen is\ndisplayed.  The first number, 24, is placed into Control Register 2\nduring the bottom part of the screen display, and changes that portion\nof the display to multicolor mode.\n\nThe only tricky part in determining which data byte affects which\ninterrupt comes in line 49264, which holds the data that determines\nthe scan line at which each interrupt will occur.  Each DATA statement\nentry reflects the scan line at which the next interrupt will occur.\nThe first item in line 49264 is 49.  Even though this is the entry for\nthe third interrupt, the next to be generates is the first interrupt,\nwhich occurs at the top of the screen.  Likewise, the last data item\nof 129 is used during the first interrupt to start the next interrupt\nat scan line 129.\n\nTry experimenting with these values to see what results you come up\nwith.  For example, if you change the number 170 to 210, you will\nincrease the text area by five lines (40 scan lines).\n\nBy changing the values in the data tables, you can alter the effect of\neach interrupt.  Change the 20 in line 49276 to 22, and you will get\nlowercase text in the middle of the screen.  Change the first 8 in\nline 49273 to 24, and you'll get multicolor text in the center window.\nEach of these table items may be used exactly like you would use the\ncorresponding register, in order to change background color, to obtain\ntext or bitmap graphics, regular or multicolor modes, screen blanking\nor extended background color mode.\n\nIt is even possible to change the table values during a program, by\nPOKEing the new value into the memory location where those table\nvalues are stored.  In that way, you can, for example, change the\nbackground color of any of the screen parts while the program is\nrunning.\n\n5 FOR I=0 TO 7:BI(I)=2^I:NEXT\n10 FOR I=49152 TO 49278:READ A:POKE I,A:NEXT:SYS12*4096\n20 PRINT CHR$(147):FOR I=0 TO 8:PRINT:NEXT\n30 PRINT\"THE TOP AREA IS HIGH-RES BIT MAP MODE\"\n40 PRINT:PRINT\"THE MIDDLE AREA IS ORDINARY TEXT \"\n50 PRINT:PRINT\"THE BOTTOM AREA IS MULTI-COLOR BIT MAP\"\n60 FORG=1384 TO 1423:POKE G,6:NEXT\n70 FORG=1024 TO 1383:POKEG,114:POKE G+640,234:NEXT\n80 A$=\"\":FOR I=1 TO 128:A$=A$+\"@\":NEXT:FOR I=32 TO 63 STEP 2\n90 POKE 648,I:PRINT CHR$(19)CHR$(153);A$;A$;A$;A$:NEXT:POKE 648,4\n100 BASE=2*4096:BK=49267\n110 H=40:C=0:FORX=0TO319:GOSUB150:NEXT\n120 H=160:C=0:FORX=0TO319STEP2:GOSUB150:NEXT:C=40\n125 FORX=1TO319STEP2:GOSUB150:NEXT\n130 C=80:FOR X=0 TO 319 STEP2:W=0:GOSUB150:W=1:GOSUB150:NEXT\n140 GOTO 140\n150 Y=INT(H+20*SIN(X/10+C)):BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504)\n160 POKE BY,PEEK(BY) OR (BI(ABS(7-(XAND7)-W))):RETURN\n49152 DATA 120, 169, 127, 141, 13, 220\n49158 DATA 169, 1, 141, 26, 208, 169\n49164 DATA 3, 133, 251, 173, 112, 192\n49170 DATA 141, 18, 208, 169, 24, 141\n49176 DATA 17, 208, 173, 20, 3, 141\n49182 DATA 110, 192, 173, 21, 3, 141\n49188 DATA 111, 192, 169, 50, 141, 20\n49194 DATA 3, 169, 192, 141, 21, 3\n49200 DATA 88, 96, 173, 25, 208, 141\n49206 DATA 25, 208, 41, 1, 240, 43\n49212 DATA 190, 251, 16, 4, 169, 2\n49218 DATA 133, 251, 166, 251, 189, 115\n49224 DATA 192, 141, 33, 208, 189, 118\n49230 DATA 192, 141, 17, 208, 189, 121\n49236 DATA 192, 141, 22, 208, 189, 124\n49242 DATA 192, 141, 24, 208, 189, 112\n49248 DATA 192, 141, 18, 208, 138, 240\n49254 DATA 6, 104, 168, 104, 170, 104\n49260 DATA 64, 76, 49, 234\n49264 DATA 49, 170, 129 :REM SCAN LINES\n49267 DATA 0, 6, 0:REM BACKGROUND COLOR\n49270 DATA 59, 27,59:REM CONTROL REG. 1\n49273 DATA 24, 8, 8:REM CONTROL REG. 2\n49276 DATA 24, 20, 24:REM MEMORY CONTROLRUN\n\nBesides enabling the creation of mixed graphics-modes screens, the\nRaster Compare Interrupt is also useful for creating scrolling zones,\nso that some parts of the screen can be fine-scrolled while the rest\nremains stationary.\n\nBit 1 enables the light pen interrupt.  This interrupt can occur when\nthe light of the raster beam strikes the light-sensitive device in the\npen's tip, causing it to close the fire button switch on joystick\nController Port #1.\n\nThe light pen interrupt affords a method of signaling to a program\nthat the pen is being held to the screen, and that its position can be\nread.  Some light pens provide a push-button switch which grounds one\nof the other lines on the joystick port.  This switch can be pressed\nby the user as an additional signal that the pen is properly\npositioned.  Its location can then be read in the light pen position\nregisters (53267-8, $D013-4).\n\nBit 2 enables the sprite-foreground collision interrupt.  This\ninterrupt can occur if one of the srpte character's dots is touching\none of the dots from the foreground display of either text character\nor bitmap graphics.\n\nBit 3 enables the sprite-sprite collision interrupt, which can occur\nif one of the sprite character's dots is touching one of the dots of\nanother sprite character.\n\nThese two interrupts are useful for games, where such collisions often\nrequire that some action be taken immediately.  Once the interrupt\nsignals that a collision has occurred, the interrupt routine can check\nthe Sprite- Foreground Collision Register at 53279 ($D01F), or the\nSprite-Sprite Collision Register at 53278 ($D01E), to see which sprite\nor sprites are involved in the collision.  See the entry for those\nlocations for more details on collisions."
  },
  {
    "id": "map-D01B",
    "address_start": 53275,
    "address_end": 53275,
    "hex_start": "$D01B",
    "hex_end": "$D01B",
    "label": "SPBGPR",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53275         $D01B          SPBGPR\nSprite to Foreground Display Priority Register\n\nBit 0:  Select display priority of Sprite 0 to foreground (0=sprite\n        appears in front of foreground)\nBit 1:  Select display priority of Sprite 1 to foreground (0=sprite\n        appears in front of foreground)\nBit 2:  Select display priority of Sprite 2 to foreground (0=sprite\n        appears in front of foreground)\nBit 3:  Select display priority of Sprite 3 to foreground (0=sprite\n        appears in front of foreground)\nBit 4:  Select display priority of Sprite 4 to foreground (0=sprite\n        appears in front of foreground)\nBit 5:  Select display priority of Sprite 5 to foreground (0=sprite\n        appears in front of foreground)\nBit 6:  Select display priority of Sprite 6 to foreground (0=sprite\n        appears in front of foreground)\nBit 7:  Select display priority of Sprite 7 to foreground (0=sprite\n        appears in front of foreground)\n\nIf a sprite is positioned to appear at a spot on the screen that is\nalready occupied by text or bitmap graphics, a conflict arises.  The\ncontents of this register determines which one will be displayed in\nsuch a situation.  If the bit that corresponds to a particular sprite\nis set to 0, the sprite will be displayed in front of the foreground\ngraphics data.  If that bit is set to 1, the foreground data will be\ndisplayed in front of the sprite.  The default value that this\nregister is set to at power-on is 0, so all sprites start out with\npriority over foreground graphics.\n\nNote that for the purpose of priority, the 01 bit-pair of multicolor\ngraphics modes is considered to display a background color, and\ntherefore will be shown behind sprite graphics even if the foreground\ngraphics data takes priority.  Also, between the sprites themselves\nthere is a fixed priority.  Each sprite has priority over all\nhigher-number sprites, so that Sprite 0 is displayed in front of all\nthe others.\n\nThe use of priority can aid in creating three-dimensional effects, by\nallowing some objects on the screen to pass in front of or behind\nother objects."
  },
  {
    "id": "map-D01C",
    "address_start": 53276,
    "address_end": 53276,
    "hex_start": "$D01C",
    "hex_end": "$D01C",
    "label": "SPMC",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53276         $D01C          SPMC\nSprite Multicolor Registers\n\nBit 0:  Select multicolor mode for Sprite 0 (1=multicolor, 0=hi-res)\nBit 1:  Select multicolor mode for Sprite 1 (1=multicolor, 0=hi-res)\nBit 2:  Select multicolor mode for Sprite 2 (1=multicolor, 0=hi-res)\nBit 3:  Select multicolor mode for Sprite 3 (1=multicolor, 0=hi-res)\nBit 4:  Select multicolor mode for Sprite 4 (1=multicolor, 0=hi-res)\nBit 5:  Select multicolor mode for Sprite 5 (1=multicolor, 0=hi-res)\nBit 6:  Select multicolor mode for Sprite 6 (1=multicolor, 0=hi-res)\nBit 7:  Select multicolor mode for Sprite 7 (1=multicolor, 0=hi-res)\n\nSprite multicolor mode is very similar to text and bitmap multicolor\nmodes (see Bit 4 of 53270, $D016).  Normally, the color of each dot of\nthe sprite is controlled by a single bit of sprite shape data.  When\nthi mode is enabled for a sprite, by setting the corresponding bit of\nthis register to 1, the bits of sprite shape data are grouped together\nin pairs, with each pair of bits controlling a double-wide dot of the\nsprite display.  By sacrificing some of the horizontal resolution (the\nsprite, although the same size, is now only 12 dots wide), you gain\nthe use of two additional colors.  The four possible combinations of\nthese bit-pairs display dot colors from the following sources:\n\n00 Background Color Register 0 (transparent)\n01 Sprite Multicolor Register 0 (53285, $D025)\n10 Sprite Color Registers (53287-94, $D027-E)\n11 Sprite Multicolor Register 1 (53286, $D026)\n\nLike multicolor text characters, multicolor sprites all share two\ncolor registers.  While each sprite can display three foreground\ncolors, only one of these colors in unique to that sprite.  The number\nof unique colors may be increated by combining more than one sprite\ninto a single character."
  },
  {
    "id": "map-D01D",
    "address_start": 53277,
    "address_end": 53277,
    "hex_start": "$D01D",
    "hex_end": "$D01D",
    "label": "XXPAND",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53277         $D01D          XXPAND\nSprite Horizontal Expansion Register\n\nBit 0:  Expand Sprite 0 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 1:  Expand Sprite 1 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 2:  Expand Sprite 2 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 3:  Expand Sprite 3 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 4:  Expand Sprite 4 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 5:  Expand Sprite 5 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 6:  Expand Sprite 6 horizontally (1=double-width sprite, 0=normal\n        width)\nBit 7:  Expand Sprite 7 horizontally (1=double-width sprite, 0=normal\n        width)\n\nThis register can be used to double the width of any sprite.  Setting\nany bit of this register to 1 will cause each dot of the corresponding\nsprite shape to be displayed twice as wide as normal, so that without\nchanging its horizontal resolution, the sprite takes up twice as much\nspace.  The horizontal expansion feature can be used alone, or in\ncombination with the vertical expansion register at 53271 ($D017)."
  },
  {
    "id": "map-D01E-D01F",
    "address_start": 53278,
    "address_end": 53279,
    "hex_start": "$D01E",
    "hex_end": "$D01F",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 53278-53279 ($D01E-$D01F)\nSprite Collision Detection Registers\n\nWhile Bit 2 of the VIC IRQ Register at 53273 ($D019) is set to 1\nanytime two sprites overlap, and Bit 1 is set to 1, when a sprite\nshape is touching the foreground text or bit-graphics display, these\nregisters specify which sprites were involved in the collision.  Every\nbit that is set to 1 indicates that the corresponding sprite was\ninvolved in the collision.  Reading these registers clears them so\nthat they can detect the next collision.  Therefore, if you plan to\nmake multiple tests on the values stored here, it may be necessary to\ncopy it to a RAM variable for further reference.\n\nNote that while these registers tell you what sprites were involved in\na collision, they do not necessarily tell you what objects have\ncollided with each other.  It is quite possible to have three sprites\nlined up in a row, where Sprite A is on the left, Sprite B is in the\nmiddle, touching Sprite A, and Sprite C is on the right, touching\nSprite B but not touching Sprite A.  The Sprite-Sprite Collision\nregister would show that all three are involved.  The only way to make\nabsolutely certain which collided with which is to check the position\nof each sprite, and calculate for each sprite display line if a sprite\nof that size would touch either of the others.  As you can imagine,\nthis is no easy task.\n\nThere are a few simple rules concerning what does or does not cause a\ncollision.  Though the sprite character consists of 504 dots in a 24\nby 21 matrix, does which represent data bits that are equal to 0 (or\nmulticolor bit- pairs equal to 00), and therefore always displayed in\nthe background color, do not count when it comes to collision.\n\nA collision can occur only if a dot which represents a sprite shape\ndata bit of 1 touches another dot of nonzero graphics data.  Consider\nthe case of two invisible sprites.  The first sprite is enabled, its\ncolor set to contrast the background, and it is positioned on the\nscreen, but its shape data bytes are all 0.  This sprite can never be\ninvolved in a collision, because it displays no nonzero data.  The\nsecond sprite is enabled, positioned on the screen, and its shape\npointer set for a data read that is filled with bytes having a value\nof 255.  Even if that sprite's color is set to the same value as the\nbackground color, making the sprite invisible, it can still be\ninvolved in collisions.  The only exception to this rule is the 01\nbit-pair of multicolor graphics data.  This bit-pair is considered\npart of the background, and the dot it displays can never be involved\nin a collision.\n\nThe other rule to remember about collisions is that they can occur in\nareas that are covered by the screen border.  Collision between\nsprites can occur when the sprites are offscreen, and collisions\nbetween sprites and foreground display data can occur when that data\nis in an area that is covered by the border due to the reduction of\nthe display to 38 columns or 24 rows."
  },
  {
    "id": "map-D01E",
    "address_start": 53278,
    "address_end": 53278,
    "hex_start": "$D01E",
    "hex_end": "$D01E",
    "label": "SPSPCL",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53278         $D01E          SPSPCL\nSprite to Sprite Collision Register\n\nBit 0:  Did Sprite 0 collide with another sprite?  (1=yes)\nBit 1:  Did Sprite 1 collide with another sprite?  (1=yes)\nBit 2:  Did Sprite 2 collide with another sprite?  (1=yes)\nBit 3:  Did Sprite 3 collide with another sprite?  (1=yes)\nBit 4:  Did Sprite 4 collide with another sprite?  (1=yes)\nBit 5:  Did Sprite 5 collide with another sprite?  (1=yes)\nBit 6:  Did Sprite 6 collide with another sprite?  (1=yes)\nBit 7:  Did Sprite 7 collide with another sprite?  (1=yes)"
  },
  {
    "id": "map-D01F",
    "address_start": 53279,
    "address_end": 53279,
    "hex_start": "$D01F",
    "hex_end": "$D01F",
    "label": "SPBGCL",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53279         $D01F          SPBGCL\nSprite to Foreground Collision Register\n\nBit 0:  Did Sprite 0 collide with the foreground display?  (1=yes)\nBit 1:  Did Sprite 1 collide with the foreground display?  (1=yes)\nBit 2:  Did Sprite 2 collide with the foreground display?  (1=yes)\nBit 3:  Did Sprite 3 collide with the foreground display?  (1=yes)\nBit 4:  Did Sprite 4 collide with the foreground display?  (1=yes)\nBit 5:  Did Sprite 5 collide with the foreground display?  (1=yes)\nBit 6:  Did Sprite 6 collide with the foreground display?  (1=yes)\nBit 7:  Did Sprite 7 collide with the foreground display?  (1=yes)"
  },
  {
    "id": "map-D020-D02E",
    "address_start": 53280,
    "address_end": 53294,
    "hex_start": "$D020",
    "hex_end": "$D02E",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 53280-53294 ($D020-$D02E)\nVIC-II Color Register\n\nAlthough these color registers are used for various purposes, all of\nthem have one thing in common.  Like the Color RAM Nybbles, only the\nlower four bits are connected.  Therefore, when reading these\nregisters, you must mask out the upper four bits (that is,\nBORDERCOLOR=PEEK(53280)AND15) in order to get a true reading."
  },
  {
    "id": "map-D020",
    "address_start": 53280,
    "address_end": 53280,
    "hex_start": "$D020",
    "hex_end": "$D020",
    "label": "EXTCOL",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53280         $D020          EXTCOL\nBorder Color Register\n\nThe color value here determines the color of the border or frame\naround the central display area.  The entire screen is set to this\ncolor when the blanking feature of Bit 4 of 53265 ($D011) is enabled.\nThe default color value is 14 (light blue)."
  },
  {
    "id": "map-D021",
    "address_start": 53281,
    "address_end": 53281,
    "hex_start": "$D021",
    "hex_end": "$D021",
    "label": "BGCOL0",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53281         $D021          BGCOL0\nBackground Color 0\n\nThis register sets the background color for all text modes, sprite\ngraphics, and multicolor bitmap graphics.  The default color value is\n6 (blue)."
  },
  {
    "id": "map-D022",
    "address_start": 53282,
    "address_end": 53282,
    "hex_start": "$D022",
    "hex_end": "$D022",
    "label": "BGCOL1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53282         $D022          BGCOL1\nBackground Color 1\n\nThis register sets the color for the 01 bit-pair of multicolor\ncharacter graphics, and the background color for characters having\nscreen codes 64-127 in extended background color text mode.  The\ndefault color value is 1 (white)."
  },
  {
    "id": "map-D023",
    "address_start": 53283,
    "address_end": 53283,
    "hex_start": "$D023",
    "hex_end": "$D023",
    "label": "BGCOL2",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53283         $D023          BGCOL2\nBackground Color 2\n\nThis register sets the color for the 10 bit-pair of multicolor\ncharacter graphics, and the background color for characters habing\nscreen codes 128-191 in extended background color text mode.  The\ndefault color value is 2 (red).\n\n53285         $D024          BGCOL3\nBackground Color 3\n\nThis register sets the background color for characters having screen\ncodes between 192 and 255 in extended background color text mode.  The\ndefault color value is 3 (cyan)."
  },
  {
    "id": "map-D025",
    "address_start": 53285,
    "address_end": 53285,
    "hex_start": "$D025",
    "hex_end": "$D025",
    "label": "SPMC0",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53285         $D025          SPMC0\nSprite Multicolor Register 0\n\nThis register sets the color that is displayed by the 01 bit-pair in\nmulticolor sprite graphics.  The default color value is 4 (purple)."
  },
  {
    "id": "map-D026",
    "address_start": 53286,
    "address_end": 53286,
    "hex_start": "$D026",
    "hex_end": "$D026",
    "label": "SPMC1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53286         $D026          SPMC1\nSprite Multicolor Register 1\n\nThis register sets the color that is displayed by the 11 bit-pair in\nmulticolor sprite graphics.  The default color value is 0 (black)."
  },
  {
    "id": "map-D027-D02E",
    "address_start": 53287,
    "address_end": 53294,
    "hex_start": "$D027",
    "hex_end": "$D02E",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 53287-53294 ($D027-$D02E)\nSprite Color Registers\n\nThese registers are used to set the color to be displayed by bits of\nhi-res sprite data having a value of 1, and by bit-pairs of multicolor\nsprite data having a value of 10.  The color of each sprite is\ndetermined by its own individual color register."
  },
  {
    "id": "map-D027",
    "address_start": 53287,
    "address_end": 53287,
    "hex_start": "$D027",
    "hex_end": "$D027",
    "label": "SP0COL",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53287         $D027          SP0COL\nSprite 0 Color Register (the default color value is 1, white)"
  },
  {
    "id": "map-D028",
    "address_start": 53288,
    "address_end": 53288,
    "hex_start": "$D028",
    "hex_end": "$D028",
    "label": "SP1COL",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53288         $D028          SP1COL\nSprite 1 Color Register (the default color value is 2, red)"
  },
  {
    "id": "map-D029",
    "address_start": 53289,
    "address_end": 53289,
    "hex_start": "$D029",
    "hex_end": "$D029",
    "label": "SP2COL",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "53289         $D029          SP2COL\nSprite 2 Color Register (the default color value is 3, cyan)\n\n53290         $D01A          SP3COL\nSprite 3 Color Register (the default color value is 4, purple)\n\n53291         $D01B          SP4COL\nSprite 4 Color Register (the default color value is 5, green)\n\n53292         $D01C          SP5COL\nSprite 5 Color Register (the default color value is 6, blue)\n\n53293         $D01D          SP6COL\nSprite 6 Color Register (the default color value is 7, yellow)\n\n53294         $D01E          SP7COL\nSprite 7 Color Register (the default color value is 12, medium gray)"
  },
  {
    "id": "map-D02F-D03F",
    "address_start": 53295,
    "address_end": 53311,
    "hex_start": "$D02F",
    "hex_end": "$D03F",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 53295-53311 ($D02F-$D03F)\nNot Connected\n\nThe VIC-II chip has only 47 registers for 64 bytes of possible address\nspace.  Therefore, the remaining 17 addresses do not access any\nmemory.  When read, they will always give a value of 255 ($FF).  This\nvalue will not change after writing to them."
  },
  {
    "id": "map-D040-D3FF",
    "address_start": 53312,
    "address_end": 54271,
    "hex_start": "$D040",
    "hex_end": "$D3FF",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 53312-54271 ($D040-$D3FF)\nVIC-II Register Images\n\nSince the VIC-II requires only enough addressing lines to handle 64\nlocations (the minimum possible for its 47 registers), none of the\nhigher bits are decoded when addressing this 1K area.  The result is\nthat every 64 byte area in this 1K block is a mirror of every other.\nPOKE53281+64,1 has the same effect as POKE53281,1 or\nPOKE53281+10*64,1; they all turn the screen background to white.  For\nthe sake of clarity in your programs it is advisable to use the base\naddress of the chip."
  },
  {
    "id": "map-D400-D41C",
    "address_start": 54272,
    "address_end": 54300,
    "hex_start": "$D400",
    "hex_end": "$D41C",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54272-54300   $D400-$D41C\nSound Interface Device (SID) Registers\n\nMmeory locations 54272-54300 ($D400-$D41C) are used to address the\n6581 Sound Interface Device (SID).\n\nSID is a custom music synthesizer and sound effects generator chip\nthat gives the 64 its impressive musical capabilities.  It provides\nthree separate music channels, or voices, as they are called.  Each\nvoice has 16-bit frequency resolution, waveform control, envelope\nshaping, oscillator synchronization, and ring modulation.  In\naddition, programmable high-pass, low-pass, and band-pass filters can\nbe set and enabled or disabled for each sound channel.\n\nSince quite a few of these locations must be used in concert to\nproduce sound, a brief summary of the interplay between some of these\nregisters may be helpful.\n\nOften the first step is to select an overall volume level using the\nVolume Register.  Then, the desired frequency or pitch of the note is\nchosen by writing to each of the two bytes which make up the 16-bit\nFrequency Register.\n\nAn ADSR envelope setting must be chosen by writing values to the\nAttack/ Decay and Sustain/Release Register.  These determine the rate\nof the rise and fall of the volume of the note from zero volume to\npeak volume and back again.  These rates have a great influence on the\ncharacter of the sound.\n\nFinally, the waveform must be selected, and the note started (or the\noscillator gated, as we say).  This is done by writing certain bits to\nthe Control Register.  The waveform control lets you select one of\nfour different waveforms, each of which has varying harmonic content\nthat affects the tone quality of the sound.  By writing a 1 to the\ngate bit, you start the Attack/ Delay/Sustain cycle.  Afer rising to a\npeak and declining to the Sustain volume, the volume will continue at\nthe same level until you write a 0 to the gate bit.  Then, the Release\ncycle will start.  Make sure that you keep the same waveform bit set\nto 1 while you write the 0 to the gate bit, so that the Release cycle\nstarts.  Otherwise, the sound will stop entirely, as it also will if\nthe Volume Register or the Frequency Register is set to 0.\n\nIt should be noted that except for the last four SID chip registers,\nthese addresses are write-only.  That means that their values cannot\nbe determined by PEEKing these locations."
  },
  {
    "id": "map-D400-D401",
    "address_start": 54272,
    "address_end": 54273,
    "hex_start": "$D400",
    "hex_end": "$D401",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 54272-54273 ($D400-$D401)\nVoice 1 Frequency Control\n\nTogether, these two locations control the frequency or pitch of the\nmusical output of voice 1.  Some frequency must be selected in order\nfor voice 1 to be heard.  This frequency may be changed in the middle\nof a note to achieve special effects.  The 16-bit range of the\nFrequency Control Register covers over eight full octaves, and allows\nyou to vary the pitch from 0 (very low) to about 4000 Hz (very high),\nin 65536 steps.  The exact frequency of the output can be determined\nby the equation\n\nFREQUENCY=(REGISTER VALUE*CLOCK/16777216)Hz\n\nwhere CLOCK equals the system clock frequency, 1022730 for American\n(NTSC) systems, 985250 for European (PAL), and REGISTER VALUE is the\ncombined value of these frequency registers.  That combined value\nequals the value of the low byte plus 256 times the value of the high\nbyte.  Using the American (NTSC) clock value, the equation works out\nto\n\nFREQUENCY=REGISTER VALUE*.060959458 Hz"
  },
  {
    "id": "map-D400",
    "address_start": 54272,
    "address_end": 54272,
    "hex_start": "$D400",
    "hex_end": "$D400",
    "label": "FRELO1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54272         $D400          FRELO1\nVoice 1 Frequency Control (low byte)"
  },
  {
    "id": "map-D401",
    "address_start": 54273,
    "address_end": 54273,
    "hex_start": "$D401",
    "hex_end": "$D401",
    "label": "FREHI1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54273         $D401          FREHI1\nVoice 1 Frequency Control (high byte)"
  },
  {
    "id": "map-D402-D403",
    "address_start": 54274,
    "address_end": 54275,
    "hex_start": "$D402",
    "hex_end": "$D403",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 54274-54275 ($D402-$D403)\nVoice 1 Pulse Waveform Width Control\n\nAs you will see below under the description of the Control Register at\n54276 ($D404), you can select one of four different waveforms for the\noutput of each voice.  If the pulse waveform is selected, these\nregisters must be set to establish the pulse width.\n\nThe pulse width has a 12-bit resolution, being made up of the value in\nthe first register and the value in the lower nybble of the second\nregister.  The pulse width determines the duty cycle, or proportion of\nthe time that the rectangular wave will stay at the high part of the\ncycle.\n\nThe following formula shows the relationship between the value in the\nPulse Width Register and the proportion of time that the wave stays at\nthe high part of the cycle:\n\nPULSE WIDTH=(REGISTER VALUE/40.95)%\n\nThe possible range of the register values (0-4095) covers the range of\nthe duty cycles from 0 to 100 percent in 4096 steps.  Changing the\npulse width will vastly change the sound created with the pulse\nwaveform."
  },
  {
    "id": "map-D402",
    "address_start": 54274,
    "address_end": 54274,
    "hex_start": "$D402",
    "hex_end": "$D402",
    "label": "PWLO1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54274         $D402          PWLO1\nVoice 1 Pulse Waveform Width (low byte)"
  },
  {
    "id": "map-D403",
    "address_start": 54275,
    "address_end": 54275,
    "hex_start": "$D403",
    "hex_end": "$D403",
    "label": "PWHI1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54275         $D403          PWHI1\nVoice 1 Pulse Waveform Width (high nybble)"
  },
  {
    "id": "map-D404",
    "address_start": 54276,
    "address_end": 54276,
    "hex_start": "$D404",
    "hex_end": "$D404",
    "label": "VCREG1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54276         $D404          VCREG1\nVoice 1 Control Register\n\nBit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release\nBit 1:  Sync Bit:  1=Synchronize Oscillator with Oscillator 3 frequency\nBit 2:  Ring Modulation:  1=Ring modulate Oscillators 1 and 3\nBit 3:  Test Bit:  1=Disable Oscillator 1\nBit 4:  Select triangle waveform\nBit 5:  Select sawtooth waveform\nBit 6:  Select pulse waveform\nBit 7:  Select random noise waveform\n\n\nBit 0.  Bit 0 is used to gate the sound.  Setting this bit to a 1\nwhile selecting one of the four waveforms will start the\nattack/decay/sustain part of the cycle.  Setting this bit back to 0\n(while keeping the same waveform setting) anytime after a note has\nstarted playing will begin the release cycle of the note.  Of course,\nin order for the gate bit to have an effect, the frequency and\nattack/decay/sustain/release (ADSR) registers must be set, as well as\nthe pulse width, if necessary, and the volume control set to a nonzero\nvalue.\n\nBit 1.  This bit is used to synchronize the fundamental frequency of\nOscillator 1 with the fundamental frequency of Oscillator 3, allowing\nyou to create a wide range of complex harmonic structures from voice\n1.  Synchronization occurs when this bit is set to 1.  Oscillator 3\nmust be set to some frequency other than zero, but no other voice 3\nparameters will affect the output from voice 1.\n\nBit 2.  When Bit 2 is set to 1, the triangle waveform output of voice\n1 is replaced with a ring modulated combination of Oscillators 1 and\n3.  This ring modulation produces nonharmonic overtone structures that\nare useful for creating bell or gong effects.\n\nBit 3.  Bit 3 is the test bit.  When set to 1, it disables the output\nof the oscillator.  This can be useful in generating very complex\nwaveforms (even speech synthesis) under software control.\n\nBit 4.  When set to 1, Bit 4 selects the triangle waveform output of\nOscillator 1.  Bit 0 must also be set for the note to be sounded.\n\nBit 5.  This bit selects the sawtooth waveform when set to 1.  Bit 0\nmust also be set for the sound to begin.\n\nBit 6.  Bit 6 chooses the pulse waveform when set to 1.  The harmonic\ncontent of sound produced using this waveform may be varied using the\nPulse Width Registers.  Bit 0 must be set to begin the sound.\n\nBit 7.  When Bit 7 is set to 1, the noise output waveform for\nOscillator 1 is set.  This creates a random sound output whose\nwaveform varies with a frequency proportionate to that of Oscillator\n1.  It can be used to imitate the sound of explosions, drums, and\nother unpitched noises.\n\nOne of the four waveforms must be chosed in order to create a sound.\nSetting more than one of these bits will result in a logical ANDing of\nthe waveforms.  Particularly, the combination of the noise waveform\nand another is not recommended."
  },
  {
    "id": "map-D405-D406",
    "address_start": 54277,
    "address_end": 54278,
    "hex_start": "$D405",
    "hex_end": "$D406",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 54277-54278 ($D405-$D406)\nVoice 1 Envelop (ADSR) Control\n\nWhen a note is played on a musical instrument, the volume does not\nsuddenly rise to a peak and then cut off to zero.  Rather, the volume\nbuilds to a peak, levels off to an intermediate value, and then fades\naway.  This creates what is known as a volume envelope.\n\nThe first phase of the envelope, in which the volume builds to a peak,\nis known as the attack phase.  The second, in which it declines to an\nintermediate level, is called the decay phase.  The third, in which\nthe intermediate leve of volume is held, is known as the sustain\nperiod.  The final interval, in which the sound fades away, is called\nthe release part of the cycle.\n\nThe SID chip allows the volume envelope of each voice to be\ncontrolled, so that specific instruments may be imitated, or new\nsounds created.  This is done via the attack/decay and sustain/release\nregisters.  Each register devotes four bits (which can store a number\nfrom 0 to 15) to each phase of the cycle.  When a note is gated by\nwriting a 1 to a waveform bit and to Bit 0 of the Control Register,\nthe attack cycle begins.\n\nThe volume of the sound builds to a peak over the period of time\nspecified by the high nybble of the attack/decay register.  Once it\nhas reached the peak volume, it falls to the intermediate level during\nthe period indicated by the low nybble of the attack/decay register\n(this is the decay phase).  The volume of this intermediate or sustain\nlevel is selected by placing a value in the high nybble of the\nsustain/release register.  This volume level is held until a 0 is\nwritten to the gate bit of the control register (while leaving the\nwaveform bit set).  When that happens, the release phase begins, and\nthe volume of the sound begins to taper off during the period\nindicated by the low nybble of the sustain/release register.\n\nYou may notice the volume of the sound does not quite get to 0 at the\nend of the release cycle, and you may need to turn off the sound to\nget rid of the residual noise.  You can do this either by setting the\nwaveform bit back to 0, changing the frequency to 0, or setting the\nvolume to 0."
  },
  {
    "id": "map-D405",
    "address_start": 54277,
    "address_end": 54277,
    "hex_start": "$D405",
    "hex_end": "$D405",
    "label": "ATDCY1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54277         $D405          ATDCY1\nVoice 1 Attack/Decay Register\n\nBits 0-3:  Select decay cycle duration (0-15)\nBits 4-7:  Select attack cycle duration (0-15)\n\nBits 4-7 control the duration of the attack cycle.  This is the period\nof time over which the volume will rise from 0 to its peak amplitude.\nThere are 16 durations which may be selected.  The way in which the\nnumber placed here corresponds to the elapsed time of this cycle is as\nfollows:\n\n0 = 2 milliseconds           8 = 100 milliseconds\n1 = 8 milliseconds           9 = 250 milliseconds\n2 = 16 milliseconds         10 = 500 milliseconds\n3 = 24 milliseconds         11 = 800 milliseconds\n4 = 38 milliseconds         12 = 1 second\n5 = 56 milliseconds         13 = 3 seconds\n6 = 68 milliseconds         14 = 5 seconds\n7 = 80 milliseconds         15 = 8 seconds\n\nBits 0-3 control the length of the decay phase, in which the volume of\nthe note declines from the peak reached in the attack phase to the\nsustain level.  The number selected corresponds to the length of this\nphase as shown below:\n\n0 = 6 milliseconds           8 = 300 milliseconds\n1 = 24 milliseconds          9 = 750 milliseconds\n2 = 48 milliseconds         10 = 1.5 seconds\n3 = 72 milliseconds         11 = 2.4 seconds\n4 = 114 milliseconds        12 = 3 seconds\n5 = 168 milliseconds        13 = 9 seconds\n6 = 204 milliseconds        14 = 15 seconds\n7 = 240 milliseconds        15 = 24 seconds\n\nSince the two functions share one register, you must multiply the\nattack value by 16 and add it to the decay value in order to come up\nwith the number to be placed in the register:\n\nREGISTER VALUE=(ATTACK*16)+DECAY"
  },
  {
    "id": "map-D406",
    "address_start": 54278,
    "address_end": 54278,
    "hex_start": "$D406",
    "hex_end": "$D406",
    "label": "SUREL1",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54278         $D406          SUREL1\nVoice 1 Sustain/Release Control Register\n\nBits 0-3:  Select release cycle duration (0-15)\nBits 4-7:  Select sustain volume level (0-15)\n\nBits 4-7 select the volume level at which the note is sustained.\nFollowing the decay cycle, the volume of the output of voice 1 will\nremain at the selected sustain level as long as the gate bit of the\nControl Register is set to 1.  The sustain values range from 0, which\nchooses no volume, to 15, which sets the output of voice 1 equal to\nthe peak volume achieved during the attack cycle.\n\nBits 0-3 determine the length of the release cycle.  This phase, in\nwhich the volume fades from the sustain level to near zero volume,\nbegins when the gate bit of the Control Register is set to 0 (while\nleaving the waveform setting that was previously chosen).  The\nduration of this decline in volume corresponds to the number (0-15)\nselected in the same way as for the decay value:\n\n0 = 6 milliseconds           8 = 300 milliseconds\n1 = 24 milliseconds          9 = 750 milliseconds\n2 = 48 milliseconds         10 = 1.5 seconds\n3 = 72 milliseconds         11 = 2.4 seconds\n4 = 114 milliseconds        12 = 3 seconds\n5 = 168 milliseconds        13 = 9 seconds\n6 = 204 milliseconds        14 = 15 seconds\n7 = 240 milliseconds        15 = 24 seconds"
  },
  {
    "id": "map-D407-D414",
    "address_start": 54279,
    "address_end": 54292,
    "hex_start": "$D407",
    "hex_end": "$D414",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 54279-54292 ($D407-$D414)\nVoice 2 and Voice 3 Controls\n\nThe various control registers for these two voices correspond almost\nexactly to those of voice 1.  The one exception is that the sync and\nring-modulation bits of voice 2 operate on Oscillators 1 and 2, while\nthe same bits of the Control Register for voice 3 uses Oscillators 2\nand 3."
  },
  {
    "id": "map-D407",
    "address_start": 54279,
    "address_end": 54279,
    "hex_start": "$D407",
    "hex_end": "$D407",
    "label": "FRELO2",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54279         $D407          FRELO2\nVoice 2 Frequency Control (low byte)"
  },
  {
    "id": "map-D408",
    "address_start": 54280,
    "address_end": 54280,
    "hex_start": "$D408",
    "hex_end": "$D408",
    "label": "FREHI2",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54280         $D408          FREHI2\nVoice 2 Frequency Control (high byte)"
  },
  {
    "id": "map-D409",
    "address_start": 54281,
    "address_end": 54281,
    "hex_start": "$D409",
    "hex_end": "$D409",
    "label": "PWLO2",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54281         $D409          PWLO2\nVoice 2 Pulse Waveform Width (low byte)"
  },
  {
    "id": "map-D40A",
    "address_start": 54282,
    "address_end": 54282,
    "hex_start": "$D40A",
    "hex_end": "$D40A",
    "label": "PWHI2",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54282         $D40A          PWHI2\nVoice 2 Pulse Waveform Width (high nybble)"
  },
  {
    "id": "map-D40B",
    "address_start": 54283,
    "address_end": 54283,
    "hex_start": "$D40B",
    "hex_end": "$D40B",
    "label": "VCREG2",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54283         $D40B          VCREG2\nVoice 2 Control Register\n\nBit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release\nBit 1:  Sync Bit:  1=Synchronize oscillator with Oscillator 1 frequency\nBit 2:  Ring Modulation:  1=Ring modulate Oscillators 2 and 1\nBit 3:  Test Bit:  1=Disable Oscillator 2\nBit 4:  Select triangle waveform\nBit 5:  Select sawtooth waveform\nBit 6:  Select pulse waveform\nBit 7:  Select noise waveform"
  },
  {
    "id": "map-D40C",
    "address_start": 54284,
    "address_end": 54284,
    "hex_start": "$D40C",
    "hex_end": "$D40C",
    "label": "ATDCY2",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54284         $D40C          ATDCY2\nVoice 2 Attack/Decay Register\n\nBits 0-3:  Select decay cycle duration (0-15)\nBits 4-7:  Select attack cycle duration (0-15)"
  },
  {
    "id": "map-D40D",
    "address_start": 54285,
    "address_end": 54285,
    "hex_start": "$D40D",
    "hex_end": "$D40D",
    "label": "SUREL2",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54285         $D40D          SUREL2\nVoice 2 Sustain/Release Control Register\n\nBits 0-3:  Select release cycle duration (0-15)\nBits 4-7:  Select sustain volume level (0-15)"
  },
  {
    "id": "map-D40E",
    "address_start": 54286,
    "address_end": 54286,
    "hex_start": "$D40E",
    "hex_end": "$D40E",
    "label": "FRELO3",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54286         $D40E          FRELO3\nVoice 3 Frequency Control (low byte)"
  },
  {
    "id": "map-D40F",
    "address_start": 54287,
    "address_end": 54287,
    "hex_start": "$D40F",
    "hex_end": "$D40F",
    "label": "FREHI3",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54287         $D40F          FREHI3\nVoice 3 Frequency Control (high byte)"
  },
  {
    "id": "map-D410",
    "address_start": 54288,
    "address_end": 54288,
    "hex_start": "$D410",
    "hex_end": "$D410",
    "label": "PWLO3",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54288         $D410          PWLO3\nVoice 3 Pulse Waveform Width (low byte)"
  },
  {
    "id": "map-D411",
    "address_start": 54289,
    "address_end": 54289,
    "hex_start": "$D411",
    "hex_end": "$D411",
    "label": "PWHI3",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54289         $D411          PWHI3\nVoice 3 Pulse Waveform Width (high nybble)"
  },
  {
    "id": "map-D412",
    "address_start": 54290,
    "address_end": 54290,
    "hex_start": "$D412",
    "hex_end": "$D412",
    "label": "VCREG3",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54290         $D412          VCREG3\nVoice 3 Control Register\n\nBit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release\nBit 1:  Sync Bit:  1=Synchronize oscillator with Oscillator 2 frequency\nBit 2:  Ring Modulation:  1=Ring modulate Oscillators 3 and 2\nBit 3:  Test Bit:  1=Disable Oscillator 3\nBit 4:  Select triangle waveform\nBit 5:  Select sawtooth waveform\nBit 6:  Select pulse waveform\nBit 7:  Select noise waveform"
  },
  {
    "id": "map-D413",
    "address_start": 54291,
    "address_end": 54291,
    "hex_start": "$D413",
    "hex_end": "$D413",
    "label": "ATDCY3",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54291         $D413          ATDCY3\nVoice 3 Attack/Decay Register\n\nBits 0-3:  Select decay cycle duration (0-15)\nBits 4-7:  Select attack cycle duration (0-15)"
  },
  {
    "id": "map-D414",
    "address_start": 54292,
    "address_end": 54292,
    "hex_start": "$D414",
    "hex_end": "$D414",
    "label": "SUREL3",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54292         $D414          SUREL3\nVoice 3 Sustain/Release Control Register\n\nBits 0-3:  Select release cycle duration (0-15)\nBits 4-7:  Select sustain volume level (0-15)"
  },
  {
    "id": "map-D415-D418",
    "address_start": 54293,
    "address_end": 54296,
    "hex_start": "$D415",
    "hex_end": "$D418",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 54293-54296 ($D415-$D418)\nFilter Controls\n\nIn addition to the controls detailed above for each voice, the SID\nchip also provides a filtering capability which allows you to\nattenuate (make quieter) certain ranges of frequencies.  Any one or\nall three voices can be filtered, and there is even a provision for\nfiltering an external signal that is input through pin 5 of the\nmonitor jack.\n\nA low-pass filter is available, which suppresses the volume of those\nfrequency components that are above a designated cutoff level.  The\nhigh-pass filter reduces the volume of frequency components that are\nbelow a certain level.  The band-pass filter reduces the volume of\nfrequency components on both sides of the chosen frequency, thereby\nenhancing that frequency.  Finally, the high-pass and low-pass filters\ncan be combined to form a notch reject filter, which reduces the\nfolume of the frequency components nearest the selected frequency.\nThese various filters can dramatically change the quality of the sound\nproduced.\n\nThe first two registers are used to select the filter cutoff\nfrequency.  This is the frequency above or below which any sounds will\nbe made quieter.  The further away from this level any frequency\ncomponents are, the more their output volume will be suppresed (high-\nand low-pass filters reduce the volume of those components by 12 dB\nper octave away from the center frequency, while the band-pass filter\nattenuates them by 6 dB per octave).\n\nThe cutoff frequency has an 11-bit range (which corresponds to the\nnumbers 0 to 2047).  This is made up of a high-byte and three low\nbits.  Therefore, to compute the frequency represented by the value in\nthese registers, you must multiply the value in the high byte by 8,\nand add the value of the low three bits.  The range of cutoff\nfreqnencies represented by these 2048 values stretches from 30 Hz to\nabout 12,000 Hz.  The exact frequency may be calculated with the\nformula:\n\nFREQUENCY=(REGISTER VALUE*5.8)+30Hz\n\nAn additional element in filtering is the resonance control.  This\nallows you to peak the volume of the frequency elements nearest the\ncutoff frequency."
  },
  {
    "id": "map-D415",
    "address_start": 54293,
    "address_end": 54293,
    "hex_start": "$D415",
    "hex_end": "$D415",
    "label": "CUTLO",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54293         $D415          CUTLO\n\nBits 0-2:  Low portion of filter cutoff frequency\nBits 5-7:  Unused"
  },
  {
    "id": "map-D416",
    "address_start": 54294,
    "address_end": 54294,
    "hex_start": "$D416",
    "hex_end": "$D416",
    "label": "CUTHI",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54294         $D416          CUTHI\nFilter Cutoff Frequency (high byte)"
  },
  {
    "id": "map-D417",
    "address_start": 54295,
    "address_end": 54295,
    "hex_start": "$D417",
    "hex_end": "$D417",
    "label": "RESON",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54295         $D417          RESON\nFilter Resonance Control Register\n\nBit 0:  Filter the output of voice 1?  1=yes\nBit 1:  Filter the output of voice 2?  1=yes\nBit 2:  Filter the output of voice 3?  1=yes\nBit 3:  Filter the output from the external input?  1=yes\nBits 4-7:  Select filter resonance 0-15\n\nBits 0-3 are used to control which of the voices will be altered by\nthe filters.  If one of these bits is set to 1, the corresponding\nvoice will be processed through the filter, and its harmonic content\nwill be changed accordingly.  If the bit is set to 0, the voice will\npass directly to the audio output.  Note that there is also a\nprovision for processing an external audio signal which is brought\nthrough pin 5 of the Audio/Video Port.\n\nBits 4-7 control the resonance of the filter.  By placing a number\nfrom 0 to 15 in these four bits, you may peak the volume of those\nfrequencies nearest the cutoff.  This creates an even sharper\nfiltering effect.  A setting of 0 causes no resonance, while a setting\nof 15 gives maximum resonance."
  },
  {
    "id": "map-D418",
    "address_start": 54296,
    "address_end": 54296,
    "hex_start": "$D418",
    "hex_end": "$D418",
    "label": "SIGVOL",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54296         $D418          SIGVOL\nVolume and Filter Select Register\n\nBits 0-3:  Select output volume (0-15)\nBit 4:  Select low-pass filter, 1=low-pass on\nBit 5:  Select band-pass filter, 1=band-pass on\nBit 6:  Select high-pass filter, 1=high-pass on\nBit 7:  Disconnect output of voice 4, 1=voice 3 off\n\nBits 0-3 control the volume of all outputs.  The possible volume\nlevels range from 0 (no volume) to 15 (maximum volume).  Some level of\nvolume must be set here before any sound can be heard.\n\nBits 4-6 control the selection of the low-pass, band-pass, or\nhigh-pass filter.  A 1 in any of these bits turns the corresponding\nfilter on.  These filters can be combined, although only one cutoff\nfrequency can be chosen.  In order for the filter to have any effect,\nat least one of the voices must be routed through it using the Filter\nResonance Control Register at 54295 ($D417).\n\nWhen Bit 7 is set to 1,  it disconnects the output of voice 3.  This\nallows you to use the output of the oscillator for modulating the\nfrequency of the other voices, or for generating random number,\nwithout any undesired audio output."
  },
  {
    "id": "map-D419-D41A",
    "address_start": 54297,
    "address_end": 54298,
    "hex_start": "$D419",
    "hex_end": "$D41A",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 54297-54298 ($D419-$D41A)\nGame Paddle Inputs\n\nThese registers allow you to read the game paddles that plug into\njoystick Controller Ports 1 and 2.  Each paddle uses a variable\nresistor (also known as a potentiometer or pot), whose resistance is\ncontrolled by turning a knob.  The varying resistance is used to vary\nthe voltage to two pins of the SID chip between 0 and +5 volts.\nAnalog-to-digital (A/D) converters in the chip interpret these voltage\nlevels as binary values and store the values in these registers.\nThese registers return a number from 0 (minumum resistance) to 255\n(maximum resistance) for each paddle in either of the ports, depending\non the position of the paddle knob.\n\nSince these registers will read the paddle values for only one\ncontroller port, there is a switching mechanism which allows you to\nselect which of the two ports to read.  By writing a bit-pair of 01\n(bit value of 64) to the last two bits of CIA #1 Data Port A (56320,\n$DC00), you select the paddles on joystick Controller Port 1.  By\nwriting a bit-pair of 10 (bit value of 128), you select the paddles on\nController Port 2.\n\nIf you look at the description of Data Port A (56320, $DC00), however,\nyou will notice that it is also used in the keyboard scanning process.\nBy writing to this port, you determine which keyboard column will be\nread.\n\nSince the IRQ interrupt keyboard scan routine and the routine that\nchecks for the STOP key are putting values into this location 60 times\nper second, you cannot reliable select the pair of paddles you wish to\nread from BASIC without first turning off the keyboard IRQ.  This can\nbe done with a POKE 56333,127.  You can then read the paddles with the\nstatements A=PEEK(54297) and B=PEEK(54298).  The IRQ can be restored\nafter a paddle read with a POKE 56333,129.  It may, however, be easier\nand more accurate in the long run to use a machine language paddle\nread subroutine such as that presented on page 347 of the Commodore 64\nProgrammer's Reference Guide.\n\nThe paddle fire buttons are read as Bits 2 and 3 of the Data Ports A\n(56320, $DC00) and B (56321, $DC01).  On Port A, if Bit 2 is set to 0,\nbutton 1 is pushed, and if Bit 3 is set to 0, button 2 is pushed.  On\nPort B, if Bit 2 is set to 0, button 3 is pushed, and if Bit 3 is set\nto 0, button 4 is pushed.\n\nThe BASIC statements to test these buttons, thereore, are:\n\nPB(1)=(PEEK(56321)AND4)/4\nPB(2)=(PEEK(56321)AND8)/8\nPB(3)=(PEEK(56320)AND4)/4\nPB(4)=(PEEK(56320)AND8)/8\n\nIf a 0 is returned by the PEEK statement, the button is pushed, and if\na 1 is returned, it is not."
  },
  {
    "id": "map-D419",
    "address_start": 54297,
    "address_end": 54297,
    "hex_start": "$D419",
    "hex_end": "$D419",
    "label": "POTX",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54297         $D419          POTX\nRead Game Paddle 1 (or 3) Position"
  },
  {
    "id": "map-D41A",
    "address_start": 54298,
    "address_end": 54298,
    "hex_start": "$D41A",
    "hex_end": "$D41A",
    "label": "POTY",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54298         $D41A          POTY\nRead Game Paddle 2 (or 4) Position"
  },
  {
    "id": "map-D41B",
    "address_start": 54299,
    "address_end": 54299,
    "hex_start": "$D41B",
    "hex_end": "$D41B",
    "label": "RANDOM",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54299         $D41B          RANDOM\nRead Oscillator 3/Random Number Generator\n\nThis register lets you read the upper eight bits of the waveform\noutput of Oscillator 3.  The kinds of numbers generated by this output\ndepend on the type of waveform selected.\n\nIf the sawtooth waveform is chosen, the output read by this register\nwill be a series of numbers which start at 0 and increase by 1 to a\nmaximum of 255, at which time they start over at 0.\n\nWhen the triangle waveform is chosen, they increase from 0 to 255, at\nwhich time they decrease to 0 again.  The rate at which these numbers\nchange is determined by the frequency of Oscillator 3.\n\nIf the pulse waveform is selected, the output here will be either 255\nor 0.\n\nFinally, selecting the noise waveform will produce a random series of\nnumbers between 0 and 255.  This allows you to use the register as a\nrandom number generator for games.\n\nThere are many other uses for reading Oscillator 3, however,\nparticularly for modulation of the other voices through machine\nlanguage software.  For example, the output of this register could be\nadded to the frequency of another voice.  If the triangle waveform\nwere selected for this purpose, it would cause the frequency of the\nother voice to rise and fall, at the frequency of Oscillator 3\n(perhaps for vibrato effects).  This output can also be combined with\nthe Filter Frequency or Pulse Width Registers to vary the values in\nthese registers quickly over a short period of time.\n\nNormally, when using Oscillator 3 for modulation, the audio output of\nvoice 3 should be turned off by setting Bit 7 of the Volume and Filter\nSelect Register at 54296 ($d418) to 1.  It is not necessary to gate\nBit 0 of Control Register 3 to use the oscillator, however, as its\noutput is not affected by the ADSR envelope cycle."
  },
  {
    "id": "map-D41C",
    "address_start": 54300,
    "address_end": 54300,
    "hex_start": "$D41C",
    "hex_end": "$D41C",
    "label": "ENV3",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "54300         $D41C          ENV3\nEnvelope Generator 3 Output\n\nThis register allows you to read the output of the voice 3 Envelope\ngenerator, in much the same way that the preceding register lets you\nread the output of Oscillator 3.  This output can also be added to\nanother oscillator's Frequency Control Registers, Pulse Width\nRegisters, or the Filter Frequency Control Register.  In order to\nproduce any output from this register, however, the gate bit in\nControl Register 3 must be set to 1.  Just as in the production of\nsound, setting the gate bit to 1 starts the attack/decay/sustain\ncycle, and setting it back to 0 starts the release cycle."
  },
  {
    "id": "map-D41D-D41F",
    "address_start": 54301,
    "address_end": 54303,
    "hex_start": "$D41D",
    "hex_end": "$D41F",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 54301-54303 ($D41D-$D41F)\nNot Connected\n\nThe SID chip has been provided with enough addresses for 32 different\nregisters, but as it has only 29, the remaining three addresses are\nnot used.  Reading them will always return a value of 255 ($FF), and\nwriting to them will have no effect."
  },
  {
    "id": "map-D420-D7FF",
    "address_start": 54304,
    "address_end": 55295,
    "hex_start": "$D420",
    "hex_end": "$D7FF",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 54304-55295 ($D420-$D7FF)\nSID Register Images\n\nSince the SID chip requires enough addressing lines for only 32\nlocations (the minimum possible for its 29 registers), none of the\nhigher bits are decoded when addressing the 1K area that has been\nassigned to it.  The result is that every 32-byte area in this 1K\nblock is a mirror of every other.  For the sake of clarity in your\nprograms, it is advisable not to use these addresses at all."
  },
  {
    "id": "map-D800-DBFF",
    "address_start": 55296,
    "address_end": 56319,
    "hex_start": "$D800",
    "hex_end": "$DBFF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "55296-56319   $D800-$DBFF\nColor RAM\n\nThe normal Commodore 64 text graphics system uses a screen RAM area to\nkeep track of the character shapes that are to be displayed.  But\nsince each character can be displayed in any of 16 foreground colors,\nthere must also be a parallel area which keeps track of the foreground\ncolor.  This 1024-byte area is used for that purpose (actually, since\nthere are only 1000 screen positions, only 1000 byte actually affect\nscreen color).\n\nThese 1000 bytes each control the foreground color of one character,\nwith the first byte controlling the foreground color of the character\nin the upper- left corner, and subsequent bytes controlling the\ncharacters to the right and below that character.\n\nBecause only four bits are needed to represent the 16 colors\navailable, only the low four bits of each Color RAM location are\nconnected (this is why they are sometimes referred to as Color RAM\nNybbles).  Writing to the high bits will not affect them, and these\nfour bits will usually return a random value when read (a small number\nof 64s return a constant value).\n\nTherefore, in order to read Color RAM correctly, you must mask out the\ntop bits by using the logical AND function.  In BASIC, you can read\nthe first byte of Color RAM with the statement CR=PEEK(55296)AND15.\nThis will always return a color value between 0 and 15.  These color\nvalues correspond to the following colors:\n\n 0 = BLACK\n 1 = WHITE\n 2 = RED\n 3 = CYAN (LIGHT BLUE-GREEN)\n 4 = PURPLE\n 5 = GREEN\n 6 = BLUE\n 7 = YELLOW\n 8 = ORANGE\n 9 = BROWN\n10 = LIGHT RED\n11 = DARK GRAY\n12 = MEDIUM GRAY\n13 = LIGHT GREEN\n14 = LIGHT BLUE\n15 = LIGHT GRAY\n\nColor mapping affords a convenient method of changing the color of the\ntext display without changing the letters.  By POKEing the appropriate\nsection of Color RAM, you can change the color of a whole section of\ntext on the screen without affecting the content of the text.  You can\neven use this method to make letters disappear by changing their\nforeground colors to match the background (or by changing the\nbackground to match the foreground), and later make them reappear by\nchanging them back, or by changing the background to a contrasting\ncolor.  An interesting example program which changes Color RAM quickly\nin BASIC can be found under the entry for 648 ($288).\n\nA change in the Operating System causes newer 64s to set all of the\nColor RAM locations to the same value as the current background color\nwhenever the screen is cleared.  Therefore, POKEing character codes to\nthe Screen RAM area will not appear to have any effect, because the\nletters will be the same color as the background.  This can easily be\nturned to your advantage, however, because it means that all you have\nto do to set all of Color RAM to a particular value is to set the\nbackground color to that value (using the register at 53281 ($D021)),\nclear the screen, and return the background color in the desired\nvalue.\n\nThe various garphics modes use this area differently than does the\nregular text mode.  In high-resolution bitmap mode, this area is not\nused at all, but in multicolor bitmap mode it is used to determine the\ncolor of the 11 bit-pair for a given 8 by 8 dot area.\n\nIn multicolor text mode, only the lowest three bits are used, so only\ncolors 0-7 may be selected.  The fourth bit is used to determine\nwhether a character will be displayed in regular text or multicolor\ntext.  Characters with a color value over 7 are displayed as\nmulticolor characters, with the color of the 11 bit-pair determined by\nthe color value minus 8.  Characters with a color value under 8 are\ndisplayed normally.\n\nIt should be noted that unlike the Screen RAM area, which can be moved\nto any RAM location, the Color RAM area is fixed, and will function\nnormally regardless of where screen memory is located."
  },
  {
    "id": "map-DC00-DC0F",
    "address_start": 56320,
    "address_end": 56335,
    "hex_start": "$DC00",
    "hex_end": "$DC0F",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56320-56335   $DC00-$DC0F\nComplex Interface Adapter (CIA) #1 Registers\n\nLocations 56320-56335 ($DC00-$DC0F) are used to communicate with the\nComplex Interface Adapter chip #1 (CIA #1).  This chip is a successor\nto the earlier VIA and PIA devices used on the VIC-20 and PET.  This\nchip functions the same way as the VIA and PIA:  It allows the 6510\nmicroprocessor to communicate with peripheral input and output\ndevices.  The specific devices that CIA #1 reads data from and sends\ndata to are the joystick controllers, the paddle fire buttons, and the\nkeyboard.\n\nIn addition to its two data ports, CIA #1 has two timers, each of\nwhich can count an interval from a millionth of a second to a\nfifteenth of a second.  Or the timers can be hooked together to count\nmuch longer intervals.  CIA #1 has an interrupt line which is\nconnected to the 6510 IRQ line.  These two timers can be used to\ngenerate interrupts at specified intervals (such as the 1/60 second\ninterrupt used for keyboard scanning, or the more complexly timed\ninterrupts that drive the tape read and write routines).  As you will\nsee below, the CIA chip has a host of other features to aid in\nInput/Output functions."
  },
  {
    "id": "map-DC00-DC01",
    "address_start": 56320,
    "address_end": 56321,
    "hex_start": "$DC00",
    "hex_end": "$DC01",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56320-56321 ($DC00-$DC01)\nCIA #1 Data Ports A and B\n\nThese registers are where the actual communication with outside\ndevices takes place.  Bits of data written to these registers can be\nsent to external devices, while bits of data that those devices send\ncan be read here.\n\nThe keyboard is so necessary to the computer's operation that you may\nhave a hard time thinking of it as a peripheral device.  Nonetheless,\nit cannot be directly read by the 6510 microprocessor.  Instead, the\nkeys are connected in a matrix of eight rows by eight columns to CIA\n#1 Ports A and B.  The layout of this matrix is shown below.\n\nWRITE TO PORT A               READ PORT B (56321, $DC01)\n56320/$DC00\n         Bit 7   Bit 6   Bit 5   Bit 4   Bit 3   Bit 2   Bit 1   Bit 0\n\nBit 7    STOP    Q       C=      SPACE   2       CTRL    <-      1\n\nBit 6    /       ^       =       RSHIFT  HOME    ;       *       LIRA\n\nBit 5    ,       @       :       .       -       L       P       +\n\nBit 4    N       O       K       M       0       J       I       9\n\nBit 3    V       U       H       B       8       G       Y       7\n\nBit 2    X       T       F       C       6       D       R       5\n\nBit 1    LSHIFT  E       S       Z       4       A       W       3\n\nBit 0    CRSR DN F5      F3      F1      F7      CRSR RT RETURN  DELETE\n\nAs you can see, there are two keys which do not appear in the matrix.\nThe SHIFT LOCK key is not read as a separate key, but rather is a\nmechanical device which holds the left SHIFT key switch in a closed\nposition.  The RESTORE key is not read like the other keys either.  It\nis directly connected to the NMI interrupt line of the 6510\nmicroprocessor, and causes an NMI interrupt to occur whenever it is\npressed (not just when it is pressed with the STOP key).\n\nIn order to read the individual keys in the matrix, you must first set\nPort A for all outputs (255, $FF), and Port B for all inputs (0),\nusing the Data Direction Registers.  Note that this is the default\ncondition.  Next, you must write a 0 in the bit of Data Port A that\ncorresponds to the column that you wish to read, and a 1 to the bits\nthat correspond to columns you wish to ignore.  You will then be able\nto read Data Port B to see which keys in that column are being pushed.\n\nA 0 in any bit position signifies that the key in the corresponding\nrow of the selected column is being pressed, while a 1 indicates that\nthe key is not being pressed.  A value of 255 ($FF) means that no keys\nin that column are being pressed.\n\nFortunately for us all, an interrupt routine causes the keyboard to be\nread, and the results are made available to the Operating System\nautomatically every 1/60 second.  And even when the normal interrupt\nroutine cannot be used, you can use the Kernal SCNKEY routine at 65439\n($FF9F) to read the keyboard.\n\nThese same data ports are also used to read the joystick controllers.\nAlthough common sense might lead you to believe that you could read\nthe joystick that is plugged into the port marked Controller Port 1\nfrom Data Port A, and the second joystick from Data Port B, there is\nnothing common about the Commodore 64.  Controller Port 1 is read from\nData Port B, and Controller Port 2 is read from CIA #1 Data Port A.\n\nJoysticks consist of five switches, one each for up, down, right, and\nleft directions, and another for the fire button.  The switches are\nread like the key switches--if the switch is pressed, the\ncorresponding bit will read 0, and if it is not pressed, the bit will\nbe set to 1.  From BASIC, you can PEEK the ports and use the AND and\nNOT operators to mask the unused bits and inverse the logic for easier\ncomprehension.  For example, to read the joystick in Controller Port\n1, you could use the statement:\n\nS1=NOT PEEK(56321)AND15\n\nThe meaning of the possible numbers returned are:\n\n 0 = none pressed\n 1 = up\n 2 = down\n 4 = left\n 5 = up left\n 6 = down left\n 8 = right\n 9 = up right\n10 = down right\n\nThe same technique can be used for joystick 2, by substituting 56320\nas the number to PEEK.  By the way, the 3 and 7 aren't listed because\nthey represent impossible combinations like up-down.\n\nTo read the fire buttons, you can PEEK the appropriate port and use\nthe AND operator to mask all but bit 4:\n\nT1=(PEEK(56321)AND16)/16\n\nThe above will return a 0 if the button is pressed, and a 1 if it is\nnot.  Substitute location 56320 as the location to PEEK for Trigger\nButton 2.\n\nSince CIA #1 Data Port B is used for reading the keyboard as well as\njoystick 1, some confusion can result.  The routine that checks the\nkeyboard has no way of telling whether a particular bit was set to 0\nby a keypress or one of the joystick switches.  For example, if you\nplug the joystick into Controller Port 1 and push the stick to the\nright, the routine will interpret this as the 2 key being pressed,\nbecause both set the same bit to 0.  Likewise, when you read the\njoystick, it will register as being pushed to the right if the 2 key\nis being pressed.\n\nThe problem of mistaking the keyboard for the joystick can be solved\nby turning off the keyscan momentarily when reading the stick with a\nPOKE 56333, 127:POKE 56320,255, and restoring it after the read with a\nPOKE 56333,129.  Sometimes you can use the simpler solution of\nclearing the keyboard buffer after reading the joystick, with a POKE\n198,0.\n\nThe problem of mistaking the joystick for a keypress is much more\ndifficult--there is no real way to turn off the joystick.  Many\ncommercially available games just use Controller Port 2 to avoid the\nconflict.  So, if you can't beat them, sit back and press your\njoystick to the left in order to slow down a program listing (the\nkeyscan routine thinks that it is the CTRL key).\n\nAs if all of the above were not enough, Port A is also used to control\nwhich set of paddles is read by the SID chip, and to read the paddle\nfire buttons.  Since there are two paddles per joystick Controller\nPort, and only two SID registers for reading paddle positions, there\nhas to be a method for switching the paddle read from joystick Port 1\nto joystick Port 2.\n\nWhen Bit 7 of Port A is set to 1 and Bit 6 is cleared to 0, the SID\nregisters will read the paddles on Port 1.  When Bit 7 is set to 0 and\nBit 6 is set to 1, the paddles on Port 2 are read by the SID chip\nregisters.  Note that this also conflicts with the keyscan routine,\nwhich is constantly writing different values to CIA #1 Data Port A in\norder to select the keyboard column to read (most of the time, the\nvalue for the last column is written to this port, which coincides\nwith the selection of paddles on joystick Port 1).  Therefore, in\norder to get an accurate reading, you must turn off the keyscan IRQ\nand select which joystick port you want to read.  See POTX at 54297\n($D419), which is the SID register where the paddles are read, for the\nexact technique.\n\nAlthough the SID chip is used to read the paddle settings, the fire\nbuttons are read at CIA #1 Data Ports A and B.  The fire buttons for\nthe paddles plugged into Controller Port 1 are read at Data Port B\n(56321, $DC01), while those for the paddles plugged into Controller\nPort 2 are read from Data Port A (56320, $DC00).  The fire buttons are\nread at Bit 2 and Bit 3 of each port (the same as the joystick left\nand joystick right switches), and as usual, the bit will read 0 if the\ncorresponding button is pushed, and 1 if it is not.\n\nAlthough only two of the rout paddle values can be read at any one\ntime, you can always read all four paddle buttons.  See the game\npaddle input description at 54297 ($D419) for the BASIC statements\nused to read these buttons.\n\nFinally, Data Port B can also be used as an output by either Timer A\nor B.  It is possible to set a mode in which the timers do not cause\nan interrupt when they run down (see the descriptions of Control\nRegisters A and B at 56334-5 ($DC0E-F)).  Instead, they cause the\noutput on Bit 6 or 7 of Data Port B to change.  Timer A can be set\neither to pulse the output of Bit 6 for one machine cycle, or to\ntoggle that bit from 1 to 0 or 0 to 1.  Timer B can use Bit 7 of this\nregister for the same purpose."
  },
  {
    "id": "map-DC00",
    "address_start": 56320,
    "address_end": 56320,
    "hex_start": "$DC00",
    "hex_end": "$DC00",
    "label": "CIAPRA",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56320         $DC00          CIAPRA\nData Port Register A\n\nBit 0:  Select to read keyboard column 0\n        Read joystick 2 up direction\nBit 1:  Select to read keyboard column 1\n        Read joystick 2 down direction\nBit 2:  Select to read keyboard column 2\n        Read joystick 2 left direction\n        Read paddle 1 fire button\nBit 3:  Select to read keyboard column 3\n        Read joystick 2 right direction\n        Read paddle 2 fire button\nBit 4:  Select to read keyboard column 4\n        Read joystick 2 fire button\nBit 5:  Select to read keyboard column 5\nBit 6:  Select to read keyboard column 6\n        Select to read paddles on Port A or B\nBit 7:  Select to read keyboard column 7\n        Select to read paddles on Port A or B"
  },
  {
    "id": "map-DC01",
    "address_start": 56321,
    "address_end": 56321,
    "hex_start": "$DC01",
    "hex_end": "$DC01",
    "label": "CIAPRB",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56321         $DC01          CIAPRB\nData Port Register B\n\nBit 0:  Read keyboard row 0\n        Read joystick 1 up direction\nBit 1:  Read keyboard row 1\n        Read joystick 1 down direction\nBit 2:  Read keyboard row 2\n        Read joystick 1 left direction\n        Read paddle 1 fire button\nBit 3:  Read keyboard row 3\n        Read joystick 1 right direction\n        Read paddle 2 fire button\nBit 4:  Read keyboard row 4\n        Read joystick 1 fire button\nBit 5:  Read keyboard row 5\nBit 6:  Read keyboard row 6\n        Toggle or pulse data output for Timer A\nBit 7:  Read keyboard row 7\n        Toggle or pulse data output for Timer B"
  },
  {
    "id": "map-DC02-DC03",
    "address_start": 56322,
    "address_end": 56323,
    "hex_start": "$DC02",
    "hex_end": "$DC03",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56322-56323 ($DC02-$DC03)\nCIA #1 Data Direction Registers A and B\n\nThese Data Direction Registers control the direction of data flow over\nData Ports A and B.  Each bit controls the direction of the data on\nthe corresponding bit of the port.  If teh bit of the Direction\nRegister is set to a 1, the corresponding Data Port bit will be used\nfor data output.  If the bit is set to a 0, the corresponding Data\nPort bit will be used for data input.  For example, Bit 7 of Data\nDirection Register A controls Bit 7 of Data Port A, and if that\ndirection bit is set to 0, Bit 7 of Data Port A will be used for data\ninput.  If the direction bit is set to 1, however, data Bit 7 on Port\nA will be used for data output.\n\nThe default setting for Data Direction Register A is 255 (all\noutputs), and for Data Direction Register B it is 0 (all inputs).\nThis corresponds to the setting used when reading the keyboard (the\nkeyboard column number is written to Data Port A, and the row number\nis then read in Data Port B)."
  },
  {
    "id": "map-DC02",
    "address_start": 56322,
    "address_end": 56322,
    "hex_start": "$DC02",
    "hex_end": "$DC02",
    "label": "CIDDRA",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56322         $DC02          CIDDRA\nData Direction Register A\n\nBit 0:  Select Bit 0 of Data Port A for input or output (0=input, 1=output)\nBit 1:  Select Bit 1 of Data Port A for input or output (0=input, 1=output)\nBit 2:  Select Bit 2 of Data Port A for input or output (0=input, 1=output)\nBit 3:  Select Bit 3 of Data Port A for input or output (0=input, 1=output)\nBit 4:  Select Bit 4 of Data Port A for input or output (0=input, 1=output)\nBit 5:  Select Bit 5 of Data Port A for input or output (0=input, 1=output)\nBit 6:  Select Bit 6 of Data Port A for input or output (0=input, 1=output)\nBit 7:  Select Bit 7 of Data Port A for input or output (0=input, 1=output)"
  },
  {
    "id": "map-DC03",
    "address_start": 56323,
    "address_end": 56323,
    "hex_start": "$DC03",
    "hex_end": "$DC03",
    "label": "CIDDRB",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56323         $DC03          CIDDRB\nData Direction Register B\n\nBit 0:  Select Bit 0 of Data Port B for input or output (0=input, 1=output)\nBit 1:  Select Bit 1 of Data Port B for input or output (0=input, 1=output)\nBit 2:  Select Bit 2 of Data Port B for input or output (0=input, 1=output)\nBit 3:  Select Bit 3 of Data Port B for input or output (0=input, 1=output)\nBit 4:  Select Bit 4 of Data Port B for input or output (0=input, 1=output)\nBit 5:  Select Bit 5 of Data Port B for input or output (0=input, 1=output)\nBit 6:  Select Bit 6 of Data Port B for input or output (0=input, 1=output)\nBit 7:  Select Bit 7 of Data Port B for input or output (0=input, 1=output)"
  },
  {
    "id": "map-DC04-DC07",
    "address_start": 56324,
    "address_end": 56327,
    "hex_start": "$DC04",
    "hex_end": "$DC07",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56324-56327 ($DC04-$DC07)\nTimers A and B Low and High Bytes\n\nThese four timer registers (two for each timer) have different\nfunctions depending on whether you are reading from them or writing to\nthem.  When you read from these registers, you get the present value\nof the Timer Counter (which counts down from its initial value to 0).\nWhen you write data to these registers, it is stored in the Timer\nLatch, and from there it can be used to load the Timer Counter using\nthe Force Load bit of Control Register A or B (see 56334-5 ($DC0E-F)\nbelow).\n\nThese interval timers can hold a 16-bit number from 0 to 65535, in\nnormal 6510 low-byte, high-byte format (VALUE=LOW BYTE+256*HIGH BYTE).\nOnce the Timer Counter is set to an initial value, and the timer is\nstarted, the timer will count down one number every microprocessor\nclock cycle.  Since the clock speed of the 64 (using the American NTSC\ntelevision standard) is 1,022,730 cycles per second, every count takes\napproximately a millionth of a second.  The formula for calculating\nthe amount of time it will take for the timer to count down from its\nlatch value to 0 is:\n\nTIME=LATCH VALUE/CLOCK SPEED\n\nwhere LATCH VALUE is the value written to the low and high timer\nregisters (LATCH VALUE=TIMER LOW+256*TIMER HIGH), and CLOCK SPEED is\n1,022,370 cycles per second for American (NTSC) standard television\nmonitors, or 985,250 for European (PAL) monitors.\n\nWhen Timer Counter A or B gets to 0, it will set Bit 0 or 1 in the\nInterrupt Control Register at 56333 ($DC0D).  If the timer interrupt\nhas been enabled (see 56333 ($DC0D)), an IRQ will take place, and the\nhigh bit of the Interrupt Control Register will be set to 1.\nAlternately, if the Port B output bit is set, the timer will write\ndata to Bit 6 or 7 of Port B.  After the timer gets to 0, it will\nreload the Timer Latch Value, and either stop or count down again,\ndepending on whether it is in one-shot or continuous mode (determined\nby Bit 3 of the Control Register).\n\nAlthough usually a timer will be used to count the microprocessor\ncycles, Timer A can count either the microprocessor clock cycles or\nexternal pulses on the CTN line, which is connected to pin 4 of the\nUser Port.\n\nTimer B is even more versatile.  In addition to these two sources,\nTimer B can count the number of times that Timer A goes to 0.  By\nsetting Timer A to count the microprocessor clock, and setting Timer B\nto count the number of times that Timer A zeros, you effectively link\nthe two timers into one 32-bit timer that can count up to 70 minutes\nwith accuracy within 1/15 second.\n\nIn the 64, CIA #1 Timer A is used to generate the interrupt which\ndrives the routine for reading the keyboard and updating the software\nclock.  Both Timers A and B are also used for the timing of the\nroutines that read and write tape data.  Normally, Timer A is set for\ncontinuous operation, and latched with a value of 149 in the low byte\nand 66 in the high byte, for a total Latch Value of 17045.  This means\nthat it is set to count to 0 every 17045/1022730 seconds, or\napproximately 1/60 second.\n\nFor tape reads and writes, the tape routines take over the IRQ\nvectors.  Even though the tape write routines use the on-chip I/O port\nat location 1 for the actual data output to the cassette, reading and\nwriting to the cassette uses both CIA #1 Timer A and Timer B for\ntiming the I/O routines."
  },
  {
    "id": "map-DC04",
    "address_start": 56324,
    "address_end": 56324,
    "hex_start": "$DC04",
    "hex_end": "$DC04",
    "label": "TIMALO",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56324         $DC04          TIMALO\nTimer A (low byte)"
  },
  {
    "id": "map-DC05",
    "address_start": 56325,
    "address_end": 56325,
    "hex_start": "$DC05",
    "hex_end": "$DC05",
    "label": "TIMAHI",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56325         $DC05          TIMAHI\nTimer A (high byte)"
  },
  {
    "id": "map-DC06",
    "address_start": 56326,
    "address_end": 56326,
    "hex_start": "$DC06",
    "hex_end": "$DC06",
    "label": "TIMBLO",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56326         $DC06          TIMBLO\nTimer B (low byte)"
  },
  {
    "id": "map-DC07",
    "address_start": 56327,
    "address_end": 56327,
    "hex_start": "$DC07",
    "hex_end": "$DC07",
    "label": "TIMBHI",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56327         $DC07          TIMBHI\nTimer B (high byte)"
  },
  {
    "id": "map-DC08-DC0B",
    "address_start": 56328,
    "address_end": 56331,
    "hex_start": "$DC08",
    "hex_end": "$DC0B",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56328-56331 ($DC08-$DC0B)\nTime of Day Clock (TOD)\n\nIn addition to the two general-purpose timers, the 6526 CIA chip has a\nspecial-purpose Time of Day Clock, which keeps time in a format that\nhumans can understand a little more easily than microseconds.\n\nThis Time of Day Clock even has an alarm, which can cause an interrupt\nat a specific time.  It is organized in four registers, one each for\nhours, minutes, seconds, and tenths of seconds.  Each register reads\nout in Binary Coded Decimal (BCD) format, for easier conversion to\nASCII digits.  A BCD byte is divided into two nybbles, each of which\nrepresents a single digit in base 10.  Even though a four-bit nybble\ncan hold a number from 0 to 15, only the base 10 digits of 0-9 are\nused.  Therefore, 10 0'clock would be represented by a byte in the\nhours register with the nybbles 0001 and 0000, which stand for the\ndigits 1 and 0.  The binary value of this byte would be 16 (16 times\nthe high nybble plus the low nybble).  Each of the other registers\noperates in the same manner.  In addition, Bit 7 of the hours register\nis used as an AM/PM flag.  If that bit is set to 1, it indicates PM,\nand if it is set to 0, the time is AM.\n\nThe Time of Day Clock Registers can be used for two purposes,\ndepending on whether you are reading them or writing to them.  If you\nare reading them, you will always be reading the time.  There is a\nlatching feature associated with reading the hours register in order\nto solve the problem of the time changing while you are reading the\nregisters.  For example, if you were reading the hours register just\nas the time was changing from 10:59 to 11:00, it is possible that you\nwould read the 10 in the hours register, and by the time you read the\nminutes register it would have changed from 59 to 00.  Therefore, you\nwould read 10:00 instead of either 10:59 or 11:00.\n\nTo prevent this kind of mistake, the Time of Day Clock Registers stop\nupdating as soon as you read the hours register, and do not start\nagain until you read the tenths of seconds register.  Of course, the\nclock continues to keep time internally even though it does not update\nthe registers.  If you want to read only minutes, or seconds or tenths\nof seconds, there is no problem, and no latching will occur.  But\nanytime you read hours, you must follow it by reading tenths of\nseconds, even if you don't care about them, or else the registers will\nnot continue to update.\n\nWriting to these registers either sets the time or the alarm,\ndepending on the setting of Bit 7 of Control Register B (56335,\n$DC0F).  If that bit is set to 1, writing to the Time of Day registers\nsets the alarm.  If the bit is set to 0, writing to the Time of Day\nregisters sets the Time of Day clock.  In either case, as with reading\nthe registers, there is a latch function.  This function stops the\nclock from updating when you write to the hours register.  The clock\nwill not start again until you write to the tenths of seconds\nregisters.\n\nThe only apparent use of the Time of Day Clock by the 64's Operating\nSystem is in the BASIC RND statement.  There, the seconds and tenths\nof seconds registers are read and their values used as part of the\nseed value for the RND(0) command.\n\nNonetheless, this clock can be an invaluable resource for the 64 user.\nIt will keep time more accurately than the software clock maintained\nat locations 60-162 ($A0-$A2) by the Timer A interrupt routine.  And\nunlike that software clock, the Time of Day Clock will not be\ndisturbed when I/O operations disrupt the Timer A IRQ, or when the IRQ\nvector is diverted elsewhere.  Not even a cold start RESET will\ndisrupt the time.  For game timers, just set the time for 00:00:00:0\nand it will keep track of elapsed time in hours, minutes, seconds and\ntenths of seconds format.\n\nThe following digital clock program, written in BASIC, will\ndemonstrate the use of these timers:\n\n10 PRINT CHR$(147):GOSUB 200\n20 H=PEEK(56331):POKE 1238,(H AND 16)/16+48:POKE 1239,(H AND 15)+48\n30 M=PEEK(56330):POKE 1241,(M AND 240)/16+48:POKE 1242,(M AND 15)+48\n40 S=PEEK(56329):POKE 1244,(S AND 240)/16+48:POKE 1245,(S AND 15)+48\n50 T=PEEK(56328)AND15:POKE 1247,T+48:GOTO 20\n200 INPUT\"WHAT IS THE HOUR\";H$:IF H$=\"\" THEN 200\n210 H=0:IF LEN(H$)>1 THEN H=16\n220 HH=VAL(RIGHT$(H$,1)):H=H+HH:POKE56331,H\n230 INPUT \"WHAT IS THE MINUTE\";M$:IF M$=\"\"THEN 200\n240 M=0:IF LEN(M$)>1 THEN M=16*VAL(LEFT$(M$,1))\n250 MM=VAL(RIGHT$(M$,1)):M=M+MM:POKE56330,M\n260 INPUT \"WHAT IS THE SECOND\";S$:IF S$=\"\"THEN 200\n270 S=0:IF LEN(S$)>1 THEN S=16*VAL(LEFT$(S$,1))\n280 SS=VAL(RIGHT$(S$,1)):S=S+SS:POKE56329,S:POKE56328,0\n290 POKE 53281,1:PRINT CHR$(147):POKE 53281,6\n300 POKE 1240,58:POKE 1243,58:POKE 1246,58:GOTO 20"
  },
  {
    "id": "map-DC08",
    "address_start": 56328,
    "address_end": 56328,
    "hex_start": "$DC08",
    "hex_end": "$DC08",
    "label": "TODTEN",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56328         $DC08          TODTEN\nTime of Day Clock Tenths of Seconds\n\nBits 0-3:  Time of Day tenths of second digit (BCD)\nBits 4-7:  Unused"
  },
  {
    "id": "map-DC09",
    "address_start": 56329,
    "address_end": 56329,
    "hex_start": "$DC09",
    "hex_end": "$DC09",
    "label": "TODSEC",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56329         $DC09          TODSEC\nTime of Day Clock Seconds\n\nBits 0-3:  Second digit of Time of Day seconds (BCD)\nBits 4-6:  First digit of Time of Day seconds (BCD)\nBit 7:  Unused"
  },
  {
    "id": "map-DC0A",
    "address_start": 56330,
    "address_end": 56330,
    "hex_start": "$DC0A",
    "hex_end": "$DC0A",
    "label": "TODMIN",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56330         $DC0A          TODMIN\nTime of Day Clock Minutes\n\nBits 0-3:  Second digit of Time of Day minutes (BCD)\nBits 4-6:  First digit of Time of Day minutes (BCD)\nBit 7:  Unused"
  },
  {
    "id": "map-DC0B",
    "address_start": 56331,
    "address_end": 56331,
    "hex_start": "$DC0B",
    "hex_end": "$DC0B",
    "label": "TODHRS",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56331         $DC0B          TODHRS\nTime of Day Clock Hours\n\nBits 0-3:  Second digit of Time of Day hours (BCD)\nBit 4:  First digit of Time of Day hours (BCD)\nBits 5-6:  Unused\nBit 7:  AM/PM Flag (1=PM, 0=AM)"
  },
  {
    "id": "map-DC0C",
    "address_start": 56332,
    "address_end": 56332,
    "hex_start": "$DC0C",
    "hex_end": "$DC0C",
    "label": "CIASDR",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56332         $DC0C          CIASDR\nSerial Data Port\n\nThe CIA chip has an on-chip serial port, which allows you to send or\nreceive a byte of data one bit at a time, with the most significant\nbit (Bit 7) being transferred first.  Control Register A at 56334\n($DC0E) allows you to choose input or output modes.  In input mode, a\nbit of data is read from the SP line (pin 5 of the User Port) whenever\na signal on the CNT line (pin 4) appears to let you know that it is\ntime for a read.  After eight bits are received this way, the data is\nplaced in the Serial Port Register, and an interrupt is generated to\nlet you know that the register should be read.\n\nIn output mode, you write data to the Serial Port Register, and it is\nsent out over the SP line (pin 5 of the User Port), using Timer A for\nthe baud rate generator.  Whenever a byte of data is written to this\nregister, transmission will start as long as Timer A is running and in\ncontinuous mode.  Data is sent at half the Timer A rage, and an output\nwill appear on the CNT line (pin 4 of the User Port) whenever a bit is\nsent.  After all eight bits have been sent, an interrupt is generated\nto indicate that it is time to load the next byte to send into the\nSerial Register.\n\nThe Serial Data Register is not used by the 64, which does all of its\nserial I/O through the regular data ports."
  },
  {
    "id": "map-DC0D",
    "address_start": 56333,
    "address_end": 56333,
    "hex_start": "$DC0D",
    "hex_end": "$DC0D",
    "label": "CIAICR",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56333         $DC0D          CIAICR\nInterrupt Control Register\n\nBit 0:  Read / did Timer A count down to 0?  (1=yes)\n        Write/ enable or disable Timer A interrupt (1=enable, 0=disable)\nBit 1:  Read / did Timer B count down to 0?  (1=yes)\n        Write/ enable or disable Timer B interrupt (1=enable, 0=disable)\nBit 2:  Read / did Time of Day Clock reach the alarm time?  (1=yes)\n        Write/ enable or disable TOD clock alarm interrupt (1=enable,\n        0=disable)\nBit 3:  Read / did the serial shift register finish a byte? (1=yes)\n        Write/ enable or disable serial shift register interrupt (1=enable,\n        0=disable)\nBit 4:  Read / was a signal sent on the flag line?  (1=yes)\n        Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)\nBit 5:  Not used\nBit 6:  Not used\nBit 7:  Read / did any CIA #1 source cause an interrupt?  (1=yes)\n        Write/ set or clear bits of this register (1=bits written with 1 will\n        be set, 0=bits written with 1 will be cleared)\n\nThis register is used to control the five interrupt sources on the\n6526 CIA chip.  These sources are Timer A, Timer B, the Time of Day\nClock, the Serial Register, and the FLAG line.  Timers A and B cause\nan interrupt when they count down to 0.  The Time of Day Clock\ngenerates an interrupt when it reaches the ALARM time.  The Serial\nShift Register interrupts when it compiles eight bits of input or\noutput.  An external signal pulling the CIA hardware line called FLAG\nlow will also cause an interrupt (on CIA #1, this FLAG line is\nconnected to the Cassette Read line of the Cassette Port).\n\nEven if the condition for a particular interrupt is satisfied, the\ninterrupt must still be enabled for an IRQ actually to occur.  This is\ndone by writing to the Interrupt Control Register.  What happens when\nyou write to this register depends on the way that you set Bit 7.  If\nyou set it to 0, any other bit that was written to with a 1 will be\ncleared, and the corresponding interrupt will be disabled.  If you set\nBit 7 to 1, any bit written to with a 1 will be set, and the\ncorresponding interrupt will be enabled.  In either case, the\ninterrupt enable flags for those bits written to with a 0 will not be\naffected.\n\nFor example, in order to disable all interrupts from BASIC, you could\nPOKE 56333, 127.  This sets Bit 7 to 0, which clears all of the other\nbits, since they are all written with 1's.  Don't try this from BASIC\nimmediate mode, as it will turn off Timer A which causes the IRQ for\nreading the keyboard, so that it will in effect turn off the keyboard.\n\nTo turn on the Timer A interrupt, a program could POKE 56333,129.  Bit\n7 is set to 1 and so is Bit 0, so the interrupt which corresponds to\nBit 0 (Timer A) is enabled.\n\nWhen you read this register, you can tell if any of the conditions for\na CIA Interrupt were satisfied because the corresponding bit will be\nset to a 1.  For example, if Timer A counts down to 0, Bit 0 of this\nregister will be set to 1.  If, in addition, the mask bit that\ncorresponds to that interrupt source is set to 1, and an interrupt\noccurs, Bit 7 will also be set.  This allows a multi-interrupt system\nto read one bit and see if the source of a particular interrupt was\nCIA #1.  You should note, however, that reading this register clears\nit, so you should preserve its contents in RAM if you want to test\nmore than one bit."
  },
  {
    "id": "map-DC0E",
    "address_start": 56334,
    "address_end": 56334,
    "hex_start": "$DC0E",
    "hex_end": "$DC0E",
    "label": "CIACRA",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56334         $DC0E          CIACRA\nControl Register A\n\nBit 0:  Start Timer A (1=start, 0=stop)\nBit 1:  Select Timer A output on Port B (1=Timer A output appears on Bit 6 of\n        Port B)\nBit 2:  Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one cycle)\nBit 3:  Timer A run mode (1=one-shot, 0=continuous)\nBit 4:  Force latched value to be loaded to Timer A counter (1=force load\n        strobe)\nBit 5:  Timer A input mode (1=count microprocessor cycles, 0=count signals on\n        CNT line at pin 4 of User Port)\nBit 6:  Serial Port (56332, $DC0C) mode (1=output, 0=input)\nBit 7:  Time of Day Clock frequency (1=50 Hz required on TOD pin, 0=60 Hz)\n\nBits 0-3.  This nybble controls Timer A.  Bit 0 is set to 1 to start\nthe timer counting down, and set to 0 to stop it.  Bit 3 sets the\ntimer for one-shot or continuous mode.\n\nIn one-shot mode, the timer counts down to 0, sets the counter value\nback to the latch value, and then sets Bit 0 back to 0 to stop the\ntimer.  In continuous mode, it reloads the latch value and starts all\nover again.\n\nBits 1 and 2 allow you to send a signal on Bit 6 of Data Port B when\nthe timer counts.  Setting Bit 1 to 1 forces this output (which\noverrides the Data Direction Register B Bit 6, and the normal Data\nPort B value).  Bit 2 allows you to choose the form this output to Bit\n6 of Data Port B will take.  Setting Bit 2 to a value of 1 will cause\nBit 6 to toggle to the opposite value when the timer runs down (a\nvalue of 1 will change to 0, and a value of 0 will change to 1).\nSetting Bit 2 to a value of 0 will cause a single pulse of a one\nmachine-cycle duration (about a millionth of a second) to occur.\n\nBit 4.  This bit is used to load the Timer A counter with the value\nthat was previously written to the Timer Low and High Byte Registers.\nWriting a 1 to this bit will force the load (although there is no data\nstored here, and the bit has no significance on a read).\n\nBit 5.  Bit 5 is used to control just what it is Timer A is counting.\nIf this bit is set to 1, it counts the microprocessor machine cycles\n(which occur at the rate of 1,022,730 cycles per second).  If the bit\nis set to 0, the timer counts pulses on the CNT line, which is\nconnected to pin 4 of the User Port.  This allows you to use the CIA\nas a frequency counter or an event counter, or to measure pulse width\nor delay times of external signals.\n\nBit 6.  Whether the Serial Port Register is currently inputting or\noutputting data (see the entry for that register at 56332 ($DC0C) for\nmore information) is controlled by this bit.\n\nBit 7.  This bit allows you to select from software whether the Time\nof Day Clock will use a 50 Hz or 60 Hz signal on the TOD pin in order\nto keep accurate time (the 64 uses a 60 Hz signal on that pin)."
  },
  {
    "id": "map-DC0F",
    "address_start": 56335,
    "address_end": 56335,
    "hex_start": "$DC0F",
    "hex_end": "$DC0F",
    "label": "CIACRB",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56335         $DC0F          CIACRB\nControl Register B\n\nBit 0:  Start Timer B (1=start, 0=stop)\nBit 1:  Select Timer B output on Port B (1=Timer B output appears on\n        Bit 7 of Port B)\nBit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one\n        cycle)\nBit 3:  Timer B run mode (1=one-shot, 0=continuous)\nBit 4:  Force latched value to be loaded to Timer B counter (1=force\n        load strobe)\nBits 5-6:  Timer B input mode\n           00 = Timer B counts microprocessor cycles\n           01 = Count signals on CNT line at pin 4 of User Port\n           10 = Count each time that Timer A counts down to 0\n           11 = Count Timer A 0's when CNT pulses are also present\nBit 7:  Select Time of Day write (0=writing to TOD registers sets\n        alarm, 1=writing to TOD registers sets clock)\n\nBits 0-3.  This nybble performs the same functions for Timer B that\nBits 0-3 of Control Register A perform for Timer A, except that Timer\nB output on Data Port B appears at Bit 7, and not Bit 6.\n\nBits 5 and 6.  These two bits are used to select what Timer B counts.\nIf both bits are set to 0, Timer B counts the microprocessor machine\ncycles (which occur at the rate of 1,022,730 cycles per second).  If\nBit 6 is set to 0 and Bit 5 is set to 1, Timer B counts pulses on the\nCNT line, which is connected to pin 4 of the User Port.  If Bit 6 is\nset to 1 and Bit 5 is set to 0, Timer B counts Timer A underflow\npulses, which is to say that it counts the number of times that Timer\nA counts down to 0.  This is used to link the two numbers into one\n32-bit timer that can count up to 70 minutes with accuracy to within\n1/15 second.  Finally, if both bits are set to 1, Timer B counts the\nnumber of times that Timer A counts down to 0 and there is a signal on\nthe CNT line (pin 4 of the User Port).\n\nBit 7.  Bit 7 controls what happens when you write to the Time of Day\nregisters.  If this bit is set to 1, writing to the TOD registers sets\nthe ALARM time.  If this bit is cleared to 0, writing to the TOD\nregisters sets the TOD clock."
  },
  {
    "id": "map-DC10-DCFF",
    "address_start": 56336,
    "address_end": 56575,
    "hex_start": "$DC10",
    "hex_end": "$DCFF",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56336-56575 ($DC10-$DCFF)\nCIA #1 Register Images\n\nSince the CIA chip requires only enough addressing lines to handle 16\nregisters, none of the higher bits are decoded when addressing the\n256-byte area that has been assigned to it.  The result is that every\n16-byte area in this 256-byte block is a mirror of every other.  Even\nso, for the sake of clarity in your programs it is advisable to use\nthe base address of the chip, and not use the higher addresses to\ncommunicate with the chip."
  },
  {
    "id": "map-DD00-DD0F",
    "address_start": 56576,
    "address_end": 56591,
    "hex_start": "$DD00",
    "hex_end": "$DD0F",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56576-56591    $DD00-$DD0F\nComplex Interface Adapter (CIA) #2 Registers\n\nLocations 56576-56591 ($DD00-$DD0F) are used to address the Complex\nInterface Adapter chip #2 (CIA #2).  Since the chip itself is\nidentical to CIA #1, which is addressed at 56320 ($DC00), the\ndiscussion here will be limited to the use which the 64 makes of this\nparticular chip.  For more general information on the chip registers,\nplease see the corresponding entries for CIA #1.\n\nOne of the significant differences between CIA chips #1 and #1 is the\nuse to which Data Ports A and B are put.  The peripheral input and\noutput devices that CIA #2 controls are those on the Serial Bus (such\nas the 1541 Disk Drive and 1525 printer), the RS-232 device (which is\nused for telecommunications), and the User Port, an eight-bit parallel\nport that can be turned to whatever purpose the user desires.  In\naddition, Data Port A has the important task of selecting the 16K bank\nofmemory that will be used by the VIC-II chip for graphics.\n\nAnother significant difference between CIA chips #1 and #2 is that the\ninterrupt line of CIA #1 is wired to the 6510 IRQ line, while that of\nCIA #2 is wired to the NMI line.  This means that interrupts from this\nchip cannot be masked by setting the Interrupt disable flag (SEI).\nThey can be disabled from CIA's Mask Register, though.  Be sure to use\nthe NMI vector when setting up routines to be driven by interrupts\ngenerated by this chip."
  },
  {
    "id": "map-DD00-DD01",
    "address_start": 56576,
    "address_end": 56577,
    "hex_start": "$DD00",
    "hex_end": "$DD01",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56576-56577 ($DD00-$DD01)\nCIA #2 Data Ports A and B\n\nThese registers are where the communication with the Serial Bus,\nRS-232 device, and User Port take place.  The Serial Bus is like the\nIEEE bus which is used by the PET, in that it allows more than one\ndevice to be connected to the port at a time, in a daisychain\narrangement.  Since each byte of data is sent one bit at a time,\nhowever, the Serial Bus is at least eight times slower than the IEEE.\nIt is presently used to control the 1541 Disk Drive and 1525 printer,\nand other devices (such as printer interface for Centronics- type\nparallel pritners and stringy floppy wafer tape storage units) can be\nplaced on this bus.\n\nData Port A is used for communication with the Serial Bus.  Bits 5 and\n7 are used for Serial Bus Data Output and Input, respectively, and\nBits 4 and 6 are used for the Serial Bus Clock Pulse Output and Input.\nBit 3 of Data Port A is used to send the ATN signal on the Serial Bus.\n\nThe 64 has built-in software to handle RS-232 communications through a\nmodem or other device plugged in the RS-232/User Port.  The RS-232\ndevice uses Bit 2 of Data Port A for data output (it is the only line\nfrom Port A that is connected to the RS-232/User Port jack).  It also\nmakes heavy use of Port B, using Bit 7 for the Data Set Ready (DSR)\nsignal, Bit 6 for the Clear to Send (CTS), Bit 4 for the Carrier\nDetect (DCD), Bit 3 for the Ring Indicator (RI), Bit 2 for Data\nTerminal Ready (DTR), Bit 1 for Request to Send (RTS), and Bit 0 for\ndata input.  See locations 659-660 ($293-$294) for more details on the\nRS-232 device.\n\nAll of the data lines which the RS-232 device uses are also available\nto the user as part of the User Port.  All of the Port B data lines,\nand Bit 2 of Port A, are brought out to the User Port connector on the\nback of the 64.  These data bits are utilized in the normal way:  The\nport connections are made to TTL-level input or output devices, and\nthe direction of data is determined by the Data Direction Registers.\n\nIn addition, the User Port has pins connected to the two CIA Serial\nPorts (whose eight-bit shift registers are well-suited for\nserial-to-parallel and parallel-to-serial conversion),and the two CNT\nlines which aid in the operation of the Serial Ports.  The CNT lines\ncan also be used in conjunction with the CIA Timers, and allow them to\nbe used as frequency counters, event counters, interval timers, etc.\nThe advanced features of the CIA chip make almost any type of\ninterfacing application possible, and in the near future we will\nprobably see many interesting applications for the User Port on the\n64.  A pin description of tthe User Port connector is provided below:\n\nUser         RS-232\nPort  CIA    DB-25\nPin   Line   Pin     Description\n\n1                    Ground\n2                    +5 Volts (100 milliamps maximum)\n3                    RESET (grounding this pin causes a cold start)\n4     CNT1           CIA #1 Serial Port and Timer Counter\n5     SP1            CIA #1 Serial Data Port\n6     CNT2           CIA #2 Serial Port and Timer Counter\n7     SP2            CIA #2 Serial Data Port\n8     PC2            CIA #2 handshaking line\n9                    Connected to the ATN line of the Serial Bus\n10                   9 Volts AC (+ phase, 50 milliamps maximum)\n11                   9 volts AC (- phase, 50 milliamps maximum)\n12                   Ground\nA            1       Ground\nB     FLAG2          CIA #2 handshaking line\nC     PB0    3       Port B Bit 0--RS-232 Received Data (SIN)\nD     PB1    4       Port B Bit 1--RS-232 Request to Send (RTS)\nE     PB2    20      Port B Bit 2--RS-232 Data Terminal Ready (DTR)\nF     PB3    22      Port B Bit 3--RS-232 Ring Indicator (RI)\nH     PB4    8       Port B Bit 4--RS-232 Carrier Detect (DCD)\nJ     PB5            Port B Bit 5\nK     PB6    5       Port B Bit 6--RS-232 Clear to Send (CTS)\nL     PB7    6       Port B Bit 7--RS-232 Data Set Ready (DSR)\nM     PA2    2       Port A Bit 2--RS-232 Transmitted Data (Sout)\nN            7       Ground\n\nOne of the handshaking lines on the above chart, PC2, was not covered\nin the discussion of CIA #1, because that line of CIA #1 is not\nconnected to anything.  The CIA #2 PC line is accessible from the User\nPort, however.  This line will go low for one cycle following a read\nor write of Port B on CIA #2.  This signal lets external devices know\nwhen data has been read or written.\n\nBits 0 and 1 of CIA #2 Port A have an extremely important function.\nAs mentioned in the section on the VIC-II chip (53248, $D000), the\nvideo chip can address only 16K of memory at a time, and all graphics\ndata must be stored in that 16K block in order to be displayed.\nWithin this area, sprite graphics data may be placed in any of 256\ngroups of 64 bytes each.  Character data can be stored in any of eight\n2K blocks.  Text screen memory may be in any of 16 1K areas, and\nbitmap screen memory may be in either of two 8K sections.\n\nWhen you turn the power on, the VIC-II uses the bottom 16K of memory\nfor graphics.  Unfortunately, this block of memory is also used\nextensively for other important purposes.  Though some means of\neliminating these conflicts are discussed above, in many situations\nyou will want to change from the default 16K bank at the low end of\nmemory.\n\nBits 0 and 1 select the current 16K bank for video memory from the\nfour possible choices using the following bit patterns:\n\n00 (bit value of 0) Bank 3 (49152-65535, $C000-$FFFF)\n01 (bit value of 1) Bank 2 (32768-49151, $8000-$BFFF)\n10 (bit value of 2) Bank 1 (16384-32767, $4000-$7FFF)\n11 (bit value of 3) Bank 0 (0-16383, $0-$3FFF)\n\nThe technique for making this change from BASIC is discussed below.\nBut before we go ahead and start changing banks, let's briefly review\nthe contents of these areas, and the considerations for using them for\ngraphics.\n\nBlock 0.  This is normally used for system variables and BASIC program\ntext.  Locations 1024-2047 ($400-$7FF) are reserved for the default\nposition of screen memory.\n\nThere is an addition limitation on memory usage of this block, as the\nVIC-II sees the character generator ROM at 4096-8191 ($1000-$1FFF),\nmaking this portion of memory unavailable for other graphics data.\nGenerally, there is little free space here for graphics display data.\nLocations 679-767 ($2A7- $2FF) are unused, and could hold one sprite\nshape (number 11) or data for 11 characters.  The area from 820-1023\n($334-$3FF), which includes the cassette I/O buffer, is available for\ngraphics memory, and is large enough to hold three sprite shapes\n(numbers 13, 14, and 15), or data for 25 characters (numbers 103-127).\nBut getting enough memory for bitmap graphics requires that you either\nreserve memory after the end of BASIC text by lowering the end of\nBASIC pointer at 56 ($38), or raise the start of BASIC pointer at 44\n($2C).  See the entries for these pointers for more details.\n\nBlock 1.  Block 1 is normally used for BASIC program storage.  When\nusing this bank, the VIC-II does not have access to the character\ngenerator ROM.  Providing that you lower the top of memory so that\nBASIC programs do not interfere, this area is wide open for sprite\nshapes, character graphics, and bitmap graphics.\n\nThe drawbacks to useing this bank are the unavailability of the\ncharacter ROM and the limitation on BASIC program space (as little as\n14K).  The absence of the character ROM is a relatively minor\nnuisance, because you can always switch in the ROM and copy any or all\nof the characters to RAM (see the entries for location 1 and the\nalternate entry for 53248 ($D000), the Character ROM, for details).\nThis block may be a good alternate choice to avoid potential conflicts\nwith other applications that use higher memory.\n\nBlock 2.  The third block (Block 2) consists of 8K of RAM, half of\nwhich is seen by the VIC-II chip as character ROM, and the 8K BASIC\ninterpreter ROM.  The BASIC ROM area is available for graphics.  This\nis possible because of the 64's special addressing.  The VIC-II chip\nreads only from RAM, and thus sees the RAM underneath the BASIC ROM,\neven if the 6510 has ROM switched in.  The 6510, on the other hand,\nalways writes to RAM, even when dealing with memory it reads as ROM.\nWhatever is written to the RAM underlying the BASIC ROM is displayed\nnormally by the VIC-II chip.  This opens up an extra 8K are for\nsprites and character data under the BASIC ROM.\n\nYou should keep in mind that while you can write to this area, you\ncannot read it from BASIC.  This may not be a serious problem when it\ncomes to character sets and sprite data, but it's more of a drawback\nif you want to use this RAM for screen memory.\n\nFor example, the Operating System has to read the text screen to move\nthe cursor properly, and if it reads the ROM value instead of the RAM\nscreen data, it gets hopelessly confused, making it impossible to type\nin any commands.\n\nLikewise, you would not be able to read the high-resolution screen if\nit were placed here, without some machine language trickery.  With\nlocations 36863-40959 ousted by the character ROM, only 4K of true RAM\nremains for use as screen memory, not enough for a complete\nhigh-resolution screen.  Therefore, this block is not recommended for\nuse in bitmap mode if your program needs to check the screen.\nOtherwise, this is a good place for graphics memory, particularly if\nyou need to emulate the screen configuration of the PET.\n\nBlock 3.  Normally Block 3 contains 4K of RAM that is completely\nunused by the system, 4K if I/O registers, and the 8K Operating System\nKernal ROM.  It is very convenient to use when you need a lot of\nmemory space for both graphics and a BASIC program.  Although the\ncharacter ROM is not available, it can be copied to RAM.  The area\nunder the Kernal ROM can be used as explained above.  One possible\nconflict that you should be aware of is that the current version of\nthe DOS support program is written to reside at 52224 ($CC00).  It\nwould be safest to avoid using 52224-53247 for graphics if you plan to\nuse DOS support.\n\nChanging banks.  Once you have selected a bank of 16K to use, the\nprocedure for making the change from BASIC is as follows:\n\n1.  Set the Data Direction Register if necessary.  In order to use\nBits 0 and 1 of Port A to change banks, these bits must be set as\noutputs in Data Direction Register A.  Since this is the default\ncondition on powering-up, this step normally will not be needed.\n\n2.  Select a bank.  Banks 0-3 can be chosen by entering the following\nlines:\n\nPOKE 56578,PEEK(56578) OR 3: REM SET FOR OUTPUT IF NOT ALREADY\nPOKE 56576,(PEEK(56576) AND 252) OR (3-BANK): REM BANK IS BANK #, MUST\n  BE 0-3\n\n3.  Set the VIC-II register for character memory.  As explained at the\nentry for location 53272 ($D018), the formula for this is:\n\nPOKE 53272,(PEEK(53272) AND 240) OR TK: REM TK IS 2 KBYTE OFFSET FROM\n  BEGINNING OF BLOCK\n\n4.  Set the VIC-II register for display memory.  As explained at the\nentry for location 53272 ($D018), the formula for this is:\n\nPOKE 53272,(PEEK(53272) AND 15) OR K*16: REM K IS KBYTE OFFSET FROM\n  BEGINNING OF BLOCK\n\nSince steps 3 and 4 operate on the same register, you could combine\nthese steps and just POKE 53272,(16*K+TK).\n\n5.  Set the Operating System pointer for display memory at 648 ($288).\nEven though you have just told the VIC-II chip where to display memory\nfor the screen, the Operating System does not yet know where to write\nits text characters.  Let it know with this statement:\n\nPOKE 648,AD/256: REM AD IS THE ACTUAL ADDRESS OF SCREEN MEMORY\n\nAfter you make this change, you must watch out for the STOP/RESTORE\nkey combination.  The BRK initialization changes the screen display\ndefault to location 1024 in Bank 0, but not the Operating System\npointer at 648 ($288).  As a result, what you are typing will not be\ndisplayed on the screen.  The computer will lock up until you turn the\npower off and back on again.  The simplest way to avoid this problem\nis to disable the RESTORE key entirely (see the entries for 792 ($318)\nand 808 ($328) for more information).\n\nBelow is a sample program which switches to Bank 3.  It includes a\nmachine language transfer routine to move the ROM character set to\nRAM, and a short interrupt routine to correct the RESTORE key problem.\nAfter the switch is made, a loop isused to POKE characters into the\nnew screen memory area.  Next, the character data is slowly erased, to\nshow that the character set is now in RAM.  Then, a loop is used to\nread the locations of the character set, and write to the same\nlocations.  This demonstrates that the 6510 reads the Kernal ROM when\nyou PEEK those locations, but POKEs to the RAM which is being\ndisplayed.  Finally, the machine language move is used again to show\nhow quickly the set is restored.\n\n20 FOR I=1 TO 33:READ A:POKE 49152+I,A:NEXT: REM SET UP ML ROUTINE\n30 GOSUB 200: REM ML COPY OF ROM CHARACTER SET TO RAM\n40 POKE 56576,PEEK(56576) AND 252: REM STEP 1, ENABLE BANK 3\n50 POKE 53272,44: REM STEPS 2-3, POINT VIC-II TO SCREEN AND CHARACTER MEMORY\n60 REM SCREEN OFFSET IS 2*16, CHARACTER OFFSET IS 12\n70 POKE 648,200: REM STEP 4, POINT OS TO SCREEN AT 51200 (200*256)\n80 PRINT CHR$(147): REM CLEAR SCREEN\n90 FOR I=53236 TO 53245:READ A:POKE I,A:NEXT: REM NEW INTERRUPT ROUTINE\n100 POKE 53246,PEEK(792):POKE 53247,PEK(793): REM SAVE OLD NMI VECTOR\n110 POKE 792,244:POKE 793,207: REM ROUTE THE INTERRUPT THROUGH THE NEW ROUTINE\n120 FOR I=0 TO 255:POKE 51400+I,I:POKE 55496+I,1:NEXT\n125 REM POKE CHARACTERS TO SCREEN\n130 FOR J=1 TO 8:FOR I=61439+J TO I+2048 STEP 8\n140 POKE I,0:NEXT I,J: REM ERASE CHARACTER SET\n150 FOR I=61440 TO I+2048:POKE I,PEEK(I):NEXT: REM POKE ROM TO RAM\n160 GOSUB 200:END: REM RESTORE CHARACTER SET\n200 POKE 56334,PEEK(56334) AND 254: REM DISABLE INTERRUPTS\n210 POKE 1,PEEK(1) AND 251:REM SWITCH CHARACTER ROM INTO 6510 MEMORY\n220 SYS 49152: REM COPY ROM CHARACTER SET TO RAM AT 61440\n230 POKE 1,PEEK(1) OR 4: REM SWITCH CHARACTER ROM OUT OF 6510 MEMORY\n240 POKE 56334,PEEK(56334)OR 1: REM ENABLE INTERRUPTS\n250 RETURN\n300 REM DATA FOR ML PROGRAM TO COPY CHARACTER SET TO RAM\n310 DATA169,0,133,251,133,253,169,208,133,252,169,240,133,254,162,16\n320 DATA160,0,177,251,145,253,136,208,249,230,252,230,254,202,208,240,96\n330 REM NEXT IS ML PROGRAM TO MAKE THE RESTORE KEY RESET OS POINTER TO SCREEN\n340 DATA 72,169,4,141,136,02,104,108,254,207\n\nSee also the sample program showing how to configure your 64 like a\nPET at location 43 ($2B)."
  },
  {
    "id": "map-DD00",
    "address_start": 56576,
    "address_end": 56576,
    "hex_start": "$DD00",
    "hex_end": "$DD00",
    "label": "CI2PRA",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56576         $DD00          CI2PRA\nData Port Register A\n\nBits 0-1:  Select the 16K VIC-II chip memory bank (11=bank 0, 00=bank 3)\nBit 2:  RS-232 data output (Sout)/Pin M of User Port\nBit 3:  Serial bus ATN signal output\nBit 4:  Serial bus clock pulse output\nBit 5:  Serial bus data output\nBit 6:  Serial bus clock pulse input\nBit 7:  Serial bus data input"
  },
  {
    "id": "map-DD01",
    "address_start": 56577,
    "address_end": 56577,
    "hex_start": "$DD01",
    "hex_end": "$DD01",
    "label": "CI2PRB",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56577         $DD01          CI2PRB\nData Port B\n\nBit 0:  RS-232 data input (SIN)/ Pin C of User Port\nBit 1:  RS-232 request to send (RTS)/ Pin D of User Port\nBit 2:  RS-232 data terminal ready (DTR)/ Pin E of User Port\nBit 3:  RS-232 ring indicator (RI)/ Pin F of User Port\nBit 4:  RS-232 carrier detect (DCD)/ Pin H of User Port\nBit 5:  Pin J of User Port\nBit 6:  RS-232 clear to send (CTS)/ Pin K of User Port\n        Toggle or pulse data output for Timer A\nBit 7:  RS-232 data set ready (DSR)/ Pin L of User Port\n        Toggle or pulse data output for Timer B"
  },
  {
    "id": "map-DD02-DD03",
    "address_start": 56578,
    "address_end": 56579,
    "hex_start": "$DD02",
    "hex_end": "$DD03",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56578-56579 ($DD02-$DD03)\nCIA #2 Data Direction Registers A and B\n\nThese Data Direction registers control the direction of data flow over\nData Ports A and B.  For more details on the operation of these\nregisters, see the entry for the CIA #1 Data Direction Registers at\n56322 ($DC02).\n\nThe default setting for Data Direction Register A is 63 (all bits\nexcept 6 and 7 are outputs), and for Data Direction Register B the\ndefault setting is 0 (all inputs).  Bits 1 and 2 of Port B are changed\nto output when the RS-232 device is opened."
  },
  {
    "id": "map-DD02",
    "address_start": 56578,
    "address_end": 56578,
    "hex_start": "$DD02",
    "hex_end": "$DD02",
    "label": "C2DDRA",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56578         $DD02          C2DDRA\nData Direction Register A\n\nBit 0:  Select Bit 0 of data Port A for input or output (0=input, 1=output)\nBit 1:  Select Bit 1 of data Port A for input or output (0=input, 1=output)\nBit 2:  Select Bit 2 of data Port A for input or output (0=input, 1=output)\nBit 3:  Select Bit 3 of data Port A for input or output (0=input, 1=output)\nBit 4:  Select Bit 4 of data Port A for input or output (0=input, 1=output)\nBit 5:  Select Bit 5 of data Port A for input or output (0=input, 1=output)\nBit 6:  Select Bit 6 of data Port A for input or output (0=input, 1=output)\nBit 7:  Select Bit 7 of data Port A for input or output (0=input, 1=output)"
  },
  {
    "id": "map-DD03",
    "address_start": 56579,
    "address_end": 56579,
    "hex_start": "$DD03",
    "hex_end": "$DD03",
    "label": "C2DDRB",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56579         $DD03          C2DDRB\nData Direction Register B\n\nBit 0:  Select Bit 0 of data Port B for input or output (0=input, 1=output)\nBit 1:  Select Bit 1 of data Port B for input or output (0=input, 1=output)\nBit 2:  Select Bit 2 of data Port B for input or output (0=input, 1=output)\nBit 3:  Select Bit 3 of data Port B for input or output (0=input, 1=output)\nBit 4:  Select Bit 4 of data Port B for input or output (0=input, 1=output)\nBit 5:  Select Bit 5 of data Port B for input or output (0=input, 1=output)\nBit 6:  Select Bit 6 of data Port B for input or output (0=input, 1=output)\nBit 7:  Select Bit 7 of data Port B for input or output (0=input, 1=output)"
  },
  {
    "id": "map-DD04-DD07",
    "address_start": 56580,
    "address_end": 56583,
    "hex_start": "$DD04",
    "hex_end": "$DD07",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56580-56583 ($DD04-$DD07)\nTimer A and B Low and High Bytes\n\nThese four timer registers are used to control Timers A and B.  For\ndetails on the operation of these timers, see the entry for Location\nRange 56324-56327 ($DC04-$DC07).\n\nThe 64 Operating System uses the CIA #2 Timers A and B mostly for\ntiming RS-232 send and receive operations.  Serial Bus timing uses CIA\n#1 Timer B."
  },
  {
    "id": "map-DD04",
    "address_start": 56580,
    "address_end": 56580,
    "hex_start": "$DD04",
    "hex_end": "$DD04",
    "label": "TI2ALO",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56580         $DD04          TI2ALO\nTimer A (low byte)"
  },
  {
    "id": "map-DD05",
    "address_start": 56581,
    "address_end": 56581,
    "hex_start": "$DD05",
    "hex_end": "$DD05",
    "label": "TI2AHI",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56581         $DD05          TI2AHI\nTimer A (high byte)"
  },
  {
    "id": "map-DD06",
    "address_start": 56582,
    "address_end": 56582,
    "hex_start": "$DD06",
    "hex_end": "$DD06",
    "label": "TI2BLO",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56582         $DD06          TI2BLO\nTimer B (low byte)"
  },
  {
    "id": "map-DD07",
    "address_start": 56583,
    "address_end": 56583,
    "hex_start": "$DD07",
    "hex_end": "$DD07",
    "label": "TI2BHI",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56583         $DD07          TI2BHI\nTimer B (high byte)"
  },
  {
    "id": "map-DD08-DD0B",
    "address_start": 56584,
    "address_end": 56587,
    "hex_start": "$DD08",
    "hex_end": "$DD0B",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56584-56587 ($DD08-$DD0B)\nTime of Day Clock\n\nIn addition to the two general purpose timers, the 6526 CIA chip has a\nspecial purpose Time of Day Clock, which keeps time in a format that\nhumans can understand a little more easily than microseconds.  For\nmore information about this clock, see the entry for Location Range\n56328-56331 ($DC08-$DC0B).  The 64's Operating system does not make\nuse of these registers."
  },
  {
    "id": "map-DD08",
    "address_start": 56584,
    "address_end": 56584,
    "hex_start": "$DD08",
    "hex_end": "$DD08",
    "label": "TO2TEN",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56584         $DD08          TO2TEN\nTime of Day Clock Tenths of Seconds\n\nBits 0-3:  Time of Day tenths of second digit (BCD)\nBits 4-7:  Unused"
  },
  {
    "id": "map-DD09",
    "address_start": 56585,
    "address_end": 56585,
    "hex_start": "$DD09",
    "hex_end": "$DD09",
    "label": "TO2SEC",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56585         $DD09          TO2SEC\nTime of Day Clock Seconds\n\nBits 0-3:  Second digit of Time of Day seconds (BCD)\nBits 4-6:  First digit of Time of Day seconds (BCD)\nBit 7:  Unused"
  },
  {
    "id": "map-DD0A",
    "address_start": 56586,
    "address_end": 56586,
    "hex_start": "$DD0A",
    "hex_end": "$DD0A",
    "label": "TO2MIN",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56586         $DD0A          TO2MIN\nTime of Day Clock Minutes\n\nBits 0-3:  Second digit of Time of Day minutes (BCD)\nBits 4-6:  First digit of Time of Day minutes (BCD)\nBit 7:  Unused"
  },
  {
    "id": "map-DD0B",
    "address_start": 56587,
    "address_end": 56587,
    "hex_start": "$DD0B",
    "hex_end": "$DD0B",
    "label": "TO2HRS",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56587         $DD0B          TO2HRS\nTime of Day Clock Hours\n\nBits 0-3:  Second digit of Time of Day hours (BCD)\nBit 4:  First digit of Time of Day hours (BCD)\nBits 5-6:  Unused\nBit 7:  AM/PM flag (1=PM, 0=AM)"
  },
  {
    "id": "map-DD0C",
    "address_start": 56588,
    "address_end": 56588,
    "hex_start": "$DD0C",
    "hex_end": "$DD0C",
    "label": "CI2SDR",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56588         $DD0C          CI2SDR\nSerial Data Port\n\nThe CIA chip has an on-chip serial port, which allows you to send or\nreceive a byte of data one bit at a time, with the most significant\nbit (Bit 7) being transferred first.  For more information about its\nuse, see the entry for location 56332 ($DC0C).  The 64's Operating\nSystem does not use this facility."
  },
  {
    "id": "map-DD0D",
    "address_start": 56589,
    "address_end": 56589,
    "hex_start": "$DD0D",
    "hex_end": "$DD0D",
    "label": "CI2ICR",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56589         $DD0D          CI2ICR\nInterrupt Control Register\n\nBit 0:  Read / did Timer A count down to 0?  (1=yes)\n        Write/ enable or disable Timer A interrupt (1=enable, 0=disable)\nBit 1:  Read / did Timer B count down to 0?  (1=yes)\n        Write/ enable or disable Timer B interrupt (1=enable, 0=disable)\nBit 2:  Read / did Time of Day Clock reach the alarm time?  (1=yes)\n        Write/ enable or disable TOD clock alarm interrupt (1=enable,\n        0=disable)\nBit 3:  Read / did the serial shift register finish a byte?  (1=yes)\n        Write/ enable or disable serial shift register interrupt (1=enable,\n        0=disable)\nBit 4:  Read / was a signal sent on the FLAG line?  (1=yes)\n        Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)\nBit 5:  Not used\nBit 6:  Not used\nBit 7:  Read / did any CIA #2 source cause an interrupt?  (1=yes)\n        Write/ set or clear bits of this register (1=bits written with 1 will\n        be set, 0=bits written with 1 will be cleared)\n\nThis register is used to control the five interrupt sources on the\n6526 CIA chip.  For details on its operation, see the entry for 56333\n($DC0D).  The main difference between these two chips pertaining to\nthis register is that on CIA #2, the FLAG line is connected to Pin B\nof the User Port, and thus is available to the user who wishes to take\nadvantage of its ability to cause interrupts for handshaking purposes.\n\nLocation Range: 56590-$56591 ($DD0E-$DD0F)\nSee locations 56334 and 56334 for details"
  },
  {
    "id": "map-DD0E",
    "address_start": 56590,
    "address_end": 56590,
    "hex_start": "$DD0E",
    "hex_end": "$DD0E",
    "label": "CI2CRA",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56590         $DD0E          CI2CRA\nControl Register A\n\nBit 0:  Start Timer A (1=start, 0=stop)\nBit 1:  Select Timer A output on Port B (1=Timer A output appears on\n        Bit 6 of Port B)\nBit 2:  Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one\n        cycle)\nBit 3:  Timer A run mode (1=one-shot, 0=continuous)\nBit 4:  Force latched value to be loaded to Timer A counter (1=force\n        load strobe)\nBit 5:  Timer A input mode (1=count microprocessor cycles, 0=count\n        signals on CNT line at pin 4 of User Port)\nBit 6:  Serial Port (56588, $DD0C) mode (1=output, 0=input)\nBit 7:  Time of Day Clock frequency (1=50 Hz required on TOD pin,\n        0=60 Hz)"
  },
  {
    "id": "map-DD0F",
    "address_start": 56591,
    "address_end": 56591,
    "hex_start": "$DD0F",
    "hex_end": "$DD0F",
    "label": "CI2CRB",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location",
    "text": "56591         $DD0F          CI2CRB\nControl Register B\n\nBit 0:  Start Timer B (1=start, 0=stop)\nBit 1:  Select Timer B output on Port B (1=Timer B output appears on\n        Bit 7 of Port B)\nBit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one\n        cycle)\nBit 3:  Timer B run mode (1=one shot, 0=continuous)\nBit 4:  Force latched value to be loaded to Timer B counter (1=force\n        load strobe)\nBits 5-6:  Timer B input mode\n           00 = Timer B counts microprocessor cycles\n           01 = Count signals on CNT line at pin 4 of User Port\n           10 = Count each time that Timer A counts down to 0\n           11 = Count Timer A 0's when CNT pulses are also present\nBit 7:  Select Time of Day write (0=writing to TOD registers sets\n           alarm, 1=writing to ROD registers sets clock)"
  },
  {
    "id": "map-DD10-DDFF",
    "address_start": 56592,
    "address_end": 56831,
    "hex_start": "$DD10",
    "hex_end": "$DDFF",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56592-56831 ($DD10-$DDFF)\nCIA #2 Register Images\n\nSince the CIA chip requires only enough addressing lines to handle 16\nregisters, none of the higher bits are decoded when addressing the\n256-byte area that has been assigned to it.  The result is that every\n16-byte area in this 256-byte block is a mirror of every other.  For\nthe sake of clarity in your programs, it is advisable not to use these\naddresses."
  },
  {
    "id": "map-DE00-DEFF",
    "address_start": 56832,
    "address_end": 57087,
    "hex_start": "$DE00",
    "hex_end": "$DEFF",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 56832-57087 ($DE00-$DEFF)\nReserved for I/O Expansion\n\nThis range of locations is not used directly by the 64's internal\nhardware.  It is, however, accessible via pin 7 of the Expansion Port.\nIt can be used to control cartridges which are connected to this port.\nFor example, the CP/M module uses this space to control which\nmicroprocessor is in control of the system.  The Z-80 microprocessor\nis turned on and off by writing to 56832 ($DE00).\n\nAnother cartridge which uses this space is Simon's BASIC.  This 16K\ncartridge is addressed at memory locations 32768-49151 ($8000-$BFFF),\nwhich means that it overlaps the regular BASIC ROM at 40960-49151\n($A000-$BFFF).  But since it contains additions to BASIC, it must use\nthe BASIC ROM as well.  This problem is solved by copying the\ncartridge at 32768-40959 ($8000-$9FFF) to RAM, and turning the\ncartridge on and off by writing to or reading from location 56832\n($DE00)."
  },
  {
    "id": "map-DF00-DFFF",
    "address_start": 57088,
    "address_end": 57343,
    "hex_start": "$DF00",
    "hex_end": "$DFFF",
    "source": "mapping-c64.txt",
    "chapter": "::   Chapter 6    ::",
    "type": "location_range",
    "text": "Location Range: 57088-57343 ($DF00-$DFFF)\nCIA #2 Register Images\n\nThis range of locations is not used directly by the 64's internal\nhardward, but is accessible via pin 10 of the Expansion Port.  One\npossible use for this I/O memory that Commodore has mentioned is an\ninexpensive parallel disk drive (which presumable would be much faster\nthan the current serial model).\n\nAlternate 53248-57343 ($D000-$DFFF)\nCharacter Generator ROM\n\nThe character generator ROM supplies the data which is to form the\nshapes of the text and graphics characters that are displayed on the\nscreen.  Each character requires eight bytes of shape data, and these\neight-byte sequences are arranged in order in which the characters\nappear in the screen code chart (see Appendix G).  For example, the\nfirst eight bytes of data in the ROM hold the shape information for\nthe commercial at sign (@), the next eight hold the shape of the\nletter A, etc.  In all, there are 4096 bytes, representing shape data\nfor two complete character sets of 256 characters each--1K each for\nuppercase/graphics, reverse uppercase/reverse graphics, lowercase/\nuppercase, and reverse lowercase/reverse uppercase.\n\nThe shape of each character is formed by an 8 by 8 matrix of screen\ndots.  Whether any of the 64 dots is lit up or not is determined by\nthe bit patterns of the character data.  Each byte of the Character\nROM holds a number from 0 to 255.  This number can be represented by\neight binary digits of 0 or 1.  The leftmost bit of these eight is\nknown as Bit 7, while the rightmost bit is called Bit 0.  Each of\nthese binary digits has a bit value that is two times greater than the\nlast.  The values of a bit set to 1 in each of the bit places are:\n\nBit    0    1     2    3    4    5    6    7\nValue  1    2     4    8   16   32   64  128\n\nA byte whose value is 255 has every bit set to 1\n(128+64+32+16+8+4+2+1=255), while a byte whose value is 0 is made up\nof all zero bits.  Numbers in between are made up of combinations of\nbits set to 1 and bits set to 0.  If you think of every bit that holds\n0 as a dot on the screen which is the color of the screen background,\nand every bit that holds a 1 as a dot whose color is that of the\nappropriate nybble in Color RAM, you can begin to get an idea of how\nthe byte values relate to the shape of the character.  For example, if\nyou PEEK at the first eight bytes of the character ROM (the technique\nis explained in the entry for location 1), you will see the numbers\n60, 102, 110, 110, 96, 98, 60, 0.  Breaking these data bytes down into\ntheir bit values gives us a picture that looks like the following:\n\n00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60\n01100110   0 +  64 +  32 +   0 +   0 +   4 +   2 +   0 = 101\n01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110\n01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110\n01100000   0 +  64 +  32 +   0 +   0 +   0 +   0 +   0 =  96\n01100010   0 +  64 +  32 +   0 +   0 +   0 +   2 +   0 =  98\n00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60\n00000000   0 +   0 +   0 +   0 +   0 +   0 +   0 +   0 =   0\n\nIf you look closely, you will recognize the shape of the commercial at\nsign (@) as it's displayed on your screen.  The first byte of data is\n60, and you can see that Bits 5, 4, 3, and 2 are set to 1.  The chart\nabove shows that the bit values for these bits are 32, 16, 8, and 4.\nAdding these together, you get 32+16+8+4=60.  This should give you an\nidea of how the byte value corresponds to the patterns of lit dots.\nFor an even more graphic display, type in the following program, which\nshows the shape of any of the 512 characters in the ROM, along with\nthe number value of each byte of the shape.\n\n10 DIM B%(7),T%(7):FOR I=0 TO 7:T%(I)=2^I:NEXT\n20 POKE 53281,2:PRINT CHR$(147):POKE 53281,1:POKE 53280,0:POKE 646,11\n30 POKE 214,20:PRINT:INPUT\" CHARACTER NUMBER (0-511)\";C$\n40 C=VAL(C$):GOSUB 80:FOR I=0 TO 7\n50 POKE 214,6+I:PRINT:PRINT TAB(23);B%(I);CHR$(20);\"   \"\n60 FOR J=7 TO 0 STEP-1:POKE 1319+(7-J)+I*40,32-128*((B%(I)ANDT%(J))=T%(J))\n70 NEXT J,I:POKE 214,20:PRINT:PRINT TAB(27)\"    \":GOTO 30\n80 POKE 56333,127:POKE 1,51:FOR I=0 TO 7\n90 B%(I)=PEEK(53248+C*8+I):NEXT:POKE 1,55:POKE 56333,129:RETURN\n\nIf you have read about the VIC-II video chip, you know that it can\naddress only 16K of memory at a time, and that all display data such\nas screen memory, character shape data, and sprite shape data must be\nstored within that 16K block.\n\nSince it would be very inconvenient for the VIC-II chip to be able to\naccess the character data only at the 16K block which includes\nadresses 53248-57343 ($D000-$DFFF), the 64 uses an addressing trick\nthat makes the VIC-II chip see an image of the Character ROM at\n4096-8191 ($1000-$1FFF) and at 36864-40959 ($9000-$9FFF).  It is not\navailable in the other two blocks.  To generate characters in these\nblocks, you must supply your own user-defined character set, or copy\nthe ROM data to RAM.  A machine language routine for doing this is\nincluded in a sample program at the entry for 56576 ($DD00).\n\nAs indicated above, you are by no means limited to useing the\ncharacter data furnished by the ROM.  The availability of user-defined\ncharacters greatly extends the graphics power of the 64.  It allows\nyou to create special text characters, like math or chemistry symbols\nand foreign language alphabets.  You can also develop special graphics\ncharacters as a substitute for plotting points in bitmap graphics.\nYou can achieve the same resolution using a custom character as in\nhigh-resolution bitmap mode, but with less memory. Once you have\ndefined the character, it is much faster to print it to the screen\nthan in would be to plot out all of the individual points.\n\nTo employ user-defined characters, you must first pick a spot to put\nthe shape data.  This requires choosing a bank of 16K for video chip\nmemory (see the entry under Bits 0-1 of 56576 ($DD00) for the\nconsiderations involved), and setting the pointer to the 2K area of\ncharacter memory in 53272 ($D018).  It is then up to you to supply the\nshape data for the characters.  You can use part of the ROM character\nset by reading the ROM and transferring the data to your character\nshape area (see the entry for location 1 for a method of reading the\nROM).\n\nYour original characters may be created by darkening squares on an 8\nby 8 grid, converting all darkened squares to their bit values, and\nthen adding the bit values for each of the eight bytes.  Or, you may\nuse one of the many character graphics editor programs that are\navailable commercially to generate the data interactively by drawing\non the screen.\n\nOne graphics mode, multicolor text mode, almost requires that you\ndefine your own character set in order to use it effectively.\nMulticolor mode is enabled by Bit 4 of location 53270 ($D016).\nInstead of using each bit to control whether an individual dot will be\nforeground color (1) or background color (0), that mode breaks down\neach byte of shape data in four bit-pairs.  These bit pairs control\nwhether a dot will be the color in Background Color Register #0 (00),\nthe color in Background Color Register #1 (01), the color in\nBackground Color Register #2 (10), or the color in the appropriate\nnybble of Color RAM (11).  Since each pair of bits controls one dot,\neach character is only four dots across.  To make up for this, each\ndot is twice as wide as a normal high-resolution dot.\n\n\n::::::::::::::::\n::            ::\n::8K Operating::\n::   System   ::\n:: Kernal ROM ::\n::::::::::::::::\n\nAs with the section on the BASIC ROM, this section is not meant to be\na complete explanation of the Kernal ROM, but rather a guidepost for\nfurther exploration.  Where the exact instructions the Kernal ROM\nroutines use are important to your programming, it will be necessary\nfor you to obtain a disassembly listing of those routines and look at\nthe code itself.\n\nKeep in mind that there is 8K of RAM underlying the Kernal ROM that\ncan be used by turning off interrupts and switching out the Kernal ROM\ntemporarily.  Even without switching out the Kernal ROM, this RAM may\nbe read by the VIC-II chip if it is banked to use the top 16K of\nmemory, and may be used for graphics data.  The Kernal and BASIC ROMs\nmay be copied to RAM, and the RAM versions modified to change existing\nfeatures or add new ones.\n\nThere are some differences between the version of the Kernal found on\nthe first few Commodore 64s and those found on the majority of newer\nmodels.  Those differences are discussed in the entries for the\nsections on later Kernal additions (patches) at 58541-58623\n($E4AD-$E4FF) an 65371-67407 ($FF5B-$FF7F).\n\nThe most obvious change causes the Color RAM at 55296 ($D800) to be\ninitialized to the background color when the screen is cleared on\nnewer models, instead of white as on the original models.  Other\nchanges allow the new Kernal software to be used by either U.S. or\nEuropean 64s.  Keep in mind that the Kernal is always subject to\nchange, and that the following discussion, while accurate at the time\nwritten (mid-1983), may not pertain to later models.  If future\nchanges are like past ones, however, they are likely to be minor ones.\nThe first place to look for these changes would be in the patch\nsections identified above."
  },
  {
    "id": "map-E000",
    "address_start": 57344,
    "address_end": 57344,
    "hex_start": "$E000",
    "hex_end": "$E000",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57344         $E000\nContinuation of EXP Routine\n\nThis routine is split, with part on the BASIC ROM and the other part\nhere.  Since the two ROMs do not occupy contiguous memory as on most\nCommodore machines, the BASIC ROM ends with a JMP $E000 instruction.\nThus, while the BASIC interpreter on the 64 is for the most part the\nsame as on the VIC, the addresses for routines in this ROM are\ndisplaced by three bytes from their location on the VIC."
  },
  {
    "id": "map-E043",
    "address_start": 57411,
    "address_end": 57411,
    "hex_start": "$E043",
    "hex_end": "$E043",
    "label": "POLY1",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57411         $E043          POLY1\nFunction Series Evaluation Subroutine 1\n\nThis routine is used to evaluate more comples expressions, and calls\nthe following routine to do the intermediate evaluation."
  },
  {
    "id": "map-E059",
    "address_start": 57433,
    "address_end": 57433,
    "hex_start": "$E059",
    "hex_end": "$E059",
    "label": "POLY2",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57433         $E059          POLY2\nFunction Series Evaluation Subroutine 2\n\nThis is the main series evaluation routine, which evaluates\nexpressions by using a table of the various values that must be\noperated on in sequence to obtain the proper result."
  },
  {
    "id": "map-E08D",
    "address_start": 57485,
    "address_end": 57485,
    "hex_start": "$E08D",
    "hex_end": "$E08D",
    "label": "RMULC",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57485         $E08D          RMULC\nMultiplicative Constant for RND\n\nA five-byte floating point number which is multiplied by the seed\nvalue as part of the process of obtaining the next value for RND>"
  },
  {
    "id": "map-E092",
    "address_start": 57490,
    "address_end": 57490,
    "hex_start": "$E092",
    "hex_end": "$E092",
    "label": "RADDC",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57490         $E092          RADDC\nAdditive Constant for RND\n\nThe five-byte floating point number stored here is added to the seed\nas part of the process of obtaining the value for RND."
  },
  {
    "id": "map-E097",
    "address_start": 57495,
    "address_end": 57495,
    "hex_start": "$E097",
    "hex_end": "$E097",
    "label": "RND",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57495         $E097          RND\nPerform RND\n\nThis routine comes up with a random number in one of three ways,\ndepending on the argument X of RND(X).  If the argument is positive,\nthe next RND value is obtained by multiplying the seed value in\nlocation 139 ($8B) by one of the constants above, adding the other\nconstant, and scrambling the resulting bytes.  This produces the next\nnumber in a sequence.  So many numbers can be produced in this way\nbefore the sequence begins to repear that it can be considered random.\n\nIf the argument is negative, the argument itself is scrambled, and\nmade the new seed.  This allows creation of a sequence that can be\nduplicated.\n\nIf the argument is 0, four bytes of the Floating Point Accumulator are\nloaded from the low and high byte of Timer A, and the tenths of second\nand second Time of Day Clock registers, all on CIA #1.  This provides\na somewhat random value determined by the setting of those timers at\nthe moment that the command is executed, which becomes the new seed\nvalue.  The RND(1) command should then be used to generate further\nrandom numbers.\n\nThe RND(0) implementation on the 64 has serious problems which make it\nunusable for generating a series of random numbers when used by\nitself.  First of all, the Time of Day Clock on CIA #1 (see\n56328-56331 ($DC08-$DC0B)) does not start running until you write to\nthe tenth of second register.  The Operating System never starts this\nclock, and therefore the two registers used as part of the floating\npoint RND(0) value always have a value of 0.  Even if the clock was\nstarted, however, these registers keep time in Binary Coded Decimal\n(BCD) format, which means that they do not produce a full range of\nnumbers from 0 to 255.  In addition, the Timer A high register output\nranges only from 0 to 66, which also imits the range of the final\nfloating point value so that certain numbers are never chosen."
  },
  {
    "id": "map-E0F9",
    "address_start": 57593,
    "address_end": 57593,
    "hex_start": "$E0F9",
    "hex_end": "$E0F9",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57593         $E0F9\nCall Kernal I/O Routines\n\nThis section is used when BASIC wants to call the Kernal I/O routines\nCHROUT, CHRIN, CHKOUT, CHKIN, and GETIN.  It handles any errors that\nresult from the call, and creates a 512-byte buffer space at the top\nof BASIC and executes a CLR if the RS-232 device is opened."
  },
  {
    "id": "map-E12A",
    "address_start": 57642,
    "address_end": 57642,
    "hex_start": "$E12A",
    "hex_end": "$E12A",
    "label": "SYS",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57642         $E12A          SYS\nPerform SYS\n\nBefore executing the machine language subroutine (JSR) at the address\nindicated, the .A, .X, .Y, and .P registers are loaded from the\nstorage area at 780-783 ($30C-$30F).  After the return from subroutine\n(RTS), the new values of those registers are stored back at 780-783\n($30C-$30F)."
  },
  {
    "id": "map-E156",
    "address_start": 57686,
    "address_end": 57686,
    "hex_start": "$E156",
    "hex_end": "$E156",
    "label": "SAVE",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57686         $E156          SAVE\nPerform SAVE\n\nThis routine sets the range of addresses to be saved from the start of\nBASIC program text and end of BASIC program text pointers at 43 ($2B)\nand 45 ($2D), and calls the Kernal SAVE routine.  This means that any\narea of memory can be saved by altering these two pointers to point to\nthe starting and ending address of the desired area, and then changing\nthem back."
  },
  {
    "id": "map-E165",
    "address_start": 57701,
    "address_end": 57701,
    "hex_start": "$E165",
    "hex_end": "$E165",
    "label": "VERIFY",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57701         $E165          VERIFY\nPerform VERIFY\n\nThis routine sets the load/verify flag at 10 ($A), and falls through\nto the LOAD routine."
  },
  {
    "id": "map-E168",
    "address_start": 57704,
    "address_end": 57704,
    "hex_start": "$E168",
    "hex_end": "$E168",
    "label": "LOAD",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57704         $E168          LOAD\nPerform LOAD\n\nThis routine sets the load address to the start of BASIC (from pointer\nat 43 ($2B)), and calls the Kerneal LOAD routine.  If the load is\nsuccessful, it relinks the BASIC program so that the links agree with\nthe address to which it is loaded, and it resets the end of BASIC\npointer to reflect the new end of program text.  If the LOAD was done\nwhile a program was running, the pointers are reset so that the\nprogram starts executing all over again from the beginning.  A CLR is\nnot performed, so that the variables build so far are retained, and\ntheir values are still accessible.  The pointer to the variable area\nis not changed, but if the new program is longer than the one that\nloaded it, the variable table will be partially overwritten.  This\nwill cause errors when the overwritten variables are referenced.\nLikewise, strings whose text was referenced at its location within the\noriginal program listing will be incorrect.\n\nSince a LOAD from a program causes the program execution to continue\nat the first line, when loading a machine language routine or data\nfile with a nonrelocating load (for example, LOAD\"FILE\",8,1) from a\nprogram, you should read a flag and GOTO the line after the LOAD if\nyou don't want the program to keep rerunning indefinitely:\n\n10 IF FLAG=1 THEN GOTO 30\n20 FLAG=1:LOAD\"FILE\",8,1\n30 REM PROGRAM CONTINUES HERE"
  },
  {
    "id": "map-E1BE",
    "address_start": 57790,
    "address_end": 57790,
    "hex_start": "$E1BE",
    "hex_end": "$E1BE",
    "label": "OPEN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57790         $E1BE          OPEN\nPerform OPEN\n\nThe BASIC OPEN statement calls the Kernal OPEN routine."
  },
  {
    "id": "map-E1C7",
    "address_start": 57799,
    "address_end": 57799,
    "hex_start": "$E1C7",
    "hex_end": "$E1C7",
    "label": "CLOSE",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57799         $E1C7          CLOSE\nPerform CLOSE\n\nThe BASIC CLOSE statement calls the Kernal CLOSE routine."
  },
  {
    "id": "map-E1D4",
    "address_start": 57812,
    "address_end": 57812,
    "hex_start": "$E1D4",
    "hex_end": "$E1D4",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57812         $E1D4\nSet Parameters for LOAD, VERIFY, and SAVE\n\nThis routine is used in common by LOAD, SAVE, and VERIFY for setting\nthe filename, the logical file, device number, and secondary address,\nall of which must be done prior to these operations."
  },
  {
    "id": "map-E200",
    "address_start": 57856,
    "address_end": 57856,
    "hex_start": "$E200",
    "hex_end": "$E200",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57856         $E200\nSkip Comma and Get Integer in .X\n\nThis subroutine is used to skip the comma between parameters and get\nthe following integer value in the .X register."
  },
  {
    "id": "map-E206",
    "address_start": 57862,
    "address_end": 57862,
    "hex_start": "$E206",
    "hex_end": "$E206",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57862         $E206\nFetch Current Character and Check for End of Line\n\nThis subroutine gets the current character, and if it is 0 (end of\nline), it pulls its own return address off the stack and returns.\nThis terminates both its own execution and that of the subroutine\nwhich called it."
  },
  {
    "id": "map-E20E",
    "address_start": 57870,
    "address_end": 57870,
    "hex_start": "$E20E",
    "hex_end": "$E20E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57870         $E20E\nCheck for Comma\n\nThis subroutine checks for a comma, moves the text pointer past it if\nfound, and returns an error if it is not found."
  },
  {
    "id": "map-E219",
    "address_start": 57881,
    "address_end": 57881,
    "hex_start": "$E219",
    "hex_end": "$E219",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57881         $E219\nSet Parameters for OPEN and CLOSE\n\nThis routine is used in common by OPEN and CLOSE for setting the\nfilename, the logical file, device number, and secondary address, all\nof which must be done prior to these operations."
  },
  {
    "id": "map-E264",
    "address_start": 57956,
    "address_end": 57956,
    "hex_start": "$E264",
    "hex_end": "$E264",
    "label": "COS",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57956         $E264          COS\nPerform COS\n\nCOS is executed by adding PI/2 to the contents of FAC1 and dropping\nthrough to SIN."
  },
  {
    "id": "map-E268",
    "address_start": 57960,
    "address_end": 57960,
    "hex_start": "$E268",
    "hex_end": "$E268",
    "label": "SIN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "57960         $E268          SIN\nPerform SIN\n\nThis routine evaluates the SIN of the number in FAC1 (which represents\nthe angle in radians), and leaves the result there."
  },
  {
    "id": "map-E2B4",
    "address_start": 58036,
    "address_end": 58036,
    "hex_start": "$E2B4",
    "hex_end": "$E2B4",
    "label": "TAN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58036         $E2B4          TAN\nPerform TAN\n\nThis routine evaluates the tangent of the number in FAC1 (which\nrepresents the angle in radians) by dividing its sine by its cosine."
  },
  {
    "id": "map-E2E0-E30D",
    "address_start": 58080,
    "address_end": 58125,
    "hex_start": "$E2E0",
    "hex_end": "$E30D",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location_range",
    "text": "Location Range: 58080-58125 ($E2E0-$E30D)\nTable of Constants for Evaluation of SIN, COS, and TAN"
  },
  {
    "id": "map-E2E0",
    "address_start": 58080,
    "address_end": 58080,
    "hex_start": "$E2E0",
    "hex_end": "$E2E0",
    "label": "PI2",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58080         $E2E0          PI2\nThe Five-Byte Floating Point Representation of the Constant PI/2"
  },
  {
    "id": "map-E2E5",
    "address_start": 58085,
    "address_end": 58085,
    "hex_start": "$E2E5",
    "hex_end": "$E2E5",
    "label": "TWOPI",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58085         $E2E5          TWOPI\nThe Five-Byte Floating Point Representation of the Constant 2*PI"
  },
  {
    "id": "map-E2EA",
    "address_start": 58090,
    "address_end": 58090,
    "hex_start": "$E2EA",
    "hex_end": "$E2EA",
    "label": "FR4",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58090         $E2EA          FR4\nThe Five-Byte Floating Point Representation of the Constant 1/4"
  },
  {
    "id": "map-E2EF",
    "address_start": 58095,
    "address_end": 58095,
    "hex_start": "$E2EF",
    "hex_end": "$E2EF",
    "label": "SINCON",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58095         $E2EF          SINCON\nTable of Constants for Evaluation of SIN, COS, and TAN\n\nThis table starts with a counter byte of 5, indicating that there are\nsix entries in the table.  This is followed by the six floating point\nconstants of five bytes each."
  },
  {
    "id": "map-E30E",
    "address_start": 58126,
    "address_end": 58126,
    "hex_start": "$E30E",
    "hex_end": "$E30E",
    "label": "ATN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58126         $E30E          ATN\nPerform ATN\n\nThe arc tangent of the number in FAC1 (which represents the angle in\nradians) is evaluated using the 12-term series of operations from the\nconstant table which follows.  The answer is left in FAC1."
  },
  {
    "id": "map-E33E",
    "address_start": 58174,
    "address_end": 58174,
    "hex_start": "$E33E",
    "hex_end": "$E33E",
    "label": "ATNCON",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58174         $E33E          ATNCON\nTable of Constants for ATN Evaluation\n\nThe table begins with a count byte of 11, which is followed by 12\nconstants in five-byte floating point representation."
  },
  {
    "id": "map-E37B",
    "address_start": 58235,
    "address_end": 58235,
    "hex_start": "$E37B",
    "hex_end": "$E37B",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58235         $E37B\nWarm Start BASIC\n\nThis is the entry point into BASIC from the BRK routine at 65126\n($FE66), which is executed when the STOP and RESTORE keys are both\npressed.  It first executes the Kernal CLRCHN routine which closes all\nfiles.  It then sets the default devices, resets the stack and BASIC\nprogram pointers, and jumps through the vector at 768 ($300) to the\nnext routine to print the READY prompt and enter the main BASIC loop."
  },
  {
    "id": "map-E38B",
    "address_start": 58251,
    "address_end": 58251,
    "hex_start": "$E38B",
    "hex_end": "$E38B",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58251         $E38B\nError Message Handler\n\nThis routine to print error messages is pointed to by the vector at\n768 ($300).  Using the .X register as an index, it either prints an\nerror message from the table at 41363 ($A193) or the READY prompt, and\ncontinues through the vector at 770 ($302) to the main BASIC loop."
  },
  {
    "id": "map-E394",
    "address_start": 58260,
    "address_end": 58260,
    "hex_start": "$E394",
    "hex_end": "$E394",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58260         $E394\nCold Start BASIC\n\nThis initialization routine is executed at the time of power-up.  The\nRAM vectors to important BASIC routines are set up starting at 768\n($300), the interpreter is initialized, the start-up messages are\nprinted, and the main loop entered through the end of the warm start\nroutine."
  },
  {
    "id": "map-E3A2",
    "address_start": 58274,
    "address_end": 58274,
    "hex_start": "$E3A2",
    "hex_end": "$E3A2",
    "label": "INITAT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58274         $E3A2          INITAT\nText of the CHRGET Routine Which Runs at 115 ($73)\n\nThe text of the CHRGET routine is stored here, and moved to Page 0 by\nthe BASIC initialization routine.  When creating a wedge in CHRGET, it\nis possible to execute all or part of this code in place of the RAM\nversion.\n\n59298         $E3BA\nInitial RND Seed Value\n\nAt power-up time, this five-byte floating point constant is\ntransferred to 139 ($8B), where it functions as the starting RND seed\nnumber.  Thus, if RND is not initialized with a negative or zero\nargument, it will always return the same sequence of numbers."
  },
  {
    "id": "map-E3BF",
    "address_start": 58303,
    "address_end": 58303,
    "hex_start": "$E3BF",
    "hex_end": "$E3BF",
    "label": "INIT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58303         $E3BF          INIT\nInitialize BASIC\n\nThis routine is called by the cold start routine to initialize all of\nthe BASIC zero-page locations which have a fixed value.  This includes\ncopying the CHRGET routine from the ROM location above, to 115 ($73)."
  },
  {
    "id": "map-E422",
    "address_start": 58402,
    "address_end": 58402,
    "hex_start": "$E422",
    "hex_end": "$E422",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58402         $E422\nPrint BASIC Start-Up Messages\n\nThis routine prints the start-up message \"**** COMMODORE 64 BASIC V2\n****\", calculates the amount of free memory, and prints the BYTES FREE\nmessage."
  },
  {
    "id": "map-E447",
    "address_start": 58439,
    "address_end": 58439,
    "hex_start": "$E447",
    "hex_end": "$E447",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58439         $E447\nTable of Vectors to Important BASIC Routines\n\nThis table contains the vectors which point to the addresses of some\nimportant BASIC routines.  The contents of this table are moved to the\nRAM table at 768 ($300)."
  },
  {
    "id": "map-E453",
    "address_start": 58451,
    "address_end": 58451,
    "hex_start": "$E453",
    "hex_end": "$E453",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58451         $E453\nCopy BASIC Vectors to RAM\n\nThe cold start routine calls this subroutine to copy the table of\nvectors to important BASIC routines to RAM, starting at location 768\n($300)."
  },
  {
    "id": "map-E460",
    "address_start": 58464,
    "address_end": 58464,
    "hex_start": "$E460",
    "hex_end": "$E460",
    "label": "WORDS",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58464         $E460          WORDS\nPower-Up Messages\n\nThe ASCII text of the start-up messages \"**** COMMODORE 64 BASIC V2\n****\" and \"BYTES FREE\" is stored here.\n\nLocation Range: 58551-58623 ($E4B7-E4FF)\nPatches Added to Later Kernal Versions\n\nThis area contains code that was not found in the original version of\nthe Kernal.  These additions were made to fix some bugs and to\nincrease Kernal compatibility between U.S. and European 64s."
  },
  {
    "id": "map-E4AD",
    "address_start": 58541,
    "address_end": 58541,
    "hex_start": "$E4AD",
    "hex_end": "$E4AD",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58541         $E4AD\nPatch for BASIC Call of CHKOUT\n\nThis patch was made to preserve the .A register if there was no error\nreturned from BASIC's call of the Kernal CHKOUT routine.  Apparently,\nthe first version could cause a malfunction of the CMD and PRINT#\ncommands."
  },
  {
    "id": "map-E4B7",
    "address_start": 58551,
    "address_end": 58551,
    "hex_start": "$E4B7",
    "hex_end": "$E4B7",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58551         $E4B7\n35 Unused Bytes (all have the value of 170 ($AA)\n\nLocaiton Range: 58586-65535 ($E4DA-$FFFF)\nKernal I/O Routines\n\nAfter the conclusion of BASIC comes the part of this ROM which can be\nconsidered the Kernal proper.  This part contains all of the vectored\nroutines found in the jump table starting at 65409 ($FF81)."
  },
  {
    "id": "map-E4DA",
    "address_start": 58586,
    "address_end": 58586,
    "hex_start": "$E4DA",
    "hex_end": "$E4DA",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58586         $E4DA\nClear Color RAM to the Color in Background Color Register 0\n\nThis routine is a patch added to the more recent versions of the\nKernal.  It is called by the routine which clears a screen line\n(59903, $E9FF), and it places the color value in Background Color\nRegister 0 (53281, $D021) into the current byte of Color RAM pointed\nto by USER (243, $F3).\n\nIn the original version of the Kernal, the routine that cleared a\nscreen line set the corresponding Color RAM to a value of 1, which\ngives text characters a white foreground color.  This was changed when\nthe white color was found to sometimes cause light flashes during\nscreen scrolling.  It was that white foreground color, however, that\nenabled the user to POKE the screen code for a character into screen\nRAM, and make that character appear on the screen in a color that\ncontrasted the blue background.  This change to the Operating System\ncauses colors POKEd to screen RAM to be the same color as the\nbackground, and thus they are invisible.\n\nThis is a fairly serious problem, because the technique of POKEing\ncharacters to screen RAM has long been a staple of Commodore graphics\nprogramming.  Fortunately, the problem has an easy colution.  Since\nthe Color RAM will be set to whatevere color is in Background Color\nRegister 0, what you have to do to initialize Color RAM to the color\nyou desire is change the background color to the desired foreground\ncolor, clear the screen, and then change the background color back\nagain:\n\nC=PEEK(53281):POKE 53281,HUE:PRINT CHR$(147):POKE 53281,C"
  },
  {
    "id": "map-E4E0",
    "address_start": 58592,
    "address_end": 58592,
    "hex_start": "$E4E0",
    "hex_end": "$E4E0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58592         $E4E0\nPause after Finding a File on Cassette\n\nThis routine is a patch to the routine which finds a file on cassette.\nAfter the file is found, the message FILETITLE FOUND appears on the\nscreen.  On the original versions of the Kernal, the user would then\nhave to hit the Commodore key to continue the load.  On the newer\nversions, this patch causes a slight pause after the tape file is\nround, during which time a keypress is looked for.  If a key is\npressed, the loading process continues immediately.  If it is not, the\nload continues by itself after the end of the pause."
  },
  {
    "id": "map-E4EC",
    "address_start": 58604,
    "address_end": 58604,
    "hex_start": "$E4EC",
    "hex_end": "$E4EC",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58604         $E4EC\nBaud Rate Table for European (PAL) Standard Monitors\n\nThis table of prescaler values was added to later Kernal versions to\nallow the same Kernal software to be used with either U.S. or European\n64s.  It contains the values which are required to obtain interrupts\nat the proper frequency for the standard RS-232 baud rates, and\ncorresponds exactly in format to the table of values for the U.S.\n(NTSC) monitor format at 65218 ($FEC2).  Separate tables are required\nbecause the prescaler values are derived from dividing the system\nclock rate by the baud rate, and PAL machines operate with a slightly\nslower clock frequency."
  },
  {
    "id": "map-E500",
    "address_start": 58624,
    "address_end": 58624,
    "hex_start": "$E500",
    "hex_end": "$E500",
    "label": "IOBASE",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58624         $E500          IOBASE\nStore Base Address of Memory-Mapped I/O Devices in .X and .Y Registers\n\nThis is one of the documented Kernal routines for which there is a\nvector in the jump table at 65523 ($FFF3).\n\nWhen called, this routine sets the .X register to the low byte of the\nbase address of the memory-mapped I/O devices, and puts the high byte\nin the .Y register.  This allows a user to set up a zero-page pointer\nto the device, and to load and store indirectly through that pointer.\nA program which uses this method, rather than directly accessing such\ndevices could be made to function without change on future Commodore\nmodels, even though the I/O chips may be addressed at different\nlocations.  This of course assumes that the CIA or a similar chip will\nbe used.  This routine is of limited value for creating software that\nis compatible with both the VIC-20 and the 64 because of the\ndifferences in the VIA I/O chip that the VIC uses.\n\nThe current version of this routine loads the .X register with a 0,\nand the .Y register with 220 ($DC), thus pointing to CIA #1, which is\nat 56320 ($DC00)."
  },
  {
    "id": "map-E505",
    "address_start": 58629,
    "address_end": 58629,
    "hex_start": "$E505",
    "hex_end": "$E505",
    "label": "SCREEN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58629         $E505          SCREEN\nStore Number of Screen Rows and Columns in .Y and .X\n\nThis is a documented Kernal routine which is vectored in the jump\ntable at 65517 ($FFED), and is provided to allow for program\ncompatibility between computers.\n\nWhen called, this subroutine returns the number of screen columns in\nthe .X register, and the number of screen rows in .Y.  Thus, a program\ncan detect the screen format of the machine on which it is running,\nand make sure that text output is formatted accordingly.\n\nThe present version of this routine loads the .X register with 40\n($28) and the .Y register with 25 ($19)."
  },
  {
    "id": "map-E50A",
    "address_start": 58634,
    "address_end": 58634,
    "hex_start": "$E50A",
    "hex_end": "$E50A",
    "label": "PLOT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58634         $E50A          PLOT\nRead/Set Location of the Cursor\n\nThe jump table entry for this documented Kernal is at 65520 ($FFF0).\n\nThe routine allows the user to read or set the position of the cursor.\nIf the carry flag is set with the SEC instruction before calling this\nsubroutine, cursor column (X position) will be returned in the .X\nregister, and the cursor row (Y position) will be returned in the .Y\nregister.  If the carry flag is cleared with a CLC instruction before\nentering this routine, and the .Y and .X registers are loaded with the\ndesired row and column positions respectively, this routine will set\nthe cursor position accordingly.\n\nThe current read routine loads .X and .Y from locations 214 ($D6) and\n211 ($D3) respectively.  The cursor set routine stores .X and .Y in\nthese locations, and calls the routine that sets the screen pointers\nat 58732 ($E56C).\n\nThe user can access this routine from BASIC by loading the .X, .Y, and\n.P register values desired to the save area starting at 780 ($30C)."
  },
  {
    "id": "map-E518",
    "address_start": 58648,
    "address_end": 58648,
    "hex_start": "$E518",
    "hex_end": "$E518",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58648         $E518\nInitialize Screen and Keyboard\n\nThis is the original CINT Kernal routine, to which additions were made\nin later versions of the Kernal.\n\nAfter calling the routine at 58784 ($E5A0) to set up default I/O\nvalues, this routine initializes the cursor blink flags, the keyboard\ndecode vector, the key repeat delay and frequency counters, the\ncurrent color code, and maximum keyboard buffer size.  It then falls\nthrough to the next routine."
  },
  {
    "id": "map-E544",
    "address_start": 58692,
    "address_end": 58692,
    "hex_start": "$E544",
    "hex_end": "$E544",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58692         $E544\nInitialize the Screen Line Link Table and Clear the Screen\n\nThis routine initializes the screen line link table at 217 ($D9),\nclears the screen, and clears the Color RAM to the background color.\nIt falls through to the next routine."
  },
  {
    "id": "map-E566",
    "address_start": 58726,
    "address_end": 58726,
    "hex_start": "$E566",
    "hex_end": "$E566",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58726         $E566\nHome the Cursor\n\nThis routine sets PNTR (211, $D3) and TBLX (214, $D6) to 0, and falls\nthrough to the next routine."
  },
  {
    "id": "map-E56C",
    "address_start": 58732,
    "address_end": 58732,
    "hex_start": "$E56C",
    "hex_end": "$E56C",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58732         $E56C\nSet Pointer to Current Screen Line\n\nThis routine sets the pointer PNT (209, $D1) to the address of the\nfirst byte of the current logical line.  In figuring this address, it\ntakes into account the status of the screen line link table, which can\nindicate that two physical lines should be joined as one logical line."
  },
  {
    "id": "map-E5A0",
    "address_start": 58784,
    "address_end": 58784,
    "hex_start": "$E5A0",
    "hex_end": "$E5A0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58784         $E5A0\nSet Default I/O Devices and Set Default Values for VIC-II Chip\nRegisters\n\nThis routine sets the keyboard and screen as the current input and\noutput devices.  It then writes the default values found in the table\nat 60601 ($ECB9) to the VIC-II chip."
  },
  {
    "id": "map-E5B4",
    "address_start": 58804,
    "address_end": 58804,
    "hex_start": "$E5B4",
    "hex_end": "$E5B4",
    "label": "LP2",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58804         $E5B4          LP2\nGet a Character from the Keyboard Buffer\n\nThis routine transfers the first character from the keybard buffer to\nthe .A register, bumps the rest of the characters one place up in\nline, and decrements the pointer, showing how many characters are\nwaiting in the buffer."
  },
  {
    "id": "map-E5CA",
    "address_start": 58826,
    "address_end": 58826,
    "hex_start": "$E5CA",
    "hex_end": "$E5CA",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58826         $E5CA\nWait for a Carriage Return from the Keyboard\n\nThis subroutine is called by the portion of the CHKIN routine that\nhandles keyboard input.  It turns the cursor on, gets characters, and\nechoes them to the screen until a carriage return has been entered.\nIt also looks for the shifted RUN/STOP key, and forces the output of\nthe commands LOAD and RUN if it finds it."
  },
  {
    "id": "map-E632",
    "address_start": 58930,
    "address_end": 58930,
    "hex_start": "$E632",
    "hex_end": "$E632",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "58930         $E632\nInput a Character from Screen or Keyboard\n\nThis routine is the portion of the Kernal CHRIN routine that handles\ninput from the keyboard and screen devices.  CHRIN gets one byte at a\ntime from the current screen position, or inputs a whole line from the\nkeyboard and returns it one byte at a time."
  },
  {
    "id": "map-E684",
    "address_start": 59012,
    "address_end": 59012,
    "hex_start": "$E684",
    "hex_end": "$E684",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59012         $E684\nTest for Quote Marks\n\nThis subroutine checks if the current character is a quotation mark,\nand if it is, toggles the quote switch at 212 ($D4)."
  },
  {
    "id": "map-E691",
    "address_start": 59025,
    "address_end": 59025,
    "hex_start": "$E691",
    "hex_end": "$E691",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59025         $E691\nAdd a Character to the Screen\n\nThis is part of the routine that outputs a character to the screen.\nIt puts printable characters into screen memory."
  },
  {
    "id": "map-E6A8",
    "address_start": 59048,
    "address_end": 59048,
    "hex_start": "$E6A8",
    "hex_end": "$E6A8",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59048         $E6A8\nReturn from Outputting a Character to the Screen\n\nThis is the common exit point for the screen portion of the CHROUT\nroutine."
  },
  {
    "id": "map-E6B6",
    "address_start": 59062,
    "address_end": 59062,
    "hex_start": "$E6B6",
    "hex_end": "$E6B6",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59062         $E6B6\nAdvance the Cursor\n\nThis routine advances the cursor, and provides for such things as\nscrolling at the end of the screen, and inserting a blank line in\norder to add another physical line to the current logical line."
  },
  {
    "id": "map-E701",
    "address_start": 59137,
    "address_end": 59137,
    "hex_start": "$E701",
    "hex_end": "$E701",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59137         $E701\nMove Cursor Back over a 40-Column Line Boundary"
  },
  {
    "id": "map-E716",
    "address_start": 59158,
    "address_end": 59158,
    "hex_start": "$E716",
    "hex_end": "$E716",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59158         $E716\nOutput to the Screen\n\nThis is the main entry point for the part of CHROUT that handles\noutput to the screen device.  It takes an ASCII character number, and\ntests if the character is printable.  If it is, it prints it (taking\ninto consideration the reverse flag, if any inserts are left, etc.).\nIf it is a nonprinting character, the routine performs the appropriate\ncursor movement, color change, screen clearing, or whatever else might\nbe indicated."
  },
  {
    "id": "map-E87C",
    "address_start": 59516,
    "address_end": 59516,
    "hex_start": "$E87C",
    "hex_end": "$E87C",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59516         $E87C\nMove Cursor to Next Line\n\nThis subroutine moves the cursor down to the next line if possible, or\nscrolls the screen if the cursor is on the last line."
  },
  {
    "id": "map-E891",
    "address_start": 59537,
    "address_end": 59537,
    "hex_start": "$E891",
    "hex_end": "$E891",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59537         $E891\nOutput a Carriage Return\n\nA carriage return is performed by clearing insert mode, reverse video,\nand quote mode, and moving the cursor to the next line."
  },
  {
    "id": "map-E8A1",
    "address_start": 59553,
    "address_end": 59553,
    "hex_start": "$E8A1",
    "hex_end": "$E8A1",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59553         $E8A1\nIf at the Beginning of a Screen Line, Move Cursor to Previous Line"
  },
  {
    "id": "map-E8B3",
    "address_start": 59571,
    "address_end": 59571,
    "hex_start": "$E8B3",
    "hex_end": "$E8B3",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59571         $E8B3\nIf at the End of a Screen Line, Move Cursor to the Next Line"
  },
  {
    "id": "map-E8CB",
    "address_start": 59595,
    "address_end": 59595,
    "hex_start": "$E8CB",
    "hex_end": "$E8CB",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59595         $E8CB\nCheck for a Color Change\n\nThis routine is used by the screen CHROUT routine to check if the\ncharacter to be printed is one that causes the current foreground\ncolor to change (such as the CTRL-1 combination)."
  },
  {
    "id": "map-E8D1",
    "address_start": 59601,
    "address_end": 59601,
    "hex_start": "$E8D1",
    "hex_end": "$E8D1",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59601         $E8D1\nPETASCII Color Code Equivalent Table\n\nThis table gives the PETASCII values of the color change characters\nfor each of the 16 possible colors.  These values are:\n\n144 ($90)  Change to color 0 (black)\n  5 ($05)  Change to color 0 (white)\n 28 ($1C)  Change to color 0 (red)\n159 ($9F)  Change to color 0 (cyan)\n156 ($9C)  Change to color 0 (purple)\n 30 ($1E)  Change to color 0 (green)\n 31 ($1F)  Change to color 0 (blue)\n158 ($9E)  Change to color 0 (yellow)\n129 ($81)  Change to color 0 (orange)\n149 ($95)  Change to color 0 (brown)\n150 ($96)  Change to color 0 (light red)\n151 ($97)  Change to color 0 (dark gray)\n152 ($98)  Change to color 0 (medium gray)\n153 ($99)  Change to color 0 (light green)\n154 ($9A)  Change to color 0 (light blue)\n155 ($9B)  Change to color 0 (light gray)"
  },
  {
    "id": "map-E8EA",
    "address_start": 59626,
    "address_end": 59626,
    "hex_start": "$E8EA",
    "hex_end": "$E8EA",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59626         $E8EA\nScroll Screen\n\nThis subroutine moves all of the screen lines up, so that a blank line\nis created at the bottom of the screen and the top screen line is\nlost.  If the top logical line is two physical lines long, all lines\nare moved up two lines.  Holding down the CTRL key will cause a brief\npause after the scroll."
  },
  {
    "id": "map-E965",
    "address_start": 59749,
    "address_end": 59749,
    "hex_start": "$E965",
    "hex_end": "$E965",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59749         $E965\nInsert a Blank Line on the Screen\n\nThis subroutine is used when INSERTing to add a blank physical line to\na logical line."
  },
  {
    "id": "map-E9C8",
    "address_start": 59848,
    "address_end": 59848,
    "hex_start": "$E9C8",
    "hex_end": "$E9C8",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59848         $E9C8\nMove Screen Line\n\nThis subroutine is used by the scroll routine to move one screen line\n(and its associated Color RAM) up a line."
  },
  {
    "id": "map-E9E0",
    "address_start": 59872,
    "address_end": 59872,
    "hex_start": "$E9E0",
    "hex_end": "$E9E0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59872         $E9E0\nSet Temporary Color Pointer for Scrolling\n\nThis subrouting sets up a pointer in 17-175 ($AE-$AF) to the Color RAM\naddress that corresponds to the temporary screen line address in\n172-173 ($AC-$AD)."
  },
  {
    "id": "map-E9F0",
    "address_start": 59888,
    "address_end": 59888,
    "hex_start": "$E9F0",
    "hex_end": "$E9F0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59888         $E9F0\nSet Pointer to Screen Address of Start of Line\n\nThis subroutine puts the address of the first byte of the screen line\ndesignated by the .X register into locations 209-210 ($D1-$D2)."
  },
  {
    "id": "map-E9FF",
    "address_start": 59903,
    "address_end": 59903,
    "hex_start": "$E9FF",
    "hex_end": "$E9FF",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59903         $E9FF\nClear Screen Line\n\nThis subroutine writes space characters to an entire line of screen\nmemory, and clears the corresponding line of color memory to color in\nBackground Color Register 0 (53281, $D021)."
  },
  {
    "id": "map-EA13",
    "address_start": 59923,
    "address_end": 59923,
    "hex_start": "$EA13",
    "hex_end": "$EA13",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59923         $EA13\nSet Cursor Blink Timing and Color Memory Address for Print to Screen\n\nThis subroutine sets the cursor blink countdown and sets the pointer\nto Color RAM.  It then falls through to the next routine."
  },
  {
    "id": "map-EA1C",
    "address_start": 59932,
    "address_end": 59932,
    "hex_start": "$EA1C",
    "hex_end": "$EA1C",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59932         $EA1C\nStore to Screen\n\nThis routine stores the character in the .A register to the screen\naddress pointed to by 209 ($D1), and stores the color in the .X\nregister to the address pointed to by 243 ($F3)."
  },
  {
    "id": "map-EA24",
    "address_start": 59940,
    "address_end": 59940,
    "hex_start": "$EA24",
    "hex_end": "$EA24",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59940         $EA24\nSynchronize Color RAM Pointer to Screen Line Pointer\n\nThis subroutine sets the pointer at 243 ($F3) to the address of the\nbeginning of the line of Color RAM which corresponds to the current\nline of screen RAM (whose pointer is at 209 ($D1))."
  },
  {
    "id": "map-EA31",
    "address_start": 59953,
    "address_end": 59953,
    "hex_start": "$EA31",
    "hex_end": "$EA31",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "59953         $EA31\nIRQ Interrupt Entry\n\nThis is the entry point to the standard IRQ interrupt handler.  Timer\nA of CIA #1 is set at power-on to cause an IRQ interrupt to occur\nevery 1/60 second.  When the interrupt occurs, program flow is\ntransferred here via the CINV vector at 788 ($314).  This routine\nupdates the software clock at 160-162 ($A0-$A2), handles the cursor\nflash, and maintains the tape interlock which keeps the cassette motor\non if a button is pushed and the interlock flag is on.  Finally, it\ncalls the keyboard scan routine, which checks the keyboard and puts\nany character it finds into the keyboard buffer."
  },
  {
    "id": "map-EA87",
    "address_start": 60039,
    "address_end": 60039,
    "hex_start": "$EA87",
    "hex_end": "$EA87",
    "label": "SCNKEY",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60039         $EA87          SCNKEY\nRead the Keyboard\n\nThis subroutine is called by the IRQ interrupt handler above to read\nthe keyboard device which is connected to CIA #1 (see entry for 56320\n($DC00) for details on how to read the keyboard).\n\nIt is the Kernal routine SCNKEY which can be entered from the jump\ntable at 65439 ($FF9F).  This routine returns the keycode of the key\ncurrently being pressed in 203 ($CB), sets the shift/control flag if\nappropriate, and jumps through the vector at 655 ($28F) to the routine\nthat sets up the proper table to translate the keycode to PETASCII.\nIt concludes with the next routine, which places the PETASCII value of\nthe character in the keyboard buffer."
  },
  {
    "id": "map-EAE0",
    "address_start": 60128,
    "address_end": 60128,
    "hex_start": "$EAE0",
    "hex_end": "$EAE0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60128         $EAE0\nDecode the Keystroke and Place its ASCII Value in the Keyboard Buffer\n\nThis is the continuation of the IRQ keyscan routine.  It decodes the\nkeycode with the proper PETASCII table, and compares it with the last\nkeystroke.  If if is the same, it checks to see if it is okay to\nrepeat the character without waiting for the key to be let up.  If the\ncharacter should be printed, it is moved to the end of the keyboard\nbuffer at 631 ($277)."
  },
  {
    "id": "map-Eb48",
    "address_start": 60232,
    "address_end": 60232,
    "hex_start": "$Eb48",
    "hex_end": "$Eb48",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60232         $Eb48\nSet Up the Proper Keyboard Decode Table\n\nThis routine is pointed to by the vector at 655 ($28F).  Its function\nis to read the shift/control flag at 653 ($28D), and set the value of\nthe decode table pointer at 245 ($F5) accordingly.\n\nFirst it checks if the SHIFT/Commodore logo combination was pressed,\nand if the toggle enable at 657 (291) will allow a change, the\ncharacter set will be changed to lowercase/uppercase or\nuppercase/graphics by changing the VIC Memory Control Register at\n53272 ($D018), and no character will be printed.\n\nNext it sets the decode table pointer.  There are 64 keys, and each\ncan have four different PETASCII values, depending on whether the key\nis pressed by itself, or in combination with the SHIFT, CTRL, or\nCommodore logo keys.  Therefore, there are four tables of 64 entries\neach to translate the keycode to PETASCII:  the standard table, the\nSHIFT table, the Commodore logo table, and the CONTROL table.  The\nroutine will set up the pointer for the appropriate table, depending\non whether the SHIFT, CTRL, or logo key was pressed.  The CTRL key\ntakes precedence, so that if another of these keys is pressed along\nwith the CTRL key, the CONTROL table is used."
  },
  {
    "id": "map-EB79",
    "address_start": 60281,
    "address_end": 60281,
    "hex_start": "$EB79",
    "hex_end": "$EB79",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60281         $EB79\nKeyboard Decode Table Vectors\n\nThis table contains the two-byte addresses of the four keyboard decode\ntables in low-byte, high-byte format."
  },
  {
    "id": "map-EB81",
    "address_start": 60289,
    "address_end": 60289,
    "hex_start": "$EB81",
    "hex_end": "$EB81",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60289         $EB81\nStandard Keyboard Matrix Decode Table\n\nThis table contains the 64 PETASCII values for the standard keyboard,\none for each key which is struck by itself.  The table is in keycode\norder (see the keycode table in Appendix H for the correspondence of\nkeycode to key).  A 65th byte with the value of 255 ($FF) marks the\nend of the table (this corresponds to a keypress value of 64, no key\npressed)."
  },
  {
    "id": "map-EBC2",
    "address_start": 60354,
    "address_end": 60354,
    "hex_start": "$EBC2",
    "hex_end": "$EBC2",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60354         $EBC2\nSHIFTed Keyboard Matrix Decode Table\n\nThis table contains the 64 PETASCII values for the shifted keyboard,\none for each key which is struck while the SHIFT key is pressed.  The\ntable is in keycode order (see the keycode table in Appendix H for the\ncorrespondence of keycode to key).  A 65th byte with the value of 255\n($FF) marks the end of the table (this corresponds to a keypress value\nof 64, no key pressed)."
  },
  {
    "id": "map-EC03",
    "address_start": 60419,
    "address_end": 60419,
    "hex_start": "$EC03",
    "hex_end": "$EC03",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60419         $EC03\nCommodore Logo Keyboard Matrix Decode Table\n\nThis table contains the 64 PETASCII values for the logo keyboard, one\nfor each key which is struck while the Commodore logo key is pressed.\nThe table is in keycode order (see the keycode table in Appendix H for\nthe correspondence of keycode to key).  A 65th byte with the value of\n255 ($FF) marks the end of the table (this corresponds to a keypress\nvalue of 64, no key pressed)."
  },
  {
    "id": "map-EC44",
    "address_start": 60484,
    "address_end": 60484,
    "hex_start": "$EC44",
    "hex_end": "$EC44",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60484         $EC44\nSet Lowercase/Uppercase or Uppercase/Graphics Character Set\n\nThe part of the Kernal CHROUT routine that outputs to the screen uses\nthis subroutine to check for the special nonprinting characters that\nswitch the character set (CHR$(14) and CHR$(142)).  If one of these is\nthe character to be printed, this routine makes the switch by setting\nthe location 53272 ($D018) accordingly."
  },
  {
    "id": "map-EC5E",
    "address_start": 60510,
    "address_end": 60510,
    "hex_start": "$EC5E",
    "hex_end": "$EC5E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60510         $EC5E\nSet Flag to Enable or Disable Switching Character Sets\n\nThis subroutine is also used to check for special characters to print.\nIn this case, it checks for the characters that enable or disable the\nSHIFT/logo combination from toggling the character set currently in\nuse (CHR$(8) and CHR$(9)).  If one of these is to be printed, the flag\nat 657 ($291) is changed."
  },
  {
    "id": "map-EC78",
    "address_start": 60536,
    "address_end": 60536,
    "hex_start": "$EC78",
    "hex_end": "$EC78",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60536         $EC78\nControl Keyboard Matrix Decode Table\n\nThis table contains the 64 PETASCII values for the Control keyboard,\none for each key which is struck while the CTRL key is pressed.  The\ntable is in keycode order (see the keycode table in Appendix H for the\ncorrespondence of keycode to key).  A 65th byte with the value of 255\n($FF) marks the end of the table (this corresponds to a keypress value\nof 64, no key pressed).\n\nThe only keys generally struck in combination with the CTRL key are\nthe ones that change the colors on the top row of the keyboard, but\nthis doesn't necessarily mean that the other CTRL key combinations\ndon't do anything.  On the contrary, looking at the values in this\ntable, you can see that any of the first 32 values in the PETASCII\ntable can be produced by some combination of the CTRL key and another\nkey.  CTRL-@ produces a CHR$(0).  CTRL-A through CTRL-Z produce\nCHR$(1) through CHR$(26).  Ctrl-: is the same as CHR$(27), CTRL-Lira\n(that's the slashed-L British pound sign) produces CHR$(28), CTRL-;\nequals CHR$(29), CTRL-up arrow produces CHR$(30), and CTRL-= produces\nCHR$(31).\n\nAny of these combinations produce the same effect as the CHR$(X)\nstatement.  For examble, CTRL-; moves the cursor over to the right,\nCTRL-N switches to lowercase, CTRL-R turns on reverse video, and\nCTRL-E changes the printing to white."
  },
  {
    "id": "map-ECB9",
    "address_start": 60601,
    "address_end": 60601,
    "hex_start": "$ECB9",
    "hex_end": "$ECB9",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60601         $ECB9\nVideo Chip Register Default Table\n\nThis table contains the default values that are stored in the 47\nVIC-II chip registers.  It is interesting to note that this table\nappears to be incomplete.  While Sprite Color Registers 0-6 are\ninitialized to values of 1-7, Sprite Color Register 7 is initialized\nto 76--the ASCII value of the letter L which begins on the next table."
  },
  {
    "id": "map-ECE7",
    "address_start": 60647,
    "address_end": 60647,
    "hex_start": "$ECE7",
    "hex_end": "$ECE7",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60647         $ECE7\nText for Keyboard Buffer When SHIFT/RUN is Pressed\n\nWhen the SHIFT and RUN keys are pressed, the ASCII text stored here is\nforced into the keyboard buffer.  That text is LOAD, carriage return,\nRUN, carriage return."
  },
  {
    "id": "map-ECF0",
    "address_start": 60656,
    "address_end": 60656,
    "hex_start": "$ECF0",
    "hex_end": "$ECF0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60656         $ECF0\nLow Byte Table of Screen Line Addresses\n\nThis table holds the low byte of the screen address for lines 0-24.\nThe high byte is derived from combining a value from the screen line\nlink table at 217 ($D9) with the pointer to screen memory at 648\n($288)."
  },
  {
    "id": "map-ED09",
    "address_start": 60681,
    "address_end": 60681,
    "hex_start": "$ED09",
    "hex_end": "$ED09",
    "label": "TALK",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60681         $ED09          TALK\nSend TALK to a Device on the Serial Bus\n\nThis is a documented Kernal routine whose entry in the jump table is\n65460 ($FFB4).  When called, it ORs the device number in the\nAccumulator with the TALK code (64, $40) and sends it on the serial\nbus.  This commands the device to TALK."
  },
  {
    "id": "map-ED0C",
    "address_start": 60684,
    "address_end": 60684,
    "hex_start": "$ED0C",
    "hex_end": "$ED0C",
    "label": "LISTEN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60684         $ED0C          LISTEN\n\nThis is a documented Kernal routine whose entry in the jump table is\n65457 ($FFB1).  When called, it ORs the device number in the\nAccumulator with the LISTEN code (32, $20) and sends it on the serial\nbus.  This commands the device to LISTEN."
  },
  {
    "id": "map-ED11",
    "address_start": 60689,
    "address_end": 60689,
    "hex_start": "$ED11",
    "hex_end": "$ED11",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60689         $ED11\nSend Command Code to a Device on the Serial Bus\n\nThis subroutine is used in common by many Kernal routines to send the\ncommand code in the Accumulator to a device on the serial bus."
  },
  {
    "id": "map-ED40",
    "address_start": 60736,
    "address_end": 60736,
    "hex_start": "$ED40",
    "hex_end": "$ED40",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60736         $ED40\nSend a Byte on the Serial Bus\n\nThis subroutine is used in common by several Kernal routines to send\nthe byte in the serial bus character buffer at 149 ($95) on the serial\nbus."
  },
  {
    "id": "map-EDB0",
    "address_start": 60848,
    "address_end": 60848,
    "hex_start": "$EDB0",
    "hex_end": "$EDB0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60848         $EDB0\nTime-Out Error on Serial Bus\n\nThis subroutine handles the case when the device does not respond by\nsetting the DEVICE NOT PRESENT error code and exiting."
  },
  {
    "id": "map-EDB9",
    "address_start": 60857,
    "address_end": 60857,
    "hex_start": "$EDB9",
    "hex_end": "$EDB9",
    "label": "SECOND",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60857         $EDB9          SECOND\nSend a Secondary Address to a Device on the Serial Bus after LISTEN\n\nThis is a documented Kernal routine that can be entered from the jump\ntable at 65427 ($FF93).  It sends a secondary address from the\nAccumulator to the device on the serial bus that has just been\ncommanded to LISTEN.  This is usually done to give the device more\nparticular instructions on how the I/O is to be carried out before\ninformation is sent."
  },
  {
    "id": "map-EDC7",
    "address_start": 60871,
    "address_end": 60871,
    "hex_start": "$EDC7",
    "hex_end": "$EDC7",
    "label": "TKSA",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60871         $EDC7          TKSA\nSend a Secondary Address to a Device on the Serial Bus after TALK\n\nThis is a documented Kernal routine that can be entered from the jump\ntable at 65430 ($FF96).  It sends a secondary address from the\nAccumulator to the device on the serial bus that has just been\ncommanded to TALK.  This is usually done to give the device more\nparticular instructions on how the I/O is to be carried out before\ninformation is sent."
  },
  {
    "id": "map-EDDD",
    "address_start": 60893,
    "address_end": 60893,
    "hex_start": "$EDDD",
    "hex_end": "$EDDD",
    "label": "CIOUT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60893         $EDDD          CIOUT\nSend a Byte to an I/O Device over the Serial Bus\n\nThis is a documented Kernal routine which can be entered from the jump\ntable at 65448 ($FFA8).  Its purpose is to send a byte of data over\nthe serial bus.  In order for the data to be received, the serial\ndevice must have first been commanded to LISTEN and been given a\nsecondary address if necessary.  This routine always buffers the\ncurrent character, and defers sending it until the next byte is\nbuffered.  When the UNLISTEN command is sent, the last byte will be\nsent with an End or Identify (EOI)."
  },
  {
    "id": "map-EDEF",
    "address_start": 60911,
    "address_end": 60911,
    "hex_start": "$EDEF",
    "hex_end": "$EDEF",
    "label": "UNTLK",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60911         $EDEF          UNTLK\nSend UNTALK to a Device on the Serial Bus\n\nThis is a documented Kernal routine whose entry in the jump table is\n65451 ($FFAB).  When called, it sends the UNTALK code (95, $5F) on the\nserial bus.  This commands any TALKer on the bus to stop sending data."
  },
  {
    "id": "map-EDFE",
    "address_start": 60926,
    "address_end": 60926,
    "hex_start": "$EDFE",
    "hex_end": "$EDFE",
    "label": "UNLSN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60926         $EDFE          UNLSN\nSend UNLISTED to a Device on the Serial Bus\n\nThis is a documented Kernal routine whose entry in the jump table is\n65454 ($FFAE).  It sends the UNLISTEN code (63, $3F) on the serial\nbus.  This commands any LISTENers to get off the serial bus, and frees\nup the bus for other users."
  },
  {
    "id": "map-EE13",
    "address_start": 60947,
    "address_end": 60947,
    "hex_start": "$EE13",
    "hex_end": "$EE13",
    "label": "ACPTR",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "60947         $EE13          ACPTR\nReceive a Byte of Data from a Device on the Serial Bus\n\nThis is a documented Kernal routine whose entry point in the jump\ntable is 65445 ($FFA5).  When called, it will get a byte of data from\nthe current TALKer on the serial bus and store it in the Accumulator.\nIn order to receive the data, the device must have previously been\nsent a command to TALK and a secondary address if it needs one."
  },
  {
    "id": "map-EE85",
    "address_start": 61061,
    "address_end": 61061,
    "hex_start": "$EE85",
    "hex_end": "$EE85",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61061         $EE85\nSet the Serial Clock Line Low (Active)\n\nThis subroutine clears the serial bus clock pulse output bit (Bit 4 of\nCIA #2 Data Port A at 56576 ($DD00))."
  },
  {
    "id": "map-EE8E",
    "address_start": 61070,
    "address_end": 61070,
    "hex_start": "$EE8E",
    "hex_end": "$EE8E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61070         $EE8E\nSet the Serial Clock Line High (Inactive)\n\nThis subroutine sets the serial bus clock pulse output bit to 1 (Bit 4\nof CIA #2 Data Port A at 56576 ($DD00))."
  },
  {
    "id": "map-EE97",
    "address_start": 61079,
    "address_end": 61079,
    "hex_start": "$EE97",
    "hex_end": "$EE97",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61079         $EE97\nSet Serial Bus Data Output Line Low\n\nThis subroutine clears the serial bus data output to 0 (Bit 5 of CIA\n#2 Data Port A at 56576 ($DD00))."
  },
  {
    "id": "map-EEA9",
    "address_start": 61097,
    "address_end": 61097,
    "hex_start": "$EEA9",
    "hex_end": "$EEA9",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61097         $EEA9\nGet Serial Bus Data Input Bit and Clock Pulse Input Bit\n\nThis subroutine reads the serial bus data input bit and clock pulse\ninput bit (Bits 7 and 6 of CIA #2 Data Port A at 56576 ($DD00)), and\nreturns the data bit in the Carry flag and the clock bit in the\nNegative flag."
  },
  {
    "id": "map-EEB3",
    "address_start": 61107,
    "address_end": 61107,
    "hex_start": "$EEB3",
    "hex_end": "$EEB3",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61107         $EEB3\nPerform a One-Millisecond Delay"
  },
  {
    "id": "map-EEBB",
    "address_start": 61115,
    "address_end": 61115,
    "hex_start": "$EEBB",
    "hex_end": "$EEBB",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61115         $EEBB\nSend Next RS-232 Bit (NMI)\n\nThis subroutine is called by the NMI interrupt handler routine to send\nthe next bit of data to the RS-232 device."
  },
  {
    "id": "map-EF2E",
    "address_start": 61230,
    "address_end": 61230,
    "hex_start": "$EF2E",
    "hex_end": "$EF2E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61230         $EF2E\nHandle RS-232 Errors\n\nThis subroutine sets the appropriate error bits in the status register\nat 663 ($297).\n\n61258         $#F4A\nSet the Word Length For the Current RS-232 Character\n\nThis routine takes the number of data bits to send per RS-232\ncharacter from the control register and puts it into the .X register\nfor use by the RS-232 routines."
  },
  {
    "id": "map-EF59",
    "address_start": 61273,
    "address_end": 61273,
    "hex_start": "$EF59",
    "hex_end": "$EF59",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61273         $EF59\nReceive Next RS-232 Bit (NMI)\n\nThis routine is called by the NMI interrupt handler routine to receive\nthe next bit of data from the RS-232 device."
  },
  {
    "id": "map-EF7E",
    "address_start": 61310,
    "address_end": 61310,
    "hex_start": "$EF7E",
    "hex_end": "$EF7E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61310         $EF7E\nSetup to Receive a New Byte from RS-232"
  },
  {
    "id": "map-EF90",
    "address_start": 61328,
    "address_end": 61328,
    "hex_start": "$EF90",
    "hex_end": "$EF90",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61328         $EF90\nTest If Start Bit Received from RS-232"
  },
  {
    "id": "map-EF97",
    "address_start": 61335,
    "address_end": 61335,
    "hex_start": "$EF97",
    "hex_end": "$EF97",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61335         $EF97\nPut a Byte of Received Data into RS-232 Receive Buffer\n\nThis routine checks for a Receive Buffer Overrun, stores the byte just\nreceived in the RS-232 receive buffer, and checks for Parity Error,\nFraming Error, or Break Detected Error.  It then sets up to receive\nthe next byte."
  },
  {
    "id": "map-EFE1",
    "address_start": 61409,
    "address_end": 61409,
    "hex_start": "$EFE1",
    "hex_end": "$EFE1",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61409         $EFE1\nCHKOUT for the RS-232 device\n\nThe Kernal CHKOUT routine calls this subroutine to define the RS-232\ndevice's logical file as an output channel.  Before this can be done,\nthe logical file must first be OPENed."
  },
  {
    "id": "map-F014",
    "address_start": 61460,
    "address_end": 61460,
    "hex_start": "$F014",
    "hex_end": "$F014",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61460         $F014\nCHROUT for the RS-232 Device\n\nThe Kernal CHROUT routine calls this subroutine to output a character\nto the RS-232 device.  After the logical file has been OPENed and set\nfor output using CHKOUT, the CHROUT routine is used to actually send a\nbyte of data."
  },
  {
    "id": "map-F04D",
    "address_start": 61517,
    "address_end": 61517,
    "hex_start": "$F04D",
    "hex_end": "$F04D",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61517         $F04D\nCHKIN for the RS-232 Device\n\nThe Kernal CHKIN routine calls this subroutine to define the RS-232\ndevice's logical file as an input channel.  A prerequisite for this is\nthat the logical file first be OPENed."
  },
  {
    "id": "map-F086",
    "address_start": 61574,
    "address_end": 61574,
    "hex_start": "$F086",
    "hex_end": "$F086",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61574         $F086\nGETIN for the RS-232 Device\n\nThe Kernal GETIN routine calls this subroutine to remove the next byte\nof data from the RS-232 receive buffer and return it in the\nAccumulator.  The routine checks for the Receive Buffer Empty Error.\nIt is also called by the Kernal CHRIN routine, which essentially does\nthe same thing as GETIN for the RS-232 device."
  },
  {
    "id": "map-F0A4",
    "address_start": 61604,
    "address_end": 61604,
    "hex_start": "$F0A4",
    "hex_end": "$F0A4",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61604         $F0A4\nStop CIA #2 RS-232 NMIs for Serial/Cassette Routines\n\nThis subroutine turns off the NMIs that drive the RS-232 routines\nbefore any I/O is done using the serial bus or cassette device.  Such\ninterrupts could throw off the timing of those I/O routines, and\ninterfere with the transmission of data."
  },
  {
    "id": "map-F0BD",
    "address_start": 61629,
    "address_end": 61629,
    "hex_start": "$F0BD",
    "hex_end": "$F0BD",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61629         $F0BD\nKernal Control Messages\n\nThe ASCII text of the Kernal I/O control messages is stored here.  The\nlast byte of every message has Bit 7 set to 1 (ASCII value + 128).\nThe messages are:\n\nI/O ERROR\nSEARCHING\nFOR\nPRESS PLAY ON TAPE\nPRESS RECORD & PLAY ON TAPE\nLOADING\nSAVING\nVERIFYING\nFOUND\nOK"
  },
  {
    "id": "map-F12B",
    "address_start": 61739,
    "address_end": 61739,
    "hex_start": "$F12B",
    "hex_end": "$F12B",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61739         $F12B\nPrint Kernal Error Message if in Direct Mode\n\nThis routine first checks location 157 ($9D) to see if the messages\nare enabled.  If they are, it prints the message indexed by the .Y\nregister."
  },
  {
    "id": "map-F13E",
    "address_start": 61758,
    "address_end": 61758,
    "hex_start": "$F13E",
    "hex_end": "$F13E",
    "label": "GETIN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61758         $F13E          GETIN\nGet One Byte from the Input Device\n\nThis is a documented Kernal routine whose jump table entry point is at\n65508 ($FFE4).  The routine jumps through a RAM vector at 810 ($32A).\nIts function is to get a character from the current input device\n(whose device number is stored at 153 ($99)).  In practive, it\noperates identically to the CHRIN routine below for all devices except\nfor the keyboard.  If the keyboard is the current input device, this\nroutine gets one character from the keyboard buffer at 631 ($277).  It\ndepends on the IRQ interrupt routine to rad the keyboard and put\ncharacters into the buffer."
  },
  {
    "id": "map-F157",
    "address_start": 61783,
    "address_end": 61783,
    "hex_start": "$F157",
    "hex_end": "$F157",
    "label": "CHRIN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61783         $F157          CHRIN\nInput a Character from the Current Device\n\nThis is a documented Kernal routine whose jump table entry point is at\n65487 ($FFCF).\n\nThe routine jumps through a RAM vector at 804 ($324).  Its function is\nto get a character from the current input device (whose device number\nis stored at 153 ($99)).  This device must first have been OPENed and\nthen designated as the input channel by the CHKIN routine.\n\nWhen this routine is called, the next byte of data available from this\ndevice is returned in the Accumulator.  The only exception is the\nroutine for the keyboard device (which is the default input device).\nIt the keyboard is the current input device, this routine blinks the\ncursor, fetches characters from the keyboard buffer, and echoes them\nto the screen until a carriage return is encountered.  When a carriage\nreturn is round, the routine sets a flag to indicate the length of the\nlast logical line before the return character, and reads the first\ncharacter of this logical line from the screen.\n\nSubsequent calls to this routine will cause the next character in the\nline to be read from the screen and returned in the Accumulator, until\nthe carriage return character is returned to indicate the end of the\nline.  Any call after this character is received will start the whole\nprocess over again.\n\nNote that only the last logical line before the carriage return is\nused.  Any time you type in more than 80 characters, a new logical\nline is started.  This routine will ignore any characters on the old\nlogical line, and process only the most recent 80-character group."
  },
  {
    "id": "map-F1CA",
    "address_start": 61898,
    "address_end": 61898,
    "hex_start": "$F1CA",
    "hex_end": "$F1CA",
    "label": "CHROUT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61898         $F1CA          CHROUT\nOutput a Byte\n\nThis is a documented Kernal routine whose jump table entry point is at\n65490 ($FFD2).  The routine jumps through a RAM vector at 806 ($326).\nIt is probably one of the best known and most used Kernal routines,\nbecause it sends the character in the Accumulator to the current\noutput device.  Unless a device has been OPENed and designated as the\ncurrent output channel using the CHKOUT routine, the character is\nprinted to the screen, which is the default output device.  If the\ncassette is the current device, outputting a byte will only add it to\nthe buffer.  No actual transmission of data will occur until the\n192-byte buffer is full."
  },
  {
    "id": "map-F20E",
    "address_start": 61966,
    "address_end": 61966,
    "hex_start": "$F20E",
    "hex_end": "$F20E",
    "label": "CHKIN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "61966         $F20E          CHKIN\nDesignate a Logical File As the Current Input Channel\n\nThis is a documented Kernal routine which can be entered from the jump\ntable at 65478 ($FFC6).\n\nThe routine jumps through a RAM vector at 798 ($31E).  If you wish to\nget data from any device other than the keyboard, this routine must be\ncalled after OPENing the device, before you can get a data byte with\nthe CHRIN or GETIN routine.  When called, the routine will designate\nthe logical file whose file number is in the .X register as the\ncurrent file, its device as the current device, and its secondary\naddress as the current secondary address.  If the device on the\nchannel is a serial device, which requires a TALK command and\nsometimes a secondary address, this routine will send them over the\nserial bus."
  },
  {
    "id": "map-F250",
    "address_start": 62032,
    "address_end": 62032,
    "hex_start": "$F250",
    "hex_end": "$F250",
    "label": "CHKOUT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62032         $F250          CHKOUT\nDesignate a Logical File As the Current Output Channel\n\nThis is a documented Kernal routine which can be entered from the jump\ntable at 65481 ($FFC9).\n\nThe routine jumps through a RAM vector at 800 ($320).  If you wish to\noutput data to any device other than the screen, this routine must be\ncalled after OPENing the device, and before you output a data byte\nwith the CHROUT routine.  When called, the routine will designate the\nlogical file whose file number is in the .X register as the current\nfile, its device as the current device, and its secondary address as\nthe current secondary address.  If the device on the channel uses the\nserial bus, and therefore requires a LISTEN command and possibly a\nsecondary address, this information will be sent on the bus."
  },
  {
    "id": "map-F291",
    "address_start": 62097,
    "address_end": 62097,
    "hex_start": "$F291",
    "hex_end": "$F291",
    "label": "CLOSE",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62097         $F291          CLOSE\nClose a Logical I/O File\n\nCLOSE is a documented Kernal routine which can be entered via the jump\ntable at 65475 ($FFC3).\n\nThe routine jumps through a RAM vector at 796 ($31C).  It is used to\nclose a logical file after all I/O operations involving that file have\nbeen completed.  This is accomplished by loading the Accumulator with\nthe logical file number of the file to be closed, and calling this\nroutine.\n\nClosing an RS-232 file will de-allocate space at the top of memory for\nthe receiving and trasmit buffers.  Closing a cassette file that was\nopened for writing will force the last block to be written to\ncassette, even if it is not a full 192 bytes.  Closing a serial bus\ndevice will send an UNLISTEN command on the bus.  Remember, it is\nnecessary to properly CLOSE a cassette or disk data file in order to\nretrieve the file later.\n\nFor all types of files, CLOSE removes the file's entry from the tables\nof logical files, device, and secondary address at 601, 611, and 621\n($259, $263, $26D), and moves all higher entries in the table down one\nspace."
  },
  {
    "id": "map-F30F",
    "address_start": 62223,
    "address_end": 62223,
    "hex_start": "$F30F",
    "hex_end": "$F30F",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62223         $F30F\nFind the File in the Logical File Table\n\nThis subroutine is used by many Kernal routines to find the position\nof the logical file in the logical file table at 601 ($259)."
  },
  {
    "id": "map-F31F",
    "address_start": 62239,
    "address_end": 62239,
    "hex_start": "$F31F",
    "hex_end": "$F31F",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62239         $F31F\nSet Current Logical File, Current Device, and Current Seconday Address\n\nThis subroutine is used to update the Kernal variables at 184-186\n($B8-$BA) which holds the current logical file number, current device\nnumber, and current secondary address number."
  },
  {
    "id": "map-F32F",
    "address_start": 62255,
    "address_end": 62255,
    "hex_start": "$F32F",
    "hex_end": "$F32F",
    "label": "CLALL",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62255         $F32F          CLALL\nClose All Logical I/O Files\n\nCLALL is a documented Kernal routine whose entry point in the jump\ntable is 65511 ($FFE7).\n\nThe routine jumps through a RAM vector at 812 ($32C).  It closes all\nopen files, by resetting the index into open files at 152 ($98) to\nzero.  It then falls through to the next routine, which restores the\ndefault I/O devices."
  },
  {
    "id": "map-F333",
    "address_start": 62259,
    "address_end": 62259,
    "hex_start": "$F333",
    "hex_end": "$F333",
    "label": "CLRCHN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62259         $F333          CLRCHN\nRestore Current Input and Output Devices to the Default Devices\n\nThis is a documented Kernal Routine which can be entered at location\n65484 ($FFCC) in the jump table.\n\nThe routine jumps through a RAM vector at 802 ($322).  It sets the\ncurrent input device to the keyboard, and the current output device to\nthe screen.  Also, if the current input device was formerly a serial\ndevice, the routine sends it an UNTALK command on the serial bus, and\nif a serial device was formerly the current output device, the routine\nsends it an UNLISTEN command."
  },
  {
    "id": "map-F34A",
    "address_start": 62282,
    "address_end": 62282,
    "hex_start": "$F34A",
    "hex_end": "$F34A",
    "label": "OPEN",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62282         $F34A          OPEN\nOpen a Logical I/O File\n\nOPEN is a documented Kernal I/O routine.  It can be entered from the\njump table at 65472 ($FFC0).\n\nThe routine jumps through a RAM vector at 794 ($31A).  This routine\nassigns a logical file to a device, so that it can be used for\nInput/Output operations.  In order to specify the logical file number,\nthe device number, and the secondary address if any, the SETLFS\nroutine must first be called.  Likewise, in order to designate the\nfilename, the SETNAM routine must be used first.  After these two\nroutines are called, OPEN is then called."
  },
  {
    "id": "map-F49E",
    "address_start": 62622,
    "address_end": 62622,
    "hex_start": "$F49E",
    "hex_end": "$F49E",
    "label": "LOAD",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62622         $F49E          LOAD\nLoad RAM from a Device\n\nThis is a documented Kernal routine, whose entry in the jump table\nappears at 65493 ($FFD5).\n\nThe routine jumps through a RAM vector at 816 ($330).  LOAD is used to\ntransfer data froma device directly to RAM.  It can also be used to\nverify RAM, comparing its contents to those of a disk or tape file.\nTo choose between these operations you must set the Accumulator with a\n0 for LOAD, or a 1 for VERIFY.\n\nSince the LOAD routine performs an OPEN, it must be preceded by a call\nto the SETLFS routine to specify the logical file number, device\nnumber, and secondary address, and a call to the SETNAM routine to\nspecify the filename (a LOAD from tape can be performed without a\nfilename being specified).  Then the .X and .Y registers should be set\nwith the starting address for the load, and the LOAD routine called.\nIf the secondary address specified was a 1, this starting address will\nbe ignored, and the header information will be used to supply the load\naddress.  If the secondary address was a 0, the address supplied by\nthe call will be used.  In either case, upon return from the\nsubroutine, the .X and .Y registers will contain the address of the\nhighest RAM location that was loaded."
  },
  {
    "id": "map-F5A5",
    "address_start": 62885,
    "address_end": 62885,
    "hex_start": "$F5A5",
    "hex_end": "$F5A5",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62885         $F5A5\nPrint SEARCHING Message if in Direct Mode"
  },
  {
    "id": "map-F5DD",
    "address_start": 62941,
    "address_end": 62941,
    "hex_start": "$F5DD",
    "hex_end": "$F5DD",
    "label": "SAVE",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "62941         $F5DD          SAVE\nSave RAM to a Device\n\nThis is a documented Kernal routine, whose entry in the jump table\nappears at 65496 ($FFD8).\n\nThe routine jumps through a RAM vector at 818 ($332).  SAVE is used to\ntransfer data directly from RAM to an I/O device.  Since the SAVE\nroutine performs an OPEN, it must be preceded by a call to the SETLFS\nroutine to specify the logical file number, device number, and\nsecondary address, and a call to the SETNAM routine to specify the\nfilename (although a SAVE to the cassette can be performed without\ngiving a filename).  A Page 0 pointer to the starting address of the\narea to be saved should be set up, with the low byte of the address\nfirst.  The accumulator should be loaded with the Page 0 offset of\nthat pointer, then the .X and .Y registers should be set with the\nending address for the save, and the SAVE routine called."
  },
  {
    "id": "map-F68F",
    "address_start": 63119,
    "address_end": 63119,
    "hex_start": "$F68F",
    "hex_end": "$F68F",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63119         $F68F\nIf in Direct Mode, Print SAVING and Filename"
  },
  {
    "id": "map-F69B",
    "address_start": 63131,
    "address_end": 63131,
    "hex_start": "$F69B",
    "hex_end": "$F69B",
    "label": "UDTIM",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63131         $F69B          UDTIM\nUpdate the Software Clock and Check for the STOP Key\n\nUDTIM is a documented Kernal routine which can be entered through the\njump table at 65514 ($FFEA).\n\nIt is normally called by the IRQ interrupt handler once every sixtieth\nof a second.  It adds one to the value in the three-byte software\njiffy clock at 160-162 ($A0-$A2), and sets the clock back to zero when\nit reaches the 24 hour point.  In addition, it scans the keyboard row\nin which the STOP key is located, and stores the current value of that\nkey in location 145 ($91).  This variable is used by the STOP routine\nwhich checks for the STOP key."
  },
  {
    "id": "map-F6DD",
    "address_start": 63197,
    "address_end": 63197,
    "hex_start": "$F6DD",
    "hex_end": "$F6DD",
    "label": "RDTIM",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63197         $F6DD          RDTIM\nRead the Time From the Software Clock into the .A, .X, and .Y\nRegisters\n\nThis is a documented Kernal routine whose entry point in the jump\ntable is 65502 ($FFDE).\n\nIt reads the software clock (which counts sixtieths of a second) into\nthe internal registers.  The .Y register contains the most significant\nbyte (from location 160 ($A0)), the .X register contains the middle\nbyte (from location 161 ($A1)), and the Accumulator contains the least\nsignificant byte (from location 162 ($A2))."
  },
  {
    "id": "map-F6E4",
    "address_start": 63204,
    "address_end": 63204,
    "hex_start": "$F6E4",
    "hex_end": "$F6E4",
    "label": "SETTIM",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63204         $F6E4          SETTIM\nSet the Software Clock from the .A, .X, and .Y Registers\n\nThis documented Kernal routine can be entered from location 65499\n($FFDB).\n\nIt performs the reverse operation from RDTIM, storing the value in the\n.Y register into location 160 ($A0), the .X register into 161 ($A1),\nand the Accumulator into 162 ($A2).  Interrupts are first disabled, to\nmake sure that the clock will not be updated while being set."
  },
  {
    "id": "map-F6ED",
    "address_start": 63213,
    "address_end": 63213,
    "hex_start": "$F6ED",
    "hex_end": "$F6ED",
    "label": "STOP",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63213         $F6ED          STOP\nTest STOP Key\n\nSTOP is a documented Kernal routine which can be entered from the jump\ntable at location 65505 ($FFE1).\n\nIt is vectored through RAM at 808 ($328).  The routine checks to see\nif the STOP key was pressed during the last UDTIM call.  If it was,\nthe Zero flag is set to 1, the CLRCHN routine is called to set the\ninput and output devices back to the keyboard and screen, and the\nkeyboard queue is emptied."
  },
  {
    "id": "map-F6FB",
    "address_start": 63227,
    "address_end": 63227,
    "hex_start": "$F6FB",
    "hex_end": "$F6FB",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63227         $F6FB\nSet Kernal I/O Error Messages\n\nThis subroutine is used to handle I/O errors from Kernal I?O routines.\nIt calls CLRCHN to restore default I/O devices.  If Bit 6 of the flag\nat 157 ($9D) is set, it prints I/O ERROR followed by the error number,\nand then sets the Carry flag to indicate an error, with the error\nnumber in the Accumulator.  The Kernal error messages are not used by\nBASIC, but may be used by machine language monitors and other\napplications."
  },
  {
    "id": "map-F72C",
    "address_start": 63276,
    "address_end": 63276,
    "hex_start": "$F72C",
    "hex_end": "$F72C",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63276         $F72C\nGet Next Tape File Header from Cassette\n\nThis routine reads in tape blocks until it finds a file header block.\nIt then prints out the FOUND message along with the first 16\ncharacters of the filename."
  },
  {
    "id": "map-F7D0",
    "address_start": 63440,
    "address_end": 63440,
    "hex_start": "$F7D0",
    "hex_end": "$F7D0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63440         $F7D0\nPut Pointer to Tape Buffer in .X and .Y Registers"
  },
  {
    "id": "map-F7D7",
    "address_start": 63447,
    "address_end": 63447,
    "hex_start": "$F7D7",
    "hex_end": "$F7D7",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63447         $F7D7\nSet I/O Area Start and End Pointers to Tape Buffer Start and End\nAddress"
  },
  {
    "id": "map-F817",
    "address_start": 63511,
    "address_end": 63511,
    "hex_start": "$F817",
    "hex_end": "$F817",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63511         $F817\nTest Cassette Buttons and Handle Messages for Tape Read\n\nThis routine tests the sense switch, and if no buttons are depressed\nit prints the PRESS PLAY ON TAPE message, and loops until a cassette\nbutton is pressed, or until the STOP key is pressed.  If a button is\npressed, it prints the message OK.\n\nSince the message printing routine is entered after the test for\ndirect mode, these messages cannot be superseded by changing the flag\nat 157 ($9D).  You could have them harmlessly printed to ROM, however,\nby changing the value of HIBASE at 648 ($288) temporarily to 160, and\nthen back to 4."
  },
  {
    "id": "map-F82E",
    "address_start": 63534,
    "address_end": 63534,
    "hex_start": "$F82E",
    "hex_end": "$F82E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63534         $F82E\nCheck Cassette Switch\n\nThis subroutine is used to check if a button on the recorder has been\npressed."
  },
  {
    "id": "map-F838",
    "address_start": 63544,
    "address_end": 63544,
    "hex_start": "$F838",
    "hex_end": "$F838",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63544         $F838\nTest Cassette Buttons and Handle Messages for Tape Write\n\nThis routine tests the sense switch, and if no buttons are depressed\nit prints the PRESS PLAY & RECORD message, and loops until a cassette\nbutton is pressed, or until the STOP key is pressed.  If a button is\npressed, it prints the message OK.  These messages cannot be supressed\nby changing the flag at 157 ($9D).  See the entry for 63511 ($F817)\nfor more information."
  },
  {
    "id": "map-F841",
    "address_start": 63553,
    "address_end": 63553,
    "hex_start": "$F841",
    "hex_end": "$F841",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63553         $F841\nStart Reading a Block of Data from the Cassette\n\nThis subroutine tests the cassette switch and initializes various\nflags for reading a block of data from cassette."
  },
  {
    "id": "map-F864",
    "address_start": 63588,
    "address_end": 63588,
    "hex_start": "$F864",
    "hex_end": "$F864",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63588         $F864\nStart Writing a Block of Data to the Cassette\n\nThis subroutine tests the cassette switch and initializes various\nflags for writing a block of data to cassette."
  },
  {
    "id": "map-F875",
    "address_start": 63605,
    "address_end": 63605,
    "hex_start": "$F875",
    "hex_end": "$F875",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63605         $F875\nCommon Code for Reading a Data Block from Tape and Writing a Block to Tape\n\nThis routine sets the actual reading or writing of a block of data.\nIt sets CIA #1 Timer B to call the IRQ which drives the actual reading\nor writing routine, saves the old IRQ vector, and sets the new IRQ\nvector to the read or write routine.  It also blanks the screen so\nthat the video chip's memory addressing (which normally takes away\nsome of the 6510 microprocessor's addressing time) will not interfere\nwith the timing of the routines."
  },
  {
    "id": "map-F8D0",
    "address_start": 63696,
    "address_end": 63696,
    "hex_start": "$F8D0",
    "hex_end": "$F8D0",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63696         $F8D0\nTest the STOP Key during Cassette I/O Operations\n\nThis subroutine is used to test the STOP key during tape I/O\noeprations, and to stop I/O if it is pressed."
  },
  {
    "id": "map-F8E2",
    "address_start": 63714,
    "address_end": 63714,
    "hex_start": "$F8E2",
    "hex_end": "$F8E2",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63714         $F8E2\nAdjust CIA #1 Timer A for Tape Bit Timing"
  },
  {
    "id": "map-F92C",
    "address_start": 63788,
    "address_end": 63788,
    "hex_start": "$F92C",
    "hex_end": "$F92C",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "63788         $F92C\nRead Tape Data (IRQ)\n\nThis is the IRQ handler routine that is used for reading data from the\ncassette.  At the end of the read, the IRQ vector is restored to the\nnormal IRQ routine."
  },
  {
    "id": "map-FA60",
    "address_start": 64096,
    "address_end": 64096,
    "hex_start": "$FA60",
    "hex_end": "$FA60",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64096         $FA60\nReceive and Store the Next Character from Cassette\n\nThis is the part of the cassette read IRQ routine that actually gets\nthe next byte of data from the cassette."
  },
  {
    "id": "map-FB8E",
    "address_start": 64398,
    "address_end": 64398,
    "hex_start": "$FB8E",
    "hex_end": "$FB8E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64398         $FB8E\nMove the Tape SAVE/LOAD Address into the Pointer at 172"
  },
  {
    "id": "map-FB97",
    "address_start": 64407,
    "address_end": 64407,
    "hex_start": "$FB97",
    "hex_end": "$FB97",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64407         $FB97\nReset Counters for Reading or Writing a New Byte of Cassette Data"
  },
  {
    "id": "map-FBA6",
    "address_start": 64422,
    "address_end": 64422,
    "hex_start": "$FBA6",
    "hex_end": "$FBA6",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64422         $FBA6\nToggle the Tape Data Output Line\n\nThis routine sets the CIA #1 Timer B, and toggles the Tape Data Output\nline on the 6510 on-chip I/O port (Bit 3 of location 1)."
  },
  {
    "id": "map-FBC8",
    "address_start": 64456,
    "address_end": 64456,
    "hex_start": "$FBC8",
    "hex_end": "$FBC8",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64456         $FBC8\nWrite Data to Cassette--Part 2 (IRQ)\n\nThis IRQ handler routine is one part of the write data to cassette\nroutine"
  },
  {
    "id": "map-FC6A",
    "address_start": 64618,
    "address_end": 64618,
    "hex_start": "$FC6A",
    "hex_end": "$FC6A",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64618         $FC6A\nWrite Data fo Cassette--Part 1 (IRQ)\n\nThis IRQ handler routine is the other part of the write data to\ncassette routine."
  },
  {
    "id": "map-FC93",
    "address_start": 64659,
    "address_end": 64659,
    "hex_start": "$FC93",
    "hex_end": "$FC93",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64659         $FC93\nRestores the Default IRQ Routine\n\nAt the end of the tape I/O operations, this subroutine is used to turn\nthe screen back on and stop the cassette motor.  It then resets the\nCIA #1 Timer A to generate an interrupt every sixtieth of a second,\nand restores the IRQ vector to point to the normal interrupt routine\nthat updates the software clock and scans the keyboard."
  },
  {
    "id": "map-FCB8",
    "address_start": 64696,
    "address_end": 64696,
    "hex_start": "$FCB8",
    "hex_end": "$FCB8",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64696         $FCB8\nTerminate Cassette I/O\n\nThis routine calls the subroutine above and returns from the\ninterrupt."
  },
  {
    "id": "map-FCD1",
    "address_start": 64721,
    "address_end": 64721,
    "hex_start": "$FCD1",
    "hex_end": "$FCD1",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64721         $FCD1\nCheck the Tape Read/Write Pointer\n\nThis routine compares the current tape read/write address with the\nending read/write address."
  },
  {
    "id": "map-FCDB",
    "address_start": 64731,
    "address_end": 64731,
    "hex_start": "$FCDB",
    "hex_end": "$FCDB",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64731         $FCDB\nAdvance the Tape Read/Write Pointer\n\nThis routine is used to move the pointer to the current read/write\naddress up a byte."
  },
  {
    "id": "map-FCE2",
    "address_start": 64738,
    "address_end": 64738,
    "hex_start": "$FCE2",
    "hex_end": "$FCE2",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64738         $FCE2\nPower-On Reset Routine\n\nThis is the RESET routine which is pointed to by the 6510 hardware\nRESET vector at 65532 ($FFFC).\n\nThis routine is automatically executed when the computer is first\nturned on.  First, it sets the Interrupt disable flag, sets the stack\npointer, and clears the Decimal mode flag.  Next, it tests for an\nautostart cartridge.  If one is found, the routine immediately jumps\nthrough the cartridge cold start vector at 32768 ($8000).  If no\ncartridge is found, the Kernal initialization routines IOINIT, RAMTAS,\nRESTOR, and CINT are called, the Interrupt disable flag is cleared,\nand the BASIC program is entered through the cold start vector at\n40960 ($A000)."
  },
  {
    "id": "map-FD02",
    "address_start": 64770,
    "address_end": 64770,
    "hex_start": "$FD02",
    "hex_end": "$FD02",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64770         $FD02\nCheck for an Autostart Cartridge\n\nThis routine tests for an autostart cartridge by comparing the\ncharacters at location 32772-6 ($8004-8) to the text below.  The Zero\nflag will be set if they match, and cleared if they don't."
  },
  {
    "id": "map-FD10",
    "address_start": 64784,
    "address_end": 64784,
    "hex_start": "$FD10",
    "hex_end": "$FD10",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64784         $FD10\nText for Autostart Cartridge Check\n\nThe characters stored here must be the fifth through the ninth\ncharacters in the cartridge in order for it to be started on power-up.\nThese characters are the PETASCII values for CBM, each with the high\nbit set (+128), and the characters \"80\"."
  },
  {
    "id": "map-FD15",
    "address_start": 64789,
    "address_end": 64789,
    "hex_start": "$FD15",
    "hex_end": "$FD15",
    "label": "RESTOR",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64789         $FD15          RESTOR\nRestore RAM Vectors for Default I/O Routines\n\nThis documented Kernal routine can be entered through the jump table\nat 65418 ($FF8A).\n\nIt sets the values for the 16 RAM vectors to the interrupt and\nimportant Kernal I/O routines in the table that starts at 788 ($314)\nto the standard values held in the ROM table at 64816 ($FD30)."
  },
  {
    "id": "map-FD1A",
    "address_start": 64794,
    "address_end": 64794,
    "hex_start": "$FD1A",
    "hex_end": "$FD1A",
    "label": "VECTOR",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64794         $FD1A          VECTOR\nSet the RAM Vector Table from the Table Pointed to by .X and .Y\n\nThis documented Kernal routine can be entered through the jump table\nat 65421 ($FF8D).\n\nIt is used to read or change the values for the 16 RAM vectors to the\ninterrupt and important Kernal I/O routines in the table that starts\nat 788 ($314).  If the Carry flag is set when the routine is called,\nthe current value of the 16 vectors will be stored at a table whose\naddress is pointed to by the values in the .X and .Y registers.  If\nthe Carry flag is cleared, the RAM vectors will be loaded from the\ntable whose address is pointed to by the .X and .Y registers.  Since\nthis routine can change the vectors for the IRQ and NMI interrupts,\nyou might expect that the Interrupt disable flag would be set at its\nbeginning.  Such is not the case, however, and therefore it would be\nwise to execute an SEI before calling it and a CLI afterwards (as the\npower-on RESET routine does) just to be safe."
  },
  {
    "id": "map-FD30",
    "address_start": 64816,
    "address_end": 64816,
    "hex_start": "$FD30",
    "hex_end": "$FD30",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64816         $FD30\nTable of RAM Vectors to the Default I/O Routines\n\nThis table contains the 16 RAM I/O vectors that are moved to 788-819\n($314-$333)."
  },
  {
    "id": "map-FD50",
    "address_start": 64848,
    "address_end": 64848,
    "hex_start": "$FD50",
    "hex_end": "$FD50",
    "label": "RAMTAS",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64848         $FD50          RAMTAS\nPerform RAM Test and Set Pointers to the Top and Bottom of RAM\n\nThis documented Kernal routine, which can be entered through location\n65415 ($FF87) of the jump table, performs a number of initialization\ntasks.\n\nFirst, it clears Pages 0, 2, and 3 of memory to zeros.  Next, it sets\nthe tape buffer pointer to address 828 ($33C), and performs a\nnondestructive test of RAM from 1024 ($400) up.  When it reaches a\nnon-RAM address (presumably the BASIC ROM at 40960 ($A000)), that\naddress is placed in the top of memory pointer at 643-4 ($283-4).  The\nbottom of memory pointer at 641-2 ($281-2) is set to point to address\n2048 ($800), which is the beginning of BASIC program text.  Finally,\nthe pointer to screen memory at 648 ($288) is set to 4, which lets the\nOperating System know that screen memory starts at 1024 ($400)."
  },
  {
    "id": "map-FD9B",
    "address_start": 64923,
    "address_end": 64923,
    "hex_start": "$FD9B",
    "hex_end": "$FD9B",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64923         $FD9B\nTable of IRQ Vectors\n\nThis table holds the vectors to the four IRQ routines which the system\nuses.  The first points to Part 1 of the cassette write routine at\n64618 ($FC6A), the second to Part 2 of the cassette write routine at\n64461 ($FBCD), the third to the standard scan keyboard IRQ at 59953\n($EA31), and the last to the cassette read routine at 63788 ($F92C)."
  },
  {
    "id": "map-FDA3",
    "address_start": 64931,
    "address_end": 64931,
    "hex_start": "$FDA3",
    "hex_end": "$FDA3",
    "label": "IOINIT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "64931         $FDA3          IOINIT\nInitialize CIA I/O Devices\n\nThis documented Kernal routine, which can be entered through the jump\ntable at 65412 ($FF84), intializes the Complex Interface Adapter (CIA)\ndevices, and turns the volume of the SID chip off.  As part of this\ninitialization, it sets CIA #1 Timer A to cause an IRQ interrupt every\nsixtieth of a second."
  },
  {
    "id": "map-FDF9",
    "address_start": 65017,
    "address_end": 65017,
    "hex_start": "$FDF9",
    "hex_end": "$FDF9",
    "label": "SETNAM",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65017         $FDF9          SETNAM\nSet Filename Parameters\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65469 ($FFBD).\n\nIt puts the value in the Accumulator into the location which stores\nthe number of characters in the filename, and sets the pointer to the\naddress of the ASCII text of the filename from the .X and .Y\nregisters.  This sets up the filename for the OPEN, LOAD, or SAVE\nroutine."
  },
  {
    "id": "map-FE00",
    "address_start": 65024,
    "address_end": 65024,
    "hex_start": "$FE00",
    "hex_end": "$FE00",
    "label": "SETLFS",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65024         $FE00          SETLFS\nSet Logical File Number, Device Number, and Secondary Address\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65466 ($FFBA).\n\nIt stores the value in the Accumulator in the location which holds the\ncurrent logical file number, the value in the .X register is put in\nthe location that holds the current device number, and the value in\nthe .Y register is stored in the location that holds the current\nsecondary address.  If no secondary address is used, the .Y register\nshould be set to 255 ($FF).  It is necessary to set the values of the\ncurrent file number, device number, and secondary address before you\nOPEN a file, or LOAD or SAVE."
  },
  {
    "id": "map-FE07",
    "address_start": 65031,
    "address_end": 65031,
    "hex_start": "$FE07",
    "hex_end": "$FE07",
    "label": "READST",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65031         $FE07          READST\nRead the I/O Status Word\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65463 ($FFB7).\n\nWhenever an I/O error occurs, a bit of the Status Word is set to\nindicate what the problem was.  The routine allows you to read the\nstatus word (it is returned in the Accumulator).  If the device was\nthe RS-232, its status register is read and cleared to zero.  For the\nmeanings of the various status codes, see the entry for location 144\n($90) or 663 ($297) for the RS-232 device."
  },
  {
    "id": "map-FE18",
    "address_start": 65048,
    "address_end": 65048,
    "hex_start": "$FE18",
    "hex_end": "$FE18",
    "label": "SETMSG",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65048         $FE18          SETMSG\nSet the Message Control Flag\n\nThis documented Kernal routine can be entered through its jump table\nvector at 65424 ($FF90).\n\nThe routine controls the printing of error messages and control\nmessages by the Kernal.  It Bit 6 is seto to 1 (bit value of 64),\nKernal control messages can be printed.  These messages include\nSEARCHING FOR, LOADING, and the like.  If Bit 6 is cleared to 0, these\nmessages will not be printed (BASIC will clear this bit when a program\nis running so that the messages do not appear when I/O is performed\nfrom a program).  Setting Bit 6 will not suppress the PRESS PLAY ON\nTAPE or PRESS PLAY & RECORD messages, however.\n\nIf Bit 7 is set to 1 (bit value of 128), Kernal error messages can be\nprinted.  If Bit 7 is set to 0, those error messages (for example, I/O\nERROR #nn) will be suppressed.  Note that BASIC has its own set of\nerror messages (such as FILE NOT FOUND ERROR) which it uses in\npreference to the Kernal's message.\n\n65057         $E21           SETTMO\nSet Time-Out Flag for IEEE Bus\n\nThis documented Kernal routine can be entered fromthe jump table at\n65442 ($FFA2).\n\nThe routine sets the time-out flag for the IEEE bus.  When timeouts\nare enabled, the Commodore will wait for a device for 64 milliseconds,\nand if it does not receive a response to its signal it will issue a\ntime-out error.  Loading the Accumulator with a value less than 128\nand calling this routine will enable time-outs, while using a value\nover 128 will disable time-outs.\n\nThis routine is for use only with the Commodore IEEE add-on card,\nwhich at the time of this writing was not yet available."
  },
  {
    "id": "map-FE25",
    "address_start": 65061,
    "address_end": 65061,
    "hex_start": "$FE25",
    "hex_end": "$FE25",
    "label": "MEMTOP",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65061         $FE25          MEMTOP\nRead/Set Top of RAM Pointer\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65433 ($FF99).\n\nIt can be used to either read or set the top of RAM pointer.  If\ncalled with the Carry flag set, the address in the pointer will be\nloaded into the .X and .Y registers.  If called with the Carry flag\ncleared, the pointer will be changed to the address found in the .X\nand .Y registers."
  },
  {
    "id": "map-FE34",
    "address_start": 65076,
    "address_end": 65076,
    "hex_start": "$FE34",
    "hex_end": "$FE34",
    "label": "MEMBOT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65076         $FE34          MEMBOT\nRead/Set Bottom of RAM Pointer\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65436 ($FF9C).\n\nIt can be used to either read or set the bottom of RAM pointer.  If\ncalled with the Carry flag set, the address in the pointer willbe\nloaded into the .X and .Y registers.  If called with the Carry flag\ncleared, the pointer will be changed to the address found in the .X\nand .Y registers."
  },
  {
    "id": "map-FE43",
    "address_start": 65091,
    "address_end": 65091,
    "hex_start": "$FE43",
    "hex_end": "$FE43",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65091         $FE43\nNMI Interrupt Entry Point\n\nThis routine is the NMI interrupt handler entry, which is pointed to\nby the hardware NMI vector at 65530 ($FFFA).\n\nAny time an NMI interrupt occurs, the Interrupt disable flag will be\nset, and the routine will jump through the RAM vector at 792 ($318),\nwhich ordinarily points to the continuation of this routine.  The\nstandard handler first checks to see if the NMI was caused by the\nRS-232 device.  If not, the RESTORE key is assumed.  The routine\nchecks for a cartridge, and if one is found it exits through the\ncartridge warm start vector at 32770 ($8002).  If not, the STOP key is\nchecked, and if it is being pressed, the BRK routine is executed.  If\nthe RS-232 device was the cause of the NMI, the cartridge and STOP key\nchecks are bypassed, and the routine skips to the end, where it checks\nwhether it is time to send or receive a data bit via the RS-232\ndevice."
  },
  {
    "id": "map-FE66",
    "address_start": 65126,
    "address_end": 65126,
    "hex_start": "$FE66",
    "hex_end": "$FE66",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65126         $FE66\nBRK, Warm Start Routine\n\nThis routine is executed when the STOP/RESTORE combination of\nkeypresses occurs.  In addition, it is the default target address of\nthe BRK instruction vector.  This routine calls the Kernal\nintialization routines RESTOR, IOINIT, and part of CINT.  It then\nexits through the BASIC warm start vector at 40962 ($A002)."
  },
  {
    "id": "map-FE72",
    "address_start": 65138,
    "address_end": 65138,
    "hex_start": "$FE72",
    "hex_end": "$FE72",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65138         $FE72\nNMI RS-232 Handler\n\nThis is the part of the NMI handler that checks if it is time to\nreceive or send a bit on the RS-232 channel, and takes the appropriate\naction if it is indeed the time."
  },
  {
    "id": "map-FEC2",
    "address_start": 65218,
    "address_end": 65218,
    "hex_start": "$FEC2",
    "hex_end": "$FEC2",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65218         $FEC2\nRS-232 Baud Rate Tables for U.S. Television Standard (NTSC)\n\nThis table contains the ten prescaler values for the ten standard baud\nrates implemented by the RS-232 Control Register at 659 ($293).  The\ntable starts with the two values needed for the lowest baud rate (50\nbaud) and finishes with the entries for the highest baud rate, 2400\nbaud.  The RS-232 routines are handled by NMI interrupts which are\ncaused by the timers on CIA #2.  Since the RS-232 device could both\nreceive and send a bit in a single cycle, the time between interrupts\nshould be a little less than half of the clock frequency divided by\nthe baud rate.  The exact formula used is:\n\n((CLOCK/BAUD)/2)-100\n\nwhere CLOCK is the processor clock speed and BAUD is the baud rate.\nThe clock frequency for machines using the U.S. television standard\n(NTSC) is 1,022,730 cycles per second, while the frequency for the\nEuropean (PAL) standard is 985,250 cycles per second.  For this\nreason, separate baud rate tables were added for European machines at\n58604 ($E4EC)."
  },
  {
    "id": "map-FED6",
    "address_start": 65238,
    "address_end": 65238,
    "hex_start": "$FED6",
    "hex_end": "$FED6",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65238         $FED6\nRS-232 Receive the Next Bit (NMI)\n\nThe NMI handler calls this subroutine to input the next bit on the\nRS-232 bus.  It then calls the next subroutine to reload the timer\nthat causes the interrupts."
  },
  {
    "id": "map-FF1A",
    "address_start": 65306,
    "address_end": 65306,
    "hex_start": "$FF1A",
    "hex_end": "$FF1A",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65306         $FF1A\nLoad the Timer with Prescaler Values from the Baud Rate Lookup Table"
  },
  {
    "id": "map-FF48",
    "address_start": 65352,
    "address_end": 65352,
    "hex_start": "$FF48",
    "hex_end": "$FF48",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65352         $FF48\nMain IRQ/BRK Interrupt Entry Point\n\nThe 6510 hardware IRQ/BRK vector at 65534 ($FFFE) points to this\naddress.\n\nAnytime the BRK instruction is encountered or an IRQ interrupt occurs,\nthis routine will be executed.  The routine first saves the .A, .X,\nand .Y registers on the stack, and then tests the BRK bit of the\nstatus register (.P) to see if a BRK was executed.  If it was, the\nroutine exits through the RAM BRK vector at 790 ($316), where it will\nusually be directed to the BRK routine at 65126 ($FE66).  If not, the\nroutine exits through the RAM IRQ vector at 788 ($314), where it will\nusually be directed to the handler that scans the keyboard at 59953\n($EA31).\n\nIf you plan to change either of these vectors to your own routine,\nremember to pull the stored register values off the stack before\nfinishing."
  },
  {
    "id": "map-FF5B-FF7F",
    "address_start": 65371,
    "address_end": 65407,
    "hex_start": "$FF5B",
    "hex_end": "$FF7F",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location_range",
    "text": "Location Range: 65371-65407 ($FF5B-$FF7F)\nPatches Added to Later Kernal Versions\n\nThis area contains additional code not found in the original version\nof the Kernal.  It is used to test whether a European (PAL) or U.S.\n(NTSC) standard monitor is used, and to compensate so that the\nsixtieth of a second interrupt will be accurately timed on either\nsystem."
  },
  {
    "id": "map-FF5B",
    "address_start": 65371,
    "address_end": 65371,
    "hex_start": "$FF5B",
    "hex_end": "$FF5B",
    "label": "CINT",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65371         $FF5B          CINT\nInitialize Screen Editor and VIC-II Chip\n\nThis is a documented Kernal routine whose entry in the jump table is\nlocated at 65409 ($FF81).\n\nThe start of the routine appears to be a patch that was added to later\nversions of the Kernal.  It first calls the old routine at 58648\n($E518).  This initializes the VIC-II chip to the default values, sets\nthe keyboard as the input device and the screen as the output device,\ninitializes the cursor flash variables, builds the screen line link\ntable, clears the screen, and homes the cursor.  The new code then\nchecks the VIC Interrupt register to see if the conditions for a\nRaster Compare IRQ have been fulfilled.  Since the Raster Register was\ninitialized to 311, that can only occur when using a PAL system (NTSC\nscreens do not have that many scan lines).  The PAL/NTSC register at\n678 ($2A6) is set on the basis of the outcome of this test.  The CIA\n#1 Timer A is then set to cause an IRQ interrupt every sixtieth of a\nsecond, using the prescaler figures for a PAL or NTSC system, as\nappropriate."
  },
  {
    "id": "map-FF6E",
    "address_start": 65390,
    "address_end": 65390,
    "hex_start": "$FF6E",
    "hex_end": "$FF6E",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65390         $FF6E\nEnd of Routine to Set Timer for Sixtieth of a Second IRQ\n\nThis appears to be a patch added to compensate for the extra length of\nthe current version of this routine, which chooses either the PAL or\nNTSC prescaler values for the timer."
  },
  {
    "id": "map-FF80",
    "address_start": 65408,
    "address_end": 65408,
    "hex_start": "$FF80",
    "hex_end": "$FF80",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65408         $FF80\nKernal Version Identifier Byte\n\nThis last byte before the jump table can be used to identify the\nversion of the Kernal.  The first version has a 170 ($AA) stored here,\nwhile the most current version at the time of this writing has a zero\nin this location.\n\nThe PET 64, a one-piece version with an integrated monochrome display,\nhas an identifier byte of 100 ($64).  The Commodore 64 logo uses this\nbyte to recognize the PET 64, and adjust its display accordingly."
  },
  {
    "id": "map-FF81-FFF5",
    "address_start": 65409,
    "address_end": 65525,
    "hex_start": "$FF81",
    "hex_end": "$FFF5",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location_range",
    "text": "Location Range: 65409-65525 ($FF81-$FFF5)\nKernal Jump Table\n\nThe following jump table is provided by Commodore in an effort to\nmaintain stable entry points for key I/O routines.  Each three-byte\ntable entry consists of a 6510 JMP instruction and the actual address\nof the routine in the ROM.  Although the actual address of the routine\nmay vary from machine to machine, or in later versions of the Kernal,\nthese addresses will stay where they are.  By jumping to the entry\npoint provided by this table, rather than directly into the ROM, you\ninsure your programs against changes in the Operating System.  In\naddition, this jump table may help you write programs that will\nfunction on more than one Commodore machine.  The 15 table entries\nfrom 65472-65514 ($FFC0-$FFEA) are the same for all Commodore\nmachines, from the earliest PET on.\n\nAs an additional aid, some of these routines are also vectored through\nthe table which starts at 788 ($314).  Since this table is in RAM, you\ncan change those vectors to point to your own routines which support\nadditional I/O devices.  Programs that use the jump table entry points\nto the I/O routines will be able to use these I/O devices without a\nproblem.\n\nThe following table will give the entry point, routine name, RAM\nvector if any, its current address, and a brief summary of its\nfunction.\n\n65409 ($FF81) CINT   (65371, $FF5B) initialize screen editor and video chip\n65412 ($FF84) IOINIT (64931, $FDA3) initialize I/O devices\n65415 ($FF87) RAMTAS (64848, $FD50) initialize RAM, tape buffer, screen\n65418 ($FF8A) RESTOR (64789, $FD15) restore default I/O vectors\n65421 ($FF8D) VECTOR (64794, $FD1A) read/set I/O vector table\n65424 ($FF90) SETMSG (65048, $FE18) set Kernal message control flag\n65427 ($FF93) SECOND (60857, $EDB9) send secondary address after LISTEN\n65430 ($FF96) TKSA   (60871, $EDC7) send secondary address after TALK\n65433 ($FF99) MEMTOP (65061, $FE25) read/set top of memory pointer\n65436 ($FF9C) MEMBOT (65076, $FE34) read/set bottom of memory pointer\n65439 ($FF9F) SCNKEY (60039, $EA87) scan the keyboard\n65442 ($FFA2) SETTMO (65057, $FE21) set time-out flag for IEEE bus\n65445 ($FFA5) ACPTR  (60947, $FE13) input byte from serial bus\n65448 ($FFA8) CIOUT  (60893, $EDDD) output byte to serial bus\n65451 ($FFAB) UNTLK  (60911, $EDEF) command serial bus device to UNTALK\n65454 ($FFAE) UNLSN  (60926, $EDFE) command serial bus device to UNLISTEN\n65457 ($FFB1) LISTEN (60684, $ED0C) command serial bus device to LISTEN\n65460 ($FFB4) TALK   (60681, $ED09) command serial bus device to TALK\n65463 ($FFB7) READST (65031, $FE07) read I/O status word\n65466 ($FFBA) SETLFS (65024, $FE00) set logical file parameters\n65469 ($FFBD) SETNAM (65017, $FDF9) set filename parameters\n65472 ($FFC0) OPEN   (via 794 ($31A) to 62282, $F34A) open a logical file\n65475 ($FFC3) CLOSE  (via 796 ($31C) to 62097, $F291) close a logical file\n65478 ($FFC6) CHKIN  (via 798 ($31E) to 61966, $F20E) define an input channel\n65481 ($FFC9) CHKOUT (via 800 ($320) to 62032, $F250) define an output channel\n65484 ($FFCC) CLRCHN (via 802 ($322) to 62259, $F333) restore default devices\n65487 ($FFCF) CHRIN  (via 804 ($324) to 61783, $F157) input a character\n65490 ($FFD2) CHROUT (via 806 ($326) to 61898, $F1CA) output a character\n65493 ($FFD5) LOAD   (via 816 ($330) to 62622, $F49E) load from device\n65496 ($FFD8) SAVE   (via 818 ($332) to 62941, $F5DD) save to a device\n65499 ($FFDB) SETTIM (63204, $F6E4) set the software clock\n65502 ($FFDE) RDTIM  (63197, $F6DD) read the software clock\n65505 ($FFE1) STOP   (via 808 ($328) to 63213, $F6ED) check the STOP key\n65508 ($FFE4) GETIN  (via 810 ($32A) to 61758, $F13E) get a character\n65511 ($FFE7) CLALL  (via 812 ($32C) to 62255, $F32F) close all files\n65514 ($FFEA) UDTIM  (63131, $F69B) update the software clock\n65517 ($FFED) SCREEN (58629, $E505) read number of screen rows and columns\n65520 ($FFF0) PLOT   (58634, $E50A) read/set position of cursor on screen\n65523 ($FFF3) IOBASE (58624, $E500) read base address of I/O devices"
  },
  {
    "id": "map-FFFA-FFFF",
    "address_start": 65530,
    "address_end": 65535,
    "hex_start": "$FFFA",
    "hex_end": "$FFFF",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location_range",
    "text": "Location Range: 65530-65535 ($FFFA-$FFFF)\n6510 Hardware Vectors\n\nThe last six locations in memory are reserved by the 6510 processor\nchip for three fixed vectors.  These vectors let the chip know at what\naddress to start executing machine language program code when an NMI\ninterrupt occurs, when the computer is turned on, or when an IRQ\ninterrupt or BRK occurs."
  },
  {
    "id": "map-FFFA",
    "address_start": 65530,
    "address_end": 65530,
    "hex_start": "$FFFA",
    "hex_end": "$FFFA",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65530         $FFFA\nNon-Maskable Interrupt Hardware Vector\n\nThis vector points to the main NMI routine at 65091 ($FE43)."
  },
  {
    "id": "map-FFFC",
    "address_start": 65532,
    "address_end": 65532,
    "hex_start": "$FFFC",
    "hex_end": "$FFFC",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65532         $FFFC\nSystem Reset (RES) Hardware Vector\n\nThis vector points to the power-on routine at 64738 ($FCE2)."
  },
  {
    "id": "map-FFFE",
    "address_start": 65534,
    "address_end": 65534,
    "hex_start": "$FFFE",
    "hex_end": "$FFFE",
    "label": "",
    "source": "mapping-c64.txt",
    "chapter": ":: Chapter 7  ::",
    "type": "location",
    "text": "65534         $FFFE\nMaskable Interrupt Request and Break Hardware Vectors\n\nThis vector points to the main IRQ handler routine at 65352 ($FF48).\n\n\n:::::::::::::::::::\n::  Appendix A   ::\n::               ::\n:: A Beginner's  ::\n::Guide to Typing::\n::  In Programs  ::\n:::::::::::::::::::\n\nWhat Is a Program?\n\nA computer cannot perform any task by itself.  Like a car without gas,\na computer has potential, but without a program, it isn't going\nanywhere.  Most of the programs published in this book are written in\na computer language called BASIC.  BASIC is easy to learn and is built\ninto all Commodore 64s.\n\nBASIC Programs\n\nComputers can be picky.  Unlike the English language, which is full of\nambiguities, BASIC usually has only one right way of stating\nsomething.  Every letter, character, or number is significant.  A\ncommon mistake is substituting a letter such as O for the numeral 0, a\nlowercase l for the numeral 1, or an uppercase B for the numeral 8.\nAlso, you must enter all punctuation such as colons and commas just as\nthey appears in the book.  Spacing can be important.  To be safe, type\nin the listings exactly as they appear.\n\nBraces and Special Characters\n\nThe exception to this typing rule is when you see the braces, such as\n{DOWN}.  Anything within a set of braces is a special character or\ncharacters that cannot easily by listed on a printer.  When you come\nacross such a special statement, refer to Appendix B, \"How to Type In\nPrograms.\"\n\nAbout DATA Statements\n\nSome programs contain a section or sections of DATA statements.  These\nlines provide information needed by the program.  Some DATA statements\ncontain actual programs (called machine language); others contain\ngraphics codes.  These lines are especially sensitive to errors.\n\nIf a single number in any one DATA statement is mistyped, your machine\ncould lock up, or crash.  The keyboard and STOP key may seem dead, and\nthe screen may go blank.  Don't panic--no damage is done.  To regain\ncontrol, you have to turn off your computer, then turn it back on.\nThis will erase whatever program was in memory, so always SAVE a copy\nof your program before you RUN it.  If your computer crashes, you can\nLOAD the program and look for your mistake.\n\nSometimes a mistyped DATA statement will cause an error message when\nthe program is RUN.  The error message may refer to the program line\nthat READs the data.  The error is still in the DATA statements,\nthough.\n\nGet to Know Your Machine\n\nYou should familiarize yourself with your computer before attempting\nto type in a program.  Learn the statements you use to store and\nretrieve your programs from tape or disk.  You'll want to save a copy\nof your program, so that you won't have to type it in every time you\nwant to use it.  Learn to use your machine's editing functions.  How\ndo you change a line if you made a mistake?  You can always retype the\nline, but you at least need to know how to backspace.  Do you know how\nto enter reverse video, lowercase, and control characters?  It's all\nexplained in your computer's manuals.\n\nA Quick Review\n\n1.  Type in the program a line at a time, in order.  Press RETURN at\nthe end of each line.  Use backspace or the back arrow to correct\nmistakes\n\n2.  Check the line you've typed against the line in the book.  You can\ncheck the entire program again if you get an error when you RUN the\nprogram.\n\n\n:::::::::::::::\n::Appendix B ::\n::           ::\n::How to Type::\n;:In Programs::\n:::::::::::::::\n\nTo make it easy to know exactly what to type when entering one of\nthese programs into your computer, we have established the following\nlisting conventions.\n\nGenerally, Commodore 64 program listings will contain words within\nbraces which spell out any special characters:  {DOWN} would mean to\npress the cursor down key.  {5 SPACES} would mean to press the space\nbar five times.\n\nTo indicate that a key should be shifted (hold down the SHIFT key\nwhile pressing the other key), the key would be unterlined in our\nlistings.  For example, _S_ would mean to type the S key while holding\nthe SHIFT key.  This would appear on your screen as a heart symbol.\nIf you find an underlined key enclosed in braces (e.g., {10 _N_}), you\nshould type the key as many times as indicated (in our example, you\nwould enter ten shifted N's).\n\nIf a key is enclosed in special brackets, [<>], you should hold down\nthe Commodore key while pressing the key inside the special brackets.\n(The Commodore key is the key in the lower-left corner of the\nkeyboard.)  Again, if the key is preceded by a number, you should\npress the key as many times as necessary.\n\nRarely, you'll see a solitary letter of the alphabet enclosed in\nbraces.  These characters can be entered by holding down the CTRL key\nwhile typing the letter in the braces.  For example, {A} would\nindicate that you should press CTRL-A.\n\nAbout the quote mode:  You know that you can move the cursor around\nthe screen with the CRSR keys.  Sometimes a programmer will want to\nmove the cursor under program control.  That's why you see all the\n{LEFT}'s, {HOME}'s, and {BLU}'s in our programs.  The only way the\ncomputer can tell the difference between direct and programmed cursor\ncontrol is the quote mode.\n\nOnce you press the quote (the double quote, SHIFT-2), you are in the\nquote mode.  If you type something and then try to change it by moving\nthe cursor left, you'll only get a bunch of reverse-video lines.\nThese are the symbols for cursor left.  The only editing key that\nisn't programmable is the DEL key; you can still use DEL to back up\nand edit the line.  Once you type another quote, you are out of quote\nmode.\n\nYou also go into quote mode when you INSerT spaces into a line.  In\nany case, the easiest way to get out of quote mode is to just press\nRETURN.  You'll then be out of quote mode and you can cursor up to the\nmistyped line and fix it.\n\nUse the following table when entering cursor and color control keys:\n\nWhen You                               When You\nRead:         Press:                   Read:          Press:\n[CLR]       SHIFT CLR/HOME             [<1>]           C= 1\n[HOME]            CLR/HOME             [<2>]           C= 2\n[UP]        SHIFT CRSR UP/DOWN         [<3>]           C= 3\n[DOWN]            CRSR UP/DOWN         [<4>]           C= 4\n[LEFT]      SHIFT CRSR LEFT/RIGHT      [<5>]           C= 5\n[RIGHT]           CRSR LEFT/RIGHT      [<6>]           C= 6\n[RVS]        CTRL 9                    [<7>]           C= 7\n[OFF]        CTRL 0                    [<8>]           C= 8\n[BLK]        CTRL 1                    [F1]               F1\n[WHT]        CTRL 2                    [F2]         SHIFT F1\n[RED]        CTRL 3                    [F3]               F3\n[CYN]        CTRL 4                    [F4]         SHIFT F3\n[PUR]        CTRL 5                    [F5]               F5\n[GRN]        CTRL 6                    [F6]         SHIFT F5\n[BLU]        CTRL 7                    [F7]               F7\n[YEL]        CTRL 8                    [F8]         SHIFT F8\n\n\n::::::::::::::\n::Appendix C::\n::          ::\n::  Screen  ::\n:: Location ::\n::  Table   ::\n::::::::::::::\n\nRow\n 0 1024  oooooooooooooooooooooooooooooooooooooooo\n   1064  oooooooooooooooooooooooooooooooooooooooo\n   1104  oooooooooooooooooooooooooooooooooooooooo\n   1144  oooooooooooooooooooooooooooooooooooooooo\n   1184  oooooooooooooooooooooooooooooooooooooooo\n 5 1224  oooooooooooooooooooooooooooooooooooooooo\n   1264  oooooooooooooooooooooooooooooooooooooooo\n   1304  oooooooooooooooooooooooooooooooooooooooo\n   1344  oooooooooooooooooooooooooooooooooooooooo\n   1384  oooooooooooooooooooooooooooooooooooooooo\n10 1424  oooooooooooooooooooooooooooooooooooooooo\n   1464  oooooooooooooooooooooooooooooooooooooooo\n   1504  oooooooooooooooooooooooooooooooooooooooo\n   1544  oooooooooooooooooooooooooooooooooooooooo\n   1584  oooooooooooooooooooooooooooooooooooooooo\n15 1624  oooooooooooooooooooooooooooooooooooooooo\n   1664  oooooooooooooooooooooooooooooooooooooooo\n   1704  oooooooooooooooooooooooooooooooooooooooo\n   1744  oooooooooooooooooooooooooooooooooooooooo\n   1784  oooooooooooooooooooooooooooooooooooooooo\n20 1824  oooooooooooooooooooooooooooooooooooooooo\n   1864  oooooooooooooooooooooooooooooooooooooooo\n   1904  oooooooooooooooooooooooooooooooooooooooo\n   1944  oooooooooooooooooooooooooooooooooooooooo\n24 1984  oooooooooooooooooooooooooooooooooooooooo\n         |    |    |    |    |    |    |    |   |\n         0    5   10   15   20   25   30   35  39\n\n                          Column\n\n\n::::::::::::::::\n:: Appendix D ::\n::            ::\n::Screen Color::\n::Memory Table::\n::::::::::::::::\n\nRow\n 0 55296  oooooooooooooooooooooooooooooooooooooooo\n   55336  oooooooooooooooooooooooooooooooooooooooo\n   55376  oooooooooooooooooooooooooooooooooooooooo\n   55416  oooooooooooooooooooooooooooooooooooooooo\n   55456  oooooooooooooooooooooooooooooooooooooooo\n 5 55496  oooooooooooooooooooooooooooooooooooooooo\n   55536  oooooooooooooooooooooooooooooooooooooooo\n   55576  oooooooooooooooooooooooooooooooooooooooo\n   55616  oooooooooooooooooooooooooooooooooooooooo\n   55656  oooooooooooooooooooooooooooooooooooooooo\n10 55696  oooooooooooooooooooooooooooooooooooooooo\n   55736  oooooooooooooooooooooooooooooooooooooooo\n   55776  oooooooooooooooooooooooooooooooooooooooo\n   55816  oooooooooooooooooooooooooooooooooooooooo\n   55856  oooooooooooooooooooooooooooooooooooooooo\n15 55896  oooooooooooooooooooooooooooooooooooooooo\n   55936  oooooooooooooooooooooooooooooooooooooooo\n   55976  oooooooooooooooooooooooooooooooooooooooo\n   56016  oooooooooooooooooooooooooooooooooooooooo\n   56056  oooooooooooooooooooooooooooooooooooooooo\n20 56096  oooooooooooooooooooooooooooooooooooooooo\n   56136  oooooooooooooooooooooooooooooooooooooooo\n   56176  oooooooooooooooooooooooooooooooooooooooo\n   56216  oooooooooooooooooooooooooooooooooooooooo\n24 56256  oooooooooooooooooooooooooooooooooooooooo\n          |    |    |    |    |    |    |    |   |\n          0    5   10   15   20   25   30   35  39\n\n                           Column\n\n\n:::::::::::::::\n::Appendix E ::\n::           ::\n::  Screen   ::\n::Color Codes::\n:::::::::::::::\n\nValue to POKE for Each Color\n\n             Low nybble    High nybble   Select multicolor\nColor        color value   color value   color value\n\nBlack         0              0            8\nWhite         1             16            9\nRed           2             32           10\nCyan          3             48           11\nPurple        4             64           12\nGreen         5             80           13\nBlue          6             96           14\nYellow        7            112           15\nOrange        8            128           --\nBrown         9            144           --\nLight Red    10            160           --\nDark Gray    11            176           --\nMedium Gray  12            192           --\nLight Green  13            208           --\nLight Blue   14            224           --\nLight Gray   15            240           --\n\nWhere To POKE Color Values For Each Mode\n\n                 Bit or\nMode *           bit-pair   Location        Color value\n\nRegular text      0         53281           Low nybble\n                  1         Color memory    Low nybble\nMulticolor text  00         53281           Low nybble\n                 01         53282           Low nybble\n                 10         53283           Low nybble\n                 11         Color memory    Select Multicolor\nExtended color   00         53281           Low nybble\ntext +           01         53282           Low nybble\n                 10         53283           Low nybble\n                 11         53284           Low nybble\nBitmapped         0         Screen memory   Low nybble ++\n                  1         Screen memory   High nybble ++\nMulticolor       00         53281           Low nybble\nbitmapped        01         Screen memory   High nybble ++\n                 10         Screen memory   Low nybble ++\n                 11         Color memory    Low nybble\n\n* For all modes, the screen border color is controlled by POKEing\nlocation 53280 with the low nybble color value.\n\n+ In exteded color mode, Bits 6 and 7 of each byte of screen memory\nserve as the bit-pair controlling background color.  Because only Bits\n0-5 are available for character selection, only characters with screen\ncodes 0-63 can be used in this mode.\n\n++ In the bitmapped modes, the high and low nybble color values are\nORed together and POKEd into the same location in memory to control\nthe colors of the corresponding cell in the bitmap.  For example, to\ncontrol the colors of cell 0 of the bitmap, OR the high and low\nnybbles and POKE the result into location 0 of screen memory.\n\n\n:::::::::::::::\n::Appendix F ::\n::           ::\n::ASCII Codes::\n:::::::::::::::\n\n[*** OMITTED ***]\n[widely available elsewhere; not suitable for textual formatting]\n\n\n::::::::::::::::\n:: Appendix G ::\n::            ::\n::Screen Codes::\n::::::::::::::::\n\n[*** OMITTED ***]\n[widely available elsewhere; not suitable for textual formatting]\n\n\n:::::::::::::::\n::Appendix H ::\n::           ::\n:: Commodore ::\n::64 Keycodes::\n:::::::::::::::\n\nKey          Keycode                   Key          Keycode\nA            10                        6            19\nB            28                        7            24\nC            20                        8            27\nD            18                        9            32\nE            14                        0            35\nF            21                        +            40\nG            26                        -            43\nH            29                        LIRA         48\nI            33                        CLR/HOME     51\nJ            34                        INST/DEL      0\nK            37                        LEFT ARROW   57\nL            42                        @            46\nM            36                        *            49\nN            39                        ^            54\nO            38                        :            45\nP            41                        ;            50\nQ            62                        =            53\nR            17                        RETURN        1\nS            13                        ,            47\nT            22                        .            44\nU            30                        /            55\nV            31                        CRSR UP/DN    7\nW             9                        CRSR LF/RT    2\nX            23                        F1            4\nY            25                        F3            5\nZ            12                        F5            6\n1            56                        F7            3\n2            59                        SPACE        60\n3             8                        RUN/STOP     63\n4            11                        NO KEY\n5            16                        PRESSED      64\n\nThe keycode is the number found at location 197 for the current key\nbeing pressed.  Try this one-line program:\n\n10 PRINT PEEK(197):GOTO 10\n\n\n::::::::::::::\n::  Index   ::\n::          ::\n::(by memory::\n:: location)::\n::::::::::::::\n\nABS  48216\nAND  45033\nASC  46987\nATN  58126\nBASIC\n  adding new commands  115,768\n  current line number  57\n  execution of statements  776,42980\n  expression evaluation  778, 44446, 44675\n  function evaluation  44967\n  pointer to bottom of string text  51\n  pointer to current data item address  65\n  pointer to current statement address  61\n  pointer to end of array storage  49\n  pointer to start of array storage  47\n  pointer to start of program text  43\n  pointer to start of variable storage  45\n  pointer to top of BASIC RAM  55\n  program text storage  2048\n  RAM vector table  768\nBuffer\n  cassette I/O buffer  178, 828\n  keyboard buffer  198, 631\n  RS-232 input buffer 247\n  RS-232 output buffer  249\n  text input buffer  512\ncartridge, autostart ROM  32768\ncassette\n  data output line  01\n  I/O buffer  828\n  Kernal ROM routines  63466-64737\n  motor control  01, 192\n  switch sense  01\ncharacter generator ROM  01, 4096, 36864, 53248\ncharcter graphics  53248\nCHAREN  01\nCHRGET  115, 58274\nCHR$  46828\nCIA (Complex Interface Adapter)\n  CIA #1  56320-56335\n  CIA #2  56576-56591\n  data direction registers  56322, 56323, 56578, 56579\n  data ports  56320, 56321, 56576, 56577\n  timers  56334, 56335, 56590, 56591\nclock\n  clock speed (6510 microprocessor)  56334\n  software clock  160\n  Time of Day clock  56328, 56584\nCLOSE  57799\nCLR  42590\nCMD  43654\ncold start, BASIC  40960, 58260\ncolor\n  background  53281\n  border (frame)  53280\n  color codes  646\n  color RAM nybbles  55296\n  current character color  646\n  multicolor background registers 53282, 53283\n  PETASCII color change characters  59601\n  sprite color registers  53287-53294\n  sprite multicolor registers  53285, 53286\nCONT  43095\nCOS  57956\nDATA  43256\ndata direction register  00, 56322, 56323, 56578, 56579\ndata port  01, 56320, 56321, 56576, 56577\nDEF  46003\nDIM  45185\ndynamic keyboard  198, 631\nerror\n  BASIC error handler  768, 42039, 58251\n  error message control flag  157\n  I/O error status  144\n  RS-232 I/O error status  663\nEXP  49133\nexpression evaluation  778, 44446, 44675\nfloating point\n  addition  47207, 47210\n  division  47887, 47890\n  fixed-floating point conversion  05, 45969\n  floating-fixed point conversion  03, 45482, 45503\n  Floating Point Accumulators  97, 110\n  floating point-ASCII conversion  48605\n  multiplication  47656, 47667\n  subtraction  47194, 47194\nFN  46068\nFOR  42818\nFRE  45949\ngarbage collection, string variable  46374\nGET, GET#  43899\nGOSUB  43139\nGOTO  43168\ngraphics\n  bitmapped graphics  53265\n  character graphics  53248\n  extended background color mode  53265\n  fine scrolling  53265, 43271\n  multicolor mode  53271\n  raster position  53265, 53266\n  screen blanking  53265\n  sprites SEE sprite graphics\nHIRAM  01\nIF  43304\nINT  48332\ninterrupt\n  CIA hardware FLAG line  56589, 56333\n  CIA serial shift register  56589, 56333\n  CIA Time of Day clock alarm  56589, 56333\n  CIA Timers A and B  56589, 56333\n  IRQ handler  59953, 65352\n  IRQ vector  788, 65534\n  light pen IRQ  53273, 53274\n  NMI handler  65091\n  NMI vector  792, 65530\n  raster compare IRQ  53266, 53273, 53274\n  sprite-display data collision IRQ  53273, 53275\n  sprite-sprite collision IRQ  53273, 53275\nINPUT  43967\nINPUT#  43941\nI/O\n  current device number  186\n  current filename address 187\n  current filename length  183\n  current input device  153\n  current I/O channel number  19\n  current logical file number  184\n  current output device  154\n  current secondary address  185\n  device number table  611\n  logical file table  601\n  number of I/O files open  152\n  RS-232 status  663\n  secondary address table  621\n  status word codes  144\njoystick controllers  56320, 56321\nKernal\n  jump table  65409\n  RAM vector table  794\n  ACPTR  60947, 65445\n  CHKIN  798, 61966, 65478\n  CHKOUT  800, 62032, 65481\n  CHRIN  804, 61783, 65487\n  CHROUT  806, 61898, 65490\n  CINT  65371, 65409\n  CIOUT  60893, 65448\n  CLALL  812, 62255, 65511\n  CLOSE  796, 62097, 65475\n  CLRCHN  802, 62259, 65484\n  GETIN  810, 61758, 65508\n  IOBASE  58624, 65523\n  IOINIT  64931, 65412\n  LISTEN  60684, 65457\n  LOAD  816, 62622, 65493\n  MEMBOT  65076, 65436\n  MEMTOP  65061, 65433\n  OPEN  794, 62282, 65472\n  PLOT  58634, 65520\n  RAMTAS  64848, 65415\n  RDTIM  63197, 65502\n  READST  65031, 65463\n  RESTOR  64789, 65418\n  SAVE  818, 62941, 65496\n  SCNKEY  60039, 65439\n  SCREEN  58629, 65517\n  SECOND  60857, 65427\n  SETLFS  65024, 65466\n  SETMSG  65048, 65424\n  SETNAM  65017, 65469\n  SETTIM  63204, 65499\n  SETTMO  65057, 65442\n  STOP  808, 63213, 65505\n  TALK  60681, 65460\n  TKSA  60871, 65430\n  UDTIM  63131, 65514\n  UNLSN  60926, 65454\n  UNTLK  60911, 65451\n  VECTOR  64794, 65421\nkeyboard\n  current key pressed  203\n  keyboard buffer  631\n  keycodes  203\n  keyboard matrix  245, 655, 56321\n  last key pressed  197\n  number of characters in buffer  198\n  pointer to matrix lookup table  245\n  reading the keyboard  56320\n  repeating keys  650\nLEFT$  46848\nLEN  46972\nLET  43429\nlight pen  53267, 53268\nLIST  42652\nLOAD  57704\nLORAM  01\nMID$ 46903\nNEW  42562\nNEXT  44318\nNMI  65095\nON GOSUB, ON GOTO  43339\nOPEN  57790\nOperating System (OS)\n  OS end of RAM pointer  643\n  OS screen memory pointer  648\n  OS start of RAM pointer  641\nOR  45030\npaddle controllers  54297, 54298\npaddle fire button  56320, 56321\nPAL/NTSC flag  678\nPEEK  47117\nPOKE  47140\nPOS  45982\nPRINT  43680\nPRINT#  43648\nprogram text area  43, 2048\nprogram text input buffer  512\nRAM\n  BASIC pointer to end of RAM  55\n  RAM/ROM selection  01\n  OS pointer to end of RAM  643\n  OS pointer to start of RAM  641\nrandom number generator  54299\nREAD  44038\nregisters, reading/setting from BASIC  780\nREM  43323\nRESER, power-on  64738, 65532\nreset, VIC-II chip  53270\nRESTORE  43037\nRESTORE key, disabling  792, 808\nRETURN  43218\nRIGHT$  46892\nRND  139, 57495\nRS-232\n  baud rate  659, 661, 665\n  baud rate tables  58604, 65218\n  buffers  247, 249\n  command register  660\n  connector pin assignments  56576, 56577\n  control register  659\n  duplex mode  660\n  handshaking protocol  660\n  Kernal ROM routines  57344-65535\n  parity  660\n  status register  663\n  stop bits  659\n  word length  659\nRUN  43121\nSAVE  57686\nscreen editor\n  current character color  646\n  cursor color RAM position  243\n  cursor flash  204, 205, 207\n  cursor maintenance  206, 647\n  cursor screen position  209, 211, 214\n  insert mode flag  216\n  key repeat  650, 651, 652\n  quote mode flag  212\n  reverse character flag  199\n  screen line link table  217\n  screen RAM  1024, 648, 53272\n  shift flag  653, 654\nSerial Bus I/O  56576, 60681-61114\nSerial Data Port (CIA)  56332, 56588\nSGN  48185\nSID chip register  54272-54300\n  SEE ALSO sound\nSIN  57960\nsound\n  ADSR envelope control  54278-54279, 54285-54286, 54292-54293\n  filtering  54293-54296\n  frequency (pitch) control  54272-54273, 54279-54280, 54286-54287\n  gate bit  54276\n  Oscillator 3 envelope generator  54300\n  Oscillator 3 output  54299\n  pulse waveform pulse width  54274-54275, 54281-54282, 54288-54289\n  ring modulation  54276, 54283, 54290\n  synchronization (hard sync)  54276, 54283, 54290\n  volume control  54296\n  waveform control  54276, 54283, 54290\nsprite graphics\n  color registers  53287-53294\n  display priority  53275\n  enabling sprite display  53274\n  horizontal expansion  53277\n  multicolor color registers  53285-53286\n  multicolor sprites  53276\n  position registers  53248-53264\n  shape data pointers  2040\n  sprite-display data collision detection  53279\n  sprite-sprite collision detection  53278\n  vertical expansion  53271\nSQR  49009\nST (I/O status word)  144\nstack, 6510 microprocessor  256\nSTOP  43055\nSTOP key  145, 808\nSTR$  46181\nSYS  780, 57642\nTAN  56083\nTime of Day clock  56328-56331, 56584-56587\ntimers, hardware  56324-56327, 56334-56335, 56580-56583, 56590-56591\ntokens, keyword  772, 774, 40972, 41042, 41088, 41118, 42364, 42772\nUser Port  56567-56577\nUSR  785\nVAL  47021\nvariable\n  array variable storage  47\n  find or create variable routine  45195\n  storage format  45\n  string text area  51\nVERIFY  57701\nVIC-II CHIP\n  memory bank switching  56576\n  registers  53248-53294\n  SEE ALSO graphics, sprite graphics\nwarm start, BASIC  40962, 58235\nWAIT  47149\nwedges  115\n\n*********\n\nEnd Project 64 etext Mapping The Commodore 64.\n\n*********"
  }
]