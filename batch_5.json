[{"id": "map-A533", "address_start": 42291, "address_end": 42291, "hex_start": "$A533", "hex_end": "$A533", "label": "LINKPRG", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42291         $A533          LINKPRG\nRelink Lines of Tokenized Program Text\n\nEach line of program text starts with a pointer to the address of the\nnext line (link address).  This routine scans each line to the end\n(which is marked with a 0), and calculates the new link address by\nadding the offset to the address of the current statement."}, {"id": "map-A560", "address_start": 42336, "address_end": 42336, "hex_start": "$A560", "hex_end": "$A560", "label": "INLIN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42336         $A560          INLIN\nInput a Line to Buffer from Keyboard\n\nThis subroutine calls the Kernal CHRIN routine (61783, $F157) to\nobtain a line of input from the current input device (usually the\nkeyboard).  It stores the characters in the BASIC text input buffer at\n512 ($200) until a carriage return or 89 characters have been\nreceived.  The keyboard device will never return more than 80\ncharacters before a carriage return, but other devices can output a\nlonger line.  An error will occur if the line goes over 80 characters."}, {"id": "map-A579", "address_start": 42361, "address_end": 42361, "hex_start": "$A579", "hex_end": "$A579", "label": "CRUNCH", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42361         $A579          CRUNCH\nTokenize Line in Input Buffer\n\nWhen a line of program text has been input into the BASIC text buffer\nat 512 ($200), this routine goes through the line and changes any\nkeywords or their abbreviations, which do not appear in quotes, into\ntheir corresponding token.  This command is vectored through RAM at\n772 ($304), so it can be diverted in order to add new commands."}, {"id": "map-A613", "address_start": 42515, "address_end": 42515, "hex_start": "$A613", "hex_end": "$A613", "label": "FINDLN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42515         $A613          FINDLN\nSearch for Line Number\n\nThis routine searches through the program text, trying to match the\ntwo-byte integer line number that is stored in 20-21 ($14-$15).  If it\nis found, 95-96 ($5F-$60) will be set as a pointer to the address of\nthe link field for that line, and the Carry flag will be set.  If it\nis not found, the Carry flag will be cleared."}, {"id": "map-A642", "address_start": 42562, "address_end": 42562, "hex_start": "$A642", "hex_end": "$A642", "label": "SCRTCH", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42562         $A642          SCRTCH\nPerform NEW\n\nThe NEW command stores two zeros in the link address of the first\nprogram line to indicate the end of program, and sets the end of\nprogram pointer at 45-46 ($2D-$2E) to point to the byte past those\nzeros.  It continues through to the CLR command code."}, {"id": "map-A65E", "address_start": 42590, "address_end": 42590, "hex_start": "$A65E", "hex_end": "$A65E", "label": "CLEAR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42590         $A65E          CLEAR\nPerform CLR\n\nThe CLR command closes all I/O files with the Kernal CLALL routine\n(62255, $F32F).  It eliminates string variables by copying the end of\nmemory pointer at 55-56 ($37-$38) to the bottom of strings pointer at\n51-52 ($33-$34).  It also copies the pointer to the end of BASIC\nprogram text at 49-50 ($31-$31) to the pointer to the start of\nnonarray variables at 45-46 ($2D-$2E) and the start of array variables\nat 47-48 ($2F-$30).  This makes these variables unusable (although the\ncontents of these areas are not actually erased).  RESTORE is called\nto set the data pointer back to the beginning, and the stack is\ncleared."}, {"id": "map-A68E", "address_start": 42638, "address_end": 42638, "hex_start": "$A68E", "hex_end": "$A68E", "label": "RUNC", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42638         $A68E          RUNC\nReset Pointer to Current Text Character to the Beginning of Program\nText\n\nThis routine resets the CHRGET pointer TXTPTR (122-123, $7A-$7B) so\nthat the next byte of text that the interpreter will read comes from\nthe beginning of program text.\n\n52652         $A69C          LIST\nPerform LIST\n\nThis routine saves the range of lines to be printed in pointers at\n95-96 ($5F- $60) and 20-21 ($14-$15), and then prints them out,\ntranslating any tokens back to their ASCII equivalent."}, {"id": "map-A717", "address_start": 42775, "address_end": 42775, "hex_start": "$A717", "hex_end": "$A717", "label": "QPLOP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42775         $A717          QPLOP\nPrint BASIC Tokens as ASCII Characters\n\nThis is the part of the LIST routine that chagnes one-byte program\ntokens back to their ASCII text characters.  The routine is vectored\nthrough RAM at 774 ($306), so it is possible to list out new command\nwords that you have added by changing this vector to detour through\nyour own routine."}, {"id": "map-A742", "address_start": 42818, "address_end": 42818, "hex_start": "$A742", "hex_end": "$A742", "label": "FOR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42818         $A742          FOR\nPerform FOR\n\nFOR is performed mostly by saving the needed information for the NEXT\npart of the command on the stack (see the entry for 256 ($100) for\ndetails).  This includes the TO termination value, so if the upper\nlimit is a variable, the current value of the variable will be stored,\nand you cannot end the loop early by decreasing the value of the TO\nvariable within the loop (although you can end it early by increasing\nthe value of the FOR variable within the loop).\n\nAlso, since the TO expression is evaluated only once, at the time FOR\nis performed, a statement such as FOR I=1 TO I+100 is valid.  The\nterminating value is not checked until NEXT is executed, so the loop\nstatements always execute at least once.  The variable used by FOR\nmust be a nonarray floating point variable.  Reusing the same FOR\nvariable in a loop that is still active will cause the previous FOR\nloop and all intervening loops to be cancelled."}, {"id": "map-A7AE", "address_start": 42926, "address_end": 42926, "hex_start": "$A7AE", "hex_end": "$A7AE", "label": "NEWSTT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42926         $A7AE          NEWSTT\nSet Up Next Statement for Execution\n\nThis routine tests for the STOP key, updates the pointer to the\ncurrent line number, and positions the text pointer to read the\nbeginning of the statement."}, {"id": "map-A7E4", "address_start": 42980, "address_end": 42980, "hex_start": "$A7E4", "hex_end": "$A7E4", "label": "GONE", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "42980         $A7E4          GONE\nRead and Execute the Next Statement\n\nThis is the routine which gets the next token and executes the\nstatement.  It is vectored through RAM at 776 ($308) to allow the\naddition and execution of new statement tokens.\n\nSince a statement must always start with a token or an implied LET\nstatement, this routine checks to see if the first character is a\nvalid token.  If it is, the address is placed on the stack, so that a\ncall to CHRGET will return to the address of the code that executes\nthe statement (see the table of statement tokens at 40972 ($A00C)).\n\nAn invalid token will cause a SYNTAX ERROR.  A character whose ASCII\nvalue is less that 128 will cause LET to be executed."}, {"id": "map-A81D", "address_start": 43037, "address_end": 43037, "hex_start": "$A81D", "hex_end": "$A81D", "label": "RESTOR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43037         $A81D          RESTOR\nPerform RESTORE\n\nThe RESTORE command simply resetes the DATA pointer at 65-66 ($41-$42)\nfrom the start of BASIC pointer at 43-44 ($2B-$2V)."}, {"id": "map-A82C", "address_start": 43052, "address_end": 43052, "hex_start": "$A82C", "hex_end": "$A82C", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43052         $A82C\nTest STOP Key for Break in Program\n\nThe Kernal STOP routine is called from here, and if the key is\npressed, the STOP (63213, $F6ED) command, below, is executed.\n\n43055         $A831          END\nPerform END\n\nThe current line number and text pointers are preserved for a possible\nCONT command, and the READY prompt is printed.  If a STOP key break\noccured, the BREAK message is printed first."}, {"id": "map-A857", "address_start": 43095, "address_end": 43095, "hex_start": "$A857", "hex_end": "$A857", "label": "CONT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43095         $A857          CONT\nPerform CONT\n\nThe CONT statement is performed by moving the saved pointers back to\nthe current statement and current text character pointers.  If the\nsaved pointers cannot be retrieved, the CAN'T CONTINUE error statement\nis printed."}, {"id": "map-A871", "address_start": 43121, "address_end": 43121, "hex_start": "$A871", "hex_end": "$A871", "label": "RUN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43121         $A871          RUN\nPerform RUN\n\nRUN is executed by calling the Kernal SETMSG (65048, $FE18) routine to\nset the message flag for RUN mode and performing a CLR to start the\nprogram.  If a line followed RUN, a GOTO is executed after the CLR."}, {"id": "map-A883", "address_start": 43139, "address_end": 43139, "hex_start": "$A883", "hex_end": "$A883", "label": "GOSUB", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43139         $A883          GOSUB\nPerform GOSUB\n\nThis statement pushes the pointers to the current text character and\ncurrent line onto the stack, along with a constant 141 ($8D) which\nidentifies the block as saved GOSUB information to be used by RETURN.\nThe GOTO is called."}, {"id": "map-A8A0", "address_start": 43168, "address_end": 43168, "hex_start": "$A8A0", "hex_end": "$A8A0", "label": "GOTO", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43168         $A8A0          GOTO\nPerform GOTO\n\nThis statement scans BASIC for the target line number (the scan starts\nwith the current line if the target line number is higher, otherwise\nit starts with the first line).  When the line is found, the pointers\nto the current statement and text character are changed, so that the\ntarget statement will be executed next."}, {"id": "map-A8D2", "address_start": 43218, "address_end": 43218, "hex_start": "$A8D2", "hex_end": "$A8D2", "label": "RETURN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43218         $A8D2          RETURN\nPerform RETURN\n\nThe RETURN statement finds the saved GOSUB data on the stack, and uses\nit to restore the pointers to the current line and current character.\nThis will cause execution to continue where it left off when GOSUB was\nexecuted."}, {"id": "map-A8F8", "address_start": 43256, "address_end": 43256, "hex_start": "$A8F8", "hex_end": "$A8F8", "label": "DATA", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43256         $A8F8          DATA\nPerform DATA\n\nDATA uses the next subroutine to find the offset to the next\nstatement, and adds the offset to the current pointers so that the\nnext statement will be executed.  If effect, it skips the statement,\nmuch like REM."}, {"id": "map-A906", "address_start": 43270, "address_end": 43270, "hex_start": "$A906", "hex_end": "$A906", "label": "DATAN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43270         $A906          DATAN\nSearch Program Text for the End of the Current BASIC Statement\n\nThis routine starts at the current byte of program text and searches\nuntil it finds a zero character (line delimiter) or a colon character\nthat is not in quotes (statement delimiter)."}, {"id": "map-A928", "address_start": 43304, "address_end": 43304, "hex_start": "$A928", "hex_end": "$A928", "label": "IF", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43304         $A928          IF\nPerform IF\n\nIF uses the FRMEVL routine at 44446 ($AD9E) to reduce the expression\nwhich follows to a single term.  If the expression evaluates to 0\n(false), the routine falls through to REM.  If it is not 0, GOTO or\nthe statement following THEN is executed."}, {"id": "map-A93B", "address_start": 43323, "address_end": 43323, "hex_start": "$A93B", "hex_end": "$A93B", "label": "REM", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43323         $A93B          REM\nPerform REM\n\nThe REM statement is executed by skipping all program text until the\nbeginning of the next statement.  It is actually a part of the IF\nstatement, which continues for a few bytes after the REM part."}, {"id": "map-A94B", "address_start": 43339, "address_end": 43339, "hex_start": "$A94B", "hex_end": "$A94B", "label": "ONGOTO", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43339         $A94B          ONGOTO\nPerform ON GOTO or ON GOSUB\n\nON is performed by converting the argument to an integer, and then\nskipping a number between commas each time that the integer is\ndecremented until the argument reaches 0.  If a GOTO or GOSUB is the\nnext token, the current number between commas is used to execute one\nof those statements.  If the numbers between commas are used up before\nthe argument reaches 0, the statement has no effect, and the next\nstatement is executed."}, {"id": "map-A96B", "address_start": 43371, "address_end": 43371, "hex_start": "$A96B", "hex_end": "$A96B", "label": "LINGET", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43371         $A96B          LINGET\nConvert an ASCII Decimal Number to a Two-Byte Binary Line Nmumber\n\nThis subroutine is used by several statements to read a decimal\nnumber, convert it to a two-byte integer line number (in low-byte,\nhigh-byte format), and check that it is in the correct range of\n0-63999."}, {"id": "map-A9A5", "address_start": 43429, "address_end": 43429, "hex_start": "$A9A5", "hex_end": "$A9A5", "label": "LET", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43429         $A9A5          LET\nPerform LET\n\nThe LET command causes variables to be created and initialized, or to\nhave a new value assigned.  It handles all types of array or nonarray\nvariables:  strings, floating point, integers, ST, TI, and TI$.  The\nroutine is composed of several subroutines that evaluate the variable,\nevaluate the assigned expression, check that the assigned value is\nsuitable for a variable of that type, and then assign a value to the\nexisting variable, or create a new variable."}, {"id": "map-AA80", "address_start": 43648, "address_end": 43648, "hex_start": "$AA80", "hex_end": "$AA80", "label": "PRINTN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43648         $AA80          PRINTN\nPerform PRINT#\n\nThe PRINT# statement calls CMD and then closes the output channel with\nthe Kernal CLRCHN routine (62259, $F333)."}, {"id": "map-AA86", "address_start": 43654, "address_end": 43654, "hex_start": "$AA86", "hex_end": "$AA86", "label": "CMD", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43654         $AA86          CMD\nPerform CMD\n\nThis routine calls the Kernal CHKOUT routine (62032, $F250), and calls\nPRINT to send any included text to the device.  Unlike PRINT# it\nleaves the output channel open, so that output continues to go to that\ndevice."}, {"id": "map-AAA0", "address_start": 43680, "address_end": 43680, "hex_start": "$AAA0", "hex_end": "$AAA0", "label": "PRINT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43680         $AAA0          PRINT\nPerform PRINT\n\nThe PRINT routine has many segments, which are required for the\nvarious options which can be added to it:  TAB, SPC, comman,\nsemicolon, variables, PI, ST, TI, and TI$.  Eventually, all output is\nconverted to strings, and the Kernal CHROUT routine is called to print\neach character."}, {"id": "map-AB1E", "address_start": 43806, "address_end": 43806, "hex_start": "$AB1E", "hex_end": "$AB1E", "label": "STROUT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43806         $AB1E          STROUT\nPrint Message from a String Whose Address Is in the .Y and .A\nRegisters\n\nThis part of the PRINT routine outputs a string whose address is in\nthe Accumulator (low byte) and .Y register (high byte), and which ends\nin a zero byte."}, {"id": "map-AB4D", "address_start": 43853, "address_end": 43853, "hex_start": "$AB4D", "hex_end": "$AB4D", "label": "DOAGIN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43853         $AB4D          DOAGIN\nError Message Formatting Routines for GET, INPUT, and READ"}, {"id": "map-AB7B", "address_start": 43899, "address_end": 43899, "hex_start": "$AB7B", "hex_end": "$AB7B", "label": "GET", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43899         $AB7B          GET\nPerform GET and GET#\n\nThe GET routine first makes sure that the program is not in direct\nmode.  It opens an input channel using the Kernal CHKIN routine\n(61966, $F20E) if a number sign was added to make GET#.  Then it calls\nthe common I/O routines in READ to get a single character, and causes\nthe input channel to be closed if one was opened."}, {"id": "map-ABA5", "address_start": 43941, "address_end": 43941, "hex_start": "$ABA5", "hex_end": "$ABA5", "label": "INPUTN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43941         $ABA5          INPUTN\nPerform INPUT#\n\nThis routine opens an input channel with the Kernal CHKIN routine,\ncalls INPUT, and then closes the channel with a CHKOUT routine (62032,\n$F250).  Extra data is discarded without an EXTRA IGNORED message, and\na FILE DATA ERROR message is issued when the data type is not suitable\nfor the type of variable used."}, {"id": "map-ABBF", "address_start": 43967, "address_end": 43967, "hex_start": "$ABBF", "hex_end": "$ABBF", "label": "INPUT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "43967         $ABBF          INPUT\nPerform INPUT\n\nThe INPUT routine checks to make sure that direct mode is not active,\nprints prompts, receives a line of input from the device, and jumps to\nthe common code in READ that assigns the input to the variables which\nwere named."}, {"id": "map-AC06", "address_start": 44038, "address_end": 44038, "hex_start": "$AC06", "hex_end": "$AC06", "label": "READ", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44038         $AC06          READ\nPerform READ\n\nThis routine includes the READ command and common code for GET and\nINPUT.  The READ command locates the next piece of DATA, reads the\ntext, and converts it to the appropriate type of data to be assigned\nto a numeric or string variable."}, {"id": "map-ACFC", "address_start": 44284, "address_end": 44284, "hex_start": "$ACFC", "hex_end": "$ACFC", "label": "EXIGNT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44284         $ACFC          EXIGNT\nASCII Text for Input Error Messages\n\nThe text stored here is ?EXTRA IGNORED and ?REDO FROM START, each\nfollowed by a carriage return and a zero byte."}, {"id": "map-AD1E", "address_start": 44318, "address_end": 44318, "hex_start": "$AD1E", "hex_end": "$AD1E", "label": "NEXT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44318         $AD1E          NEXT\nPerform NEXT\n\nNEXT is executed by finding the appropriate FOR data on the stack,\nadding the STEP value to the FOR variable, and comparing the result to\nthe TO value.  If the loop is done, the stack entries for that FOR\ncommand are removed from the stack.  If the loop hasn't reached its\nlimit, the pointers to the current statement and text character are\nupdated from the FOR stack entry, which causes execution to continue\nwith the statement after the FOR statement."}, {"id": "map-AD8A", "address_start": 44426, "address_end": 44426, "hex_start": "$AD8A", "hex_end": "$AD8A", "label": "FRMNUM", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44426         $AD8A          FRMNUM\nEvaluate a Numeric Expression and/or Check for Data Type Mismatch\n\nThis routine can be called from different entry points to check the\ncurrent data against the desired data type (string or numeric) to see\nif they match.  If they don't, a TYPE MISMATCH error will result."}, {"id": "map-AD9E", "address_start": 44446, "address_end": 44446, "hex_start": "$AD9E", "hex_end": "$AD9E", "label": "FRMEVAL", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44446         $AD9E          FRMEVAL\nEvaluate Expression\n\nThis is the beginning point of a very powerful group of subroutines\nwhich are used extensively by BASIC.\n\nThe main purpose of these routines is to read in the ASCII text of\nBASIC expressions, separate the operators and terms of the expression,\ncheck them for errors, combine the individual terms by performing the\nindicated operations, and obtain a single value which the BASIC\nprogram can use.\n\nThis can be a very complex task, and expressions an be of the string\nor numeric type, and can contain any type of variable, as well as\nconstants.\n\nAt the end, the flag which shows whether the resulting value is string\nor numeric at 13 ($D) is set, and if the value is numeric, the flag at\n14 ($E) is set as well, to show if it is an integer or floating point\nnumer."}, {"id": "map-AE83", "address_start": 44675, "address_end": 44675, "hex_start": "$AE83", "hex_end": "$AE83", "label": "EVAL", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44675         $AE83          EVAL\nConvert a Single Numeric Term from ASCII Text to a Floating Point\nNumber\n\nThis routine reduces a single arithmetic term which is part of an\nexpression from ASCII text to its floating point equivalent.\n\nIf the term is a constant, the routine sets the data type flag to\nnumber, sets the text pointer to the first ASCII numeric character,\nand jumps to the routine which converts the ASCII string to a floating\npoint number.\n\nIf the term is a variable, the variable value is retrieved.  If it is\nthe PI character, the value of PI is moved into the Floating Point\nAccumulator.\n\nThis routine is vectored through RAM at 778 ($30A)."}, {"id": "map-AEA8", "address_start": 44712, "address_end": 44712, "hex_start": "$AEA8", "hex_end": "$AEA8", "label": "PIVAL", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44712         $AEA8          PIVAL\nPI Expressed as a Five-Byte Floating Point Number\n\nThe value of PI is stored here as a five-byte floating point number."}, {"id": "map-AEF1", "address_start": 44785, "address_end": 44785, "hex_start": "$AEF1", "hex_end": "$AEF1", "label": "PARCHK", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44785         $AEF1          PARCHK\nEvaluate Expression Within Parentheses\n\nThis routine evaluates an expression within parentheses by calling the\nsyntax checking routines that look for opening and closing\nparentheses, and then calling FRMEVL (4446, $AD9E) for each level of\nparentheses."}, {"id": "map-AEF7", "address_start": 44791, "address_end": 44791, "hex_start": "$AEF7", "hex_end": "$AEF7", "label": "CHKCLS", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44791         $AEF7          CHKCLS\nCheck for and Skip Closing Parentheses"}, {"id": "map-AEFA", "address_start": 44794, "address_end": 44794, "hex_start": "$AEFA", "hex_end": "$AEFA", "label": "CHKOPN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44794         $AEFA          CHKOPN\nCheck for and Skip Opening Parentheses"}, {"id": "map-AEFF", "address_start": 44799, "address_end": 44799, "hex_start": "$AEFF", "hex_end": "$AEFF", "label": "CHKCOM", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44799         $AEFF          CHKCOM\nCheck for and Skip Comma\n\nThis syntax checking device is the same in substance as the two\nchecking routines above.  It is used when the next character should be\na comma.  If it is not, a SYNTAX ERROR retults.  If it is, the\ncharacter is skipped and the next character is read.  Any character\ncan be checked for and skipped this way by loading the character into\nthe Accumulator and entering this routine from SYNCHR at 44799\n($AEFF)."}, {"id": "map-AF08", "address_start": 44808, "address_end": 44808, "hex_start": "$AF08", "hex_end": "$AF08", "label": "SNERR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44808         $AF08          SNERR\nPrint Syntax Error Message"}, {"id": "map-AF2B", "address_start": 44843, "address_end": 44843, "hex_start": "$AF2B", "hex_end": "$AF2B", "label": "ISVAR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44843         $AF2B          ISVAR\nGet the Value of a Variable"}, {"id": "map-AFA7", "address_start": 44967, "address_end": 44967, "hex_start": "$AFA7", "hex_end": "$AFA7", "label": "ISFUN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "44967         $AFA7          ISFUN\nDispatch and Evaluate a Function\n\nIf a BASIC function (like ASC(\"A\")) is part of an expression, this\nroutine will use the function dispatch table at 42242 ($A502) to set\nup the address of th proper function routine, and then branch to that\nroutine."}, {"id": "map-AFE6", "address_start": 45030, "address_end": 45030, "hex_start": "$AFE6", "hex_end": "$AFE6", "label": "OROP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45030         $AFE6          OROP\nPerform OR\n\nThe OR routine sets the .Y register as a flag, and falls through to\nthe AND routine, which also performs OR."}, {"id": "map-AFE9", "address_start": 45033, "address_end": 45033, "hex_start": "$AFE9", "hex_end": "$AFE9", "label": "ANDOP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45033         $AFE9          ANDOP\nPerform AND\n\nThe AND routine changes the parameters to two-byte integer values, and\nperforms the appropriate logical operation (AND or OR).  A result of 0\nsignifies false, while a result of -1 signifies true."}, {"id": "map-B016", "address_start": 45078, "address_end": 45078, "hex_start": "$B016", "hex_end": "$B016", "label": "DORE1", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "45078         $B016          DORE1\nPerform Comparisons\n\nThis routine does the greater than (>), less than (<), and equal (=)\ncomparisons for foating point numbers and strings.  The result in the\nFloating Point Accumulator will be 0 if the comparison is false, and\n-1 if it is true.\n\n45185         $B018          DIM\nPerform DIM\n\nThis command calls the next routine to create an array for every\nvariable dimensioned (since a statement can take the form DIM A(12),\nB(13), C(14)...).  If the array element is referenced before a DIM\nstatement (for example, A(3)=4), the array will be dimensioned to 10\n(as if DIM A(10) were executed).  Remember, DIMensioning an array to\n10 really creates 11 elements (10).  The 0 element should always be\nconsidered in calculating the size to DIMension your array."}]