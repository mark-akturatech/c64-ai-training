[{"id": "map-66", "address_start": 102, "address_end": 102, "hex_start": "$66", "hex_end": "$66", "label": "FACSGN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "102           $66            FACSGN\nFloating Point Accumulator #1: Sign\n\nA value of 0 here indicates a positive number, while a value of 255\n($FF) indicates a negative number."}, {"id": "map-67", "address_start": 103, "address_end": 103, "hex_start": "$67", "hex_end": "$67", "label": "SGNFLG", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "103           $67            SGNFLG\nNumber of Terms in a Series Evaluation\n\nThis location is used by mathematical formula evaluation routines.  It\nindicates the number of separate evaluations that must be done to\nresolve a complex expression down to a single term."}, {"id": "map-68", "address_start": 104, "address_end": 104, "hex_start": "$68", "hex_end": "$68", "label": "BITS", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "104           $68            BITS\nFloating Point Accumulator #1: Overflow Digit\n\nThis location contains the overflow byte.  The overflow byte is used\nin an intermediate step of conversion from an integer or text string\nto a floating point number."}, {"id": "map-69-6E", "address_start": 105, "address_end": 110, "hex_start": "$69", "hex_end": "$6E", "label": "FAC2", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "105-110       $69-$6E        FAC2\nFloating Point Accumulator #2\n\nA second Floating Point Accumulator, used in conjunction with Floating\nPoint Accumulator #1 in the evaluation of products, sums,\ndifferences--in short, any operation requiring more than one value.\nThe format of this accumulator is the same as FAC1."}, {"id": "map-69", "address_start": 105, "address_end": 105, "hex_start": "$69", "hex_end": "$69", "label": "ARGEXP", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "105           $69            ARGEXP\nFloating Point Accumulator #2: Exponent"}, {"id": "map-6A-6D", "address_start": 106, "address_end": 109, "hex_start": "$6A", "hex_end": "$6D", "label": "ARGHO", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "106-109       $6A-$6D        ARGHO\nFloating Point Accumulator #2: Mantissa"}, {"id": "map-6E", "address_start": 110, "address_end": 110, "hex_start": "$6E", "hex_end": "$6E", "label": "ARGSGN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "110           $6E            ARGSGN\nFloating Point Accumulator #2: Sign"}, {"id": "map-6F", "address_start": 111, "address_end": 111, "hex_start": "$6F", "hex_end": "$6F", "label": "ARISGN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "111           $6F            ARISGN\nResult of a Signed Comparison of Accumulator #1 to Accumulator #2\n\nUsed to indicate whether the two Floating Point Accumulators have like\nor unlike signs.  A 0 indicates like signs, a 255 ($FF) indicates\nunlike signs."}, {"id": "map-70", "address_start": 112, "address_end": 112, "hex_start": "$70", "hex_end": "$70", "label": "FACOV", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "112           $70            FACOV\nLow Order Mantissa Byte of Floating Point Accumulator #1 (For\nRounding)\n\nIf the mantissa of the floating point number has more significant\nfigures than can be held in four bytes, the least significant figures\nare placed here.  They are used to extend the accuracy of intermediate\nmathematical operations and to round to the final figure."}, {"id": "map-71-72", "address_start": 113, "address_end": 114, "hex_start": "$71", "hex_end": "$72", "label": "FBUFPT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "113-114       $71-$72        FBUFPT\nSeries Evaluation Pointer\n\nThis location points to the address of a temporary table of values\nbuilt in the free RAM area for the evaluation of formulas.  It is also\nused for such various purposes as a TI$ work area, string setup\npointer, and work space for the evaluation of the size of an array.\n\nAlthough this is labeled a pointer to the tape buffer in the\nProgrammer's Reference Guide, disassembly of the BASIC ROM reveals no\nreference to this location for that purpose (see 178 ($B2) for pointer\nto tape buffer)."}, {"id": "map-73-8A", "address_start": 115, "address_end": 138, "hex_start": "$73", "hex_end": "$8A", "label": "CHRGET", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "115-138       $73-$8A        CHRGET\nSubroutine: Get Next BASIC Text Character\n\nThis is actually a machine language subroutine, which at the time of a\nBASIC cold start (such as when the power is turned on) is copied from\nMOVCHG (58274, $E3A2) in the ROM to this zero page location.\n\nCHRGET is a crucial routine which BASIC uses to read text characters,\nsuch as the text of the BASIC program which is being interpreted.  It\nis placed on zero page to make the routine run faster.  Since it keeps\ntrack of the address of the character being read within the routine\nitself, the routine must be in RAM in order to update that pointer.\nThe pointer to the address of the byte currently being read is really\nthe operand of a LDA instruction.  When entered from CHRGET, the\nroutine increments the pointer by modifying the operand at TXTPTR\n(122, $7A), thus allowing the next character to be read.\n\nEntry at CHRGOT (121, $79) allows the current character to be read\nagain.  The CHRGET routine skips spaces, sets the various flags or the\nstatus register (.P) to indicate whether the character read was a\ndigit, statement terminator, or other type of character, and returns\nwith the retrieved character in the Accumulator (.A).\n\nSince CHRGET is used to read every BASIC statement before it is\nexecuted, and since it is in RAM, and therefore changeable, it makes a\nhandy place to intercept BASIC to add new features and commands (and\nin the older PET line, it was the only way to add such features).\nDiversion of the CHRGET routine for this purpose is generally referred\nto as a wedge.\n\nSince a wedge can greatly slow down execution speed, mose of the time\nit is set up so that it performs its preprocessing functions only when\nin direct or immediate mode.  The most well-known example of such a\nwedge is the \"Universal DOS Support\" program that allows easier\ncommunication with the disk drive command channel.\n\nAs this is such a central routine, a disassembly listing is given\nbelow to provide a better understanding of how it works."}, {"id": "map-73", "address_start": 115, "address_end": 115, "hex_start": "$73", "hex_end": "$73", "label": "CHRGET", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "115 $73   CHRGET  INC TXTPTR   ; increment low byte of TXTPTR"}, {"id": "map-75", "address_start": 117, "address_end": 117, "hex_start": "$75", "hex_end": "$75", "label": "BNE", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "117 $75           BNE CHRGOT   ; if low byte isn't 0, skip next"}, {"id": "map-77", "address_start": 119, "address_end": 119, "hex_start": "$77", "hex_end": "$77", "label": "INC", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "119 $77           INC TXTPTR+1 ; increment high byte of TXTPTR"}, {"id": "map-79", "address_start": 121, "address_end": 121, "hex_start": "$79", "hex_end": "$79", "label": "CHRGOT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "121 $79   CHRGOT  LDA          ; load byte from where TXTPTR points\n                               ; entry here does not update TXTPTR,\n                               ; allowing you to readl the old byte again"}, {"id": "map-7A", "address_start": 122, "address_end": 122, "hex_start": "$7A", "hex_end": "$7A", "label": "TXTPTR", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "122 $7A   TXTPTR  $0207        ; pointer is really the LDA operand\n                               ; TXTPTR+1 points to 512-580 ($200-$250)\n                               ; when reading from the input buffer\n                               ; in direct mode"}, {"id": "map-7C", "address_start": 124, "address_end": 124, "hex_start": "$7C", "hex_end": "$7C", "label": "POINTB", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "124 $7C   POINTB  CMP #$3A     ; carry flag set if > ASCII numeral 9"}, {"id": "map-7E", "address_start": 126, "address_end": 126, "hex_start": "$7E", "hex_end": "$7E", "label": "BCS", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "126 $7E           BCS EXIT     ; character is not a numeral--exit"}, {"id": "map-80", "address_start": 128, "address_end": 128, "hex_start": "$80", "hex_end": "$80", "label": "CMP", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "128 $80           CMP #$20     ; if it is an ASCI space..."}, {"id": "map-82", "address_start": 130, "address_end": 130, "hex_start": "$82", "hex_end": "$82", "label": "BEQ", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "130 $82           BEQ CHRGET   ; ignore it and get next character"}, {"id": "map-84", "address_start": 132, "address_end": 132, "hex_start": "$84", "hex_end": "$84", "label": "SEC", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "132 $84           SEC          ; prepare to subtract"}, {"id": "map-85", "address_start": 133, "address_end": 133, "hex_start": "$85", "hex_end": "$85", "label": "SBC", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "133 $85           SBC #$30     ; ASCII 0-9 are between 48-57 ($30-$39)"}, {"id": "map-87", "address_start": 135, "address_end": 135, "hex_start": "$87", "hex_end": "$87", "label": "SEC", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "135 $87           SEC          ; prepare to subtract again"}, {"id": "map-88", "address_start": 136, "address_end": 136, "hex_start": "$88", "hex_end": "$88", "label": "SBC", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "136 $88           SBC #$D0     ; if < ASCII 0 (57, $39) then carry is set"}, {"id": "map-8A", "address_start": 138, "address_end": 138, "hex_start": "$8A", "hex_end": "$8A", "label": "EXIT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "138 $8A   EXIT    RTS          ; carry is clear only for numeral on return\n\nThe Accumulator (.A register) holds the character that was read on\nexit from the routine.  Status register (.P) bits which can be tested\nfor on exit are:\n\n  Carry Clear if the character was an ASCII digit 0-9.\n  Carry Set, otherwise.\n  Zero Set only if the character was a statement terminator 0 or an\nASCII colon, 58 ($3A).\n  Zero Clear, otherwise.\n\n\nOne wedge insertion technique is to change CHRGET's INC $7A to a JMP\nWEDGE, have your wedge update TXTPTR itself, and then JSR CHRGOT.\nAnother is to change the CMP #$3A at location 124 ($7C), which I have\nlabeled POINTB, to a JMP WEDGE, do your wedge processing, and then\nexit through the ROM version of POINTB, which is located at 48283\n($E3AB).  For more detailed information about wedges, see Programming\nthe PET/CBM, Raeto Collin West, pages 365-68.\n\nWhile the wedge is a good, quick technique for adding new commands, a\nmuch more elegant method exists for accomplishing this task on the\nVIC-20 and 64 withouth slowing BASIC down to the extent that the wedge\ndoes.  See the entries for the BASIC RAM vector area at 768-779\n($300-$30B) for more details."}, {"id": "map-8B-8F", "address_start": 139, "address_end": 143, "hex_start": "$8B", "hex_end": "$8F", "label": "RNDX", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "139-143       $8B-$8F        RNDX\nRND Function Seed Value\n\nThis location holds the five-byte floating point value returned by the\nRND function.  It is initially set to a seed value copied from ROM\n(the five bytes are 128, 79, 199, 82, 88--$80, $4F, $C7, $52, $58).\n\nWhen the function RND(X) is called, the numeric value of X does not\naffect the number returned, but its sign does.  If X is equal to 0,\nRND generates a seed value from chip-level hardware timers.  If X is a\npositive number, RND(X) will return the next number in an arithmetic\nsequence.  This sequence continues for such a long time without\nrepeating itself, and gives such an even distribution of numbers, that\nit can be considered random.  If X is negative, the seed value is\nchanged to a number that corresponds to a scrambled floating point\nrepresentation of the number X itself.\n\nGiven a particular seed value, the same pseudorandom series of numbers\nwill always be returned.  This can be handy for debugging purposes,\nbut not where you wish to have truly random numbers.\n\nThe traditional Commodore method of selecting a random seed is by\nusing the expression RND(-TI), mostly because RND(0) didn't function\ncorrectly on early PETs.  While the RND(0) form doesn't really work\nright on the 64 either (see location 57495 ($E097)), the expression\nRND(-RND(0)) may produce a more random seed value."}, {"id": "map-90-FF", "address_start": 144, "address_end": 255, "hex_start": "$90", "hex_end": "$FF", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location_range", "text": "Location Range: 144-255 ($90-$FF)\nKernal Work Storage Area\n\nThis is the zero-page storage area for the Kernal.  The user should\ntake into account what effect changing a location here will have on\nthe operation of the Kernal functions before making any such changes.\n\nAt power-on, this range of locations is first filled with zeros, and\nthen initialized from values stored in ROM as needed."}, {"id": "map-90", "address_start": 144, "address_end": 144, "hex_start": "$90", "hex_end": "$90", "label": "STATUS", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "144           $90            STATUS\nKernal I/O Status Word (ST)\n\nThe Kernal routines which open I/O channels or perform input/output\nfunctions check and update this location.  The value here is almost\nalways the same as that returned to BASIC by use of the reserved\nvariable ST.  Note that BASIC syntax will not allow an assignment such\nas ST=4.  A table of status codes for cassette and serial devices\nfollows below:\n\nCassette:\nBit 2 (Bit Value of 4) = Short Block\nBit 3 (Bit Value of 8) = Long Block\nBit 4 (Bit Value of 16) = Unrecoverable error (Read), mismatch\nBit 5 (Bit Value of 32) = Checksum error\nBit 6 (Bit Value of 64) = End of file\n\nSerial Devices:\nBit 0 (Bit Value of 1) = Time out (Write)\nBit 1 (Bit Value of 2) = Time out (Read)\nBit 6 (Bit Value of 64) = EOI (End or Identify)\nBit 7 (Bit Value of 128) = Device not present\n\nProbably the most useful bit to test is Bit 6 (end of file).  When\nusing the GET statement to read in individual bytes from a file, the\nstatement IF ST AND 64 will be true if you have got to the end of the\nfile.\n\nFor status codes for the RS-232 device, see the entry for location 663\n($297)."}, {"id": "map-91", "address_start": 145, "address_end": 145, "hex_start": "$91", "hex_end": "$91", "label": "STKEY", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "145           $91            STKEY\nFlag: Was STOP Key Pressed?\n\nThis location is updated every 1/60 second during the execution of the\nIRQ routine that reads the keyboard and updates the jiffy clock.\n\nThe value of the last row of the keyboard matrix is placed here.  That\nrow contains the STOP key, and although this location is used\nprimarily to detect when that key has been pressed, it can also detect\nwhen any of the other keys in that row of the matrix have been\npressed.\n\nIn reading the keyboard matrix, a bit set to 1 means that no key has\nbeen pressed, while a bit reset to 0 indicates that a key is pressed.\nTherefore, the following values indicate the keystrokes detailed\nbelow:"}, {"id": "map-7F", "address_start": 127, "address_end": 127, "hex_start": "$7F", "hex_end": "$7F", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "127 $7F  = STOP key pressed\n\nVIC owners will notice that the 64's keyboard matrix is very different\nfrom the VIC's.  One of the advantages of this difference is that you\ncan test for the STOP key by following a read of this location with a\nBPL instruction, which will cause a branch to occur anytime that the\nSTOP key is pressed."}, {"id": "map-92", "address_start": 146, "address_end": 146, "hex_start": "$92", "hex_end": "$92", "label": "SVXT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "146           $92            SVXT\nTiming Constant for Tape Reads\n\nThis location is used as an adjustable timing constant for tape reads,\nwhich can be changed to allow for the slight speed variation between\ntapes."}, {"id": "map-93", "address_start": 147, "address_end": 147, "hex_start": "$93", "hex_end": "$93", "label": "VERCK", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "147           $93            VERCK\nFlag for Load Routine: 0=LOAD, 1=VERIFY\n\nThe same Kernal routine can perform either a LOAD or VERIFY, depending\non the value stored in the Accumulator (.A) on entry to the routine.\nThis location is used to determine which operation to perform."}, {"id": "map-94", "address_start": 148, "address_end": 148, "hex_start": "$94", "hex_end": "$94", "label": "C3PO", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "148           $94            C3PO\nFlag: Serial Bus--Output Character Was Buffered\n\nThis location is used by the serial output routines to indicate that a\ncharacter has been placed in the output buffer and is waiting to be\nsent."}, {"id": "map-95", "address_start": 149, "address_end": 149, "hex_start": "$95", "hex_end": "$95", "label": "BSOUR", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "149           $95            BSOUR\nBuffered Character for Serial Bus\n\nThis is the character waiting to be sent.  A 255 ($FF) indicates that\nno character is waiting for serial output."}, {"id": "map-96", "address_start": 150, "address_end": 150, "hex_start": "$96", "hex_end": "$96", "label": "SYNO", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "150           $96            SYNO\nCassette Block Synchronization Number"}, {"id": "map-97", "address_start": 151, "address_end": 151, "hex_start": "$97", "hex_end": "$97", "label": "XSAV", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "151           $97            XSAV\nTemporary .X Register Save Area\n\nThis .X register save area is used by the routines that get and put an\nASCII character."}, {"id": "map-98", "address_start": 152, "address_end": 152, "hex_start": "$98", "hex_end": "$98", "label": "LDTND", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "152           $98            LDTND\nNumber of Open I/O Files/Index to the End of File Tables\n\nThe number of currently open I/O files is stored here.  The maximum\nnumber that can be open at one time is ten.  The number stored here is\nused as the index to the end of the tables that hold the file numbers,\ndevice numbers, and secondary address numbers (see locations 601-631\n($259-$277) for more information about these tables).\n\nCLOSE decreases this number and removes entries from the tables\nreferred to above, while OPEN increases it and adds the appropriate\ninformation to the end of the tables.  The Kernal routine CLALL closes\nall files by setting this number to 0, which effectively empties the\ntable."}, {"id": "map-99", "address_start": 153, "address_end": 153, "hex_start": "$99", "hex_end": "$99", "label": "DFLTN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "153           $99            DFLTN\nDefault Input Device (Set to 0 for Keyboard)\n\nThe default value of this location is 0, which designates the keyboard\nas the current input device.  That value can be changed by the Kernal\nroutine CHKIN (61966, $F20E), which uses this location to store the\ndevice number of the device whose file it defines as an input channel.\n\nBASIC calls CHKIN whenever the command INPUT# or GET# is executed, but\nclears the channel after the input operation has been completed."}, {"id": "map-9A", "address_start": 154, "address_end": 154, "hex_start": "$9A", "hex_end": "$9A", "label": "DFLTO", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "154           $9A            DFLTO\nDefault Output (CMD) Device (Set to 3 for the Screen)\n\nThe default value of this location is 3, which designates the screen\nas the current output device.  That value can be changed by the Kernal\nroutine CHKOUT (62032, $F250), which uses this location to store the\ndevice number of the device whose file it defines as an output\nchannel.\n\nBASIC calls CHKOUT whenever the command PRINT# or CMD is executed, but\nclears the channel after the PRINT# operation has been completed."}, {"id": "map-9B", "address_start": 155, "address_end": 155, "hex_start": "$9B", "hex_end": "$9B", "label": "PRTY", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "155           $9B            PRTY\nTape Character Parity\n\nThis location is used to help detect when bits of information have\nbeen lost during transmission of tape data."}, {"id": "map-9C", "address_start": 156, "address_end": 156, "hex_start": "$9C", "hex_end": "$9C", "label": "DPSW", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "156           $9C            DPSW\nFlag: Tape Byte Received\n\nThis location is used as a flag to indicate whether a complete byte of\ntape data has been received, or whether it has only been partially\nreceived."}, {"id": "map-9D", "address_start": 157, "address_end": 157, "hex_start": "$9D", "hex_end": "$9D", "label": "MSGFLG", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "157           $9D            MSGFLG\nFlag: Kernal Message Control\n\nThis flag is set by the Kernal routine SETMSG (65048, $FE18), and it\ncontrols whether or not Kernal error messages or control messages will\nbe displayed.\n\nA value of 192 ($C0) here means that both Kernal error and control\nmessages will be displayed.  This will never normally occur when using\nBASIC, which prefers its own plain text error messages over the\nKernal's perfunctory I/O ERROR (number).  The Kernal error messages\nmight be used, however, when you are SAVEing or LOADing with a machine\nlanguage monitor.\n\nA 128 ($80) means that control messages only will be displayed.  Such\nwill be the case when you are in the BASIC direct or immediate mode.\nThese messages include SEARCHING, SAVING, FOUND, etc.\n\nA value of 64 means that Kernal error messages only are on.  A 0 here\nsuppresses the display of all Kernal messages.  This is the value\nplaced here when BASIC enters the program or RUN mode."}, {"id": "map-9E", "address_start": 158, "address_end": 158, "hex_start": "$9E", "hex_end": "$9E", "label": "PTR1", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "158           $9E            PTR1\nTape Pass 1 Error Log Index\n\nThis location is used in setting up an error log of bytes in which\ntransmission parity errors occur the first time that the block is\nreceived (each tape block is sent twice to minimize data loss from\ntransmission error)."}, {"id": "map-9F", "address_start": 159, "address_end": 159, "hex_start": "$9F", "hex_end": "$9F", "label": "PTR2", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "159           $9F            PTR2\nTape Pass 2 Error Log Correction Index\n\nThis location is used in correcting bytes of tape data which were\ntransmitted incorrectly on the first pass."}, {"id": "map-A0-A2", "address_start": 160, "address_end": 162, "hex_start": "$A0", "hex_end": "$A2", "label": "TIME", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "160-162       $A0-$A2        TIME\nSoftware Jiffy Clock\n\nThese three locations are updated 60 times a second, and serve as a\nsoftware clock which counts the number of jiffies (sixtieths of a\nsecond) that have elapsed since the computer was turned on.\n\nThe value of location 162 ($A2) is increased every jiffy (0.1667\nsecond), 161 ($A1) is updated every 256 jiffies (4.2267 seconds), and\n160 ($A0) changes every 65536 jiffies (or every 18.2044 minutes).\nAfter 24 hours, these locations are set back to 0.\n\nThe jiffy clock is used by the BASIC reserved variables TI and TI$.\nThese are not ordinary variables that are stored in the RAM variable\narea, but are functions that call the Kernal routines RDTIM (63197,\n$F6DD), and SETTIM (63204, $F6E4).  Assigning the value of TI or TI$\nto another variable reads these locations, while assigning a given\nvalue to TI$ alters these locations.\n\nTo illustrate the relationship between these locations and TI$, try\nthe following program.  The program sets the jiffy clock to 23 hours,\n50 minutes.  After the program has been running for one minute, all\nthese locations will be reset to 0.\n\n100 TI$=\"235900\"\n110 PRINT TI$,PEEK(160),PEEK(161),PEEK(162)\n120 GOTO 110\n\nSince updating is done by the IRQ interrupt that reads the keyboard,\nanything which affects the operation of that interrupt routine will\nalso interfere with this clock.  A typical example is tape I/O\noperations, which steal the IRQ vector for their own use, and restore\nit afterwards.  Obviously, user routines which redirect the IRQ and do\nnot send it back to the normal routine will upset software clock\noperation as well."}, {"id": "map-A3-A4", "address_start": 163, "address_end": 164, "hex_start": "$A3", "hex_end": "$A4", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "163-164       $A3-$A4\nTemporary Data Storage Area\n\nThese locations are used temporarily by the tape and serial I/O\nroutines."}, {"id": "map-A5", "address_start": 165, "address_end": 165, "hex_start": "$A5", "hex_end": "$A5", "label": "CNTDN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "165           $A5            CNTDN\nCassette Synchronization Character Countdown\n\nUsed to count down the number of synchronization characters that are\nsent before the actual data in a tape block."}, {"id": "map-A6", "address_start": 166, "address_end": 166, "hex_start": "$A6", "hex_end": "$A6", "label": "BUFPNT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "166           $A6            BUFPNT\nCount of Characters in Tape I/O Buffer\n\nThis location is used to count the number of bytes that have been read\nin or written to the tape buffer.  Since on a tape write, no data is\nsent until the 192 byte buffer is full, you can force output of the\nbuffer with the statement POKE 166,191."}, {"id": "map-A7", "address_start": 167, "address_end": 167, "hex_start": "$A7", "hex_end": "$A7", "label": "INBIT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "167           $A7            INBIT\nRS-232 Input Bits/Cassette Temporary Storage Area\n\nThis location is used to temporarily store each bit of serial data\nthat is received, as well as for miscellaneous tasks by tape I/O."}, {"id": "map-A8", "address_start": 168, "address_end": 168, "hex_start": "$A8", "hex_end": "$A8", "label": "BITCI", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "168           $A8            BITCI\nRS-232 Input Bit Count/Cassete Temporary Storage\n\nThis location is used to count the number of bits of serial data that\nhas been received.  This is necessary so that the serial routines will\nknow when a full word has been received.  It is also used as an error\nflag during tape loads."}]