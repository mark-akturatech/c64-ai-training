*********

Welcome to Project 64!

The goal of Project 64 is to preserve Commodore 64 related documents
in electronic text format that might otherwise cease to exist with the
rapid advancement of computer technology and declining interest in 8-
bit computers on the part of the general population.

Extensive efforts were made to preserve the contents of the original
document.  However, certain portions, such as diagrams, program
listings, and indexes may have been either altered or sacrificed due
to the limitations of plain vanilla text.  Diagrams may have been
eliminated where ASCII-art was not feasible.  Program listings may be
missing display codes where substitutions were not possible.  Tables
of contents and indexes may have been changed from page number
references to section number references. Please accept our apologies
for these limitations, alterations, and possible omissions.

Document names are limited to the 8.3 file convention of DOS. The
first characters of the file name are an abbreviation of the original
document name. The version number of the etext follows next. After
that a letter may appear to indicate the particular source of the
document. Finally, the document is given a .TXT extension.

The author(s) of the original document and members of Project 64 make
no representations about the accuracy or suitability of this material
for any purpose.  This etext is provided "as-is".  Please refer to the
warantee of the original document, if any, that may included in this
etext.  No other warantees, express or implied, are made to you as to
the etext or any medium it may be on.  Neither the author(s) nor the
members of Project 64 will assume liability for damages either from
the direct or indirect use of this etext or from the distribution of
or modification to this etext. Therefore if you read this document or
use the information herein you do so at your own risk.

*********

The Project 64 etext of the ~Mapping The Commodore 64 book~, typed
by David Holz <david_holz@hotmail.com>, formatted to 71 columns and
somewhat proofed by Cris Berneburg <pcgeek@compuserve.com>.

MAPC6410.TXT, May 1998, etext #352#

Note from the tired typist:

WHEW!  This is a LOT of text.  And, yes, this whole darned 11,000-line
thing was completely hand-typed.  As for the content, I tried to get
everything exactly word-for-word.  However, many typos are bound to be
lurking in these pages.  Thus I give permission for anybody to edit
and repost this file without having to contact me.  I also made some
minor changes, which include throwing out page numbers and
delimitation, filling up to 79 columns wide, listing out some
ordinary-formatted text into somewhat formatted tables, and correcting
some typos and errors in the original text.

The book bears Sheldon Leemon's name and was published by Compute!
Publications, (c) 1984.  Again (like the Project 64 header should
read), this copy is meant for reference only, and to preserve its
contents from being eternally lost.  No monetary or other damages to
Compute! Publications or Sheldon Leemon are meant by the creation and
transfer of this electronic book, and the intellectual ownership of
the contents of this text by the above parties is hereby acknowledged.
No profit is to be made from the transfer of this electronic copy!  I
claim no responsibility for anything that anybody does with the text
herein, as do the original author and publisher.

Without further ado, here's one of the best C64 references around!
Enjoy!

White Flame (aka David Holz)
http://www.geocities.com/ResearchTriangle/Lab/1767

*********

MAPPING THE Commodore 64

::::::::::::
::Contents::
::::::::::::

Foreword

Acknowledgments

Introduction

Chapter 1.  Page 0

Chapter 2.  Page 1

Chapter 3.  Pages 2 and 3
  BASIC and Kernal Working Storage

Chapter 4.  1K to 40K
  Screen, Memory, Sprite Pointers, and
  BASIC Program Text

Chapter 5.  8K BASIC ROM and 4K Free RAM

Chapter 6.  VIC-II, SID, I/O Devices, Color RAM,
  and Character ROM

Chapter 7. 8K Operating System Kernal ROM

Appendix A.  A Beginner's Guide to
  Typing In Programs

Appendix B.  How to Type In Programs

Appendix C.  Screen Location Table

Appendix D.  Screen Color Memory Table

Appendix E.  Screen Color Codes

Appendix F.  ASCII Codes
  [*** OMITTED ***]
  [widely available elsewhere; not suitable for textual formatting]

Appendix G.  Screen Codes
  [*** OMITTED ***]
  [widely available elsewhere; not suitable for textual formatting]

Appendix H.  Commodore 64 Keycodes

Index (By Memory Location)


::::::::::::
::Foreword::
::::::::::::

This is a memory map of the Commodore 64 personal computer.  But it's
much more than that.  It's a reference book which every programmer who
uses the 64 will find invaluable.  What is a memory map?  It's a list
of the memory locations in a computer.  But Mapping the Commodore 64
is a memory amp that goes much further.  It explains the purpose of
each location and shows you how to change the contents of many of
them.  You can make the computer do what you want it to.  If you're a
BASIC programmer, you'll find easy-to-understand explanations of how
to use the advanced features of the Commodore 64, and how to include
these features in your own programs.  If you're already using machine
language to write your own programs, you'll use this guide over and
over again, referring to specific memory locations and routines.
You'll have the most complete guide to the Commodore 64's memory
available.

As with all COMPUTE! books, the explanations are clear and easy to
understand.  Beginning and advanced programmers alike will find
Mapping the Commodore 64 a valuable resource.


::::::::::::::::::::
::Acknowledgements::
::::::::::::::::::::

I would like to thank Russ Davies, author of Mapping the VIC, for his
generosity in sharing the results of his research.  Without his help,
and that of Dan Heeb, author of the The Commodore 64 and VIC Tool Kit,
this book would have been much less complete.

Of all the published sources of information about the 64, I have found
the Commodore 64 Programmer's Reference Guide to be the most valuable
for technical information.  That Commodore has come out with such a
thorough reference work so quickly after the introduction of the
machine is much to their credit.  Because of the similarities between
the 64 and previous Commodore computers, I have also relied heavily on
ooks that deal with the PET/CBM.  Of particular interest are
Programming the PET/CBM by Raeto West, which should be subtitled
"Everything You Ever Wanted to Know about Commodore Computers," and
the PET/CBM Personal Computer Guide, Third Edition, Osborne/
McGraw-Hill.  These important reference works contain more information
of real benefit to the 64 owner than most books which deal
specifically with the 64.

Finally, I would like to thank my wife Lenore.  Although her
contribution to this book was nontechnical in nature, it was as
important as any other.


::::::::::::::::
::Introduction::
::::::::::::::::

To many computer users, the concept of a memory map may be an
unfamiliar one.  Simply stated, it is a guide to your computer's
internal hardware and software.  A memory map can help you use the
PEEK and POKE instructions to extend your BASIC programming powers.
If you plan to do machine language programming, it is necessary that
you be able to find your way around the system.

Many computer owners think of a program as something they buy at a
store and feed into the computer so that it will let them play games,
or do word processing, or keep financial records.  But this type of
applications software is by no means the only kind.

It is important to remember that a computer cannot do anything without
some kind of program.  When the computer displays the READY prompt, or
blinks the cursor, or displays the letters that you type, it can only
do so by executing a program.  In the examples shown above, it is the
master control program, the Operating System (OS), which is being
executed.

When you give the computer a command such as LOAD, the BASIC
interpreter program translates the English-like request to the
language of numbers which the computer understands.  The Operating
System and BASIC interpreter programs are contained in permanent Read
Only Memory (ROM), and are available as soon as you turn the power on.
Without them, your computer would be a rather expensive paperweight.

This permanent software co-exists inside your computer with the
applications program that you load.  Since the system software
performs many of the same functions as the applications program (such
as reading information from the keyboard and displaying it on the
screen), it is often possible for the applications program to make use
of certain parts of the Operating System.  This not only makes the
task of the programmer easier, but in come cases it allows him or her
to do things that otherwise would not be possible.

The Commodore 64 also has hardware support chips which enable the
graphics display, sound synthesis, and communications with external
devices.  Since these chips are addressed like memory, they occupy
space in our map.  Control over these chips, and the graphics, sound,
and I/O functions they make possible, can only be accomplished by
manipulation of the memory addresses which correspond to these
devices.  Therefore, a guide to these addresses is necessary in order
to take advantage of the graphics, music, and communications power
that they offer.

The purpose of this book is to describe the memory locations used by
the system, and to show, wherever possible, how to utilize them in
your own programs.  The book should clear up some of the mystery
surrounding the way your computer works.

How to Use This Book

The Commodore 64 and communicate with 64K or 65536 (64*1024) bytes of
memory.  Each of these bytes of memory can store a number from 0 to
255.  The computer can read (and sometimes write) information from any
of these 65536 locations by using its address, a number from 0 to
65535.

Bits and Bytes

Each byte is make up of eight binary digits called bits.  These bits
are the computer's smallest unit of information.  They can contain
only the number one or the number zero, but when combined, they can be
used to form any number needed.  To see how that is possible, let's
look at a single bit.

A single bit can only be a one or a zero.  But if two bits are
combined the number increases.

00,01,10,11

That makes four possible combinations.  And if a third bit is added:

000,001,010,011,100,101,110,111

When eight bits are put together, the number of combinations increases
to 256.  These eight bits are called a byte and can be used to
represent the numbers from 0 to 255.

This system of numbering is known as binary (or base two).  It works
much like the decimal (base ten) system.  In the base ten numbering
system, the rightmost digit is known as the one's place, and holds a
number from 0 to 9.  The next place to the left is known as then ten's
place, and also holds a number from 0 to 9, which represents the
number of times the one's place has been used in counting (the number
of tens).

In the binary system, there is a one's place, then a two's place, a
four's place, etc.  The bits are counted from right to left, starting
with Bit 0.  Here are the values of each bit:

Bit 0 = 1
Bit 1 = 2
Bit 2 = 4
Bit 3 = 8
Bit 4 = 16
Bit 5 = 32
Bit 6 = 64
Bit 7 = 128

If all the bits are added together (128+64+32+16+4+2+1), they total
255, which is the maximum value of one byte.  What if you need to
count higher than 255?  Use two bytes.

By using a second bytere to count the number of 255's, 65536
combinations are possible (256*256).  This is the same number as the
bytes of memory in the Commodore 64.  Therefore, any byte can be
addressed by a number using a maximum of two bytes.

When discussing large, even units of memory, the second byte, the
number of 256's, is often used alone.  These units are known as pages.
Page 0 starts at location zero (0*256), Page 1 starts at location 256
(1*256), etc.

You may see thn terms low-byte, high-byte order or LSB (Least
Significant Byte), MSB (Most Significant Byte) order, mentioned later
in this book.  That refers to the way in which the Commodore 64
usually deals with a two-byte address.  The byte of the address that
represents the number of 256's (MSB) is usually stored higher in
memory than the part that stores the leftover value from 0 to 255
(LSB).  Therefore, to find the address, you must add the LSB to
256*MSB.

Hexadecimal

One other numbering system that is used in speaking about computers is
the hexadecimal (base 16) system.  Each hexadecimal digit can count a
number from 0 to 15.  Since the highest numeric digit is 9, the
alphabet must be used:  A=10, B=11, and so on up to F=15.  With just
two digits, 256 combinations are possible (16*16).  That means that
each byte can be represented by just two hexadecimal digits, each of
which stands for four bits of memory.  These four- bit units are
smaller than a byte, so they are known as nybbles.

Since programmers often find that hexadecimal numbers are easier to
use than binary or decimal numbers, many numbers in this book are
given in both decimal and hexadecimal format.  A dollar sign ($) has
been placed in front of each hexadecimal number.

AND, OR, and EOR

Certain functions on the 64 (particularly those using the sound and
graphics chips) are controlled by a single bit.  You will often see
references to setting Bit 6 to a value of one, or setting Bit 3 to a
value of zero.  This can be done by adding or subtracting the bit
value for that particular bit from the value of the whole byte.

Adding or subtracting the bit value will work only if you know the
status of that bit already.  If Bit 4 is off, and you add 16 (the bit
value of Bit 4) to the byte, it will turn Bit 4 on.  But if it were on
already, adding 16 would turn Bit 4 off, and another bit on.

This is where logical (sometimes called Boolean) functions come in
handy.  Two functions, OR and AND, are available in BASIC, and a
third, EOR, can be used in machine language programming for bit
manipulation.

AND is usually used to zero out (or mask) unwanted bits.  When you AND
a number with another, a 1 will appear in the resulting number only of
identical bits in the ANDed numbers had been set to 1.  For example,
if you wanted to turn of Bit 4 in the number 154, you could AND it
with 239 (which is the maximum bit combination minus the bit value to
be masked; 255-16):

    10011010 = 154
AND 11101111 = 239
    --------
  = 10001010 = 138

By using the AND function, nothing would be harmed if we tried to turn
off a bit that wasn't on.  You can always turn a bit off by using the
formula BYTEVALUE AND (255-BITVALUE).  Remember, there must be a 1 in
the same bit of both numbers in order for the same bit in the result
to have a 1.

The opposite function, turning a bit on, is performed by the OR
statement.  The OR function puts a 1 in the bit of the resulting
number if there was a 1 in the same bit in either of the two numbers.
For example, to turn Bit 4 back on in the number 138, we would use the
statement 138 OR 16 (the bit value for the bit we want to turn on):

    10001010 = 138
OR  00010000 =  16
    --------
  = 10011010 = 154

Again, no harm would be done if the bit was already on.  A bit can
always be turned on with the formula BYTEVALUE OR BITVALUE.

The third operation, EOR, can be done only in machine language.  It is
used to reverse the value of a bit.  If the bit of the second number
holds a 1, it will reverse the value of the corresponding bit in the
first number.  Therefore, to switch all of the bits, you can EOR a
number by 255:

    10011010 = 154
EOR 11111111 = 255
    --------
  = 01100101 = 101

Notice that this produces the complement of the original number (256
minus the number).  Anytime you with to flip a bit from 0 to 1, or 1
to 0, you can EOR it with the value of that bit.

The Format of Entries

The entries in this book are organized at the most general level by
large blocks 9the 256 page 0 locations, for example, or the 8192
locations in the BASIC ROM).  At the beginning of these blocks, you
will often find an explanation that will give you an idea of how the
lcoations in that section are related.  Usually, this overview will
make it easier to understand the more detailed explanations of the
individual locations in that block.

Within these larger blocks, you will sometimes see a few locations
grouped under the heading Location Range.  This grouping is done where
the locations are so interrelated that it would be meaningless to try
to explain one without explaining them all.

Finally comes the entries for individual locations.  These give the
address, first in decimal, then in hexadecimal, and sometimes a label.
This label is merely a mnemonic device, used in machine language
programming, for easier reference to a particular memory location.
Although Commodore has not released the source code for their
Operating System or BASIC, they have published some of these labels in
the Commodore 64 Programmer's Reference Guide.

Other labels used here are taken from Jim Butterfield's PET memory
maps, which have enjoyed a wide circulation among Commodore users.
Their use here should help 64 owners adapt information about the PET
to their own machines.

The mnemonic label for an entry is followed by a one-line description
of the location.  Often, a more detailed explanation will appear under
that, ranging from a couple of sentences to several pages.
Occasionally, program samples will accompany these explanations.

Sometimes the single-line descriptions will identify a location as a
flag, a vector, or a pointer.  A flag is just a number that the
program uses to store the outcome of a previous operation.  A pointer
of vector is usually a two-byte location that holds a significant
address.  Generally, the term pointer is used when the address points
to the start of some data, and vector is used when the address points
to the start of a machine language program.  However, sometimes these
terms will be used interchangeably, with the meaning clear from the
context.


:::::::::::::
