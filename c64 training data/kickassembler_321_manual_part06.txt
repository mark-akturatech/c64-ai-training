# KickAssembler Script Language - Expressions, Variables, Constants

            lda table1,x
            …
                                                                                                  12
Note that virtual memory blocks can overlap other memory blocks. They are marked with an
asterisk in the memory map.
   Memory Map
   ----------------------------
   *$0400-$05ff Data Tables 1
   *$0400-$064f Data Tables 2
   $1000-$1005 Program
Since virtual memory blocks aren’t saved, the above example will only save the memory from
$1000 to $1005.
With the .align directive, you can align the program counter to a given interval. This is useful for
optimizing your code as crossing a memory page boundary yields a penalty of one cycle for
memory referring commands. To avoid this, use the .align command to align your tables:
   .pc = $1000 “Program”
            ldx #1
            lda data,x
            rts
   .pc = $10ff               //Bad place for the data
   .align $100               //Alignment to the nearest page boundary saves a cycle
   data: .byte 1,2,3,4,5,6,7,8
The .byte, .word, .dword and .text directives are used to generate byte, word (one word= two
bytes), dword (double word = 4 bytes) and text data as in standard 6510 assemblers (see previous
example).
With the .fill directive you can fill a section of the memory with bytes. It works like a loop and
automatically sets the variable i to the byte number.
   .fill 5, 0                // Generates byte 0,0,0,0,0
   .fill 5, i                // Generates byte 0,1,2,3,4
   .fill 256, 127.5 + 127.5*sin(toRadians(i*360/256)) // Generates a sine curve
In case you want your code placed at position $1000 in the memory but want it assembled like it
was placed at $2000, you can use the .pseudopc directive:
   .pc = $1000 “Program to be relocated at $2000”
   .pseudopc $2000 {
   loop:       inc $d020
               jmp loop      // Will produce jmp $2000 instead of jmp $1000
   }
Here is an overview of the memory and data directives:
Form                       Example                 Description
.pc = <expr> [“name”] .pc = $1000                  Sets the program counter.
                           “Program”
.align <expr>              .align $100             Aligns the program counter to a given interval.
.byte <expr list>          .byte 1,2,3             Generates byte data.
                                                                                                     13
.word <expr list>          .word 3,2,1            Generates word data (2 bytes).
                           .word $1122
.dword <expr list>         .dword 1,2,3           Generates double word data (4 bytes).
                           .dword $11223344
.text <expr>               .text “Hello”          Generates text data.
.fill <expr>, <expr>       .fill 256, 0           Generates a number of bytes, given by the first
                           .fill 256, i           expression, with the data given by the second
                                                  expression. The variable i is set to the byte number
                                                  in the second expression.
.pseudopc <expr>           .pseudopc $2000        Assembles code as if it was placed at a different
{…}                        {…}                    location.
3.6 The Import Directive
With the .import directive you can import external files into your source. You can import source,
binary, C64, and text files:
   // Import and assemble the sourcefile ‘standardlibrary.asm’
   .import source “StandardLibrary.asm”
   // import the bytes from the file ‘music.bin’
   .import binary “Music.bin”
   // Import the bytes from the c64 file ‘charset.c64’
   // (Same as binary but skips the first two address bytes)
   .import c64 “charset.c64”
   // Import the chars from the text file
   // (Converts the bytes as a .text directive would do)
   .import text “scroll.txt”
When Kick Assembler searches for a file, it first look in the current directory. Afterwards it looks
in the directories supplied by the ‘-libdir’ parameter when running the assembler. This enables you
to create standard libraries for files you use in several different sources. A command line could
look like this:
   java –jar kickass.jar myProgram.asm –libdir ..\music –libdir c:\code\stdlib
If you build source code libraries you might want to ensure that the library is only included once in
your code. This can be done by placing a .importonce directive in the top of the library file:
File1:
   .importonce
   .print “This will only be printed once!”
File2:
   .import source “file1.asm”               // This will import file1
   .import source “file1.asm”               // This will not import anything
                                                                                                      14
3.7 Comments
Comments are pieces of the program that are ignored by the assembler. Kick Assembler supports
line and block comments known from languages such as C++ and Java. When the assembler sees
‘//’ it ignores the rest of that line. C block comments ignores everything between /* and */.
   /*----------------------------------------------------------
   This little program is made to demonstrate comments
   ------------------------------------------------------------*/
             lda #10
             sta $d020         // This is also a comment
             sta /* Comments can be placed anywhere */ $d021
             rts
Traditional 6510 asm line comments (;) are not supported since the semicolon is used in for-loops
in the script language.
Type                                   Form                           Description
C line comments                        // This is also a comment      Ignores the rest of the line
C block comments                       /*                             Ignores everything between /*
                                       This is a block comment        and */
                                       */
3.8 User Console Output (.print, .printnow and .error)
With the .print directive you can output text to the user while assembling. For example:
   .print “Hello world”
   .var x=2
   .print “x=”+x
This will give the following output from the assembler:
   parsing
   flex pass 1
   Output pass
       Hello world
       x=2.0
Notice that the output is given during the output pass. You can also print the output immediately
with the .printnow command. This is useful for debugging script where errors prevent the execution
of the output pass. The .printnow command will print the output in each pass, and in some passes
the output might be incomplete due to lack of information. In the following example we print a
label that isn’t resolved in the first pass:
   .printnow "loop=$" + toHexString(loop)
   .pc = $1000
   loop: jmp loop
This will give the following output:
                                                                                                   15
   parsing
   flex pass 1
