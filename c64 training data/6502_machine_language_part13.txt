# ML for C64 - Chapter 6: SYS, USR, Parameter Passing

Write a program to subtract two single-digit numbers, similar to the one in
the above exercise.  You may continue to use the subroutine from the previous
chapter.

Write a program to input a single-digit number.  If the number is less than
five, double it and print the result.  If the number is five or over, divide
it by two (discarding any remainder) and print the result.  Try to produce a
neat output.

Write a program to input a single-digit number.  Print the word ODD or EVEN
behind the number, depending on whether it is odd or even.  Use the LSR
instruction followed by a BCC or BCS test to check for odd or even.

If you've been following the logic, you have developed quite a bit of
capability in machine language.  You can input, you can output, and you can
do quite a bit of arithmetic in between.

By now, you should have developed skills with the machine language monitor
and feel much more comfortable zipping in and out.  These skills are not
difficult, but they are important to the beginner.  Without them, you can
never get comfortably into the real meat:  how to code machine language
itself.

                                                                         :70:
                                                                         :71:



                                                          Chapter 5

                                                            Address
                                                              Modes


          This chapter discusses:

            o Non-addresses:  implied, immediate, register

            o Absolute and zero-page

            o Indexing

            o The relative address for branches

            o Indirect addressing

            o Indirect, indexed


                                                                         :72:

Addressing Modes
----------------

Computer instructions come in two parts:  the instruction itself, or op code,
and the address, or operand.  The term "address" is a little misleading,
since sometimes the operand does not refer to any memory address.

The term address mode refers to the way in which the instruction obtains
information.  Depending on how you count them, there are up to 13 address
modes used by the 650x microprocessor.  They may be summarized as follows:

  1.  No memory address:  implied, accumulator.

  2.  No address, but a value supplied:  immediate.

  3.  An address designating a single memory location:  absolute, zero-page.

  4.  An indexed address designating a range of 256 locations:  absolute,x;
      absolute,y;  zero-page,x;  zero-page,y.

  5.  A location in which the real (two-byte) jump address may be found:
      indirect.

  6.  An offset value (e.g., forward 9, back 17) used for branch
      instructions:  relative.

  7.  Combination of indirect and indexed addresses, useful for reaching data
      anywhere in memory:  indirect, indexed; indexed, indirect.


No Address:  Implied Mode
-------------------------

Instructions such as INX (increment X), BRK (break), and TAY (transfer A to
Y) need no address; they make no memory reference and are complete in
themselves.  Such instructions occupy one byte of memory.

We might say that such instructions have "no address."  The precise term is
"implied address," which seems to say that there is in fact an address, but
we do not need to state it.

Perhaps the word "implied" is used in this manner:  an instruction such as
INX implies the use of the address register; and an instruction such as BRK
implies the address of the machine language monitor.  If so, there's an
instruction that still defies this definition:  NOP.


The Do-Nothing Instruction:  NOP
--------------------------------

NOP (no operation) is an instruction that does nothing.  It affects no data
registers or flags.  When a NOP instruction is given, nothing happens and the
processor continues to the next instruction.  It seems inappropriate to me
that we say that NOP has an implied address.  It doesn't do anything; it
doesn't have an address at all.  On the other hand, I suppose that logicians
might say, "Yes, but it does nothing to the X register."

                                                                         :73:

The NOP instruction, whose op code is #EA, is surprisingly useful.  It's not
simply that if you're a contract programmer getting paid by the byte you
might be tempted to put a large number of NOP instructions into your
program.  NOP can serve two important program testing functions:  taking out
unwanted instructions, or leaving space for extra instructions.

It's not as easy to change a machine language program as it is to change a
BASIC program.  As you have seen, the instructions are placed in specific
locations.  If we wish to eliminate an instruction, we must either move all
the following instructions down or fill in the space with NOP instructions.
If we move the instructions, we may need to correct some of the addresses.

Examine the following code:

  0350  LDA #$00
  0352  STA $1234
  0355  ORA $3456

If we decide to eliminate the instruction at 0352 (STA $1234), we must remove
all three bytes.  So we place code $EA in locations 0352, 0353, and 0354.

Suppose we are testing a moderately large program.  Most programs will break
into distinct "modules," each of which does a specific job.  One module might
clear a portion of memory to zero, another might do a calculation, and so on.
When we are checking out this program, it might be wise to look at each
module as it runs.

In this case, we might deliberately code a BRK (break) command between each
program module.  The program will start to run, and then it will break to the
machine language monitor.  Within the monitor, we can examine memory to
ensure that this module has done the job as we planned it.  When we are
satisfied, we can start the next module using the .G command.  In this way,
we can have tight testing control over our program.

That's all very well, but when we have finished testing our program and are
satisfied that it runs correctly, we don't want the BRK instructions there.
That's easy to fix.  We replace the BRK codes ($00) with NOP's ($EA), and the
program will run through to the end.

If we are writing a program and suspect that we may need to insert one or two
extra instructions within a certain area of the code, we can put a number of
NOP instructions there.  The space will be available for use when we need it.

                                                                         :74:

No Address:  Accumulator Mode
-----------------------------

We have observed that the shift and rotate instructions, ASL, ROL, LSR, and
ROR, allow data manipulation in either the A register or directly in memory.
When we want to use the A register, or accumulator, you should note this fact
as you code your program.  For example, you would write ASL A.

Where accumulator mode addressing is used, it has the same characteristics as
implied addressing:  the whole instruction fits into one byte.

Where the shift/rotate instructions refer to a memory location, an address
will of course be needed.  These address modes will be described later.

Other than the shift and rotate instructions, there is one other set of
instructions that manipulates memory directly.  You may recall INX, INY, DEX,
and DEY increment or decrement an index register.

INC (increment memory) adds one to any memory location.  DEC (decrement
memory) subtracts one from any memory location.  Both instructions affect the
N and Z flags.

When an instruction modifies memory, the address mode is neither implied nor
accumulator.  Memory reference addressing will be discussed later.


Not Quite an Address:  Immediate Mode
-------------------------------------

Coding such as LDA #$34 does not reference a memory address.  Instead, it
designates a specific value (in this case, $34).  An instruction with
immediate addressing takes up two bytes:  one for the op code and the second
for the immediate value.

We have used immediate addressing several times.  It has a "natural" feel,
and it's fast and convenient.  There is one potential pitfall:  immediate
addressing is so easy that it may be abused.  Each time you code an immediate
address, ask yourself, "Could this value ever change?"  By writing a value
into a program, rather than a variable, you may be freezing that value
forever.

An example:  a program is written for a VIC-20, which has 22 columns on the
screen.  At various places in the program, values are compared to 22 (hex
16), and 22 is added or subtracted to various screen addresses.  In each
case, immediate mode addressing is used to provide the value of 22.  Some
time later, the programmer decides to convert to the Commodore 64, which has
40 columns on the screen.  The programmer must change each immediate mode
reference from 22 to 40 (hex 28).

                                                                         :75:

If the value 22 had been stored in a memory location so as to be used as a
variable, all this recoding would not be needed.  The moral is clear:
excessive use of immediate mode can call for extra programming work at a
later time.

There are certain instructions for which immediate addressing is not
possible.  For example, we can LDA #$00, that is, bring in the actual value
zero rather than the contents of an address, but we cannot STA immediate--we
must store the information somewhere in memory.


A Single Address:  Absolute Mode
--------------------------------

An instruction might specify any address within memory--from $0000 to $FFFF--
and handle information from that address.  Giving the full address is called
absolute addressing; if you like, you can deal with information absolutely
anywhere in memory.


  +----------------------------------------------------------------------+
  |                                 MEMORY                               |
  +----------------------------------------------------------------------+
                           ^
                           |

  Figure 5.1  Absolute Mode Specifies One Address Anywhere Within Memory.


We have used absolute addresses several times.  When we exchanged the
contents of memory locations $0380 and $0381, we named these addresses as we
used them.  When we stored a value from the keyboard, we named location
$03C0.  We have also used absolute addresses for program control:
subroutines at $FFD2 and $033C were called up simply by giving the address.

The JSR (jump subroutine) instruction calls up a subroutine anywhere in
memory by using absolute addressing.  There is also a JMP (jump) instruction,
which can transfer program execution to any location in memory; it's similar
to the BASIC GOTO statement.  JMP can use absolute addressing--it can go
anywhere.

There's a limitation to absolute addressing, however.  Once you have written
the instruction, you can go only to the address stated.  You cannot reach a
range of locations; only one.

                                                                         :76:

One-location addressing can be good for any of several jobs.  On the PET/CBM,
we might want to switch between text and graphics modes by manipulating
address 59468 (hexadecimal E84C).  On the VIC-20, we might like to set the
volume level of the sound generator by placing a value into location 36878
(hex 900E).  On a Commodore 64, the screen's background color can be changed
by manipulating address 53281 (hex D021).  In each case, it's one specific
address that we want; absolute addressing will do the job for us.  And we
will also use absolute addressing to reference the various RAM locations that
we have picked for our own program "variables."


Zero-Page Mode
--------------

A hexadecimal address such as $0381 is sixteen bits long and takes up two
bytes of memory.  We call the high byte (in this case, $03), the "memory
page" of the address.  We might say (but usually don't) that this address is
in page 3 at position $81.


   $00     $FF $100
  +-----------+----------------------------------------------------------+
  |           |                     MEMORY                               |
  +-----------+----------------------------------------------------------+
          ^
          |

  Figure 5.2  Zero-Page Mode Specifies A Single Address from $00 to $FF.


Addresses such as $004C and $00F7 are in page zero; in fact, page zero
consists of all addresses from $0000 to $00FF.  Page-zero locations are very
popular and quite busy.  There's an address mode specifically designed to
quickly get to these locations:  zero-page addressing.  We may think of it as
a short address, and omit the first two digits.  Instead of coding LDA $0090,
we may write LDA $90, and the resulting code will occupy less space and run
slightly faster.

Zero-page locations are so popular that we'll have a hard time finding spare
locations for our own programs.  As a result, we tend to conserve zero-page
locations on Commodore machines.  We'll need the few that are available for a
special addressing mode, indirect, indexed, that will be discussed later.

There are many locations in zero page that are useful to read.  For example,
the BASIC system variable ST, which is important in input/output handling,
may be examined there (location $96 in PET/CBM, location $90 in VIC-20 and
Commodore 64).  If you need to know whether the user is holding down a key,
