# C64 PRG Chapter 2 - BASIC Keywords (DIM-GET)

  48   BASIC LANGUAGE VOCABULARY
~


  FRE

  TYPE: Function
  FORMAT: FRE ( <variable> )

  Action: This function tells you how much RAM is available for your
  program and its variables. If a program tries to use more space than is
  available, the OUT OF MEMORY error results.
    The number in parentheses can have any value, and it is not used in
  the calculation.

  +-----------------------------------------------------------------------+
  | NOTE: If the result of FRE is negative, add 65536 to the FRE number   |
  | get the number of bytes available in memory.                          |
  +-----------------------------------------------------------------------+

  EXAMPLES of FRE Function:

    PRINT FRE(0)
    10 X = (FRE(K)-1000)/7
    950 IF FRE(0)< 100 THEN PRINT "NOT ENOUGH ROOM"

  +-----------------------------------------------------------------------+
  | NOTE: The following always tells you the current available RAM:       |
  | PRINT FRE(0) - (FRE(0) < 0)* 65536                                    |
  +-----------------------------------------------------------------------+


  GET

  TYPE: Statement
  FORMAT: GET <variable list>

    Action: This statement reads each key typed by the user. As the user is
  typing, the characters are stored in the Commodore 64's keyboard buffer.
  Up to 10 characters are stored here, and any keys struck after the 10th
  are lost. Reading one of the characters with the GET statement makes room
  for another character.
    If the GET statement specifies numeric data, and the user types a key
  other than a number, the message ?SYNTAX ERROR appears. To be safe, read
  the keys as strings and convert them to numbers later.


                                             BASIC LANGUAGE VOCABULARY   49
~


    The GET statement can be used to avoid some of the limitations of the
  INPUT statement. For more on this, see the section on Using the GET
  Statement in the Programming Techniques section.


  EXAMPLES of GET Statement:

    10 GET A$: IF A$ ="" THEN 10: REM LOOPS IN 10 UNTIL ANY KEY HIT
    20 GET A$, B$, C$, D$, E$: REM READS 5 KEYS
    30 GET A, A$



  GET#

  TYPE: I/O Statement
  FORMAT: GET# <file number>, <variable list>


    Action: This statement reads characters one-at-a-time from the device
  or file specified. It works the same as the GET statement, except that
  the data comes from a different place than the keyboard. If no character
  is received, the variable is set to an empty string (equal to "") or to 0
  for numeric variables. Characters used to separate data in files, like
  the comma (,) or <RETURN> key code (ASC code of 13), are received like
  any other character.
    When used with device #3 (TV screen), this statement will read char-
  acters one by one from the screen. Each use of GET# moves the cursor 1
  position to the right. The character at the end of the logical line is
  changed to a CHR$ (13), the <RETURN> key code.



  EXAMPLES of GET# Statement:

    5 GET#1, A$
    10 OPEN 1,3: GET#1, Z7$
    20 GET#1, A, B, C$, D$





  50   BASIC LANGUAGE VOCABULARY
~


  GOSUB

  TYPE: Statement
  FORMAT: GOSUB <line number>

    Action: This is a specialized form of the GOTO statement, with one
  important difference: GOSUB remembers where it came from. When the
  RETURN statement (different from the <RETURN> key on the keyboard)
  is reached in the program, the program jumps back to the statement
  immediately following the original GOSUB statement.
    The major use of a subroutine (GOSUB really means GO to a SUBroutine)
  is when a small section of program is used by different sections of the
  program. By using subroutines rather than repeating the same lines over
  and over at different places in the program, you can save lots of program
  space. In this way, GOSUB is similar to DEF FN. DEF FN lets you save
  space when using a formula, while GOSUB saves space when using a several-
  line routine. Here is an inefficient program that doesn't use GOSUB:

    100 PRINT "THIS PROGRAM PRINTS"
    110 FOR L = 1 TO 500:NEXT
    120 PRINT "SLOWLY ON THE SCREEN"
    130 FOR L = 1 TO 500:NEXT
    140 PRINT "USING A SIMPLE LOOP"
    150 FOR L = 1 TO 500:NEXT
    160 PRINT "AS A TIME DELAY."
    170 FOR L = 1 TO 500:NEXT

  Here is the same program using GOSUB:

    100 PRINT "THIS PROGRAM PRINTS"
    110 GOSUB 200
    120 PRINT "SLOWLY ON THE SCREEN"
    130 GOSUB 200
    140 PRINT "USING A SIMPLE LOOP"
    150 GOSUB 200
    160 PRINT "AS A TIME DELAY."
    170 GOSUB 200
    180 END
    200 FOR L = 1 TO 500 NEXT
    210 RETURN



                                             BASIC LANGUAGE VOCABULARY   51
~


    Each time the program executes a GOSUB, the line number and position
  in the program line are saved in a special area called the "stack,"
  which takes up 256 bytes of your memory. This limits the amount of data
  that can be stored in the stack. Therefore, the number of subroutine
  return addresses that can be stored is limited, and care should be taken
  to make sure every GOSUB hits the corresponding RETURN, or else you'll
  run out of memory even though you have plenty of bytes free.


  GOTO

  TYPE: Statement
  FORMAT :GOTO <line number>
	  or GO TO <line number>

    Action: This statement allows the BASIC program to execute lines out
  of numerical order. The word GOTO followed by a number will make the
  program jump to the line with that number. GOTO NOT followed by a number
  equals GOTO 0. It must have the line number after the word GOTO.
    It is possible to create loops with GOTO that will never end. The
  simplest example of this is a line that GOes TO itself, like 10 GOTO 10.
  These loops can be stopped using the <RUN/STOP> key on the keyboard.

  EXAMPLES of GOTO Statement:

    GOTO 100
    10 GO TO 50
    20 GOTO 999


  IF...THEN...

  TYPE: Statement
  FORMAT: IF <expression> THEN <line number>
	  IF <expression> GOTO <line number>
	  IF <expression> THEN <statements>

    Action: This is the statement that gives BASIC most of its "intelli-
  gence," the ability to evaluate conditions and take different actions de-
  pending on the outcome.



  52   BASIC LANGUAGE VOCABULARY
~


    The word IF is followed by an expression, which can include variables,
  strings, numbers, comparisons, and logical operators. The word THEN
  appears on the same line and is followed by either a line number or one
  or more BASIC statements. When the expression is false, everything after
  the word THEN on that line is ignored, and execution continues with the
  next line number in the program. A true result makes the program either
  branch to the line number after the word THEN or execute whatever other
  BASIC statements are found on that line.


  EXAMPLE of IF...GOTO...Statement:

    100 INPUT "TYPE A NUMBER"; N
    110 IF N <= 0 GOTO 200
    120 PRINT "SQUARE ROOT=" SQR(N)
    130 GOTO 100
    200 PRINT "NUMBER MUST BE >0"
    210 GOTO 100

    This program prints out the square root of any positive number. The IF
  statement here is used to validate the result of the INPUT. When the
  result of N <= 0 is true, the program skips to line 200, and when the
  result is false the next line to be executed is 120. Note that THEN GOTO
  is not needed with IF...THEN, as in line 110 where GOTO 200 actually
  means THEN GOTO 200.


  EXAMPLE OF IF...THEN...Statement:

    100 FOR L = 1 TO 100
    110 IF RND(1) < .5 THEN X=X+1: GOTO 130
    120 Y=Y+1
    130 NEXT L
    140 PRINT "HEADS=" X
    150 PRINT "TAILS= " Y

  The IF in line 110 tests a random number to see if it is less than .5.
  When the result is true, the whole series of statements following the
  word THEN are executed: first X is incremented by 1, then the program
  skips to line 130. When the result is false, the program drops to the
  next statement, line 120.


                                             BASIC LANGUAGE VOCABULARY   53
~


  INPUT

  TYPE: Statement
  FORMAT: INPUT [ "<prompt>" ; ] <variable list>

    Action: This is a statement that lets the person RUNning the program
  "feed" information into the computer. When executed, this statement
  PRINTs a question mark (?) on the screen, and positions the cursor 1
  space to the right of the question mark. Now the computer waits, cursor
  blinking, for the operator to type in the answer and press the <RETURN>
  key.
    The word INPUT may be followed by any text contained in quote marks
  (""). This text is PRINTed on the screen, followed by the question mark.
    After the text comes a semicolon (;) and the name of one or more
  variables separated by commas. This variable is where the computer
  stores the information that the operator types. The variable can be any
  legal variable name, and you can have several different variable
  names, each for a different input.

  EXAMPLES of INPUT Statement:

    100 INPUT A
    110 INPUT B, C, D
    120 INPUT "PROMPT"; E

    When this program RUNs, the question mark appears to prompt the
  operator that the Commodore 64 is expecting an input for line 100. Any
  number typed in goes into A, for later use in the program. If the answer
  typed was not a number, the ?REDO FROM START message appears, which means
  that a string was received when a number was expected.
    If the operator just hits <RETURN> without typing anything, the vari-
  able's value doesn't change.
    Now the next question mark, for line 110, appears. If we type only
  one number and hit the <RETURN>, Commodore 64 will now display 2
  question marks (??), which means that more input is required. You can








