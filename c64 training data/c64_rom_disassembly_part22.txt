# C64 BASIC ROM Disassembly $BC00-$BCFF - LOG, Polynomial Evaluation

.,BC00 A2 05    LDX #$05        5 bytes to copy
.,BC02 B5 68    LDA $68,X       get byte from FAC2,X
.,BC04 95 60    STA $60,X       save byte at FAC1,X
.,BC06 CA       DEX             decrement count
.,BC07 D0 F9    BNE $BC02       loop if not all done
.,BC09 86 70    STX $70         clear FAC1 rounding byte
.,BC0B 60       RTS             

                                *** round and copy FAC1 to FAC2
.,BC0C 20 1B BC JSR $BC1B       round FAC1
                                copy FAC1 to FAC2
.,BC0F A2 06    LDX #$06        6 bytes to copy
.,BC11 B5 60    LDA $60,X       get byte from FAC1,X
.,BC13 95 68    STA $68,X       save byte at FAC2,X
.,BC15 CA       DEX             decrement count
.,BC16 D0 F9    BNE $BC11       loop if not all done
.,BC18 86 70    STX $70         clear FAC1 rounding byte
.,BC1A 60       RTS             

                                *** round FAC1
.,BC1B A5 61    LDA $61         get FAC1 exponent
.,BC1D F0 FB    BEQ $BC1A       exit if zero
.,BC1F 06 70    ASL $70         shift FAC1 rounding byte
.,BC21 90 F7    BCC $BC1A       exit if no overflow
                                round FAC1 (no check)
.,BC23 20 6F B9 JSR $B96F       increment FAC1 mantissa
.,BC26 D0 F2    BNE $BC1A       branch if no overflow
.,BC28 4C 38 B9 JMP $B938       nornalise FAC1 for C=1 and return

                                *** get FAC1 sign
                                return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve, A = $00, Cb = ?/0
.,BC2B A5 61    LDA $61         get FAC1 exponent
.,BC2D F0 09    BEQ $BC38       exit if zero (allready correct SGN(0)=0)

                                *** return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
                                no = 0 check
.,BC2F A5 66    LDA $66         else get FAC1 sign (b7)

                                *** return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
                                no = 0 check, sign in A
.,BC31 2A       ROL             move sign bit to carry
.,BC32 A9 FF    LDA #$FF        set byte for -ve result
.,BC34 B0 02    BCS $BC38       return if sign was set (-ve)
.,BC36 A9 01    LDA #$01        else set byte for +ve result
.,BC38 60       RTS             

                                *** perform SGN()
.,BC39 20 2B BC JSR $BC2B       get FAC1 sign, return A = $FF -ve, A = $01 +ve

                                *** save A as integer byte
.,BC3C 85 62    STA $62         save FAC1 mantissa 1
.,BC3E A9 00    LDA #$00        clear A
.,BC40 85 63    STA $63         clear FAC1 mantissa 2
.,BC42 A2 88    LDX #$88        set exponent
                                set exponent = X, clear FAC1 3 and 4 and normalise
.,BC44 A5 62    LDA $62         get FAC1 mantissa 1
.,BC46 49 FF    EOR #$FF        complement it
.,BC48 2A       ROL             sign bit into carry
                                set exponent = X, clear mantissa 4 and 3 and normalise FAC1
.,BC49 A9 00    LDA #$00        clear A
.,BC4B 85 65    STA $65         clear FAC1 mantissa 4
.,BC4D 85 64    STA $64         clear FAC1 mantissa 3
                                set exponent = X and normalise FAC1
.,BC4F 86 61    STX $61         set FAC1 exponent
.,BC51 85 70    STA $70         clear FAC1 rounding byte
.,BC53 85 66    STA $66         clear FAC1 sign (b7)
.,BC55 4C D2 B8 JMP $B8D2       do ABS and normalise FAC1

                                *** perform ABS()
.,BC58 46 66    LSR $66         clear FAC1 sign, put zero in b7
.,BC5A 60       RTS             

                                *** compare FAC1 with (AY)
                                returns A=$00 if FAC1 = (AY)
                                returns A=$01 if FAC1 > (AY)
                                returns A=$FF if FAC1 < (AY)
.,BC5B 85 24    STA $24         save pointer low byte
.,BC5D 84 25    STY $25         save pointer high byte
.,BC5F A0 00    LDY #$00        clear index
.,BC61 B1 24    LDA ($24),Y     get exponent
.,BC63 C8       INY             increment index
.,BC64 AA       TAX             copy (AY) exponent to X
.,BC65 F0 C4    BEQ $BC2B       branch if (AY) exponent=0 and get FAC1 sign
                                A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
.,BC67 B1 24    LDA ($24),Y     get (AY) mantissa 1, with sign
.,BC69 45 66    EOR $66         EOR FAC1 sign (b7)
.,BC6B 30 C2    BMI $BC2F       if signs <> do return A = $FF, Cb = 1/-ve
                                A = $01, Cb = 0/+ve and return
.,BC6D E4 61    CPX $61         compare (AY) exponent with FAC1 exponent
.,BC6F D0 21    BNE $BC92       branch if different
.,BC71 B1 24    LDA ($24),Y     get (AY) mantissa 1, with sign
.,BC73 09 80    ORA #$80        normalise top bit
.,BC75 C5 62    CMP $62         compare with FAC1 mantissa 1
.,BC77 D0 19    BNE $BC92       branch if different
.,BC79 C8       INY             increment index
.,BC7A B1 24    LDA ($24),Y     get mantissa 2
.,BC7C C5 63    CMP $63         compare with FAC1 mantissa 2
.,BC7E D0 12    BNE $BC92       branch if different
.,BC80 C8       INY             increment index
.,BC81 B1 24    LDA ($24),Y     get mantissa 3
.,BC83 C5 64    CMP $64         compare with FAC1 mantissa 3
.,BC85 D0 0B    BNE $BC92       branch if different
.,BC87 C8       INY             increment index
.,BC88 A9 7F    LDA #$7F        set for 1/2 value rounding byte
.,BC8A C5 70    CMP $70         compare with FAC1 rounding byte (set carry)
.,BC8C B1 24    LDA ($24),Y     get mantissa 4
.,BC8E E5 65    SBC $65         subtract FAC1 mantissa 4
.,BC90 F0 28    BEQ $BCBA       exit if mantissa 4 equal
                                gets here if number <> FAC1
.,BC92 A5 66    LDA $66         get FAC1 sign (b7)
.,BC94 90 02    BCC $BC98       branch if FAC1 > (AY)
.,BC96 49 FF    EOR #$FF        else toggle FAC1 sign
.,BC98 4C 31 BC JMP $BC31       return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve

                                *** convert FAC1 floating to fixed
.,BC9B A5 61    LDA $61         get FAC1 exponent
.,BC9D F0 4A    BEQ $BCE9       if zero go clear FAC1 and return
.,BC9F 38       SEC             set carry for subtract
.,BCA0 E9 A0    SBC #$A0        subtract maximum integer range exponent
.,BCA2 24 66    BIT $66         test FAC1 sign (b7)
.,BCA4 10 09    BPL $BCAF       branch if FAC1 +ve
                                FAC1 was -ve
.,BCA6 AA       TAX             copy subtracted exponent
.,BCA7 A9 FF    LDA #$FF        overflow for -ve number
.,BCA9 85 68    STA $68         set FAC1 overflow byte
.,BCAB 20 4D B9 JSR $B94D       twos complement FAC1 mantissa
.,BCAE 8A       TXA             restore subtracted exponent
.,BCAF A2 61    LDX #$61        set index to FAC1
.,BCB1 C9 F9    CMP #$F9        compare exponent result
.,BCB3 10 06    BPL $BCBB       if < 8 shifts shift FAC1 A times right and return
.,BCB5 20 99 B9 JSR $B999       shift FAC1 A times right (> 8 shifts)
.,BCB8 84 68    STY $68         clear FAC1 overflow byte
.,BCBA 60       RTS             

                                *** shift FAC1 A times right
.,BCBB A8       TAY             copy shift count
.,BCBC A5 66    LDA $66         get FAC1 sign (b7)
.,BCBE 29 80    AND #$80        mask sign bit only (x000 0000)
.,BCC0 46 62    LSR $62         shift FAC1 mantissa 1
.,BCC2 05 62    ORA $62         OR sign in b7 FAC1 mantissa 1
.,BCC4 85 62    STA $62         save FAC1 mantissa 1
.,BCC6 20 B0 B9 JSR $B9B0       shift FAC1 Y times right
.,BCC9 84 68    STY $68         clear FAC1 overflow byte
.,BCCB 60       RTS             

                                *** perform INT()
.,BCCC A5 61    LDA $61         get FAC1 exponent
.,BCCE C9 A0    CMP #$A0        compare with max int
.,BCD0 B0 20    BCS $BCF2       exit if >= (allready int, too big for fractional part!)
.,BCD2 20 9B BC JSR $BC9B       convert FAC1 floating to fixed
.,BCD5 84 70    STY $70         save FAC1 rounding byte
.,BCD7 A5 66    LDA $66         get FAC1 sign (b7)
.,BCD9 84 66    STY $66         save FAC1 sign (b7)
.,BCDB 49 80    EOR #$80        toggle FAC1 sign
.,BCDD 2A       ROL             shift into carry
.,BCDE A9 A0    LDA #$A0        set new exponent
.,BCE0 85 61    STA $61         save FAC1 exponent
.,BCE2 A5 65    LDA $65         get FAC1 mantissa 4
.,BCE4 85 07    STA $07         save FAC1 mantissa 4 for power function
.,BCE6 4C D2 B8 JMP $B8D2       do ABS and normalise FAC1

                                *** clear FAC1 and return
.,BCE9 85 62    STA $62         clear FAC1 mantissa 1
.,BCEB 85 63    STA $63         clear FAC1 mantissa 2
.,BCED 85 64    STA $64         clear FAC1 mantissa 3
.,BCEF 85 65    STA $65         clear FAC1 mantissa 4
.,BCF1 A8       TAY             clear Y
.,BCF2 60       RTS             

                                *** get FAC1 from string
.,BCF3 A0 00    LDY #$00        clear Y
.,BCF5 A2 0A    LDX #$0A        set index
.,BCF7 94 5D    STY $5D,X       clear byte
.,BCF9 CA       DEX             decrement index
.,BCFA 10 FB    BPL $BCF7       loop until numexp to negnum (and FAC1) = $00
.,BCFC 90 0F    BCC $BD0D       branch if first character is numeric
.,BCFE C9 2D    CMP #$2D        else compare with "-"
