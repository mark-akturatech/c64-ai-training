# C64 Zero Page - BASIC Working Storage $14-$2A

low- byte, high-byte integer format, as is the number of a BASIC line
that is to be added or replaced.

LIST saves the highest line number to list (or 65535 ($FFFF) if
program is to be listed to the end) at this location.

GOTO tests the target line number to see if it is greater than the
line number currently being executed.  If it is greater, GOTO starts
its search for the target line at the current line number.  If it is
not greater, GOTO must search for the target line from the first line
of the program.  It is interesting to note that the test is of the
most significant byte only.  Therefore, INT(TARGETLINE/256) must be
greater than INT(CURRENTLINE/256) in order for the search to start
with the current line, instead of at the beginning of the program.

PEEK, POKE, WAIT, and SYS use this location as a pointer to the
address which is the subject of the command.

22            $16            TEMPPT
Pointer to the Next Available Space in the Temporary String Stack

This location points to the next available slot in the temporary
string descriptor stack located at 25-33 ($19-$21).  Since that stack
has room for three descriptors of three bytes each, this location will
point to 25 ($19) if the stack is empty, to 28 ($1C) if there is one
entry, to 31 ($1F) if there are two entries, and to 34 ($22) if the
stack is full.

If BASIC needs to add an entry to the temporary string descriptor
stack, and this location holds a 34, indicating that the stack is
full, the FORMULA TOO COMPLEX error message is issued.  Otherwise, the
entry is added, and three is added to this pointer.

23-24         $17-$18        LASTPT
Pointer to the Address of the Last String in the Temporary String
Stack

This pointer indicates the last slot used in the temporary string
descriptor stack.  Therefore, the value stored at 23 ($17) should be 3
less than that stored at 22 ($16), while 24 ($18) will contain a 0.

25-33         $19-$21        TEMPST
Descriptor Stack for Temporary Strings

The temporary string descriptor stack contains information about
temporary strings which hve not yet been assigned to a string
variable.  An examples of such a temporary string is the literal
string "HELLO" in the statement PRINT "HELLO".

Each three-byte descriptor in this stack contains the length of the
string, and its starting and ending locations, expresses as
displacements within the BASIC storage area.

34-37         $22-$25        INDEX
Miscellaneous Temporary Pointers and Save Area

This area is used by many BASIC routines to hold temporary pointers
and calculation results.

38-42         $26-$2A        RESHO
Floating Point Multiplication Work Area

This location is used by BASIC multiplication and division routines.
It is also used by the routines which compute the size of the area
required to store an array which is being created.

43-44         $2B-$2C        TXTTAB
Pointer to the Start of BASIC Program Text

This two-byte pointer lets BASIC know where program text is stored.
Ordinarily, such text is located beginning at 2049 ($801).  Using this
pointer, it is possible to change the program text area.  Typical
reasons for doing this include:

1.  Conforming the memory configuration to that of other Commodore
computers.  On 32K PET and CBM computers, for example, screen memory
starts at 32768 ($8000), and BASIC text begins at 1025 ($401).  You
can emulate this configuration with the 64 with the following short
program:

10 POKE 55,0:POKE 56,128: CLR: REM LOWER TOP OF MEMORY TO 32768
20 POKE 56576,PEEK(56576) AND 253: REM ENABLE BANK 2
30 POKE 53272,4: REM TEXT DISPLAY MEMORY NOW STARTS AT 32768
40 POKE 648,128:REM OPERATING SYSTEM PRINTS TO SCREEN AT 32768 (128*256)
50 POKE 44,4:POKE 1024,0: REM MOVE START OF BASIC TO 1025 (4*256+1)
60 POKE 792,193: REM DISABLE RESTORE KEY
70 PRINT CHR$(147);"NOW CONFIGURED LIKE PET":NEW
80 REM ALSO SEE ENTRIES FOR LOCATION 55, 56576, AND 648

Such reconfiguring can be helpful in transferring programs from the 64
to the PET, or vice versa.  Since the 64 automatically relocates BASIC
program text, it can load and list PET programs even though the
program file indicates a loading addresss that is different from the
64 start of BASIC.  The PET does not have this automatic relocation
feature, however, and it loads all BASIC programs at the two-byte
address indicated at the beginning of the disk or tape file.

So if the PET loads a 64 program at its normal starting address of
2049 ($801), it will not recognize its presence because it expects a
BASIC program to start at 1025 ($401).  Therefore, if you want to let
a PET and 64 share a program, you must either reconfigure the 64 to
start BASIC where the PET does, or reconfigure the PET to start BASIC
where the 64 does (with a POKE 41,8:POKE 2048,0).

2.  Raising the lowest location used for BASIC text in order to create
a safe area in low memory.  For example, if you wish to use the
high-resolution graphics mode, you may want to put the start of screen
memory at 8192 ($2000).  The high-resolution moe requires 8K of
memory, and you cannot use the lowest 8K for this purpose because it
is already being used for the zero-page assignments.

Since BASIC program text normally starts at 2048 ($801), this means
that you only have 6k for program text before your program runs over
into screen memory.  One way around this is by moving the start of
basic to 16385 ($4001) by typing in direct entry mode:

POKE 44,64: POKE 64*256,0:NEW

Other uses might include setting aside a storage area for sprite shape
data, or user-defined character sets.

3.  Keeping two or more programs in memory simultaneously.  By
changing this pointer, you can keep more than one BASIC program in
memory at one time, and switch back and forth betwenn them.  Examples
of this application can be found in COMPUTE!'s First Book of PET/CBM,
pages 66 and 163.

This technique has a number of offshoots that are perhaps of more
practical use.

a) You can store two programs in memory simultaneously for the purpose
of appending one to the other.  This technique requires that the line
numbers of the two programs do not overlap.  (See Programming the
PET/CBM by Raeto Collin West, pages 41-42, for a discussion of this
technique).

b) You can have two programs in memory at once and use the concept in
(2) above to allow an easier way to create a safe area in low memory.
The first program is just onw line that sets the start of BASIC
pointer to the address of the second program which is located higher
in memory, and then runs that second program.

4. Since this address is used as the address of the first byte to
SAVE, you can save any section of memory by changing this pointer to
indicate the starting address, and the pointer 45-46 ($2D-$2D) to
indicate the address of the byte after the last byte that you wish to
save.

45-46         $2D-$2E        VARTAB
Pointer to the Start of the BASIC Variable Storage Area

This location points to the address which marks the end of the BASIC
program text area, and the beginning of the variable storage area.
All nonarray variables are stored here, as are string descriptors (for
the address of the area where the actual text of strings is stored,
see location 51 ($33)).

Seven bytes of memory are allocated for each variable.  The first two
bytes are used for the variable name, which consists of the ASCII
value of the first two letters of the variable name.  If the variable
name is a single letter, the second byte will contain a zero.

The seventh bit of one or both of these bytes can be set (which would
add 128 to the ASCII value of the letter).  This indicates the
variable type.  If neither byte has the seventh bit set, the variable
is the regular floating point type.  If only the first byte has its
seventh bit set, the variable is a string.  If only the second byte
has its seventh bit set, the variable is a defined function (FN).  If
both bytes have the seventh bit set, the variable is an integer.

The use of the other five bytes depends on the type of variable.  A
floating point variable will use the five bytes to store the value of
the variable in floating point format.  An integer will have its value
stored in the third and fourth bytes, high byte first, and the other
three will be unused.

A string variable will use the third byte for its length, and the
fourth and fifth bytes for a pointer to the address of the string
text, leaving the last two bytes unused.  Note that the acrual string
text that is pointed to is located either in the part of the BASIC
program where the string is first assigned a value, or in the string
text storage area pointed to by location 51 ($33).

A function definition will use the third and fourth bytes for a
pointer to the address in the BASIC program text where the function
definition starts.  It uses the fifth and sixth bytes for a pointer to
the dependent variable (the X of FN A(X)).  The final byte is not
used.

Knowing something about how variables are created can help your BASIC
programming.  For example, you can see that nonarray integer variables
take up no less space than floating point variables, and since most
BASIC commands convert the integers to floating point, they do not
offer a speed advantage either, and in many cases will actually slow
the program down.  As will be seen below, however, integer arrays can
save a considerable amount of space.

Variables are stored in the order in which they are created.
Likewise, when BASIC goes looking for a variable, it starts its search
at the beginning of this area.  If commonly used variables are defined
at the end of the program, and are thus at the back of this area, it
will take longer to find them.  It may help program execution speed to
define the variables that will be used most frequently right at the
beginning of the program.

Also, remember that once created, variables do not go away during
program execution.  Even if they are never used again, they still take
up space in the variable storage area, and they slow down the routine
that is used to search for variables that are referenced.

Another point to consider about the order in which to define variables
is that arrays are created in a separate area of memory which starts
at the end of the nonarray variable area.  Therefore, every time a
nonarray variable is created, all of the arrays must be moved seven
bytes higher in memory in order to make room for the new variable.
Therefore, it may help performance to avoid defining nonarray
variables after defining arrays.

This pointer will be reset to one byte past the end of the BASIC
program text whenever you execute the statements CLR, NEW, RUN, or
LOAD.  Adding or modifying a BASIC statement will have the same
effect, because the higher numbered BASIC statements have to be moved
up into memory to make room for the new statements, and can therefore
overwrite the variable storage area.  This means that if you wish to
check the value of a variable after stopping a program, you can only
do so before modifying the program.

The exception to the above is when the LOAD command is issued from a
program.  The purpose of not resetting this pointer in such a case is
to allow the chaining of programs by having one program load and then
run the next (that is also why a LOAD issued from a program causes a
RUN from the beginning of the program).  This allows the second
program to share variables with the first.  There are problems with
this, however.  Some string variable descriptors and function
definitions have their pointers set to areas within the program text.
When this text is replaced by a load, these pointers are no longer
valid, which will lead to errors if the FN or string value is
referenced.  And if the second program text area is larger than that
of the first, the second program will overwrite some of the first
program's variables, and their values will be lost.
