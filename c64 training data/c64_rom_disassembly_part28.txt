# C64 KERNAL ROM Disassembly $E500-$E5FF - I/O Base, Keyboard

.,E500 A2 00    LDX #$00        get the I/O base address low byte
.,E502 A0 DC    LDY #$DC        get the I/O base address high byte
.,E504 60       RTS             

                                *** return the x,y organization of the screen
.,E505 A2 28    LDX #$28        get the x size
.,E507 A0 19    LDY #$19        get the y size
.,E509 60       RTS             

                                *** read/set the x,y cursor position
.,E50A B0 07    BCS $E513       if read cursor go do read
.,E50C 86 D6    STX $D6         save the cursor row
.,E50E 84 D3    STY $D3         save the cursor column
.,E510 20 6C E5 JSR $E56C       set the screen pointers for the cursor row, column
.,E513 A6 D6    LDX $D6         get the cursor row
.,E515 A4 D3    LDY $D3         get the cursor column
.,E517 60       RTS             

                                *** initialise the screen and keyboard
.,E518 20 A0 E5 JSR $E5A0       initialise the vic chip
.,E51B A9 00    LDA #$00        clear A
.,E51D 8D 91 02 STA $0291       clear the shift mode switch
.,E520 85 CF    STA $CF         clear the cursor blink phase
.,E522 A9 48    LDA #$48        get the keyboard decode logic pointer low byte
.,E524 8D 8F 02 STA $028F       save the keyboard decode logic pointer low byte
.,E527 A9 EB    LDA #$EB        get the keyboard decode logic pointer high byte
.,E529 8D 90 02 STA $0290       save the keyboard decode logic pointer high byte
.,E52C A9 0A    LDA #$0A        set the maximum size of the keyboard buffer
.,E52E 8D 89 02 STA $0289       save the maximum size of the keyboard buffer
.,E531 8D 8C 02 STA $028C       save the repeat delay counter
.,E534 A9 0E    LDA #$0E        set light blue
.,E536 8D 86 02 STA $0286       save the current colour code
.,E539 A9 04    LDA #$04        speed 4
.,E53B 8D 8B 02 STA $028B       save the repeat speed counter
.,E53E A9 0C    LDA #$0C        set the cursor flash timing
.,E540 85 CD    STA $CD         save the cursor timing countdown
.,E542 85 CC    STA $CC         save the cursor enable, $00 = flash cursor

                                *** clear the screen
.,E544 AD 88 02 LDA $0288       get the screen memory page
.,E547 09 80    ORA #$80        set the high bit, flag every line is a logical line start
.,E549 A8       TAY             copy to Y
.,E54A A9 00    LDA #$00        clear the line start low byte
.,E54C AA       TAX             clear the index
.,E54D 94 D9    STY $D9,X       save the start of line X pointer high byte
.,E54F 18       CLC             clear carry for add
.,E550 69 28    ADC #$28        add the line length to the low byte
.,E552 90 01    BCC $E555       if no rollover skip the high byte increment
.,E554 C8       INY             else increment the high byte
.,E555 E8       INX             increment the line index
.,E556 E0 1A    CPX #$1A        compare it with the number of lines + 1
.,E558 D0 F3    BNE $E54D       loop if not all done
.,E55A A9 FF    LDA #$FF        set the end of table marker
.,E55C 95 D9    STA $D9,X       mark the end of the table
.,E55E A2 18    LDX #$18        set the line count, 25 lines to do, 0 to 24
.,E560 20 FF E9 JSR $E9FF       clear screen line X
.,E563 CA       DEX             decrement the count
.,E564 10 FA    BPL $E560       loop if more to do

                                *** home the cursor
.,E566 A0 00    LDY #$00        clear Y
.,E568 84 D3    STY $D3         clear the cursor column
.,E56A 84 D6    STY $D6         clear the cursor row

                                *** set screen pointers for cursor row, column
.,E56C A6 D6    LDX $D6         get the cursor row
.,E56E A5 D3    LDA $D3         get the cursor column
.,E570 B4 D9    LDY $D9,X       get start of line X pointer high byte
.,E572 30 08    BMI $E57C       if it is the logical line start continue
.,E574 18       CLC             else clear carry for add
.,E575 69 28    ADC #$28        add one line length
.,E577 85 D3    STA $D3         save the cursor column
.,E579 CA       DEX             decrement the cursor row
.,E57A 10 F4    BPL $E570       loop, branch always
.,E57C 20 F0 E9 JSR $E9F0       fetch a screen address
.,E57F A9 27    LDA #$27        set the line length
.,E581 E8       INX             increment the cursor row
.,E582 B4 D9    LDY $D9,X       get the start of line X pointer high byte
.,E584 30 06    BMI $E58C       if logical line start exit
.,E586 18       CLC             else clear carry for add
.,E587 69 28    ADC #$28        add one line length to the current line length
.,E589 E8       INX             increment the cursor row
.,E58A 10 F6    BPL $E582       loop, branch always
.,E58C 85 D5    STA $D5         save current screen line length
.,E58E 4C 24 EA JMP $EA24       calculate the pointer to colour RAM and return
.,E591 E4 C9    CPX $C9         compare it with the input cursor row
.,E593 F0 03    BEQ $E598       if there just exit
.,E595 4C ED E6 JMP $E6ED       else go ??
.,E598 60       RTS             

                                *** orphan bytes ??
.,E599 EA       NOP             huh
.,E59A 20 A0 E5 JSR $E5A0       initialise the vic chip
.,E59D 4C 66 E5 JMP $E566       home the cursor and return

                                *** initialise the vic chip
.,E5A0 A9 03    LDA #$03        set the screen as the output device
.,E5A2 85 9A    STA $9A         save the output device number
.,E5A4 A9 00    LDA #$00        set the keyboard as the input device
.,E5A6 85 99    STA $99         save the input device number
.,E5A8 A2 2F    LDX #$2F        set the count/index
.,E5AA BD B8 EC LDA $ECB8,X     get a vic ii chip initialisation value
.,E5AD 9D FF CF STA $CFFF,X     save it to the vic ii chip
.,E5B0 CA       DEX             decrement the count/index
.,E5B1 D0 F7    BNE $E5AA       loop if more to do
.,E5B3 60       RTS             

                                *** input from the keyboard buffer
.,E5B4 AC 77 02 LDY $0277       get the current character from the buffer
.,E5B7 A2 00    LDX #$00        clear the index
.,E5B9 BD 78 02 LDA $0278,X     get the next character,X from the buffer
.,E5BC 9D 77 02 STA $0277,X     save it as the current character,X in the buffer
.,E5BF E8       INX             increment the index
.,E5C0 E4 C6    CPX $C6         compare it with the keyboard buffer index
.,E5C2 D0 F5    BNE $E5B9       loop if more to do
.,E5C4 C6 C6    DEC $C6         decrement keyboard buffer index
.,E5C6 98       TYA             copy the key to A
.,E5C7 58       CLI             enable the interrupts
.,E5C8 18       CLC             flag got byte
.,E5C9 60       RTS             

                                *** write character and wait for key
.,E5CA 20 16 E7 JSR $E716       output character

                                *** wait for a key from the keyboard
.,E5CD A5 C6    LDA $C6         get the keyboard buffer index
.,E5CF 85 CC    STA $CC         cursor enable, $00 = flash cursor, $xx = no flash
.,E5D1 8D 92 02 STA $0292       screen scrolling flag, $00 = scroll, $xx = no scroll
                                this disables both the cursor flash and the screen scroll
                                while there are characters in the keyboard buffer
.,E5D4 F0 F7    BEQ $E5CD       loop if the buffer is empty
.,E5D6 78       SEI             disable the interrupts
.,E5D7 A5 CF    LDA $CF         get the cursor blink phase
.,E5D9 F0 0C    BEQ $E5E7       if cursor phase skip the overwrite
                                else it is the character phase
.,E5DB A5 CE    LDA $CE         get the character under the cursor
.,E5DD AE 87 02 LDX $0287       get the colour under the cursor
.,E5E0 A0 00    LDY #$00        clear Y
.,E5E2 84 CF    STY $CF         clear the cursor blink phase
.,E5E4 20 13 EA JSR $EA13       print character A and colour X
.,E5E7 20 B4 E5 JSR $E5B4       input from the keyboard buffer
.,E5EA C9 83    CMP #$83        compare with [SHIFT][RUN]
.,E5EC D0 10    BNE $E5FE       if not [SHIFT][RUN] skip the buffer fill
                                keys are [SHIFT][RUN] so put "LOAD",$0D,"RUN",$0D into
                                the buffer
.,E5EE A2 09    LDX #$09        set the byte count
.,E5F0 78       SEI             disable the interrupts
.,E5F1 86 C6    STX $C6         set the keyboard buffer index
.,E5F3 BD E6 EC LDA $ECE6,X     get byte from the auto load/run table
.,E5F6 9D 76 02 STA $0276,X     save it to the keyboard buffer
.,E5F9 CA       DEX             decrement the count/index
.,E5FA D0 F7    BNE $E5F3       loop while more to do
.,E5FC F0 CF    BEQ $E5CD       loop for the next key, branch always
                                was not [SHIFT][RUN]
.,E5FE C9 0D    CMP #$0D        compare the key with [CR]
