# ML for C64 - Chapter 3: Input, Comparisons



Running the Program
-------------------

If necessary, move the cursor down to an empty line.  Type the command .G
033C and the program will run.  Again, it doesn't take long; the break back
to the MLM seems instantaneous.  Where's the letter H that we were supposed
to print?  It's hard to see, but it's there.  Look at your .G 033C command
and you'll see it.

Project for enthusiasts:  Can you add to the program and print HI?  The ASCII
code for the letter I is $49.  Can you add again and print HI on a separate
line?  The ASCII code for a RETURN is $0D.  Remember that you can find all
ASCII codes in Appendix D; look in the column marked ASCII.


Linking with BASIC
------------------

So far we have started up our programs with a .G (go) command from the MLM,
and we have terminated our programs with a BRK command that returns us to the
monitor.  That's not a convenient way to run a program; most users would
prefer to say RUN out of BASIC and have the computer do everything.

We can link to a machine language program from BASIC and when the program is
finished, it can return to BASIC and allow the BASIC program to continue to
run.  The commands we need are

  (BASIC) SYS--Go to a machine language subroutine at the stated address;

  (Machine language) RTS--Return to whoever called this subroutine.

Let's change our machine language program first.  We must change from BRK at
the end to RTS (return from subroutine) so that when the program is finished
it will return to BASIC.  If you like, you may change it directly on the
disassembly listing:  disassemble and then type over the 00 byte that
represents BRK with a value of 60.  Press RETURN and you'll see that the
instruction has now changed to RTS.  Alternatively, you may re-assemble with

                                                                         :31:

  .A 033C  LDA #$48
  .A 033E  JSR $FFD2
  .A 0341  RTS

Now return to BASIC (using the .X command).  The computer will say READY; you
may now call your program with a SYS command.

Address $033C is 828 in decimal.  Thus, we type SYS 828.  When we press
RETURN, the letter H will be printed.

We're not finished.  Any machine language subroutine may be called from a
BASIC program.  Type NEW, which clears out the BASIC work area; our machine
language program is left untouched, since NEW is a BASIC command.  Now enter
the following program:

  100 FOR J=1 TO 10
  110 SYS 828
  120 NEXT J

How many times will our program at 828 ($033C) be called?  How may times will
the letter H be printed?  Will they be on the same line or separate lines?
Type RUN and see.

Project for enthusiasts:  Again, change the machine language program to say
HI.  Use your imagination.  What else would you like the computer to say?
Would you like to use colors or reverse font?

We've achieved an important new plateau:  BASIC and machine language working
together.  It's easier on the user, who doesn't have to learn specialized
monitor commands.  It's easier on the programmer, too, since things that are
easy to do in BASIC can be written in that language; things that are clumsy
or slow in BASIC can be written in machine language.  We can get the best of
both worlds.

Let's distinguish our three different types of subroutine calls:

  GOSUB--calls a BASIC subroutine from a BASIC program.
  SYS--calls a machine language subroutine from a BASIC program.
  JSR--calls a machine language subroutine from machine language.

                                                                         :32:

Loops
-----

We know how to send characters to the screen, one at a time.  But long
messages, such as THE QUICK BROWN CAT..., might lead to tedious coding if we
had to write an instruction for each letter to be sent.  We need to set up a
program loop to repeat the printing activity.

Let's write a program to print the word HELLO followed by a RETURN.

We must store the word HELLO somewhere in memory.  It doesn't matter where,
provided it doesn't conflict with anything else.  I'll arbitrarily choose
address $034A to $034F.  We'll put it there in a moment.  Remember that the
characters that make up the word HELLO (plus the RETURN) are not program
instructions; they are simple data.  We must put them in a place with a
memory change--we must not try to assemble them.

We will need to count the characters as we send them.  We wish to send six
characters, so a count of six is our limit.  Let's use the X register to keep
track of the count.  First, we must set X to zero:

  .A 033C  LDX #$00

Note that we use the # symbol to denote an immediate value:  we want to load
X with the value zero, not something from address 0.  Now, we'll do something
new.  I want to take a character to be printed from address $034A.  But wait,
that's only the first time around.  When we come back to this point in the
loop, I want to take a character from $034B, and then from $034C, and so on.

How can we do this?  It seems that we must write one address into the LDA
instruction, and that address can't change.  But there is a way.

We can ask the computer to take the address we supply, and add the contents
of X or Y to this address before we use it.  The computed address is called
an effective address.

Let's look at our position.  The first time around the loop, X is counting
the characters and has a value of zero.  If we specify our address as 034A+X,
the effective address will be 034A.  That's where we will have stored the
letter H.

When we come back around the loop--we haven't written that part yet--X should
now equal one.  An address of 034A+X would give an effective address of 034B:
the computer would go there and get the letter E.  As we go around the loop,
the letters, L, L, O, and RETURN will be brought in as needed.

As we enter the LDA instruction, we don't type the plus sign.  Instead, we
signal indexing with a comma:  LDA $034A,X.  We may use either X or Y for
indexing:  they are sometimes called index register.  In this case, of
course, we use X.  So we code

                                                                         :33:

  .A 033E  LDA $034A,X
  .A 0341  JSR $FFD2

The first time, the computer loads the contents of address $034A (the letter
H of HELLO) and prints it.  When the loop comes back here, with X equal to
one, this instruction will load the contents of $034B and print the letter E.

The X register counts the number of letters printed, so we must add one to
the contents of X.  There's a special command that will add one to the
contents of X:  INX, for increment X.  A similar code, INY, allows Y to be
incremented; and DEX (decrement X) and DEY (decrement Y) allow X or Y to be
decremented, or reduced, by one.  At the moment, INX is the one we need for
counting:

  .A 0344  INX

Now we can test X to see if it is equal to six yet.  The first time around,
it won't be since X started at zero and was incremented to a value of 1.  If
X is not equal to six, we'll go back to $033E and print another letter.
Here's how we code it:

  .A 0345  CPX #$06
  .A 0347  BNE $033E

CPX stands for compare X; note that we are testing for an immediate value of
six, so we use the # symbol.  BNE means branch not equal; if X is not equal
to six, back we go to address $033E.

A little careful thought will reveal that the program will go back five times
for a total of six times around the loop.  It's exactly what we want.

Let's show the whole code, completing it with RTS:

  .A 033C  LDX #$00
  .A 033E  LDA $034A,X
  .A 0341  JSR $FFD2
  .A 0344  INX
  .A 0345  CPX #$06
  .A 0347  BNE $033E
  .A 0349  RTS

We may now put the characters for HELLO into memory.  These are data, not
instructions, so we must not try to assemble them.  Instead, we change memory
in the usual way, by displaying and then typing over.  We give the command .M
034A 034F, and type over the display to show

  .:034A  48 45 4C 4C 4F 0D xx xx

                                                                         :34:

By a lucky coincidence, this data fits exactly behind our program.

Everything should be ready now.  Disassemble the program at $033C and check
it.  You may note that the data at $034A doesn't disassemble too well, but
that's to be expected; these bytes are not instructions and cannot be
decoded.

When all looks well, return to BASIC (with .X) and try SYS 828.  The computer
should say HELLO.

Once again, set up a BASIC loop program:

  100 FOR J=1 TO 3
  110 SYS 828
  120 NEXT J


A Comment on SAVE
-----------------

If you wished to save the program to cassette tape, you'd have a problem on
the VIC or Commodore 64.  The machine language program is in the cassette
buffer; a save-to-tape command would cause the contents of the buffer to be
destroyed before the program could be written to tape.  Even disk commands
would not be completely safe:  4.0 BASIC disk commands use the cassette
buffer area as a work area; using these commands would probably destroy our
machine language program.

But saving the program is not the main problem.  A correctly saved program
can give trouble when you try to bring it back and run it safely.  The
difficulty is related to BASIC pointers, especially the start-of-variables
pointer.  The problem, and how to solve it, will be discussed in some detail
in Chapter 6.


A Stopgap SAVE
--------------

We can preserve short programs by making them part of DATA statements.  The
procedure is not difficult if screen editing is used intelligently.

We note that the program extends from $033C to $034F, including the message
(HELLO) at the end.  The decimal equivalents to these addresses are 828 to
847.  Enter the following BASIC line:

  FOR J=828 TO 847:PRINT PEEK(J);:NEXT J

Study the above line.  You will see that it asks BASIC to go through the part
of memory containing your machine language program, and display the contents
(in decimal notation, of course).  You'll see a result that looks something
like this:

                                                                         :35:

   162  0  189  74  3  32  210  255  232
  224  6  208  245  96  72  69  76  76  79
    13

These are indeed the bytes that make up your program.  With a little study,
you could reconstruct the 162-0 combination to be LDX #$00, or the 72-69-76-
76-69 at the end to be the word HELLO in ASCII.  It looks different when it's
in decimal, but it's still the same numbers.

You may try a little skill and artistry, using screen editing to perform the
next activity, or you may just retype the numbers into data lines as shown.
Either way, arrange the numbers as follows:

  50 DATA 162,0,189,74,3,32,210,255,232,224,6
  60 DATA 208,245,96,72,69,76,76,79,13

We now have a copy of our program, exactly the way it appears in memory, but
stored within DATA statements.  The DATA statements are part of a normal
BASIC program, of course, and will SAVE and LOAD with no trouble at all.

We can now reconstruct our machine language program, placing it back into
memory, with a simple BASIC POKE program:

  80 FOR J=828 TO 847:READ X:POKE J,X:NEXT J

Now our program is safe and sound--it handles like BASIC, but it will do a
machine language task for us as desired.  Let's display the entire BASIC
program

  50 DATA 162,0,189,74,3,32,210,255,232,224,6
  60 DATA 208,245,96,72,69,76,76,79,13
  80 FOR J=828 TO 847:READ X:POKE J,X:NEXT J
  100 FOR J=1 TO 3
  110 SYS 828
  120 NEXT J

This method of saving a machine language program is clean and trouble free,
but it becomes awkward where long programs are involved.  More advanced
methods will be discussed in Chapter 6.


Things You Have Learned
-----------------------

- Subroutines can be called from machine language using the JSR command.
  There are several useful kernal subroutines permanently available.

- A BASIC program may call a machine language program as a subroutine:  the
  BASIC command is SYS.  The machine language subroutine returns to the
  calling point with an RTS (return from subroutine) instruction.

                                                                         :36:

- The CHROUT subroutine at address $FFD2 allows output of a character,
  usually to the screen.  In addition to printable characters, special
  cursor- and color-control characters may be sent.

- Most machine language monitors have a small assembler to help program
  preparation, and a disassembler to assist in program checking.
