# C64 VIC-II Sprite Control $D010-$D017

($141) the rightmost dot goes past the right edge of the visible
display area, and a position 355 ($158) the whole sprite has moved out
of sight, off the right edge of the screen.

These registers are all intialized to 0 at power-up.

53248         $D000          SP0X
Sprite 0 Horizontal Position

53249         $D001          SP0Y
Sprite 0 Vertical Position

53250         $D002          SP1X
Sprite 1 Horizontal Position

53251         $D003          SP1Y
Sprite 1 Vertical Position

53252         $D004          SP2X
Sprite 2 Horizontal Position

53253         $D005          SP2Y
Sprite 2 Vertical Position

53254         $D006          SP3X
Sprite 3 Horizontal Position

53255         $D007          SP3Y
Sprite 3 Vertical Position

53256         $D008          SP4X
Sprite 4 Horizontal Position

53257         $D009          SP4Y
Sprite 4 Vertical Position

53258         $D00A          SP5X
Sprite 5 Horizontal Position

53259         $D00B          SP5Y
Sprite 5 Vertical Position

53260         $D00C          SP6X
Sprite 6 Horizontal Position

53261         $D00D          SP6Y
Sprite 6 Vertical Position

53262         $D00E          SP7X
Sprite 7 Horizontal Position

53263         $D00F          SP7Y
Sprite 7 Vertical Position

53264         $D010          MSIGX
Most Significant Bits of Sprites 0-7 Horizontal Position

Bit 0:  Most significant bit of Sprite 0 horizontal position
Bit 1:  Most significant bit of Sprite 1 horizontal position
Bit 2:  Most significant bit of Sprite 2 horizontal position
Bit 3:  Most significant bit of Sprite 3 horizontal position
Bit 4:  Most significant bit of Sprite 4 horizontal position
Bit 5:  Most significant bit of Sprite 5 horizontal position
Bit 6:  Most significant bit of Sprite 6 horizontal position
Bit 7:  Most significant bit of Sprite 7 horizontal position

Setting one of these bites to 1 adds 256 to the horizontal position of
the corresponding sprite.  Resetting one of these bits to 0 restricts
the horizontal position of the corresponding sprite to a value of 255
or less

53265         $D011          SCROLY
Vertical Fine Scrolling and Control Register

Bits 0-2:  Fine scroll display vertically by X scan lines (0-7)
Bit 3:  Select a 24-row or 25-row text display (1=25 rows, 0=24 rows)
Bit 4:  Blank the entire screen to the same color as the background
  (0=blank)
Bit 5:  Enable bitmap graphics mode (1=enable)
Bit 6:  Enable extended color text mode (1=enable)
Bit 7:  High bit (Bit 8) of raster compare register at 53266 ($D012)

This is one of the two important multifunction control registers on
the VIC-II chip.  Its defaule value is 155, which sets the high bit of
the raster compare to 1, selects a 25-row display, disables the
blanking feature, and uses a vertical scrolling offset of three scan
lines.

Bits 0-2.  These bits control vertical fine scrolling of the screen
display.  This feature allows you to move the entire text display
smoothly up and down, enabling the display area to act as a window,
scrolling over a larger text or character graphics display.

Since each row of text is eight scan lines high, if you simply move
each line of text up one row, the characters travel an appreciable
distance each time they move, which gives the motion a jerky quality.
This is called coarse scrolling, and you can see an example of it when
LISTing a program that is too long to fit on the screen all at one
time.

By placing a number from 1 to 7 into these three bits, you can move
the whole screen display down by from 1 to 7 dot spaces.  Stepping
through the values 1 to 7 allows you to smoothly make the transition
from having a character appear in one row on the screen to having it
appear in the next row.  To demonstrate this, type in the following
sample program, LIST it, and RUN.

10 FOR I= 1 TO 50:FOR J=0 TO 7
20 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I
30 FOR I= 1 TO 50:FOR J=7 TO 0 STEP-1
40 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I

As you can see, after the display has moved seven dot positions up or
down, it starts over at its original position.  In order to continue
the scroll, you must do a coarse scroll every time the value of the
scroll bits goes from 7 to 0, or from 0 to 7.  This is accomplished by
moving the display data for each line by 40 bytes in either direction,
overwriting the data for the last line, and introducing a line of data
at the opposite end of screen memory to replace it.  Obviously, ony a
machine language program can move all of these lines quickly enough to
maintain the effect of smooth motion.  The following BASIC program,
however, will give you an iea of what vertical fine scrolling is like:

10 POKE 53281,0:PRINTCHR$(5);CHR$(147)
20 FORI=1 TO 27:
30 PRINTTAB(15)CHR$(145)"            ":POKE 53265,PEEK(53265)AND248
40 WAIT53265,128:PRINTTAB(15)"I'M FALLING"
50 FOR J=1 TO 7
60 POKE53265,(PEEK(53265)AND248)+J
70 FORK=1TO50
80 NEXT K,J,I:RUN

Bit 3.  This bit register allows you to select either the normal
25-line text display (by setting the bit to 1), or a shortened 24-row
display (by resetting that bit to 0).  This shortened display is
created by extending the border to overlap the top or bottom row.  The
characters in these rows are still there; they are just covered up.

The shortened display is designed to aid vertical fine scrolling.  It
covers up the line into which new screen data is introduced, so that
the viewer does not see the new data being moved into place.

However, unlink the register at 53270 ($D016) which shortens the
screen by one character space on either side to aid horizontal
scrolling in either direction, this register can blank only one
vertical line at a time.  In order to compensate, it blanks the top
line when the three scroll bits in this register are set to 0, and
shifts the blanking one scan line at a time as the value of thee bits
increases.  Thus the bottom line is totally blanked when these bits
are set to 7.

Bit 4.  Bit 4 of this register controls the screen blanking feature.
When this bit is set to 0, no data can be displayed on the screen.
Instead, the whole screen will be filled with the color of the frame
(which is controlled by th eBorder Color Register at 53280 ($D020)).

Screen blanking is useful because of the way in which the VIC-II chip
interacts with the 6510 microprocessor.  Since the VIC-II and the 6510
both have to address the same memory, they must share the system data
bus.  Sharing the data bus means that they must take turns whenever
they want to address memory.

The VIC-II chip was designed so that it fetches most of the data it
needs during the part of the cycle in which the 6510 is not using the
data bus.  But certain operations, such as reading the 40 screen codes
needed for each line of text from video mmeory, or fetching sprite
data, require that the VIC-II chip get data at a faster rate than is
possible just by using the off half of the 6510 cycle.

Thus, the VIC-II chip must delay the 6510 for a short amount of time
while it is using the data bus to gather display information for text
or bitmap graphics, and must delay it a little more if sprites are
also enabled.  When you set the screen blanking bit to 0, these delays
are eliminated, and the 6510 processor is allowed to run at its full
speed.  This speeds up any processing task a little.

To demonstrate this, run the following short program.  As you will
see, leaving the screen on makes the processor run about 7 percent
slower than when you turn it off.  If you perform the same timing test
on the VIC-20, you will find that it runs at the same speed with its
screen on as the 64 does with its screen off.  And the same test on a
PET will run substantially slower.

10 PRINT CHR$(147);TAB(13);"TIMING TEST":PRINT:TI$="000000":GOTO 30
20 FOR I=1 TO 10000:NEXT I:RETURN
30 GOSUB 20:DISPLAY=TI
40 POKE 53265,11:TI$="000000"
50 GOSUB 20:NOSCREEN=TI:POKE 53265,27
60 PRINT "THE LOOP TOOK";DISPLAY;" JIFFIES"
70 PRINT "WITH NO SCREEN BLANKING":PRINT
80 PRINT "THE LOOP TOOK";NOSCREEN;" JIFFIES"
90 PRINT "WITH SCREEN BLANKING":PRINT
100 PRINT "SCREEN BLANKING MAKE THE PROCESSOR"
110 PRINT "GO";DISPLAY/NOSCREEN*100-100;"PERCENT FASTER"

The above explanation accounts for the screen being turned off during
tape read and write operations.  The timing of these operations is
rather critical, and would be affected by even the relatively small
delay caused by the video chip.  It also explains why the 64 has
difficulty loading programs from an unmodified 1540 Disk Drive, since
the 1540 was set up to transfer data from the VIC-20, which does not
have to contend with these slight delays.

If you turn off the 64 display with a POKE 53265,PEEEK(53265) AND 239,
you will be able to load programs correctly from an old 1540 drive.
The new 1541 drive transfers data at a slightly slower rate in the
default setting, and can be set from software to transfer it at the
higher rate for the VIC-20.

Bit 5.  Setting Bit 5 of this register to 1 enables the bitmap
graphics mode.  In this mode, the screen area is broken down into
64,000 separate dots of light, 320 dots across by 200 dots high.  Each
dot corresponds to one bit of display memory.  If the bit is set to 1,
the dot will be displayed in the foreground color.  If the bit is
reset to 0, it will be displayed in the background color.  This allows
the display of high-resolution graphics images for games, charts, and
graphs, etc.

Bitmapping is a common technique for implementing high-resolution
graphics on a microcomputer.  There are some features of the Commodore
system which are unusual, however.

Most systems display screen memory sequentially; that is, the first
byte controls the display of the first eight dots in the upper-left
corner of the screen, the second byte controls the eight dots to the
right of that, etc.  In the Commodore system, display memory is laid
out more along the lines of how character graphics dot-data is
arranged.

The first byte controls the row of eight dots in the top-left corner
of the screen, but the next byte controls the eight dots below that,
and so on until the ninth byte.  The ninth byte controls the eight
dots directly to the right of those controlled by the first byte of
display memory.  It is exactly the same as if the screen were filled
with 1000 programmable characters, with display memory taking the
place of the character dot-data.

The 64's bitmap graphics mode also resembles character graphics in
that the foreground color of the dots is set by a color map (although
it does not use the Color RAM for this purpose).  Four bits of each
byte of this color memory control the foreground color of one of these
eight-byte groups of display memory (which form an 8 by 8 grid of 64
dots).  Unlike character graphics, however, the other four bits
control the background color that will be seen in the eight-byte
display group where a bit has a value of 0.

Setting up a bitmap graphics screen is somewhat more complicated than
just setting this register bit to 1.  You must first choose a location
for the display memory area, and for the color memory area.  The
display memory area will be 8192 bytes long (8000 of which are
actually used for the display) and can occupy only the first or the
second half of the 16K space which the VIC-II chip can address.

Each byte of bitmap graphics color memory uses four bits for the
background color as well as four bits for the foreground color.
Therefore, the Color RAM nybbles at 55296 ($D800), which are wired for
four bits only, cannot be used.  Another RAM location must therefore
be found for color memory.

This color memory area will take up 1K (1000 bytes of which are
actually used to control the foreground and background colors of the
dots), and must be in the opposite half of VIC-II memory as the
display data.  Since bitmap graphics require so much memory for the
display, you may want to select a different 16K bank for VIC-II memory
(see the discussion of things to consider in selecting a VIC-II memory
bank at location 56576 ($DD00)).

To keep things simple, however, let's assume that you have selected to
use the default bank of VIC-II memory, which is the first 16K.  You
would have to select locations 8192-16383 ($2000-$3FFF) for screen
memory, because the VIC-II chip sees an image of the character ROM in
the first half of the 16K block (at locations 4096-8192
($1000-$1FFF)).  Color memory could be placed at the default location
of text display memory, at 1024-2047 ($400-$7FF).  Placement of bitmap
display and color memory is controlled by the VIC Memory Control
Register at 53272 ($D018).

When in bitmap mode, the lower four bits of this register, which
normally control the base address of character dot-data, now control
the location of the 8K bitmap.  Only Bit 3 is significant.  If it is
set to 1, the graphics display memory will be in the second 8K of
VIC-II memory (in this case, starting at 8192 ($2000)).  If that bit
contains a 0, the first 8K will be used for the bitmap.  The upper
four bits of this register, which normally control the location of the
Video Display Matrix, are used in bitmap mode to establish the
location of the color map within the VIC-II address space.  These four
bits can hold a number from 0 to 15, which indicates on which 1K
boundary the color map begins.  For example, if color memory began at
1024 (1K), the value of these four bits would be 0001.

Once the bitmap mode has been selected, and the screen and color
memory areas set up, you must establish a method for turning each
individual dot on and off.  The conventional method for identifying
each dot is to assign it to a horizontal (X) position coordinate and a
vertical (Y) coordinate.

Horizontal position values will range from 0 to 319, where dot 0 is at
the extreme left-hand side of the screen, and dot 319 at the extreme
right.  Vertical positions will range from 0 to 199, where dot 0 is on
the top line, and dot 199 is on the bottom line.
