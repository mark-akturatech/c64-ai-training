# ML for C64 - Appendix A: Instruction Details (EOR-PLP)

| sure to save any sensitive data in these registers before calling CHKIN.  |
|                                                                           |
| Status:  Status flags may be changed.  In VIC and Commodore 64, the C     |
| (carry) flag indicates some type of problem with connecting to the input  |
| channel.                                                                  |
|                                                                           |
*---------------------------------------------------------------------------*

                                                                        :137:

To switch input to logical file 1, we would need to follow these steps:

  1.  Load a value of 1 into X (LDX #$01).

  2.  JSR to address $FFC6.

Once the input is switched, we may obtain as many characters as we wish using
subroutine $FFE4.  Eventually, we must disconnect from the logical file and
return to our default input--the keyboard.  We do this by calling subroutine
CLRCHN at address $FFCC.  This is the same subroutine that disconnects output
from a logical file.


Input Example
-------------

We can write a program to read an input file from disk or cassette.  First,
let's write the file.  We open the file according to its type:

  Disk:      OPEN 1,8,3,"0:DEMO,S,W"
  Cassette:  OPEN 1,1,1

This may be done with a direct statement.  Now let's write a few things to
the file:

  PRINT #1,"HELLO THIS IS A TEST"
  PRINT #1,"THIS IS THE LAST LINE"
  CLOSE 1

If we have typed in the above statements correctly, we should have a
completed sequential file written on cassette or disk.  Before writing the
machine language input program, let's examine how we might read the file back
in BASIC:

  Disk:      100 OPEN 1,8,3,"DEMO"
  Cassette:  100 OPEN 1
             110 INPUT #1,X$
             120 PRINT X$
             130 IF ST=0 GOTO 110
             140 CLOSE 1

We might alternatively have written lines 110 and 120 as

             120 GET #1,X$
             130 PRINT X$;

This more closely approximates the logic flow of our machine language
program, since it will get the characters one at a time.  If you are unsure
about the role of ST, read up on it.  We will use the same variable (at its
address of $90 or $96) to do exactly the same thing in machine language.

Type NEW and enter the following program:

                                                                        :138:

  Disk:      100 OPEN 1,8,3,"DEMO"
  Cassette:  100 OPEN 1,1,1
             110 SYS 828
             120 CLOSE 1

We will read the file and copy it to the screen entirely in machine language.
Let's start coding at $033C:

  .A 033C  LDX #$01
  .A 033E  JSR $FFC6

Now the input is connected to logical file 1.  Let's get information from it
and put it on the screen:

  .A 0341  JSR $FFE4
  .A 0344  JSR $FFD2

We must check ST as we would in BASIC.  ST might be at either of two
addresses, depending on the system:

  VIC, Commodore 64:  .A 0347  LDA $90
  PET/CBM:            .A 0347  LDA $96

If ST is zero, there is more to come from the file; we may go back.  If ST is
nonzero, there could be an error or we may be at the end of the file.  In
either case, we don't want to read more from the file.

  .A 0349  BEQ $0341
  .A 034B  JSR $FFCC
  .A 034E  RTS

Check it and try it.  The file is delivered to the screen quickly.


A File Transfer Program
-----------------------

Let's write a program to transfer a sequential file from any common device to
any other.  BASIC will sort out which files to handle; once the files are
opened, machine language will take from and deliver to the appropriate
logical devices as desired.

It's not a good idea to switch input and output at the same time--in other
words, to call both $FFC6 and $FFC9 without canceling either via $FFCC.  The
kernal doesn't mind, but it confuses the peripheral devices, which expect to
have exclusive occupancy of the data bus to the computer..  So we'll follow
the pattern:  switching on, sending or receiving, switching off, and then
going to the other device.

                                                                        :139:

One more thing.  ST tells us the status of the last device handled.
Consider:  if we input a character, then output a character, and then check
the value of ST, we have a problem.  ST will not tell us about the input,
since the last device handled was output; thus, we won't know if we are at
the end of the file or not.  In machine language, as in BASIC, we must code
carefully to solve this problem.

Here comes BASIC:

  100 PRINT "FILE TRANSFER"
  110 INPUT "INPUT FROM (DISK,TAPE)";A$
  120 IF LEFT$(A$,1)="T" THEN OPEN 1:GOTO 160
  130 IF LEFT$(A$,1)<>"D" GOTO 110
  140 INPUT "DISK FILE NAME";N$
  150 OPEN 1,8,3,N$
  160 INPUT "TO (DISK,TAPE,SCREEN)";B$
  170 IF LEFT$(B$,1)="S" THEN OPEN 2,3:GOTO240
  180 IF LEFT$(B$,1)="D" GOTO 210
  190 IF LEFT$(B$,1)<>"T" GOTO 160
  200 IF LEFT$(A$,1)="T" GOTO 160
  210 INPUT "OUTPUT FILE NAME";F$
  220 IF LEFT$(B$,1)="D" THEN OPEN 2,8,4,"0:"+N$+",S,W"
  230 IF LEFT$(B$,1)="T" THEN OPEN 2,1,1,N$
  240 SYS xxxx
  250 CLOSE 2:CLOSE 1

We'll work this out for the Commodore 64 computer; you can adjust it for
PET/CBM or VIC-20.  The above BASIC program should not take up more than 511
bytes; on a standard Commodore 64, that means that we'll have clear space for
our machine language program starting at $0A00 (decimal 2560).  We'll move
the start-of-variables along, of course, so that our machine language program
won't be disturbed by them.

When we first type line 240, we won't know what SYS address to use.  After
the program is typed in (with SYS xxxx at line 240), we can easily confirm
that the machine language can start at $0A00 by checking the start-of-
variables pointer.  We go back and change 240 to SYS 2560; now we're ready to
put in the machine language code:

  .A 0A00  LDX #$01
  .A 0A02  JSR $FFC6
  .A 0A05  JSR $FFE4

                                                                        :140:

By this time, we have a character in the A register from the input source.
We also have a value in ST, telling us if this is the last character.  Let's
examine the ST problem:  we must check its value now, since ST will be
changed after we do the output.  But we don't want to take any action based
on ST yet; we must first send the character we have received.  Let's check
ST, and put the results of the check onto the stack:

  .A 0A08  LDX $90
  .A 0A0A  PHP

If ST is zero, the Z flag will be set; we'll preserve this flag along with
the others until we call it back from the stack.  If you are adapting this
program for the PET/CBM, don't forget that ST is at address $96 for your
machine.

The next thing we want to do is to disconnect the input by calling $FFCC; but
this will destroy the A register.  How can we preserve this value?  By
transferring to another register, or by pushing A to the stack.  Let's do
that.  There will now be two things on the stack.

  .A 0A0B  PHA

We are now free to disconnect from the input channel and connect to the
output.  Here we go:

  .A 0A0C  JSR $FFCC
  .A 0A0F  LDX #$02
  .A 0A11  JSR $FFC9
  .A 0A14  PLA

The A register gets back the last thing saved to the stack, and that, of
course, is our input character.  We're ready to send it to the output device:

  .A 0A15  JSR $FFD2
  .A 0A18  JSR $FFCC

Now we may pick up on the condition of ST that we stacked away earlier.  Here
come up the flags that we stored:

  .A 0A1B  PLP

If the Z flag is set, we want to go back and get another character.  If not,
we are finished and can return to BASIC, allowing BASIC to close the files
for us:

  .A 0A1C  BEQ $0A00
  .A 0A1E  RTS

Important:  Before running this program, be sure to move the start-of-
variables pointer ($002D/$002E) so that it points at address $0A1F;
otherwise, the BASIC variables will destroy this program.

                                                                        :141:

Review:  The Instruction Set
----------------------------

We started with the load, save, and compare for the three data registers:

  LDA  LDX  LDY
  STA  STX  STY
  CMP  CPX  CPY

The instructions are almost identical in action, although only the A register
has indirect, indexed addressing modes.  We continued with the logical and
arithmetic routines that apply only to A:

  AND  ORA  EOR  ADC  SBC

Arithmetic also includes the shift and rotate instructions, which may be used
on the A register or directly upon memory:

  ASL  ROL  LSR  ROR

Memory may also be directly modified by the increment and decrement
instructions, which have related instructions that operate on X and Y:

  INC  DEC
  INX  DEX
  INY  DEY

We may transfer control by means of branch instructions, which are all
conditional:

  BEQ  BCS  BMI  BVS
  BNE  BCC  BPL  BVC

The branch instructions can make only short "hops"; the jump instruction is
unconditional:

  JMP

Subroutines are called with the jump-subroutine, and returned with return-
from-subroutine; we may also return from interrupts:

  JSR  RTS  RTI

We may modify any of several flags with the appropriate set or clear command.
Some of the flags control internal processor operation:  for example, the I
(interrupt disable) flag locks out the interrupt; the D (decimal mode)
affects the way the ADC and SBC work with numbers.

                                                                        :142:

  SEC       SEI  SED
  CLC  CLV  CLI  CLD

We may transfer information between the A register and X or Y; and for
checking or setting the stack location, we may move the stack pointer to X,
or X to the stack pointer.  The latter is a powerful command, so use it with
care.

  TAX  TAY  TSX
  TXA  TYA  TXS

We may push or pull information from the stack:

  PHA  PHP
  PLA  PLP

There's a special test, used mostly for checking IA chips:

  BIT

The BIT test is used only for specific locations:  no indexing is allowed.
The high bit from the location being tested is transferred straight to the N
flag.  The next highest bit (bit 6) goes straight to the V flag.  Finally,
the Z flag is set according to whether the location has any bits set that
match the bits set in the A register.  Thus, we can check a location with
BIT $.... followed by BMI to test the high bit, or BVS to test bit 6, or BNE
to test any selected bit or group of bits.  It's a rather specialized
instruction, but useful for testing input/output ports.

Finally, the instruction that does nothing, and the BRK instruction that
causes a "false interrupt," usually taking us to the monitor:

  NOP  BRK

That's the whole set.  With these instructions, you can write programs to
