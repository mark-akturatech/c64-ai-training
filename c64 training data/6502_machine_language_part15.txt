# ML for C64 - Chapter 7: Interrupts, IRQ, NMI

We'll be working through an elaborate example that uses indirect, indexed
addressing to manipulate the computer screen.  First, a brief diversion.

                                                                         :83:

A Rarity:  Indexed, Indirect
----------------------------

There is another addressing mode that is little used in Commodore computers:
indexed, indirect.  It uses the X register rather than the Y, and is coded as
in the following example:  LDA ($C0,X).  In this case, indexing takes place
first.  The contents of X are added to the indirect address (in this case,
$C0) to make an effective indirect address.  If X were equal to 4 in this
example, the effective indirect address would be $00C4, and the contents of
$00C4 and $00C5 would be used as the effective address of the data.

 $00               $FF
  ++--+--+--+--------+---------------------------------------------------+
  ||..|..|..|        |              MEMORY                               |
  ++--+--+--+--------+---------------------------------------------------+
    ^     ^|                    ^
    |     ||                    |
    |  X  |`--------------------'
    +-----'
    |
  INDEXED, INDIRECT ALLOWS ONE OF SEVERAL
  INDIRECT ADDRESSES TO BE CHOSEN USING
  THE X INDEX REGISTER

  Figure 5.9


In certain types of control processing, this is a quite useful address mode.
X will contain an even number; since each indirect address is two bytes long,
we will need to skip from one to the other, two bytes at a time.

Let's take a hypothetical communications system that is connected to four
telecommunications lines and see how indexed, indirect addressing might be
used.  Characters are being received from the four lines almost
simultaneously.  As each character arrives, it must be put away into a memory
buffer belonging to that particular line; in that way, traffic received from
the various sources won't get mixed together.  Zero-page will contain four
indirect addresses, one for each line; each indirect address points at an
input area for one line.  Suppose a character is received into the A register
from one of the lines; the line number (times two) is in the X register.  We
could then put the character away with the instruction STA ($60,X).  Thus, if
line zero was involved, its indirect address at address $60/61 would be used;
for line 1, the address at $62/63 would be used; and so on.  After we had
stored the character concerned, we'd need to bump the indirect pointer so
that the next character will go into a new position:  INC $60,X would do the
trick.

                                                                         :84:

The above example is a rather specialized use of the indexed, indirect
address mode.  You may never need to use this mode.  Indeed, most programmers
lead full, rich lives without ever writing code that uses indexed, indirect
addressing.


The Great Zero-Page Hunt
------------------------

Indirect, indexed addresses are very important.  They are your gateway to
reaching any part of memory from a single instruction.  But you must have two
bytes available in zero-page for each indirect address you want to use.

The Commodore ROM system helps itself to liberal amounts of zero-page memory.
You don't have much empty space left over.  How can you find space for these
indirect pointers?

First, look for unused locations.  There are only a few of them:  on the VIC
and Commodore 64, you'll find four locations at locations $00FC to $00FF.
That's enough for two indirect addresses.

If you need more, look through the memory maps for locations designated as
"work areas" or "utility pointers."  They can usually be put to work for a
temporary job.

Finally, you can take working parts of zero-page and copy them to some other
parts of memory.  You can use these locations, carefully putting back the
original contents before returning to BASIC.  Don't try this with any values
that are used by the interrupt routines (involved with the screen, keyboard,
or RS-232); the interrupt can and does strike while your machine language
program is running.  And if the interrupt program changes these zero-page
values, your program is going to behave badly.


Project:  Screen Manipulation
-----------------------------

This project is intended to show how indirect, indexed addressing can be used
effectively.  We'll change something on the screen--enough so that we reach
more than 256 addresses.  Ordinary indexing, therefore, won't do.

                                                                         :85:

We'll select a number of lines on the screen; within each line, we'll change
a certain group of characters.  In other words, we will write the code so as
to manipulate a window on the screen.

To do this, we'll need to code two steps:  setting up the start of a screen
line, and later moving on to the next line when needed.  Within each line,
we'll work our way through the range of screen columns that we have selected.
In fact, it's a big loop (for the lines) containing a small loop (for the
columns within that line).  We'll use indirect addressing to point to the
start of each line, and indexing (the Y register) to select the portion of
that line to change.

Since there's a variety of Commodore machines, we have some problems to
resolve.  All Commodore screens are "memory mapped," that is, the information
appearing on the screen is copied directly from some part of memory.  We may
change the screen by changing the appropriate memory.  But different machines
use different memory addresses; and in VIC and Commodore 64, the screen may
be moved around.  Another thing to consider is that the length of the line
varies between different machines--it might be 22 or 40 or 80 columns.

No problem.  If you have a 40-column machine, 40 equals $28; code

  .A 033C  LDA #$28

For a 22-column machine, change the above to LDA #$16; and for an 80-column
PET, code LDA #$50.

Have you coded the correct value?  Let's proceed with our next decision.  In
the PET/CBM, screen memory starts at address $8000; in VIC or Commodore 64,
the screen starts at whatever page is designated in address $0288.  Let's
code as follows:

  PET/CBM:           .A 033E  LDX #$80
                     .A 0340  NOP

  VIC/Commodore 64:  .A 033E  LDX $0288

The NOP instruction does nothing, but it makes the coding the same length so
that we may continue with address $0341 in either case.  The A register tells
us our line length, and the X register tells us the page number on which the
screen starts.  Let's put them away.  The line length will be needed for
addition later, so we may put it anywhere safe; the screen address will be
part of an indirect address, so it must go into zero-page.

                                                                         :86:

It's hard to find a zero-page address that may be used in all Commodore
machines; we'll choose $00BB and $00BC.  $BB contains the low byte of the
address, of course.  Let's code

  .A 0341  STA $03A0
  .A 0344  STX $BC

Note that we are using zero-page addressing mode for the instruction at
address $0344.  That puts the high byte of the address in place.  Now we'll
set the low byte to zero:

  .A 0346  LDA #$00
  .A 0348  STA $BB

Our indirect address is now pointing at the start of screen memory.  Let's
discuss in more detail what we want to do with the screen.  Specifically, we
want to change a number of lines, let's say 14, on the screen.  We will step
along our indirect address by adding to the indirect address:  maybe 22,
maybe 40, maybe 80; whatever is in address $03A0.  And we won't do the whole
line; we'll start in column 5 and go to column 18.  Let's count the lines in
the X register; we'll start X at zero.

  .A 034A  LDX #$00

Now we're ready to do a screen line.  Later, we'll adjust the indirect
address and come back here to do another line.  We should make a note to
ourselves:  "Come back to $034C for the next screen line."

The indirect address is pointing at the start of the line.  We want to start
work in column 5.  That means that Y should start with an offset of 4 (the
start of the line plus 4).  Let's do it:

  .A 034C  LDY #$04

We're going to walk Y up, and loop back to this point for the next character
on the line.  We might note:  "Come back to $034E for the next character."

We're ready to go.  Let's dig out the character that's currently on the
screen:

  .A 034E  LDA ($BB),Y

This is worth a review.  Locations $BB and $BC contain the address of the
start of screen memory; on the PET/CBM, for example, this would be $8000.  To
this, we add the contents of Y (value 4) to create an effective address of
$8004; and from location $8004 we get the screen character.

We decide that we will leave spaces alone.  The space character shows on the
screen as a value of decimal 32, hex 20.  Let's skip the next operation if
it's a space:

                                                                         :87:

  .A 0350  CMP #$20
  .A 0352  BEQ $0356

We have to guess at the address to which we will skip ahead, since we haven't
gotten there yet.  Make a note:  "This address may need correction."

  .A 0354  EOR #$80

This is where we manipulate the character.  The EOR is a "flip-over" command;
we're flipping the high bit of the screen value.  You may look up screen
codes to see what this does, or you may wait and see what happens.  At this
point, our code from $0352 joins up.  As it happens, we were lucky again:
the address is exactly right to rejoin at $0356.  But if it were not, you
know how to fix it, don't you?  Exit the assembler, then go back and type
over.

Now we put the modified character back to the screen:

  .A 0356  STA ($BB),Y

We have done one character.  Let's move along the line to the next character,
and if we have passed column 18 (Y=17) we should quite and go to the next
line.

  .A 0358  INY
  .A 0359  CPY #$12
  .A 035B  BCC $034E

Y moves along to the next character position:  five, then six the next time
around, and so on.  So long as Y is less than 18 (hex 12) we'll go back,
since BCC means "branch less than."  If we get past this point, we have
completed the line and must move to the next one.

We move to the next line by adding to the indirect address.  We must add 22,
or 40, or 80; the value is in address $03A0 (you may remember that we stored
it with the instruction at $0341).  We must remember to clear the carry flag
before starting the addition, and to add starting at the low byte of the
address (at $BB).

  .A 035D  CLC
  .A 035E  LDA $BB
  .A 0360  ADC $03A0
  .A 0363  STA $BB
  .A 0365  LDA $BC
  .A 0367  ADC #$00
  .A 0369  STA $BC

                                                                         :88:

The last three instructions seem odd.  Why would we add zero to the contents
of $BC?  Surely that changes nothing.  The answer is obvious after a little
thought:  there might be a carry from the previous addition.

Now we're ready to count the lines:  we had decided to use X as a counter.
Let's add one to X, and test to see whether we have done the 14 lines:

  .A 036B  INX
  .A 036C  CPX #$0E
  .A 036E  BNE $034C

If we've done the required number of lines, we have nothing more to do other
than return to BASIC:

  .A 0370  RTS

Disassemble and check it.  Again, you'll find that the code occupies more
than one full screen.  Return to BASIC.

This time, we'll write a small BASIC program to exercise the machine language
code.  Type NEW to clear out any old BASIC code, and enter

  100 FOR J=1 TO 10
  110 SYS 828
  120 FOR K=1 TO 200
  130 NEXT K,J

The extra loop is to slow things down.  Machine language runs so fast that
the effect might not be properly visible if run at full speed.

Project for enthusiasts:  Can you change the program to do a different set of
columns?  Could you change it so that it affected only the letter "S"
wherever it appeared on the screen?


Comment for VIC-20 and Commodore 64
-----------------------------------

This exercise will work as intended.  Other types of screen work might call
for you to set the color nybble memory values before you can successfully
work directly with screen memory.  The rules for machine language are no
different from those for BASIC:  if you wish to POKE to the screen, you may
need to take the color nybble area into account.


Things You Have Learned
-----------------------

- Three address modes are not addresses at all.  Implied addressing means no
  address at all; accumulator addressing uses the A register and means the
  same thing; and immediate addressing uses a value, not an address.

                                                                         :89:

- Absolute addresses reference one location only, somewhere in memory.  Zero-
