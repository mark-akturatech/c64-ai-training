# C64 BASIC ROM - Operator Dispatch, Keyword Tables

program can use.

This can be a very complex task, and expressions an be of the string
or numeric type, and can contain any type of variable, as well as
constants.

At the end, the flag which shows whether the resulting value is string
or numeric at 13 ($D) is set, and if the value is numeric, the flag at
14 ($E) is set as well, to show if it is an integer or floating point
numer.

44675         $AE83          EVAL
Convert a Single Numeric Term from ASCII Text to a Floating Point
Number

This routine reduces a single arithmetic term which is part of an
expression from ASCII text to its floating point equivalent.

If the term is a constant, the routine sets the data type flag to
number, sets the text pointer to the first ASCII numeric character,
and jumps to the routine which converts the ASCII string to a floating
point number.

If the term is a variable, the variable value is retrieved.  If it is
the PI character, the value of PI is moved into the Floating Point
Accumulator.

This routine is vectored through RAM at 778 ($30A).

44712         $AEA8          PIVAL
PI Expressed as a Five-Byte Floating Point Number

The value of PI is stored here as a five-byte floating point number.

44785         $AEF1          PARCHK
Evaluate Expression Within Parentheses

This routine evaluates an expression within parentheses by calling the
syntax checking routines that look for opening and closing
parentheses, and then calling FRMEVL (4446, $AD9E) for each level of
parentheses.

44791         $AEF7          CHKCLS
Check for and Skip Closing Parentheses

44794         $AEFA          CHKOPN
Check for and Skip Opening Parentheses

44799         $AEFF          CHKCOM
Check for and Skip Comma

This syntax checking device is the same in substance as the two
checking routines above.  It is used when the next character should be
a comma.  If it is not, a SYNTAX ERROR retults.  If it is, the
character is skipped and the next character is read.  Any character
can be checked for and skipped this way by loading the character into
the Accumulator and entering this routine from SYNCHR at 44799
($AEFF).

44808         $AF08          SNERR
Print Syntax Error Message

44843         $AF2B          ISVAR
Get the Value of a Variable

44967         $AFA7          ISFUN
Dispatch and Evaluate a Function

If a BASIC function (like ASC("A")) is part of an expression, this
routine will use the function dispatch table at 42242 ($A502) to set
up the address of th proper function routine, and then branch to that
routine.

45030         $AFE6          OROP
Perform OR

The OR routine sets the .Y register as a flag, and falls through to
the AND routine, which also performs OR.

45033         $AFE9          ANDOP
Perform AND

The AND routine changes the parameters to two-byte integer values, and
performs the appropriate logical operation (AND or OR).  A result of 0
signifies false, while a result of -1 signifies true.

45078         $B016          DORE1
Perform Comparisons

This routine does the greater than (>), less than (<), and equal (=)
comparisons for foating point numbers and strings.  The result in the
Floating Point Accumulator will be 0 if the comparison is false, and
-1 if it is true.

45185         $B018          DIM
Perform DIM

This command calls the next routine to create an array for every
variable dimensioned (since a statement can take the form DIM A(12),
B(13), C(14)...).  If the array element is referenced before a DIM
statement (for example, A(3)=4), the array will be dimensioned to 10
(as if DIM A(10) were executed).  Remember, DIMensioning an array to
10 really creates 11 elements (10).  The 0 element should always be
considered in calculating the size to DIMension your array.

45195         $B08B          PTRGET
Search for a Variable and Set It Up If It Is Not Found

This routine attempts to locate a variable by searching for its name
in the variable area.  If an existing variable of that name cannot be
found, one is created with the NOTFNS routine below.

45331         $B113
Check If .A Register Holds Alphabetic ASCII Character

This is part of the check for a valid variable name (it must start
with an alphabetic character).

45341         $B11D          NOTFNS
Create a New BASIC Variable

This routine makes space for a seven-byte descriptor by moving the
variable storage area seven bytes higher in memory, and then creates
the descriptor.

45445         $B185          FINPTR
Return the Address of the Variable That Was Found or Created

This routine stores the address of the variable that was found or
created by the preceding routines in a pointer at 71-72 ($47-$48).

45460         $B194          ARYGET
Allocate Space for Array Descriptors

This routine allocates five bytes plus two bytes for every dimension
specified for the array descriptor.

45477         $B1A5          N32768
The Constant -32768 in Five-Byte Floating Point Format

This constant is used for range checking in the conversion of a
floating point number to a signed integer (the minimum inter value is
-32768).

45482         $B1AA
Convert a Floating Point Number to a Signed Integer in .A and .Y Registers

This subroutine calls AYINT, below, which checks to make sure that the
number in the Floating Point Accumulator is between 32767 and -32768,
and converts it to a 16-bit signed integer in 100-101 ($64-$65), high
byte first.  It leaves the high byte of the integer in the
Accumulator, and the low byte in the .Y register.

Although this routine does not appear to be referenced anywhere in
BASIC, the vector at locations 3-4 points to its address.  Presumably,
it is provided for the benefit of the user who wishes to pass
parameters in a USR call, or the like.

45490         $B1B2          INTIDX
Input and Convert a Floating Point Subscript to a Positive Integer

This routine converts a floating point subscript value to an integer,
making sure first that it is positive.

45503         $B1BF          AYINT
Convert a Floating Point Number to a Signed Integer

This subroutine first checks to make sure that the number in the
Floating Point Accumulator is between 32767 and -32768.  If it is not,
an ILLEGAL QUANTITY error results.  If it is, the routine converts it
to a 16-bit signed integer with the high byte in location 100 ($64),
and the low byte in location 101 ($65).

45521         $B1D1          ISARY
Find Array Element or Create New Array in RAM

This routine searches for an array.  If it is found, the subscript
value is checked to see if it is valid, and pointers to the array and
element of the array are set.  If it is not found, the array is
created, and the pointers set.

45637         $B245          BSERR
Print BAD SUBSCRIPT Error Message

45640         $B248          FCERR
Print ILLEGAL QUANTITY Error Message

45900         $B34C          UMULT
Compute the Size of a Multidimensional Array

This routine calculates the size of a multidimensional array by
multiplying the dimensions.

45949         $B37D          FRE
Perform FRE

The FRE function calls the garbage collection routine at 46374 ($B526)
to get rid of unused string text, and calculates the difference
between the bottom of string text and the top of array storage.  It
then drops through to the follow routine, which assumes that the free
memory value is a 16-bit signed integer, and converts it to floating
point accordingly.

Of course, while the free memory space on the PET might have always
been 32767 or less (the maximum value of a signed integer), sich is
definitely not the case on the 64.  Because conversion is from a
signed integer, any memory value over 32767 will be regarded as
negative (the high bit is treated as a sign bit).  Therefore, for
these higher values you must add twice the bit value of the high bit
(65536) in order to come up with the correct value.  The expression
FRE(0)-6556*(FRE(0)<0) will always return the correct amount of free
memory.

45969         $B391          GIVAYF
Convert 16-Bit Signed Integer to Floating Point

This routine treats the value in the Accumulator as the high byte of a
16-bit signed integer, and the value in the .Y register as the low
byte, and converts the signed integer into a floating point number in
the Floating Point Accumulator.

The address of this routine is pointed to by the RAM vector at 5-6,
and the routine can be used to return an argument from the USR call in
the Floating Point Accumulator.

45982         $B39E          POS
Perform POS

The POS command calls the Kernal PLOT routine (58634, $E50A) to get
the position of the cursor on the logical line.  What it really does
is an equivalent of PEEK(211).  Remember, since we are dealing with a
logical line, this number can be over 39.  The statement "THIS
SENTENCE IS LONGER THAN ONE PHYSICAL LINE";POS(X) will return a value
of 48 for the POS(X).

45990         $B3A6          ERRDIR
Check If the Program is Running in Direct Mode, and If So Issue an Error

This routine is called by statements that prohibit execution in direct
mode.  It checks a flag that is set when a line without a linenumber
is entered, and causes an ILLEGAL DIRECT error if the flag is set.

46003         $B3B3          DEF
Perform DEF

DEF performs some syntax checking, and pushes five bytes onto the
stack:  the first byte of the function statement, a two-byte pointer
to the dependent variable (the X in FN(X)), and the address of the
first character of the definition itself, where it resides in the
program text.
