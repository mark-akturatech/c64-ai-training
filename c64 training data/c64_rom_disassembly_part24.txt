# C64 BASIC ROM Disassembly $BE00-$BFFF - RND, SYS, SAVE, LOAD

.,BE00 A9 BD    LDA #$BD        set 1000000000 pointer low byte
.,BE02 A0 BD    LDY #$BD        set 1000000000 pointer high byte
.,BE04 20 28 BA JSR $BA28       do convert AY, FCA1*(AY)
.,BE07 A9 F7    LDA #$F7        set number exponent count
.,BE09 85 5D    STA $5D         save number exponent count
.,BE0B A9 B8    LDA #$B8        set 999999999.25 pointer low byte (max before sci note)
.,BE0D A0 BD    LDY #$BD        set 999999999.25 pointer high byte
.,BE0F 20 5B BC JSR $BC5B       compare FAC1 with (AY)
.,BE12 F0 1E    BEQ $BE32       exit if FAC1 = (AY)
.,BE14 10 12    BPL $BE28       go do /10 if FAC1 > (AY)
                                FAC1 < (AY)
.,BE16 A9 B3    LDA #$B3        set 99999999.90625 pointer low byte
.,BE18 A0 BD    LDY #$BD        set 99999999.90625 pointer high byte
.,BE1A 20 5B BC JSR $BC5B       compare FAC1 with (AY)
.,BE1D F0 02    BEQ $BE21       branch if FAC1 = (AY) (allow decimal places)
.,BE1F 10 0E    BPL $BE2F       branch if FAC1 > (AY) (no decimal places)
                                FAC1 <= (AY)
.,BE21 20 E2 BA JSR $BAE2       multiply FAC1 by 10
.,BE24 C6 5D    DEC $5D         decrement number exponent count
.,BE26 D0 EE    BNE $BE16       go test again, branch always
.,BE28 20 FE BA JSR $BAFE       divide FAC1 by 10
.,BE2B E6 5D    INC $5D         increment number exponent count
.,BE2D D0 DC    BNE $BE0B       go test again, branch always
                                now we have just the digits to do
.,BE2F 20 49 B8 JSR $B849       add 0.5 to FAC1 (round FAC1)
.,BE32 20 9B BC JSR $BC9B       convert FAC1 floating to fixed
.,BE35 A2 01    LDX #$01        set default digits before dp = 1
.,BE37 A5 5D    LDA $5D         get number exponent count
.,BE39 18       CLC             clear carry for add
.,BE3A 69 0A    ADC #$0A        up to 9 digits before point
.,BE3C 30 09    BMI $BE47       if -ve then 1 digit before dp
.,BE3E C9 0B    CMP #$0B        A>=$0B if n>=1E9
.,BE40 B0 06    BCS $BE48       branch if >= $0B
                                carry is clear
.,BE42 69 FF    ADC #$FF        take 1 from digit count
.,BE44 AA       TAX             copy to X
.,BE45 A9 02    LDA #$02        set exponent adjust
.,BE47 38       SEC             set carry for subtract
.,BE48 E9 02    SBC #$02        -2
.,BE4A 85 5E    STA $5E         save exponent adjust
.,BE4C 86 5D    STX $5D         save digits before dp count
.,BE4E 8A       TXA             copy to A
.,BE4F F0 02    BEQ $BE53       branch if no digits before dp
.,BE51 10 13    BPL $BE66       branch if digits before dp
.,BE53 A4 71    LDY $71         get output string index
.,BE55 A9 2E    LDA #$2E        character "."
.,BE57 C8       INY             increment index
.,BE58 99 FF 00 STA $00FF,Y     save to output string
.,BE5B 8A       TXA             
.,BE5C F0 06    BEQ $BE64       
.,BE5E A9 30    LDA #$30        character "0"
.,BE60 C8       INY             increment index
.,BE61 99 FF 00 STA $00FF,Y     save to output string
.,BE64 84 71    STY $71         save output string index
.,BE66 A0 00    LDY #$00        clear index (point to 100,000)
.,BE68 A2 80    LDX #$80        
.,BE6A A5 65    LDA $65         get FAC1 mantissa 4
.,BE6C 18       CLC             clear carry for add
.,BE6D 79 19 BF ADC $BF19,Y     add byte 4, least significant
.,BE70 85 65    STA $65         save FAC1 mantissa4
.,BE72 A5 64    LDA $64         get FAC1 mantissa 3
.,BE74 79 18 BF ADC $BF18,Y     add byte 3
.,BE77 85 64    STA $64         save FAC1 mantissa3
.,BE79 A5 63    LDA $63         get FAC1 mantissa 2
.,BE7B 79 17 BF ADC $BF17,Y     add byte 2
.,BE7E 85 63    STA $63         save FAC1 mantissa2
.,BE80 A5 62    LDA $62         get FAC1 mantissa 1
.,BE82 79 16 BF ADC $BF16,Y     add byte 1, most significant
.,BE85 85 62    STA $62         save FAC1 mantissa1
.,BE87 E8       INX             increment the digit, set the sign on the test sense bit
.,BE88 B0 04    BCS $BE8E       if the carry is set go test if the result was positive
                                else the result needs to be negative
.,BE8A 10 DE    BPL $BE6A       not -ve so try again
.,BE8C 30 02    BMI $BE90       else done so return the digit
.,BE8E 30 DA    BMI $BE6A       not +ve so try again
                                else done so return the digit
.,BE90 8A       TXA             copy the digit
.,BE91 90 04    BCC $BE97       if Cb=0 just use it
.,BE93 49 FF    EOR #$FF        else make the 2's complement ..
.,BE95 69 0A    ADC #$0A        .. and subtract it from 10
.,BE97 69 2F    ADC #$2F        add "0"-1 to result
.,BE99 C8       INY             increment ..
.,BE9A C8       INY             .. index to..
.,BE9B C8       INY             .. next less ..
.,BE9C C8       INY             .. power of ten
.,BE9D 84 47    STY $47         save current variable pointer low byte
.,BE9F A4 71    LDY $71         get output string index
.,BEA1 C8       INY             increment output string index
.,BEA2 AA       TAX             copy character to X
.,BEA3 29 7F    AND #$7F        mask out top bit
.,BEA5 99 FF 00 STA $00FF,Y     save to output string
.,BEA8 C6 5D    DEC $5D         decrement # of characters before the dp
.,BEAA D0 06    BNE $BEB2       branch if still characters to do
                                else output the point
.,BEAC A9 2E    LDA #$2E        character "."
.,BEAE C8       INY             increment output string index
.,BEAF 99 FF 00 STA $00FF,Y     save to output string
.,BEB2 84 71    STY $71         save output string index
.,BEB4 A4 47    LDY $47         get current variable pointer low byte
.,BEB6 8A       TXA             get character back
.,BEB7 49 FF    EOR #$FF        toggle the test sense bit
.,BEB9 29 80    AND #$80        clear the digit
.,BEBB AA       TAX             copy it to the new digit
.,BEBC C0 24    CPY #$24        
                                compare the table index with the max for decimal numbers
.,BEBE F0 04    BEQ $BEC4       if at the max exit the digit loop
.,BEC0 C0 3C    CPY #$3C        
                                compare the table index with the max for time
.,BEC2 D0 A6    BNE $BE6A       loop if not at the max
                                now remove trailing zeroes
.,BEC4 A4 71    LDY $71         restore the output string index
.,BEC6 B9 FF 00 LDA $00FF,Y     get character from output string
.,BEC9 88       DEY             decrement output string index
.,BECA C9 30    CMP #$30        compare with "0"
.,BECC F0 F8    BEQ $BEC6       loop until non "0" character found
.,BECE C9 2E    CMP #$2E        compare with "."
.,BED0 F0 01    BEQ $BED3       branch if was dp
                                restore last character
.,BED2 C8       INY             increment output string index
.,BED3 A9 2B    LDA #$2B        character "+"
.,BED5 A6 5E    LDX $5E         get exponent count
.,BED7 F0 2E    BEQ $BF07       if zero go set null terminator and exit
                                exponent isn't zero so write exponent
.,BED9 10 08    BPL $BEE3       branch if exponent count +ve
.,BEDB A9 00    LDA #$00        clear A
.,BEDD 38       SEC             set carry for subtract
.,BEDE E5 5E    SBC $5E         subtract exponent count adjust (convert -ve to +ve)
.,BEE0 AA       TAX             copy exponent count to X
.,BEE1 A9 2D    LDA #$2D        character "-"
.,BEE3 99 01 01 STA $0101,Y     save to output string
.,BEE6 A9 45    LDA #$45        character "E"
.,BEE8 99 00 01 STA $0100,Y     save exponent sign to output string
.,BEEB 8A       TXA             get exponent count back
.,BEEC A2 2F    LDX #$2F        one less than "0" character
.,BEEE 38       SEC             set carry for subtract
.,BEEF E8       INX             increment 10's character
.,BEF0 E9 0A    SBC #$0A        subtract 10 from exponent count
.,BEF2 B0 FB    BCS $BEEF       loop while still >= 0
.,BEF4 69 3A    ADC #$3A        add character ":" ($30+$0A, result is 10 less that value)
.,BEF6 99 03 01 STA $0103,Y     save to output string
.,BEF9 8A       TXA             copy 10's character
.,BEFA 99 02 01 STA $0102,Y     save to output string
.,BEFD A9 00    LDA #$00        set null terminator
.,BEFF 99 04 01 STA $0104,Y     save to output string
.,BF02 F0 08    BEQ $BF0C       go set string pointer (AY) and exit, branch always
                                save last character, [EOT] and exit
.,BF04 99 FF 00 STA $00FF,Y     save last character to output string
                                set null terminator and exit
.,BF07 A9 00    LDA #$00        set null terminator
.,BF09 99 00 01 STA $0100,Y     save after last character
                                set string pointer (AY) and exit
.,BF0C A9 00    LDA #$00        set result string pointer low byte
.,BF0E A0 01    LDY #$01        set result string pointer high byte
.,BF10 60       RTS             

                                *** constants
.:BF11 80 00                    0.5, first two bytes
.:BF13 00 00 00                 null return for undefined variables
.:BF16 FA 0A 1F 00              -100 000 000
.:BF1A 00 98 96 80               +10 000 000
.:BF1E FF F0 BD C0                -1 000 000
.:BF22 00 01 86 A0                  +100 000
.:BF26 FF FF D8 F0                   -10 000
.:BF2A 00 00 03 E8                    +1 000
.:BF2E FF FF FF 9C                     - 100
.:BF32 00 00 00 0A                       +10
.:BF36 FF FF FF FF                        -1

                                *** jiffy counts
.:BF3A FF DF 0A 80              -2160000    10s hours
.:BF3E 00 03 4B C0               +216000        hours
.:BF42 FF FF 73 60                -36000    10s mins
.:BF46 00 00 0E 10                 +3600        mins
.:BF4A FF FF FD A8                  -600    10s secs
.:BF4E 00 00 00 3C                   +60        secs

                                *** not referenced
.:BF52 EC                       checksum byte

                                *** spare bytes, not referenced
.:BF53 AA AA AA AA AA
.:BF58 AA AA AA AA AA AA AA AA
.:BF60 AA AA AA AA AA AA AA AA
.:BF68 AA AA AA AA AA AA AA AA
.:BF70 AA

                                *** perform SQR()
.,BF71 20 0C BC JSR $BC0C       round and copy FAC1 to FAC2
.,BF74 A9 11    LDA #$11        set 0.5 pointer low address
.,BF76 A0 BF    LDY #$BF        set 0.5 pointer high address
.,BF78 20 A2 BB JSR $BBA2       unpack memory (AY) into FAC1

                                *** perform power function
.,BF7B F0 70    BEQ $BFED       perform EXP()
.,BF7D A5 69    LDA $69         get FAC2 exponent
.,BF7F D0 03    BNE $BF84       branch if FAC2<>0
.,BF81 4C F9 B8 JMP $B8F9       clear FAC1 exponent and sign and return
.,BF84 A2 4E    LDX #$4E        set destination pointer low byte
.,BF86 A0 00    LDY #$00        set destination pointer high byte
.,BF88 20 D4 BB JSR $BBD4       pack FAC1 into (XY)
.,BF8B A5 6E    LDA $6E         get FAC2 sign (b7)
.,BF8D 10 0F    BPL $BF9E       branch if FAC2>0
                                else FAC2 is -ve and can only be raised to an
                                integer power which gives an x + j0 result
.,BF8F 20 CC BC JSR $BCCC       perform INT()
.,BF92 A9 4E    LDA #$4E        set source pointer low byte
.,BF94 A0 00    LDY #$00        set source pointer high byte
.,BF96 20 5B BC JSR $BC5B       compare FAC1 with (AY)
.,BF99 D0 03    BNE $BF9E       branch if FAC1 <> (AY) to allow Function Call error
                                this will leave FAC1 -ve and cause a Function Call
                                error when LOG() is called
.,BF9B 98       TYA             clear sign b7
.,BF9C A4 07    LDY $07         get FAC1 mantissa 4 from INT() function as sign in
                                Y for possible later negation, b0 only needed
.,BF9E 20 FE BB JSR $BBFE       save FAC1 sign and copy ABS(FAC2) to FAC1
.,BFA1 98       TYA             copy sign back ..
.,BFA2 48       PHA             .. and save it
.,BFA3 20 EA B9 JSR $B9EA       perform LOG()
.,BFA6 A9 4E    LDA #$4E        set pointer low byte
.,BFA8 A0 00    LDY #$00        set pointer high byte
.,BFAA 20 28 BA JSR $BA28       do convert AY, FCA1*(AY)
.,BFAD 20 ED BF JSR $BFED       perform EXP()
.,BFB0 68       PLA             pull sign from stack
.,BFB1 4A       LSR             b0 is to be tested
.,BFB2 90 0A    BCC $BFBE       if no bit then exit
                                do - FAC1
.,BFB4 A5 61    LDA $61         get FAC1 exponent
.,BFB6 F0 06    BEQ $BFBE       exit if FAC1_e = $00
.,BFB8 A5 66    LDA $66         get FAC1 sign (b7)
.,BFBA 49 FF    EOR #$FF        complement it
.,BFBC 85 66    STA $66         save FAC1 sign (b7)
.,BFBE 60       RTS             

                                *** exp(n) constant and series
.:BFBF 81 38 AA 3B 29           1.44269504 = 1/LOG(2)
.:BFC4 07                       series count
.:BFC5 71 34 58 3E 56           2.14987637E-5
.:BFCA 74 16 7E B3 1B           1.43523140E-4
.:BFCF 77 2F EE E3 85           1.34226348E-3
.:BFD4 7A 1D 84 1C 2A           9.61401701E-3
.:BFD9 7C 63 59 58 0A           5.55051269E-2
.:BFDE 7E 75 FD E7 C6           2.40226385E-1
.:BFE3 80 31 72 18 10           6.93147186E-1
.:BFE8 81 00 00 00 00           1.00000000

                                *** perform EXP()
.,BFED A9 BF    LDA #$BF        set 1.443 pointer low byte
.,BFEF A0 BF    LDY #$BF        set 1.443 pointer high byte
.,BFF1 20 28 BA JSR $BA28       do convert AY, FCA1*(AY)
.,BFF4 A5 70    LDA $70         get FAC1 rounding byte
.,BFF6 69 50    ADC #$50        +$50/$100
.,BFF8 90 03    BCC $BFFD       skip rounding if no carry
.,BFFA 20 23 BC JSR $BC23       round FAC1 (no check)
.,BFFD 4C 00 E0 JMP $E000       continue EXP()

                                *** start of the kernal ROM
                                EXP() continued
