# C64 BASIC ROM Disassembly $B400-$B4FF - VAL, STR$, CHR$

.,B400 20 8D AD JSR $AD8D       check if source is numeric, else do type mismatch
.,B403 68       PLA             pop function pointer low byte
.,B404 85 4E    STA $4E         restore it
.,B406 68       PLA             pop function pointer high byte
.,B407 85 4F    STA $4F         restore it
.,B409 A0 02    LDY #$02        index to variable pointer high byte
.,B40B B1 4E    LDA ($4E),Y     get variable address low byte
.,B40D 85 47    STA $47         save current variable pointer low byte
.,B40F AA       TAX             copy address low byte
.,B410 C8       INY             index to variable address high byte
.,B411 B1 4E    LDA ($4E),Y     get variable pointer high byte
.,B413 F0 99    BEQ $B3AE       branch if high byte zero
.,B415 85 48    STA $48         save current variable pointer high byte
.,B417 C8       INY             index to mantissa 3
                                now stack the function variable value before use
.,B418 B1 47    LDA ($47),Y     get byte from variable
.,B41A 48       PHA             stack it
.,B41B 88       DEY             decrement index
.,B41C 10 FA    BPL $B418       loop until variable stacked
.,B41E A4 48    LDY $48get current variable pointer high byte
.,B420 20 D4 BB JSR $BBD4       pack FAC1 into (XY)
.,B423 A5 7B    LDA $7B         get BASIC execute pointer high byte
.,B425 48       PHA             push it
.,B426 A5 7A    LDA $7A         get BASIC execute pointer low byte
.,B428 48       PHA             push it
.,B429 B1 4E    LDA ($4E),Y     get function execute pointer low byte
.,B42B 85 7A    STA $7A         save BASIC execute pointer low byte
.,B42D C8       INY             index to high byte
.,B42E B1 4E    LDA ($4E),Y     get function execute pointer high byte
.,B430 85 7B    STA $7B         save BASIC execute pointer high byte
.,B432 A5 48    LDA $48         get current variable pointer high byte
.,B434 48       PHA             push it
.,B435 A5 47    LDA $47         get current variable pointer low byte
.,B437 48       PHA             push it
.,B438 20 8A AD JSR $AD8A       evaluate expression and check is numeric, else do
                                type mismatch
.,B43B 68       PLA             pull variable address low byte
.,B43C 85 4E    STA $4E         save variable address low byte
.,B43E 68       PLA             pull variable address high byte
.,B43F 85 4F    STA $4F         save variable address high byte
.,B441 20 79 00 JSR $0079       scan memory
.,B444 F0 03    BEQ $B449       branch if null (should be [EOL] marker)
.,B446 4C 08 AF JMP $AF08       else syntax error then warm start

                                *** restore BASIC execute pointer and function variable from stack
.,B449 68       PLA             pull BASIC execute pointer low byte
.,B44A 85 7A    STA $7A         save BASIC execute pointer low byte
.,B44C 68       PLA             pull BASIC execute pointer high byte
.,B44D 85 7B    STA $7B         save BASIC execute pointer high byte
                                put execute pointer and variable pointer into function
.,B44F A0 00    LDY #$00        clear index
.,B451 68       PLA             pull BASIC execute pointer low byte
.,B452 91 4E    STA ($4E),Y     save to function
.,B454 68       PLA             pull BASIC execute pointer high byte
.,B455 C8       INY             increment index
.,B456 91 4E    STA ($4E),Y     save to function
.,B458 68       PLA             pull current variable address low byte
.,B459 C8       INY             increment index
.,B45A 91 4E    STA ($4E),Y     save to function
.,B45C 68       PLA             pull current variable address high byte
.,B45D C8       INY             increment index
.,B45E 91 4E    STA ($4E),Y     save to function
.,B460 68       PLA             pull ??
.,B461 C8       INY             increment index
.,B462 91 4E    STA ($4E),Y     save to function
.,B464 60       RTS             

                                *** perform STR$()
.,B465 20 8D AD JSR $AD8D       check if source is numeric, else do type mismatch
.,B468 A0 00    LDY #$00        set string index
.,B46A 20 DF BD JSR $BDDF       convert FAC1 to string
.,B46D 68       PLA             dump return address (skip type check)
.,B46E 68       PLA             dump return address (skip type check)
.,B46F A9 FF    LDA #$FF        set result string low pointer
.,B471 A0 00    LDY #$00        set result string high pointer
.,B473 F0 12    BEQ $B487print null terminated string to utility pointer

                                *** do string vector
                                copy descriptor pointer and make string space A bytes long
.,B475 A6 64    LDX $64         get descriptor pointer low byte
.,B477 A4 65    LDY $65         get descriptor pointer high byte
.,B479 86 50    STX $50         save descriptor pointer low byte
.,B47B 84 51    STY $51         save descriptor pointer high byte

                                *** make string space A bytes long
.,B47D 20 F4 B4 JSR $B4F4       make space in string memory for string A long
.,B480 86 62    STX $62         save string pointer low byte
.,B482 84 63    STY $63         save string pointer high byte
.,B484 85 61    STA $61         save length
.,B486 60       RTS

                                *** scan, set up string
                                print " terminated string to utility pointer
.,B487 A2 22    LDX #$22        set terminator to "
.,B489 86 07    STX $07         set search character, terminator 1
.,B48B 86 08    STX $08         set terminator 2
                                print search or alternate terminated string to utility pointer
                                source is AY
.,B48D 85 6F    STA $6F         store string start low byte
.,B48F 84 70    STY $70         store string start high byte
.,B491 85 62    STA $62         save string pointer low byte
.,B493 84 63    STY $63         save string pointer high byte
.,B495 A0 FF    LDY #$FF        set length to -1
.,B497 C8       INY             increment length
.,B498 B1 6F    LDA ($6F),Y     get byte from string
.,B49A F0 0C    BEQ $B4A8       exit loop if null byte [EOS]
.,B49C C5 07    CMP $07         compare with search character, terminator 1
.,B49E F0 04    BEQ $B4A4       branch if terminator
.,B4A0 C5 08    CMP $08         compare with terminator 2
.,B4A2 D0 F3    BNE $B497       loop if not terminator 2
.,B4A4 C9 22    CMP #$22        compare with "
.,B4A6 F0 01    BEQ $B4A9       branch if " (carry set if = !)
.,B4A8 18       CLC             clear carry for add (only if [EOL] terminated string)
.,B4A9 84 61    STY $61         save length in FAC1 exponent
.,B4AB 98       TYA             copy length to A
.,B4AC 65 6F    ADC $6F         add string start low byte
.,B4AE 85 71    STA $71         save string end low byte
.,B4B0 A6 70    LDX $70         get string start high byte
.,B4B2 90 01    BCC $B4B5       branch if no low byte overflow
.,B4B4 E8       INX             else increment high byte
.,B4B5 86 72    STX $72         save string end high byte
.,B4B7 A5 70    LDA $70         get string start high byte
.,B4B9 F0 04    BEQ $B4BF       branch if in utility area
.,B4BB C9 02    CMP #$02        compare with input buffer memory high byte
.,B4BD D0 0B    BNE $B4CA       branch if not in input buffer memory
                                string in input buffer or utility area, move to string
                                memory
.,B4BF 98       TYA             copy length to A
.,B4C0 20 75 B4 JSR $B475       copy descriptor pointer and make string space A bytes long
.,B4C3 A6 6F    LDX $6F         get string start low byte
.,B4C5 A4 70    LDY $70         get string start high byte
.,B4C7 20 88 B6 JSR $B688       store string A bytes long from XY to utility pointer
                                check for space on descriptor stack then ...
                                put string address and length on descriptor stack and update stack pointers
.,B4CA A6 16    LDX $16         get the descriptor stack pointer
.,B4CC E0 22    CPX #$22        compare it with the maximum + 1
.,B4CE D0 05    BNE $B4D5       if there is space on the string stack continue
                                else do string too complex error
.,B4D0 A2 19    LDX #$19        error $19, string too complex error
.,B4D2 4C 37 A4 JMP $A437       do error #X then warm start
                                put string address and length on descriptor stack and update stack pointers
.,B4D5 A5 61    LDA $61         get the string length
.,B4D7 95 00    STA $00,X       put it on the string stack
.,B4D9 A5 62    LDA $62         get the string pointer low byte
.,B4DB 95 01    STA $01,X       put it on the string stack
.,B4DD A5 63    LDA $63         get the string pointer high byte
.,B4DF 95 02    STA $02,X       put it on the string stack
.,B4E1 A0 00    LDY #$00        clear Y
.,B4E3 86 64    STX $64         save the string descriptor pointer low byte
.,B4E5 84 65    STY $65         save the string descriptor pointer high byte, always $00
.,B4E7 84 70    STY $70         clear FAC1 rounding byte
.,B4E9 88       DEY             Y = $FF
.,B4EA 84 0D    STY $0D         save the data type flag, $FF = string
.,B4EC 86 17    STX $17         save the current descriptor stack item pointer low byte
.,B4EE E8       INX             update the stack pointer
.,B4EF E8       INX             update the stack pointer
.,B4F0 E8       INX             update the stack pointer
.,B4F1 86 16    STX $16         save the new descriptor stack pointer
.,B4F3 60       RTS             

                                *** make space in string memory for string A long
                                return X = pointer low byte, Y = pointer high byte
.,B4F4 46 0F    LSR $0F         clear garbage collected flag (b7)
                                make space for string A long
.,B4F6 48       PHA             save string length
.,B4F7 49 FF    EOR #$FF        complement it
.,B4F9 38       SEC             set carry for subtract, two's complement add
.,B4FA 65 33    ADC $33         add bottom of string space low byte, subtract length
.,B4FC A4 34    LDY $34         get bottom of string space high byte
.,B4FE B0 01    BCS $B501       skip decrement if no underflow
