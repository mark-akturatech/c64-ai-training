# ML for C64 - Chapter 3: Flags, Logic, Status Register

specified address and performs the instructions given there until it
encounters a return from subroutine (RTS) command, at which time it resumes
execution of instructions at the calling point:  the instruction immediately
following JSR.

For example, if at address $033C I code the instruction JSR $1234, the 650x
will change its PC to $1234 and start to take instructions from that address.
Execution will continue until the instruction RTS is encountered.  At this
time, the microprocessor would switch back to the instruction following the
JSR, which in this case would be address $033F (the JSR instruction is three
bytes long).

As in BASIC, subroutines may be "nested;" that is, one subroutine may call
another, and that subroutine may call yet another.  We will deal with
subroutine mechanisms in more detail later.  For the moment, we'll concern
ourselves with calling prewritten subroutines.


Prewritten Subroutines
----------------------

A number of useful subroutines are permanently stored in the ROM memory of
the computer.  All Commodore machines have a standard set of subroutines that
may be called up by your programs.  They are always at the same addresses,
and perform in about the same way regardless of which Commodore machine is
used:  PET, CBM, Commodore 64, PLUS/4, or VIC-20.  These routines are called
the kernal subroutines.  Details on them can be found in the appropriate
Commodore reference manuals, but we'll give usage information here.

The original meaning of the term kernal seems to be lost in legend.  It was
originally an acronym, standing for something like "Keyboard Entry Read,
Network and Link."  Today, it's just the label we apply to the operating
system that makes screen, keyboard, other input/output and control mechanisms
work together.  To describe this central control system, we might choose to
correct the spelling so as to get the English word, "kernel."  For now, we'll
use Commodore's word.

                                                                         :25:

The three major kernal subroutines that we will deal with in the next few
chapters are shown here:

Address     Name       What it does
-------------------------------------------------
$FFD2       CHROUT     Output an ASCII character
$FFE4       GETIN      Gets an ASCII character
$FFE1       STOP       Checks the RUN/STOP key

With the first two subroutines, we can input and output data easily.  The
third allows us to honor the RUN/STOP key, to guard against certain types of
programming error.  In this chapter, we'll use CHROUT to print information to
the screen.


CHROUT--The Output Subroutine
-----------------------------

The CHROUT subroutine at address $FFD2 may be used for all types of output:
to screen, to disk, to cassette tape, or to other devices.  It's similar to
PRINT and PRINT#, except that it sends only one character.  For the moment,
we'll use CHROUT only for sending information to the computer screen.

*---------------------------------------------------------------------------*
|                                                                           |
| Subroutine:   CHROUT                                                      |
| Address:      $FFD2                                                       |
| Action:       Sends a copy of the character in the A register to the      |
|               output channel.  The output channel is the computer screen  |
|               unless arrangements have been made to switch it.            |
|                                                                           |
| The character sent is usually ASCII (or PET ASCII).  When sent to the     |
| screen, all special characters--graphics, color codes, cursor movements-- |
| will be honored in the usual way.                                         |
|                                                                           |
| Registers:  All data registers are preserved during a CHROUT call.  Upon  |
| return from the subroutine, A, X, and Y will not have changed.            |
|                                                                           |
| Status:  Status flags may be changed.  In the VIC and Commodore 64, the C |
| (carry) flag indicates some type of problem with output.                  |
|                                                                           |
*---------------------------------------------------------------------------*

To print a letter X on the screen, we would need to follow these steps:

  1.  Bring the ASCII letter X ($58) into the A register.

  2.  JSR to address $FFD2

                                                                         :26:

Why Not POKE?
-------------

It may seem that there's an easier way to make things appear on the screen.
We might POKE information directly to screen memory; in machine language, we
would call this a store rather than a POKE, of course.  The moment we change
something in this memory area, the information displayed on the screen will
change.  Screen memory is generally located at the following addresses:

  PET/CBM:       $8000 and up (decimal 32768)
  Commodore 64:  $0400 and up (decimal 1024)
  264/364:       $0C00 and up (decimal 3072)
  VIC-20:        $1E00 and up (decimal 7680)

The screen memory of the VIC-20 in particular may move around a good deal,
depending on how much additional RAM memory has been fitted.

Occasionally, screen POKEs are the best way to do the job.  But most of the
time we'll use the CHROUT, $FFD2 subroutine.  Here are some of the reasons
why:

 o As with PRINT, we don't need to worry about where to place the next
   character; it will be positioned automatically at the cursor point.

 o If the screen is filled, scrolling will take place automatically.

 o Screen memory needs special characters.  For example, the character X has
   a standard ASCII code of $58, but to POKE it to the screen we'd need to
   use the code $18.  The CHROUT subroutine uses $58.

 o Screen memory may move around, depending on the system and the program.
   The POKE address would need to change; but CHROUT keeps working.

 o Special control characters are honored:  $0D for RETURN, to start a new
   line; cursor movements; color changes.  We can even clear the screen by
   loading the screen-clear character ($93) and calling $FFD2.

 o To POKE the screen of the VIC or Commodore 64, the corresponding color
   nybble memory must also be POKEd (see the appropriate memory map in
   Appendix B).  With the subroutine at $FFD2, color is set automatically.


A Print Project
---------------

Let's write some code to print the letter H on the screen.  Once again, we'll
use address $033C, the cassette buffer, to hold our program.  Reminder:  be
sure to have your monitor loaded and ready before you start this project.

                                                                         :27:

First, the plan; we lay out the instructions

  LDA #$48

We're using a new symbol (#) to signal a special type of information.  It
goes by a variety of names:  pounds sign, sharp, hash mark, or numbers sign.
A more formal name for the symbol is octothorpe, meaning "eight points."
Whatever you call it, the symbol means "the following information is not an
address, it's a value."  In other words, we don't want the computer to go to
address $48, we want it to load the A register with the value $48, which
represents the ASCII letter H.  This type of information access is called
immediate addressing.  In other words, take information immediately, don't go
to memory for it.

  JSR $FFD2

The previous instruction brought the letter H into the A register; this one
prints it to the screen.  Now all we need to do is quite.  BRK takes us to
the machine language monitor.


Monitor Extensions
------------------

We could repeat the steps of the previous chapter:  hand-assembling the
source code into machine language, and then placing it into memory.  We would
need to know the instruction codes, and then do a careful translation.  But
there's an easier way.

Most machine language monitors contain extra commands to help us do this type
of mechanical translation.  We'll use the assembler feature of these
monitors.

Most monitors contain the assemble (.A) command.  The notable exception is
the built-in monitors with the PET/CBM; these, however, can be extended by
loading in a "monitor extension" program such as Supermon.  The Commodore
PLUS/4 series contains an extended monitor, which includes the .A command.

These assemblers are often called nonsymbolic assemblers.  This means that
whenever an address is needed, you must furnish that exact address.  You
cannot type in a name such as CHROUT and expect the tiny assembler to know
what address that represents; instead, you must type $FFD2.

Load your monitor or monitor extension.  Do any setup that may be needed.
Then type the following monitor command:

  .A 033C  LDA #$48

                                                                         :28:

We are asking the computer to assemble (.A) at address $033C (note we don't
use the $ here) the command LDA, Load A, the immediate value of $48, which
represents the ASCII letter H.  When you type RETURN after entering this
line, the computer may do either of two things:

  1.  It may do nothing except print a question mark somewhere on the line.
      The question mark indicates an error in your coding.  If the question
      mark appears directly after the letter A, your monitor does not
      understand the .A assemble instruction; get another monitor or properly
      set up the one you have.

  2.  Or, it will correctly translate your instruction, and put the object
      code into memory starting at the address specified.  In this case, that
      would happen to be $A9 at address $033C and $48 at address $033D.  It
      would then help you by printing part of the next expected instruction.
      The computer expects that you will type a line starting with

        .A 033E

It places the first part of this line on the screen to save you typing.  The
screen should now look like this:

  .A 033C  LDA #$48
  .A 033E

You may now complete the instruction by typing in JSR $FFD2 and pressing
RETURN.  Again, the computer will anticipate the next line by printing .A
0341, which allows you to type in the final command, BRK.  The screen now
looks like this:

  .A 033C  LDA #$48
  .A 033E  JSR $FFD2
  .A 0341  BRK
  .A 0342

The computer is still waiting for another instruction.  We have no more
instructions, so we press RETURN to signal that we're finished.

At this point, our program is stored in memory.  The instructions have been
assembled directly into place, and the object code is hopefully ready to go.

Note that this saves us the trouble of remembering--or looking up--the op
codes for each instruction.  And we don't need to keep track of how long each
instruction should be; the assembler does it for us.

If you like, you can display memory and look at the object program with the
.M 033C 0341.  You'll see the bytes of your program in memory:

  .:033C A9 48 20 D2 FF 00 xx xx

                                                                         :29:

The first six bytes are your program.  The last two bytes don't matter:  they
were whatever was in that part of memory before.  We don't care what is
there, since the program will stop when it reaches the BRK ($00) at address
$0341; it won't be concerned with the contents of memory at $0342 or $0343.


Checking:  The Disassembler
---------------------------

When we changed our source code into object code, we called this process of
translation assembly, and we called a program that did the job an assembler.

Now we're written a program and it's safely stored in memory.  We have
inspected memory and have seen the bytes there; but they are hard to read.
It would be convenient if we could perform an inverse assembly, that is, take
the contents of memory and translate it into source code.  The monitor has
this capability, called a disassembler.

If we ask the computer to disassemble the code starting at $033C, it will
examine the code there and establish that the contents ($A9) correspond to an
LDA immediate command.  It will then print for our information LDA #$48,
which is much more readable than the original two bytes, A9 48.

Give the command .D 033C and press RETURN.  D stands for disassemble, of
course, and the address must follow.

The computer will now show a full screen of code.  On the left is the address
followed by the bytes making up the instruction.  On the right is the
reconstructed source code.  The screen shows much more memory than our
program needs.  Again, we ignore all lines beyond address $0341, which is the
last instruction of our program.  Anything following is "junk" left in memory
that the program does not use.

An interesting feature of most disassembly listings is that the cursor is
left flashing on the last line of the disassembly rather than on the line
below.  When you have a large program, this allows you to type the letter D
followed by RETURN and the next part of your program will immediately be
displayed.  On the other hand, if you don't want to disassemble more code,
press the cursor down key and move to a "clean" line before typing your next
instruction.

A disassembly is a good way to check for errors.  If you find an error in the
listing, you may correct that line by re-assembling it, using the .A command
once again.  Minor errors may be corrected directly on the left-hand side of
the disassembly listing.  In other words, suppose that you had incorrectly
coded LDA #$58 during the assembly phase; when you perform the disassembly,
this line will show as

                                                                         :30:

  .,033C A9 58     LDA #$58

You recognize that the 58 should be 48; you may move the cursor up--use the
cursor home if you wish--and type over the value on the left-hand side.  In
this case, you place the cursor over the 5, type 4 to change the display to
48, and press RETURN.  You will see from the display that the problem has
been fixed.
