# 6502 Instructions by Type - Shift, Logical, Arithmetic, Comparison

           bit) and bit #6 of the operand are transferred to the respective
           bits of the status register, the Negative flag and the oVerflow
           flag. (Thus, these two bits can be easily used to store and set
           flags for conditional branches, see below.)
           The contents of the accumulator remains uneffected.
           BIT .... bit test (accumulator & memory)
           Conditional Branch Instructions
           Branch targets are relative, signed 8-bit address offsets.
           (An offset of zero corresponds to the immedately following address.
           While it is perfectly feasible to calculate offsets by hand, more
           often these are computed by an assembler program from absoulte
           addresses or labels. In the latter case, branch instructions may
           look more like absolute address mode instructions, while taking in
           actuality just a relative offset as a single-byte operand.)
           BCC .... branch on carry clear
           BCS .... branch on carry set
           BEQ .... branch on equal                (zero flag set)
           BMI .... branch on minus                (negative flag set)
           BNE .... branch on not equal            (zero flag clear)
           BPL .... branch on plus                 (negative flag clear)
           BVC .... branch on overflow clear
           BVS .... branch on overflow set
           Jumps & Subroutines
           JSR and RTS affect the stack as the return address is pushed onto or
           pulled from the stack, respectively.
           (JSR will first push the high-byte of the return address [PC+2] onto
           the stack, then the low-byte. The stack will then contain, seen from
           the bottom or from the most recently added byte, [PC+2]-L [PC+2]-H.)
           JMP .... jump
           JSR .... jump subroutine
           RTS .... return from subroutine
           Interrupts
           A hardware interrupt (maskable IRQ and non-maskable NMI), will cause
           the processor to put first the address currently in the program
           counter onto the stack (in HB-LB order), followed by the value of
                                                                6502 Instruction Set
            the status register. (The stack will now contain, seen from the
            bottom or from the most recently added byte, SR PC-L PC-H with the
            stack pointer pointing to the address below the stored contents of
            status register.) Then, the processor will divert its control flow
            to the address provided in the two word-size interrupt vectors at
            $FFFA (IRQ) and $FFFE (NMI).
            A set interrupt disable flag will inhibit the execution of an IRQ,
            but not of a NMI, which will be executed anyways.
            The break instruction (BRK) behaves like a NMI, but will push the
            value of PC+2 onto the stack to be used as the return address. Also,
            as with any software initiated transfer of the status register to
            the stack, the break flag will be found set on the respective value
            pushed onto the stack. Then, control is transferred to the address
            in the NMI-vector at $FFFE.
            In any way, the interrupt disable flag is set to inhibit any further
            IRQ as control is transferred to the interrupt handler specified by
            the respective interrupt vector.
            The RTI instruction restores the status register from the stack and
            behaves otherwise like the JSR instruction. (The break flag is
            always ignored as the status is read from the stack, as it isn't a
            real processor flag anyway.)
            BRK .... break / software interrupt
            RTI .... return from interrupt
            See the section Jump Vectors and Stack Operations below for
            operational details.
            Other
            NOP .... no operation
          6502 Address Modes in Detail
          (This section, especially the diagrams included, is heavily inspired
          by the Acorn Atom manual "Atomic Theory and Practice" by David
          Johnson Davies, Acorn Computers Limited, 2nd ed. 1980, p 118â€“121.)
            Implied Addressing
            These instructions act directly on one or more registers or flags
            internal to the CPU. Therefor, these instructions are principally
            single-byte instructions, lacking an explicit operand. The operand
            is implied, as it is already provided by the very instruction.
            Instructions targeting exclusively the contents of the accumulator
            may or may not be denoted by using an explicit "A" as the operand,
            depending on the flavor of syntax. (This may be regarded as a
            special address mode of its own, but it is really a special case of
            an implied instruction. It is still a single-byte instruction and no
            operand is provided in machine language.)
                                                                      6502 Instruction Set
           Mnemonic Examples:
           CLC ......... clear the carry flag
           ROL A ....... rotate contents of accumulator left by one position
           ROL ......... same as above, implicit notation (A implied)
           TXA ......... transfer contents of X-register to the accumulator
           PHA ......... push the contents of the accumulator to the stack
           RTS ......... return from subroutine (by pulling PC from stack)
           Mind that some of these instructions, while simple in appearance,
           may be quite complex operations, like "PHA", which involves the
           accumulator, the stack pointer and memory access.
           Immediate Addressing
           Here, a literal operand is given immediately after the instruction.
           The operand is always an 8-bit value and the total instruction
           length is always 2 bytes. In memory, the operand is a single byte
           following immediately after the instruction code. In assembler, the
           mode is usually indicated by a "#" prefix adjacent to the operand.
            Mnemonic    Instruction
            LDA #7        A9 07
                          A: 07
