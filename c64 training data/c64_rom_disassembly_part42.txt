# C64 KERNAL ROM Disassembly $FA00-$FCFF - I/O Control

.,FA00 C6 A3    DEC $A3         decrement EOI flag byte
.,FA02 30 C5    BMI $F9C9       
.,FA04 46 D7    LSR $D7         
.,FA06 66 BF    ROR $BF         parity count
.,FA08 A2 DA    LDX #$DA        set timimg max byte
.,FA0A 20 E2 F8 JSR $F8E2       set timing
.,FA0D 4C BC FE JMP $FEBC       restore registers and exit interrupt
.,FA10 A5 96    LDA $96         get cassette block synchronization number
.,FA12 F0 04    BEQ $FA18       
.,FA14 A5 B4    LDA $B4         
.,FA16 F0 07    BEQ $FA1F       
.,FA18 A5 A3    LDA $A3         get EOI flag byte
.,FA1A 30 03    BMI $FA1F       
.,FA1C 4C 97 F9 JMP $F997       
.,FA1F 46 B1    LSR $B1         shift tape timing constant max byte
.,FA21 A9 93    LDA #$93        
.,FA23 38       SEC             
.,FA24 E5 B1    SBC $B1         subtract tape timing constant max byte
.,FA26 65 B0    ADC $B0         add tape timing constant min byte
.,FA28 0A       ASL             
.,FA29 AA       TAX             copy timimg high byte
.,FA2A 20 E2 F8 JSR $F8E2       set timing
.,FA2D E6 9C    INC $9C         
.,FA2F A5 B4    LDA $B4         
.,FA31 D0 11    BNE $FA44       
.,FA33 A5 96    LDA $96         get cassette block synchronization number
.,FA35 F0 26    BEQ $FA5D       
.,FA37 85 A8    STA $A8         save receiver bit count in
.,FA39 A9 00    LDA #$00        clear A
.,FA3B 85 96    STA $96         clear cassette block synchronization number
.,FA3D A9 81    LDA #$81        enable timer A interrupt
.,FA3F 8D 0D DC STA $DC0D       save VIA 1 ICR
.,FA42 85 B4    STA $B4         
.,FA44 A5 96    LDA $96         get cassette block synchronization number
.,FA46 85 B5    STA $B5         
.,FA48 F0 09    BEQ $FA53       
.,FA4A A9 00    LDA #$00        
.,FA4C 85 B4    STA $B4         
.,FA4E A9 01    LDA #$01        disable timer A interrupt
.,FA50 8D 0D DC STA $DC0D       save VIA 1 ICR
.,FA53 A5 BF    LDA $BF         parity count
.,FA55 85 BD    STA $BD         save RS232 parity byte
.,FA57 A5 A8    LDA $A8         get receiver bit count in
.,FA59 05 A9    ORA $A9         OR with start bit check flag
.,FA5B 85 B6    STA $B6         
.,FA5D 4C BC FE JMP $FEBC       restore registers and exit interrupt

                                *** # store character
.,FA60 20 97 FB JSR $FB97       new tape byte setup
.,FA63 85 9C    STA $9C         clear byte received flag
.,FA65 A2 DA    LDX #$DA        set timimg max byte
.,FA67 20 E2 F8 JSR $F8E2       set timing
.,FA6A A5 BE    LDA $BE         get copies count
.,FA6C F0 02    BEQ $FA70       
.,FA6E 85 A7    STA $A7         save receiver input bit temporary storage
.,FA70 A9 0F    LDA #$0F        
.,FA72 24 AA    BIT $AA         
.,FA74 10 17    BPL $FA8D       
.,FA76 A5 B5    LDA $B5         
.,FA78 D0 0C    BNE $FA86       
.,FA7A A6 BE    LDX $BE         get copies count
.,FA7C CA       DEX             
.,FA7D D0 0B    BNE $FA8A       if ?? restore registers and exit interrupt
.,FA7F A9 08    LDA #$08        set short block
.,FA81 20 1C FE JSR $FE1C       OR into serial status byte
.,FA84 D0 04    BNE $FA8A       restore registers and exit interrupt, branch always
.,FA86 A9 00    LDA #$00        
.,FA88 85 AA    STA $AA         
.,FA8A 4C BC FE JMP $FEBC       restore registers and exit interrupt
.,FA8D 70 31    BVS $FAC0       
.,FA8F D0 18    BNE $FAA9       
.,FA91 A5 B5    LDA $B5         
.,FA93 D0 F5    BNE $FA8A       
.,FA95 A5 B6    LDA $B6         
.,FA97 D0 F1    BNE $FA8A       
.,FA99 A5 A7    LDA $A7         get receiver input bit temporary storage
.,FA9B 4A       LSR             
.,FA9C A5 BD    LDA $BD         get RS232 parity byte
.,FA9E 30 03    BMI $FAA3       
.,FAA0 90 18    BCC $FABA       
.,FAA2 18       CLC             
.,FAA3 B0 15    BCS $FABA       
.,FAA5 29 0F    AND #$0F        
.,FAA7 85 AA    STA $AA         
.,FAA9 C6 AA    DEC $AA         
.,FAAB D0 DD    BNE $FA8A       
.,FAAD A9 40    LDA #$40        
.,FAAF 85 AA    STA $AA         
.,FAB1 20 8E FB JSR $FB8E       copy I/O start address to buffer address
.,FAB4 A9 00    LDA #$00        
.,FAB6 85 AB    STA $AB         
.,FAB8 F0 D0    BEQ $FA8A       
.,FABA A9 80    LDA #$80        
.,FABC 85 AA    STA $AA         
.,FABE D0 CA    BNE $FA8A       restore registers and exit interrupt, branch always
.,FAC0 A5 B5    LDA $B5         
.,FAC2 F0 0A    BEQ $FACE       
.,FAC4 A9 04    LDA #$04        
.,FAC6 20 1C FE JSR $FE1C       OR into serial status byte
.,FAC9 A9 00    LDA #$00        
.,FACB 4C 4A FB JMP $FB4A       
.,FACE 20 D1 FC JSR $FCD1       check read/write pointer, return Cb = 1 if pointer >= end
.,FAD1 90 03    BCC $FAD6       
.,FAD3 4C 48 FB JMP $FB48       
.,FAD6 A6 A7    LDX $A7         get receiver input bit temporary storage
.,FAD8 CA       DEX             
.,FAD9 F0 2D    BEQ $FB08       
.,FADB A5 93    LDA $93         get load/verify flag
.,FADD F0 0C    BEQ $FAEB       if load go ??
.,FADF A0 00    LDY #$00        clear index
.,FAE1 A5 BD    LDA $BD         get RS232 parity byte
.,FAE3 D1 AC    CMP ($AC),Y     
.,FAE5 F0 04    BEQ $FAEB       
.,FAE7 A9 01    LDA #$01        
.,FAE9 85 B6    STA $B6         
.,FAEB A5 B6    LDA $B6         
.,FAED F0 4B    BEQ $FB3A       
.,FAEF A2 3D    LDX #$3D        
.,FAF1 E4 9E    CPX $9E         
.,FAF3 90 3E    BCC $FB33       
.,FAF5 A6 9E    LDX $9E         
.,FAF7 A5 AD    LDA $AD         
.,FAF9 9D 01 01 STA $0101,X     
.,FAFC A5 AC    LDA $AC         
.,FAFE 9D 00 01 STA $0100,X     
.,FB01 E8       INX             
.,FB02 E8       INX             
.,FB03 86 9E    STX $9E         
.,FB05 4C 3A FB JMP $FB3A       
.,FB08 A6 9F    LDX $9F         
.,FB0A E4 9E    CPX $9E         
.,FB0C F0 35    BEQ $FB43       
.,FB0E A5 AC    LDA $AC         
.,FB10 DD 00 01 CMP $0100,X     
.,FB13 D0 2E    BNE $FB43       
.,FB15 A5 AD    LDA $AD         
.,FB17 DD 01 01 CMP $0101,X     
.,FB1A D0 27    BNE $FB43       
.,FB1C E6 9F    INC $9F         
.,FB1E E6 9F    INC $9F         
.,FB20 A5 93    LDA $93         get load/verify flag
.,FB22 F0 0B    BEQ $FB2F       if load ??
.,FB24 A5 BD    LDA $BD         get RS232 parity byte
.,FB26 A0 00    LDY #$00        
.,FB28 D1 AC    CMP ($AC),Y     
.,FB2A F0 17    BEQ $FB43       
.,FB2C C8       INY             
.,FB2D 84 B6    STY $B6         
.,FB2F A5 B6    LDA $B6         
.,FB31 F0 07    BEQ $FB3A       
.,FB33 A9 10    LDA #$10        
.,FB35 20 1C FE JSR $FE1C       OR into serial status byte
.,FB38 D0 09    BNE $FB43       
.,FB3A A5 93    LDA $93         get load/verify flag
.,FB3C D0 05    BNE $FB43       if verify go ??
.,FB3E A8       TAY             
.,FB3F A5 BD    LDA $BD         get RS232 parity byte
.,FB41 91 AC    STA ($AC),Y     
.,FB43 20 DB FC JSR $FCDB       increment read/write pointer
.,FB46 D0 43    BNE $FB8B       restore registers and exit interrupt, branch always
.,FB48 A9 80    LDA #$80        
.,FB4A 85 AA    STA $AA         
.,FB4C 78       SEI             
.,FB4D A2 01    LDX #$01        disable timer A interrupt
.,FB4F 8E 0D DC STX $DC0D       save VIA 1 ICR
.,FB52 AE 0D DC LDX $DC0D       read VIA 1 ICR
.,FB55 A6 BE    LDX $BE         get copies count
.,FB57 CA       DEX             
.,FB58 30 02    BMI $FB5C       
.,FB5A 86 BE    STX $BE         save copies count
.,FB5C C6 A7    DEC $A7         decrement receiver input bit temporary storage
.,FB5E F0 08    BEQ $FB68       
.,FB60 A5 9E    LDA $9E         
.,FB62 D0 27    BNE $FB8B       if ?? restore registers and exit interrupt
.,FB64 85 BE    STA $BE         save copies count
.,FB66 F0 23    BEQ $FB8B       restore registers and exit interrupt, branch always
.,FB68 20 93 FC JSR $FC93       restore everything for STOP
.,FB6B 20 8E FB JSR $FB8E       copy I/O start address to buffer address
.,FB6E A0 00    LDY #$00        clear index
.,FB70 84 AB    STY $AB         clear checksum
.,FB72 B1 AC    LDA ($AC),Y     get byte from buffer
.,FB74 45 AB    EOR $AB         XOR with checksum
.,FB76 85 AB    STA $AB         save new checksum
.,FB78 20 DB FC JSR $FCDB       increment read/write pointer
.,FB7B 20 D1 FC JSR $FCD1       check read/write pointer, return Cb = 1 if pointer >= end
.,FB7E 90 F2    BCC $FB72       loop if not at end
.,FB80 A5 AB    LDA $AB         get computed checksum
.,FB82 45 BD    EOR $BD         compare with stored checksum ??
.,FB84 F0 05    BEQ $FB8B       if checksum ok restore registers and exit interrupt
.,FB86 A9 20    LDA #$20        else set checksum error
.,FB88 20 1C FE JSR $FE1C       OR into the serial status byte
.,FB8B 4C BC FE JMP $FEBC       restore registers and exit interrupt

                                *** copy I/O start address to buffer address
.,FB8E A5 C2    LDA $C2         get I/O start address high byte
.,FB90 85 AD    STA $AD         set buffer address high byte
.,FB92 A5 C1    LDA $C1         get I/O start address low byte
.,FB94 85 AC    STA $AC         set buffer address low byte
.,FB96 60       RTS             

                                *** new tape byte setup
.,FB97 A9 08    LDA #$08        eight bits to do
.,FB99 85 A3    STA $A3         set bit count
.,FB9B A9 00    LDA #$00        clear A
.,FB9D 85 A4    STA $A4         clear tape bit cycle phase
.,FB9F 85 A8    STA $A8         clear start bit first cycle done flag
.,FBA1 85 9B    STA $9B         clear byte parity
.,FBA3 85 A9    STA $A9         clear start bit check flag, set no start bit yet
.,FBA5 60       RTS             

                                *** send lsb from tape write byte to tape
                                this routine tests the least significant bit in the tape write byte and sets VIA 2 T2
                                depending on the state of the bit. if the bit is a 1 a time of $00B0 cycles is set, if
                                the bot is a 0 a time of $0060 cycles is set. note that this routine does not shift the
                                bits of the tape write byte but uses a copy of that byte, the byte itself is shifted
                                elsewhere
.,FBA6 A5 BD    LDA $BD         get tape write byte
.,FBA8 4A       LSR             shift lsb into Cb
.,FBA9 A9 60    LDA #$60        set time constant low byte for bit = 0
.,FBAB 90 02    BCC $FBAF       branch if bit was 0
                                set time constant for bit = 1 and toggle tape
.,FBAD A9 B0    LDA #$B0        set time constant low byte for bit = 1
                                write time constant and toggle tape
.,FBAF A2 00    LDX #$00        set time constant high byte
                                write time constant and toggle tape
.,FBB1 8D 06 DC STA $DC06       save VIA 1 timer B low byte
.,FBB4 8E 07 DC STX $DC07       save VIA 1 timer B high byte
.,FBB7 AD 0D DC LDA $DC0D       read VIA 1 ICR
.,FBBA A9 19    LDA #$19        load timer B, timer B single shot, start timer B
.,FBBC 8D 0F DC STA $DC0F       save VIA 1 CRB
.,FBBF A5 01    LDA $01         read the 6510 I/O port
.,FBC1 49 08    EOR #$08        toggle tape out bit
.,FBC3 85 01    STA $01         save the 6510 I/O port
.,FBC5 29 08    AND #$08        mask tape out bit
.,FBC7 60       RTS

                                *** flag block done and exit interrupt
.,FBC8 38       SEC             set carry flag
.,FBC9 66 B6    ROR $B6         set buffer address high byte negative, flag all sync,
                                data and checksum bytes written
.,FBCB 30 3C    BMI $FC09       restore registers and exit interrupt, branch always

                                *** tape write IRQ routine
                                this is the routine that writes the bits to the tape. it is called each time VIA 2 T2
                                times out and checks if the start bit is done, if so checks if the data bits are done,
                                if so it checks if the byte is done, if so it checks if the synchronisation bytes are
                                done, if so it checks if the data bytes are done, if so it checks if the checksum byte
                                is done, if so it checks if both the load and verify copies have been done, if so it
                                stops the tape
.,FBCD A5 A8    LDA $A8         get start bit first cycle done flag
.,FBCF D0 12    BNE $FBE3       if first cycle done go do rest of byte
                                each byte sent starts with two half cycles of $0110 ststem clocks and the whole block
                                ends with two more such half cycles
.,FBD1 A9 10    LDA #$10        set first start cycle time constant low byte
.,FBD3 A2 01    LDX #$01        set first start cycle time constant high byte
.,FBD5 20 B1 FB JSR $FBB1       write time constant and toggle tape
.,FBD8 D0 2F    BNE $FC09       if first half cycle go restore registers and exit
                                interrupt
.,FBDA E6 A8    INC $A8         set start bit first start cycle done flag
.,FBDC A5 B6    LDA $B6         get buffer address high byte
.,FBDE 10 29    BPL $FC09       if block not complete go restore registers and exit
                                interrupt. the end of a block is indicated by the tape
                                buffer high byte b7 being set to 1
.,FBE0 4C 57 FC JMP $FC57       else do tape routine, block complete exit
                                continue tape byte write. the first start cycle, both half cycles of it, is complete
                                so the routine drops straight through to here
.,FBE3 A5 A9    LDA $A9         get start bit check flag
.,FBE5 D0 09    BNE $FBF0       if the start bit is complete go send the byte bits
                                after the two half cycles of $0110 ststem clocks the start bit is completed with two
                                half cycles of $00B0 system clocks. this is the same as the first part of a 1 bit
.,FBE7 20 AD FB JSR $FBAD       set time constant for bit = 1 and toggle tape
.,FBEA D0 1D    BNE $FC09       if first half cycle go restore registers and exit
                                interrupt
.,FBEC E6 A9    INC $A9         set start bit check flag
.,FBEE D0 19    BNE $FC09       restore registers and exit interrupt, branch always
                                continue tape byte write. the start bit, both cycles of it, is complete so the routine
                                drops straight through to here. now the cycle pairs for each bit, and the parity bit,
                                are sent
.,FBF0 20 A6 FB JSR $FBA6       send lsb from tape write byte to tape
.,FBF3 D0 14    BNE $FC09       if first half cycle go restore registers and exit
                                interrupt
                                else two half cycles have been done
.,FBF5 A5 A4    LDA $A4         get tape bit cycle phase
.,FBF7 49 01    EOR #$01        toggle b0
.,FBF9 85 A4    STA $A4         save tape bit cycle phase
.,FBFB F0 0F    BEQ $FC0C       if bit cycle phase complete go setup for next bit
                                each bit is written as two full cycles. a 1 is sent as a full cycle of $0160 system
                                clocks then a full cycle of $00C0 system clocks. a 0 is sent as a full cycle of $00C0
                                system clocks then a full cycle of $0160 system clocks. to do this each bit from the
                                write byte is inverted during the second bit cycle phase. as the bit is inverted it
                                is also added to the, one bit, parity count for this byte
.,FBFD A5 BD    LDA $BD         get tape write byte
.,FBFF 49 01    EOR #$01        invert bit being sent
.,FC01 85 BD    STA $BD         save tape write byte
.,FC03 29 01    AND #$01        mask b0
.,FC05 45 9B    EOR $9B         EOR with tape write byte parity bit
