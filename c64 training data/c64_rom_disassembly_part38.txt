# C64 KERNAL ROM Disassembly $F500-$F5FF - Tape Write

.,F4B2 C9 03    CMP #$03        
.,F4B4 F0 F9    BEQ $F4AF       
.,F4B6 90 7B    BCC $F533       
.,F4B8 A4 B7    LDY $B7         get file name length
.,F4BA D0 03    BNE $F4BF       if not null name go ??
.,F4BC 4C 10 F7 JMP $F710       else do 'missing file name' error and return
.,F4BF A6 B9    LDX $B9         get the secondary address
.,F4C1 20 AF F5 JSR $F5AF       print "Searching..."
.,F4C4 A9 60    LDA #$60        
.,F4C6 85 B9    STA $B9         save the secondary address
.,F4C8 20 D5 F3 JSR $F3D5       send secondary address and filename
.,F4CB A5 BA    LDA $BA         get the device number
.,F4CD 20 09 ED JSR $ED09       command serial bus device to TALK
.,F4D0 A5 B9    LDA $B9         get the secondary address
.,F4D2 20 C7 ED JSR $EDC7       send secondary address after TALK
.,F4D5 20 13 EE JSR $EE13       input byte from serial bus
.,F4D8 85 AE    STA $AE         save program start address low byte
.,F4DA A5 90    LDA $90         get the serial status byte
.,F4DC 4A       LSR             shift time out read ..
.,F4DD 4A       LSR             .. into carry bit
.,F4DE B0 50    BCS $F530       if timed out go do file not found error and return
.,F4E0 20 13 EE JSR $EE13       input byte from serial bus
.,F4E3 85 AF    STA $AF         save program start address high byte
.,F4E5 8A       TXA             copy secondary address
.,F4E6 D0 08    BNE $F4F0       load location not set in LOAD call, so continue with the
                                load
.,F4E8 A5 C3    LDA $C3         get the load address low byte
.,F4EA 85 AE    STA $AE         save the program start address low byte
.,F4EC A5 C4    LDA $C4         get the load address high byte
.,F4EE 85 AF    STA $AF         save the program start address high byte
.,F4F0 20 D2 F5 JSR $F5D2       
.,F4F3 A9 FD    LDA #$FD        mask xxxx xx0x, clear time out read bit
.,F4F5 25 90    AND $90         mask the serial status byte
.,F4F7 85 90    STA $90         set the serial status byte
.,F4F9 20 E1 FF JSR $FFE1       scan stop key, return Zb = 1 = [STOP]
.,F4FC D0 03    BNE $F501       if not [STOP] go ??
.,F4FE 4C 33 F6 JMP $F633       else close the serial bus device and flag stop
.,F501 20 13 EE JSR $EE13       input byte from serial bus
.,F504 AA       TAX             copy byte
.,F505 A5 90    LDA $90         get the serial status byte
.,F507 4A       LSR             shift time out read ..
.,F508 4A       LSR             .. into carry bit
.,F509 B0 E8    BCS $F4F3       if timed out go try again
.,F50B 8A       TXA             copy received byte back
.,F50C A4 93    LDY $93         get load/verify flag
.,F50E F0 0C    BEQ $F51C       if load go load
                                else is verify
.,F510 A0 00    LDY #$00        clear index
.,F512 D1 AE    CMP ($AE),Y     compare byte with previously loaded byte
.,F514 F0 08    BEQ $F51E       if match go ??
.,F516 A9 10    LDA #$10        flag read error
.,F518 20 1C FE JSR $FE1C       OR into the serial status byte
.:F51B 2C       .BYTE $2C       makes next line BIT $AE91
.,F51C 91 AE    STA ($AE),Y     save byte to memory
.,F51E E6 AE    INC $AE         increment save pointer low byte
.,F520 D0 02    BNE $F524       if no rollover go ??
.,F522 E6 AF    INC $AF         else increment save pointer high byte
.,F524 24 90    BIT $90         test the serial status byte
.,F526 50 CB    BVC $F4F3       loop if not end of file
                                close file and exit
.,F528 20 EF ED JSR $EDEF       command serial bus to UNTALK
.,F52B 20 42 F6 JSR $F642       close serial bus device
.,F52E 90 79    BCC $F5A9       if ?? go flag ok and exit
.,F530 4C 04 F7 JMP $F704       do file not found error and return

                                *** ??
.,F533 4A       LSR             
.,F534 B0 03    BCS $F539       
.,F536 4C 13 F7 JMP $F713       else do 'illegal device number' and return
.,F539 20 D0 F7 JSR $F7D0       get tape buffer start pointer in XY
.,F53C B0 03    BCS $F541       if ??
.,F53E 4C 13 F7 JMP $F713       else do 'illegal device number' and return
.,F541 20 17 F8 JSR $F817       wait for PLAY
.,F544 B0 68    BCS $F5AE       exit if STOP was pressed
.,F546 20 AF F5 JSR $F5AF       print "Searching..."
.,F549 A5 B7    LDA $B7         get file name length
.,F54B F0 09    BEQ $F556       
.,F54D 20 EA F7 JSR $F7EA       find specific tape header
.,F550 90 0B    BCC $F55D       if no error continue
.,F552 F0 5A    BEQ $F5AE       exit if ??
.,F554 B0 DA    BCS $F530       , branch always
.,F556 20 2C F7 JSR $F72C       find tape header, exit with header in buffer
.,F559 F0 53    BEQ $F5AE       exit if ??
.,F55B B0 D3    BCS $F530       
.,F55D A5 90    LDA $90         get the serial status byte
.,F55F 29 10    AND #$10        mask 000x 0000, read error
.,F561 38       SEC             flag fail
.,F562 D0 4A    BNE $F5AE       if read error just exit
.,F564 E0 01    CPX #$01        
.,F566 F0 11    BEQ $F579       
.,F568 E0 03    CPX #$03        
.,F56A D0 DD    BNE $F549       
.,F56C A0 01    LDY #$01        
.,F56E B1 B2    LDA ($B2),Y     
.,F570 85 C3    STA $C3         
.,F572 C8       INY             
.,F573 B1 B2    LDA ($B2),Y     
.,F575 85 C4    STA $C4         
.,F577 B0 04    BCS $F57D       
.,F579 A5 B9    LDA $B9         get the secondary address
.,F57B D0 EF    BNE $F56C       
.,F57D A0 03    LDY #$03        
.,F57F B1 B2    LDA ($B2),Y     
.,F581 A0 01    LDY #$01        
.,F583 F1 B2    SBC ($B2),Y     
.,F585 AA       TAX             
.,F586 A0 04    LDY #$04        
.,F588 B1 B2    LDA ($B2),Y     
.,F58A A0 02    LDY #$02        
.,F58C F1 B2    SBC ($B2),Y     
.,F58E A8       TAY             
.,F58F 18       CLC             
.,F590 8A       TXA             
.,F591 65 C3    ADC $C3         
.,F593 85 AE    STA $AE         
.,F595 98       TYA             
.,F596 65 C4    ADC $C4         
.,F598 85 AF    STA $AF         
.,F59A A5 C3    LDA $C3         
.,F59C 85 C1    STA $C1         set I/O start addresses low byte
.,F59E A5 C4    LDA $C4         
.,F5A0 85 C2    STA $C2         set I/O start addresses high byte
.,F5A2 20 D2 F5 JSR $F5D2       display "LOADING" or "VERIFYING"
.,F5A5 20 4A F8 JSR $F84A       do the tape read
.:F5A8 24       .BYTE $24       makes next line BIT $18, keep the error flag in Cb
.,F5A9 18       CLC             flag ok
.,F5AA A6 AE    LDX $AE         get the LOAD end pointer low byte
.,F5AC A4 AF    LDY $AF         get the LOAD end pointer high byte
.,F5AE 60       RTS             

                                *** print "Searching..."
.,F5AF A5 9D    LDA $9D         get message mode flag
.,F5B1 10 1E    BPL $F5D1       exit if control messages off
.,F5B3 A0 0C    LDY #$0C        
                                index to "SEARCHING "
.,F5B5 20 2F F1 JSR $F12F       display kernel I/O message
.,F5B8 A5 B7    LDA $B7         get file name length
.,F5BA F0 15    BEQ $F5D1       exit if null name
.,F5BC A0 17    LDY #$17        
                                else index to "FOR "
.,F5BE 20 2F F1 JSR $F12F       display kernel I/O message

                                *** print file name
.,F5C1 A4 B7    LDY $B7         get file name length
.,F5C3 F0 0C    BEQ $F5D1       exit if null file name
.,F5C5 A0 00    LDY #$00        clear index
.,F5C7 B1 BB    LDA ($BB),Y     get file name byte
.,F5C9 20 D2 FF JSR $FFD2       output character to channel
.,F5CC C8       INY             increment index
.,F5CD C4 B7    CPY $B7         compare with file name length
.,F5CF D0 F6    BNE $F5C7       loop if more to do
.,F5D1 60       RTS             

                                *** display "LOADING" or "VERIFYING"
.,F5D2 A0 49    LDY #$49        
                                point to "LOADING"
.,F5D4 A5 93    LDA $93         get load/verify flag
.,F5D6 F0 02    BEQ $F5DA       branch if load
.,F5D8 A0 59    LDY #$59        
                                point to "VERIFYING"
.,F5DA 4C 2B F1 JMP $F12B       display kernel I/O message if in direct mode and return

                                *** save RAM to device, A = index to start address, XY = end address low/high
.,F5DD 86 AE    STX $AE         save end address low byte
.,F5DF 84 AF    STY $AF         save end address high byte
.,F5E1 AA       TAX             copy index to start pointer
.,F5E2 B5 00    LDA $00,X       get start address low byte
.,F5E4 85 C1    STA $C1         set I/O start addresses low byte
.,F5E6 B5 01    LDA $01,X       get start address high byte
.,F5E8 85 C2    STA $C2         set I/O start addresses high byte
.,F5EA 6C 32 03 JMP ($0332)     go save, usually points to $F685

                                *** save
.,F5ED A5 BA    LDA $BA         get the device number
.,F5EF D0 03    BNE $F5F4       if not keyboard go ??
                                else ..
.,F5F1 4C 13 F7 JMP $F713       else do 'illegal device number' and return
.,F5F4 C9 03    CMP #$03        compare device number with screen
.,F5F6 F0 F9    BEQ $F5F1       if screen do illegal device number and return
.,F5F8 90 5F    BCC $F659       branch if < screen
                                is greater than screen so is serial bus
.,F5FA A9 61    LDA #$61        set secondary address to $01
                                when a secondary address is to be sent to a device on
                                the serial bus the address must first be ORed with $60
.,F5FC 85 B9    STA $B9         save the secondary address
.,F5FE A4 B7    LDY $B7         get the file name length
