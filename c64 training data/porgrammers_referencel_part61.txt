# C64 PRG Chapter 6 - Input/Output Guide

  336   INPUT/OUTPUT GUIDE
~


  (replaces) the RETURN character that is normally PRINTed at the end of
  the line.
    The comma (,) separates items into columns. The Commodore 64 has 4
  columns of 10 characters each on the screen. When the computer PRINTs a
  comma, it moves the cursor right to the start of the next column. If it
  is past the last column of the line, it moves the cursor down to the next
  line. Like the semicolon, if it is the last item on a line the RETURN is
  suppressed.
    The quote marks ("") separate literal text from variables. The first
  quote mark on the line starts the literal area, and the next quote mark
  ends it. By the way, you don't have to have a final quote mark at the
  end of the line.
    The RETURN code (CHR$ code of 13) makes the cursor go to the next
  logical line on the screen. This is not always the very next line. When
  you type past the end of a line, that line is linked to the next line.
  The computer knows that both lines are really one long line. The links
  are held in the line link table (see the memory map for how this is set
  up).
    A logical line can be 1 or 2 screen lines long, depending on what was
  typed or PRINTed.  The logical line the cursor is on determines where the
  <RETURN> key sends it. The logical line at the top of the screen
  determines if the screen scrolls 1 or 2 lines at a time. There are other
  ways to use the TV as an output device. The chapter on graphics describes
  the commands to create objects that move across the screen. The VIC chip
  section tells how the screen and border colors and sizes are changed. And
  the sound chapter tells how the TV speaker creates music and special
  effects.

  OUTPUT TO OTHER DEVICES

    It is often necessary to send output to devices other than the screen,
  like a cassette deck, printer, disk drive, or modem. The OPEN statement
  in BASIC creates a "channel" to talk to one of these devices. Once the
  channel is OPEN, the PRINT# statement will send characters to that
  device.

  EXAMPLE of OPEN and PRINT# Statements:

    100 OPEN 4,4: PRINT# 4, "WRITING ON PRINTER"
    110 OPEN 3,8,3,"0:DISK-FILE,S,W":PRINT#3,"SEND TO DISK"
    120 OPEN 1,1,1,"TAPE-FILE": PRINT#1,"WRITE ON TAPE"
    130 OPEN 2,2,0,CHR$(10):PRINT#2,"SEND TO MODEM"

                                                   INPUT/OUTPUT GUIDE   337
~


    The OPEN statement is somewhat different for each device. The pa-
  rameters in the OPEN statement are shown in the table below for each
  device.

  TABLE of OPEN Statement Parameters:

    FORMAT: OPEN file#, device#, number, string

  +--------+---------+---------------------+------------------------------+
  | DEVICE | DEVICE# |       NUMBER        |            STRING            |
  +--------+---------+---------------------+------------------------------+
  |CASSETTE|    1    | 0 = Input           | File Name                    |
  |        |         | 1 = Output          |                              |
  |        |         | 2 = Output with EOT |                              |
  | MODEM  |    2    | 0                   | Control Registers            |
  | SCREEN |    3    | 0,1                 |                              |
  | PRINTER|  4 or 5 | 0 = Upper/Graphics  | Text Is PRINTed              |
  |        |         | 7 = Upper/Lower Case|                              |
  | DISK   | 8 to 11 | 2-14 = Data Channel | Drive #, File Name           |
  |        |         |                     | File Type, Read/Write        |
  |        |         | 15 = Command        | Command                      |
  |        |         |      Channel        |                              |
  +--------+---------+---------------------+------------------------------+

  OUTPUT TO PRINTER

    The printer is an output device similar to the screen. Your main con-
  cern when sending output to the printer is to create a format that is
  easy on the eyes. Your tools here include reversed, double-width, capital
  and lower case letters, as well as dot-programmable graphics.
    The SPC function works for the printer in the same way it works for the
  screen. However, the TAB function does not work correctly on the printer,
  because it calculates the current position on the line based on the
  cursor's position on the screen, not on the paper.
    The OPEN statement for the printer creates the channel for communi-
  cation. It also specifies which character set will be used, either upper
  case with graphics or upper and lower case.

  EXAMPLES of OPEN Statement for Printer:

    OPEN 1,4: REM UPPER CASE/GRAPHICS
    OPEN 1,4,7: REM UPPER AND LOWER CASE

  338   INPUT/OUTPUT GUIDE
~


    When working with one character set, individual lines can be PRINTed
  in the opposite character set. When in upper case with graphics, the
  cursor down character (CHR$(17)) switches the characters to the upper
  and lower case set. When in upper and lower case, the cursor up char-
  acter (CHR$(145)) allows upper case and graphics characters to be
  PRINTed.
    Other special functions in the printer are controlled through character
  codes. All these codes are simply PRINTed just like any other character.

  TABLE of Printer Control Character Codes:
  +----------+------------------------------------------------------------+
  | CHR$ CODE|                         PURPOSE                            |
  +----------+------------------------------------------------------------+
  |    10    |   Line feed                                                |
  |    13    |   RETURN (automatic line feed on CBM printers)             |
  |    14    |   Begin double-width character mode                        |
  |    15    |   End double-width character mode                          |
  |    18    |   Begin reverse character mode                             |
  |   146    |   End reverse character mode                               |
  |    17    |   Switch to upper/lower case character set                 |
  |   145    |   Switch to upper case/graphics character set              |
  |    16    |   Tab to position in next 2 characters                     |
  |    27    |   Move to specified dot position                           |
  |     8    |   Begin dot-programmable graphic mode                      |
  |    26    |   Repeat graphics data                                     |
  +----------+------------------------------------------------------------+
    See your Commodore printer's manual for details on using the command
  codes.

  OUTPUT TO MODEM

    The modem is a simple device that can translate character codes into
  audio pulses and vice-versa, so that computers can communicate over
  telephone lines. The OPEN statement for the modem sets up the parameters
  to match the speed and format of the other computer you are communicating
  with. Two characters can be sent in the string at the end
  of the OPEN statement.
    The bit positions of the first character code determine the baud rate,
  number of data bits, and number of stop bits. The second code is op-
  tional, and its bits specify the parity and duplex of the transmission.
  See the RS-232 section or your VICMODEM manual for specific details on
  this device.

                                                   INPUT/OUTPUT GUIDE   339
~


  EXAMPLE of OPEN Statement for Modem:

    OPEN 1,2,0,CHR$(6): REM 300 BAUD
    100 OPEN 2,2,0,CHR$(163) CHR$(112): REM 110 BAUD, ETC.

    Most computers use the American Standard Code for Information In-
  terchange, known as ASCII (pronounced ASK-KEY). This standard set of
  character codes is somewhat different from the codes used in the Com-
  modore 64. When communicating with other computers, the Commodore
  character codes must be translated into their ASCII counterparts. A table
  of standard ASCII codes is included in this book in Appendix C.
    Output to the modem is a fairly uncomplicated task, aside from the need
  for character translation. However, you must know the receiving device
  fairly well, especially when writing programs where your computer "talks"
  to another computer without human intervention. An example of this would
  be a terminal program that automatically types in your account number and
  secret password. To do this successfully, you must carefully count the
  number of characters and RETURN characters. Otherwise, the computer
  receiving the characters won't know what to do with them.

  WORKING WITH CASSETTE TAPE

    Cassette tapes have an almost unlimited capacity for data. The longer
  the tape, the more information it can store. However, tapes are limited
  in time. The more data on the tape, the longer the time it takes to find
  the information.
    The programmer must try to minimize the time factor when working with
  tape storage. One common practice is to read the entire cassette data
  file into RAM, then process it, and then re-write all the data on the
  tape. This allows you to sort, edit, and examine your data. However, this
  limits the size of your files to the amount of available RAM.
    If your data file is larger than the available RAM, it is probably time
  to switch to using the floppy disk. The disk can read data at any
  position on the disk, without needing to read through all the other data.
  You can write data over old data without disturbing the rest of the file.
  That's why the disk is used for all business applications like ledgers
  and mailing lists.
    The PRINT# statement formats data just like the PRINT statement does.
  All punctuation works the same. But remember, you're not working with the
  screen now. The formatting must be done with the INPUT# statement
  constantly in mind.


  340   INPUT/OUTPUT GUIDE
~


    Consider the statement PRINT# 1, A$, B$, C$. When used with the screen,
  the commas between the variables provide enough blank space between items
  to format them into columns ten characters wide. On cassette, anywhere
  from 1 to 10 spaces will be added, depending on th length of the strings.
  This wastes space on your tape.
    Even worse is what happens when the INPUT# statement tries to read
  these strings. The statement INPUT# 1, A$, B$, C$ will discover no data
  for B$ and C$. A$ will contain all three variables, plus the spaces be-
  tween them. What happens? Here's a look at the tape file:

    A$="DOG" B$="CAT" C$="TREE"
    PRINT# 1, A$, B$, C$

    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    D O G                 C  A  T                       T  R  E  E  RETURN

    The INPUT# statement works like the regular INPUT statement. When
  typing data into the INPUT statement, the data items are separated,
  either by hitting the <RETURN> key or using commas to separate them. The
  PRINT# statement puts a RETURN at the end of a line just like the PRINT
  statement. A$ fills up with all three values because there's no separator
  on the tape between them, only after all three.
    A proper separator would be a comma (,) or a RETURN on the tape. The
  RETURN code is automatically put at the end of a PRINT or PRINT#
  statement. One way to put the RETURN code between each item is to us only
  one item per PRINT# statement. A better way is to set a variable to the
  RETURN CHR$ code, which is CHR$(13), or use a comma. The statement for
  this is R$=",":PRINT#1, A$ R$ B$ R$ C$. Don't use commas or any other
  punctuation between the variable names, since the Commodore 64 can tell
  them apart and they'll only use up space in your program.
    A proper tape file looks like this:

    1 2 3 4 5 6 7 8 9 10 11 12 13

    D O G , C A T , T  R  E  E  RETURN

    The GET# statement will pick data from the tape one character at a
  time. It will receive each character, including the RETURN code and other
  punctuation. The CHR$(0) code is received as an empty string, not as a
  one character string with a code of 0. If you try to use the ASC function
  on an empty string, you get the error message ILLEGAL QUANTITY ERROR.


                                                   INPUT/OUTPUT GUIDE   341
~


    The line GET# 1, A$: A= ASC(A$) is commonly used in programs to examine
  tape data. To avoid error messages, the line should be modified to
  GET#1, A$: A=ASC(A$+CHR$(0)). The CHR$(0) at the end acts as insurance
  against empty strings, but doesn't affect the ASC function when there are
  other characters in A$.



  DATA STORAGE ON FLOPPY DISKETTES

    Diskettes allow 3 different forms of data storage. Sequential files are
  similar to those on tape, but several can can be used at the same time.
  Relative files let you organize the data into records, and then read and
  replace individual records within the file. Random files let you work
  with data anywhere on the disk. They are organized into 256 byte sections
  called blocks.
    The PRINT# statement's limitations are discussed in the section on
  cassette tape. The same limitations to format apply on the disk. RETURNs
  or commas are needed to separate your data. The CHR$(0) is still read by
  the GET# statement as an empty string.
    Relative and random files both make use of separate data and command
  "channels." Data written to the disk goes through the data channel, where
  it is stored in a temporary buffer in the disk's RAM. When the record or
  block is complete, a command is sent through the command channel that
  tells the drive where to put the data, and the entire buffer is written.
    Applications that require large amounts of data to be processed are
  best stored in relative disk files. These will use the least amount of
  time and provide the best flexibility for the programmer. Your disk drive
  manual gives a complete programming guide to use of disk files.














