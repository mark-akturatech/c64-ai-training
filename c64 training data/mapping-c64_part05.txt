# C64 Zero Page - BASIC Memory Pointers $2D-$38


The ability to chain short programs is a holdover from the days of the
8K PET, for which this BASIC was written, but with the vastly
increased memory of the 64, program chaining should not be necessary.

You should also note that SAVE uses this pointer as the address of the
byte after the last byte to SAVE.

47-48          $2F-$30       ARYTAB
Pointer to the Start of the BASIC Array Storage Area

This location points to the address of the end of nonarray variable
storage, and the beginning of array variable storage.  The format for
array storage is as follows:

The first two bytes hold the array name.  The format and high-bit
patterns are the same as for nonarray variables (see 45 ($2D) above),
except that there is no equivalent to the function definition.

Next comes a two-byte offset to the start of the next array, low byte
first.  Then there is a one-byte value for the number of array
dimensions (e.g., 2 for a two-dimensional array like A(x,y)).  That
byte is followed by pairs of bytes which hold the value of each array
dimension+1 (DIMensioning an array always makes space for 0, so A(0)
can be used).

Finally come the values of the variables themselves.  The format for
these values is the same as with nonarray values, but each value only
takes up the space required; that is, floating point variables use
five bytes each, integers two bytes, and string descriptors three
bytes each.

Remember that as with nonarray string, the actual string text is
stored elsewhere, in the area which starts at the location pointed to
in 51-52 ($33- $34).

49-50         $31-$32        STREND
Pointer to End of the BASIC Array Storage Area (+1), and the Start of
Free RAM

This location points to the address of the end of BASIC array storage
space and the start of free RAM.  Since string text starts at the top
of memory and builds downwards, this location can also be thought of
as the last possible address of the string storage area.  Defining new
variables pushes this pointer upward, toward the last string text.

If a string for which space is being allocated would cross over this
boundary into the array storage area, garbage collection is performed,
and if there still is not enough room, an OUT OF MEMORY error occurs.
FRE performs garbage collection, and returns the difference between
the addresses pointed to here and the address of the end of string
text storage pointed to by location 51 ($33).

51-52         $33-$34        FREETOP
Pointer to the Bottom of the String Text Storage Area

This pointer marks the current end of the string text area, and the
top of free RAM (strings are built from the top of memory downward).
Additional string texts are added, to the area below the address
pointed to here.  After they are added, this pointer is lowered to
point below the newly added string text.  The garbage collection
routine (which is also called by FRE) readjusts this pointer upward.

While the power-on/reset routines set this pointer to the top of RAM,
the CLR command sets this pointer to the end of BASIC memory, as
indicated in location 55 ($37).  This allows the user to set aside an
area of BASIC memory that will not be disturbed by the program, as
detailed at location 55 ($37).

53-54         $35-$36        FRESPC
Temporary Pointer for Strings

This is used as a temporary pointer to the most current string added
by the routines which build strings or move them in memory.

55-56         $37-$38        MEMSIZ
Pointer to the Highest Address Used by BASIC

The power-on/reset routine tests each byte of RAM until it comes to
the BASIC ROM, and sets this pointer to the adress of the highest byte
of consecutive RAM found (40959, $9FFF).

There are two circumstances under which this pointer may be changed
after power-up to reflect an address lower than the actual top of
consecutive RAM:

1.  Users may wish to lower this pointer themselves, in order to set
aside an area of free RAM that will not be disturbed by BASIC.  For
example, to set aside a 1K area at the top of BASIC, start your
program with the line:

POKE 56,PEEK(56)-4:CLR

The CLR is necessary to insure that the string text will start below
your safe area.

You may wish to store machine language programs, sprites, or alternate
character sets in such an area.  For the latter two applications,
however, keep in mind the 16K addressing range limitation of the
VIC-II chip.  If you do not assign the VIC-II to a bank other than the
default memory bank of 0-16383 ($0-$3FFF), you must lower the top of
memory below 16383 ($3FFF) if you wish your sprite or character data
area to be within its addressing range.

2.  Then the RS-232 device (number 2) is opened, this pointer and the
pointer to the end of user RAM at 643 are lowered by 512 bytes in
order to create two 256-byte buffers, one for input and the other for
output.

Since the contents of these buffers will overwrite any variables at
the top of memory, a CLR command is issued at the time device 2 is
opened.  Therefore, the RS-232 device should be opened before defining
any variables, and before setting aside a safe area for machine
language programs or other uses, as described above.

57-58         $39-$3A        CURLIN
Current BASIC Line Number

This location contains the line number of the BASIC statement which is
currently being executed, in LSB/MSB format.  A value of 255 ($FF) in
location 58 ($3A), which translates to a line number of 65280 or above
(well over the 63999 limit for a program line), means that BASIC is
currently in immediate mode, rather than RUN mode.

BASIC keywords that are illegal in direct mode check 58 ($3A) to
determine whether or not this is the current mode.

When in RUN mode, this location is updated as each new BASIC line is
fetched for execution.  Therefore, a TRACE function could be added by
diverting the vector at 776 ($308), which points to the routine that
executes the next token, to a user-written routine which prints the
line number indicated by this location before jumping to the token
execution routine.  (LISTing the line itself would be somewhat harder,
because LIST uses many Page 0 locations that would have to be
preserved and restored afterwards.)

This line number is used by BREAK and error messages to show where
program execution stopped.  The value here is copied to 59 ($3B) by
STOP, END, and the stop-key BREAK, and copied back by CONT.

59-60         $3B-$3C        OLDLIN
Previous BASIC Line Number

When program execution ends, the last line number executed is stored
here, and restored to location 57 ($39) by CONT.

61-62         $3D-$3E        OLDTXT
Pointer to the Address of the Current BASIC Statement

This location contains the address (not the line number) of the text
of the BASIC statement that is being executed.  The value of TXTPTR
(122, $7A), the pointer tot he address of the BASIC text character
currently being scanned, is stored here each time a new BASIC line
begins execution.

END, STOP, and the STOP-key BREAK save the value of TXTPTR here, and
CONT restores this value to TXTPTR.  CONT will not continue if 62
($3E) has been changed to a zero by a LOAD, a modification to the
program text, or by error routines.

63-64         $3F-$40        DATLIN
Current DATA Line Number

This location holds the line number of the current DATA statement
being READ.  It should be noted that this information is not used to
determine where the next DATA item is read from (that is the job of
the pointer at 65-66 ($41-$42) below).  But if an error concerning the
DATA occurs, this number will be moved to 57 ($39), so that the error
message will show that the error occurred in the line that contains
the DATA statement, rather than in the line that contains the READ
statement.

65-66         $41-$42        DATPTR
Pointer to the Address of the Current DATA Item

This location points to the address (not the line number) within the
BASIC program text area where DATA is currently being READ.  RESTORE
sets this pointer back to the address indicated by the start of BASIC
pointer at location 43 ($2B).

The sample program below shows how the order in which DATA statements
are READ can be changed using this pointer.  The current address of
the statement before the DATA statement is stored in a variable, and
then used to change this pointer.

10 A1=PEEK(61):A2=PEEK(62)
20 DATA THIS DATA WILL BE USED SECOND
30 B1=PEEK(61):B2=PEEK(62)
40 DATA THIS DATA WILL BE USED FIRST
50 C1=PEEK(61):C2=PEEK(62)
60 DATA THIS DATA WILL BE USED THIRD
70 POKE 65,B1:POKE 66,B2:READ A$:PRINT A$
80 POKE 65,A1:POKE 66,A2:READ A$:PRINT A$
90 POKE 65,C1:POKE 66,C2:READ A$:PRINT A$

67-68         $43-$44        INPPTR
Pointer in the Source of GET, READ, or INPUT Information

READ, INPUT and GET all use this as a pointer to the address of the
source of incoming data, such as DATA statements, or the text input
buffer at 512 ($200).

69-70         $45-$46        VARNAM
Current BASIC Variable Name

The current variable name being searched for is stored here, in the
same two- byte format as in the variable value storage area located at
the address pointed to by 45 ($2D).  See that location for an
explanation of the format.

71-72         $47-$48        VARPNT
Pointer to the Current BASIC Variable Value

This location points to the address of the descriptor of the current
BASIC variable (see location 45 ($2D) for the format of a variable
descriptor).  Specifically, it points to the byte just after the
two-character variable name.

During a FN call, this location does not point to the dependent
variable (the A of FN A), so that a real variable of the same name
will not have its value changed by the call.

73-74         $49-$4A        FORPNT
Temporary Pointer to the Index Variable Used by FOR

The address of the BASIC variable which is the subject of a FOR/NEXT
loop is first stored here, but is then pushed onto the stack.  That
leaves this location free to be used as a work area by such statements
as INPUT, GET, READ, LIST, WAIT, CLOSE, LOAD, SAVE, RETURN, and GOSUB.

For a description of the stack entries made by FOR, see location 256
($100).

75-76         $4B-$4C        OPPTR
Math Operator Table Displacement

This location is used during the evaluation of mathematical
expressions to hold the displacement of the current math operator in
an operator table.  It is also used as a save area for the pointer to
the address of program text which is currently being read.
