# ML for C64 - Appendix J: Disk User's Guide, DOS Commands

=======================


Concept
-------

The 6525 Tri-Port Interface (TPI) is designed to simplify the implementation
of complex I/O operations in microcomputer systems.  It combines two
dedicated 8-bit I/O ports with a third 8-bit port programmable for either
normal I/O operations or priority interrupt/handshaking control.  Depending
on the mode selected, the 6525 can provide 24 individually programmable I/O
lines or 16 I/O lines, 2 handshake lines and 5 priority interrupt inputs.


Register Map
------------

  +---+---+---+---+----+---------------------------------------------------+
  |RS2|RS1|RS0|REG|NAME| DESCRIPTION                                       |
  +---+---+---+---+----+---------------------------------------------------+
  | 0 | 0 | 0 |R0 |PRA | Port Register A                                   |
  | 0 | 0 | 1 |R1 |PRB | Port Register B                                   |
  | 0 | 1 | 0 |R2 |PRC | Port Register C                                   |
  | 0 | 1 | 1 |R3 |DDRA| Data Direction Register A                         |
  | 1 | 0 | 0 |R4 |DDRB| Data Direction Register B                         |
  | 1 | 0 | 1 |R5 |DDRC| Data Direction Register C/Interrupt Mask Register |
  | 1 | 1 | 0 |R6 |CR  | Control Register                                  |
  | 1 | 1 | 1 |R7 |AIR | Active Interrupt Register                         |
  +---+---+---+---+----+---------------------------------------------------+
                                                                          

                            6525 Control Registers

                       +-----+-----+-----+-----+-----+-----+-----+-----+
      CR               | CB1 | CB0 | CA1 | CA0 | IE4 | IE3 | IP  | MC  |
                       +-----+-----+-----+-----+-----+-----+-----+-----+
      AIR                                | A4  | A3  | A2  | A1  | A0  |
                                         +-----+-----+-----+-----+-----+
      DDRC (When MC=1)                   | M4  | M3  | M2  | M1  | M0  |
                       +-----+-----+-----+-----+-----+-----+-----+-----+
      PRC (When MC=1)  | CB  | CA  |/IRQ | I4  | I3  | I2  | I1  | I0  |
                       +-----+-----+-----+-----+-----+-----+-----+-----+



CA, CB Functional Description
-----------------------------

The CA, CB lines are outputs used in the same fashion as the CA2 and CB2
output of the 6520.

                                                                        :305:

                              CA Output Modes

CA1 CA0      MODE       DESCRIPTION
----------------------------------------------------------------------------
 0   0    "Handshake"   CA is set high on an active transition of the I3
            on Read     interrupt signal and set low by a microprocessor
                        "Read A Data" operation.  This allows positive
                        control of data transfers from the peripheral device
                        to the microprocessor.

 0   1   Pulse Output   CA goes low for 1ms after a "Read A Data" operation.
                        This pulse can be used to signal the peripheral
                        device that data was taken.

 1   0   Manual Output  CA set low.

 1   1   Manual Output  CA set high.


                              CB Output Modes

CB1 CB0      MODE       DESCRIPTION
----------------------------------------------------------------------------
 0   0    "Handshake"   CB is set low on microprocessor "Write B Data"
           on Write     operation and is set high by an active transition of
                        the I4 interrupt input signal.  This allows positive
                        control of data transfers from the microprocessor to
                        the peripheral device.

 0   1   Pulse Output   CB goes low for 1ms after a microprocessor "Write B
                        Data" operation.  This can be used to signal the
                        peripheral device that data is available.

 1   0   Manual Output  CB set low.

 1   1   Manual Output  CB set high.



Interrupt Mask Register Description
-----------------------------------

When the Interrupt Mode is selected (MC = 1), the Data Direction Register for
Port C (DDRC) is used to enable or disable a corresponding interrupt input.
For example:  If M0=0 then I0 is disabled and any I0 interrupt latched in the
interrupt latch register will not be transferred to the AIR and will not
cause IRQ to go low.  The interrupt latch can be cleared by writing a zero to
the appropriate I bit in PRC.

                                                                        :306:

Port Register C Description
---------------------------

Port Register C (PRC) can operate in two modes.  The mode is controlled by
bit MC in register CR.  When MC=0, PRC is a standard I/O port, operating
identically to PRA & PRB.  If MC=1, then port register C is used for
handshaking and priority interrupt input and output.


                               PRC When MC = 0

              +-----+-----+-----+-----+-----+-----+-----+-----+
              | PC7 | PC6 | PC5 | PC4 | PC3 | PC2 | PC1 | PC0 |
              +-----+-----+-----+-----+-----+-----+-----+-----+


                               PRC When MC = 1

              +-----+-----+-----+-----+-----+-----+-----+-----+
              | CB  | CA  |/IRQ | I4  | I3  | I2  | I1  | I0  |
              +-----+-----+-----+-----+-----+-----+-----+-----+


Interrupt Edge Control
----------------------

Bits IE4 and IE3 in the control register (CR) are used to determine the
active edge which will be recognized by the interrupt latch.

If IE4 (IE3) = 0 then I4 (I3) latch will be set on a negative transition of
I4 (I3) input.

If IE4 (IE3) = 1 then I4 (I3) latch will be set on a positive transition of
I4 (I3) input.

All other interrupt latches (I2, I1, I0) are set on a negative transition of
the corresponding interrupt input.

                          Interrupt Latch Register
                          ------------------------
            +----+----+----+----+----+  Clears on Read of AIR Using12345678901234567890
            | I4 | I3 | I2 | I1 | I0 |  Following Equation
            +----+----+----+----+----+  
                                        ILR <- ILR xor AIR


                          Active Interrupt Register
                          -------------------------
            +----+----+----+----+----+  
            | A4 | A3 | A2 | A1 | A0 |  Clears on Write to AIR
            +----+----+----+----+----+  


                          Interrupt Priority Select
                          -------------------------
                           +----+       IP = 0  No Priority
                           | IP |
                           +----+       IP = 1  Interrupts Prioritized

                                                                        :307:

Functional Description
----------------------

1.  IP = 0  No Priority

All interrupt information latched into interrupt latch register (ILR) is
immediately transferred into active interrupt register (AIR) and /IRQ is
pulled low.  Upon read of interrupt the /IRQ is reset high and the
appropriate bit(s) of the interrupt latch register is cleared by exclusive
OR-ing the ILR with AIR (ILR xor AIR).  After the appropriate interrupt
request has been serviced a Write to the AIR will clear it and initiate a new
interrupt sequence if any interrupts were received during previous interrupt
servicing.  In this non-prioritized mode it is possible for two or more
interrupts to occur simultaneously and be transferred to the AIR.  If this
occurs it is a software effort to recognize this and act accordingly.


2.  IP = 1  Interrupts Prioritized

In this mode the Interrupt Inputs are prioritized in the following order:

  I4 > I3 > I2 > I1 > I0

In this mode only one bit of the AIR can be set at any one time.  If an
interrupt occurs it is latched into the interrupt latch register, the /IRQ
line is pulled low and the appropriate bit of the AIR is set.  To understand
fully the operation of the priority interrupts it is easiest to consider the
following examples.

A.  The first case is the simplest.  A single interrupt occurs and the
    processor can service it completely before another interrupt request is
    received.

    1.  Interrupt I1 is received.
    2.  Bit I1 is set high in Interrupt Latch Register.
    3.  /IRQ is pulled low.
    4.  A1 is set high.
    5.  Processor recognizes /IRQ and reads AIR to determine which interrupt
        occurred.
    6.  Bit I1 is reset and /IRQ is reset to high.
    7.  Processor services Interrupt and signals completion of Service
        routine by writing to AIR.
    8.  A1 is reset low and interrupt sequence is complete.

                                                                        :308:

B.  The second case occurs when an interrupt has been received and a higher
    priority interrupt occurs.  (See Note)

    1.  Interrupt I1 is received.
    2.  Bit I1 is set high on the Interrupt Latch Register.
    3.  /IRQ is pulled low and A1 is set high.
    4.  Processor recognizes /IRQ and reads AIR to determine which interrupt
        occurred.
    5.  Bit I1 is reset and /IRQ is reset high.
    6.  Processor begins servicing I1 interrupt and the I2 interrupt is
        received.
    7.  A2 is set, A1 is reset low and /IRQ is pulled low.
    8.  Processor has not yet completed servicing I1 interrupt so this
        routine will be automatically stacked in 650x stack queue when new
        /IRQ for I2 of interrupt is received.
    9.  Processor reads AIR to determine I2 interrupt occurrence and bit I2
        of interrupt latch is reset.
   10.  Processor services I2 interrupt, clears A2 by writing AIR and returns
        from interrupt.  Returning from interrupt causes 650x processor to
        resume servicing I1 interrupt.
   11.  Upon clearing A2 bit in AIR, the A1 bit will not be restored to a
        one.  Internal circuitry will prevent a lower priority interrupt from
        interrupting the resumed I1.

C.  The third case occurs when an interrupt has been received and a lower
    priority interrupt occurs.

    1.  Interrupt I1 is received and latched.
    2.  /IRQ is pulled low and A1 is set high.
    3.  Processor recognizes /IRQ and reads AIR to determine that I1
        interrupt occurred.
    4.  Processor logic servicing I1 interrupt during which I0 interrupt
        occurs and is latched.
    5.  Upon completion of I1 interrupt routine the processor writes AIR to
        clear A1 to signal 6525 that interrupt service is complete.
    6.  Latch I0 interrupt is transferred to AIR and /IRQ is pulled low to
        begin new interrupt sequence.

  *------------------------------------------------------------------------*
  | NOTE:  It was indicated that the 6525 will maintain Priority Interrupt |
  | information from previously serviced interrupts.                       |
  |                                                                        |
  | This is achieved by the use of an Interrupt Stack.  This stack is      |
  | pushed whenever a read of AIR occurs and is pulled whenever a write to |
  | AIR occurs.  It is therefore important not to perform any extraneous   |
  | reads or writes to AIR since this will cause extra and unwanted stack  |
  | operations to occur.                                                   |
  |                                                                        |
  | The only time a read of AIR should occur is to respond to an interrupt |
  | request.                                                               |
  |                                                                        |
  | The only time a write of AIR should occur is to signal the 6525 that   |
  | the interrupt service is complete.                                     |
  *------------------------------------------------------------------------*


                                                                        :309:



                                                         Appendix J

                                                        Disk User's
                                                              Guide



The optional disk holds programs supplementary to the book.

The programs are as follows:

  SUPERMON1        - for original ROM PET computers
  SUPERMON2        - for upgrade ROM PET/CBM computers
  SUPERMON4        - for 4.0 PET/CBM computers
  SUPERMON.V       - for VIC-20 computers
  SUPERMON64       - for Commodore 64 computers
  SUPERMON INST    - instructions, BASIC
  UNICOPY64        - for Commodore 64
  UNICOPY INST     - instructions, BASIC
  ]UNICOPY LIST    - BASIC, all machines
  UNICOPY ASSY     - data file for UNICOPY LIST
  COPY-ALL         - for PET/CBM
  COPY-ALL.64      - for Commodore 64
  CROSS REF        - for PET/CBM
  CROSS REF 64     - for Commodore 64
  FACTORS          - for PET/CBM
  FACTORS V64      - for VIC-20, Commodore 64, and PLUS/4
  PENTOMINOS INST  - instructions
  PENTOMINOS       - BASIC, all machines
  PENTOMINOS PET   - for PET/CBM
  PENTOMINOS V64   - for VIC-20, Commodore 64, and PLUS/4
  PENTOMINOS B128  - boot for B128 system
  +PENTO128        - program for B128
  +XFER            - transfer sequence for B128
  STRING THING     - BASIC, for PET/CBM
  STRING THING V64 - BASIC, for VIC-20, Commodore 64
  ]SAMPLE FILE     - for use with STRING THING

                                                                        :310:

These programs are public domain, and may be obtained from user groups.  They
are available here for user convenience.

The following notes may be useful in using or studying the programs.


  SUPERMON1        - for original ROM PET computers
  SUPERMON2        - for upgrade ROM PET/CBM computers
  SUPERMON4        - for 4.0 PET/CBM computers
  SUPERMON.V       - for VIC-20 computers
  SUPERMON64       - for Commodore 64 computers
  SUPERMON INST    - instructions, BASIC

Supermon 2 and 4 are "extensions" to the built-in MLM of the respective
machines.  The other Supermon versions are complete monitors.

Remember that the programs on disk are "monitor generators," that is, they
build the monitor for you.  After the monitor has been build, you should
remove the builder program so that you don't end up with two copies.  In
other words, after RUN type .X to return to BASIC, NEW to scrap the builder,
and then SYS4 or SYS8 to return to the monitor whenever desired.
