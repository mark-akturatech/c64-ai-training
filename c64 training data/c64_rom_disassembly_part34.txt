# C64 KERNAL ROM Disassembly $ED00-$EDFF - Serial Bus

.:ED00 80 A8 D0 F8 20 48 70 98
.:ED08 C0

                                *** command serial bus device to TALK
.,ED09 09 40    ORA #$40        OR with the TALK command
.:ED0B 2C       .BYTE $2C       makes next line BIT $2009

                                *** command devices on the serial bus to LISTEN
.,ED0C 09 20    ORA #$20        OR with the LISTEN command
.,ED0E 20 A4 F0 JSR $F0A4       check RS232 bus idle

                                *** send a control character
.,ED11 48       PHA             save device address
.,ED12 24 94    BIT $94         test deferred character flag
.,ED14 10 0A    BPL $ED20       if no defered character continue
.,ED16 38       SEC             else flag EOI
.,ED17 66 A3    ROR $A3         rotate into EOI flag byte
.,ED19 20 40 ED JSR $ED40       Tx byte on serial bus
.,ED1C 46 94    LSR $94         clear deferred character flag
.,ED1E 46 A3    LSR $A3         clear EOI flag
.,ED20 68       PLA             restore the device address

                                *** defer a command
.,ED21 85 95    STA $95         save as serial defered character
.,ED23 78       SEI             disable the interrupts
.,ED24 20 97 EE JSR $EE97       set the serial data out high
.,ED27 C9 3F    CMP #$3F        compare read byte with $3F
.,ED29 D0 03    BNE $ED2E       branch if not $3F, this branch will always be taken as
                                after VIA 2's PCR is read it is ANDed with $DF, so the
                                result can never be $3F ??
.,ED2B 20 85 EE JSR $EE85       set the serial clock out high
.,ED2E AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,ED31 09 08    ORA #$08        mask xxxx 1xxx, set serial ATN low
.,ED33 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
                                if the code drops through to here the serial clock is low and the serial data has been
                                released so the following code will have no effect apart from delaying the first byte
                                by 1ms
                                set the serial clk/data, wait and Tx byte on the serial bus
.,ED36 78       SEI             disable the interrupts
.,ED37 20 8E EE JSR $EE8E       set the serial clock out low
.,ED3A 20 97 EE JSR $EE97       set the serial data out high
.,ED3D 20 B3 EE JSR $EEB3       1ms delay

                                *** Tx byte on serial bus
.,ED40 78       SEI             disable the interrupts
.,ED41 20 97 EE JSR $EE97       set the serial data out high
.,ED44 20 A9 EE JSR $EEA9       get the serial data status in Cb
.,ED47 B0 64    BCS $EDAD       if the serial data is high go do 'device not present'
.,ED49 20 85 EE JSR $EE85       set the serial clock out high
.,ED4C 24 A3    BIT $A3         test the EOI flag
.,ED4E 10 0A    BPL $ED5A       if not EOI go ??
                                I think this is the EOI sequence so the serial clock has been released and the serial
                                data is being held low by the peripheral. first up wait for the serial data to rise
.,ED50 20 A9 EE JSR $EEA9       get the serial data status in Cb
.,ED53 90 FB    BCC $ED50       loop if the data is low
                                now the data is high, EOI is signalled by waiting for at least 200us without pulling
                                the serial clock line low again. the listener should respond by pulling the serial
                                data line low
.,ED55 20 A9 EE JSR $EEA9       get the serial data status in Cb
.,ED58 B0 FB    BCS $ED55       loop if the data is high
                                the serial data has gone low ending the EOI sequence, now just wait for the serial
                                data line to go high again or, if this isn't an EOI sequence, just wait for the serial
                                data to go high the first time
.,ED5A 20 A9 EE JSR $EEA9       get the serial data status in Cb
.,ED5D 90 FB    BCC $ED5A       loop if the data is low
                                serial data is high now pull the clock low, preferably within 60us
.,ED5F 20 8E EE JSR $EE8E       set the serial clock out low
                                now the C64 has to send the eight bits, LSB first. first it sets the serial data line
                                to reflect the bit in the byte, then it sets the serial clock to high. The serial
                                clock is left high for 26 cycles, 23us on a PAL Vic, before it is again pulled low
                                and the serial data is allowed high again
.,ED62 A9 08    LDA #$08        eight bits to do
.,ED64 85 A5    STA $A5         set serial bus bit count
.,ED66 AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,ED69 CD 00 DD CMP $DD00       compare it with itself
.,ED6C D0 F8    BNE $ED66       if changed go try again
.,ED6E 0A       ASL             shift the serial data into Cb
.,ED6F 90 3F    BCC $EDB0       if the serial data is low go do serial bus timeout
.,ED71 66 95    ROR $95         rotate the transmit byte
.,ED73 B0 05    BCS $ED7A       if the bit = 1 go set the serial data out high
.,ED75 20 A0 EE JSR $EEA0       else set the serial data out low
.,ED78 D0 03    BNE $ED7D       continue, branch always
.,ED7A 20 97 EE JSR $EE97       set the serial data out high
.,ED7D 20 85 EE JSR $EE85       set the serial clock out high
.,ED80 EA       NOP             waste ..
.,ED81 EA       NOP             .. a ..
.,ED82 EA       NOP             .. cycle ..
.,ED83 EA       NOP             .. or two
.,ED84 AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,ED87 29 DF    AND #$DF        mask xx0x xxxx, set the serial data out high
.,ED89 09 10    ORA #$10        mask xxx1 xxxx, set the serial clock out low
.,ED8B 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,ED8E C6 A5    DEC $A5         decrement the serial bus bit count
.,ED90 D0 D4    BNE $ED66       loop if not all done
                                now all eight bits have been sent it's up to the peripheral to signal the byte was
                                received by pulling the serial data low. this should be done within one milisecond
.,ED92 A9 04    LDA #$04        wait for up to about 1ms
.,ED94 8D 07 DC STA $DC07       save VIA 1 timer B high byte
.,ED97 A9 19    LDA #$19        load timer B, timer B single shot, start timer B
.,ED99 8D 0F DC STA $DC0F       save VIA 1 CRB
.,ED9C AD 0D DC LDA $DC0D       read VIA 1 ICR
.,ED9F AD 0D DC LDA $DC0D       read VIA 1 ICR
.,EDA2 29 02    AND #$02        mask 0000 00x0, timer A interrupt
.,EDA4 D0 0A    BNE $EDB0       if timer A interrupt go do serial bus timeout
.,EDA6 20 A9 EE JSR $EEA9       get the serial data status in Cb
.,EDA9 B0 F4    BCS $ED9F       if the serial data is high go wait some more
.,EDAB 58       CLI             enable the interrupts
.,EDAC 60       RTS             
                                device not present
.,EDAD A9 80    LDA #$80        error $80, device not present
.:EDAF 2C       .BYTE $2C       makes next line BIT $03A9
                                timeout on serial bus
.,EDB0 A9 03    LDA #$03        error $03, read timeout, write timeout
.,EDB2 20 1C FE JSR $FE1C       OR into the serial status byte
.,EDB5 58       CLI             enable the interrupts
.,EDB6 18       CLC             clear for branch
.,EDB7 90 4A    BCC $EE03       ATN high, delay, clock high then data high, branch always

                                *** send secondary address after LISTEN
.,EDB9 85 95    STA $95         save the defered Tx byte
.,EDBB 20 36 ED JSR $ED36       set the serial clk/data, wait and Tx the byte

                                *** set serial ATN high
.,EDBE AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EDC1 29 F7    AND #$F7        mask xxxx 0xxx, set serial ATN high
.,EDC3 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,EDC6 60       RTS             

                                *** send secondary address after TALK
.,EDC7 85 95    STA $95         save the defered Tx byte
.,EDC9 20 36 ED JSR $ED36       set the serial clk/data, wait and Tx the byte

                                *** wait for the serial bus end after send
                                return address from patch 6
.,EDCC 78       SEI             disable the interrupts
.,EDCD 20 A0 EE JSR $EEA0       set the serial data out low
.,EDD0 20 BE ED JSR $EDBE       set serial ATN high
.,EDD3 20 85 EE JSR $EE85       set the serial clock out high
.,EDD6 20 A9 EE JSR $EEA9       get the serial data status in Cb
.,EDD9 30 FB    BMI $EDD6       loop if the clock is high
.,EDDB 58       CLI             enable the interrupts
.,EDDC 60       RTS             

                                *** output a byte to the serial bus
.,EDDD 24 94    BIT $94         test the deferred character flag
.,EDDF 30 05    BMI $EDE6       if there is a defered character go send it
.,EDE1 38       SEC             set carry
.,EDE2 66 94    ROR $94         shift into the deferred character flag
.,EDE4 D0 05    BNE $EDEB       save the byte and exit, branch always
.,EDE6 48       PHA             save the byte
.,EDE7 20 40 ED JSR $ED40       Tx byte on serial bus
.,EDEA 68       PLA             restore the byte
.,EDEB 85 95    STA $95         save the defered Tx byte
.,EDED 18       CLC             flag ok
.,EDEE 60       RTS             

                                *** command serial bus to UNTALK
.,EDEF 78       SEI             disable the interrupts
.,EDF0 20 8E EE JSR $EE8E       set the serial clock out low
.,EDF3 AD 00 DD LDA $DD00       read VIA 2 DRA, serial port and video address
.,EDF6 09 08    ORA #$08        mask xxxx 1xxx, set the serial ATN low
.,EDF8 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,EDFB A9 5F    LDA #$5F        set the UNTALK command
.:EDFD 2C       .BYTE $2C       makes next line BIT $3FA9

                                *** command serial bus to UNLISTEN
.,EDFE A9 3F    LDA #$3F        set the UNLISTEN command
