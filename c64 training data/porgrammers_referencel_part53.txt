# C64 PRG Chapter 5 - Kernal: ACPTR, CHKIN, CHKOUT, CHRIN

  282   BASIC TO MACHINE LANGUAGE
~


  B-11. Function Name: GETIN


    Purpose: Get a character
    Call address: $FFE4 (hex) 65508 (decimal)
    Communication registers: A
    Preparatory routines: CHKIN, OPEN
    Error returns: See READST
    Stack requirements: 7+
    Registers affected: A (X, Y)

    Description: If the channel is the keyboard, this subroutine removes
  one character from the keyboard queue and returns it as an ASCII value in
  the accumulator. If the queue is empty, the value returned in the
  accumulator will be zero. Characters are put into the queue automatically
  by an interrupt driven keyboard scan routine which calls the SCNKEY
  routine. The keyboard buffer can hold up to ten characters. After the
  buffer is filled, additional characters are ignored until at least one
  character has been removed from the queue. If the channel is RS-232, then
  only the A register is used and a single character is returned. See
  READST to check validity. If the channel is serial, cassette, or screen,
  call BASIN routine.


  How to Use:

    1) Call this routine using a JSR instruction.
    2) Check for a zero in the accumulator (empty buffer).
    3) Process the data.


  EXAMPLE:

         ;WAIT FOR A CHARACTER
    WAIT JSR GETIN
         CMP #0
         BEQ WAIT






                                            BASIC TO MACHINE LANGUAGE   283
~


  B-12. Function Name: IOBASE

    Purpose: Define I/O memory page
    Call address: $FFF3 (hex) 65523 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns:
    Stack requirements: 2
    Registers affected: X, Y


    Description: This routine sets the X and Y registers to the address of
  the memory section where the memory mapped 110 devices are located. This
  address can then be used with an offset to access the memory mapped I/O
  devices in the Commodore 64. The offset is the number of locations from
  the beginning of the page on which the I/O register you want is located.
  The X register contains the low order address byte, while the Y register
  contains the high order address byte.
    This routine exists to provide compatibility between the Commodore 64,
  VIC-20, and future models of the Commodore 64. If the J/0 locations for
  a machine language program are set by a call to this routine, they should
  still remain compatible with future versions of the Commodore 64, the
  KERNAL and BASIC.


  How to Use:

    1) Call this routine by using the JSR instruction.
    2) Store the X and the Y registers in consecutive locations.
    3) Load the Y register with the offset.
    4) Access that I/O location.

  EXAMPLE:

    ;SET THE DATA DIRECTION REGISTER OF THE USER PORT TO 0 (INPUT)
    JSR IOBASE
    STX POINT       ;SET BASE REGISTERS
    STY POINT+1
    LDY #2
    LDA #0          ;OFFSET FOR DDR OF THE USER PORT
    STA (POINT),Y   ;SET DDR TO 0


  284   BASIC TO MACHINE LANGUAGE
~


  B-13. Function Name: IOINIT

    Purpose: Initialize I/O devices
    Call Address: $FF84 (hex) 65412 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns:
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine initializes all input/output devices and
  routines. It is normally called as part of the initialization procedure
  of a Commodore 64 program cartridge.

  EXAMPLE:
    JSR IOINIT

  B-14. Function Name: LISTEN

    Purpose: Command a device on the serial bus to listen
    Call Address: $FFB1 (hex) 65457 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: None
    Registers affected: A

    Description: This routine will command a device on the serial bus to
  receive data. The accumulator must be loaded with a device number between
  0 and 31 before calling the routine. LISTEN will OR the number bit by bit
  to convert to a listen address, then transmits this data as a command on
  the serial bus. The specified device will then go into listen mode, and
  be ready to accept information.

  How to Use:
    1) Load the accumulator with the number of the device to command
       to LISTEN.
    2) Call this routine using the JSR instruction.

  EXAMPLE:
    ;COMMAND DEVICE #8 TO LISTEN
    LDA #8
    JSR LISTEN
                                            BASIC TO MACHINE LANGUAGE   285
~


  B-15. Function Name: LOAD

    Purpose: Load RAM from device
    Call address: $FFD5 (hex) 65493 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: SETLFS, SETNAM
    Error returns: 0,4,5,8,9, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine LOADs data bytes from any input device di-
  rectly into the memory of the Commodore 64. It can also be used for a
  verify operation, comparing data from a device with the data already in
  memory, while leaving the data stored in RAM unchanged.
    The accumulator (.A) must be set to 0 for a LOAD operation, or 1 for a
  verify, If the input device is OPENed with a secondary address (SA) of 0
  the header information from the device is ignored. In this case, the X
  and Y registers must contain the starting address for the load. If the
  device is addressed with a secondary address of 1, then the data is
  loaded into memory starting at the location specified by the header. This
  routine returns the address of the highest RAM location loaded.
    Before this routine can be called, the KERNAL SETLFS, and SETNAM
  routines must be called.


  +-----------------------------------------------------------------------+
  | NOTE: You can NOT LOAD from the keyboard (0), RS-232 (2), or the      |
  | screen (3).                                                           |
  +-----------------------------------------------------------------------+


  How to Use:

    0) Call the SETLFS, and SETNAM routines. If a relocated load is de-
       sired, use the SETLFS routine to send a secondary address of 0.
    1) Set the A register to 0 for load, 1 for verify.
    2) If a relocated load is desired, the X and Y registers must be set
       to the start address for the load.
    3) Call the routine using the JSR instruction.




  286   BASIC TO MACHINE LANGUAGE
~


  EXAMPLE:

          ;LOAD   A FILE FROM TAPE

           LDA #DEVICE1        ;SET DEVICE NUMBER
           LDX #FILENO         ;SET LOGICAL FILE NUMBER
           LDY CMD1            ;SET SECONDARY ADDRESS
           JSR SETLFS
           LDA #NAME1-NAME     ;LOAD A WITH NUMBER OF
                               ;CHARACTERS IN FILE NAME
           LDX #<NAME          ;LOAD X AND Y WITH ADDRESS OF
           LDY #>NAME          ;FILE NAME
           JSR SETNAM
           LDA #0              ;SET FLAG FOR A LOAD
           LDX #$FF            ;ALTERNATE START
           LDY #$FF
           JSR LOAD
           STX VARTAB          ;END OF LOAD
           STY VARTA B+1
           JMP START
   NAME    .BYT 'FILE NAME'
   NAME1                       ;


  B-16. Function Name: MEMBOT

    Purpose: Set bottom of memory
    Call address: $FF9C (hex) 65436 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: None
    Registers affected: X, Y

    Description: This routine is used to set the bottom of the memory. If
  the accumulator carry bit is set when this routine is called, a pointer
  to the lowest byte of RAM is returned in the X and Y registers. On the
  unexpanded Commodore 64 the initial value of this pointer is $0800
  (2048 in decimal). If the accumulator carry bit is clear (-O) when this
  routine is called, the values of the X and Y registers are transferred to
  the low and high bytes, respectively, of the pointer to the beginning of
  RAM.

                                            BASIC TO MACHINE LANGUAGE   287
~


  How to Use:
  TO READ THE BOTTOM OF RAM
    1) Set the carry.
    2) Call this routine.

  TO SET THE BOTTOM OF MEMORY
    1) Clear the carry.
    2) Call this routine.

  EXAMPLE:

    ;MOVE BOTTOM OF MEMORY UP 1 PAGE
    SEC         ;READ MEMORY BOTTOM
    JSR MEMBOT
    INY
    CLC         ;SET MEMORY BOTTOM TO NEW VALUE
    JSR MEMBOT

  B-17. Function Name: MEMTOP

    Purpose: Set the top of RAM
    Call address: $FF99 (hex) 65433 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: X, Y

    Description: This routine is used to set the top of RAM. When this
  routine is called with the carry bit of the accumulator set, the pointer
  to the top of RAM will be loaded into the X and Y registers. When this
  routine is called with the accumulator carry bit clear, the contents of
  the X and Y registers are loaded in the top of memory pointer, changing
  the top of memory.

  EXAMPLE:
    ;DEALLOCATE THE RS-232 BUFFER
    SEC
    JSR MEMTOP   ;READ TOP OF MEMORY
    DEX
    CLC
    JSR MEMTOP   ;SET NEW TOP OF MEMORY

