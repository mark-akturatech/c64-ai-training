# C64 KERNAL ROM Disassembly $F200-$F5FF - Tape Routines

.,F200 AA       TAX             restore X
.,F201 A5 9E    LDA $9E         get the character from the character buffer
.,F203 90 02    BCC $F207       exit if no error
.,F205 A9 00    LDA #$00        else clear A
.,F207 60       RTS             
                                output the character to the RS232 device
.,F208 20 17 F0 JSR $F017       send byte to the RS232 buffer, no setup
.,F20B 4C FC F1 JMP $F1FC       do no error exit

                                *** open channel for input
.,F20E 20 0F F3 JSR $F30F       find a file
.,F211 F0 03    BEQ $F216       if the file is open continue
.,F213 4C 01 F7 JMP $F701       else do 'file not open' error and return
.,F216 20 1F F3 JSR $F31F       set file details from table,X
.,F219 A5 BA    LDA $BA         get the device number
.,F21B F0 16    BEQ $F233       if the device was the keyboard save the device #, flag
                                ok and exit
.,F21D C9 03    CMP #$03        compare the device number with the screen
.,F21F F0 12    BEQ $F233       if the device was the screen save the device #, flag ok
                                and exit
.,F221 B0 14    BCS $F237       if the device was a serial bus device go ??
.,F223 C9 02    CMP #$02        else compare the device with the RS232 device
.,F225 D0 03    BNE $F22A       if not the RS232 device continue
.,F227 4C 4D F0 JMP $F04D       else go get input from the RS232 buffer and return
.,F22A A6 B9    LDX $B9         get the secondary address
.,F22C E0 60    CPX #$60        
.,F22E F0 03    BEQ $F233       
.,F230 4C 0A F7 JMP $F70A       go do 'not input file' error and return
.,F233 85 99    STA $99         save the input device number
.,F235 18       CLC             flag ok
.,F236 60       RTS             
                                the device was a serial bus device
.,F237 AA       TAX             copy device number to X
.,F238 20 09 ED JSR $ED09       command serial bus device to TALK
.,F23B A5 B9    LDA $B9         get the secondary address
.,F23D 10 06    BPL $F245       
.,F23F 20 CC ED JSR $EDCC       wait for the serial bus end after send
.,F242 4C 48 F2 JMP $F248       
.,F245 20 C7 ED JSR $EDC7       send secondary address after TALK
.,F248 8A       TXA             copy device back to A
.,F249 24 90    BIT $90         test the serial status byte
.,F24B 10 E6    BPL $F233       if device present save device number and exit
.,F24D 4C 07 F7 JMP $F707       do 'device not present' error and return

                                *** open channel for output
.,F250 20 0F F3 JSR $F30F       find a file
.,F253 F0 03    BEQ $F258       if file found continue
.,F255 4C 01 F7 JMP $F701       else do 'file not open' error and return
.,F258 20 1F F3 JSR $F31F       set file details from table,X
.,F25B A5 BA    LDA $BA         get the device number
.,F25D D0 03    BNE $F262       if the device is not the keyboard go ??
.,F25F 4C 0D F7 JMP $F70D       go do 'not output file' error and return
.,F262 C9 03    CMP #$03        compare the device with the screen
.,F264 F0 0F    BEQ $F275       if the device is the screen go save output the output
                                device number and exit
.,F266 B0 11    BCS $F279       if > screen then go handle a serial bus device
.,F268 C9 02    CMP #$02        compare the device with the RS232 device
.,F26A D0 03    BNE $F26F       if not the RS232 device then it must be the tape device
.,F26C 4C E1 EF JMP $EFE1       else go open RS232 channel for output
                                open a tape channel for output
.,F26F A6 B9    LDX $B9         get the secondary address
.,F271 E0 60    CPX #$60        
.,F273 F0 EA    BEQ $F25F       if ?? do not output file error and return
.,F275 85 9A    STA $9A         save the output device number
.,F277 18       CLC             flag ok
.,F278 60       RTS             
.,F279 AA       TAX             copy the device number
.,F27A 20 0C ED JSR $ED0C       command devices on the serial bus to LISTEN
.,F27D A5 B9    LDA $B9         get the secondary address
.,F27F 10 05    BPL $F286       if address to send go ??
.,F281 20 BE ED JSR $EDBE       else set serial ATN high
.,F284 D0 03    BNE $F289       go ??, branch always
.,F286 20 B9 ED JSR $EDB9       send secondary address after LISTEN
.,F289 8A       TXA             copy device number back to A
.,F28A 24 90    BIT $90         test the serial status byte
.,F28C 10 E7    BPL $F275       if the device is present go save the output device number
                                and exit
.,F28E 4C 07 F7 JMP $F707       else do 'device not present error' and return

                                *** close a specified logical file
.,F291 20 14 F3 JSR $F314       find file A
.,F294 F0 02    BEQ $F298       if file found go close it
.,F296 18       CLC             else the file was closed so just flag ok
.,F297 60       RTS             
                                file found so close it
.,F298 20 1F F3 JSR $F31F       set file details from table,X
.,F29B 8A       TXA             copy file index to A
.,F29C 48       PHA             save file index
.,F29D A5 BA    LDA $BA         get the device number
.,F29F F0 50    BEQ $F2F1       if it is the keyboard go restore the index and close the
                                file
.,F2A1 C9 03    CMP #$03        compare the device number with the screen
.,F2A3 F0 4C    BEQ $F2F1       if it is the screen go restore the index and close the
                                file
.,F2A5 B0 47    BCS $F2EE       if > screen go do serial bus device close
.,F2A7 C9 02    CMP #$02        compare the device with the RS232 device
.,F2A9 D0 1D    BNE $F2C8       if not the RS232 device go ??
                                else close RS232 device
.,F2AB 68       PLA             restore file index
.,F2AC 20 F2 F2 JSR $F2F2       close file index X
.,F2AF 20 83 F4 JSR $F483       initialise RS232 output
.,F2B2 20 27 FE JSR $FE27       read the top of memory
.,F2B5 A5 F8    LDA $F8         get the RS232 input buffer pointer high byte
.,F2B7 F0 01    BEQ $F2BA       if no RS232 input buffer go ??
.,F2B9 C8       INY             else reclaim RS232 input buffer memory
.,F2BA A5 FA    LDA $FA         get the RS232 output buffer pointer high byte
.,F2BC F0 01    BEQ $F2BF       if no RS232 output buffer skip the reclaim
.,F2BE C8       INY             else reclaim the RS232 output buffer memory
.,F2BF A9 00    LDA #$00        clear A
.,F2C1 85 F8    STA $F8         clear the RS232 input buffer pointer high byte
.,F2C3 85 FA    STA $FA         clear the RS232 output buffer pointer high byte
.,F2C5 4C 7D F4 JMP $F47D       go set the top of memory to F0xx
                                is not the RS232 device
.,F2C8 A5 B9    LDA $B9         get the secondary address
.,F2CA 29 0F    AND #$0F        mask the device #
.,F2CC F0 23    BEQ $F2F1       if ?? restore index and close file
.,F2CE 20 D0 F7 JSR $F7D0       get tape buffer start pointer in XY
.,F2D1 A9 00    LDA #$00        character $00
.,F2D3 38       SEC             flag the tape device
.,F2D4 20 DD F1 JSR $F1DD       output the character to the cassette or RS232 device
.,F2D7 20 64 F8 JSR $F864       initiate tape write
.,F2DA 90 04    BCC $F2E0       
.,F2DC 68       PLA             
.,F2DD A9 00    LDA #$00        
.,F2DF 60       RTS             
.,F2E0 A5 B9    LDA $B9         get the secondary address
.,F2E2 C9 62    CMP #$62        
.,F2E4 D0 0B    BNE $F2F1       if not ?? restore index and close file
.,F2E6 A9 05    LDA #$05        set logical end of the tape
.,F2E8 20 6A F7 JSR $F76A       write tape header
.,F2EB 4C F1 F2 JMP $F2F1       restore index and close file

                                *** serial bus device close
.,F2EE 20 42 F6 JSR $F642       close serial bus device
.,F2F1 68       PLA             restore file index

                                *** close file index X
.,F2F2 AA       TAX             copy index to file to close
.,F2F3 C6 98    DEC $98         decrement the open file count
.,F2F5 E4 98    CPX $98         compare the index with the open file count
.,F2F7 F0 14    BEQ $F30D       exit if equal, last entry was closing file
                                else entry was not last in list so copy last table entry
                                file details over the details of the closing one
.,F2F9 A4 98    LDY $98         get the open file count as index
.,F2FB B9 59 02 LDA $0259,Y     get last+1 logical file number from logical file table
.,F2FE 9D 59 02 STA $0259,X     save logical file number over closed file
.,F301 B9 63 02 LDA $0263,Y     get last+1 device number from device number table
.,F304 9D 63 02 STA $0263,X     save device number over closed file
.,F307 B9 6D 02 LDA $026D,Y     get last+1 secondary address from secondary address table
.,F30A 9D 6D 02 STA $026D,X     save secondary address over closed file
.,F30D 18       CLC             flag ok
.,F30E 60       RTS             

                                *** find a file
.,F30F A9 00    LDA #$00        clear A
.,F311 85 90    STA $90         clear the serial status byte
.,F313 8A       TXA             copy the logical file number to A

                                *** find file A
.,F314 A6 98    LDX $98         get the open file count
.,F316 CA       DEX             decrememnt the count to give the index
.,F317 30 15    BMI $F32E       if no files just exit
.,F319 DD 59 02 CMP $0259,X     compare the logical file number with the table logical
                                file number
.,F31C D0 F8    BNE $F316       if no match go try again
.,F31E 60       RTS             

                                *** set file details from table,X
.,F31F BD 59 02 LDA $0259,X     get logical file from logical file table
.,F322 85 B8    STA $B8         save the logical file
.,F324 BD 63 02 LDA $0263,X     get device number from device number table
.,F327 85 BA    STA $BA         save the device number
.,F329 BD 6D 02 LDA $026D,X     get secondary address from secondary address table
.,F32C 85 B9    STA $B9         save the secondary address
.,F32E 60       RTS             

                                *** close all channels and files
.,F32F A9 00    LDA #$00        clear A
.,F331 85 98    STA $98         clear the open file count

                                *** close input and output channels
.,F333 A2 03    LDX #$03        set the screen device
.,F335 E4 9A    CPX $9A         compare the screen with the output device number
.,F337 B0 03    BCS $F33C       if <= screen skip the serial bus unlisten
.,F339 20 FE ED JSR $EDFE       else command the serial bus to UNLISTEN
.,F33C E4 99    CPX $99         compare the screen with the input device number
.,F33E B0 03    BCS $F343       if <= screen skip the serial bus untalk
.,F340 20 EF ED JSR $EDEF       else command the serial bus to UNTALK
.,F343 86 9A    STX $9A         save the screen as the output device number
.,F345 A9 00    LDA #$00        set the keyboard as the input device
.,F347 85 99    STA $99         save the input device number
.,F349 60       RTS             

                                *** open a logical file
.,F34A A6 B8    LDX $B8         get the logical file
.,F34C D0 03    BNE $F351       if there is a file continue
.,F34E 4C 0A F7 JMP $F70A       else do 'not input file error' and return
.,F351 20 0F F3 JSR $F30F       find a file
.,F354 D0 03    BNE $F359       if file not found continue
.,F356 4C FE F6 JMP $F6FE       else do 'file already open' error and return
.,F359 A6 98    LDX $98         get the open file count
.,F35B E0 0A    CPX #$0A        compare it with the maximum + 1
.,F35D 90 03    BCC $F362       if less than maximum + 1 go open the file
.,F35F 4C FB F6 JMP $F6FB       else do 'too many files error' and return
.,F362 E6 98    INC $98         increment the open file count
.,F364 A5 B8    LDA $B8         get the logical file
.,F366 9D 59 02 STA $0259,X     save it to the logical file table
.,F369 A5 B9    LDA $B9         get the secondary address
.,F36B 09 60    ORA #$60        OR with the OPEN CHANNEL command
.,F36D 85 B9    STA $B9         save the secondary address
.,F36F 9D 6D 02 STA $026D,X     save it to the secondary address table
.,F372 A5 BA    LDA $BA         get the device number
.,F374 9D 63 02 STA $0263,X     save it to the device number table
.,F377 F0 5A    BEQ $F3D3       if it is the keyboard go do the ok exit
.,F379 C9 03    CMP #$03        compare the device number with the screen
.,F37B F0 56    BEQ $F3D3       if it is the screen go do the ok exit
.,F37D 90 05    BCC $F384       if tape or RS232 device go ??
                                else it is a serial bus device
.,F37F 20 D5 F3 JSR $F3D5       send the secondary address and filename
.,F382 90 4F    BCC $F3D3       go do ok exit, branch always
.,F384 C9 02    CMP #$02        
.,F386 D0 03    BNE $F38B       
.,F388 4C 09 F4 JMP $F409       go open RS232 device and return
.,F38B 20 D0 F7 JSR $F7D0       get tape buffer start pointer in XY
.,F38E B0 03    BCS $F393       if >= $0200 go ??
.,F390 4C 13 F7 JMP $F713       else do 'illegal device number' and return
.,F393 A5 B9    LDA $B9         get the secondary address
.,F395 29 0F    AND #$0F        
.,F397 D0 1F    BNE $F3B8       
.,F399 20 17 F8 JSR $F817       wait for PLAY
.,F39C B0 36    BCS $F3D4       exit if STOP was pressed
.,F39E 20 AF F5 JSR $F5AF       print "Searching..."
.,F3A1 A5 B7    LDA $B7         get file name length
.,F3A3 F0 0A    BEQ $F3AF       if null file name just go find header
.,F3A5 20 EA F7 JSR $F7EA       find specific tape header
.,F3A8 90 18    BCC $F3C2       branch if no error
.,F3AA F0 28    BEQ $F3D4       exit if ??
.,F3AC 4C 04 F7 JMP $F704       do file not found error and return
.,F3AF 20 2C F7 JSR $F72C       find tape header, exit with header in buffer
.,F3B2 F0 20    BEQ $F3D4       exit if end of tape found
.,F3B4 90 0C    BCC $F3C2       
.,F3B6 B0 F4    BCS $F3AC       
.,F3B8 20 38 F8 JSR $F838       wait for PLAY/RECORD
.,F3BB B0 17    BCS $F3D4       exit if STOP was pressed
.,F3BD A9 04    LDA #$04        set data file header
.,F3BF 20 6A F7 JSR $F76A       write tape header
.,F3C2 A9 BF    LDA #$BF        
.,F3C4 A4 B9    LDY $B9         get the secondary address
.,F3C6 C0 60    CPY #$60        
.,F3C8 F0 07    BEQ $F3D1       
.,F3CA A0 00    LDY #$00        clear index
.,F3CC A9 02    LDA #$02        
.,F3CE 91 B2    STA ($B2),Y     save to tape buffer
.,F3D0 98       TYA             clear A
.,F3D1 85 A6    STA $A6         save tape buffer index
.,F3D3 18       CLC             flag ok
.,F3D4 60       RTS             

                                *** send secondary address and filename
.,F3D5 A5 B9    LDA $B9         get the secondary address
.,F3D7 30 FA    BMI $F3D3       ok exit if -ve
.,F3D9 A4 B7    LDY $B7         get file name length
.,F3DB F0 F6    BEQ $F3D3       ok exit if null
.,F3DD A9 00    LDA #$00        clear A
.,F3DF 85 90    STA $90         clear the serial status byte
.,F3E1 A5 BA    LDA $BA         get the device number
.,F3E3 20 0C ED JSR $ED0C       command devices on the serial bus to LISTEN
.,F3E6 A5 B9    LDA $B9         get the secondary address
.,F3E8 09 F0    ORA #$F0        OR with the OPEN command
.,F3EA 20 B9 ED JSR $EDB9       send secondary address after LISTEN
.,F3ED A5 90    LDA $90         get the serial status byte
.,F3EF 10 05    BPL $F3F6       if device present skip the 'device not present' error
.,F3F1 68       PLA             else dump calling address low byte
.,F3F2 68       PLA             dump calling address high byte
.,F3F3 4C 07 F7 JMP $F707       do 'device not present' error and return
.,F3F6 A5 B7    LDA $B7         get file name length
.,F3F8 F0 0C    BEQ $F406       branch if null name
.,F3FA A0 00    LDY #$00        clear index
.,F3FC B1 BB    LDA ($BB),Y     get file name byte
.,F3FE 20 DD ED JSR $EDDD       output byte to serial bus
.,F401 C8       INY             increment index
.,F402 C4 B7    CPY $B7         compare with file name length
.,F404 D0 F6    BNE $F3FC       loop if not all done
.,F406 4C 54 F6 JMP $F654       command serial bus to UNLISTEN and return

                                *** open RS232 device
.,F409 20 83 F4 JSR $F483       initialise RS232 output
.,F40C 8C 97 02 STY $0297       save the RS232 status register
.,F40F C4 B7    CPY $B7         compare with file name length
.,F411 F0 0A    BEQ $F41D       exit loop if done
.,F413 B1 BB    LDA ($BB),Y     get file name byte
.,F415 99 93 02 STA $0293,Y     copy to 6551 register set
.,F418 C8       INY             increment index
.,F419 C0 04    CPY #$04        compare with $04
.,F41B D0 F2    BNE $F40F       loop if not to 4 yet
.,F41D 20 4A EF JSR $EF4A       compute bit count
.,F420 8E 98 02 STX $0298       save bit count
.,F423 AD 93 02 LDA $0293       get pseudo 6551 control register
.,F426 29 0F    AND #$0F        mask 0000 xxxx, baud rate
.,F428 F0 1C    BEQ $F446       if zero skip the baud rate setup
.,F42A 0A       ASL             * 2 bytes per entry
.,F42B AA       TAX             copy to the index
.,F42C AD A6 02 LDA $02A6       get the PAL/NTSC flag
.,F42F D0 09    BNE $F43A       if PAL go set PAL timing
.,F431 BC C1 FE LDY $FEC1,X     get the NTSC baud rate value high byte
.,F434 BD C0 FE LDA $FEC0,X     get the NTSC baud rate value low byte
.,F437 4C 40 F4 JMP $F440       go save the baud rate values
.,F43A BC EB E4 LDY $E4EB,X     get the PAL baud rate value high byte
.,F43D BD EA E4 LDA $E4EA,X     get the PAL baud rate value low byte
.,F440 8C 96 02 STY $0296       save the nonstandard bit timing high byte
.,F443 8D 95 02 STA $0295       save the nonstandard bit timing low byte
.,F446 AD 95 02 LDA $0295       get the nonstandard bit timing low byte
.,F449 0A       ASL             * 2
.,F44A 20 2E FF JSR $FF2E       
.,F44D AD 94 02 LDA $0294       read the pseudo 6551 command register
.,F450 4A       LSR             shift the X line/3 line bit into Cb
.,F451 90 09    BCC $F45C       if 3 line skip the DRS test
.,F453 AD 01 DD LDA $DD01       read VIA 2 DRB, RS232 port
.,F456 0A       ASL             shift DSR in into Cb
.,F457 B0 03    BCS $F45C       if DSR present skip the error set
.,F459 20 0D F0 JSR $F00D       set no DSR
.,F45C AD 9B 02 LDA $029B       get index to Rx buffer end
.,F45F 8D 9C 02 STA $029C       set index to Rx buffer start, clear Rx buffer
.,F462 AD 9E 02 LDA $029E       get index to Tx buffer end
.,F465 8D 9D 02 STA $029D       set index to Tx buffer start, clear Tx buffer
.,F468 20 27 FE JSR $FE27       read the top of memory
.,F46B A5 F8    LDA $F8         get the RS232 input buffer pointer high byte
.,F46D D0 05    BNE $F474       if buffer already set skip the save
.,F46F 88       DEY             decrement top of memory high byte, 256 byte buffer
.,F470 84 F8    STY $F8         save the RS232 input buffer pointer high byte
.,F472 86 F7    STX $F7         save the RS232 input buffer pointer low byte
.,F474 A5 FA    LDA $FA         get the RS232 output buffer pointer high byte
.,F476 D0 05    BNE $F47D       if ?? go set the top of memory to F0xx
.,F478 88       DEY             
.,F479 84 FA    STY $FA         save the RS232 output buffer pointer high byte
.,F47B 86 F9    STX $F9         save the RS232 output buffer pointer low byte

                                *** set the top of memory to F0xx
.,F47D 38       SEC             read the top of memory
.,F47E A9 F0    LDA #$F0        set $F000
.,F480 4C 2D FE JMP $FE2D       set the top of memory and return

                                *** initialise RS232 output
.,F483 A9 7F    LDA #$7F        disable all interrupts
.,F485 8D 0D DD STA $DD0D       save VIA 2 ICR
.,F488 A9 06    LDA #$06        set RS232 DTR output, RS232 RTS output
.,F48A 8D 03 DD STA $DD03       save VIA 2 DDRB, RS232 port
.,F48D 8D 01 DD STA $DD01       save VIA 2 DRB, RS232 port
.,F490 A9 04    LDA #$04        mask xxxx x1xx, set RS232 Tx DATA high
.,F492 0D 00 DD ORA $DD00       OR it with VIA 2 DRA, serial port and video address
.,F495 8D 00 DD STA $DD00       save VIA 2 DRA, serial port and video address
.,F498 A0 00    LDY #$00        clear Y
.,F49A 8C A1 02 STY $02A1       clear the RS-232 interrupt enable byte
.,F49D 60       RTS             

                                *** load RAM from a device
.,F49E 86 C3    STX $C3         set kernal setup pointer low byte
.,F4A0 84 C4    STY $C4         set kernal setup pointer high byte
.,F4A2 6C 30 03 JMP ($0330)     do LOAD vector, usually points to $F4A5

                                *** load
.,F4A5 85 93    STA $93         save load/verify flag
.,F4A7 A9 00    LDA #$00        clear A
.,F4A9 85 90    STA $90         clear the serial status byte
.,F4AB A5 BA    LDA $BA         get the device number
.,F4AD D0 03    BNE $F4B2       if not the keyboard continue
                                do 'illegal device number'
.,F4AF 4C 13 F7 JMP $F713       else do 'illegal device number' and return
