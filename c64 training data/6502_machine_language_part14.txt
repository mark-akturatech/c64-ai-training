# ML for C64 - Chapter 7: Stack Operations, JSR/RTS

there's an address in zero page that will tell you that (location $97 in
PET/CBM, $CB in VIC and 64).

Zero-page addressing, like absolute addressing, references one location only.
It's good for a specific value; but for a range of values we need something
more.

                                                                         :77:

A Range of 256 Addresses:  Absolute, Indexed Mode
-------------------------------------------------

Indexing has already been used in Chapter 2.  We give an absolute address,
and then indicate that the contents of X or Y should be added to this address
to give an effective address.


  +----------------------------------------------------------------------+
  |                                 MEMORY                               |
  +----------------------------------------------------------------------+
                  ^        ^
                  |        |
                  +--------'
                  |      INDEX
                BASE     VALUE
               ADDRESS

  Figure 5.3


Indexing is used only for data handling:  it's available for such activities
as load and store, but not for branch or jump.  Many instructions give you a
choice of X or Y as an index register; a few are limited specifically to X or
Y.  Instructions that compare or store X and Y (CPX, CPY, STX, and STY) do
not have absolute, indexed addressing; neither does the BIT instruction.

An instruction using absolute, indexed addressing can reach up to 256
locations.  Registers X and Y may hold values from 0 to 255, so that the
effective address may range from the address given to 255 locations higher.
Indexing always increases the address; there is no such thing as a negative
index when used with an absolute address.  If the address given is above
$FF00, a high value in the index may cause the address to "wrap around" and
generate an effective address in the region of $0000; otherwise, the
effective address is never lower than the instruction address.

We've seen the use of indexing.  An instruction can reference a certain
address, then, as the program loops or as the need for information changes,
the same instruction can reference the contents of a different address.  The
maximum range of 256 locations is an important limitation.

                                                                         :78:

The "reach" of absolute, indexed instruction allows it to handle information
in buffers (such as the input buffer, keyboard buffer, cassette buffer);
tables (such as the active file table); and short messages (such as HELLO or
error messages).  It's not big enough, however, to reach all parts of screen
memory, all parts of a BASIC program, or all of RAM.  For that, we'll use
indirect, indexed addressing, which will be described later.


All of Zero Page:  Zero-Page, Indexed
-------------------------------------

Zero-page, indexed addressing seems at first glance to be similar to
absolute, indexed mode.  The address given (this time in zero-page) has the
contents of the selected index added to it.  But there's a difference:  in
this case, the effective address can never leave zero page.

This mode usually uses the X register; only two instructions, LDX and STX,
use the Y register for zero-page, indexed addressing.  In either case, the
index is added to the zero-page address; if the total goes beyond zero page,
the address "wraps around."  As an example, if an instruction is coded LDA
#$E0,X and the X register contains 50 at the time of execution, the effective
address will be $0030.  The total ($E0 + $50 or $130) will be trimmed back to
zero page.



   $00     $FF $100
  +-----------+----------------------------------------------------------+
  |           |                     MEMORY                               |
  +-----------+----------------------------------------------------------+
    ^     ^ ^
    |     | |
    |     +-'
  |-'     +---|
          |
        BASE
       ADDRESS

  Figure 5.4


Thus, any zero page address can be indexed to reach any other place in zero
page; the reach of 256 locations represents the whole of zero page.  This
creates a new possibility:  with zero-page, indexed addressing, we can
achieve negative indexing.  For this address mode only, we can index in a
downward direction by using index register values such as $FF for -1, $FE for
-2, and so on.

On Commodore machines, zero page is fairly well occupied.  There is limited
opportunity to use zero-page, indexed addressing.

                                                                         :79:

Branching:  Relative Address Mode
---------------------------------

We have written several branch instructions already; the assembler allowed us
to enter the actual addresses to which we want to branch.  The assembler
translates it to a different form--the relative address.


         ,---------.
         |  ,---.  |
         v  |   v  |
  +----------------------------------------------------------------------+
  |                                 MEMORY                               |
  +----------------------------------------------------------------------+

  Figure 5.5


Relative address means, "branch forward or backwards a certain number of
bytes from this point."  The relative address is one byte, making the whole
instruction two bytes long.  Its value is taken as a signed number.

A branch instruction with a relative address of $05 would mean, "if the
branch is taken, skip the next 5 bytes."  A branch instruction with a
relative address of $F7 would mean, "if the branch is taken, back up 9 bytes
from where you would otherwise be."  As a signed number, $F7 is equal to a
value of -9.

We can calculate a branch by performing hexadecimal subtraction; the "target"
address is subtracted from the PC address.  If we have a branch at $0341 that
should go to $033C, we would work as follows:  $033C (the target) minus $0343
(the location following the branch instruction) would give a result of $F9,
or minus 7.  This is tedious to do, and often results in mistakes; such
mistakes in calculating a branch address are often fatal to the program run.
We are much better off using an assembler to work out the arithmetic for us.

The longest branches are:  $7F, or 127 locations ahead; and $80, or 128
locations back.  This poses no difficulties with short programs, such as the
ones we are writing here.  But in larger programs, the branch may not be able
to reach far enough.  The usual solution to this is to place a JMP (jump)
instruction nearby, which is capable of going anywhere in memory; JMP uses
absolute addressing.  The appropriate branch instruction will go to the JMP,
which in turn will take the program to the desired location.

                                                                         :80:

Advocates of programming style make the following argument.  All programs
should be written into neat small modules.  Logic block should be broken into
subroutines, and the subroutines into even smaller subroutines; this way,
everything is neat and testable.  If you should find a branch that won't
reach, ask yourself whether it's time to break your program into smaller
chunks before the logic gets too messy.  By the liberal use of subroutines,
you can arrange your code so that all branches are short and easily within
reach.  If you do break up the program structure, the branches will then
always reach.  It's up to you to choose your coding style, but you might give
the question some thought.

An interesting aspect of relative addressing is that code containing branches
is easy to relocate.  A piece of code containing a branch to six locations
ahead will work perfectly if the whole code is moves to a different location.
This is not true of jumps and subroutine calls, or any code using absolute
addressing--if the location changes, the address must be changed.


The ROM Link--Jumps in Indirect Mode
------------------------------------

We have mentioned the JMP instruction that will take the program to any
specified address.  JMP has another address mode:  indirect addressing.

Indirect addressing is signaled by the use of parentheses around the address.
It works this way.  An address is supplied, but it's not the one we will
eventually use.  We take this address, and at the location it specifies,
we'll find the effective address, or indirect address.  The indirect address
is two bytes long, of course, and is stored in the usual 650x manner of low
byte first.

An example will help to make things clear.  Suppose that at address $033C we
have the instruction JMP ($1234).  The parentheses tell us that indirect
addressing is involved.  The machine code is hex 6C 34 12; as always, the
address is "turned around."  Now suppose that at addresses $1234 and $1235 we
have stored values $24 and $68.  The jump instruction would behave as
follows:  it would go to $1234 and $1235, get the contents, and the program
would transfer to address $6824.


  +-------+---+----------------------------------------------------------+
  |       |   |                     MEMORY                               |
  +-------+---+----------------------------------------------------------+
           ^ |            ^
           | |            |
           | `------------'
      INDIRECT
      ADDRESS

  Figure 5.6

                                                                         :81:

The JMP indirect has a somewhat specialized use.  Normally, if we want to
transfer control to some location, we just JMP there; no need for the
indirect step.  But there's one quite important case where indirect jumps
serve an important function.

Within ROM, there are a large amount of permanent instructions that the
computer uses to perform tasks.  Since it's in ROM, we can never change this
code.  If the various programs were linked only be means of JMP and JSR
statements, they could not be changed, and we would not be able to modify
behavior of the machine.

Built into the ROM program, there are a series of carefully planned indirect
jumps.  Instead of the ROM leaping from one instruction directly to another,
it jumps indirectly via an address stored in RAM.  We can change the contents
of RAM; and if we change the address stored in RAM, we can modify the
behavior of the system.  The best-known indirect address is that associated
with the interrupt sequence:  it's at $0090 in PET/CBM and $0314 in VIC, 64,
and PLUS/4.

You might not code many indirect jumps, but you'll be glad that they are
there in ROM.


Data From Anywhere:  Indirect, Indexed
--------------------------------------

The problems with indexed addressing have been noted:  the reach of only 256
bytes limits the data capability of this method.

Indirect addressing seems to offer a total solution.  We can write an
instruction that points at an indirect address.  Since we can change the
indirect address at will, or add to or subtract from it, we can cause our
instruction to deal with data anywhere in memory.

In fact, we get a limitation and a bonus.  First, the limitation:  for
indirect, indexed instructions the indirect address must be in zero-page--two
bytes, of course, organized low byte first, as always.  Next, the bonus:
after the indirect address is obtained, it will be indexed with the Y
register to form the final effective address.

Let's step our way through the mechanism and see how it works.  Suppose I
code LDA ($C0),Y with values $11 in address $00C0 and $22 in address $00C1.
If the Y register contains a value of 3, the instruction will follow these
steps:  The address at $00C0-1 is extracted, giving $2211; then the contents
of Y are added to give the effective address of $2214.  If the contents of Y
changed, the effective address would change slightly.  If the indirect
address at $C0 and $C1 was changed, the effective address would change
radically.

                                                                         :82:

The combination of indirect and indexing may seem like overkill.  If you can
designate any location in memory with an indirect address, why bother with
indexing?  After all, anywhere plus one is still anywhere.

Indirect addressing plus indexing proves to be an ideal combination for the
manipulation of data.  Almost all data breaks up into logical chunks of some
sort:  records, table entries, screen lines, words, and so on.  Here's the
technique.  We position the indirect address at the start of a given logical
data chunk, and use the Y register to scan through the information.  When
we're ready to move to the next item, we move the indirect address along, and
repeat the same scanning of the Y register through the new data.


   $00            $FF
  +-------+---+------+---------------------------------------------------+
  |       |   |      |              MEMORY                               |
  +-------+---+------+---------------------------------------------------+
           ^ |            ^  ^
           | |            |  |
           | |            +--'
           | `------------' Y
      INDIRECT
      ADDRESS

  Figure 5.7


One may think of it as a fishing analogy:  We anchor the boat in a certain
spot (fix the indirect address) and then use the fishing line (the Y
register) to reach the data we need.  When we're ready for the next item, we
pull up the anchor and move along to a new place.

      .--------------DATA IN MEMORY--------------.
      |                                          |
      v                                          v
     +--------------+--------------+--------------+
     |  NAME, ETC.  |  NAME, ETC.  |  NAME, ETC.  |
     +--------------+--------------+--------------+
      ^              ^              ^
      |              |              |
      A              B

     Figure 5.8


