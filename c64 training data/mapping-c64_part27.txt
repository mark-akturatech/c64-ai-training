# C64 VIC-II Screen Control $D018-$D01F


Because of the unusual layout of bitmap screen data on the 64, it is
fairly easy to transfer text characters to a bitmap screen, but it is
somewhat awkward finding the bit which affects the screen dot having a
given X-Y coordinate.  First, you must find the byte BY in which the
bit resides, and then you must POKE a vlue into that byte which turns
the desired bit on or off.  Given that the horizontal position of the
dot is stored in the variable X, its vertical position is in the
variable Y, and the base address of the bitmap area is in the variable
BASE, you can find the desired byte with the formula:

BY=BASE+40*(Y AND 256)+(Y AND 7)+(X AND 504)

To turn on the desired dot,

POKE BY, PEEK(BY) OR (2^(NOTX AND 7)

To turn the dot off,

POKE BY, PEEK(BY) AND (255-2^(NOTX AND 7))

The exponentation function takes a lot of time.  To speed things up,
an array can be created, each of whose elements corresponds to a power
of two.

FOR I=0 TO 7:BIT(I)=2^1:NEXT

After this is done, the expression 2^(I) can be replaced by BI(I).

The following sample program illustrates the bit-graphics concepts
explained above, and serves as a summary of that information.

10 FOR I=0 TO 7:BI(I)=2^I:NEXT: REM SET UP ARRAY OF POWERS OF 2 (BIT VALUE)
20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
30 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE
40 A$="":FOR I=1 TO 37:A$=A$+"C":NEXT:PRINT CHR$(19);
50 FOR I=1 TO 27:PRINTA$;:NEXT:POKE2023,PEEK(2022): REM SET COLOR MAP
60 A$="":FOR I=1 TO 27:A$=A$+"@":NEXT:FOR I=32 TO 63 STEP 2
70 POKE648,I:PRINT CHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLEAR HI-RES SCREEN
80 FORY=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM
90 X=INT(160+40*SIN(Y/10)): REM SINE WAVE SHAPE
100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504): REM FIND HI-RES BYTE
110 POKEBY,PEEK(BY)OR(BI(NOT X AND 7)):NEXT Y:REM POKE IN BIT VALUE
120 GOTO 120: REM LET IT STAY ON SCREEN

As you can see, using BASIC to draw in bit-graphics mode is somewhat
slow and tedious.  Machine language is much more suiable for
bit-graphics plotting.  For a program that lets you replace some BASIC
ommands with high-res drawing commands, see the article "Hi-Res
Graphics Made Simple," by Paul F. Schatz, in COMPUTE!'s First Book of
Commodore 64 Sound and Graphics.

There is a slightly lower resolution bitmap graphics mode available
which offers up to four colors per 8 by 8 dot matrix.  To enable this
mode, you must set the multicolor bit (Bit 4 of 53270 ($D016)) while
in bitmap graphics mode.  For more information on this mode, see the
entry for the multicolor enable bit.

Bit 6.  This bit of this register enables extended background color
mode.  This mode lets you select the background color of each text
character, as well as its foreground color.  It is able to increase
the number of background colors displayed, by reducing the number of
characters that can be shown on the screen.

Normally, 256 character shapes can be displayed on the screen.  You
can use them either by using the PRINT statement or by POKEing a
display code from 0 to 255 into screen memory.  If the POKEing method
is used, you must also POKE a color code from 0 to 15 into color
memory (for example, if you POKE 1024,1, and POKE 55296,1, a white A
appears in the top-left corner of the screen).

The background color of the screen is determined by Background Color
Register 0, and you can change this color by POKEing a new value to
that register, which is located at 53281 ($D021).  For example, POKE
53281,0 creates a black background.

When extended background color mode is activated, however, only the
first 64 shapes found in the table of the screen display codes can be
displayed on the screen.  This group includes the letters of the
alphabet, numerals, and punctuation marks.  If you try to print on the
screen a character having a higher display code, the shape displayed
will be from the first group of 64, but that character's background
will no longer be determined by the register at 53281 ($D021).
Instead, it will be determined by one of the other background color
registers.

When in extended background color mode, characters having display
codes 64- 127 will take their background color from register 1, and
location 53282 ($D022).  These characters include various SHIFTed
characters.  Those with codes 128-191 will have their background
colors determined by register 2, at 53283 ($D023).  These include the
reversed numbers, letters, and punctuation marks.  Finally, characters
with codes 192-255 will use register 4, at 53284 ($D024).  These are
the reversed graphics characters.

Let's try an experiment to see just how this works.  First, we will
put the codes for four different letters in screen memory:

FOR I=0 TO 3:POKE 1230+(I*8),I*64+I:POKE 55502+(I*8),1:NEXT

Four white letters should appear on the screen, an A, a shifted A, a
reversed A, and a reversed, shifted A, all on a blue background.
Next, we will put colors in the other background color registers:

POKE 53282,0:POKE53283,2:POKE53284,5

This sets the registers to black, red, and green, respectively.
Finally, we will activate extended color mode by setting Bit 6 of the
VIC-II register at location 53265 to a 1.  The BASIC statement that
turns this mode on is:

POKE 53265,PEEK(53265) OR 64

Notice that two things happened.  First, all of the letters took on
the same shape, that of the letter A.  Second, each took on the
background color of a different color register.  To get things back to
normal, turn off extended color mode with this statement:

POKE 53265,PEEK(53265) AND 191

Extended color mode can be a very useful enhancement for your text
displays.  It allows the creation of windows.  These windows, because
of their different background colors, make different bodies of text
stand out as visually distinct from one another.  For example, a text
adventure program could have one window to display the player's
current location, one to show an inventory of possessions, and one to
accept commands for the next move.

In this mode the background color of these windows can be changed
instantly, just by POKEing a new value to the color register.  This
technique lends itself to some dramatic effects.  A window can be
flashed to draw attention to a particular message at certain times.
And varying the foreground color can make either the window or the
message vanish and reappear later.

There are, however, a couple of problems involved in using these
windows.  The character shape that you want to use might not have a
screen code of less than 64.  In that case, the only solution is to
define your own character set, with the shape you want in one of the
first 64 characters.

Another problem is that characters within a PRINT statement in your
program listing are not always going to look the same on the screen.
Having to figure out what letter to print to get the number 4 with a
certain background color can be very inconvenient.  The easiest
solution to this problem is to have a subroutine to the translation
for you.  Since letters will appear normally in window 1, and window 3
characters are simply window 1 characters reversed, you will only have
problems with characters in windows 2 and 4.  To conver these
characters, put your message in A$, and use the following subroutine:

500 B$="":FOR I=1 TO LEN(A$):B=ASC(MID$(A$,I,1))
510 B=B+32:IF B<96 THEN B=B+96
520 B$=B$+CHR$(B):NEXT I:RETURN

This subroutine converts each letter to its ASCII equivalent, adds the
proper offset, and converts it back to part of the new string, B$.
When the conversion is complete, B$ will hold the characters necessary
to PRINT that message in window 2.  For window 4, PRINT
CHR$(18);B$;CHR$(146).  This will turn reverse video on before
printing the string, and turn it off afterwards.

A practical demonstration of the technique for setting up windows is
given in the sample program below.  The program sets up three windows,
and shows them flashing, appearing and disappearing.

5 DIM RO$(25):RO$(0)=CHR$(19):FOR I=1 TO 24:RO$(I)=RO$(I-1)+CHR$(17):NEXT
10 POKE 53265,PEEK(53265) OR 64
20 POKE 53280,0:POKE 53281,0:POKE 53282,1:POKE 53283,2:POKE 53284,13
25 OP$=CHR$(160):FOR I=1 TO 4:OP$=OP$:NEXTI:PRINTCHR$(147);RO$(3);
30 FOR I=1 TO10:PRINTTAB(1);CHR$(18);"               ";TAB(23);OP$:NEXT
40 PRINT CHR$(146):PRINT:PRINT:FOR I=1 TO 4:PRINTOP$;OP$;OP$;OP$;OP$;:NEXTI
50 PRINT RO$(5);CHR$(5);CHR$(18);TAB(2);"A RED WINDOW"
60 PRINT CHR$(18);TAB(2);"COULD BE USED"
70 PRINT CHR$(18);TAB(2);"FOR ERROR"
80 PRINT CHR$(18);TAB(2);"MESSAGES"
100 A$="A GREEN WINDOW":GOSUB 300:PRINT RO$(5);CHR$(144);CHR$(18);TAB(24);B$
110 A$="COULD BE USED":GOSUB 300:PRINTTAB(24);CHR$(18);B$
120 A$="TO GIVE":GOSUB 300:PRINTTAB(24);CHR$(18);B$
130 A$="INSTRUCTIONS":GOSUB 300:PRINTTAB(24);CHR$(18);B
140 PRINT CHR$(31);RO$(19);
150 A$="  WHILE THE MAIN WINDOW COULD BE USED":GOSUB 300:PRINT B$
160 A$="  FOR ACCEPTING COMMANDS.":GOSUB 300:PRINT B$
170 FOR I=1 TO 5000:NEXT I:POKE 53284,0
180 FOR I=1 TO 5:FOR J=1 TO 300:NEXT J:POKE 53282,15
190 FOR J=1 TO 300:NEXT J:POKE 53282,1
200 NEXT I:POKE 53283,-2*(PEEK(53283)=240):POKE 53284,-13*(PEEK(53284)=240)
210 GOTO 180
300 B$="":FOR I=1TOLEN(A$):B=ASC(MID$(A$,I,1))
310 B=B+32:IFB<96THENB=B+96
320 B$=B$+CHR$(B):NEXTI:RETURN

Bit 7.  Bit 7 of this register is the high-order bit (Bit 8) of the
Raster Compare register at 53266 ($D012).  Even though it is located
here, it functions as part of that register (see the description below
for more information on the Raster Compare register).

Machine language programmers should note that its position here at Bit
7 allows testing this bit with the Negative flag.  Since scan lines
above number 256 are all off the screen, this provides an easy way to
delay changing the graphics display until the scan is in the vertical
blanking interval and the display is no longer being drawn:

LOOP  LDA $D011
      BPL LOOP

Sprites should always be moved when the raster is scanning off-screen,
because if they are moved while they are being scanned, their shapes
will waver slightly.

The BASIC equivalent of the program fragment above is the statement
WAIT 53265,128, but BASIC is usually not fast enough to execute the
next statement while still in the blanking interval.

53266          $D012         RASTER
Read Current Raster Scan Line/Write Line to Compare for Raster IRQ

The Raster Compare register has two different functions, depending on
whether you are reading from it or writing to it.  When this register
is read, it tells which screen line the electron beam is currently
scanning.

There are 262 horizontal lines which make up the American (NTSC)
standard display screen (312 lines in the European or PAL standard
screen).  Every one of these lines is scanned and updated 60 times per
second.  Only 200 of these lines (numbers 50-249) are part of the
visible display.

It is sometimes helpful to know just what line is being scanned,
because changing screen graphics on a particular line while that line
is being scanned may cause a slight disruption on the screen.  By
reading this register, it is possible for a machine language program
to wait until the scan is off the bottom of the screen before changing
the graphics display.

It is even possible for a machine language program to read this
register, and change the screen display when a certain scan line is
reached.  The program below uses this technique to change the
background color in midscreen, in order to show all 256 combinations
of foreground and background text colors at once.

40 FOR I=49152 TO 49188:READ A:POKE I,A:NEXT:POKE 53280,11
50 PRINT CHR$(147):FOR I=1024 TO I+1000:POKE I,160:POKE I+54272,11:NEXT I
60 FOR I=0 TO 15:FOR J=0 TO 15
70 P=1196+(48*I)+J:POKE P,J+I:POKE P+54272,J:NEXT J,I
80 PRINT TAB(15)CHR$(5)"COLOR CHART":FOR I=1 TO 19:PRINT:NEXT
85 PRINT "THIS CHART SHOWS ALL COMBINATIONS OF   "
86 PRINT "FOREGROUND AND BACKGROUND COLORS.      "
87 PRINT "FOREGROUND INCREASES FROM LEFT TO RIGHT"
88 PRINT "BACKGROUND INCREASES FROM TOP TO BOTTOM"
90 SYS 12*4096
100 DATA 169,90,133,251,169,0,141,33,208,162,15,120,173,17,208,48
105 DATA 251,173,18,208
110 DATA 197,251,208,249,238,33,208,24,105,8,133,251,202,16,233,48,219

Writing to this register designates the comparison value for the
Raster Compare Interrupt.  When that interrupt is enabled, a maskable
interrupt request will be issued every time the electron beam scan
reaches the scan line whose number was written here.  This is a much
more flexible technique for changing the display in midscreen than
reading this register as the sample program above does.  That
technique requires that the program continuously watch the Raster
Register, while the interrupt method will call the program when the
time is right to act.  For more information on raster interrupts, see
the entry for the Interrupt Mask Register (53274, $D01A).

It is very important to remember that this register requires nine
bits, and that this location only holds eight of those bits (the ninth
is Bit 7 of 53265 ($D011)).  If you forget to read or write to the
ninth bit, your results could be in error by a factor of 256.

For example, some early programs written to demonstrate the raster
interrupt took for granted that the ninth bit of this register would
be set to 0 on power-up.  When a later version of the Kernal changed
this initial value to a 1, their interrupt routines, which were
supposed to set the raster interrupt to occur at scan line number 150,
ended up setting it for line number 406 instead.  Since the scan line
numbers do not go up that high, no interrupt request was ever issued
and the program did not work.

Location Range: 53267-53268 ($D013-$D014)
Light Pen Registers

A light pen is an input device that can be plugged into joystick
Control Port #1.  It is shaped like a pen and has a light-sensitive
device at its tip that causes the trigger switch of the joystick port
to close at the moment the electron beam that updates the screen
display strikes it.  The VIC-II chip keeps track of where the beam is
when that happens, and records the corresponding horizontal and
vertical screen coordinates in the registers at these locations.

A program can read the position at which the light pen is held up to
the screen.  The values in these registers are updated once every
screen frame (60 times per second).  Once the switch is closed and a
value written to these registers, the registers are latched, and
subsequent switch closings during the same screen frame will not be
recorded.

A given light pen may not be entirely accurate (and the operator may
not have a steady hand).  It is probably wise to average the positions
