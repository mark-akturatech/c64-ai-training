# C64 PRG Chapter 4 - Programming Sound and Music, SID Overview

  184   PROGRAMMING SOUND AND MUSIC
~


    When you've had a little more practice with making music, then you can
  get a little more involved, by using the PEEK function. PEEK is a
  function that is equal to the value currently in the indicated memory
  location.
    X=PEEK(MEM)

    The value of the variable X is set equal to the current contents of
  memory location MEM.
    Of course, your programs include other BASIC commands, but for a full
  explanation of them, refer to the BASIC Statements section of this
  manual.
    Let's jump right in and try a simple program using only one of the
  three voices. Computer ready? Type NEW, then type in this program, and
  save it on your Commodore DATASSETTE(TM) or disk. Then, RUN it.

  EXAMPLE PROGRAM 1:
start tok64 page185.prg
  5 s=54272
  10 forl=stos+24:pokel,0:next:rem clear sound chip
  20 pokes+5,9:pokes+6,0
  30 pokes+24,15              :rem set volume to maximum
  40 readhf,lf,dr
  50 ifhf<0thenend
  60 pokes+1,hf:pokes,lf
  70 pokes+4,33
  80 fort=1todr:next
  90 pokes+4,32:fort=1to50:next
  100 goto40
  110 data25,177,250,28,214,250
  120 data25,177,250,25,177,250
  130 data25,177,125,28,214,125
  140 data32,94,750,25,177,250
  150 data28,214,250,19,63,250
  160 data19,63,250,19,63,250
  170 data21,154,63,24,63,63
  180 data25,177,250,24,63,125
  190 data19,63,250,-1,-1,-1
stop tok64

    Here's a line-by-line description of the program you've just typed in.
  Refer to it whenever you feel the need to investigate parts of the pro-
  gram that you don't understand completely.

                                          PROGRAMMING SOUND AND MUSIC   185
~


  LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 1:

  +--------+--------------------------------------------------------------+
  | Line(s)|                         Description                          |
  +--------+--------------------------------------------------------------+
  | 5      | Set S to start of sound chip.                                |
  | 10     | Clear all sound chip registers.                              |
  | 20     | Set Attack/Decay for voice 1 (A=O,D=9).                      |
  |        | Set Sustain/Release for voice 1 (S=O,R=O),                   |
  | 30     | Set volume at maximum.                                       |
  | 40     | Read high frequency, low frequency, duration of note.        |
  | 50     | When high frequency less than zero, song is over.            |
  | 60     | Poke high and low frequency of voice 1.                      |
  | 70     | Gate sawtooth waveform for voice 1.                          |
  | 80     | Timing loop for duration of note.                            |
  | 90     | Release sawtooth waveform for voice 1.                       |
  | 100    | Return for next note.                                        |
  | 110-180| Data for song: high frequency, low frequency, duration       |
  |        | (number of counts) for each note.                            |
  | 190    | Last note of song and negative Is signaling end of song.     |
  +--------+--------------------------------------------------------------+

  VOLUME CONTROL

    Chip register 24 contains the overall volume control. The volume can be
  set anywhere between 0 and 15. The other four bits are used for purposes
  we'll get into later. For now it is enough to know volume is 0 to 15.
  Look at line 30 to see how it's set in Example Program 1.

  FREQUENCIES OF SOUND WAVES

    Sound is created by the movement of air in waves. Think of throwing a
  stone into a pool and seeing the waves radiate outward. When similar
  waves are created in air, we hear it. If we measure the time between one
  peak of a wave and the next, we find the number of seconds for one cycle
  of the wave (n = number of seconds). The reciprocal of this number (1/n)
  gives you the cycles per second. Cycles per second are more commonly
  known as the frequency. The highness or lowness of a sound (pitch) is
  determined by the frequency of the sound waves produced.
    The sound generator in your Commodore computer uses two locations to
  determine the frequency. Appendix E gives you the frequency values you
  need to reproduce a full eight octaves of musical notes. To create a

  186   PROGRAMMING SOUND AND MUSIC
~


  frequency other than the ones listed in the note table use "Fout" (fre-
  quency output) and the following formula to represent the frequency (Fn)
  of the sound you want to create. Remember that each note requires both a
  high and a low frequency number.

             Fn = Fout/.06097

    Once you've figured out what Fn is for your "new" note the next step is
  to create the high and low frequency values for that note. To do this you
  must first round off Fn so that any numbers to the right of the decimal
  point are left off. You are now left with an integer value. Now you can
  set the high frequency location (Fhi) by using the formula
  Fhi=INT(Fn/256) and the low frequency location (Flo) should be
  Flo=Fn-(256*Fhi).
    At this point you have already played with one voice of your computer.
  If you wanted to stop here you could find a copy of your favorite tune
  and become the maestro conducting your own computer orchestra in your "at
  home" concert hall.

  USING MULTIPLE VOICES

    Your Commodore computer has three independently controlled voices
  (oscillators). Our first example program used only one of them. later on,
  you'll learn how to change the quality of the sound made by the voices.
  But right now, let's get all three voices singing.
    This example program shows you one way to translate sheet music for
  your computer orchestra. Try typing it in, and then SAVE it on your
  DATASSETTE(TM) or disk. Don't forget to type NEW before typing in this
  program.

  EXAMPLE PROGRAM 2:

start tok64 page187.prg
  10 s=54272:forl=stos+24:pokel,0:next
  20 dimh(2,200),l(2,200),c(2,200)
  30 dimfq(11)
  40 v(0)=17:v(1)=65:v(2)=33
  50 pokes+10,8:pokes+22,128:pokes+23,244
  60 fori=0to11:readfq(i):next
  100 fork=0to2
  110 i=0
  120 readnm




  130 ifnm=0then250
  140 wa=v(k):wb=wa-1:ifnm<0thennm=-nm:wa=0:wb=0
  150 dr%nm/128:oc%=(nm-128*dr%)/16
  160 nt=nm-128*dr%-16*oc%
  170 fr=fq(nt)
  180 ifoc%=7then200
  190 forj=6tooc%step-1:fr=fr/2:next
  200 hf%=fr/256:lf%=fr-256*hf%
  210 ifdr%=1thenh(k,i)=hf%:l(k,i)=lf%:c(k,i)=wa:i=i+1:goto120
  220 forj=1todr%-1:h(k,i)=hf%:l(k,i)=lf%:c(k,i)=wa:i=i+1:next
  230 h(k,i)=hf%:l(k,i)=lf%:c(k,i)=wb
  240 i=i+1:goto120
  250 ifi>imthenim=i
  260 next
  500 pokes+5,0:pokes+6,240
  510 pokes+12,85:pokes+13,133
  520 pokes+19,10:pokes+20,197
  530 pokes+24,31
  540 fori=0toim
  550 pokes,l(0,i):pokes+7,l(1,i):pokes+14,l(2,i)
  560 pokes+1,h(0,i):pokes+8,h(1,i):pokes+15,h(2,i)
  570 pokes+4,c(0,i):pokes+11,c(1,i):pokes+18,c(2,i)
  580 fort=1to80:next:next
  590 fort=1to200:next:pokes+24,0
  600 data34334,36376,38539,40830
  610 data43258,45830,48556,51443
  620 data54502,57743,61176,64814
  1000 data594,594,594,596,596,1618,587,592,587.585,331,336
  1010 data1097,583,585,585,585,587,587,1609,585,331,337,594,594,593
  1020 data1618,594,596,594,592,587,1616,587,585,331,336,841,327
  1999 data1607,0
  2000 data583,585,583,583,327,329,1611,583,585,578,578,578
  2010 data196,198,583,326,578,326,327,329,327,329,326,578,583
  2020 data1606,582,322,324,582,587,329,327,1606,583,327,329,587,331,329
  2999 data329,328,1609,578,834,324,322,327,585,1602,0
  3000 data567,566,567,304,306,308,310,1591,567,311,310,567
  3010 data306,304,299,308,304,171,176,306,291,551,306,308
  3020 data310,308,310,306,295,297,299,304,1586,562,567,310,315,311
  3030 data308,313,297,1586,567,560,311,309,308,309,306,308
  3999 data1577,299,295,306,310,311,304,562,546,1575,0
stop tok64



  188   PROGRAMMING SOUND AND MUSIC
~


    Here is a line,-by-line explanation of Example Program 2. For now, we
  are interested in how the three voices are controlled.

  LINE-BY-LINE EXPLANATION OF EXAMPLE PROGRAM 2:

  +---------+-------------------------------------------------------------+
  | Line(s) |                       Description                           |
  +---------+-------------------------------------------------------------+
  | 10      | Set S equal to start of sound chip and clear all sound      |
  |         | chip registers.                                             |
  | 20      | Dimension arrays to contain activity of song, 1/16th of a   |
  |         | measure per location.                                       |
  | 30      | Dimension array to contain base frequency for each note.    |
  | 40      | Store waveform control byte for each voice.                 |
  | 50      | Set high pulse width for voice 2.                           |
  |         | Set high frequency for filter cutoff.                       |
  |         | Set resonance for filter and filter voice 3.                |
  | 60      | Read in base frequency for each note.                       |
  | 100     | Begin decoding loop for each voice.                         |
  | 110     | Initialize pointer to activity array.                       |
  | 120     | Read coded note.                                            |
  | 130     | If coded note is zero, then next voice.                     |
  | 140     | Set waveform controls to proper voice.                      |
  |         | If silence, set waveform controls to 0.                     |
  | 150     | Decode duration and octave.                                 |
  | 160     | Decode note.                                                |
  | 170     | Get base frequency for this note.                           |
  | 180     | If highest octave, skip division loop.                      |
  | 190     | Divide base frequency by 2 appropriate number of times.     |
  | 200     | Get high and low frequency bytes.                           |
  | 210     | If sixteenth note, set activity array: high frequency, low  |
  |         | frequency, and waveform control (voice on).                 |
  | 220     | For all but last beat of note, set activity array: high     |
  |         | frequency, low frequency, waveform control (voice on).      |
  | 230     | For last beat of note, set activity array: high frequency,  |
  |         | low frequency, waveform control (voice off).                |
  | 240     | Increment pointer to activity array. Get next note.         |
  | 250     | If longer than before, reset number of activities.          |
  | 260     | Go back for next voice.                                     |
  | 500     | Set Attack/Decay for voice 1 (A=0, D=0).                    |
  |         | Set Sustain/Release for voice 1 (S=15, R=0).                |


                                          PROGRAMMING SOUND AND MUSIC   189
~


  +---------+-------------------------------------------------------------+
  | Line(s) |                       Description                           |
  +---------+-------------------------------------------------------------+
  | 510     | Set Attack/Decay for voice 2 (A=5, D=5).                    |
  |         | Set Sustain/Release for voice 2 (S=8, R=5).                 |
  | 520     | Set Attack/Decay for voice 3 (A=O, D=10).                   |
  |         | Set Sustain/Release for voice 3 (S=12, R=5).                |
  | 530     | Set volume 15, low-pass filtering.                          |
  | 540     | Start loop for every 1/16th of a measure.                   |
  | 550     | POKE low frequency from activity array for all voices.      |
  | 560     | POKE high frequency from activity array for all voices.     |
  | 570     | POKE waveform control from activity array for all voices.   |
  | 580     | Timing loop for 1/16th of a measure and back for next       |
  |         | 1/16th measure.                                             |
  | 590     | Pause, then turn off volume.                                |
  | 600-620 | Base frequency data.                                        |
  |1000-1999| Voice 1 data.                                               |
  |2000-2999| Voice 2 data.                                               |
  |3000-3999| Voice 3 data.                                               |
  +-----------------------------------------------------------------------+

    The values used in the data statements were found by using the note
  table in Appendix E and the chart below:


                    +-----------------+------------+
                    |   NOTE TYPE     |  DURATION  |
                    +-----------------+------------+
                    |        1/16     |     128    |
                    |        1/8      |     256    |
                    | DOTTED 1/8      |     384    |
                    |        1/4      |     512    |
                    |    1/4+1/16     |     640    |
                    | DOTTED 1/4      |     768    |
                    |        1/2      |    1024    |
                    |    1/2+1/16     |    1152    |
                    |    1/2+1/8      |    1280    |
                    | DOTTED 1/2      |    1536    |
                    |  WHOLE          |    2048    |
                    +-----------------+------------+



