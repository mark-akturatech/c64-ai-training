# C64 BASIC ROM Disassembly $B700-$B8FF - String Concatenation, Garbage Collection

.,B700 20 61 B7 JSR $B761       pull string data and byte parameter from stack
                                return pointer in descriptor, byte in A (and X), Y=0
.,B703 D1 50    CMP ($50),Y     compare byte parameter with string length
.,B705 98       TYA             clear A
.,B706 90 04    BCC $B70C       branch if string length > byte parameter
.,B708 B1 50    LDA ($50),Y     else make parameter = length
.,B70A AA       TAX             copy to byte parameter copy
.,B70B 98       TYA             clear string start offset
.,B70C 48       PHA             save string start offset
.,B70D 8A       TXA             copy byte parameter (or string length if <)
.,B70E 48       PHA             save string length
.,B70F 20 7D B4 JSR $B47D       make string space A bytes long
.,B712 A5 50    LDA $50         get descriptor pointer low byte
.,B714 A4 51    LDY $51         get descriptor pointer high byte
.,B716 20 AA B6 JSR $B6AA       pop (YA) descriptor off stack or from top of string space
                                returns with A = length, X = pointer low byte,
                                Y = pointer high byte
.,B719 68       PLA             get string length back
.,B71A A8       TAY             copy length to Y
.,B71B 68       PLA             get string start offset back
.,B71C 18       CLC             clear carry for add
.,B71D 65 22    ADC $22         add start offset to string start pointer low byte
.,B71F 85 22    STA $22         save string start pointer low byte
.,B721 90 02    BCC $B725       branch if no overflow
.,B723 E6 23    INC $23         else increment string start pointer high byte
.,B725 98       TYA             copy length to A
.,B726 20 8C B6 JSR $B68C       store string from pointer to utility pointer
.,B729 4C CA B4 JMP $B4CA       check space on descriptor stack then put string address
                                and length on descriptor stack and update stack pointers

                                *** perform RIGHT$()
.,B72C 20 61 B7 JSR $B761       pull string data and byte parameter from stack
                                return pointer in descriptor, byte in A (and X), Y=0
.,B72F 18       CLC             clear carry for add-1
.,B730 F1 50    SBC ($50),Y     subtract string length
.,B732 49 FF    EOR #$FF        invert it (A=LEN(expression$)-l)
.,B734 4C 06 B7 JMP $B706       go do rest of LEFT$()

                                *** perform MID$()
.,B737 A9 FF    LDA #$FF        set default length = 255
.,B739 85 65    STA $65         save default length
.,B73B 20 79 00 JSR $0079       scan memory
.,B73E C9 29    CMP #$29        compare with ")"
.,B740 F0 06    BEQ $B748       branch if = ")" (skip second byte get)
.,B742 20 FD AE JSR $AEFD       scan for ",", else do syntax error then warm start
.,B745 20 9E B7 JSR $B79E       get byte parameter
.,B748 20 61 B7 JSR $B761       pull string data and byte parameter from stack
                                return pointer in descriptor, byte in A (and X), Y=0
.,B74B F0 4B    BEQ $B798       if null do illegal quantity error then warm start
.,B74D CA       DEX             decrement start index
.,B74E 8A       TXA             copy to A
.,B74F 48       PHA             save string start offset
.,B750 18       CLC             clear carry for sub-1
.,B751 A2 00    LDX #$00        clear output string length
.,B753 F1 50    SBC ($50),Y     subtract string length
.,B755 B0 B6    BCS $B70D       if start>string length go do null string
.,B757 49 FF    EOR #$FF        complement -length
.,B759 C5 65    CMP $65         compare byte parameter
.,B75B 90 B1    BCC $B70E       if length>remaining string go do RIGHT$
.,B75D A5 65    LDA $65         get length byte
.,B75F B0 AD    BCS $B70E       go do string copy, branch always

                                *** pull string data and byte parameter from stack
                                return pointer in descriptor, byte in A (and X), Y=0
.,B761 20 F7 AE JSR $AEF7       scan for ")", else do syntax error then warm start
.,B764 68       PLA             pull return address low byte
.,B765 A8       TAY             save return address low byte
.,B766 68       PLA             pull return address high byte
.,B767 85 55    STA $55         save return address high byte
.,B769 68       PLA             dump call to function vector low byte
.,B76A 68       PLA             dump call to function vector high byte
.,B76B 68       PLA             pull byte parameter
.,B76C AA       TAX             copy byte parameter to X
.,B76D 68       PLA             pull string pointer low byte
.,B76E 85 50    STA $50         save it
.,B770 68       PLA             pull string pointer high byte
.,B771 85 51    STA $51         save it
.,B773 A5 55    LDA $55         get return address high byte
.,B775 48       PHA             back on stack
.,B776 98       TYA             get return address low byte
.,B777 48       PHA             back on stack
.,B778 A0 00    LDY #$00        clear index
.,B77A 8A       TXA             copy byte parameter
.,B77B 60       RTS             

                                *** perform LEN()
.,B77C 20 82 B7 JSR $B782       evaluate string, get length in A (and Y)
.,B77F 4C A2 B3 JMP $B3A2       convert Y to byte in FAC1 and return

                                *** evaluate string, get length in Y
.,B782 20 A3 B6 JSR $B6A3       evaluate string
.,B785 A2 00    LDX #$00        set data type = numeric
.,B787 86 0D    STX $0D         clear data type flag, $FF = string, $00 = numeric
.,B789 A8       TAY             copy length to Y
.,B78A 60       RTS             

                                *** perform ASC()
.,B78B 20 82 B7 JSR $B782       evaluate string, get length in A (and Y)
.,B78E F0 08    BEQ $B798       if null do illegal quantity error then warm start
.,B790 A0 00    LDY #$00        set index to first character
.,B792 B1 22    LDA ($22),Y     get byte
.,B794 A8       TAY             copy to Y
.,B795 4C A2 B3 JMP $B3A2       convert Y to byte in FAC1 and return

                                *** do illegal quantity error then warm start
.,B798 4C 48 B2 JMP $B248       do illegal quantity error then warm start

                                *** scan and get byte parameter
.,B79B 20 73 00 JSR $0073       increment and scan memory

                                *** get byte parameter
.,B79E 20 8A AD JSR $AD8A       evaluate expression and check is numeric, else do
                                type mismatch

                                *** evaluate byte expression, result in X
.,B7A1 20 B8 B1 JSR $B1B8       evaluate integer expression, sign check
.,B7A4 A6 64    LDX $64         get FAC1 mantissa 3
.,B7A6 D0 F0    BNE $B798       if not null do illegal quantity error then warm start
.,B7A8 A6 65    LDX $65         get FAC1 mantissa 4
.,B7AA 4C 79 00 JMP $0079       scan memory and return

                                *** perform VAL()
.,B7AD 20 82 B7 JSR $B782       evaluate string, get length in A (and Y)
.,B7B0 D0 03    BNE $B7B5       branch if not null string
                                string was null so set result = $00
.,B7B2 4C F7 B8 JMP $B8F7       clear FAC1 exponent and sign and return
.,B7B5 A6 7A    LDX $7A         get BASIC execute pointer low byte
.,B7B7 A4 7B    LDY $7B         get BASIC execute pointer high byte
.,B7B9 86 71    STX $71         save BASIC execute pointer low byte
.,B7BB 84 72    STY $72         save BASIC execute pointer high byte
.,B7BD A6 22    LDX $22         get string pointer low byte
.,B7BF 86 7A    STX $7A         save BASIC execute pointer low byte
.,B7C1 18       CLC             clear carry for add
.,B7C2 65 22    ADC $22         add string length
.,B7C4 85 24    STA $24         save string end low byte
.,B7C6 A6 23    LDX $23         get string pointer high byte
.,B7C8 86 7B    STX $7B         save BASIC execute pointer high byte
.,B7CA 90 01    BCC $B7CD       branch if no high byte increment
.,B7CC E8       INX             increment string end high byte
.,B7CD 86 25    STX $25         save string end high byte
.,B7CF A0 00    LDY #$00        set index to $00
.,B7D1 B1 24    LDA ($24),Y     get string end byte
.,B7D3 48       PHA             push it
.,B7D4 98       TYA             clear A
.,B7D5 91 24    STA ($24),Y     terminate string with $00
.,B7D7 20 79 00 JSR $0079       scan memory
.,B7DA 20 F3 BC JSR $BCF3       get FAC1 from string
.,B7DD 68       PLA             restore string end byte
.,B7DE A0 00    LDY #$00        clear index
.,B7E0 91 24    STA ($24),Y     put string end byte back

                                *** restore BASIC execute pointer from temp
.,B7E2 A6 71    LDX $71         get BASIC execute pointer low byte back
.,B7E4 A4 72    LDY $72         get BASIC execute pointer high byte back
.,B7E6 86 7A    STX $7A         save BASIC execute pointer low byte
.,B7E8 84 7B    STY $7B         save BASIC execute pointer high byte
.,B7EA 60       RTS             

                                *** get parameters for POKE/WAIT
.,B7EB 20 8A AD JSR $AD8A       evaluate expression and check is numeric, else do
                                type mismatch
.,B7EE 20 F7 B7 JSR $B7F7       convert FAC_1 to integer in temporary integer
.,B7F1 20 FD AE JSR $AEFD       scan for ",", else do syntax error then warm start
.,B7F4 4C 9E B7 JMP $B79E       get byte parameter and return

                                *** convert FAC_1 to integer in temporary integer
.,B7F7 A5 66    LDA $66         get FAC1 sign
.,B7F9 30 9D    BMI $B798       if -ve do illegal quantity error then warm start
.,B7FB A5 61    LDA $61         get FAC1 exponent
.,B7FD C9 91    CMP #$91        compare with exponent = 2^16
.,B7FF B0 97    BCS $B798       if >= do illegal quantity error then warm start
.,B801 20 9B BC JSR $BC9B       convert FAC1 floating to fixed
.,B804 A5 64    LDA $64         get FAC1 mantissa 3
.,B806 A4 65    LDY $65         get FAC1 mantissa 4
.,B808 84 14    STY $14         save temporary integer low byte
.,B80A 85 15    STA $15         save temporary integer high byte
.,B80C 60       RTS             

                                *** perform PEEK()
.,B80D A5 15    LDA $15         get line number high byte
.,B80F 48       PHA             save line number high byte
.,B810 A5 14    LDA $14         get line number low byte
.,B812 48       PHA             save line number low byte
.,B813 20 F7 B7 JSR $B7F7       convert FAC_1 to integer in temporary integer
.,B816 A0 00    LDY #$00        clear index
.,B818 B1 14    LDA ($14),Y     read byte
.,B81A A8       TAY             copy byte to A
.,B81B 68       PLA             pull byte
.,B81C 85 14    STA $14         restore line number low byte
.,B81E 68       PLA             pull byte
.,B81F 85 15    STA $15         restore line number high byte
.,B821 4C A2 B3 JMP $B3A2       convert Y to byte in FAC_1 and return

                                *** perform POKE
.,B824 20 EB B7 JSR $B7EB       get parameters for POKE/WAIT
.,B827 8A       TXA             copy byte to A
.,B828 A0 00    LDY #$00        clear index
.,B82A 91 14    STA ($14),Y     write byte
.,B82C 60       RTS             

                                *** perform WAIT
.,B82D 20 EB B7 JSR $B7EB       get parameters for POKE/WAIT
.,B830 86 49    STX $49         save byte
.,B832 A2 00    LDX #$00        clear mask
.,B834 20 79 00 JSR $0079       scan memory
.,B837 F0 03    BEQ $B83C       skip if no third argument
.,B839 20 F1 B7 JSR $B7F1       scan for "," and get byte, else syntax error then
                                warm start
.,B83C 86 4A    STX $4A         save EOR argument
.,B83E A0 00    LDY #$00        clear index
.,B840 B1 14    LDA ($14),Y     get byte via temporary integer (address)
.,B842 45 4A    EOR $4A         EOR with second argument       (mask)
.,B844 25 49    AND $49         AND with first argument        (byte)
.,B846 F0 F8    BEQ $B840       loop if result is zero
.,B848 60       RTS             

                                *** add 0.5 to FAC1 (round FAC1)
.,B849 A9 11    LDA #$11        set 0.5 pointer low byte
.,B84B A0 BF    LDY #$BF        set 0.5 pointer high byte
.,B84D 4C 67 B8 JMP $B867       add (AY) to FAC1

                                *** perform subtraction, FAC1 from (AY)
.,B850 20 8C BA JSR $BA8C       unpack memory (AY) into FAC2

                                *** perform subtraction, FAC1 from FAC2
.,B853 A5 66    LDA $66         get FAC1 sign (b7)
.,B855 49 FF    EOR #$FF        complement it
.,B857 85 66    STA $66         save FAC1 sign (b7)
.,B859 45 6E    EOR $6E         EOR with FAC2 sign (b7)
.,B85B 85 6F    STA $6F         save sign compare (FAC1 EOR FAC2)
.,B85D A5 61    LDA $61         get FAC1 exponent
.,B85F 4C 6A B8 JMP $B86A       add FAC2 to FAC1 and return
.,B862 20 99 B9 JSR $B999       shift FACX A times right (>8 shifts)
.,B865 90 3C    BCC $B8A3       go subtract mantissas

                                *** add (AY) to FAC1
.,B867 20 8C BA JSR $BA8C       unpack memory (AY) into FAC2

                                *** add FAC2 to FAC1
.,B86A D0 03    BNE $B86F       branch if FAC1 is not zero
.,B86C 4C FC BB JMP $BBFC       FAC1 was zero so copy FAC2 to FAC1 and return
                                FAC1 is non zero
.,B86F A6 70    LDX $70         get FAC1 rounding byte
.,B871 86 56    STX $56         save as FAC2 rounding byte
.,B873 A2 69    LDX #$69        set index to FAC2 exponent address
.,B875 A5 69    LDA $69         get FAC2 exponent
.,B877 A8       TAY             copy exponent
.,B878 F0 CE    BEQ $B848       exit if zero
.,B87A 38       SEC             set carry for subtract
.,B87B E5 61    SBC $61         subtract FAC1 exponent
.,B87D F0 24    BEQ $B8A3       if equal go add mantissas
.,B87F 90 12    BCC $B893       if FAC2 < FAC1 then go shift FAC2 right
                                else FAC2 > FAC1
.,B881 84 61    STY $61         save FAC1 exponent
.,B883 A4 6E    LDY $6E         get FAC2 sign (b7)
.,B885 84 66    STY $66         save FAC1 sign (b7)
.,B887 49 FF    EOR #$FF        complement A
.,B889 69 00    ADC #$00        +1, twos complement, carry is set
.,B88B A0 00    LDY #$00        clear Y
.,B88D 84 56    STY $56         clear FAC2 rounding byte
.,B88F A2 61    LDX #$61        set index to FAC1 exponent address
.,B891 D0 04    BNE $B897       branch always
                                FAC2 < FAC1
.,B893 A0 00    LDY #$00        clear Y
.,B895 84 70    STY $70         clear FAC1 rounding byte
.,B897 C9 F9    CMP #$F9        compare exponent diff with $F9
.,B899 30 C7    BMI $B862       branch if range $79-$F8
.,B89B A8       TAY             copy exponent difference to Y
.,B89C A5 70    LDA $70         get FAC1 rounding byte
.,B89E 56 01    LSR $01,X       shift FAC? mantissa 1
.,B8A0 20 B0 B9 JSR $B9B0       shift FACX Y times right
                                exponents are equal now do mantissa subtract
.,B8A3 24 6F    BIT $6F         test sign compare (FAC1 EOR FAC2)
.,B8A5 10 57    BPL $B8FE       if = add FAC2 mantissa to FAC1 mantissa and return
.,B8A7 A0 61    LDY #$61        set the Y index to FAC1 exponent address
.,B8A9 E0 69    CPX #$69        compare X to FAC2 exponent address
.,B8AB F0 02    BEQ $B8AF       if = continue, Y = FAC1, X = FAC2
.,B8AD A0 69    LDY #$69        else set the Y index to FAC2 exponent address
                                subtract the smaller from the bigger (take the sign of
                                the bigger)
.,B8AF 38       SEC             set carry for subtract
.,B8B0 49 FF    EOR #$FF        ones complement A
.,B8B2 65 56    ADC $56         add FAC2 rounding byte
.,B8B4 85 70    STA $70         save FAC1 rounding byte
.,B8B6 B9 04 00 LDA $0004,Y     get FACY mantissa 4
.,B8B9 F5 04    SBC $04,X       subtract FACX mantissa 4
.,B8BB 85 65    STA $65         save FAC1 mantissa 4
.,B8BD B9 03 00 LDA $0003,Y     get FACY mantissa 3
.,B8C0 F5 03    SBC $03,X       subtract FACX mantissa 3
.,B8C2 85 64    STA $64         save FAC1 mantissa 3
.,B8C4 B9 02 00 LDA $0002,Y     get FACY mantissa 2
.,B8C7 F5 02    SBC $02,X       subtract FACX mantissa 2
.,B8C9 85 63    STA $63         save FAC1 mantissa 2
.,B8CB B9 01 00 LDA $0001,Y     get FACY mantissa 1
.,B8CE F5 01    SBC $01,X       subtract FACX mantissa 1
.,B8D0 85 62    STA $62         save FAC1 mantissa 1

                                *** do ABS and normalise FAC1
.,B8D2 B0 03    BCS $B8D7       branch if number is +ve
.,B8D4 20 47 B9 JSR $B947       negate FAC1

                                *** normalise FAC1
.,B8D7 A0 00    LDY #$00        clear Y
.,B8D9 98       TYA             clear A
.,B8DA 18       CLC             clear carry for add
.,B8DB A6 62    LDX $62         get FAC1 mantissa 1
.,B8DD D0 4A    BNE $B929       if not zero normalise FAC1
.,B8DF A6 63    LDX $63         get FAC1 mantissa 2
.,B8E1 86 62    STX $62         save FAC1 mantissa 1
.,B8E3 A6 64    LDX $64         get FAC1 mantissa 3
.,B8E5 86 63    STX $63         save FAC1 mantissa 2
.,B8E7 A6 65    LDX $65         get FAC1 mantissa 4
.,B8E9 86 64    STX $64         save FAC1 mantissa 3
.,B8EB A6 70    LDX $70         get FAC1 rounding byte
.,B8ED 86 65    STX $65         save FAC1 mantissa 4
.,B8EF 84 70    STY $70         clear FAC1 rounding byte
.,B8F1 69 08    ADC #$08        add x to exponent offset
.,B8F3 C9 20    CMP #$20        compare with $20, max offset, all bits would be = 0
.,B8F5 D0 E4    BNE $B8DB       loop if not max

                                *** clear FAC1 exponent and sign
.,B8F7 A9 00    LDA #$00        clear A
.,B8F9 85 61    STA $61         set FAC1 exponent

                                *** save FAC1 sign
.,B8FB 85 66    STA $66         save FAC1 sign (b7)
.,B8FD 60       RTS             

                                *** add FAC2 mantissa to FAC1 mantissa
.,B8FE 65 56    ADC $56         add FAC2 rounding byte
