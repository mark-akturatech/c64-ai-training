# C64 KERNAL ROM Disassembly $E200-$E3FF - Keyboard Input

.,E200 20 0E E2 JSR $E20E       scan for ",byte", else do syntax error then warm start
.,E203 4C 9E B7 JMP $B79E       get byte parameter and return
                                exit function if [EOT] or ":"
.,E206 20 79 00 JSR $0079       scan memory
.,E209 D0 02    BNE $E20D       branch if not [EOL] or ":"
.,E20B 68       PLA             dump return address low byte
.,E20C 68       PLA             dump return address high byte
.,E20D 60       RTS             

                                *** scan for ",valid byte", else do syntax error then warm start
.,E20E 20 FD AE JSR $AEFD       scan for ",", else do syntax error then warm start

                                *** scan for valid byte, not [EOL] or ":", else do syntax error then warm start
.,E211 20 79 00 JSR $0079       scan memory
.,E214 D0 F7    BNE $E20D       exit if following byte
.,E216 4C 08 AF JMP $AF08       else do syntax error then warm start

                                *** get parameters for OPEN/CLOSE
.,E219 A9 00    LDA #$00        clear the filename length
.,E21B 20 BD FF JSR $FFBD       clear the filename
.,E21E 20 11 E2 JSR $E211       scan for valid byte, else do syntax error then warm start
.,E221 20 9E B7 JSR $B79E       get byte parameter, logical file number
.,E224 86 49    STX $49         save logical file number
.,E226 8A       TXA             copy logical file number to A
.,E227 A2 01    LDX #$01        set default device number, cassette
.,E229 A0 00    LDY #$00        set default command
.,E22B 20 BA FF JSR $FFBA       set logical, first and second addresses
.,E22E 20 06 E2 JSR $E206       exit function if [EOT] or ":"
.,E231 20 00 E2 JSR $E200       scan and get byte, else do syntax error then warm start
.,E234 86 4A    STX $4A         save device number
.,E236 A0 00    LDY #$00        clear command
.,E238 A5 49    LDA $49         get logical file number
.,E23A E0 03    CPX #$03        compare device number with screen
.,E23C 90 01    BCC $E23F       branch if less than screen
.,E23E 88       DEY             else decrement command
.,E23F 20 BA FF JSR $FFBA       set logical, first and second addresses
.,E242 20 06 E2 JSR $E206       exit function if [EOT] or ":"
.,E245 20 00 E2 JSR $E200       scan and get byte, else do syntax error then warm start
.,E248 8A       TXA             copy command to A
.,E249 A8       TAY             copy command to Y
.,E24A A6 4A    LDX $4A         get device number
.,E24C A5 49    LDA $49         get logical file number
.,E24E 20 BA FF JSR $FFBA       set logical, first and second addresses
.,E251 20 06 E2 JSR $E206       exit function if [EOT] or ":"
.,E254 20 0E E2 JSR $E20E       scan for ",byte", else do syntax error then warm start

                                *** set filename
.,E257 20 9E AD JSR $AD9E       evaluate expression
.,E25A 20 A3 B6 JSR $B6A3       evaluate string
.,E25D A6 22    LDX $22         get string pointer low byte
.,E25F A4 23    LDY $23         get string pointer high byte
.,E261 4C BD FF JMP $FFBD       set the filename and return

                                *** perform COS()
.,E264 A9 E0    LDA #$E0        set pi/2 pointer low byte
.,E266 A0 E2    LDY #$E2        set pi/2 pointer high byte
.,E268 20 67 B8 JSR $B867       add (AY) to FAC1

                                *** perform SIN()
.,E26B 20 0C BC JSR $BC0C       round and copy FAC1 to FAC2
.,E26E A9 E5    LDA #$E5        set 2*pi pointer low byte
.,E270 A0 E2    LDY #$E2        set 2*pi pointer high byte
.,E272 A6 6E    LDX $6E         get FAC2 sign (b7)
.,E274 20 07 BB JSR $BB07       divide by (AY) (X=sign)
.,E277 20 0C BC JSR $BC0C       round and copy FAC1 to FAC2
.,E27A 20 CC BC JSR $BCCC       perform INT()
.,E27D A9 00    LDA #$00        clear byte
.,E27F 85 6F    STA $6F         clear sign compare (FAC1 EOR FAC2)
.,E281 20 53 B8 JSR $B853       perform subtraction, FAC2 from FAC1
.,E284 A9 EA    LDA #$EA        set 0.25 pointer low byte
.,E286 A0 E2    LDY #$E2        set 0.25 pointer high byte
.,E288 20 50 B8 JSR $B850       perform subtraction, FAC1 from (AY)
.,E28B A5 66    LDA $66         get FAC1 sign (b7)
.,E28D 48       PHA             save FAC1 sign
.,E28E 10 0D    BPL $E29D       branch if +ve
                                FAC1 sign was -ve
.,E290 20 49 B8 JSR $B849       add 0.5 to FAC1 (round FAC1)
.,E293 A5 66    LDA $66         get FAC1 sign (b7)
.,E295 30 09    BMI $E2A0       branch if -ve
.,E297 A5 12    LDA $12         get the comparison evaluation flag
.,E299 49 FF    EOR #$FF        toggle flag
.,E29B 85 12    STA $12         save the comparison evaluation flag
.,E29D 20 B4 BF JSR $BFB4       do - FAC1
.,E2A0 A9 EA    LDA #$EA        set 0.25 pointer low byte
.,E2A2 A0 E2    LDY #$E2        set 0.25 pointer high byte
.,E2A4 20 67 B8 JSR $B867       add (AY) to FAC1
.,E2A7 68       PLA             restore FAC1 sign
.,E2A8 10 03    BPL $E2AD       branch if was +ve
                                else correct FAC1
.,E2AA 20 B4 BF JSR $BFB4       do - FAC1
.,E2AD A9 EF    LDA #$EF        set pointer low byte to counter
.,E2AF A0 E2    LDY #$E2        set pointer high byte to counter
.,E2B1 4C 43 E0 JMP $E043       ^2 then series evaluation and return

                                *** perform TAN()
.,E2B4 20 CA BB JSR $BBCA       pack FAC1 into $57
.,E2B7 A9 00    LDA #$00        clear A
.,E2B9 85 12    STA $12         clear the comparison evaluation flag
.,E2BB 20 6B E2 JSR $E26B       perform SIN()
.,E2BE A2 4E    LDX #$4E        set sin(n) pointer low byte
.,E2C0 A0 00    LDY #$00        set sin(n) pointer high byte
.,E2C2 20 F6 E0 JSR $E0F6       pack FAC1 into (XY)
.,E2C5 A9 57    LDA #$57        set n pointer low byte
.,E2C7 A0 00    LDY #$00        set n pointer high byte
.,E2C9 20 A2 BB JSR $BBA2       unpack memory (AY) into FAC1
.,E2CC A9 00    LDA #$00        clear byte
.,E2CE 85 66    STA $66         clear FAC1 sign (b7)
.,E2D0 A5 12    LDA $12         get the comparison evaluation flag
.,E2D2 20 DC E2 JSR $E2DC       save flag and go do series evaluation
.,E2D5 A9 4E    LDA #$4E        set sin(n) pointer low byte
.,E2D7 A0 00    LDY #$00        set sin(n) pointer high byte
.,E2D9 4C 0F BB JMP $BB0F       convert AY and do (AY)/FAC1

                                *** save comparison flag and do series evaluation
.,E2DC 48       PHA             save comparison flag
.,E2DD 4C 9D E2 JMP $E29D       add 0.25, ^2 then series evaluation

                                *** constants and series for SIN/COS(n)
.:E2E0 81 49 0F DA A2           1.570796371, pi/2, as floating number
.:E2E5 83 49 0F DA A2           6.28319, 2*pi, as floating number
.:E2EA 7F 00 00 00 00           0.25
.:E2EF 05                       series counter
.:E2F0 84 E6 1A 2D 1B           -14.3813907
.:E2F5 86 28 07 FB F8            42.0077971
.:E2FA 87 99 68 89 01           -76.7041703
.:E2FF 87 23 35 DF E1            81.6052237
.:E304 86 A5 5D E7 28           -41.3147021
.:E309 83 49 0F DA A2             6.28318531   2*pi

                                *** perform ATN()
.,E30E A5 66    LDA $66         get FAC1 sign (b7)
.,E310 48       PHA             save sign
.,E311 10 03    BPL $E316       branch if +ve
.,E313 20 B4 BF JSR $BFB4       else do - FAC1
.,E316 A5 61    LDA $61         get FAC1 exponent
.,E318 48       PHA             push exponent
.,E319 C9 81    CMP #$81        compare with 1
.,E31B 90 07    BCC $E324       branch if FAC1 < 1
.,E31D A9 BC    LDA #$BC        pointer to 1 low byte
.,E31F A0 B9    LDY #$B9        pointer to 1 high byte
.,E321 20 0F BB JSR $BB0F       convert AY and do (AY)/FAC1
.,E324 A9 3E    LDA #$3E        pointer to series low byte
.,E326 A0 E3    LDY #$E3        pointer to series high byte
.,E328 20 43 E0 JSR $E043       ^2 then series evaluation
.,E32B 68       PLA             restore old FAC1 exponent
.,E32C C9 81    CMP #$81        compare with 1
.,E32E 90 07    BCC $E337       branch if FAC1 < 1
.,E330 A9 E0    LDA #$E0        pointer to (pi/2) low byte
.,E332 A0 E2    LDY #$E2        pointer to (pi/2) low byte
.,E334 20 50 B8 JSR $B850       perform subtraction, FAC1 from (AY)
.,E337 68       PLA             restore FAC1 sign
.,E338 10 03    BPL $E33D       exit if was +ve
.,E33A 4C B4 BF JMP $BFB4       else do - FAC1 and return
.,E33D 60       RTS             

                                *** series for ATN(n)
.:E33E 0B                       series counter
.:E33F 76 B3 83 BD D3           -6.84793912E-04
.:E344 79 1E F4 A6 F5            4.85094216E-03
.:E349 7B 83 FC B0 10            -.0161117015
.:E34E 7C 0C 1F 67 CA             .034209638
.:E353 7C DE 53 CB C1            -.054279133
.:E358 7D 14 64 70 4C             .0724571965
.:E35D 7D B7 EA 51 7A            -.0898019185
.:E362 7D 63 30 88 7E             .110932413
.:E367 7E 92 44 99 3A            -.142839808
.:E36C 7E 4C CC 91 C7             .19999912
.:E371 7F AA AA AA 13            -.333333316
.:E376 81 00 00 00 00            1

                                *** BASIC warm start entry point
.,E37B 20 CC FF JSR $FFCC       close input and output channels
.,E37E A9 00    LDA #$00        clear A
.,E380 85 13    STA $13         set current I/O channel, flag default
.,E382 20 7A A6 JSR $A67A       flush BASIC stack and clear continue pointer
.,E385 58       CLI             enable the interrupts
.,E386 A2 80    LDX #$80        set -ve error, just do warm start
.,E388 6C 00 03 JMP ($0300)     go handle error message, normally $E38B
.,E38B 8A       TXA             copy the error number
.,E38C 30 03    BMI $E391       if -ve go do warm start
.,E38E 4C 3A A4 JMP $A43A       else do error #X then warm start
.,E391 4C 74 A4 JMP $A474       do warm start

                                *** BASIC cold start entry point
.,E394 20 53 E4 JSR $E453       initialise the BASIC vector table
.,E397 20 BF E3 JSR $E3BF       initialise the BASIC RAM locations
.,E39A 20 22 E4 JSR $E422       print the start up message and initialise the memory
                                pointers
                                not ok ??
.,E39D A2 FB    LDX #$FB        value for start stack
.,E39F 9A       TXS             set stack pointer
.,E3A0 D0 E4    BNE $E386       do "READY." warm start, branch always

                                *** character get subroutine for zero page
                                the target address for the LDA $EA60 becomes the BASIC execute pointer once the
                                block is copied to its destination, any non zero page address will do at assembly
                                time, to assemble a three byte instruction. $EA60 is RTS, NOP.
                                page 0 initialisation table from $0073
                                increment and scan memory
.,E3A2 E6 7A    INC $7A         increment BASIC execute pointer low byte
.,E3A4 D0 02    BNE $E3A8       branch if no carry
                                else
.,E3A6 E6 7B    INC $7B         increment BASIC execute pointer high byte
                                page 0 initialisation table from $0079
                                scan memory
.,E3A8 AD 60 EA LDA $EA60       get byte to scan, address set by call routine
.,E3AB C9 3A    CMP #$3A        compare with ":"
.,E3AD B0 0A    BCS $E3B9       exit if>=
                                page 0 initialisation table from $0080
                                clear Cb if numeric
.,E3AF C9 20    CMP #$20        compare with " "
.,E3B1 F0 EF    BEQ $E3A2       if " " go do next
.,E3B3 38       SEC             set carry for SBC
.,E3B4 E9 30    SBC #$30        subtract "0"
.,E3B6 38       SEC             set carry for SBC
.,E3B7 E9 D0    SBC #$D0        subtract -"0"
                                clear carry if byte = "0"-"9"
.,E3B9 60       RTS             

                                *** spare bytes, not referenced
.:E3BA 80 4F C7 52 58           0.811635157

                                *** initialise BASIC RAM locations
.,E3BF A9 4C    LDA #$4C        opcode for JMP
.,E3C1 85 54    STA $54         save for functions vector jump
.,E3C3 8D 10 03 STA $0310       save for USR() vector jump
                                set USR() vector to illegal quantity error
.,E3C6 A9 48    LDA #$48        set USR() vector low byte
.,E3C8 A0 B2    LDY #$B2        set USR() vector high byte
.,E3CA 8D 11 03 STA $0311       save USR() vector low byte
.,E3CD 8C 12 03 STY $0312       save USR() vector high byte
.,E3D0 A9 91    LDA #$91        set fixed to float vector low byte
.,E3D2 A0 B3    LDY #$B3        set fixed to float vector high byte
.,E3D4 85 05    STA $05         save fixed to float vector low byte
.,E3D6 84 06    STY $06         save fixed to float vector high byte
.,E3D8 A9 AA    LDA #$AA        set float to fixed vector low byte
.,E3DA A0 B1    LDY #$B1        set float to fixed vector high byte
.,E3DC 85 03    STA $03         save float to fixed vector low byte
.,E3DE 84 04    STY $04         save float to fixed vector high byte
                                copy the character get subroutine from $E3A2 to $0074
.,E3E0 A2 1C    LDX #$1C        set the byte count
.,E3E2 BD A2 E3 LDA $E3A2,X     get a byte from the table
.,E3E5 95 73    STA $73,X       save the byte in page zero
.,E3E7 CA       DEX             decrement the count
.,E3E8 10 F8    BPL $E3E2       loop if not all done
                                clear descriptors, strings, program area and mamory pointers
.,E3EA A9 03    LDA #$03        set the step size, collecting descriptors
.,E3EC 85 53    STA $53         save the garbage collection step size
.,E3EE A9 00    LDA #$00        clear A
.,E3F0 85 68    STA $68         clear FAC1 overflow byte
.,E3F2 85 13    STA $13         clear the current I/O channel, flag default
.,E3F4 85 18    STA $18         clear the current descriptor stack item pointer high byte
.,E3F6 A2 01    LDX #$01        set X
.,E3F8 8E FD 01 STX $01FD       set the chain link pointer low byte
.,E3FB 8E FC 01 STX $01FC       set the chain link pointer high byte
.,E3FE A2 19    LDX #$19        initial the value for descriptor stack
