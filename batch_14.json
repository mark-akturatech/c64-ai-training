[{"id": "map-FE18", "address_start": 65048, "address_end": 65048, "hex_start": "$FE18", "hex_end": "$FE18", "label": "SETMSG", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65048         $FE18          SETMSG\nSet the Message Control Flag\n\nThis documented Kernal routine can be entered through its jump table\nvector at 65424 ($FF90).\n\nThe routine controls the printing of error messages and control\nmessages by the Kernal.  It Bit 6 is seto to 1 (bit value of 64),\nKernal control messages can be printed.  These messages include\nSEARCHING FOR, LOADING, and the like.  If Bit 6 is cleared to 0, these\nmessages will not be printed (BASIC will clear this bit when a program\nis running so that the messages do not appear when I/O is performed\nfrom a program).  Setting Bit 6 will not suppress the PRESS PLAY ON\nTAPE or PRESS PLAY & RECORD messages, however.\n\nIf Bit 7 is set to 1 (bit value of 128), Kernal error messages can be\nprinted.  If Bit 7 is set to 0, those error messages (for example, I/O\nERROR #nn) will be suppressed.  Note that BASIC has its own set of\nerror messages (such as FILE NOT FOUND ERROR) which it uses in\npreference to the Kernal's message.\n\n65057         $E21           SETTMO\nSet Time-Out Flag for IEEE Bus\n\nThis documented Kernal routine can be entered fromthe jump table at\n65442 ($FFA2).\n\nThe routine sets the time-out flag for the IEEE bus.  When timeouts\nare enabled, the Commodore will wait for a device for 64 milliseconds,\nand if it does not receive a response to its signal it will issue a\ntime-out error.  Loading the Accumulator with a value less than 128\nand calling this routine will enable time-outs, while using a value\nover 128 will disable time-outs.\n\nThis routine is for use only with the Commodore IEEE add-on card,\nwhich at the time of this writing was not yet available."}, {"id": "map-FE25", "address_start": 65061, "address_end": 65061, "hex_start": "$FE25", "hex_end": "$FE25", "label": "MEMTOP", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65061         $FE25          MEMTOP\nRead/Set Top of RAM Pointer\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65433 ($FF99).\n\nIt can be used to either read or set the top of RAM pointer.  If\ncalled with the Carry flag set, the address in the pointer will be\nloaded into the .X and .Y registers.  If called with the Carry flag\ncleared, the pointer will be changed to the address found in the .X\nand .Y registers."}, {"id": "map-FE34", "address_start": 65076, "address_end": 65076, "hex_start": "$FE34", "hex_end": "$FE34", "label": "MEMBOT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65076         $FE34          MEMBOT\nRead/Set Bottom of RAM Pointer\n\nThis is a documented Kernal routine, which can be entered through the\njump table at location 65436 ($FF9C).\n\nIt can be used to either read or set the bottom of RAM pointer.  If\ncalled with the Carry flag set, the address in the pointer willbe\nloaded into the .X and .Y registers.  If called with the Carry flag\ncleared, the pointer will be changed to the address found in the .X\nand .Y registers."}, {"id": "map-FE43", "address_start": 65091, "address_end": 65091, "hex_start": "$FE43", "hex_end": "$FE43", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65091         $FE43\nNMI Interrupt Entry Point\n\nThis routine is the NMI interrupt handler entry, which is pointed to\nby the hardware NMI vector at 65530 ($FFFA).\n\nAny time an NMI interrupt occurs, the Interrupt disable flag will be\nset, and the routine will jump through the RAM vector at 792 ($318),\nwhich ordinarily points to the continuation of this routine.  The\nstandard handler first checks to see if the NMI was caused by the\nRS-232 device.  If not, the RESTORE key is assumed.  The routine\nchecks for a cartridge, and if one is found it exits through the\ncartridge warm start vector at 32770 ($8002).  If not, the STOP key is\nchecked, and if it is being pressed, the BRK routine is executed.  If\nthe RS-232 device was the cause of the NMI, the cartridge and STOP key\nchecks are bypassed, and the routine skips to the end, where it checks\nwhether it is time to send or receive a data bit via the RS-232\ndevice."}, {"id": "map-FE66", "address_start": 65126, "address_end": 65126, "hex_start": "$FE66", "hex_end": "$FE66", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65126         $FE66\nBRK, Warm Start Routine\n\nThis routine is executed when the STOP/RESTORE combination of\nkeypresses occurs.  In addition, it is the default target address of\nthe BRK instruction vector.  This routine calls the Kernal\nintialization routines RESTOR, IOINIT, and part of CINT.  It then\nexits through the BASIC warm start vector at 40962 ($A002)."}, {"id": "map-FE72", "address_start": 65138, "address_end": 65138, "hex_start": "$FE72", "hex_end": "$FE72", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65138         $FE72\nNMI RS-232 Handler\n\nThis is the part of the NMI handler that checks if it is time to\nreceive or send a bit on the RS-232 channel, and takes the appropriate\naction if it is indeed the time."}, {"id": "map-FEC2", "address_start": 65218, "address_end": 65218, "hex_start": "$FEC2", "hex_end": "$FEC2", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65218         $FEC2\nRS-232 Baud Rate Tables for U.S. Television Standard (NTSC)\n\nThis table contains the ten prescaler values for the ten standard baud\nrates implemented by the RS-232 Control Register at 659 ($293).  The\ntable starts with the two values needed for the lowest baud rate (50\nbaud) and finishes with the entries for the highest baud rate, 2400\nbaud.  The RS-232 routines are handled by NMI interrupts which are\ncaused by the timers on CIA #2.  Since the RS-232 device could both\nreceive and send a bit in a single cycle, the time between interrupts\nshould be a little less than half of the clock frequency divided by\nthe baud rate.  The exact formula used is:\n\n((CLOCK/BAUD)/2)-100\n\nwhere CLOCK is the processor clock speed and BAUD is the baud rate.\nThe clock frequency for machines using the U.S. television standard\n(NTSC) is 1,022,730 cycles per second, while the frequency for the\nEuropean (PAL) standard is 985,250 cycles per second.  For this\nreason, separate baud rate tables were added for European machines at\n58604 ($E4EC)."}, {"id": "map-FED6", "address_start": 65238, "address_end": 65238, "hex_start": "$FED6", "hex_end": "$FED6", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65238         $FED6\nRS-232 Receive the Next Bit (NMI)\n\nThe NMI handler calls this subroutine to input the next bit on the\nRS-232 bus.  It then calls the next subroutine to reload the timer\nthat causes the interrupts."}, {"id": "map-FF1A", "address_start": 65306, "address_end": 65306, "hex_start": "$FF1A", "hex_end": "$FF1A", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65306         $FF1A\nLoad the Timer with Prescaler Values from the Baud Rate Lookup Table"}, {"id": "map-FF48", "address_start": 65352, "address_end": 65352, "hex_start": "$FF48", "hex_end": "$FF48", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65352         $FF48\nMain IRQ/BRK Interrupt Entry Point\n\nThe 6510 hardware IRQ/BRK vector at 65534 ($FFFE) points to this\naddress.\n\nAnytime the BRK instruction is encountered or an IRQ interrupt occurs,\nthis routine will be executed.  The routine first saves the .A, .X,\nand .Y registers on the stack, and then tests the BRK bit of the\nstatus register (.P) to see if a BRK was executed.  If it was, the\nroutine exits through the RAM BRK vector at 790 ($316), where it will\nusually be directed to the BRK routine at 65126 ($FE66).  If not, the\nroutine exits through the RAM IRQ vector at 788 ($314), where it will\nusually be directed to the handler that scans the keyboard at 59953\n($EA31).\n\nIf you plan to change either of these vectors to your own routine,\nremember to pull the stored register values off the stack before\nfinishing."}, {"id": "map-FF5B-FF7F", "address_start": 65371, "address_end": 65407, "hex_start": "$FF5B", "hex_end": "$FF7F", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location_range", "text": "Location Range: 65371-65407 ($FF5B-$FF7F)\nPatches Added to Later Kernal Versions\n\nThis area contains additional code not found in the original version\nof the Kernal.  It is used to test whether a European (PAL) or U.S.\n(NTSC) standard monitor is used, and to compensate so that the\nsixtieth of a second interrupt will be accurately timed on either\nsystem."}, {"id": "map-FF5B", "address_start": 65371, "address_end": 65371, "hex_start": "$FF5B", "hex_end": "$FF5B", "label": "CINT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65371         $FF5B          CINT\nInitialize Screen Editor and VIC-II Chip\n\nThis is a documented Kernal routine whose entry in the jump table is\nlocated at 65409 ($FF81).\n\nThe start of the routine appears to be a patch that was added to later\nversions of the Kernal.  It first calls the old routine at 58648\n($E518).  This initializes the VIC-II chip to the default values, sets\nthe keyboard as the input device and the screen as the output device,\ninitializes the cursor flash variables, builds the screen line link\ntable, clears the screen, and homes the cursor.  The new code then\nchecks the VIC Interrupt register to see if the conditions for a\nRaster Compare IRQ have been fulfilled.  Since the Raster Register was\ninitialized to 311, that can only occur when using a PAL system (NTSC\nscreens do not have that many scan lines).  The PAL/NTSC register at\n678 ($2A6) is set on the basis of the outcome of this test.  The CIA\n#1 Timer A is then set to cause an IRQ interrupt every sixtieth of a\nsecond, using the prescaler figures for a PAL or NTSC system, as\nappropriate."}, {"id": "map-FF6E", "address_start": 65390, "address_end": 65390, "hex_start": "$FF6E", "hex_end": "$FF6E", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65390         $FF6E\nEnd of Routine to Set Timer for Sixtieth of a Second IRQ\n\nThis appears to be a patch added to compensate for the extra length of\nthe current version of this routine, which chooses either the PAL or\nNTSC prescaler values for the timer."}, {"id": "map-FF80", "address_start": 65408, "address_end": 65408, "hex_start": "$FF80", "hex_end": "$FF80", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65408         $FF80\nKernal Version Identifier Byte\n\nThis last byte before the jump table can be used to identify the\nversion of the Kernal.  The first version has a 170 ($AA) stored here,\nwhile the most current version at the time of this writing has a zero\nin this location.\n\nThe PET 64, a one-piece version with an integrated monochrome display,\nhas an identifier byte of 100 ($64).  The Commodore 64 logo uses this\nbyte to recognize the PET 64, and adjust its display accordingly."}, {"id": "map-FF81-FFF5", "address_start": 65409, "address_end": 65525, "hex_start": "$FF81", "hex_end": "$FFF5", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location_range", "text": "Location Range: 65409-65525 ($FF81-$FFF5)\nKernal Jump Table\n\nThe following jump table is provided by Commodore in an effort to\nmaintain stable entry points for key I/O routines.  Each three-byte\ntable entry consists of a 6510 JMP instruction and the actual address\nof the routine in the ROM.  Although the actual address of the routine\nmay vary from machine to machine, or in later versions of the Kernal,\nthese addresses will stay where they are.  By jumping to the entry\npoint provided by this table, rather than directly into the ROM, you\ninsure your programs against changes in the Operating System.  In\naddition, this jump table may help you write programs that will\nfunction on more than one Commodore machine.  The 15 table entries\nfrom 65472-65514 ($FFC0-$FFEA) are the same for all Commodore\nmachines, from the earliest PET on.\n\nAs an additional aid, some of these routines are also vectored through\nthe table which starts at 788 ($314).  Since this table is in RAM, you\ncan change those vectors to point to your own routines which support\nadditional I/O devices.  Programs that use the jump table entry points\nto the I/O routines will be able to use these I/O devices without a\nproblem.\n\nThe following table will give the entry point, routine name, RAM\nvector if any, its current address, and a brief summary of its\nfunction.\n\n65409 ($FF81) CINT   (65371, $FF5B) initialize screen editor and video chip\n65412 ($FF84) IOINIT (64931, $FDA3) initialize I/O devices\n65415 ($FF87) RAMTAS (64848, $FD50) initialize RAM, tape buffer, screen\n65418 ($FF8A) RESTOR (64789, $FD15) restore default I/O vectors\n65421 ($FF8D) VECTOR (64794, $FD1A) read/set I/O vector table\n65424 ($FF90) SETMSG (65048, $FE18) set Kernal message control flag\n65427 ($FF93) SECOND (60857, $EDB9) send secondary address after LISTEN\n65430 ($FF96) TKSA   (60871, $EDC7) send secondary address after TALK\n65433 ($FF99) MEMTOP (65061, $FE25) read/set top of memory pointer\n65436 ($FF9C) MEMBOT (65076, $FE34) read/set bottom of memory pointer\n65439 ($FF9F) SCNKEY (60039, $EA87) scan the keyboard\n65442 ($FFA2) SETTMO (65057, $FE21) set time-out flag for IEEE bus\n65445 ($FFA5) ACPTR  (60947, $FE13) input byte from serial bus\n65448 ($FFA8) CIOUT  (60893, $EDDD) output byte to serial bus\n65451 ($FFAB) UNTLK  (60911, $EDEF) command serial bus device to UNTALK\n65454 ($FFAE) UNLSN  (60926, $EDFE) command serial bus device to UNLISTEN\n65457 ($FFB1) LISTEN (60684, $ED0C) command serial bus device to LISTEN\n65460 ($FFB4) TALK   (60681, $ED09) command serial bus device to TALK\n65463 ($FFB7) READST (65031, $FE07) read I/O status word\n65466 ($FFBA) SETLFS (65024, $FE00) set logical file parameters\n65469 ($FFBD) SETNAM (65017, $FDF9) set filename parameters\n65472 ($FFC0) OPEN   (via 794 ($31A) to 62282, $F34A) open a logical file\n65475 ($FFC3) CLOSE  (via 796 ($31C) to 62097, $F291) close a logical file\n65478 ($FFC6) CHKIN  (via 798 ($31E) to 61966, $F20E) define an input channel\n65481 ($FFC9) CHKOUT (via 800 ($320) to 62032, $F250) define an output channel\n65484 ($FFCC) CLRCHN (via 802 ($322) to 62259, $F333) restore default devices\n65487 ($FFCF) CHRIN  (via 804 ($324) to 61783, $F157) input a character\n65490 ($FFD2) CHROUT (via 806 ($326) to 61898, $F1CA) output a character\n65493 ($FFD5) LOAD   (via 816 ($330) to 62622, $F49E) load from device\n65496 ($FFD8) SAVE   (via 818 ($332) to 62941, $F5DD) save to a device\n65499 ($FFDB) SETTIM (63204, $F6E4) set the software clock\n65502 ($FFDE) RDTIM  (63197, $F6DD) read the software clock\n65505 ($FFE1) STOP   (via 808 ($328) to 63213, $F6ED) check the STOP key\n65508 ($FFE4) GETIN  (via 810 ($32A) to 61758, $F13E) get a character\n65511 ($FFE7) CLALL  (via 812 ($32C) to 62255, $F32F) close all files\n65514 ($FFEA) UDTIM  (63131, $F69B) update the software clock\n65517 ($FFED) SCREEN (58629, $E505) read number of screen rows and columns\n65520 ($FFF0) PLOT   (58634, $E50A) read/set position of cursor on screen\n65523 ($FFF3) IOBASE (58624, $E500) read base address of I/O devices"}, {"id": "map-FFFA-FFFF", "address_start": 65530, "address_end": 65535, "hex_start": "$FFFA", "hex_end": "$FFFF", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location_range", "text": "Location Range: 65530-65535 ($FFFA-$FFFF)\n6510 Hardware Vectors\n\nThe last six locations in memory are reserved by the 6510 processor\nchip for three fixed vectors.  These vectors let the chip know at what\naddress to start executing machine language program code when an NMI\ninterrupt occurs, when the computer is turned on, or when an IRQ\ninterrupt or BRK occurs."}, {"id": "map-FFFA", "address_start": 65530, "address_end": 65530, "hex_start": "$FFFA", "hex_end": "$FFFA", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65530         $FFFA\nNon-Maskable Interrupt Hardware Vector\n\nThis vector points to the main NMI routine at 65091 ($FE43)."}, {"id": "map-FFFC", "address_start": 65532, "address_end": 65532, "hex_start": "$FFFC", "hex_end": "$FFFC", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65532         $FFFC\nSystem Reset (RES) Hardware Vector\n\nThis vector points to the power-on routine at 64738 ($FCE2)."}, {"id": "map-FFFE", "address_start": 65534, "address_end": 65534, "hex_start": "$FFFE", "hex_end": "$FFFE", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "65534         $FFFE\nMaskable Interrupt Request and Break Hardware Vectors\n\nThis vector points to the main IRQ handler routine at 65352 ($FF48).\n\n\n:::::::::::::::::::\n::  Appendix A   ::\n::               ::\n:: A Beginner's  ::\n::Guide to Typing::\n::  In Programs  ::\n:::::::::::::::::::\n\nWhat Is a Program?\n\nA computer cannot perform any task by itself.  Like a car without gas,\na computer has potential, but without a program, it isn't going\nanywhere.  Most of the programs published in this book are written in\na computer language called BASIC.  BASIC is easy to learn and is built\ninto all Commodore 64s.\n\nBASIC Programs\n\nComputers can be picky.  Unlike the English language, which is full of\nambiguities, BASIC usually has only one right way of stating\nsomething.  Every letter, character, or number is significant.  A\ncommon mistake is substituting a letter such as O for the numeral 0, a\nlowercase l for the numeral 1, or an uppercase B for the numeral 8.\nAlso, you must enter all punctuation such as colons and commas just as\nthey appears in the book.  Spacing can be important.  To be safe, type\nin the listings exactly as they appear.\n\nBraces and Special Characters\n\nThe exception to this typing rule is when you see the braces, such as\n{DOWN}.  Anything within a set of braces is a special character or\ncharacters that cannot easily by listed on a printer.  When you come\nacross such a special statement, refer to Appendix B, \"How to Type In\nPrograms.\"\n\nAbout DATA Statements\n\nSome programs contain a section or sections of DATA statements.  These\nlines provide information needed by the program.  Some DATA statements\ncontain actual programs (called machine language); others contain\ngraphics codes.  These lines are especially sensitive to errors.\n\nIf a single number in any one DATA statement is mistyped, your machine\ncould lock up, or crash.  The keyboard and STOP key may seem dead, and\nthe screen may go blank.  Don't panic--no damage is done.  To regain\ncontrol, you have to turn off your computer, then turn it back on.\nThis will erase whatever program was in memory, so always SAVE a copy\nof your program before you RUN it.  If your computer crashes, you can\nLOAD the program and look for your mistake.\n\nSometimes a mistyped DATA statement will cause an error message when\nthe program is RUN.  The error message may refer to the program line\nthat READs the data.  The error is still in the DATA statements,\nthough.\n\nGet to Know Your Machine\n\nYou should familiarize yourself with your computer before attempting\nto type in a program.  Learn the statements you use to store and\nretrieve your programs from tape or disk.  You'll want to save a copy\nof your program, so that you won't have to type it in every time you\nwant to use it.  Learn to use your machine's editing functions.  How\ndo you change a line if you made a mistake?  You can always retype the\nline, but you at least need to know how to backspace.  Do you know how\nto enter reverse video, lowercase, and control characters?  It's all\nexplained in your computer's manuals.\n\nA Quick Review\n\n1.  Type in the program a line at a time, in order.  Press RETURN at\nthe end of each line.  Use backspace or the back arrow to correct\nmistakes\n\n2.  Check the line you've typed against the line in the book.  You can\ncheck the entire program again if you get an error when you RUN the\nprogram.\n\n\n:::::::::::::::\n::Appendix B ::\n::           ::\n::How to Type::\n;:In Programs::\n:::::::::::::::\n\nTo make it easy to know exactly what to type when entering one of\nthese programs into your computer, we have established the following\nlisting conventions.\n\nGenerally, Commodore 64 program listings will contain words within\nbraces which spell out any special characters:  {DOWN} would mean to\npress the cursor down key.  {5 SPACES} would mean to press the space\nbar five times.\n\nTo indicate that a key should be shifted (hold down the SHIFT key\nwhile pressing the other key), the key would be unterlined in our\nlistings.  For example, _S_ would mean to type the S key while holding\nthe SHIFT key.  This would appear on your screen as a heart symbol.\nIf you find an underlined key enclosed in braces (e.g., {10 _N_}), you\nshould type the key as many times as indicated (in our example, you\nwould enter ten shifted N's).\n\nIf a key is enclosed in special brackets, [<>], you should hold down\nthe Commodore key while pressing the key inside the special brackets.\n(The Commodore key is the key in the lower-left corner of the\nkeyboard.)  Again, if the key is preceded by a number, you should\npress the key as many times as necessary.\n\nRarely, you'll see a solitary letter of the alphabet enclosed in\nbraces.  These characters can be entered by holding down the CTRL key\nwhile typing the letter in the braces.  For example, {A} would\nindicate that you should press CTRL-A.\n\nAbout the quote mode:  You know that you can move the cursor around\nthe screen with the CRSR keys.  Sometimes a programmer will want to\nmove the cursor under program control.  That's why you see all the\n{LEFT}'s, {HOME}'s, and {BLU}'s in our programs.  The only way the\ncomputer can tell the difference between direct and programmed cursor\ncontrol is the quote mode.\n\nOnce you press the quote (the double quote, SHIFT-2), you are in the\nquote mode.  If you type something and then try to change it by moving\nthe cursor left, you'll only get a bunch of reverse-video lines.\nThese are the symbols for cursor left.  The only editing key that\nisn't programmable is the DEL key; you can still use DEL to back up\nand edit the line.  Once you type another quote, you are out of quote\nmode.\n\nYou also go into quote mode when you INSerT spaces into a line.  In\nany case, the easiest way to get out of quote mode is to just press\nRETURN.  You'll then be out of quote mode and you can cursor up to the\nmistyped line and fix it.\n\nUse the following table when entering cursor and color control keys:\n\nWhen You                               When You\nRead:         Press:                   Read:          Press:\n[CLR]       SHIFT CLR/HOME             [<1>]           C= 1\n[HOME]            CLR/HOME             [<2>]           C= 2\n[UP]        SHIFT CRSR UP/DOWN         [<3>]           C= 3\n[DOWN]            CRSR UP/DOWN         [<4>]           C= 4\n[LEFT]      SHIFT CRSR LEFT/RIGHT      [<5>]           C= 5\n[RIGHT]           CRSR LEFT/RIGHT      [<6>]           C= 6\n[RVS]        CTRL 9                    [<7>]           C= 7\n[OFF]        CTRL 0                    [<8>]           C= 8\n[BLK]        CTRL 1                    [F1]               F1\n[WHT]        CTRL 2                    [F2]         SHIFT F1\n[RED]        CTRL 3                    [F3]               F3\n[CYN]        CTRL 4                    [F4]         SHIFT F3\n[PUR]        CTRL 5                    [F5]               F5\n[GRN]        CTRL 6                    [F6]         SHIFT F5\n[BLU]        CTRL 7                    [F7]               F7\n[YEL]        CTRL 8                    [F8]         SHIFT F8\n\n\n::::::::::::::\n::Appendix C::\n::          ::\n::  Screen  ::\n:: Location ::\n::  Table   ::\n::::::::::::::\n\nRow\n 0 1024  oooooooooooooooooooooooooooooooooooooooo\n   1064  oooooooooooooooooooooooooooooooooooooooo\n   1104  oooooooooooooooooooooooooooooooooooooooo\n   1144  oooooooooooooooooooooooooooooooooooooooo\n   1184  oooooooooooooooooooooooooooooooooooooooo\n 5 1224  oooooooooooooooooooooooooooooooooooooooo\n   1264  oooooooooooooooooooooooooooooooooooooooo\n   1304  oooooooooooooooooooooooooooooooooooooooo\n   1344  oooooooooooooooooooooooooooooooooooooooo\n   1384  oooooooooooooooooooooooooooooooooooooooo\n10 1424  oooooooooooooooooooooooooooooooooooooooo\n   1464  oooooooooooooooooooooooooooooooooooooooo\n   1504  oooooooooooooooooooooooooooooooooooooooo\n   1544  oooooooooooooooooooooooooooooooooooooooo\n   1584  oooooooooooooooooooooooooooooooooooooooo\n15 1624  oooooooooooooooooooooooooooooooooooooooo\n   1664  oooooooooooooooooooooooooooooooooooooooo\n   1704  oooooooooooooooooooooooooooooooooooooooo\n   1744  oooooooooooooooooooooooooooooooooooooooo\n   1784  oooooooooooooooooooooooooooooooooooooooo\n20 1824  oooooooooooooooooooooooooooooooooooooooo\n   1864  oooooooooooooooooooooooooooooooooooooooo\n   1904  oooooooooooooooooooooooooooooooooooooooo\n   1944  oooooooooooooooooooooooooooooooooooooooo\n24 1984  oooooooooooooooooooooooooooooooooooooooo\n         |    |    |    |    |    |    |    |   |\n         0    5   10   15   20   25   30   35  39\n\n                          Column\n\n\n::::::::::::::::\n:: Appendix D ::\n::            ::\n::Screen Color::\n::Memory Table::\n::::::::::::::::\n\nRow\n 0 55296  oooooooooooooooooooooooooooooooooooooooo\n   55336  oooooooooooooooooooooooooooooooooooooooo\n   55376  oooooooooooooooooooooooooooooooooooooooo\n   55416  oooooooooooooooooooooooooooooooooooooooo\n   55456  oooooooooooooooooooooooooooooooooooooooo\n 5 55496  oooooooooooooooooooooooooooooooooooooooo\n   55536  oooooooooooooooooooooooooooooooooooooooo\n   55576  oooooooooooooooooooooooooooooooooooooooo\n   55616  oooooooooooooooooooooooooooooooooooooooo\n   55656  oooooooooooooooooooooooooooooooooooooooo\n10 55696  oooooooooooooooooooooooooooooooooooooooo\n   55736  oooooooooooooooooooooooooooooooooooooooo\n   55776  oooooooooooooooooooooooooooooooooooooooo\n   55816  oooooooooooooooooooooooooooooooooooooooo\n   55856  oooooooooooooooooooooooooooooooooooooooo\n15 55896  oooooooooooooooooooooooooooooooooooooooo\n   55936  oooooooooooooooooooooooooooooooooooooooo\n   55976  oooooooooooooooooooooooooooooooooooooooo\n   56016  oooooooooooooooooooooooooooooooooooooooo\n   56056  oooooooooooooooooooooooooooooooooooooooo\n20 56096  oooooooooooooooooooooooooooooooooooooooo\n   56136  oooooooooooooooooooooooooooooooooooooooo\n   56176  oooooooooooooooooooooooooooooooooooooooo\n   56216  oooooooooooooooooooooooooooooooooooooooo\n24 56256  oooooooooooooooooooooooooooooooooooooooo\n          |    |    |    |    |    |    |    |   |\n          0    5   10   15   20   25   30   35  39\n\n                           Column\n\n\n:::::::::::::::\n::Appendix E ::\n::           ::\n::  Screen   ::\n::Color Codes::\n:::::::::::::::\n\nValue to POKE for Each Color\n\n             Low nybble    High nybble   Select multicolor\nColor        color value   color value   color value\n\nBlack         0              0            8\nWhite         1             16            9\nRed           2             32           10\nCyan          3             48           11\nPurple        4             64           12\nGreen         5             80           13\nBlue          6             96           14\nYellow        7            112           15\nOrange        8            128           --\nBrown         9            144           --\nLight Red    10            160           --\nDark Gray    11            176           --\nMedium Gray  12            192           --\nLight Green  13            208           --\nLight Blue   14            224           --\nLight Gray   15            240           --\n\nWhere To POKE Color Values For Each Mode\n\n                 Bit or\nMode *           bit-pair   Location        Color value\n\nRegular text      0         53281           Low nybble\n                  1         Color memory    Low nybble\nMulticolor text  00         53281           Low nybble\n                 01         53282           Low nybble\n                 10         53283           Low nybble\n                 11         Color memory    Select Multicolor\nExtended color   00         53281           Low nybble\ntext +           01         53282           Low nybble\n                 10         53283           Low nybble\n                 11         53284           Low nybble\nBitmapped         0         Screen memory   Low nybble ++\n                  1         Screen memory   High nybble ++\nMulticolor       00         53281           Low nybble\nbitmapped        01         Screen memory   High nybble ++\n                 10         Screen memory   Low nybble ++\n                 11         Color memory    Low nybble\n\n* For all modes, the screen border color is controlled by POKEing\nlocation 53280 with the low nybble color value.\n\n+ In exteded color mode, Bits 6 and 7 of each byte of screen memory\nserve as the bit-pair controlling background color.  Because only Bits\n0-5 are available for character selection, only characters with screen\ncodes 0-63 can be used in this mode.\n\n++ In the bitmapped modes, the high and low nybble color values are\nORed together and POKEd into the same location in memory to control\nthe colors of the corresponding cell in the bitmap.  For example, to\ncontrol the colors of cell 0 of the bitmap, OR the high and low\nnybbles and POKE the result into location 0 of screen memory.\n\n\n:::::::::::::::\n::Appendix F ::\n::           ::\n::ASCII Codes::\n:::::::::::::::\n\n[*** OMITTED ***]\n[widely available elsewhere; not suitable for textual formatting]\n\n\n::::::::::::::::\n:: Appendix G ::\n::            ::\n::Screen Codes::\n::::::::::::::::\n\n[*** OMITTED ***]\n[widely available elsewhere; not suitable for textual formatting]\n\n\n:::::::::::::::\n::Appendix H ::\n::           ::\n:: Commodore ::\n::64 Keycodes::\n:::::::::::::::\n\nKey          Keycode                   Key          Keycode\nA            10                        6            19\nB            28                        7            24\nC            20                        8            27\nD            18                        9            32\nE            14                        0            35\nF            21                        +            40\nG            26                        -            43\nH            29                        LIRA         48\nI            33                        CLR/HOME     51\nJ            34                        INST/DEL      0\nK            37                        LEFT ARROW   57\nL            42                        @            46\nM            36                        *            49\nN            39                        ^            54\nO            38                        :            45\nP            41                        ;            50\nQ            62                        =            53\nR            17                        RETURN        1\nS            13                        ,            47\nT            22                        .            44\nU            30                        /            55\nV            31                        CRSR UP/DN    7\nW             9                        CRSR LF/RT    2\nX            23                        F1            4\nY            25                        F3            5\nZ            12                        F5            6\n1            56                        F7            3\n2            59                        SPACE        60\n3             8                        RUN/STOP     63\n4            11                        NO KEY\n5            16                        PRESSED      64\n\nThe keycode is the number found at location 197 for the current key\nbeing pressed.  Try this one-line program:\n\n10 PRINT PEEK(197):GOTO 10\n\n\n::::::::::::::\n::  Index   ::\n::          ::\n::(by memory::\n:: location)::\n::::::::::::::\n\nABS  48216\nAND  45033\nASC  46987\nATN  58126\nBASIC\n  adding new commands  115,768\n  current line number  57\n  execution of statements  776,42980\n  expression evaluation  778, 44446, 44675\n  function evaluation  44967\n  pointer to bottom of string text  51\n  pointer to current data item address  65\n  pointer to current statement address  61\n  pointer to end of array storage  49\n  pointer to start of array storage  47\n  pointer to start of program text  43\n  pointer to start of variable storage  45\n  pointer to top of BASIC RAM  55\n  program text storage  2048\n  RAM vector table  768\nBuffer\n  cassette I/O buffer  178, 828\n  keyboard buffer  198, 631\n  RS-232 input buffer 247\n  RS-232 output buffer  249\n  text input buffer  512\ncartridge, autostart ROM  32768\ncassette\n  data output line  01\n  I/O buffer  828\n  Kernal ROM routines  63466-64737\n  motor control  01, 192\n  switch sense  01\ncharacter generator ROM  01, 4096, 36864, 53248\ncharcter graphics  53248\nCHAREN  01\nCHRGET  115, 58274\nCHR$  46828\nCIA (Complex Interface Adapter)\n  CIA #1  56320-56335\n  CIA #2  56576-56591\n  data direction registers  56322, 56323, 56578, 56579\n  data ports  56320, 56321, 56576, 56577\n  timers  56334, 56335, 56590, 56591\nclock\n  clock speed (6510 microprocessor)  56334\n  software clock  160\n  Time of Day clock  56328, 56584\nCLOSE  57799\nCLR  42590\nCMD  43654\ncold start, BASIC  40960, 58260\ncolor\n  background  53281\n  border (frame)  53280\n  color codes  646\n  color RAM nybbles  55296\n  current character color  646\n  multicolor background registers 53282, 53283\n  PETASCII color change characters  59601\n  sprite color registers  53287-53294\n  sprite multicolor registers  53285, 53286\nCONT  43095\nCOS  57956\nDATA  43256\ndata direction register  00, 56322, 56323, 56578, 56579\ndata port  01, 56320, 56321, 56576, 56577\nDEF  46003\nDIM  45185\ndynamic keyboard  198, 631\nerror\n  BASIC error handler  768, 42039, 58251\n  error message control flag  157\n  I/O error status  144\n  RS-232 I/O error status  663\nEXP  49133\nexpression evaluation  778, 44446, 44675\nfloating point\n  addition  47207, 47210\n  division  47887, 47890\n  fixed-floating point conversion  05, 45969\n  floating-fixed point conversion  03, 45482, 45503\n  Floating Point Accumulators  97, 110\n  floating point-ASCII conversion  48605\n  multiplication  47656, 47667\n  subtraction  47194, 47194\nFN  46068\nFOR  42818\nFRE  45949\ngarbage collection, string variable  46374\nGET, GET#  43899\nGOSUB  43139\nGOTO  43168\ngraphics\n  bitmapped graphics  53265\n  character graphics  53248\n  extended background color mode  53265\n  fine scrolling  53265, 43271\n  multicolor mode  53271\n  raster position  53265, 53266\n  screen blanking  53265\n  sprites SEE sprite graphics\nHIRAM  01\nIF  43304\nINT  48332\ninterrupt\n  CIA hardware FLAG line  56589, 56333\n  CIA serial shift register  56589, 56333\n  CIA Time of Day clock alarm  56589, 56333\n  CIA Timers A and B  56589, 56333\n  IRQ handler  59953, 65352\n  IRQ vector  788, 65534\n  light pen IRQ  53273, 53274\n  NMI handler  65091\n  NMI vector  792, 65530\n  raster compare IRQ  53266, 53273, 53274\n  sprite-display data collision IRQ  53273, 53275\n  sprite-sprite collision IRQ  53273, 53275\nINPUT  43967\nINPUT#  43941\nI/O\n  current device number  186\n  current filename address 187\n  current filename length  183\n  current input device  153\n  current I/O channel number  19\n  current logical file number  184\n  current output device  154\n  current secondary address  185\n  device number table  611\n  logical file table  601\n  number of I/O files open  152\n  RS-232 status  663\n  secondary address table  621\n  status word codes  144\njoystick controllers  56320, 56321\nKernal\n  jump table  65409\n  RAM vector table  794\n  ACPTR  60947, 65445\n  CHKIN  798, 61966, 65478\n  CHKOUT  800, 62032, 65481\n  CHRIN  804, 61783, 65487\n  CHROUT  806, 61898, 65490\n  CINT  65371, 65409\n  CIOUT  60893, 65448\n  CLALL  812, 62255, 65511\n  CLOSE  796, 62097, 65475\n  CLRCHN  802, 62259, 65484\n  GETIN  810, 61758, 65508\n  IOBASE  58624, 65523\n  IOINIT  64931, 65412\n  LISTEN  60684, 65457\n  LOAD  816, 62622, 65493\n  MEMBOT  65076, 65436\n  MEMTOP  65061, 65433\n  OPEN  794, 62282, 65472\n  PLOT  58634, 65520\n  RAMTAS  64848, 65415\n  RDTIM  63197, 65502\n  READST  65031, 65463\n  RESTOR  64789, 65418\n  SAVE  818, 62941, 65496\n  SCNKEY  60039, 65439\n  SCREEN  58629, 65517\n  SECOND  60857, 65427\n  SETLFS  65024, 65466\n  SETMSG  65048, 65424\n  SETNAM  65017, 65469\n  SETTIM  63204, 65499\n  SETTMO  65057, 65442\n  STOP  808, 63213, 65505\n  TALK  60681, 65460\n  TKSA  60871, 65430\n  UDTIM  63131, 65514\n  UNLSN  60926, 65454\n  UNTLK  60911, 65451\n  VECTOR  64794, 65421\nkeyboard\n  current key pressed  203\n  keyboard buffer  631\n  keycodes  203\n  keyboard matrix  245, 655, 56321\n  last key pressed  197\n  number of characters in buffer  198\n  pointer to matrix lookup table  245\n  reading the keyboard  56320\n  repeating keys  650\nLEFT$  46848\nLEN  46972\nLET  43429\nlight pen  53267, 53268\nLIST  42652\nLOAD  57704\nLORAM  01\nMID$ 46903\nNEW  42562\nNEXT  44318\nNMI  65095\nON GOSUB, ON GOTO  43339\nOPEN  57790\nOperating System (OS)\n  OS end of RAM pointer  643\n  OS screen memory pointer  648\n  OS start of RAM pointer  641\nOR  45030\npaddle controllers  54297, 54298\npaddle fire button  56320, 56321\nPAL/NTSC flag  678\nPEEK  47117\nPOKE  47140\nPOS  45982\nPRINT  43680\nPRINT#  43648\nprogram text area  43, 2048\nprogram text input buffer  512\nRAM\n  BASIC pointer to end of RAM  55\n  RAM/ROM selection  01\n  OS pointer to end of RAM  643\n  OS pointer to start of RAM  641\nrandom number generator  54299\nREAD  44038\nregisters, reading/setting from BASIC  780\nREM  43323\nRESER, power-on  64738, 65532\nreset, VIC-II chip  53270\nRESTORE  43037\nRESTORE key, disabling  792, 808\nRETURN  43218\nRIGHT$  46892\nRND  139, 57495\nRS-232\n  baud rate  659, 661, 665\n  baud rate tables  58604, 65218\n  buffers  247, 249\n  command register  660\n  connector pin assignments  56576, 56577\n  control register  659\n  duplex mode  660\n  handshaking protocol  660\n  Kernal ROM routines  57344-65535\n  parity  660\n  status register  663\n  stop bits  659\n  word length  659\nRUN  43121\nSAVE  57686\nscreen editor\n  current character color  646\n  cursor color RAM position  243\n  cursor flash  204, 205, 207\n  cursor maintenance  206, 647\n  cursor screen position  209, 211, 214\n  insert mode flag  216\n  key repeat  650, 651, 652\n  quote mode flag  212\n  reverse character flag  199\n  screen line link table  217\n  screen RAM  1024, 648, 53272\n  shift flag  653, 654\nSerial Bus I/O  56576, 60681-61114\nSerial Data Port (CIA)  56332, 56588\nSGN  48185\nSID chip register  54272-54300\n  SEE ALSO sound\nSIN  57960\nsound\n  ADSR envelope control  54278-54279, 54285-54286, 54292-54293\n  filtering  54293-54296\n  frequency (pitch) control  54272-54273, 54279-54280, 54286-54287\n  gate bit  54276\n  Oscillator 3 envelope generator  54300\n  Oscillator 3 output  54299\n  pulse waveform pulse width  54274-54275, 54281-54282, 54288-54289\n  ring modulation  54276, 54283, 54290\n  synchronization (hard sync)  54276, 54283, 54290\n  volume control  54296\n  waveform control  54276, 54283, 54290\nsprite graphics\n  color registers  53287-53294\n  display priority  53275\n  enabling sprite display  53274\n  horizontal expansion  53277\n  multicolor color registers  53285-53286\n  multicolor sprites  53276\n  position registers  53248-53264\n  shape data pointers  2040\n  sprite-display data collision detection  53279\n  sprite-sprite collision detection  53278\n  vertical expansion  53271\nSQR  49009\nST (I/O status word)  144\nstack, 6510 microprocessor  256\nSTOP  43055\nSTOP key  145, 808\nSTR$  46181\nSYS  780, 57642\nTAN  56083\nTime of Day clock  56328-56331, 56584-56587\ntimers, hardware  56324-56327, 56334-56335, 56580-56583, 56590-56591\ntokens, keyword  772, 774, 40972, 41042, 41088, 41118, 42364, 42772\nUser Port  56567-56577\nUSR  785\nVAL  47021\nvariable\n  array variable storage  47\n  find or create variable routine  45195\n  storage format  45\n  string text area  51\nVERIFY  57701\nVIC-II CHIP\n  memory bank switching  56576\n  registers  53248-53294\n  SEE ALSO graphics, sprite graphics\nwarm start, BASIC  40962, 58235\nWAIT  47149\nwedges  115\n\n*********\n\nEnd Project 64 etext Mapping The Commodore 64.\n\n*********"}]