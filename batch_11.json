[{"id": "map-E2E0-E30D", "address_start": 58080, "address_end": 58125, "hex_start": "$E2E0", "hex_end": "$E30D", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location_range", "text": "Location Range: 58080-58125 ($E2E0-$E30D)\nTable of Constants for Evaluation of SIN, COS, and TAN"}, {"id": "map-E2E0", "address_start": 58080, "address_end": 58080, "hex_start": "$E2E0", "hex_end": "$E2E0", "label": "PI2", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58080         $E2E0          PI2\nThe Five-Byte Floating Point Representation of the Constant PI/2"}, {"id": "map-E2E5", "address_start": 58085, "address_end": 58085, "hex_start": "$E2E5", "hex_end": "$E2E5", "label": "TWOPI", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58085         $E2E5          TWOPI\nThe Five-Byte Floating Point Representation of the Constant 2*PI"}, {"id": "map-E2EA", "address_start": 58090, "address_end": 58090, "hex_start": "$E2EA", "hex_end": "$E2EA", "label": "FR4", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58090         $E2EA          FR4\nThe Five-Byte Floating Point Representation of the Constant 1/4"}, {"id": "map-E2EF", "address_start": 58095, "address_end": 58095, "hex_start": "$E2EF", "hex_end": "$E2EF", "label": "SINCON", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58095         $E2EF          SINCON\nTable of Constants for Evaluation of SIN, COS, and TAN\n\nThis table starts with a counter byte of 5, indicating that there are\nsix entries in the table.  This is followed by the six floating point\nconstants of five bytes each."}, {"id": "map-E30E", "address_start": 58126, "address_end": 58126, "hex_start": "$E30E", "hex_end": "$E30E", "label": "ATN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58126         $E30E          ATN\nPerform ATN\n\nThe arc tangent of the number in FAC1 (which represents the angle in\nradians) is evaluated using the 12-term series of operations from the\nconstant table which follows.  The answer is left in FAC1."}, {"id": "map-E33E", "address_start": 58174, "address_end": 58174, "hex_start": "$E33E", "hex_end": "$E33E", "label": "ATNCON", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58174         $E33E          ATNCON\nTable of Constants for ATN Evaluation\n\nThe table begins with a count byte of 11, which is followed by 12\nconstants in five-byte floating point representation."}, {"id": "map-E37B", "address_start": 58235, "address_end": 58235, "hex_start": "$E37B", "hex_end": "$E37B", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58235         $E37B\nWarm Start BASIC\n\nThis is the entry point into BASIC from the BRK routine at 65126\n($FE66), which is executed when the STOP and RESTORE keys are both\npressed.  It first executes the Kernal CLRCHN routine which closes all\nfiles.  It then sets the default devices, resets the stack and BASIC\nprogram pointers, and jumps through the vector at 768 ($300) to the\nnext routine to print the READY prompt and enter the main BASIC loop."}, {"id": "map-E38B", "address_start": 58251, "address_end": 58251, "hex_start": "$E38B", "hex_end": "$E38B", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58251         $E38B\nError Message Handler\n\nThis routine to print error messages is pointed to by the vector at\n768 ($300).  Using the .X register as an index, it either prints an\nerror message from the table at 41363 ($A193) or the READY prompt, and\ncontinues through the vector at 770 ($302) to the main BASIC loop."}, {"id": "map-E394", "address_start": 58260, "address_end": 58260, "hex_start": "$E394", "hex_end": "$E394", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58260         $E394\nCold Start BASIC\n\nThis initialization routine is executed at the time of power-up.  The\nRAM vectors to important BASIC routines are set up starting at 768\n($300), the interpreter is initialized, the start-up messages are\nprinted, and the main loop entered through the end of the warm start\nroutine."}, {"id": "map-E3A2", "address_start": 58274, "address_end": 58274, "hex_start": "$E3A2", "hex_end": "$E3A2", "label": "INITAT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58274         $E3A2          INITAT\nText of the CHRGET Routine Which Runs at 115 ($73)\n\nThe text of the CHRGET routine is stored here, and moved to Page 0 by\nthe BASIC initialization routine.  When creating a wedge in CHRGET, it\nis possible to execute all or part of this code in place of the RAM\nversion.\n\n59298         $E3BA\nInitial RND Seed Value\n\nAt power-up time, this five-byte floating point constant is\ntransferred to 139 ($8B), where it functions as the starting RND seed\nnumber.  Thus, if RND is not initialized with a negative or zero\nargument, it will always return the same sequence of numbers."}, {"id": "map-E3BF", "address_start": 58303, "address_end": 58303, "hex_start": "$E3BF", "hex_end": "$E3BF", "label": "INIT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58303         $E3BF          INIT\nInitialize BASIC\n\nThis routine is called by the cold start routine to initialize all of\nthe BASIC zero-page locations which have a fixed value.  This includes\ncopying the CHRGET routine from the ROM location above, to 115 ($73)."}, {"id": "map-E422", "address_start": 58402, "address_end": 58402, "hex_start": "$E422", "hex_end": "$E422", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58402         $E422\nPrint BASIC Start-Up Messages\n\nThis routine prints the start-up message \"**** COMMODORE 64 BASIC V2\n****\", calculates the amount of free memory, and prints the BYTES FREE\nmessage."}, {"id": "map-E447", "address_start": 58439, "address_end": 58439, "hex_start": "$E447", "hex_end": "$E447", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58439         $E447\nTable of Vectors to Important BASIC Routines\n\nThis table contains the vectors which point to the addresses of some\nimportant BASIC routines.  The contents of this table are moved to the\nRAM table at 768 ($300)."}, {"id": "map-E453", "address_start": 58451, "address_end": 58451, "hex_start": "$E453", "hex_end": "$E453", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58451         $E453\nCopy BASIC Vectors to RAM\n\nThe cold start routine calls this subroutine to copy the table of\nvectors to important BASIC routines to RAM, starting at location 768\n($300)."}, {"id": "map-E460", "address_start": 58464, "address_end": 58464, "hex_start": "$E460", "hex_end": "$E460", "label": "WORDS", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58464         $E460          WORDS\nPower-Up Messages\n\nThe ASCII text of the start-up messages \"**** COMMODORE 64 BASIC V2\n****\" and \"BYTES FREE\" is stored here.\n\nLocation Range: 58551-58623 ($E4B7-E4FF)\nPatches Added to Later Kernal Versions\n\nThis area contains code that was not found in the original version of\nthe Kernal.  These additions were made to fix some bugs and to\nincrease Kernal compatibility between U.S. and European 64s."}, {"id": "map-E4AD", "address_start": 58541, "address_end": 58541, "hex_start": "$E4AD", "hex_end": "$E4AD", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58541         $E4AD\nPatch for BASIC Call of CHKOUT\n\nThis patch was made to preserve the .A register if there was no error\nreturned from BASIC's call of the Kernal CHKOUT routine.  Apparently,\nthe first version could cause a malfunction of the CMD and PRINT#\ncommands."}, {"id": "map-E4B7", "address_start": 58551, "address_end": 58551, "hex_start": "$E4B7", "hex_end": "$E4B7", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58551         $E4B7\n35 Unused Bytes (all have the value of 170 ($AA)\n\nLocaiton Range: 58586-65535 ($E4DA-$FFFF)\nKernal I/O Routines\n\nAfter the conclusion of BASIC comes the part of this ROM which can be\nconsidered the Kernal proper.  This part contains all of the vectored\nroutines found in the jump table starting at 65409 ($FF81)."}, {"id": "map-E4DA", "address_start": 58586, "address_end": 58586, "hex_start": "$E4DA", "hex_end": "$E4DA", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58586         $E4DA\nClear Color RAM to the Color in Background Color Register 0\n\nThis routine is a patch added to the more recent versions of the\nKernal.  It is called by the routine which clears a screen line\n(59903, $E9FF), and it places the color value in Background Color\nRegister 0 (53281, $D021) into the current byte of Color RAM pointed\nto by USER (243, $F3).\n\nIn the original version of the Kernal, the routine that cleared a\nscreen line set the corresponding Color RAM to a value of 1, which\ngives text characters a white foreground color.  This was changed when\nthe white color was found to sometimes cause light flashes during\nscreen scrolling.  It was that white foreground color, however, that\nenabled the user to POKE the screen code for a character into screen\nRAM, and make that character appear on the screen in a color that\ncontrasted the blue background.  This change to the Operating System\ncauses colors POKEd to screen RAM to be the same color as the\nbackground, and thus they are invisible.\n\nThis is a fairly serious problem, because the technique of POKEing\ncharacters to screen RAM has long been a staple of Commodore graphics\nprogramming.  Fortunately, the problem has an easy colution.  Since\nthe Color RAM will be set to whatevere color is in Background Color\nRegister 0, what you have to do to initialize Color RAM to the color\nyou desire is change the background color to the desired foreground\ncolor, clear the screen, and then change the background color back\nagain:\n\nC=PEEK(53281):POKE 53281,HUE:PRINT CHR$(147):POKE 53281,C"}, {"id": "map-E4E0", "address_start": 58592, "address_end": 58592, "hex_start": "$E4E0", "hex_end": "$E4E0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58592         $E4E0\nPause after Finding a File on Cassette\n\nThis routine is a patch to the routine which finds a file on cassette.\nAfter the file is found, the message FILETITLE FOUND appears on the\nscreen.  On the original versions of the Kernal, the user would then\nhave to hit the Commodore key to continue the load.  On the newer\nversions, this patch causes a slight pause after the tape file is\nround, during which time a keypress is looked for.  If a key is\npressed, the loading process continues immediately.  If it is not, the\nload continues by itself after the end of the pause."}, {"id": "map-E4EC", "address_start": 58604, "address_end": 58604, "hex_start": "$E4EC", "hex_end": "$E4EC", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58604         $E4EC\nBaud Rate Table for European (PAL) Standard Monitors\n\nThis table of prescaler values was added to later Kernal versions to\nallow the same Kernal software to be used with either U.S. or European\n64s.  It contains the values which are required to obtain interrupts\nat the proper frequency for the standard RS-232 baud rates, and\ncorresponds exactly in format to the table of values for the U.S.\n(NTSC) monitor format at 65218 ($FEC2).  Separate tables are required\nbecause the prescaler values are derived from dividing the system\nclock rate by the baud rate, and PAL machines operate with a slightly\nslower clock frequency."}, {"id": "map-E500", "address_start": 58624, "address_end": 58624, "hex_start": "$E500", "hex_end": "$E500", "label": "IOBASE", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58624         $E500          IOBASE\nStore Base Address of Memory-Mapped I/O Devices in .X and .Y Registers\n\nThis is one of the documented Kernal routines for which there is a\nvector in the jump table at 65523 ($FFF3).\n\nWhen called, this routine sets the .X register to the low byte of the\nbase address of the memory-mapped I/O devices, and puts the high byte\nin the .Y register.  This allows a user to set up a zero-page pointer\nto the device, and to load and store indirectly through that pointer.\nA program which uses this method, rather than directly accessing such\ndevices could be made to function without change on future Commodore\nmodels, even though the I/O chips may be addressed at different\nlocations.  This of course assumes that the CIA or a similar chip will\nbe used.  This routine is of limited value for creating software that\nis compatible with both the VIC-20 and the 64 because of the\ndifferences in the VIA I/O chip that the VIC uses.\n\nThe current version of this routine loads the .X register with a 0,\nand the .Y register with 220 ($DC), thus pointing to CIA #1, which is\nat 56320 ($DC00)."}, {"id": "map-E505", "address_start": 58629, "address_end": 58629, "hex_start": "$E505", "hex_end": "$E505", "label": "SCREEN", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58629         $E505          SCREEN\nStore Number of Screen Rows and Columns in .Y and .X\n\nThis is a documented Kernal routine which is vectored in the jump\ntable at 65517 ($FFED), and is provided to allow for program\ncompatibility between computers.\n\nWhen called, this subroutine returns the number of screen columns in\nthe .X register, and the number of screen rows in .Y.  Thus, a program\ncan detect the screen format of the machine on which it is running,\nand make sure that text output is formatted accordingly.\n\nThe present version of this routine loads the .X register with 40\n($28) and the .Y register with 25 ($19)."}, {"id": "map-E50A", "address_start": 58634, "address_end": 58634, "hex_start": "$E50A", "hex_end": "$E50A", "label": "PLOT", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58634         $E50A          PLOT\nRead/Set Location of the Cursor\n\nThe jump table entry for this documented Kernal is at 65520 ($FFF0).\n\nThe routine allows the user to read or set the position of the cursor.\nIf the carry flag is set with the SEC instruction before calling this\nsubroutine, cursor column (X position) will be returned in the .X\nregister, and the cursor row (Y position) will be returned in the .Y\nregister.  If the carry flag is cleared with a CLC instruction before\nentering this routine, and the .Y and .X registers are loaded with the\ndesired row and column positions respectively, this routine will set\nthe cursor position accordingly.\n\nThe current read routine loads .X and .Y from locations 214 ($D6) and\n211 ($D3) respectively.  The cursor set routine stores .X and .Y in\nthese locations, and calls the routine that sets the screen pointers\nat 58732 ($E56C).\n\nThe user can access this routine from BASIC by loading the .X, .Y, and\n.P register values desired to the save area starting at 780 ($30C)."}, {"id": "map-E518", "address_start": 58648, "address_end": 58648, "hex_start": "$E518", "hex_end": "$E518", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58648         $E518\nInitialize Screen and Keyboard\n\nThis is the original CINT Kernal routine, to which additions were made\nin later versions of the Kernal.\n\nAfter calling the routine at 58784 ($E5A0) to set up default I/O\nvalues, this routine initializes the cursor blink flags, the keyboard\ndecode vector, the key repeat delay and frequency counters, the\ncurrent color code, and maximum keyboard buffer size.  It then falls\nthrough to the next routine."}, {"id": "map-E544", "address_start": 58692, "address_end": 58692, "hex_start": "$E544", "hex_end": "$E544", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58692         $E544\nInitialize the Screen Line Link Table and Clear the Screen\n\nThis routine initializes the screen line link table at 217 ($D9),\nclears the screen, and clears the Color RAM to the background color.\nIt falls through to the next routine."}, {"id": "map-E566", "address_start": 58726, "address_end": 58726, "hex_start": "$E566", "hex_end": "$E566", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58726         $E566\nHome the Cursor\n\nThis routine sets PNTR (211, $D3) and TBLX (214, $D6) to 0, and falls\nthrough to the next routine."}, {"id": "map-E56C", "address_start": 58732, "address_end": 58732, "hex_start": "$E56C", "hex_end": "$E56C", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58732         $E56C\nSet Pointer to Current Screen Line\n\nThis routine sets the pointer PNT (209, $D1) to the address of the\nfirst byte of the current logical line.  In figuring this address, it\ntakes into account the status of the screen line link table, which can\nindicate that two physical lines should be joined as one logical line."}, {"id": "map-E5A0", "address_start": 58784, "address_end": 58784, "hex_start": "$E5A0", "hex_end": "$E5A0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58784         $E5A0\nSet Default I/O Devices and Set Default Values for VIC-II Chip\nRegisters\n\nThis routine sets the keyboard and screen as the current input and\noutput devices.  It then writes the default values found in the table\nat 60601 ($ECB9) to the VIC-II chip."}, {"id": "map-E5B4", "address_start": 58804, "address_end": 58804, "hex_start": "$E5B4", "hex_end": "$E5B4", "label": "LP2", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58804         $E5B4          LP2\nGet a Character from the Keyboard Buffer\n\nThis routine transfers the first character from the keybard buffer to\nthe .A register, bumps the rest of the characters one place up in\nline, and decrements the pointer, showing how many characters are\nwaiting in the buffer."}, {"id": "map-E5CA", "address_start": 58826, "address_end": 58826, "hex_start": "$E5CA", "hex_end": "$E5CA", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58826         $E5CA\nWait for a Carriage Return from the Keyboard\n\nThis subroutine is called by the portion of the CHKIN routine that\nhandles keyboard input.  It turns the cursor on, gets characters, and\nechoes them to the screen until a carriage return has been entered.\nIt also looks for the shifted RUN/STOP key, and forces the output of\nthe commands LOAD and RUN if it finds it."}, {"id": "map-E632", "address_start": 58930, "address_end": 58930, "hex_start": "$E632", "hex_end": "$E632", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "58930         $E632\nInput a Character from Screen or Keyboard\n\nThis routine is the portion of the Kernal CHRIN routine that handles\ninput from the keyboard and screen devices.  CHRIN gets one byte at a\ntime from the current screen position, or inputs a whole line from the\nkeyboard and returns it one byte at a time."}, {"id": "map-E684", "address_start": 59012, "address_end": 59012, "hex_start": "$E684", "hex_end": "$E684", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59012         $E684\nTest for Quote Marks\n\nThis subroutine checks if the current character is a quotation mark,\nand if it is, toggles the quote switch at 212 ($D4)."}, {"id": "map-E691", "address_start": 59025, "address_end": 59025, "hex_start": "$E691", "hex_end": "$E691", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59025         $E691\nAdd a Character to the Screen\n\nThis is part of the routine that outputs a character to the screen.\nIt puts printable characters into screen memory."}, {"id": "map-E6A8", "address_start": 59048, "address_end": 59048, "hex_start": "$E6A8", "hex_end": "$E6A8", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59048         $E6A8\nReturn from Outputting a Character to the Screen\n\nThis is the common exit point for the screen portion of the CHROUT\nroutine."}, {"id": "map-E6B6", "address_start": 59062, "address_end": 59062, "hex_start": "$E6B6", "hex_end": "$E6B6", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59062         $E6B6\nAdvance the Cursor\n\nThis routine advances the cursor, and provides for such things as\nscrolling at the end of the screen, and inserting a blank line in\norder to add another physical line to the current logical line."}, {"id": "map-E701", "address_start": 59137, "address_end": 59137, "hex_start": "$E701", "hex_end": "$E701", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59137         $E701\nMove Cursor Back over a 40-Column Line Boundary"}, {"id": "map-E716", "address_start": 59158, "address_end": 59158, "hex_start": "$E716", "hex_end": "$E716", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59158         $E716\nOutput to the Screen\n\nThis is the main entry point for the part of CHROUT that handles\noutput to the screen device.  It takes an ASCII character number, and\ntests if the character is printable.  If it is, it prints it (taking\ninto consideration the reverse flag, if any inserts are left, etc.).\nIf it is a nonprinting character, the routine performs the appropriate\ncursor movement, color change, screen clearing, or whatever else might\nbe indicated."}, {"id": "map-E87C", "address_start": 59516, "address_end": 59516, "hex_start": "$E87C", "hex_end": "$E87C", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59516         $E87C\nMove Cursor to Next Line\n\nThis subroutine moves the cursor down to the next line if possible, or\nscrolls the screen if the cursor is on the last line."}, {"id": "map-E891", "address_start": 59537, "address_end": 59537, "hex_start": "$E891", "hex_end": "$E891", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59537         $E891\nOutput a Carriage Return\n\nA carriage return is performed by clearing insert mode, reverse video,\nand quote mode, and moving the cursor to the next line."}, {"id": "map-E8A1", "address_start": 59553, "address_end": 59553, "hex_start": "$E8A1", "hex_end": "$E8A1", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59553         $E8A1\nIf at the Beginning of a Screen Line, Move Cursor to Previous Line"}, {"id": "map-E8B3", "address_start": 59571, "address_end": 59571, "hex_start": "$E8B3", "hex_end": "$E8B3", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59571         $E8B3\nIf at the End of a Screen Line, Move Cursor to the Next Line"}, {"id": "map-E8CB", "address_start": 59595, "address_end": 59595, "hex_start": "$E8CB", "hex_end": "$E8CB", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59595         $E8CB\nCheck for a Color Change\n\nThis routine is used by the screen CHROUT routine to check if the\ncharacter to be printed is one that causes the current foreground\ncolor to change (such as the CTRL-1 combination)."}, {"id": "map-E8D1", "address_start": 59601, "address_end": 59601, "hex_start": "$E8D1", "hex_end": "$E8D1", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59601         $E8D1\nPETASCII Color Code Equivalent Table\n\nThis table gives the PETASCII values of the color change characters\nfor each of the 16 possible colors.  These values are:\n\n144 ($90)  Change to color 0 (black)\n  5 ($05)  Change to color 0 (white)\n 28 ($1C)  Change to color 0 (red)\n159 ($9F)  Change to color 0 (cyan)\n156 ($9C)  Change to color 0 (purple)\n 30 ($1E)  Change to color 0 (green)\n 31 ($1F)  Change to color 0 (blue)\n158 ($9E)  Change to color 0 (yellow)\n129 ($81)  Change to color 0 (orange)\n149 ($95)  Change to color 0 (brown)\n150 ($96)  Change to color 0 (light red)\n151 ($97)  Change to color 0 (dark gray)\n152 ($98)  Change to color 0 (medium gray)\n153 ($99)  Change to color 0 (light green)\n154 ($9A)  Change to color 0 (light blue)\n155 ($9B)  Change to color 0 (light gray)"}, {"id": "map-E8EA", "address_start": 59626, "address_end": 59626, "hex_start": "$E8EA", "hex_end": "$E8EA", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59626         $E8EA\nScroll Screen\n\nThis subroutine moves all of the screen lines up, so that a blank line\nis created at the bottom of the screen and the top screen line is\nlost.  If the top logical line is two physical lines long, all lines\nare moved up two lines.  Holding down the CTRL key will cause a brief\npause after the scroll."}, {"id": "map-E965", "address_start": 59749, "address_end": 59749, "hex_start": "$E965", "hex_end": "$E965", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59749         $E965\nInsert a Blank Line on the Screen\n\nThis subroutine is used when INSERTing to add a blank physical line to\na logical line."}, {"id": "map-E9C8", "address_start": 59848, "address_end": 59848, "hex_start": "$E9C8", "hex_end": "$E9C8", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59848         $E9C8\nMove Screen Line\n\nThis subroutine is used by the scroll routine to move one screen line\n(and its associated Color RAM) up a line."}, {"id": "map-E9E0", "address_start": 59872, "address_end": 59872, "hex_start": "$E9E0", "hex_end": "$E9E0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59872         $E9E0\nSet Temporary Color Pointer for Scrolling\n\nThis subrouting sets up a pointer in 17-175 ($AE-$AF) to the Color RAM\naddress that corresponds to the temporary screen line address in\n172-173 ($AC-$AD)."}, {"id": "map-E9F0", "address_start": 59888, "address_end": 59888, "hex_start": "$E9F0", "hex_end": "$E9F0", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59888         $E9F0\nSet Pointer to Screen Address of Start of Line\n\nThis subroutine puts the address of the first byte of the screen line\ndesignated by the .X register into locations 209-210 ($D1-$D2)."}, {"id": "map-E9FF", "address_start": 59903, "address_end": 59903, "hex_start": "$E9FF", "hex_end": "$E9FF", "label": "", "source": "mapping-c64.txt", "chapter": ":: Chapter 7  ::", "type": "location", "text": "59903         $E9FF\nClear Screen Line\n\nThis subroutine writes space characters to an entire line of screen\nmemory, and clears the corresponding line of color memory to color in\nBackground Color Register 0 (53281, $D021)."}]