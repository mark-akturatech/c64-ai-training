[{"id": "map-B8FE", "address_start": 47358, "address_end": 47358, "hex_start": "$B8FE", "hex_end": "$B8FE", "label": "NORMAL", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47358         $B8FE          NORMAL\nNormalize Floating Point Accumulator #1"}, {"id": "map-B947", "address_start": 47431, "address_end": 47431, "hex_start": "$B947", "hex_end": "$B947", "label": "NEGFAC", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47431         $B947          NEGFAC\nReplace FAC1 with Its 2's Complement"}, {"id": "map-B97E", "address_start": 47486, "address_end": 47486, "hex_start": "$B97E", "hex_end": "$B97E", "label": "OVERR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47486         $B97E          OVERR\nPrint Overflow Error Message"}, {"id": "map-B9BC", "address_start": 47548, "address_end": 47548, "hex_start": "$B9BC", "hex_end": "$B9BC", "label": "FONE", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47548         $B9BC          FONE\nFloating Point Constant with a Value of 1\n\nThis five-byte floating point representation of the number 1 is stored\nhere for use by the floating point routines.  It is also used as the\ndefault STEP value for the FOR statement."}, {"id": "map-B9C1", "address_start": 47553, "address_end": 47553, "hex_start": "$B9C1", "hex_end": "$B9C1", "label": "LOGCN2", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47553         $B9C1          LOGCN2\nTable of Floating Point Constants for the LOG Function\n\nThis table of eight numeric constants in five-byte floating point\nrepresentation is used by the LOG function."}, {"id": "map-B9EA", "address_start": 47594, "address_end": 47594, "hex_start": "$B9EA", "hex_end": "$B9EA", "label": "LOG", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47594         $B9EA          LOG\nPerform LOG to Base E\n\nThe LOG to the base e of the number in FAC1 is performed here, and the\nresult left in FAC1."}, {"id": "map-BA28", "address_start": 47656, "address_end": 47656, "hex_start": "$BA28", "hex_end": "$BA28", "label": "FMULT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47656         $BA28          FMULT\nMultiply FAC1 with FAC2\n\nThis routine multiplies the contents of FAC1 by the contents of FAC2\nand stores the result in FAC1"}, {"id": "map-BA59", "address_start": 47705, "address_end": 47705, "hex_start": "$BA59", "hex_end": "$BA59", "label": "MLTPLY", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47705         $BA59          MLTPLY\nMultiply a Byte Subroutine\n\nThis subroutine is used to repetitively add a mantissa byte of FAC2 to\nFAC1 the number of times specified in the .A register."}, {"id": "map-BA8C", "address_start": 47756, "address_end": 47756, "hex_start": "$BA8C", "hex_end": "$BA8C", "label": "CONUPK", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47756         $BA8C          CONUPK\nMove a Floating Point Number from Memory into FAC2\n\nThis subroutine loads FAC2 from the four-byte number (three mantissa\nand one sign) pointed to by the .A and .Y registers."}, {"id": "map-BAB7", "address_start": 47799, "address_end": 47799, "hex_start": "$BAB7", "hex_end": "$BAB7", "label": "MULDIV", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47799         $BAB7          MULDIV\nAdd Exponent of FAC1 to Exponent of FAC2"}, {"id": "map-BAD4", "address_start": 47828, "address_end": 47828, "hex_start": "$BAD4", "hex_end": "$BAD4", "label": "MLDVEX", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47828         $BAD4          MLDVEX\nHandle Underflow or Overflow"}, {"id": "map-BAE2", "address_start": 47842, "address_end": 47842, "hex_start": "$BAE2", "hex_end": "$BAE2", "label": "MUL10", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47842         $BAE2          MUL10\nMultiply FAC1 by 10\n\nThis subroutine is called to help convert a floating point number to a\nseries of ASCII numerals."}, {"id": "map-BAF9", "address_start": 47865, "address_end": 47865, "hex_start": "$BAF9", "hex_end": "$BAF9", "label": "TENC", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47865         $BAF9          TENC\nThe Constant 10 in Five-Byte Floating Format"}, {"id": "map-BAFE", "address_start": 47870, "address_end": 47870, "hex_start": "$BAFE", "hex_end": "$BAFE", "label": "DIV10", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47870         $BAFE          DIV10\nDivide FAC1 by 10"}, {"id": "map-BB0F", "address_start": 47887, "address_end": 47887, "hex_start": "$BB0F", "hex_end": "$BB0F", "label": "FDIV", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47887         $BB0F          FDIV\nDivide a Number in Memory by FAC1\n\nThis number in memory is stored to FAC2, and this routine falls\nthrough to the next."}, {"id": "map-BB12", "address_start": 47890, "address_end": 47890, "hex_start": "$BB12", "hex_end": "$BB12", "label": "FDIVT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "47890         $BB12          FDIVT\nDivide FAC2 by FAC1\n\nThis routine is used to divide the contents of FAC2 by the contents of\nFAC1, with the result being stored in FAC1.  A check for division by 0\nis made before dividing."}, {"id": "map-BBA2", "address_start": 48034, "address_end": 48034, "hex_start": "$BBA2", "hex_end": "$BBA2", "label": "MOVFM", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48034         $BBA2          MOVFM\nMove a Floating Point Number from Memory to FAC1\n\nThis routine loads FAC1 with the five-byte floating point number\npointed to by the address stored in the Accumulator (low byte) and the\n.Y register (high byte)."}, {"id": "map-BBC7", "address_start": 48071, "address_end": 48071, "hex_start": "$BBC7", "hex_end": "$BBC7", "label": "MOV2F", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48071         $BBC7          MOV2F\nMove a Floating Point Number from FAC1 to Memory\n\nThis routine is used to move a number from the Floating Point\nAccumulator (FAC1) to memory at either 92-96 ($5C-$60) or 87-91\n($57-$5B), depending on the entry point to the routine."}, {"id": "map-BBFC", "address_start": 48124, "address_end": 48124, "hex_start": "$BBFC", "hex_end": "$BBFC", "label": "MOVFA", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48124         $BBFC          MOVFA\nMove a Floating Point Number from FAC2 to FAC1"}, {"id": "map-BC0C", "address_start": 48140, "address_end": 48140, "hex_start": "$BC0C", "hex_end": "$BC0C", "label": "MOVAF", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48140         $BC0C          MOVAF\nRound and Move a Floating Point Number from FAC1 to FAC2"}, {"id": "map-BC0F", "address_start": 48143, "address_end": 48143, "hex_start": "$BC0F", "hex_end": "$BC0F", "label": "MOVEF", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48143         $BC0F          MOVEF\nCopy FAC1 to FAC2 Without Rounding"}, {"id": "map-BC1B", "address_start": 48155, "address_end": 48155, "hex_start": "$BC1B", "hex_end": "$BC1B", "label": "ROUND", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48155         $BC1B          ROUND\nRound Accumulator #1 by Adjusting the Rounding Byte\n\nIf doubling the rounding byte at location 112 ($70) makes it greater\nthan 128, the value of FAC1 is increased by 1."}, {"id": "map-BC2B", "address_start": 48171, "address_end": 48171, "hex_start": "$BC2B", "hex_end": "$BC2B", "label": "SIGN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48171         $BC2B          SIGN\nPut the Sign of Accumulator #1 into .A Register\n\nOn exit from this routine the Accumulator will hold a 0 if FAC1 is 0,\na 1 if it is positive, and a value of 255 ($FF) if it is negative."}, {"id": "map-BC39", "address_start": 48185, "address_end": 48185, "hex_start": "$BC39", "hex_end": "$BC39", "label": "SGN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48185         $BC39          SGN\nPerform SGN\n\nThe SGN routine calls the above routine to put the sign of FAC1 into\n.A, and then converts that value into a floating point number in FAC1."}, {"id": "map-BC58", "address_start": 48216, "address_end": 48216, "hex_start": "$BC58", "hex_end": "$BC58", "label": "ABS", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48216         $BC58          ABS\nPerform ABS\n\nThe FAC1 sign byte at 102 ($66) is shifted right by this command, so\nthat the top bit is a 0 (positive)."}, {"id": "map-BC5B", "address_start": 48219, "address_end": 48219, "hex_start": "$BC5B", "hex_end": "$BC5B", "label": "FCOMP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48219         $BC5B          FCOMP\nCompare FAC1 to Memory\n\nOn entry to this routine, .A and .Y point to a five-byte floating\npoint number to be compared to FAC1.  After the comparison, .A holds 0\nif the two are equal, a 1 if the value of FAC1 is greater than that in\nthe memory location, and 255 ($FF) if the value of FAC1 is less than\nthat in the memory location."}, {"id": "map-BC9B", "address_start": 48283, "address_end": 48283, "hex_start": "$BC9B", "hex_end": "$BC9B", "label": "QINT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48283         $BC9B          QINT\nConvert FAC1 into Integer Within FAC1\n\nThis routine converts the value in FAC1 into a four-byte signed\ninteger in 98- 101 ($62-$65), with the most significant byte first."}, {"id": "map-BCCC", "address_start": 48332, "address_end": 48332, "hex_start": "$BCCC", "hex_end": "$BCCC", "label": "INT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48332         $BCCC          INT\nPerform INT\n\nThis routine removes the fractional part of a floating point number by\ncalling the routine above to change it to an integer, and then\nchanging the integer back to floating point format."}, {"id": "map-BCF3", "address_start": 48371, "address_end": 48371, "hex_start": "$BCF3", "hex_end": "$BCF3", "label": "FIN", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48371         $BCF3          FIN\nConvert an ASCII String to a Floating Point Number FAC1\n\nThis routine is called by VAL to evaluate and convert an ASCII string\nto a floating point number."}, {"id": "map-BD7E", "address_start": 48510, "address_end": 48510, "hex_start": "$BD7E", "hex_end": "$BD7E", "label": "FINLOG", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48510         $BD7E          FINLOG\nAdd Signed Integer to FAC1\n\nThis routine is used to add an ASCII digit that has been converted to\na signed integer to FAC1."}, {"id": "map-BDB3", "address_start": 48563, "address_end": 48563, "hex_start": "$BDB3", "hex_end": "$BDB3", "label": "NO999", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48563         $BDB3          NO999\n\nThis table of three floating point constants holds the values\n99,999,999.5, 999,999,999.5 and 1,000,000,000.  These values are used\nin converting strings to floating point numbers."}, {"id": "map-BDC0", "address_start": 48576, "address_end": 48576, "hex_start": "$BDC0", "hex_end": "$BDC0", "label": "INPRT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48576         $BDC0          INPRT\nPrint IN Followed by a Line Number"}, {"id": "map-BDCD", "address_start": 48589, "address_end": 48589, "hex_start": "$BDCD", "hex_end": "$BDCD", "label": "LINPRT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48589         $BDCD          LINPRT\nOutput a Number in ASCII Decimal Digits\n\nThis routine is used to output the line number for the routine above.\nIt converts thenumber whose high byte is in .A and whose low byte is\nin .X to a floating point number.  It also calls the routine below,\nwhich converts the floating point number to an ASCII string."}, {"id": "map-BDDD", "address_start": 48605, "address_end": 48605, "hex_start": "$BDDD", "hex_end": "$BDDD", "label": "FOUT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48605         $BDDD          FOUT\nConvert Contents of FAC1 to ASCII String\n\nThis routine converts a floating point number to a string of ASCII\ndigits, and sets a pointer to the string in .A and .Y."}, {"id": "map-BF11", "address_start": 48913, "address_end": 48913, "hex_start": "$BF11", "hex_end": "$BF11", "label": "FHALF", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48913         $BF11          FHALF\nThe Constant Value 1/2 in Five-Byte Floating Point Notation\n\nThis constant is used for rounding and SQR."}, {"id": "map-BF1C", "address_start": 48924, "address_end": 48924, "hex_start": "$BF1C", "hex_end": "$BF1C", "label": "FOUTBL", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48924         $BF1C          FOUTBL\nPowers of Minus Ten Constants Table\n\nThis table contains the powers of -10 expressed as four-byte floating\npoint numbers (that is, -1; +10; -100; +1000; -10,000; +100,000;\n-1,000,000; +10,000,000; and -100,000,000)."}, {"id": "map-BF3A", "address_start": 48954, "address_end": 48954, "hex_start": "$BF3A", "hex_end": "$BF3A", "label": "FDCEND", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48954         $BF3A          FDCEND\nTable of Constants for TI$ Conversion\n\nThis table contains the floating point representation of the powers of\n-60 multiplied by 1 or 10.  These constants are used for converting\nTI$ to ASCII."}, {"id": "map-BF52", "address_start": 48978, "address_end": 48978, "hex_start": "$BF52", "hex_end": "$BF52", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "48978         $BF52\nUnused area\n\nThis unused area is filled with byts of 170 ($AA)."}, {"id": "map-BF71", "address_start": 49009, "address_end": 49009, "hex_start": "$BF71", "hex_end": "$BF71", "label": "SQR", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "49009         $BF71          SQR\nPerform SQR\n\nThis routine moves the contents of FAC1 to FAC2, moves the constant\n0.5 to FAC1, and falls through to the exponentation routine."}, {"id": "map-BF7B", "address_start": 49019, "address_end": 49019, "hex_start": "$BF7B", "hex_end": "$BF7B", "label": "FPWRT", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "49019         $BF7B          FPWRT\nPerforms Exponentation (Power Calculation Called for by UPARROW)\n\nThis routine raises the value in FAC2 to the power in FAC1 and leaves\nthe result in FAC1."}, {"id": "map-BFB4", "address_start": 49076, "address_end": 49076, "hex_start": "$BFB4", "hex_end": "$BFB4", "label": "NEGOP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "49076         $BFB4          NEGOP\nPerform NOT and >\n\nThis negates the Floating Point Accumulator by exclusive ORing the\nsign byte with a constant of 255 ($FF).  Zero is left unchanged.  The\nresults of this command follow rom the formula NOT X=-(X+1).\nTherefore, if you NOT a tatement that is true (-1), you get 0 (false)."}, {"id": "map-BFBF", "address_start": 49087, "address_end": 49087, "hex_start": "$BFBF", "hex_end": "$BFBF", "label": "EXPCON", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "49087         $BFBF          EXPCON\nTable of Constants for EXP and LOG in Five-Byte Floating Point Format\n\nThese tables are used to calculate 2 to the N power."}, {"id": "map-BFED", "address_start": 49133, "address_end": 49133, "hex_start": "$BFED", "hex_end": "$BFED", "label": "EXP", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "49133         $BFED          EXP\nPerform EXP\n\nThis routine calculates the natural logarithm e (2.718281828...)\nraised to the power in FAC1.  The result is left in FAC1.\n\nThis routine is split between the BASIC ROM wich ends at 49151 ($BFFF)\nand the Kernal ROM which begins at 57344 ($E000).  Therefore, a JMP\n$E000 instruction is tacked on to the end, which makes the BASIC\nroutines in the 64 Kernal ROM three bytes higher in memory than the\ncorresponding VIC-20 routines."}, {"id": "map-C000-CFFF", "address_start": 49152, "address_end": 53247, "hex_start": "$C000", "hex_end": "$CFFF", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 5 ::", "type": "location", "text": "49152-53247   $C000-$CFFF\n4K Free RAM\n\nLocations 49152 to 53247 ($C000 to $CFFF) are free RAM.  Since this\narea is not contiguous with the BASIC program text RAM area, it is not\navailable for BASIC program or variable storage (it is not counted in\nthe FRE(0) total).\n\nThis area is fully available for any other use, however, sudh as\nstoring machine language subroutines for use with BASIC, alternate I/O\ndrivers for parallel or IEEE devices, character graphics or sprite\ndata, etc.\n\nThis large free area is such a tempting spot for system additions that\nmany such applications may be competing for the same RAM space.  For\nexample, the Universal Wedge DOS Support program that adds easy access\nto the disk communications channel is usually loaded at 52224 ($CC00).\nPrograms that use that part of RAM will therefore overwrite the DOS\nsupport program, with the result that they may not run correctly, or\neven at all.  Likewise, Simon's BASIC, the extended language which\nCommodore has released on cartridge, uses several locations in this\nrange.  Be aware of this potential problem when you buy hardware\nadditions that use this spot to hook into the system.\n\n\n::::::::::::::::::::\n::                ::\n::VIC-II, SID, I/O::\n:: Devices, Color ::\n::    RAM, and    ::\n:: Character ROM  ::\n::::::::::::::::::::"}, {"id": "map-D000-DFFF", "address_start": 53248, "address_end": 57343, "hex_start": "$D000", "hex_end": "$DFFF", "label": "", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53248-57343   $D000-$DFFF\n\nThis 4K block of memory is used for several key functions.  Normally,\nthe 6510 microprocessor addresses the two Complex Interface Adapter\n(CIA) Input/Output chips here, along with the VIC-II video controller\nchip, the Sound Interface Device (SID) music synthesizer, and the\nColor RAM.\n\nAlternatively, the 6510 can address the character ROM here (though\nnormally only the VIC-II chip has access to it).  Finally, there is\nalso 4K of RAM here, although to use it may require banking it in only\nwhen necessary, as the I/O devices are needed for such niceties as\nreading he keyboard, and updating the screen display.\n\nIt will appear from the map of the I/O devices below that many of the\nlocations are not accounted for.  That is beause these devices tie up\nmore addressing space than they actually use.  Each of them uses only\na few addresses, mostly on the bit level.\n\nThe missing addresses either consist of images of the hardware\nregisters, or cannot be addressed in this configuration.  In addition,\nsome address space is left open for the use of future hardware devices\nwhich might be plugged into the expansion port, like the CP/M card.\n\nAs mentioned above, memory usage by these I/O devices is to intensive\nthat to work with them often requires that you turn individual bits on\nand off.  Here is a quick reminder of how to manipulate bits.\n\nThe bit values for each bit are:\n\nBit 0 = 1\nBit 1 = 2\nBit 2 = 4\nBit 3 = 8\nBit 4 = 16\nBit 5 = 32\nBit 6 = 64\nBit 7 = 128\n\nTo set a bit to 1 from BASIC, POKE address, PEEK(address) OR Bitvalue.\nTo reset a bit to 0 from BASIC, POKE address, PEEK(address) AND\n255-Bitvalue."}, {"id": "map-D000-D02E", "address_start": 53248, "address_end": 53294, "hex_start": "$D000", "hex_end": "$D02E", "label": "", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53248-53294   $D000-$D02E\nVIC-II Chip Registers\n\nThe Video Interface Controller (VIC-II chip) is a specially designed\nprocessor that is in charge of the 64's video display.  It is this\nchip which makes possible the 64's wide range of graphics\ncapabilities.\n\nThe VIC-II chip's ability to address memory is independent of the 6510\nmicroprocessor.  It can address only 16K at a time, and any of the\nfour blocks of 16K can be chosen for video memory.  The system default\nis for it to use the first 16K.\n\nAll of the video display memory, character dot data, and sprite shapes\nmust be stored within the chosen 16K block.  Locations 53248-53294\n($D000-$D02E) are registers which allow the user to communicate with\nthe VIC-II chip.  Although for the most part they can be written to\nand read like ordinary memory locations, their contents directly\ncontrol the video display.  Since many of these locations work in\nclose conjunction with others, a general overview of some of the\ndifferent graphics systems on the 64 is in order.\n\nThe most familiar type of graphics display is the ordinary text that\nappears when you turn the machine on.  The area of RAM which is\ndisplayed on the screen is determined by the Video Matrix Base Address\nNybble of the VIC-II Memory Control Register (53272, $D018).  The\naddress of the dot-data which is used to assign a shape to each text\ncharacter based on an 8 by 8 matrix of lit or unlit dots is determined\nby the other half of the Memory Control Register at 53272 ($D018).\nMore information on how the data is used to represent the character\nshapes may be found at the alternate entry for 49152 ($C000), the\nCharacter Generator ROM.\n\nText character graphics may employ one of the two sets of text and\ngraphics characters in the Character Generator ROM, or the user may\nsubstitute a completely different set of graphics or text characters\nin RAM.\n\nNormally, the text graphics screen uses a background color which is\ncommon to all text characters, and that value is stored in Background\nColor Register 0 (53281, $D021).  The color of the frame around the\nscreen is determined by the Border Color Register at 53280 ($D020).\n\nThe color of each character is determined by one nybble of the Color\nRAM which starts at 55296 ($D800).  There are, however, two variations\nwhich alter this scheme somewhat.\n\nThe first is called multicolor text mode, and is set by Bit 4 of 53270\n($D016).  Instead of each bit selecting either the foreground or the\nbackground color for each dot in the character, bit-pairs are used to\nselect one of four colors for each double-width dot.  This results in\nthe horizontal resolution being cut to four dots across per character,\nbut allows two extra colors to be introduced from Background Color\nRegisters 1 and 2 (53282-53283, $D022-$D023).\n\nThe other text mode is called Extended Background Color Mode.  In this\nmode, the foreground color is always selected by the Color RAM.  The\nbackground color depends on the actual screen code of the character.\nIn this mode, only the first 64 character shapes are available, but\neach can have one of four different background colors.\n\nThe background color for each character is determined by its screen\ncode as follows:\n\n1.  If the screen code is from 0-63 (this includes the normal\nalphanumerics), the value in Background Color Register 0 (53281,\n$D021) will determine the background color, as is usual.\n\n2.  Characters with codes 64-255 will have the same shape as the\ncorresponding character in the group with codes 0-63.\n\n3.  For characters with codes 64-127 (SHIFTed characters), the\nbackground colors are deterined by the value in Background Color\nRegister 1 (53282, $D022).\n\n4.  The value in Background Color Register 2 (53283, $D023) is used\nfor characters with codes 128-191 (reversed alphanumerics).\n\n5.  For characters with codes 192-255, the value in Background Color\nRegister 3 (53284, $D024) is used to determine the background color.\n\n\nIn place of the normal text mode, a bitmap graphics mode is also\nabailable by setting Bit 5 of location 53265 ($D011).  In this mode,\neach bit of data determines whether one dot on the screen will be set\nto either the background color or foreground color.  Within an 8 by 8\ndot area, the foreground and background colors may be individually\nselected.\n\nThe bitmap area is 320 dots wide and 200 dots high.  The area which\ncontains the graphics data, the bitmap, is determined by the Character\nDot Data Base Address in the lower nybble of the VIC-II Memory Control\nRegister (53272, $D018).  The Video Matrix Base Address in the upper\nnybble, which normally determines which area of memory will be\ndisplayed, instead determines where the color memory for each 8 by 8\nground of dots will be located.\n\nThe Color RAM is not used for high-resolution bitmap graphics.  But\nmulticolor mode is also available for bitmap graphics, and it uses the\nColor RAM to determine the foreground color of each dot.\n\nAs with multicolor text mode, the horizontal resolution is but in half\n(to 160 dots across), so that in addition to the foreground and\nbackground colors, each dot can be one of two other colors as well.\nThis mode gets the value for the two extra colors from the two nybbles\nof each byte of bitmap color memory, the location of which is\ndetermined by the Video Matrix Base Address.\n\nMulticolor text mode offers four colors, three of which will be common\nto all characters, and one of which can be selected individually.\nMulticolor bitmap mode offers a choice of four colors, three of which\ncan be individually selected within an 8 by 8 dot area.\n\nThe 64 also contains an entirely separate graphics system, whose\ncharacter shapes, colors, and positions are derived and displayed\nwithout any reference to the Video Matrix and Character Dot-Data\naddresses.  Best of all, these characters may be moved quickly and\neasily to any position on the screen, greatly facilitating games and\nanimated graphics of all types.  This system is known as sprite\ngraphics.\n\nSprite graphics takes its name from the graphics characters it\ndisplays, each of which is called a sprite.  There are eight sprites,\nknown as Sprites 0-7.  Each sprite character is 24 dots wide by 21\ndots high.  This is about eight times as large as a regular text\ncharacter, which is only 8 dots wide by 8 dots high.\n\nA sprite takes its shape from 63 bytes of data in one of the 256 data\nblocks, each 64 bytes long, that can fit into the 16K space which the\nVIC-II chip can address.  The block currently assigned to any given\nsprite is determined by the Sprite Data Pointers, which are located at\nthe last eight bytes of the screen memory area (the default locations\nare 2040-2047, $7F8-$7FF).\n\nThe first Sprite Data Pointer determines the data block used for the\nshape of Sprite 0, the second for the shape of Sprite 1, etc.  The\nnumber in the pointer times 64 equals the address of the first byte of\nthe data block within the VIC-II addressing range.\n\nFor example, using the default values for VIC-II addressing area and\nscreen memory, a value of 11 in location 2040 ($7F8) would mean that\nthe shape of Sprite0 is determined by the data in the 63-byte block\nstarting at location 704 (11*64).  It should be noted that it is\npossible for more than one sprite to take its shape data from the same\nblock, so that only 64 bytes of data are required to create eight\nsprites, each having the same shape.\n\nThe dot patterns of each sprite correspond to the bit patterns of the\nsprite shape data.  Each byte of shape data in memory consists of a\nnumber from 0 to 255.  This number can be represented by eight binary\ndigits of 0 or 1.\n\nEach binary digit has a bit value that is two times greater than the\nlast.  If the digit in the zero bit place is a 1, it has a value of 1\n(we count bit places from 0 to 7).  A 1 in the first bit place has a\nvalue of 2, the second bit has a value of 4, the third has a value of\n8, the fourth has a vlue of 16, the fifth a value of 32, the sixth a\nvalue of 64, and the seventh a value of 128.\n\nBy making all of the possible combinations of 0's and 1's in all eight\nbit places, and adding the bit values of every bit place that contains\na 1, we can represent every number from 0 to 255 as a series of 1's\nand 0's.\n\nIf you think of every 0 as a dot having the same color as the\nbackground, and every 1 as a dot which is the color of the sprite, you\ncan see how a series of bytes could be used to represent the sprite\nshape.\n\nSince each line of the sprite is 24 dots wide, it takes 3 bytes of\nmemory (24 bits) per line to portray its shape.  Let's take a look at\na couple of sample sprite lines.\n\n00000000 01111110 00000000 = 0, 126, 0\n\nAs you can see, the first and last bytes are all 0's, so nothing will\nbe displayed there.  The middle byte has six 1's, so it will be\ndisplayed as a line six dots long.  By adding the values of these dix\nbits (64+32+16+8+4+2), we get a byte value of 126.  Let's try another\nline.\n\n00011111 11111111 11111000 = 21, 255, 248\n\nThe first byte has five bits set to 1, having values of 16, 8, 4, 2,\nand 1, for a total of 31.  The second byte has all bits set to 1, so\nit has the maximum value of 255.  The third byte also has five bits\nset to 1, having values of 128, 64, 32, 16, and 8, for a total of 248.\nThe result is that this line of sprite data will display a line that\nis 18 dots long.\n\nWe can put these two kinds of lines together to show how a large cross\nmight be drawn using bytes of sprite data.\n\n000000000000000000000000 = 0, 0, 0\n000000000000000000000000 = 0, 0, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000111111111111111111000 = 21, 255, 248\n000111111111111111111000 = 21, 255, 248\n000111111111111111111000 = 21, 255, 248\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000111111000000000 = 0, 126, 0\n000000000000000000000000 = 0, 0, 0\n000000000000000000000000 = 0,0,0\n\nThe 63 numbers, displayed three per line opposite the bit patters they\nrepresent, are the values that would have to be put in the sprite\nshape data area in order to display this cross using sprite graphics.\n\nEven after the sprite shape data has been placed in memory, and the\nSprite Data Pointer has been set to display that block of data bytes\nas the sprite shape, there are still several steps that must be taken\nin order to display the sprite on the screen.\n\nThe proper bit of the Sprite Display Enable Register at 53269 ($D015)\nmust be set to 1 in order to turn on the sprite display.  A horizontal\nand vertical screen position must be selected for the sprite by means\nof the horizontal and vertical position registers (53248-53264,\n$D000-$D010).  Finally, the color value of the sprite should be placed\nin the appropriate Sprite Color Register (53287-53294, $D027-$D02E).\n\nOnce you have the sprite on the screen, animation is fairly simple to\nachieve.  Moving the sprite is as easy as changing the values in the\nsprite position registers.  Changing the sprite shape can be\naccomplished by merely changing the Sprite Data Pointer to point to\nanother block of shape data in memory.\n\nThere are also some optional sprite graphics features available which\nenhance its flexibility.  Sprite expand registers allow you to make\neach sprite twice as wide as normal, twice as tall, or both.\nCollision detection registers let you know when a sprite shape\noverlaps a regular text character or bitmap dot, or if two sprites are\ntouching.\n\nIf a sprite is positioned in the same place on the screen as a text\ncharacter or bitmap dot, a Priority Register allows you to choose\nwhether the sprite or the normal graphics will by displayed.  This\nenables three- dimensional effects by letting you choose whether the\nsprite goes in front of or behind other objects on the screen.\n\nFinally, any sprite may be selected for multicolor display, using the\nregister at location 53276 ($D01C).  In this mode, as in multicolor\ntext and bitmap modes, pairs of bits are used to determine the color\nof each double- width dot.  The possible color values which may be\nselected are those of Background Color Register 0, the Sprite Color\nRegister, or the two color values in the Sprite Multicolor Registers\nat 53285-53286 ($D025-$D026)."}, {"id": "map-D000-D010", "address_start": 53248, "address_end": 53264, "hex_start": "$D000", "hex_end": "$D010", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location_range", "text": "Location Range: 53248-53264 ($D000-$D010)\nSprite Horizontal and Vertical Position Registers\n\nThese locations determine the horizontal and vertical position at\nwhich each sprite will be displayed on the screen.  Each sprite has\nits own horizontal and vertical position register.  In addition, all\nof the sprites share a common register which is used to extend the\nrange of horizontal positions.\n\nVertical positions for each sprite range from 0 to 255, and these\nindicate the vertical position of the top line of the sprite's 21-line\nlength.  Since there are only 200 visible scan lines in the screen\ndisplay, some of these vertical positions will result in the sprite\nbeing partially or wholly offscreen.\n\nThe visible viewing area starts at line 50 and extends to line 249.\nTherefore, any sprite whose vertical psition is 29 ($1D) or less will\nbe completely above the visible picture.  At vertical position 30\n($1E), the bottom line of the sprite display becomes visible at the\ntop of the screen.  At position 230 ($E6), the bottom line of the\nsprite is lost from view off the bottom of the screen, and at vertical\nposition 250 ($FA), the entire sprite disappears from view off the\nbottom edge of the screen.\n\nHorizontal positioning is somewhat trickier, because the visible\ndisplay area is 320 dots wide, and one eight-bit register can hold\nonly 256 position values.  Therefore, an additional register is needed\nto hold the ninth bit of each sprite's horizontal position.\n\nEach sprite is assigned a single bit in the Most Significant Bit of\nHorizontal Position register (MSB register) at 53264 ($D010).  If that\nbit is set to 1, the value 256 is added to the horizontal position.\nThis extends the range of possible horizontal positions to 511.\n\nIn order to set a sprite's horizontal position, you must make sure\nthat both the values in the horizontal position register and the MSB\nRegister are correct.  For example, if you wish to set the horizontal\nposition of Sprite 5 to a value of 30, you must place a value of 30 in\nthe Sprite 5 Horizontal Position Register (POKE 53258,30 will do it\nfrom BASIC), and you must also clear Bit 5 of the MSB Register (POKE\n53264,PEEK(53264)AND(255-16)).  If you forget the MSB register, and\nBit 5 is set to 1, you will end up with position 286 instead of 30.\n\nThe horizontal position value indicates the position of the leftmost\ndot of the sprite's 24-dot width.  The visible display is restricted\nto the 320 dot positions between positions 24 and 344.  At position 0\nthe whole sprite is past the left edge of the visible screen.  At\nposition 1 the righmost dot enters the display area, and at position\n24 ($18) the entire sprite is displayed on screen.  At position 321\n($141) the rightmost dot goes past the right edge of the visible\ndisplay area, and a position 355 ($158) the whole sprite has moved out\nof sight, off the right edge of the screen.\n\nThese registers are all intialized to 0 at power-up."}, {"id": "map-D000", "address_start": 53248, "address_end": 53248, "hex_start": "$D000", "hex_end": "$D000", "label": "SP0X", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53248         $D000          SP0X\nSprite 0 Horizontal Position"}, {"id": "map-D001", "address_start": 53249, "address_end": 53249, "hex_start": "$D001", "hex_end": "$D001", "label": "SP0Y", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53249         $D001          SP0Y\nSprite 0 Vertical Position"}, {"id": "map-D002", "address_start": 53250, "address_end": 53250, "hex_start": "$D002", "hex_end": "$D002", "label": "SP1X", "source": "mapping-c64.txt", "chapter": "::   Chapter 6    ::", "type": "location", "text": "53250         $D002          SP1X\nSprite 1 Horizontal Position"}]