[{"id": "map-0-8F", "address_start": 0, "address_end": 143, "hex_start": "$0", "hex_end": "$8F", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location_range", "text": "Location Range: 0-143 ($0-$8F)\nBASIC Working Storage\n\nThis portion of zero page is used by BASIC only.  Therefore, a program\nwritten entirely in machine language that does not interact with BASIC\ncan freely use this area."}, {"id": "map-0", "address_start": 0, "address_end": 0, "hex_start": "$0", "hex_end": "$0", "label": "D6510", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "0             $0             D6510\n6510 On-Chip I/O DATA Direction Register\n\nBit 0: Direction of Bit 0 I/O on port at next address.  Default = 1 (output)\nBit 1: Direction of Bit 1 I/O on port at next address.  Default = 1 (output)\nBit 2: Direction of Bit 2 I/O on port at next address.  Default = 1 (output)\nBit 3: Direction of Bit 3 I/O on port at next address.  Default = 1 (output)\nBit 4: Direction of Bit 4 I/O on port at next address.  Default = 0 (input)\nBit 5: Direction of Bit 5 I/O on port at next address.  Default = 1 (output)\nBit 6: Direction of Bit 6 I/O on port at next address.  Not used.\nBit 7: Direction of Bit 7 I/O on port at next address.  Not used.\n\nThis location is the first of a number of hardware registers that we\nwill discuss.  Although they can be written to and/or read like RAM,\nthey are connected to hardware devices, and their contents affect the\noperation of the devices.\n\nEach bit of this Data Direction Register determines whether the\ncontents of the corresponding bit on the Internal I/O Port (see\nlocation 1) can be written to by peripheral devices.  If the bit is\nset to 0, it indicates the direction of data flow as Input, which\nmeans that the corresponding bit of the I/O port will be affected by\nperipheral defices.  If the bit is set to 1, it indicates Output.  On\nthe 64, only Bits 0-5 are significant.  On power-up, this register is\nset to 239 ($EF), which indicates that all bits, except for Bit 4\n(which senses the cassette switch), are set up for Output."}, {"id": "map-1", "address_start": 1, "address_end": 1, "hex_start": "$1", "hex_end": "$1", "label": "R6510", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "1             $1             R6510\n\nBit 0: LORAM signal.  Selects ROM or RAM at 40960 ($A000).  1=BASIC, 0=RAM\nBit 1: HIRAM signal.  Selects ROM or RAM at 57344 ($E000).  1=Kernal, 0=RAM\nBit 2: CHAREN signal.  Selects character ROM or I/O devices.  1=I/O, 0=ROM\nBit 3: Cassette Data Output line.\nBit 4: Cassette Switch Sense.  Reads 0 if a button is pressed, 1 if not.\nBit 5: Cassette Motor Switch Control.  A 1 turns the motor on, 0 turns it off.\nBits 6-7: Not connected--no function presently defined.\n\nThe chief function of this register is to determine which blocks of\nRAM and ROM the 6510 microprocessor will address.  The Commodore 64\ncomes with 64K RAM, even though it normally does not use all of that\nRAM at once.  In addition, it has an 8K BASIC Interpreter ROM, an 8K\nOperating System Kernal ROM, a 4K Character Generator ROM, a Sound\nInterface Device (SID), a 6566 Video Interface Controller (VIC-II),\nand two 6526 Complex Interface adapter chips.\n\nTo address all of these at once would require 88K, 24K past the\naddressing limit of the 6510 microprocessor.  In order to allocate\naddress space, the I/O Port is used to affect the addressing lines,\nand thus determine which segments of RAM and ROM will be addressed at\nany one time.\n\nBit 0.  This bit controls the LORAM signal.  A 0 in this bit position\nswitches the BASIC ROM out, and replaces it with RAM at addresses\n40960-49151 ($A000-$BFFF).  The default value of this bit is 1.\n\nBit 1.  Bit 1 controls the HIRAM signal.  A 0 in this bit position\nswitches the Kernal ROM out, and replaces it with RAM at 57344-65535\n($E000-$FFFF).  As the BASIC interpreter uses the Kernal, it is also\nswitched out and replaced by RAM.  The default value of this bit is 1.\n\nThe system allows a wide range of combinations of RAM and ROM to be\nutilized.  Of course, the BASIC programmer will have little need, in\nthe ordinary course of events, to switch out the BASIC ROM and the\nKernal.  To do so would just hang the system up.  But one way to make\nuse of this feature is to move the contents of ROM to the\ncorresponding RAM addresses.  That way, you can easily modify and\ncustomize the BASIC interpreter and OS Kernal routines, which are\nordinarily fixed in ROM.  For examples, to move BASIC into RAM, just\ntype:\n\nFOR I=40960 TO 49151:POKE I,PEEK(I):NEXT\n\nThough it appears that such a program would not do anything, it in\nfact copies bytes from ROM to RAM.  This is because any data which is\nwritten to a ROM location is stored in the RAM which resides at the\nsame address.  So while you are PEEKing ROM, you are POKEing RAM.  To\nswitch to your RAM copy of BASIC, type in:\n\nPOKE 1,PEEK(1) AND 254.\n\nNow you are ready to make modifications.  Examples of simple\nmodifications include changing the text which the interpreter prints,\nsuch as the READY prompt, the power-up message, or the keyword table.\n\nAn example of the latter would be POKE 41122,69.  This changes the FOR\nkeyword to FER, so that BASIC would respond normally to a FER-NEXT\nloop, but fail to recognize FOR as syntactically correct.\n\nOn the more practical side, you could change the prompt that INPUT\nissues to a colon, rather than a question mark:\n\nPOKE 43846,58\n\nYou are not limited to just cosmetic changes of text.  Jim Butterfield\nhas given an example in COMPUTE! magazine of changing the interpreter\nso that it assigns a null string the ASCII value 0.  In the ROM\nversion, the command PRINT ASC(\"\") will return ?ILLEGAL QUANTITY\nERROR.  This is inconvenient when INPUTting a string, because if the\nuser presses RETURN and you try to check the ASCII value of the string\nthat has been entered, you will get this error.  By entering POKE\n46991,5, this is changed so that PRINT ASC(\"\") now responds with a\nzero.\n\nFor the more serious machine language programmer, it is quite feasible\nto add new commands or modify existing ones by diverting the vectors\nwhich are discussed in the section covering the BASIC interpreter ROM.\nFor a good example of this technique, see the article \"Hi-Res Graphics\nMade Simple\" by Paul Schatz in COMPUTE!'s First Book of Commodore 64\nSound and Graphics.  The program example there inserts new graphics\ncommands into a RAM version of BASIC.  When you want to switch back to\nthe ROM BASIC, enter POKE 1,PEEK(1) OR 1.\n\nFor machine language applications, it would be possible to replace the\nROM programs with an entirely different operating system, or an\napplication that has its own screen editing and I/O functions\nincluded.  Such an application would first have to be loaded from disk\ninto RAM.  A language other than BASIC could be loaded, and could then\njust switch out the BASIC ROM, while still using the OS Kernal.\n\nOr a spreadsheet application that contained its own I/O routines could\nswitch out all ROMs and have the use of all of RAM that is not\nactually needed for the program itself, for data.  It should be\nremembered, however, that before switching the Kernal out, it is\nnecessary to disable interrupts, as the vectors for these interrupts\nare contained in the Kernal.\n\nBit 2.  This bit controls the CHAREN signal.  A 0 in this position\nswitches the character generator ROM in, so that it can be read by the\n6510 at addresses 53248-57343 ($D000-$DFFF).  Normally, this bit is\nset to 1, so that while the VIC-II chip has access to the character\ngenerator ROM for purposes of creating the screen display, the user\ncannot PEEK into it.  Since this ROM is switched into the system in\nthe same location as the I/O devices (SID chip, VIC-II chip, and 6526\nCIA's), o I/O can occur when this ROM is switched in.\n\nThe ability to switch in the character generator ROM is very useful to\nthe programmer who wishes to expirement with user-defined characters.\nModified character graphics is one of the  more powerful graphics\ntools available, but often the user will not want to redefine a whole\ncharacter set at one time.  By reading the character ROM and\nduplicating its contents in RAM, the user can replace only a few\ncharacters in the set.  The method for reading this ROM into RAM from\nBASIC is as follows:\n\n10 POKE 56333,127:POKE1,PEEK(1) AND 251:FOR I=0 TO 2048\n20 POKE BASE+I,PEEK(53248+I):NEXT:POKE 1,PEEK(1) OR 4:POKE 56333,129\n\nThe first POKE is necessary to turn off the system timer interrupt.\nSince the I/O devices are addressed in the same space as the character\nROM, switching that ROM in switches all I/O out, making it necessary\nto turn off any interrupts which use these devices.\n\nThe second POKE is the one which switches in the character ROM.  The\nprogram loop then reads this ROM memory into RAM, starting with the\naddress BASE.  Note that this address should start on an even 2K\nboundary (an address evenly divisible by 2048) within the block of\nmemory presently being addresses by the VIC-II chip (for more\ninformation on where to put user-defined character sets, and how to\nuse them, see the section on the VIC-II chip, under location 53272\n($D018), the section on the character ROM at 49152 ($C000), and the\nsection on banking VIC-II memory at 56576 ($DD00)).  After reading the\ncontents of ROM into RAM, the next POKEs switch out the character ROM\nand restore the interrupt.\n\nIt should be noted that while Bits 0-2 of this register allow software\ncontrol of some signals that determine the memory configuration that\nis used by the Commodore 64 at any given time, they are not the only\ndetermining factor.  Signals can also be generated by means of plug-in\nexpansion cartridges which are connected to the expansion port, and\nthese can change the memory map.\n\nTwo lines located on the exapansion port are called GAME and EXROM.\nWhen used in conjunction with the software-controlled lines noted\nabove, these two hardware lines can enable cartridge ROM to replace\nvarious segments of ROM and/or RAM.\n\nPossible configurations include 8K of cartridge ROM to be switched in\nat $8000-$9FFF, for a BASIC enhancement program; an 8K cartridge ROM\nat $A000-$BFFF, replacing BASIC, or at $E000-$FFFF, replacing the\nKernal, or a 16k cartridge at $8000-$C000.\n\nWhen cartridge ROM is selected to replace the Kernal, a Max emulator\nmode is entered, which mimics the specification of the ill-fated Max\nMachine, a game machine which Commodore never produced for sale int he\nU.S.  In this mode, only the first 6K of RAM are used, there is no\naccess to the character ROM, and graphics data such as charactger\ndot-data is mapped down from 57344 ($E000) to 8192 ($2000).  Further\nhardware information may be obtained from the Commodore 64\nProgrammer's Reference Guide.\n\nBits 3-5 of this register have functions connected with the Datasette\nrecorder.  These are as follows:\n\nBit 3.  This is the Cassette Data Output line.  This line is connected\nto the Cassette Data Write line on the cassette port, and is used to\nsend the data which is written to tape.\n\nBit 4.  This bit is the Cassette Switch Sense line.  This bit enables\na program to tell whether or not one of the buttons that moves the\nrecorder is pressed down.  If the switch on the recorder is down, this\nbit will have a value of 1.  Remember that Bit 4 of the data direction\nregister at location 0 must contain a 0 for this bit to properly\nreflect the status of the switch.\n\nBit 5.  Bit 5 is the Cassette Motor Control.  Setting this bit to zero\nallows the motor to turn when you press one of the buttons on the\nrecorder, while setting it to one disables it from turning.\n\nMost of the time, the setting of this bit will be controlled by the\ninterrupt routine that is used to read the keyboard every sixtieth of\na second.  If none of the buttons on the recorder is pressed, that\ninterrupt routine shuts the motor off and sets the interlock at\nlocation 192 ($C0) to zero.  When a button is pressed, if the\ninterlock location is zero, Bit 5 of this register is set to zero to\nturn the motor on.\n\nWhen the interlock location contains a zero, the keyscan routine will\nnot let you control the setting of this bit of the register (and the\ninterlock is always set to zero when no buttons are pressed).  In\norder for you to gain control of the motor, you must POKE a nonzero\nvalue into 192 after a button on the recorder has been pressed.  You\ncan then shut off the motor and turn it back on as you please, by\nmanipulating this bit, so long as a button stays pressed."}, {"id": "map-3-4", "address_start": 3, "address_end": 4, "hex_start": "$3", "hex_end": "$4", "label": "ADRAY1", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "3-4           $3-$4          ADRAY1\nVector: Routine to Convert a Number from Floating Point to Signed\nInteger\n\nThis vector points to the address of the BASIC routine which converts\na floating point number to an integer.  In the current Kernal version,\nthe address that it points to is 45482 ($B1AA).  Disassembly of the\nROMs indicates that BASIC does not use this vector.  However, it may\nbe of real assistance to the programmer who wishes to use data that is\nstored in floating point format.  The parameter that is passed by the\nUSR command is available only in that format, for example.\n\nSince it is extremely difficult to decipher and use a floating point\nnumber, the simplest way to deal with such data is to use the\nconversion routines that are built into BASIC to change it into a\ntwo-byte signed integer.  This could be accomplished by jumping\ndirectly into the BASIC ROM, if you know the location of the routine.\nTherefore, if the address changes in future versions of the 64 or\nfuture Commodore computers, you won't have to modify your program to\nmake it work with them.\n\nSee the entry for the USR vector at 785 ($311) for an explanation of\nhow to use this routine in connection with the USR command."}, {"id": "map-5-6", "address_start": 5, "address_end": 6, "hex_start": "$5", "hex_end": "$6", "label": "ADRAY2", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "5-6           $5-$6          ADRAY2\nVector: Routine to Convert a Number from Integer to Floating Point\n\nThis vector points to the address of the BASIC routine which converts\nan integer to a floating point number.  This routine is currently\nlocated at 45969 ($B391).  BASIC does not appear to reference this\nlocation.  It is available for use by the programmer who needs to make\nsuch a conversion for a machine language program that interacts with\nBASIC.  For an explanation of how to use this routine in connection\nwith the USR command, see the entry for the USR vector at 785 ($311)."}, {"id": "map-7", "address_start": 7, "address_end": 7, "hex_start": "$7", "hex_end": "$7", "label": "CHARAC", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "7             $7             CHARAC\nSearch Character for Scanning BASIC Text Input\n\nThis location and the next are used heavily by the BASIC routines that\nscan the text that comes into the buffer at 512 ($200), in order to\ndetect significant characters such as quotes, comma, the colon which\nseparates BASIC statements, and end-of-line.  The ASCII values of such\nspecial characters are usually stored here.\n\nThis location is also used as a work area by other BASIC routines that\ndo not involve scanning text."}, {"id": "map-8", "address_start": 8, "address_end": 8, "hex_start": "$8", "hex_end": "$8", "label": "ENDCHR", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "8             $8             ENDCHR\nSearch Character for Statement Termination or Quote\n\nLike location 7, this location is used as a work byte during the\ntokenization of a BASIC statement.  Most of the time, its value is 0\nor 34."}, {"id": "map-9", "address_start": 9, "address_end": 9, "hex_start": "$9", "hex_end": "$9", "label": "TRMPOS", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "9             $9             TRMPOS\nColumn position of the Cursor before the Last TAB or SPC\n\nTRMPOS is used by TAB and SPC.  The cursor column position prior to\nthe TAB or SPC is moved here from 211 ($D3), and is used to calculate\nwhere the cursor ends up after one of these functions is invoked.\nNote that the value contained here shows the position of the cursor on\na logical line.  Since one logical line can be up to two physical\nlines long, the value stored here can range from 0 to 79."}, {"id": "map-A", "address_start": 10, "address_end": 10, "hex_start": "$A", "hex_end": "$A", "label": "VERCK", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "10            $A             VERCK\nFlag: LOAD or VERIFY\n\nBASIC uses one Kernal routine to perform either the LOAD or VERIFY\nfunction, depending on whether the Accumulator (.A) is set to 0 or 1\nupon entry to the routine.  BASIC sets the value of VERCK to 0 for a\nLOAD, or 1 for a VERIFY.  Its contents are passed to the Kernal LOAD\nroutine, which in turn stores it in location 147 ($93)."}, {"id": "map-B", "address_start": 11, "address_end": 11, "hex_start": "$B", "hex_end": "$B", "label": "COUNT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "11            $B             COUNT\nIndex into the Text Input Buffer/Number of Array Subscripts\n\nThe routines that convert the text in the input buffer at 512 ($200)\ninto lines of executable program tokes, and the routines that link\nthese program lines together, use this location as an index into the\ninput buffer area.  When the job of converting text to tokens is\nfinished, the value in this location is equal to the length of the\ntokenized line.\n\nThe routines which build an array or locate an element in an array use\nthis location to calculate the number of DIMensions called for and the\namount of storage required for a newly created array, or the number of\nsubscripts specified when referencing an array element."}, {"id": "map-C", "address_start": 12, "address_end": 12, "hex_start": "$C", "hex_end": "$C", "label": "DIMFLG", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "12            $C             DIMFLG\nFlags for the Routines That Locate or Build an Array\n\nThis location is used as a flag by the routines that build an array or\nreference an existing array.  It is used to determine whether a\nvariable is in an array, whether the array has already been\nDIMensioned, and whether a new array should assume the default\ndimensions."}, {"id": "map-D", "address_start": 13, "address_end": 13, "hex_start": "$D", "hex_end": "$D", "label": "VALTYP", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "13            $D             VALTYP\nFlag: Type of Data (String or Numeric)\n\nThis flag is used internally to indicate whether data being operated\nupon is string or numeric.  A value of 255 ($FF) in this location\nindicates string data, while a 0 indicates numeric data.  This\ndetermination is made every time a variable is located or created."}, {"id": "map-E", "address_start": 14, "address_end": 14, "hex_start": "$E", "hex_end": "$E", "label": "INTFLG", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "14            $E             INTFLG\nFlat: Type of Numeric Data (Integer or Floating Point)\n\nIf data which BASIC is using is determined to be numeric, it is\nfurther classified here as either a floating point number or as an\ninteger.  A 128 ($80) in this location identifies the number as an\ninteger, and a 0 indicates a floating point number."}, {"id": "map-F", "address_start": 15, "address_end": 15, "hex_start": "$F", "hex_end": "$F", "label": "GARBFL", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "15            $F             GARBFL\nFlag for LIST, Garbage Collection, and Program Tokenization\n\nThe LIST routine uses this byte as a flag to let it know when it has\ncome to a character string in quotes.  It will then print the string,\nrather than search it for BASIC keyword tokens.\n\nThe garbage collection routine uses this location as a flag to\nindicate that garbage collection has already been tried before adding\na new string.  If there is still not enough memory, an OUT OF MEMORY\nmessage will result.\n\nThis location is also used as a work byte for the process of\nconverting a line of text in the BASIC input buffer (512, $200) into a\nlinked program line of BASIC keyword tokens."}, {"id": "map-10", "address_start": 16, "address_end": 16, "hex_start": "$10", "hex_end": "$10", "label": "SUBFLG", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "16            $10            SUBFLG\nFlag: Subscript Reference to an Array or User-Defined Function Call (FN)\n\nThis flag is used by the PTRGET routine which finds or creates a\nvariable, at the time it checks whether the name of a variable is\nvalid.  If an opening parenthesis is found, this flag is set to\nindicate that the variable in question is either an array variable or\na user-defined function.\n\nYou should note that it is perfectly legal for a user-defined function\n(FN) to have the same name as a floating point variable.  Moreover, it\nis also legal to redefine a function.  Using a FN name in an already\ndefined function results in the new definition of the function."}, {"id": "map-11", "address_start": 17, "address_end": 17, "hex_start": "$11", "hex_end": "$11", "label": "INPFLG", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "17            $11            INPFLG\nFlag: Is Data Input to GET, READ or INPUT?\n\nSince the keywords GET, INPUT, and READ perform similar functions,\nBASIC executes some of the same instructions for all three.  There are\nalso many areas of difference, however, and this flag indicates which\nof the three keywords is currently being executed, so that BASIC will\nknow whether or not to execute the instructions which relate to the\nareas in which the commands differ (152 ($98)=READ, 64 ($40)=GET,\n0=INPUT).\n\nAs a result, INPUT will show the ? prompt, will echo characters back\nto the screen, and will wait for a whole line of text ended by a\ncarriage return.  GET gives no prompt and accepts one character\nwithout waiting.  The colon character and the comma are valid data for\nGET, but are treated as delimiters between data by INPUT and READ.\n\nAs each command has its own error messages, this flag is used to\ndetermine the appropriate message to issue in case of an error."}, {"id": "map-12", "address_start": 18, "address_end": 18, "hex_start": "$12", "hex_end": "$12", "label": "TANSGN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "18            $12            TANSGN\nFlag: Sign of the Result of the TAN or SIN Function\n\nThis location is used to determine whether the sign of the value\nreturned by the functions SIN or TAN is positive or negative.\n\nAdditionally, the string and numeric comparison routines use this\nlocation to indicate the outcome of the comparison.  For a comparison\nof variable A to variable B, the value here will be 1 if A is greater\nthan B, 2 if A equals B, and 4 if a is less than B.  If more than one\ncomparison operator was used to compare the two variables (e.g., >= or\n<=), the value here will be a combination of the above values."}, {"id": "map-13", "address_start": 19, "address_end": 19, "hex_start": "$13", "hex_end": "$13", "label": "CHANNL", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "19            $13            CHANNL\nCurrent I/O Channel (CMD Logical File) Number\n\nWhenever BASIC inputs or outputs data, it looks here to determine\nwhich I/O device is currently active for the purpose of prompting or\noutput control.  It uses location 184 ($B8) for purposes of deciding\nwhat device actually to put input from or output to.\n\nWhen the default input device (number 0, the keyboard) or output\ndevice (number 3, the display screen) is used, the value here will be\na zero, and the format of prompting and output will be the standard\nscreen output format.\n\nWhen another device is used, the logical file number (CMD channel\nnumber) will be placed here.  This lets the system now that it may\nhave to make some subtle changes in the way it performs the I/O\noperation.  For example, if TAB is used with the PRINT command, cursor\nright characters are used if the device PRINTed to is the screen.\nOtherwise, spaces are output when the number here is other than zero\n(the assumption being that you can't tab a printer like you can the\nscreen).\n\nLikewise, the ? prompt for INPUT is suppressed if the file number here\nis nonzero, as is the EXTRA IGNORED message, and input of a carriage\nreturn by itself is ignored, rather than being treated as a null\nstring (\"\").  Therefore, by OPENing the screen as a device, and\nissuing the CMD statement, you can force the suppression of the ?\nprompt, and the other effects above.\n\nCMD places the new output file number here, and calls the Kernal to\nopen the device for output, leaving it LISTENing for output (such as\nthe READY prompt, which is diverted to the new device).\n\nMany routines reset this location and UNLISTEN the device, defeating\nthe CMD and once again sending the output to the screen.  If an error\nmessage has to be displayed, for example, this location will be reset\nand the message will be displayed on the screen.  GET, GET#, INPUT,\nINPUT#, and PRINT# all will reset this location after the I/O is\ncompleted, effectively redirecting output back to the screen.  PRINT\nand LIST are the only I/O operations that will not undo the CMD.\n\nThis location can also be used to fool BASIC into thinking that data\nit is reading from the tape is actually being entered into the\nkeyboard in immediate mode.\n\nFor a look at a technique that uses a different approach to accomplish\nthe same thing for disk or tape users, see location 512 ($200), the\nkeyboard buffer."}, {"id": "map-14-15", "address_start": 20, "address_end": 21, "hex_start": "$14", "hex_end": "$15", "label": "LINNUM", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "20-21         $14-$15        LINNUM\nInteger Line Number Value\n\nThe target line number for GOTO, LIST, ON, and GOSUB is stored here in\nlow- byte, high-byte integer format, as is the number of a BASIC line\nthat is to be added or replaced.\n\nLIST saves the highest line number to list (or 65535 ($FFFF) if\nprogram is to be listed to the end) at this location.\n\nGOTO tests the target line number to see if it is greater than the\nline number currently being executed.  If it is greater, GOTO starts\nits search for the target line at the current line number.  If it is\nnot greater, GOTO must search for the target line from the first line\nof the program.  It is interesting to note that the test is of the\nmost significant byte only.  Therefore, INT(TARGETLINE/256) must be\ngreater than INT(CURRENTLINE/256) in order for the search to start\nwith the current line, instead of at the beginning of the program.\n\nPEEK, POKE, WAIT, and SYS use this location as a pointer to the\naddress which is the subject of the command."}, {"id": "map-16", "address_start": 22, "address_end": 22, "hex_start": "$16", "hex_end": "$16", "label": "TEMPPT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "22            $16            TEMPPT\nPointer to the Next Available Space in the Temporary String Stack\n\nThis location points to the next available slot in the temporary\nstring descriptor stack located at 25-33 ($19-$21).  Since that stack\nhas room for three descriptors of three bytes each, this location will\npoint to 25 ($19) if the stack is empty, to 28 ($1C) if there is one\nentry, to 31 ($1F) if there are two entries, and to 34 ($22) if the\nstack is full.\n\nIf BASIC needs to add an entry to the temporary string descriptor\nstack, and this location holds a 34, indicating that the stack is\nfull, the FORMULA TOO COMPLEX error message is issued.  Otherwise, the\nentry is added, and three is added to this pointer."}, {"id": "map-17-18", "address_start": 23, "address_end": 24, "hex_start": "$17", "hex_end": "$18", "label": "LASTPT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "23-24         $17-$18        LASTPT\nPointer to the Address of the Last String in the Temporary String\nStack\n\nThis pointer indicates the last slot used in the temporary string\ndescriptor stack.  Therefore, the value stored at 23 ($17) should be 3\nless than that stored at 22 ($16), while 24 ($18) will contain a 0."}, {"id": "map-19-21", "address_start": 25, "address_end": 33, "hex_start": "$19", "hex_end": "$21", "label": "TEMPST", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "25-33         $19-$21        TEMPST\nDescriptor Stack for Temporary Strings\n\nThe temporary string descriptor stack contains information about\ntemporary strings which hve not yet been assigned to a string\nvariable.  An examples of such a temporary string is the literal\nstring \"HELLO\" in the statement PRINT \"HELLO\".\n\nEach three-byte descriptor in this stack contains the length of the\nstring, and its starting and ending locations, expresses as\ndisplacements within the BASIC storage area."}, {"id": "map-22-25", "address_start": 34, "address_end": 37, "hex_start": "$22", "hex_end": "$25", "label": "INDEX", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "34-37         $22-$25        INDEX\nMiscellaneous Temporary Pointers and Save Area\n\nThis area is used by many BASIC routines to hold temporary pointers\nand calculation results."}, {"id": "map-26-2A", "address_start": 38, "address_end": 42, "hex_start": "$26", "hex_end": "$2A", "label": "RESHO", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "38-42         $26-$2A        RESHO\nFloating Point Multiplication Work Area\n\nThis location is used by BASIC multiplication and division routines.\nIt is also used by the routines which compute the size of the area\nrequired to store an array which is being created."}, {"id": "map-2B-2C", "address_start": 43, "address_end": 44, "hex_start": "$2B", "hex_end": "$2C", "label": "TXTTAB", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "43-44         $2B-$2C        TXTTAB\nPointer to the Start of BASIC Program Text\n\nThis two-byte pointer lets BASIC know where program text is stored.\nOrdinarily, such text is located beginning at 2049 ($801).  Using this\npointer, it is possible to change the program text area.  Typical\nreasons for doing this include:\n\n1.  Conforming the memory configuration to that of other Commodore\ncomputers.  On 32K PET and CBM computers, for example, screen memory\nstarts at 32768 ($8000), and BASIC text begins at 1025 ($401).  You\ncan emulate this configuration with the 64 with the following short\nprogram:\n\n10 POKE 55,0:POKE 56,128: CLR: REM LOWER TOP OF MEMORY TO 32768\n20 POKE 56576,PEEK(56576) AND 253: REM ENABLE BANK 2\n30 POKE 53272,4: REM TEXT DISPLAY MEMORY NOW STARTS AT 32768\n40 POKE 648,128:REM OPERATING SYSTEM PRINTS TO SCREEN AT 32768 (128*256)\n50 POKE 44,4:POKE 1024,0: REM MOVE START OF BASIC TO 1025 (4*256+1)\n60 POKE 792,193: REM DISABLE RESTORE KEY\n70 PRINT CHR$(147);\"NOW CONFIGURED LIKE PET\":NEW\n80 REM ALSO SEE ENTRIES FOR LOCATION 55, 56576, AND 648\n\nSuch reconfiguring can be helpful in transferring programs from the 64\nto the PET, or vice versa.  Since the 64 automatically relocates BASIC\nprogram text, it can load and list PET programs even though the\nprogram file indicates a loading addresss that is different from the\n64 start of BASIC.  The PET does not have this automatic relocation\nfeature, however, and it loads all BASIC programs at the two-byte\naddress indicated at the beginning of the disk or tape file.\n\nSo if the PET loads a 64 program at its normal starting address of\n2049 ($801), it will not recognize its presence because it expects a\nBASIC program to start at 1025 ($401).  Therefore, if you want to let\na PET and 64 share a program, you must either reconfigure the 64 to\nstart BASIC where the PET does, or reconfigure the PET to start BASIC\nwhere the 64 does (with a POKE 41,8:POKE 2048,0).\n\n2.  Raising the lowest location used for BASIC text in order to create\na safe area in low memory.  For example, if you wish to use the\nhigh-resolution graphics mode, you may want to put the start of screen\nmemory at 8192 ($2000).  The high-resolution moe requires 8K of\nmemory, and you cannot use the lowest 8K for this purpose because it\nis already being used for the zero-page assignments.\n\nSince BASIC program text normally starts at 2048 ($801), this means\nthat you only have 6k for program text before your program runs over\ninto screen memory.  One way around this is by moving the start of\nbasic to 16385 ($4001) by typing in direct entry mode:\n\nPOKE 44,64: POKE 64*256,0:NEW\n\nOther uses might include setting aside a storage area for sprite shape\ndata, or user-defined character sets.\n\n3.  Keeping two or more programs in memory simultaneously.  By\nchanging this pointer, you can keep more than one BASIC program in\nmemory at one time, and switch back and forth betwenn them.  Examples\nof this application can be found in COMPUTE!'s First Book of PET/CBM,\npages 66 and 163.\n\nThis technique has a number of offshoots that are perhaps of more\npractical use.\n\na) You can store two programs in memory simultaneously for the purpose\nof appending one to the other.  This technique requires that the line\nnumbers of the two programs do not overlap.  (See Programming the\nPET/CBM by Raeto Collin West, pages 41-42, for a discussion of this\ntechnique).\n\nb) You can have two programs in memory at once and use the concept in\n(2) above to allow an easier way to create a safe area in low memory.\nThe first program is just onw line that sets the start of BASIC\npointer to the address of the second program which is located higher\nin memory, and then runs that second program.\n\n4. Since this address is used as the address of the first byte to\nSAVE, you can save any section of memory by changing this pointer to\nindicate the starting address, and the pointer 45-46 ($2D-$2D) to\nindicate the address of the byte after the last byte that you wish to\nsave."}, {"id": "map-2D-2E", "address_start": 45, "address_end": 46, "hex_start": "$2D", "hex_end": "$2E", "label": "VARTAB", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "45-46         $2D-$2E        VARTAB\nPointer to the Start of the BASIC Variable Storage Area\n\nThis location points to the address which marks the end of the BASIC\nprogram text area, and the beginning of the variable storage area.\nAll nonarray variables are stored here, as are string descriptors (for\nthe address of the area where the actual text of strings is stored,\nsee location 51 ($33)).\n\nSeven bytes of memory are allocated for each variable.  The first two\nbytes are used for the variable name, which consists of the ASCII\nvalue of the first two letters of the variable name.  If the variable\nname is a single letter, the second byte will contain a zero.\n\nThe seventh bit of one or both of these bytes can be set (which would\nadd 128 to the ASCII value of the letter).  This indicates the\nvariable type.  If neither byte has the seventh bit set, the variable\nis the regular floating point type.  If only the first byte has its\nseventh bit set, the variable is a string.  If only the second byte\nhas its seventh bit set, the variable is a defined function (FN).  If\nboth bytes have the seventh bit set, the variable is an integer.\n\nThe use of the other five bytes depends on the type of variable.  A\nfloating point variable will use the five bytes to store the value of\nthe variable in floating point format.  An integer will have its value\nstored in the third and fourth bytes, high byte first, and the other\nthree will be unused.\n\nA string variable will use the third byte for its length, and the\nfourth and fifth bytes for a pointer to the address of the string\ntext, leaving the last two bytes unused.  Note that the acrual string\ntext that is pointed to is located either in the part of the BASIC\nprogram where the string is first assigned a value, or in the string\ntext storage area pointed to by location 51 ($33).\n\nA function definition will use the third and fourth bytes for a\npointer to the address in the BASIC program text where the function\ndefinition starts.  It uses the fifth and sixth bytes for a pointer to\nthe dependent variable (the X of FN A(X)).  The final byte is not\nused.\n\nKnowing something about how variables are created can help your BASIC\nprogramming.  For example, you can see that nonarray integer variables\ntake up no less space than floating point variables, and since most\nBASIC commands convert the integers to floating point, they do not\noffer a speed advantage either, and in many cases will actually slow\nthe program down.  As will be seen below, however, integer arrays can\nsave a considerable amount of space.\n\nVariables are stored in the order in which they are created.\nLikewise, when BASIC goes looking for a variable, it starts its search\nat the beginning of this area.  If commonly used variables are defined\nat the end of the program, and are thus at the back of this area, it\nwill take longer to find them.  It may help program execution speed to\ndefine the variables that will be used most frequently right at the\nbeginning of the program.\n\nAlso, remember that once created, variables do not go away during\nprogram execution.  Even if they are never used again, they still take\nup space in the variable storage area, and they slow down the routine\nthat is used to search for variables that are referenced.\n\nAnother point to consider about the order in which to define variables\nis that arrays are created in a separate area of memory which starts\nat the end of the nonarray variable area.  Therefore, every time a\nnonarray variable is created, all of the arrays must be moved seven\nbytes higher in memory in order to make room for the new variable.\nTherefore, it may help performance to avoid defining nonarray\nvariables after defining arrays.\n\nThis pointer will be reset to one byte past the end of the BASIC\nprogram text whenever you execute the statements CLR, NEW, RUN, or\nLOAD.  Adding or modifying a BASIC statement will have the same\neffect, because the higher numbered BASIC statements have to be moved\nup into memory to make room for the new statements, and can therefore\noverwrite the variable storage area.  This means that if you wish to\ncheck the value of a variable after stopping a program, you can only\ndo so before modifying the program.\n\nThe exception to the above is when the LOAD command is issued from a\nprogram.  The purpose of not resetting this pointer in such a case is\nto allow the chaining of programs by having one program load and then\nrun the next (that is also why a LOAD issued from a program causes a\nRUN from the beginning of the program).  This allows the second\nprogram to share variables with the first.  There are problems with\nthis, however.  Some string variable descriptors and function\ndefinitions have their pointers set to areas within the program text.\nWhen this text is replaced by a load, these pointers are no longer\nvalid, which will lead to errors if the FN or string value is\nreferenced.  And if the second program text area is larger than that\nof the first, the second program will overwrite some of the first\nprogram's variables, and their values will be lost.\n\nThe ability to chain short programs is a holdover from the days of the\n8K PET, for which this BASIC was written, but with the vastly\nincreased memory of the 64, program chaining should not be necessary.\n\nYou should also note that SAVE uses this pointer as the address of the\nbyte after the last byte to SAVE."}, {"id": "map-2F-30", "address_start": 47, "address_end": 48, "hex_start": "$2F", "hex_end": "$30", "label": "ARYTAB", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "47-48          $2F-$30       ARYTAB\nPointer to the Start of the BASIC Array Storage Area\n\nThis location points to the address of the end of nonarray variable\nstorage, and the beginning of array variable storage.  The format for\narray storage is as follows:\n\nThe first two bytes hold the array name.  The format and high-bit\npatterns are the same as for nonarray variables (see 45 ($2D) above),\nexcept that there is no equivalent to the function definition.\n\nNext comes a two-byte offset to the start of the next array, low byte\nfirst.  Then there is a one-byte value for the number of array\ndimensions (e.g., 2 for a two-dimensional array like A(x,y)).  That\nbyte is followed by pairs of bytes which hold the value of each array\ndimension+1 (DIMensioning an array always makes space for 0, so A(0)\ncan be used).\n\nFinally come the values of the variables themselves.  The format for\nthese values is the same as with nonarray values, but each value only\ntakes up the space required; that is, floating point variables use\nfive bytes each, integers two bytes, and string descriptors three\nbytes each.\n\nRemember that as with nonarray string, the actual string text is\nstored elsewhere, in the area which starts at the location pointed to\nin 51-52 ($33- $34)."}, {"id": "map-31-32", "address_start": 49, "address_end": 50, "hex_start": "$31", "hex_end": "$32", "label": "STREND", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "49-50         $31-$32        STREND\nPointer to End of the BASIC Array Storage Area (+1), and the Start of\nFree RAM\n\nThis location points to the address of the end of BASIC array storage\nspace and the start of free RAM.  Since string text starts at the top\nof memory and builds downwards, this location can also be thought of\nas the last possible address of the string storage area.  Defining new\nvariables pushes this pointer upward, toward the last string text.\n\nIf a string for which space is being allocated would cross over this\nboundary into the array storage area, garbage collection is performed,\nand if there still is not enough room, an OUT OF MEMORY error occurs.\nFRE performs garbage collection, and returns the difference between\nthe addresses pointed to here and the address of the end of string\ntext storage pointed to by location 51 ($33)."}, {"id": "map-33-34", "address_start": 51, "address_end": 52, "hex_start": "$33", "hex_end": "$34", "label": "FREETOP", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "51-52         $33-$34        FREETOP\nPointer to the Bottom of the String Text Storage Area\n\nThis pointer marks the current end of the string text area, and the\ntop of free RAM (strings are built from the top of memory downward).\nAdditional string texts are added, to the area below the address\npointed to here.  After they are added, this pointer is lowered to\npoint below the newly added string text.  The garbage collection\nroutine (which is also called by FRE) readjusts this pointer upward.\n\nWhile the power-on/reset routines set this pointer to the top of RAM,\nthe CLR command sets this pointer to the end of BASIC memory, as\nindicated in location 55 ($37).  This allows the user to set aside an\narea of BASIC memory that will not be disturbed by the program, as\ndetailed at location 55 ($37)."}, {"id": "map-35-36", "address_start": 53, "address_end": 54, "hex_start": "$35", "hex_end": "$36", "label": "FRESPC", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "53-54         $35-$36        FRESPC\nTemporary Pointer for Strings\n\nThis is used as a temporary pointer to the most current string added\nby the routines which build strings or move them in memory."}, {"id": "map-37-38", "address_start": 55, "address_end": 56, "hex_start": "$37", "hex_end": "$38", "label": "MEMSIZ", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "55-56         $37-$38        MEMSIZ\nPointer to the Highest Address Used by BASIC\n\nThe power-on/reset routine tests each byte of RAM until it comes to\nthe BASIC ROM, and sets this pointer to the adress of the highest byte\nof consecutive RAM found (40959, $9FFF).\n\nThere are two circumstances under which this pointer may be changed\nafter power-up to reflect an address lower than the actual top of\nconsecutive RAM:\n\n1.  Users may wish to lower this pointer themselves, in order to set\naside an area of free RAM that will not be disturbed by BASIC.  For\nexample, to set aside a 1K area at the top of BASIC, start your\nprogram with the line:\n\nPOKE 56,PEEK(56)-4:CLR\n\nThe CLR is necessary to insure that the string text will start below\nyour safe area.\n\nYou may wish to store machine language programs, sprites, or alternate\ncharacter sets in such an area.  For the latter two applications,\nhowever, keep in mind the 16K addressing range limitation of the\nVIC-II chip.  If you do not assign the VIC-II to a bank other than the\ndefault memory bank of 0-16383 ($0-$3FFF), you must lower the top of\nmemory below 16383 ($3FFF) if you wish your sprite or character data\narea to be within its addressing range.\n\n2.  Then the RS-232 device (number 2) is opened, this pointer and the\npointer to the end of user RAM at 643 are lowered by 512 bytes in\norder to create two 256-byte buffers, one for input and the other for\noutput.\n\nSince the contents of these buffers will overwrite any variables at\nthe top of memory, a CLR command is issued at the time device 2 is\nopened.  Therefore, the RS-232 device should be opened before defining\nany variables, and before setting aside a safe area for machine\nlanguage programs or other uses, as described above."}, {"id": "map-39-3A", "address_start": 57, "address_end": 58, "hex_start": "$39", "hex_end": "$3A", "label": "CURLIN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "57-58         $39-$3A        CURLIN\nCurrent BASIC Line Number\n\nThis location contains the line number of the BASIC statement which is\ncurrently being executed, in LSB/MSB format.  A value of 255 ($FF) in\nlocation 58 ($3A), which translates to a line number of 65280 or above\n(well over the 63999 limit for a program line), means that BASIC is\ncurrently in immediate mode, rather than RUN mode.\n\nBASIC keywords that are illegal in direct mode check 58 ($3A) to\ndetermine whether or not this is the current mode.\n\nWhen in RUN mode, this location is updated as each new BASIC line is\nfetched for execution.  Therefore, a TRACE function could be added by\ndiverting the vector at 776 ($308), which points to the routine that\nexecutes the next token, to a user-written routine which prints the\nline number indicated by this location before jumping to the token\nexecution routine.  (LISTing the line itself would be somewhat harder,\nbecause LIST uses many Page 0 locations that would have to be\npreserved and restored afterwards.)\n\nThis line number is used by BREAK and error messages to show where\nprogram execution stopped.  The value here is copied to 59 ($3B) by\nSTOP, END, and the stop-key BREAK, and copied back by CONT."}, {"id": "map-3B-3C", "address_start": 59, "address_end": 60, "hex_start": "$3B", "hex_end": "$3C", "label": "OLDLIN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "59-60         $3B-$3C        OLDLIN\nPrevious BASIC Line Number\n\nWhen program execution ends, the last line number executed is stored\nhere, and restored to location 57 ($39) by CONT."}, {"id": "map-3D-3E", "address_start": 61, "address_end": 62, "hex_start": "$3D", "hex_end": "$3E", "label": "OLDTXT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "61-62         $3D-$3E        OLDTXT\nPointer to the Address of the Current BASIC Statement\n\nThis location contains the address (not the line number) of the text\nof the BASIC statement that is being executed.  The value of TXTPTR\n(122, $7A), the pointer tot he address of the BASIC text character\ncurrently being scanned, is stored here each time a new BASIC line\nbegins execution.\n\nEND, STOP, and the STOP-key BREAK save the value of TXTPTR here, and\nCONT restores this value to TXTPTR.  CONT will not continue if 62\n($3E) has been changed to a zero by a LOAD, a modification to the\nprogram text, or by error routines."}, {"id": "map-3F-40", "address_start": 63, "address_end": 64, "hex_start": "$3F", "hex_end": "$40", "label": "DATLIN", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "63-64         $3F-$40        DATLIN\nCurrent DATA Line Number\n\nThis location holds the line number of the current DATA statement\nbeing READ.  It should be noted that this information is not used to\ndetermine where the next DATA item is read from (that is the job of\nthe pointer at 65-66 ($41-$42) below).  But if an error concerning the\nDATA occurs, this number will be moved to 57 ($39), so that the error\nmessage will show that the error occurred in the line that contains\nthe DATA statement, rather than in the line that contains the READ\nstatement."}, {"id": "map-41-42", "address_start": 65, "address_end": 66, "hex_start": "$41", "hex_end": "$42", "label": "DATPTR", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "65-66         $41-$42        DATPTR\nPointer to the Address of the Current DATA Item\n\nThis location points to the address (not the line number) within the\nBASIC program text area where DATA is currently being READ.  RESTORE\nsets this pointer back to the address indicated by the start of BASIC\npointer at location 43 ($2B).\n\nThe sample program below shows how the order in which DATA statements\nare READ can be changed using this pointer.  The current address of\nthe statement before the DATA statement is stored in a variable, and\nthen used to change this pointer.\n\n10 A1=PEEK(61):A2=PEEK(62)\n20 DATA THIS DATA WILL BE USED SECOND\n30 B1=PEEK(61):B2=PEEK(62)\n40 DATA THIS DATA WILL BE USED FIRST\n50 C1=PEEK(61):C2=PEEK(62)\n60 DATA THIS DATA WILL BE USED THIRD\n70 POKE 65,B1:POKE 66,B2:READ A$:PRINT A$\n80 POKE 65,A1:POKE 66,A2:READ A$:PRINT A$\n90 POKE 65,C1:POKE 66,C2:READ A$:PRINT A$"}, {"id": "map-43-44", "address_start": 67, "address_end": 68, "hex_start": "$43", "hex_end": "$44", "label": "INPPTR", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "67-68         $43-$44        INPPTR\nPointer in the Source of GET, READ, or INPUT Information\n\nREAD, INPUT and GET all use this as a pointer to the address of the\nsource of incoming data, such as DATA statements, or the text input\nbuffer at 512 ($200)."}, {"id": "map-45-46", "address_start": 69, "address_end": 70, "hex_start": "$45", "hex_end": "$46", "label": "VARNAM", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "69-70         $45-$46        VARNAM\nCurrent BASIC Variable Name\n\nThe current variable name being searched for is stored here, in the\nsame two- byte format as in the variable value storage area located at\nthe address pointed to by 45 ($2D).  See that location for an\nexplanation of the format."}, {"id": "map-47-48", "address_start": 71, "address_end": 72, "hex_start": "$47", "hex_end": "$48", "label": "VARPNT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "71-72         $47-$48        VARPNT\nPointer to the Current BASIC Variable Value\n\nThis location points to the address of the descriptor of the current\nBASIC variable (see location 45 ($2D) for the format of a variable\ndescriptor).  Specifically, it points to the byte just after the\ntwo-character variable name.\n\nDuring a FN call, this location does not point to the dependent\nvariable (the A of FN A), so that a real variable of the same name\nwill not have its value changed by the call."}, {"id": "map-49-4A", "address_start": 73, "address_end": 74, "hex_start": "$49", "hex_end": "$4A", "label": "FORPNT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "73-74         $49-$4A        FORPNT\nTemporary Pointer to the Index Variable Used by FOR\n\nThe address of the BASIC variable which is the subject of a FOR/NEXT\nloop is first stored here, but is then pushed onto the stack.  That\nleaves this location free to be used as a work area by such statements\nas INPUT, GET, READ, LIST, WAIT, CLOSE, LOAD, SAVE, RETURN, and GOSUB.\n\nFor a description of the stack entries made by FOR, see location 256\n($100)."}, {"id": "map-4B-4C", "address_start": 75, "address_end": 76, "hex_start": "$4B", "hex_end": "$4C", "label": "OPPTR", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "75-76         $4B-$4C        OPPTR\nMath Operator Table Displacement\n\nThis location is used during the evaluation of mathematical\nexpressions to hold the displacement of the current math operator in\nan operator table.  It is also used as a save area for the pointer to\nthe address of program text which is currently being read."}, {"id": "map-4D", "address_start": 77, "address_end": 77, "hex_start": "$4D", "hex_end": "$4D", "label": "OPMASK", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "77            $4D            OPMASK\nMask for Comparison Operation\n\nThe expression evaluation routine creates a mask here which lets it\nknow whether the current comparieson operation is a less-than (1),\nequals (2), or greater-than (4) comparison."}, {"id": "map-4E-4F", "address_start": 78, "address_end": 79, "hex_start": "$4E", "hex_end": "$4F", "label": "DEFPNT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "78-79         $4E-$4F        DEFPNT\nPointer to the Current FN Descriptor\n\nDuring function definition (DEF FN) this location is used as a pointer\nto the descriptor that is created.  During function execution (FN) it\npoints to the FN descriptor in which the evaluation results should be\nsaved."}, {"id": "map-50-52", "address_start": 80, "address_end": 82, "hex_start": "$50", "hex_end": "$52", "label": "DSCPNT", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "80-82         $50-$52        DSCPNT\nTemporary Pointer to the Current String Descriptor\n\nThe string assignment and handling routines use the first two bytes as\na temporary pointer to the current string descriptor, and the third to\nhold the value of the string length."}, {"id": "map-53", "address_start": 83, "address_end": 83, "hex_start": "$53", "hex_end": "$53", "label": "FOUR6", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "83            $53            FOUR6\nConstant for Garbage Collection\n\nThe constant contained here lets the garbage collection routines know\nwhether a three- or seven-byte string descriptor is being collected."}, {"id": "map-54-56", "address_start": 84, "address_end": 86, "hex_start": "$54", "hex_end": "$56", "label": "JMPER", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "84-86         $54-$56        JMPER\nJump to Function Instruction\n\nThe first byte is the 6502 JMP instruction ($4C), followed by the\naddress of the required function taken from the table at 41042\n($A052)."}, {"id": "map-57-60", "address_start": 87, "address_end": 96, "hex_start": "$57", "hex_end": "$60", "label": "", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "87-96         $57-$60\nBASIC Numeric Work Area\n\nThis is a very busy work area, used by many routines."}, {"id": "map-61-66", "address_start": 97, "address_end": 102, "hex_start": "$61", "hex_end": "$66", "label": "FAC1", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "97-102        $61-$66        FAC1\nFloating Point Accumulator #1\n\nThe Floating Point Accumulator is central to the execution of any\nBASIC mathematical operation.  It is used in the conversion of\nintegers to floating point numbers, strings to floating point numbers,\nand vice versa.  The results of most evaluations are stored in this\nlocation.\n\nThe internal format of floating point numbers is not particularly easy\nto understand (or explain).  Generally speaking, the number is broken\ninto the normalized mantissa, which represents a number between 1 and\n1.99999..., and an exponent value, which represents a power of 2.\nMultiplying the mantissa by 2 raised to the value of the exponent\ngives you the value of the floating point number.\n\nFortunately, the BASIC interpreter contains many routines for the\nmanipulation and conversion of floating point number, and these\nroutines can be called by the user.  See the entries for locations 3\nand 5\n\nFloating Point Accumulator #1 can be further divided into the\nfollowing locations:"}, {"id": "map-61", "address_start": 97, "address_end": 97, "hex_start": "$61", "hex_end": "$61", "label": "FACEXP", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "97            $61            FACEXP\nFloating Point Accumulator #1: Exponent\n\nThis exponent represents the closest power of two to the number, with\n129 added to take care of the sign problem for negative exponents.  An\nexponent of 128 is used for the value 0; an exponent of 129 represents\n2 to the 0 power, or 1; an exponent of 130 represents 2 to the first\npower, or 2; 131 is 2 squared, or 4; 132 is 2 cubed, or 8; and so on."}, {"id": "map-62-65", "address_start": 98, "address_end": 101, "hex_start": "$62", "hex_end": "$65", "label": "FACHO", "source": "mapping-c64.txt", "chapter": "::Chapter 1::", "type": "location", "text": "98-101        $62-$65        FACHO\nFloating Point Accumulator #1: Mantissa\n\nThe most significant digit can be assumed to be a 1 (remember that the\nrange of the mantissa is from 1 to 1.99999...) when a floating point\nnumber is stored to a variable.  The first bit is used for the sign of\nthe number, and the other 31 bits of the four-byte mantissa hold the\nother significant digits.\n\nThe first two bytes (98-99, $62-$63) of this location will hold the\nsigned integer result of a floating point to integer conversion, in\nhigh-byte, low- byte order."}]